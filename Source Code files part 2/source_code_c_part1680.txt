   sizeof u, NULL, &bInvalid);

        if  (bInvalid)
            continue;   //  Character wasn't any good...

        _ASSERTE((unsigned) icTo <= cpi.MaxCharSize);

        //  OK, we mapped one- but, before we go on, make sure it also works
        //  in the other direction, since the U2M does some jiggering

        unsigned u3 = 0;

        MultiByteToWideChar(dwidMap, 0, (PSTR) &uTo, 2, (PWSTR) &u3, 2);

        if  (u3 != u)
            continue;   //  Not a one-for one? Not interested...

        cwaMap.Add(uTo);
        cwaMap.Add(u);
    }

    //  OK, we've got the down and dirty details- now, generate the file...

    try {
        CString csName;
        csName.Format(_TEXT("WPS%u.CTT"), dwidMap);

        CFile   cfOut(csName, 
            CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

        //  Write the tranlated pairs

        cfOut.Write(cwaMap.GetData(), cwaMap.GetSize() * sizeof(WORD));
    }

    catch(CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::GenerateAllMaps

  This member will generate an MBCS -> Unicode one-to-one mapping table for all
  installed code pages in the user's system for which we do not now have maps.

******************************************************************************/

BOOL    CCodePageInformation::GenerateAllMaps() const {

    BOOL    bReturn = TRUE;

    for (unsigned u = InstalledCount(); u--; )
        if  (!HaveMap(Installed(u)) && !GenerateMap(Installed(u)))
            bReturn = FALSE;

    return  bReturn;
}

/******************************************************************************

  CCodePageInformation::HaveMap

  Reports that the map is one of our resources (or isn't, as the case may be).

******************************************************************************/

BOOL    CCodePageInformation::HaveMap(DWORD dwidMap) const {    
    return  (dwidMap < 65536) ? !!FindResource(hi, 
        MAKEINTRESOURCE((WORD) dwidMap), MAKEINTRESOURCE(MAPPING_TABLE)) : 
        FALSE;  
}

/******************************************************************************

  CCodePageInformation::IsDBCS(DWORD dwidPage)

  This is actually pretty simple- if the translation table is smaller than 1024
  bytes (256 encodings), it isn't DBCS.

******************************************************************************/

BOOL    CCodePageInformation::IsDBCS(DWORD dwidPage) {
    if  (!Load(dwidPage))
        return  FALSE;  //  May be optimistic, but we'll find out...

    return  m_cbaMap.GetSize() > 1024;
}

/******************************************************************************

  CCodePageInformation::IsDBCS(DWORD dwidPage, WORD wCodePoint)

  If the page isn't DBCS, we're done.  Otherwise, make sure the Unicode->MBCS
  map is loaded, and get the answer from there.

******************************************************************************/

BOOL    CCodePageInformation::IsDBCS(DWORD dwidPage, WORD wCodePoint) {
    if  (!IsDBCS(dwidPage))
        return  FALSE;

    if  (!Map(TRUE))
        return  FALSE;  //  Just say no, because the error's already been told

    //  0xFFFF is invalid, hence SBCS (default always must be)

    _ASSERTE(m_cwaOut[wCodePoint] != 0xFFFF);

    return ((WORD) (1 + m_cwaOut[wCodePoint])) > 0x100;
}

/******************************************************************************

  CCodePageInformation::Convert

  This is one of the workhorses- it loads the given code page, and maps the 
  given character strings one way or the other, depending upon which is empty.

******************************************************************************/

unsigned    CCodePageInformation::Convert(CByteArray& cbaMBCS, 
                                          CWordArray& cwaWC, 
                                          DWORD dwidPage){

    if  (!cbaMBCS.GetSize() == !cwaWC.GetSize())    //  Must be clear which way
        return  0;

    if  (!Load(dwidPage) || !Map(cwaWC.GetSize()))
        return  0;

    CWordArray& cwaMap = cwaWC.GetSize() ? m_cwaOut : m_cwaIn;
    try {
        if  (cbaMBCS.GetSize()) {
            cwaWC.RemoveAll();
            for   (int i = 0; i < cbaMBCS.GetSize();) {
                WORD    wcThis = cbaMBCS[i];

                if  (cwaMap[wcThis] == 0xFFFF) {    //  No SBCS mapping
                    wcThis += cbaMBCS[i + 1] << 8;
                    if  (cwaMap[wcThis] == 0xFFFF) {    //  No DBCS, either?
                        _ASSERTE(FALSE);
                        return  0;  //  We have failed to convert!
                    }
                }
                cwaWC.Add(cwaMap[wcThis]);
                i += 1 + (wcThis > 0xFF);
            }
        }
        else {
            cbaMBCS.RemoveAll();
            for (int i = 0; i < cwaWC.GetSize(); i++) {
                if  (cwaMap[cwaWC[i]] == 0xFFFF) {
                    _ASSERTE(0);
                    return  0;
                }
                cbaMBCS.Add((BYTE) cwaMap[cwaWC[i]]);
                if  (0xFF < cwaMap[cwaWC[i]])
                    cbaMBCS.Add((BYTE)(cwaMap[cwaWC[i]] >> 8));
            }
        }
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  0;
    }

    return  cwaWC.GetSize();    //  Correct conversion count either way!
}

/******************************************************************************

  CCodePageInformation::Collect

  This member fills a passed CWordArray with either the domain or range of the
  mapping function.  In either case, the array is in ascending order.

******************************************************************************/

BOOL    CCodePageInformation::Collect(DWORD dwidPage, CWordArray& cwaCollect, 
                                      BOOL bUnicode) {

    if  (!Load(dwidPage) || !Map(bUnicode))
        return  FALSE;

    CWordArray& cwaMap = bUnicode ? m_cwaOut : m_cwaIn;
    cwaCollect.RemoveAll();

    //  Code points < 0x20 always map, but aren't usable, so screen them out

    try {
        for (unsigned u = 0x20; u < (unsigned) cwaMap.GetSize(); u++)
            if  (~(int)(short)cwaMap[u])    //  0xFFFF means not mapped!
                cwaCollect.Add(u);
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\fontedit.cpp ===
/******************************************************************************

  Source File:  Font Knowledge Base.CPP

  This handles the DLL initialization and termination code needed for the DLL
  to work as an AFX Extension DLL.  It was created by App Wizard, and probably
  will see little modification.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  03-07-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    <AfxDllx.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE FontKnowledgeBaseDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) 	{
		TRACE0("Font Knowledge Base.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(FontKnowledgeBaseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(FontKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Font Knowledge Base.DLL Terminating!\n");
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\codepage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CodePage.rc
//
#define MAPPING_TABLE                   2622

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\fontinfo.cpp ===
/******************************************************************************

  Source File:  Generic Font Information.CPP

  This implements the CFontInfo and all related classes, which describe printer
  fonts in all the detail necessary to satisfy all these different operating
  systems.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Began work on this monster

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "Glyph Translation.H"
#include    "Generic Font Information.H"
#include    <Code Page Knowledge Base.H>
#else
#include    "GTT.H"
#include    "FontInfo.H"
#include    "CodePage.H"
#endif
#include    "..\Resource.H"

//  These are used to glue in UFM-specific stuff

struct INVOCATION {
    DWORD   dwcbCommand;    //  Byte size of string
    DWORD   dwofCommand;    //  Offset in the file to the string
};

//  `Yes, this is a bit sleazy, but DirectDraw has nothing now or ever to
//  do with this tool, so why waste time tracking down more files?

#define __DD_INCLUDED__
typedef DWORD   PDD_DIRECTDRAW_GLOBAL, PDD_SURFACE_LOCAL, DESIGNVECTOR,
                DD_CALLBACKS, DD_HALINFO,
                DD_SURFACECALLBACKS, DD_PALETTECALLBACKS, VIDEOMEMORY;
#include    "winddi.h"
#include    "fmnewfm.h"
#include    <math.h>

//  A handy constant for converting radians to 10's of a degree

static const double dConvert = 900.0 / atan2(1.0, 0.0);

//  Use a static CCodePageInformation to derive more benefit from caching

static CCodePageInformation ccpi;

/******************************************************************************

  CKern

  This class encapsulates the kerning pair structure.  It's pretty trivial.
  The CFontInfo class maintains an array of these.

******************************************************************************/

class CKern : public CObject {
    FD_KERNINGPAIR  m_fdkp;
public:
    CKern() { m_fdkp.wcFirst = m_fdkp.wcSecond = m_fdkp.fwdKern = 0; }
    CKern(FD_KERNINGPAIR& fdkp) { m_fdkp = fdkp; }

    WCHAR   First() const { return m_fdkp.wcFirst; }
    WCHAR   Second() const { return m_fdkp.wcSecond; }
    short   Amount() const { return m_fdkp.fwdKern; }

    void    SetAmount(short sNew) { m_fdkp.fwdKern = sNew; }
    void    Store(CFile& cf) { cf.Write(&m_fdkp, sizeof m_fdkp); }
};

/******************************************************************************

  CFontDifference class

  This class handles the requisite information content for the Font Difference
  structure involved with Font Simulation.

******************************************************************************/

/******************************************************************************

  CFontDifference::CFontDifference(PBYTE pb)

  This constructor initializes the fields from a FONTDIFF structure in memory.

******************************************************************************/

CFontDifference::CFontDifference(PBYTE pb, CBasicNode *pcbn) {
    FONTDIFF    *pfd = (FONTDIFF *) pb;
    m_pcbnOwner = pcbn;

    m_cwaMetrics.Add(pfd -> usWinWeight);
    m_cwaMetrics.Add(pfd -> fwdMaxCharInc);
    m_cwaMetrics.Add(pfd -> fwdAveCharWidth);
    m_cwaMetrics.Add((WORD) (dConvert *
        atan2((double) pfd -> ptlCaret.x, (double) pfd -> ptlCaret.y)));
}

/******************************************************************************

  CFontDifference::SetMetric

  This function will modify one of the four metrics, if it is new, and it meets
  our criteria (Max >= Average, 0 <= Angle < 900, Weight <= 1000).  Errors are
  reported via a public enum return code.

******************************************************************************/

WORD    CFontDifference::SetMetric(unsigned u, WORD wNew) {
    if  (wNew == m_cwaMetrics[u])
        return  OK;
    switch  (u) {
    case    Max:
        if  (wNew < m_cwaMetrics[Average])
            return  Reversed;
        break;

    case    Average:
        if  (wNew > m_cwaMetrics[Max])
            return  Reversed;
        break;

    case    Weight:
        if  (wNew > 1000)
            return  TooBig;
        break;

    default:    //  Angle
        if  (wNew > 899)
            return  TooBig;
    }
    m_cwaMetrics[u] = wNew;
    m_pcbnOwner -> Changed();
    return  OK;
}

/******************************************************************************

  CFontDifference::Store(CFile& cf)

  This member creates a FONTDIFF structure, fills it, and writes it to the
  given file.  The big calculation is the x and y components for the italic
  angle, if there is one.

******************************************************************************/

void    CFontDifference::Store(CFile& cf, WORD wfSelection) {
    FONTDIFF    fd = {0, 0, 0, 0, m_cwaMetrics[Weight], wfSelection, 
        m_cwaMetrics[Average], m_cwaMetrics[Max]};

    fd.bWeight = (m_cwaMetrics[Weight] >= FW_BOLD) ? PAN_WEIGHT_BOLD :
        (m_cwaMetrics[Weight] > FW_EXTRALIGHT) ? 
            PAN_WEIGHT_MEDIUM : PAN_WEIGHT_LIGHT;

    fd.ptlCaret.x = !m_cwaMetrics[Angle] ? 0 :
        (long) (10000.0 * tan(((double) m_cwaMetrics[Angle]) / dConvert));

    fd.ptlCaret.y = m_cwaMetrics[Angle] ? 10000 : 1;

    cf.Write(&fd, sizeof fd);
}

/******************************************************************************

  CFontInfo class

  This class encapsulates all of the font knowledge this application needs.

******************************************************************************/

IMPLEMENT_SERIAL(CFontInfo, CProjectNode, 0)

/******************************************************************************

  CFontInfo::MapPFM

  This loads a PFM format file, if it isn't already loaded.

******************************************************************************/

BOOL    CFontInfo::MapPFM() {

    if  (m_cbaPFM.GetSize())
        return  TRUE;   //  Already has been loaded!

    try {
        CFile   cfLoad(m_csSource, CFile::modeRead | CFile::shareDenyWrite);
        m_cbaPFM.SetSize(cfLoad.GetLength());
        cfLoad.Read(m_cbaPFM.GetData(), cfLoad.GetLength());
    }

    catch   (CException   *pce) {
        pce -> ReportError();
        pce -> Delete();
        m_cbaPFM.RemoveAll();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CFontInfo::GetTranslation

  This loads a PFM format file and gets the default CTT ID from it.  Nothing
  else is done.

******************************************************************************/

extern "C"  int ICttID2GttID(long lPredefinedCTTID);

BOOL    CFontInfo::GetTranslation() {

    //  PFM file structures- these are declared at this level to keep them off 
    //  the master class list for the project.

#pragma pack(1) //  The following is byte-aligned

    struct sPFMHeader {
        WORD    m_wType, m_wPoints, m_wVertRes, m_wHorizRes, m_wAscent, 
                m_wInternalLeading, m_wExternalLeading;
        BYTE    m_bfItalic, m_bfUnderline, m_bfStrikeOut;
        WORD    m_wWeight;
        BYTE    m_bCharSet;
        WORD    m_wPixWidth, m_wPixHeight;
        BYTE    m_bfPitchAndFamily;
        WORD    m_wAvgWidth, m_wMaxWidth;
        BYTE    m_bFirstChar, m_bLastChar, m_bDefaultChar, m_bBreakChar;
        WORD    m_wcbWidth;
        DWORD   m_dwDevice, m_dwFace, m_dwBitsPointer, m_dwofBits;
        BYTE    m_bReserved;
    };

    struct sPFMExtension {
        WORD    m_wcbRemaining; //  From this point on
        DWORD   m_dwofExtMetrics, m_dwofExtentTable, m_dwofOriginTable, 
                m_dwofPairKernTable, m_dwofTrackKernTable, m_dwofDriverInfo, 
                m_dwReserved;
    };

#pragma pack (2)    //  Everything else has word alignment

    struct sOldKernPair {
        union {
            BYTE m_abEach[2];
            WORD m_wBoth;
        };
        short m_sAmount;
    };

    struct sKernTrack {
        short m_sDegree, m_sMinSize, m_sMinAmount, m_sMaxSize, m_sMaxAmount;
    };

    struct sPFMDriverInfo {
        enum {CurrentVersion = 0x200};
        enum {CannotItalicize = 1, CannotUnderline, SendCRAfterUsing = 4,
                CannotMakeBold = 8, CannotDoubleUnderline = 0x10,
                CannotStrikeThru = 0x20, BackspaceForPairs = 0x40};
        WORD    m_wcbThis, m_wVersion, m_wfCapabilities, m_widThis, m_wAdjustY, 
                m_wYMovement, m_widCTT, m_wUnderlinePosition, 
                m_wDoubleUnderlinePosition, m_wStrikeThruPosition;
        DWORD   m_dwofSelect, m_dwofDeselect;
        WORD    m_wPrivateData;   /* Used in DeskJet driver for font enumerations */
        short   m_sShiftFromCenter;
        enum {HPIntelliFont, TrueType, PPDSScalable, CapsL, OEMType1, OEMType2};
        WORD    m_wFontType;
    };

#pragma pack()  //  We now return control to you

    if  (!MapPFM())
        return  FALSE;
    //  Now, map out the rest of the pieces of the structure.

    union {
            BYTE        *pbPFM; //  Base of the file for offsets!
            sPFMHeader  *pspfmh;
    };

    pbPFM = m_cbaPFM.GetData();

    //  Screen out evil files- part 1: is length sufficient?

    unsigned    uSize = sizeof (sPFMHeader) + sizeof (sPFMExtension) +
         sizeof (sPFMDriverInfo);
    if  ((unsigned) m_cbaPFM.GetSize() < uSize)
         return FALSE;

    //  YA Sanity check

    if  (pspfmh -> m_bLastChar < pspfmh -> m_bFirstChar)
         return FALSE;

    //  Width table, if there is one.

    WORD    *pwWidth = pspfmh -> m_wPixWidth ? NULL : (PWORD) (pspfmh + 1);
    uSize += !!pwWidth * sizeof (WORD) * 
        (2 + pspfmh -> m_bLastChar - pspfmh -> m_bFirstChar);

    //  Screen out evil files- part 2: is length still sufficient?

    if  ((unsigned) m_cbaPFM.GetSize() < uSize)
         return FALSE;

    //  PFMExtension follows width table, otherwise the header

    sPFMExtension   *pspfme = pwWidth ? (sPFMExtension *) 
        (pwWidth + 2 + pspfmh -> m_bLastChar - pspfmh -> m_bFirstChar) :
        (sPFMExtension *) (pspfmh + 1);

    //  Penultimate sanity check- is the driver info offset real?

    if  ((unsigned) m_cbaPFM.GetSize() < 
         pspfme -> m_dwofDriverInfo + sizeof (sPFMDriverInfo))
        return  FALSE;

    //  Text Metrics, DriverInfo and others are pointed at by PFM
    //  Extension.

    sPFMDriverInfo  *pspfmdi = 
        (sPFMDriverInfo *) (pbPFM + pspfme -> m_dwofDriverInfo);

    //  Final sanity check- is the driver info version real?

    if  (pspfmdi -> m_wVersion > sPFMDriverInfo::CurrentVersion)
        return  FALSE;

    m_widTranslation = (WORD) ICttID2GttID((long) - (short) pspfmdi -> m_widCTT);
    Changed();

    return  TRUE;
}

/******************************************************************************

  CFontInfo::CalculateWidths()

  This member function is needed whenever a change is made to a variable pitch
  font's width table, or equally well, whenever an arbitrary table is picked up
  by a formerly fixed pitch font.  It calculates the width using the approved
  algorithm (average means average of 26 lower-case plus the space, unless they
  don't exist, in which case it is of all non-zero widths).

******************************************************************************/

void    CFontInfo::CalculateWidths() {

    //  Assume the max width is now 0, then prove otherwise.  Also collect the
    //  raw information needed to correctly calculate the average width.

    m_wMaximumIncrement = 0;

    unsigned    uPointsToAverage = 0, uOverallWidth = 0, uAverageWidth = 0,
        uZeroPoints = 0;

    for (unsigned u = 0; u < (unsigned) m_cpaGlyphs.GetSize(); u++) {
        WORD    wWidth = m_cwaWidth[u];;
        m_wMaximumIncrement = max(m_wMaximumIncrement, wWidth);

        uOverallWidth += wWidth;
        if  (!wWidth)   uZeroPoints++;
        if  (Glyph(u).CodePoint() == m_cwaSignificant[Break] ||
             (Glyph(u).CodePoint() >= (WORD) 'a' &&
             Glyph(u).CodePoint() <= (WORD) 'z')) {
            uAverageWidth += wWidth;
            uPointsToAverage++;
        }
    }

    //  If we averaged 27 points, then this is the correct width.  Otherwise,
    //  We average all of the widths.   cf the IFIMETRICS description in DDK

    m_wAverageWidth = (uPointsToAverage == 27) ? 
        (WORD) (0.5 + ((double) uAverageWidth) / 27.0) :
        (WORD) (0.5 + (((double) uOverallWidth) / (double) (u - uZeroPoints)));
}

/******************************************************************************

  CFontInfo::CFontInfo()

  This class constructor has a lot of work to do.  Not only does it have to 
  initialize 5 zillion fields, it has to build the context menu list, and a few
  other glorious items of that ilk.

******************************************************************************/

CFontInfo::CFontInfo() {
    m_pcmdt = NULL;
    m_pcgmTranslation = NULL;
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
    m_cfn.SetExtension(_T(".UFM"));

    m_bCharacterSet = m_bPitchAndFamily = 0;

    m_wMaximumIncrement = m_wfStyle = m_wWeight = m_wAverageWidth  = 
        m_wHeight = m_widTranslation = 0;

    m_bLocation = m_bTechnology = m_bfGeneral = 0;
    m_bScalable = FALSE;
    m_wXResolution =  m_wYResolution = m_wPrivateData = 0;
    m_sPreAdjustY =  m_sPostAdjustY =  m_sCenterAdjustment = 0;
    m_wMaxScale = m_wMinScale = m_wScaleDevice = 0;
    m_bfScaleOrientation = 0;

    m_cwaSpecial.InsertAt(0, 0, 1 + InternalLeading);    //  Initialize this array.

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_RenameItem);

    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_GenerateOne);
}

/******************************************************************************

  CFontInfo::CFontInfo(const CFontInfo& cfiRef, WORD widCTT)

  This class constructor duplicates an existing font, but changes the CTT ID,
  and generates a new name and file name accordingly

******************************************************************************/

CFontInfo::CFontInfo(const CFontInfo& cfiRef, WORD widCTT) {
    m_pcmdt = cfiRef.m_pcmdt;
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
    m_pcgmTranslation = NULL;
    m_cfn.SetExtension(_T(".UFM"));
    CString csWork;

    //  Copy the file name and generate new names

    csWork.Format(_T("(CTT %d)"), (long) (short) widCTT);
    m_cfn.Rename(cfiRef.m_cfn.Path() + cfiRef.Name() + csWork);
    m_csSource = cfiRef.m_csSource;
    Rename(cfiRef.Name() + csWork);

    m_bCharacterSet = m_bPitchAndFamily = 0;

    m_wMaximumIncrement = m_wfStyle = m_wWeight = m_wAverageWidth = 
        m_wHeight = 0;

    m_bLocation = m_bTechnology = m_bfGeneral = 0;
    m_bScalable = FALSE;
    m_wXResolution =  m_wYResolution = m_wPrivateData = 0;
    m_sPreAdjustY =  m_sPostAdjustY =  m_sCenterAdjustment = 0;
    m_wMaxScale = m_wMinScale = m_wScaleDevice = 0;
    m_bfScaleOrientation = 0;

    m_cwaSpecial.InsertAt(0, 0, 1 + InternalLeading);    //  Initialize this array.

    m_widTranslation = widCTT;

    //  Build the context menu control
    m_cwaMenuID.Copy(cfiRef.m_cwaMenuID);
}

CFontInfo::~CFontInfo() {
    if  (m_pcfdBold)
        delete  m_pcfdBold;

    if  (m_pcfdItalic)
        delete  m_pcfdItalic;

    if  (m_pcfdBoth)
        delete  m_pcfdBoth;
}

/******************************************************************************

  CFontInfo::GTTDescription

  This returns a CString naming the GTT associated with this font.  It will
  come from the workspace if the font is a resource, or the string table, if it
  is predefined.

******************************************************************************/

CString CFontInfo::GTTDescription() const {
    if  (m_pcgmTranslation)
        return  m_pcgmTranslation -> Name();

    CString csName;

    if  ((short) m_widTranslation <= 0)
        csName.LoadString(IDS_DefaultPage + (short) m_widTranslation);

    if  (!csName.GetLength())
        csName.Format(IDS_ResourceID, (short) m_widTranslation);

    return  csName;
}

/******************************************************************************

  CFontInfo::InterceptItalic

  This calculates where a line drawn at the italic slant angle would intercept
  a rectangle the height of the ascender, and twice the maximum width of the
  font.  It is used to help draw the image of this line in the font editor.

******************************************************************************/

void    CFontInfo::InterceptItalic(CPoint& cpt) const {
    if  (!m_cwaSpecial[ItalicAngle]) {  //  Nothing
        cpt.x = 5;
        cpt.y = 0;
        return;
    }

    //  First, assume we will hit the top- it's almost always true.

    cpt.x = 5 + (long) (0.5 + tan(((double) m_cwaSpecial[ItalicAngle]) /
        dConvert) * ((double) m_cwaSpecial[Baseline]));

    if  (cpt.x <= -5 + 2 * m_wMaximumIncrement) {
        cpt.y = 0;
        return;
    }

    //  OK, assume the opposite

    cpt.y = (long) (0.5 + tan(((double) (900 - m_cwaSpecial[ItalicAngle])) /
        dConvert) * ((double) (-10 + 2 * m_wMaximumIncrement)));
    cpt.x = -5 + 2 * m_wMaximumIncrement;
}

/******************************************************************************

  CFontInfo::CompareWidths

  This compares the character widths for two indices, and returns, Less, More,
  or Equal, as need be.  It is not const, because Glyph() is not, and I've
  already got a bazillion member functions.

******************************************************************************/

unsigned    CFontInfo::CompareWidths(unsigned u1, unsigned u2) {

    _ASSERT(IsVariableWidth() && u1 < (unsigned) m_cpaGlyphs.GetSize() &&
        u2 < (unsigned) m_cpaGlyphs.GetSize());

    return  (m_cwaWidth[u1] < m_cwaWidth[u2]) ? Less :
        (m_cwaWidth[u1] > m_cwaWidth[u2]) ? More : Equal;
}

/******************************************************************************

  CFontInfo::MapKerning

  This maps out the available code points, and the kern pairs in both 
  directions, into a CWordArray and a pair of CSafeMapWordToObs (where the
  underlying CObjects are CMapWordToDWords), respectively.  This allows the
  Add Kerning Pair dialog to screen out already defined pairs, and invalid code
  points.

******************************************************************************/

void    CFontInfo::MapKerning(CSafeMapWordToOb& csmw2o1, 
                              CSafeMapWordToOb& csmw2o2, 
                              CWordArray& cwaPoints) {

    //  If this isn't variable width, then we'll need to pull up some glyph
    //  data, temporarily.

    BOOL    bDispose = !IsVariableWidth();

    if  (bDispose)
        m_pcgmTranslation -> Collect(m_cpaGlyphs);
    for (unsigned u = 0; u < m_pcgmTranslation -> Glyphs(); u++)
        if  (!DBCSFont() || Glyph(u).CodePoint() < 0x80)
            cwaPoints.Add(Glyph(u).CodePoint());
        else
            break;

    if  (bDispose)
        m_cpaGlyphs.RemoveAll();

    for (u = 0; u < m_csoaKern.GetSize(); u++) {
        CKern&  ck = *(CKern *) m_csoaKern[u];

        union {
            CObject         *pco;
            CMapWordToDWord *pcmw2d;
        };

        //  Map first word to second

        if  (csmw2o1.Lookup(ck.First(), pco)) {
            _ASSERT(!pcmw2d -> operator[](ck.Second()));
            pcmw2d -> operator[](ck.Second()) = (DWORD) ck.Amount();
        }
        else {
            CMapWordToDWord *pcmw2d = new CMapWordToDWord;
            pcmw2d -> operator[](ck.Second()) = (DWORD) ck.Amount();
            csmw2o1[ck.First()] = pcmw2d;
        }

        //  Now the other direction

        if  (csmw2o2.Lookup(ck.Second(), pco)) {
            _ASSERT(!pcmw2d -> operator[](ck.First()));
            pcmw2d -> operator[](ck.First()) = (DWORD) ck.Amount();
        }
        else {
            CMapWordToDWord *pcmw2d = new CMapWordToDWord;
            pcmw2d -> operator[](ck.First()) = (DWORD) ck.Amount();
            csmw2o2[ck.Second()] = pcmw2d;
        }
    }
}

/******************************************************************************

  CFontInfo::CompareKernAmount

    This is an editor sort helper- it tells how two kern amounts compare by
    index.

******************************************************************************/

unsigned    CFontInfo::CompareKernAmount(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.Amount() < ck2.Amount()) ? Less : 
    (ck1.Amount() > ck2.Amount()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::CompareKernFirst

    This is an editor sort helper- it tells how two kern first characters
    compare by index.

******************************************************************************/

unsigned    CFontInfo::CompareKernFirst(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.First() < ck2.First()) ? Less : 
    (ck1.First() > ck2.First()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::CompareKernSecond

    This is an editor sort helper- it tells how two kern second characters
    compare by index.

******************************************************************************/

unsigned    CFontInfo::CompareKernSecond(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.Second() < ck2.Second()) ? Less : 
    (ck1.Second() > ck2.Second()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::SetSourceName

  This takes and stores the source file name so we can load and convert later.
  It also renames (or rather, sets the original name) the font data using the
  base file name.

******************************************************************************/

void    CFontInfo::SetSourceName(LPCTSTR lpstrNew) {

    m_csSource = lpstrNew;

    m_csName = m_csSource.Mid(m_csSource.ReverseFind(_T('\\')) + 1);

    if  (m_csName.Find(_T('.')) >= 0)
        if  (m_csName.Right(4).CompareNoCase(_T(".PFM"))) {
            m_csName.SetAt(m_csName.Find(_T('.')), _T('_'));
            CProjectNode::Rename(m_csName);
        }
        else
            CProjectNode::Rename(m_csName.Left(m_csName.Find(_T('.'))));
    else
        CProjectNode::Rename(m_csName);
}

/******************************************************************************

  CFontInfo::Generate

  This member generates the font information in one of the supported forms.  I
  determine the desired form from the file's extension.

******************************************************************************/

BOOL ConvertPFMToIFI(LPCTSTR lpstrPFM, LPCTSTR lpstrIFI, LPCTSTR lpstrUniq);

extern "C" {
    
    BOOL    BConvertPFM(LPBYTE lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT,
                        PWSTR pwstrUnique, LPCTSTR lpstrUFM, int iGTTID);
    DWORD   DwGetCodePage(LONG lPredefinedCTTId);            
}

BOOL    CFontInfo::Generate(CString csPath) {
    CString csExtension = csPath.Right(4);
    csExtension.MakeUpper();

    if  (csExtension == _T(".IFI"))
        return  ConvertPFMToIFI(m_csSource, csPath, m_csUnique);
    if  (csExtension == _T(".UFM")) {
        if  (!m_pcgmTranslation) {
            CString csWork;

            csWork.Format(IDS_BadCTTID, (LPCTSTR) m_csSource, 
                (long) (short) m_widTranslation);
            AfxMessageBox(csWork);
            return  FALSE;
        }

        //  Determine whether a GTT file or code page is to be used
        DWORD   dwCodePage = DwGetCodePage((LONG) - (short) m_widTranslation);

        //  Load the GTT file, if we need to.  This handles predefined, as well

        CByteArray  cbaMap;

        m_pcgmTranslation -> Load(cbaMap);

        if  (!cbaMap.GetSize())
            return  FALSE;
            
        //  Load the PFM file into memory (should already be there)

        if  (!MapPFM())
            return  FALSE;  //  Couldn't load PFM- impossible at this point!

        //  Convert the unique name string to Unicode

        CByteArray  cbaIn;
        CWordArray  cwaOut;

        cbaIn.SetSize(1 + m_csUnique.GetLength());
        lstrcpy((LPSTR) cbaIn.GetData(), (LPCTSTR) m_csUnique);
        ccpi.Convert(cbaIn, cwaOut, GetACP());

        //  DO IT!
        return  BConvertPFM(m_cbaPFM.GetData(), dwCodePage, cbaMap.GetData(), 
            cwaOut.GetData(), FileName(), (short) m_widTranslation);
    }
    return  TRUE;
}

/******************************************************************************

  CFontInfo::AddFamily

  This searches for the given name in the list of families, and adds it if it
  is not there.  It returns TRUE if it succeeded.

******************************************************************************/

BOOL    CFontInfo::AddFamily(LPCTSTR lpstrNew) {

    for (unsigned u = 0; u < Families(); u++)
        if  (!Family(u).CompareNoCase(lpstrNew))
            break;

    if  (u < Families())
        return  FALSE;  //  Already have it!

    try {
        m_csaFamily.Add(lpstrNew);
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    Changed();
    return  TRUE;
}

/******************************************************************************

  CFontInfo::RemoveFamily

  This function removes the given family name from the list of aliases.  This
  code is more robust than it needs to be- it'll remove duplicates, even though
  the add code won't allow them to be added.  No telling what the input data
  looks like, though, is there?

******************************************************************************/

void    CFontInfo::RemoveFamily(LPCTSTR lpstrDead) {

    for (unsigned u = 0; u < Families(); u ++)
        if  (!Family(u).CompareNoCase(lpstrDead)) {
            m_csaFamily.RemoveAt(u--);  //  Decrement so we don't miss one
            Changed();
        }
}

/*****************************************************************************

  CFontInfo::ChangePitch

  We exploit the fact that the widths are maintained in the CGlyphMap 
  (actually the CGlyphHandle) class.  All this method need do for a variable
  font flipping to fixed is to toss out the m_cpaGlyphs member's content.  To
  flip to variable, collect the handles, then check the first one's width- if
  it's non-zero, then a previous transition from variable to fixed is being
  undone, and we can recycle the old values, thus keeping any edits that may
  have been lost.  Otherwise, the trick code comes- the initial values get
  filled- what's tricky is that for a DBCS character set, only the SBCS values
  less than 0x80 can be variable.

******************************************************************************/

void    CFontInfo::ChangePitch(BOOL bFixed) {

    if  (bFixed == !IsVariableWidth())
        return; //  Nothing to change!

    if  (bFixed) {
        m_cpaGlyphs.RemoveAll();    //  CPtrArray doesn't delete anything
        m_wAverageWidth = DBCSFont() ? (1 + m_wMaximumIncrement) >> 1 : 
            m_wMaximumIncrement;
        Changed();
        return;
    }

    if  (!m_pcgmTranslation)    return; //  Can't do this with no GTT available

    m_pcgmTranslation -> Collect(m_cpaGlyphs);
    if  (!m_cwaWidth.GetSize())
        m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize());
    Changed();  //  It sure has...

    if  (!m_cpaGlyphs.GetSize() || m_cwaWidth[0]) {
        //  Update the maximum and average width if this is not DBCS
        if  (!DBCSFont())
            CalculateWidths();
        return; //  We did all that needed to be done
    }

    if  (!DBCSFont()) {

        for (int i = 0; i < m_cpaGlyphs.GetSize(); i++)
            m_cwaWidth[i] = m_wMaximumIncrement;

        return;
    }

    for (int i = 0; i < m_cpaGlyphs.GetSize() && Glyph(i).CodePoint() < 0x80;)
            m_cwaWidth[i++] = m_wAverageWidth; //  In DBCS, this is always it
}

/*****************************************************************************

  CFontInfo::SetScalability

  This is called to turn scalability on or off.  All that really needs to be
  done is to establish values for the maximum and minimum scale, the font -> 
  device units mapping members, and the lowercase ascender /descender, if this
  is the first time this information has changed.

******************************************************************************/

void    CFontInfo::SetScalability(BOOL bOn) {

    if  (IsScalable() == !!bOn)
        return; //  Nothing to change

    if  (!bOn) {
        m_bScalable = FALSE;
        Changed();
        return;
    }

    m_bScalable = TRUE;
    Changed();

    if  (m_wMaxScale && m_wMinScale && m_wMaxScale != m_wMinScale)
        return; //  We've already got data.

    m_wMaxScale = m_wMinScale = m_wScaleDevice = 
        m_wHeight - m_cwaSpecial[InternalLeading];

    //  Flaky, but set the initial max and min to +- 1 point from nominal

    m_wMaxScale += m_wYResolution / 72;
    m_wMinScale -= m_wYResolution / 72;

    //  Finally, set the lowercase ascender and descender to simple defaults

    m_cwaSpecial[Lowerd] = m_cwaSpecial[Baseline] - 
        m_cwaSpecial[InternalLeading];
    m_cwaSpecial[Lowerp] = m_wHeight - m_cwaSpecial[Baseline];
}

/*****************************************************************************

  CFontInfo::SetSpecial

  This adjusts anything that may need adjusting if a special metric is 
  altered.

******************************************************************************/

void    CFontInfo::SetSpecial(unsigned ufMetric, short sSpecial) {
    if  (m_cwaSpecial[ufMetric] == (WORD) sSpecial)
        return; //  Nothing changed
    m_cwaSpecial[ufMetric] = (WORD) sSpecial;
    switch  (ufMetric) {
    case    InternalLeading:

        //  Adjust the scaling factors if need be
        if  (m_wScaleDevice > m_wHeight - sSpecial)
            m_wScaleDevice = m_wHeight - sSpecial;
        if  (m_wMinScale > m_wHeight - sSpecial)
            m_wMinScale = m_wHeight - sSpecial;
    }

    Changed();
}

    

/*****************************************************************************

  CFontInfo::SetMaxWidth

  This is not as simple as it might seem.  If the font is variable, don't do
  it.  If it is not, then if it is DBCS, set the average width to 1/2 the new 
  maximum.  Otherwise, set it also to the maximum.

******************************************************************************/

void    CFontInfo::SetMaxWidth(WORD wWidth) {
    if  (IsVariableWidth()) return;

    if  (wWidth == m_wMaximumIncrement) return; //  Nothing to do!

    m_wMaximumIncrement = wWidth;

    m_wAverageWidth = DBCSFont() ? (wWidth + 1) >> 1 : wWidth;

    Changed();
}

/*****************************************************************************

  CFontInfo::SetHeight

  This member checks to see if the new height is non-zero and new.  If so, it
  uses it for the new height, then adjusts all of the possibly affected
  special metrics so they continue to meet the constraints.

******************************************************************************/

BOOL    CFontInfo::SetHeight(WORD wHeight) {
    if  (!wHeight || wHeight == m_wHeight)
        return  FALSE;

    m_wHeight = wHeight;

    short   sBaseline = (short) (min(wHeight, m_cwaSpecial[Baseline]));

    for (unsigned u = 0; u <= InternalLeading; u++) {
        switch  (u) {
        case    InterlineGap:
            if  (m_cwaSpecial[u] > 2 * wHeight)
                m_cwaSpecial[u] = 2 * wHeight;
            continue;

        case    UnderOffset:
        case    SubMoveY:
        case    Lowerd:

            if  ((short) m_cwaSpecial[u] < sBaseline - wHeight)
                m_cwaSpecial[u] = sBaseline - wHeight;
            continue;

        case    UnderSize:

            if  (m_cwaSpecial[u] > wHeight - (unsigned) sBaseline)
                m_cwaSpecial[u] = wHeight = (unsigned) sBaseline;

            if  (!m_cwaSpecial[u])
                m_cwaSpecial[u] = 1;
            continue;

        case    SuperSizeX:
        case    SubSizeX:
        case    SuperMoveX:
        case    SubMoveX:
        case    ItalicAngle:
            continue;   //  These aren't affected

        default:
            if  (m_cwaSpecial[u] > (unsigned) sBaseline)
                m_cwaSpecial[u] = sBaseline;
        }
    }

    //  Adjust the scaling factors if need be
    if  (m_wScaleDevice > m_wHeight - m_cwaSpecial[InternalLeading])
        m_wScaleDevice = m_wHeight - m_cwaSpecial[InternalLeading];
    if  (m_wMinScale > m_wHeight - m_cwaSpecial[InternalLeading])
        m_wMinScale = m_wHeight - m_cwaSpecial[InternalLeading];

    Changed();

    return  TRUE;
}

/*****************************************************************************

  CFontInfo::SetCharacterSet

  This one is a bit tricky- the new character set must be compatible with the
  GTT file associated with this font.  So we need to check it before we pass
  on it.

  ASSUMPTIONS:
  (1)  Things are bulletproof enough that the existing character set will 
  already pass this test.

******************************************************************************/

BOOL    CFontInfo::SetCharacterSet(BYTE bNew) {
    unsigned u;

    switch  (bNew) {
    case    SHIFTJIS_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 932)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    HANGEUL_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 949)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    CHINESEBIG5_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 950)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    GB2312_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 936)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    default:
        //  Don't accept any DBCS codepages
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            switch  (m_pcgmTranslation -> PageID(u)) {
            case    932:
            case    936:
            case    949:
            case    950:
            case    1361:   //  Johab- but it isn't in the converter!
                return  FALSE;
        }
    }

    if  (m_bCharacterSet != bNew) {
        m_bCharacterSet = bNew;
        Changed();
    }

    return  TRUE;
}

/******************************************************************************

  CFontInfo::SetSignificant

  This member is called to change the value of one of the significant code 
  points (break character or default) encoded in the font.  Doing this 
  correctly means getting the ANSI and UNICODE versions of the code point, and 
  discarding any out-of-range values.

  This function returns an encoded value indicating success or cause of 
  failure.

******************************************************************************/

WORD    CFontInfo::SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode) {
    _ASSERT(wItem > Last && wItem <= Break);

    if  (!bUnicode && wChar > 255)
        return  DoubleByte;

    CWaitCursor cwc;    //  Unfortunately, if not Unicode, htis is slow

    CPtrArray               cpaGlyphs;
    CWordArray              cwa;
    CByteArray              cba;
    CDWordArray             cdaPage;

    m_pcgmTranslation -> Collect(cpaGlyphs);
    m_pcgmTranslation -> CodePages(cdaPage);

    for (int i = 0; i < cpaGlyphs.GetSize(); i++) {
        CGlyphHandle& cgh = *(CGlyphHandle *) cpaGlyphs[i];

        if  (bUnicode) {
            if  (cgh.CodePoint() == wChar) {
                cwa.Add(wChar);
                ccpi.Convert(cba, cwa, cdaPage[cgh.CodePage()]);
                break;
            }
        }
        else {
            if  (i)
                cwa.SetAt(0, cgh.CodePoint());
            else
                cwa.Add(cgh.CodePoint());

            ccpi.Convert(cba, cwa, cdaPage[cgh.CodePage()]);

            if  (cba.GetSize() == 1 && cba[0] == (BYTE) wChar)
                break;
            cba.RemoveAll();    //  So we can try again
        }
    }

    if  (i == cpaGlyphs.GetSize())
        return  InvalidChar;

    if  (cba.GetSize() != 1)
        return  DoubleByte;

    //  OK, we passed all of the hurdles

    if  (m_cwaSignificant[wItem] == cwa[0])
        return  OK; //  Nothing changed!!!!

    m_cwaSignificant[wItem] = cwa[0];
    m_cbaSignificant[wItem] = cba[0];
    Changed();
    return  OK;
}

/******************************************************************************

  CFontInfo::SetScaleLimit

  This member receives a proposed new maximum or minimum font size in device
  units.  First, it is compared to the existing size, for a quick exit.  Then
  we check to see that the ordering of the limits and the nominal size is 
  preserved.  If it is not, we describe the problem and leave.  Otherwise, we
  update the value, and note that the font information has changed.

******************************************************************************/

WORD    CFontInfo::SetScaleLimit(BOOL bMax, WORD wNew) {

    if  (wNew == (bMax ? m_wMaxScale : m_wMinScale))
        return  ScaleOK;

    if  (bMax ? wNew <= m_wMinScale : wNew >= m_wMaxScale)
        return  Reversed;

    if  (bMax ? wNew < m_wScaleDevice : wNew > m_wScaleDevice)
        return  NotWindowed;

    if  (bMax)
        m_wMaxScale = wNew;
    else
        m_wMinScale = wNew;

    Changed();
    return  ScaleOK;
}

/******************************************************************************

  CFontInfo::SetDeviceEmHeight

  This member sets the units used for determing the conversion from font units
  (in which all metrics are given) to device units.  The checking is similar to
  that above, except here, we need to make sure that the font units are always
  of equal or greater resolution than the device units.

******************************************************************************/

WORD    CFontInfo::SetDeviceEmHeight(WORD wNew) {

    if  (wNew == m_wScaleDevice)
        return  ScaleOK;

    if  (wNew > m_wHeight - m_cwaSpecial[InternalLeading])
        return  Reversed;

    if  (wNew < m_wMinScale || wNew > m_wMaxScale)
        return  NotWindowed;

    m_wScaleDevice = wNew;

    Changed();
    return  ScaleOK;
}

/******************************************************************************

  CFontInfo::Load

  This member function loads the UFM file, finally initializing all of the
  tons of individual values we're trying to pretend we know how to manage
  here.

******************************************************************************/

//  These flags have a negative sense, but the UI makes more sense if they
//  are positive, so their sense is inverted using the following constant

#define FLIP_FLAGS  (DF_NOITALIC | DF_NOUNDER | DF_NO_BOLD |\
                    DF_NO_DOUBLE_UNDERLINE | DF_NO_STRIKETHRU)

BOOL    CFontInfo::Load() {

    CFile   cfUFM;

    if  (!cfUFM.Open(m_cfn.FullName(), 
        CFile::modeRead | CFile::shareDenyWrite)) {
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, (LPCTSTR) m_cfn.FullName());
        AfxMessageBox(csMessage);
        return  FALSE;
    }

    //  Try to load the file- proclaim defeat on any exception.
    
    CByteArray  cbaUFM;

    try {

        cbaUFM.SetSize(cfUFM.GetLength());
        cfUFM.Read(cbaUFM.GetData(), cbaUFM.GetSize());
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, (LPCTSTR) m_cfn.FullName());
        AfxMessageBox(csMessage);
        return  FALSE;
    }

    //  First thing in the file is the header.

    PUNIFM_HDR  pufmh = (PUNIFM_HDR) cbaUFM.GetData();

    //  pull up the GTT ID

    m_widTranslation = (WORD) pufmh -> lGlyphSetDataRCID;

    //  Find the UNIDRVINFO

    PUNIDRVINFO pudi = 
        (PUNIDRVINFO) (cbaUFM.GetData() + pufmh -> loUnidrvInfo);

    //  Fill in the two invocation strings- why it is the offset is NULL
    //  and the count is garbage when there is none is beyond me, but so be it.

    if  (pudi -> SelectFont.dwofCommand)
        m_ciSelect.Init((PBYTE) pudi + pudi -> SelectFont.dwofCommand, 
            pudi -> SelectFont.dwcbCommand);

    if  (pudi -> UnSelectFont.dwofCommand)
        m_ciDeselect.Init((PBYTE) pudi + pudi -> UnSelectFont.dwofCommand, 
            pudi -> UnSelectFont.dwcbCommand);

    //  Initialize the files of interest from the UNIDRVINFO

    m_bScalable = (pudi -> flGenFlags & UFM_SCALABLE);

    m_bTechnology = (BYTE) pudi -> wType;

    if  (pudi -> flGenFlags & UFM_SOFT)
        m_bLocation = Download;
    else
        if  (pudi -> flGenFlags & UFM_CART_MAIN)
            m_bLocation = MainCartridge;
        else
            if  (pudi -> flGenFlags & UFM_CART)
                m_bLocation = Cartridge;

    m_wXResolution = pudi -> wXRes;
    m_wYResolution = pudi -> wYRes;
    m_wPrivateData = pudi -> wPrivateData;

    m_sPreAdjustY = pudi -> sYAdjust;
    m_sPostAdjustY = pudi -> sYMoved;

    m_sCenterAdjustment = pudi -> sShift;
    m_bfGeneral = (BYTE) pudi -> fCaps ^ FLIP_FLAGS;

    //  Time to bite the IFIMETRICS bullet

    union {
        PBYTE       pbIFI;
        PIFIMETRICS pifi;
    };

    pbIFI = cbaUFM.GetData() + pufmh -> loIFIMetrics;

    //  Get the special metrics loaded first
    m_cwaSpecial[CapH] = pifi -> fwdCapHeight;
    m_cwaSpecial[LowerX] = pifi -> fwdXHeight;
    m_cwaSpecial[SuperMoveX] = pifi -> fwdSuperscriptXOffset;
    m_cwaSpecial[SuperMoveY] = pifi -> fwdSuperscriptYOffset;
    m_cwaSpecial[SubMoveX] = pifi -> fwdSubscriptXOffset;
    m_cwaSpecial[SubMoveY] = pifi -> fwdSubscriptYOffset;
    m_cwaSpecial[SuperSizeX] = pifi -> fwdSuperscriptXSize;
    m_cwaSpecial[SuperSizeY] = pifi -> fwdSuperscriptYSize;
    m_cwaSpecial[SubSizeX] = pifi -> fwdSubscriptXSize;
    m_cwaSpecial[SubSizeY] = pifi -> fwdSubscriptYSize;
    m_cwaSpecial[UnderOffset] = pifi -> fwdUnderscorePosition;
    m_cwaSpecial[UnderSize] = pifi -> fwdUnderscoreSize;
    m_cwaSpecial[StrikeOffset] = pifi -> fwdStrikeoutPosition;
    m_cwaSpecial[StrikeSize] = pifi -> fwdStrikeoutSize;
    m_cwaSpecial[ItalicAngle] = (WORD) (dConvert * 
        atan2((double) pifi -> ptlCaret.x, (double) pifi -> ptlCaret.y));
    m_cwaSpecial[Baseline] = pifi -> fwdWinAscender;
    m_cwaSpecial[InterlineGap] = pifi -> fwdMacLineGap;

    //  Now, see if there is an EXTTEXTMETRIC- if so, fill in some fields from
    //  it.

    PEXTTEXTMETRIC  petm = (PEXTTEXTMETRIC) (pufmh -> loExtTextMetric ?
        (cbaUFM.GetData() + pufmh -> loExtTextMetric) : NULL);

    if  (petm) {
        m_wMinScale = petm -> emMinScale;
        m_wMaxScale = petm -> emMaxScale;

        //  Scads of special metrics- double underlining will not be preserved.
        m_cwaSpecial[Lowerd] = petm -> emLowerCaseAscent;
        m_cwaSpecial[Lowerp] = petm -> emLowerCaseDescent;
        m_cwaSpecial[ItalicAngle] = petm -> emSlant;

        //  Orientation, Master Units (Font units are calculated)
        m_bfScaleOrientation = (BYTE) petm -> emOrientation;
        m_wScaleDevice = petm -> emMasterHeight;
    }

    //  Let's get the rest of the IFIMETRICS stuff, now.
    m_cbaSignificant.SetSize(1 + Break);
    m_cwaSignificant.SetSize(1 + Break);
    m_cbaSignificant[Break] = pifi -> chBreakChar;
    m_bCharacterSet = pifi -> jWinCharSet;
    m_cbaSignificant[Default] = pifi -> chDefaultChar;
    m_cbaSignificant[First] = pifi -> chFirstChar;
    m_cbaSignificant[Last] = pifi -> chLastChar;
    m_bPitchAndFamily = pifi -> jWinPitchAndFamily;
    m_wAverageWidth = pifi -> fwdAveCharWidth;
    m_cwaSignificant[Break] = pifi -> wcBreakChar;
    m_cwaSignificant[Default] = pifi -> wcDefaultChar;
    m_cwaSignificant[First] = pifi -> wcFirstChar;
    m_cwaSignificant[Last] = pifi -> wcLastChar;
    m_wMaximumIncrement = pifi -> fwdMaxCharInc;
    m_wWeight = pifi -> usWinWeight;
    m_wHeight = pifi -> fwdWinAscender + pifi -> fwdWinDescender;
    m_cwaSpecial[InternalLeading] = m_wHeight - pifi -> fwdUnitsPerEm;
    m_wfStyle = pifi -> fsSelection;

    //  Get the face and other name strings.  Let CString handle the
    //  Unicode conversions for us,

    m_csUnique = (PWSTR) (pbIFI + pifi -> dpwszUniqueName);
    m_csStyle = (PWSTR) (pbIFI + pifi -> dpwszStyleName);
    m_csFace = (PWSTR) (pbIFI + pifi -> dpwszFaceName);
    m_csaFamily.RemoveAll();    //  Just in case it isn't clean

    PWSTR   pwstrFamily = (PWSTR) (pbIFI + pifi -> dpwszFamilyName);
    CString csWork(pwstrFamily);
    m_csaFamily.Add(csWork);
    pwstrFamily += 1 + wcslen(pwstrFamily);

    if  (pifi -> flInfo & FM_INFO_FAMILY_EQUIV)
        while   (*pwstrFamily) {
            csWork = pwstrFamily;
            m_csaFamily.Add(csWork);
            pwstrFamily += 1 + wcslen(pwstrFamily);
        }

    //  Font Difference structures, if any.

    if  (pifi -> dpFontSim) {
        union {
            PBYTE   pbfs;
            FONTSIM *pfs;
        };

        pbfs = pbIFI + pifi -> dpFontSim;

        //  If we're reloading, clean these up!

        if  (m_pcfdBold)
            delete  m_pcfdBold;

        if  (m_pcfdItalic)
            delete  m_pcfdItalic;

        if  (m_pcfdBoth)
            delete  m_pcfdBoth;

        //  Bold simulation

        if  (pfs -> dpBold)
            m_pcfdBold = new CFontDifference(pbfs + pfs -> dpBold, this);

        //  Italic Simulation

        if  (pfs -> dpItalic)
            m_pcfdItalic = new CFontDifference(pbfs + pfs -> dpItalic, this);

        //  Bold Italic Simulation

        if  (pfs -> dpBoldItalic)
            m_pcfdBoth = new CFontDifference(pbfs + pfs -> dpBoldItalic, this);
    }

    //  Width table, but only if there is an associated GTT.

    if  (m_pcgmTranslation && pufmh -> loWidthTable) {
        union {
            PBYTE       pbwt;
            PWIDTHTABLE pwt;
        };

        pbwt = cbaUFM.GetData() + pufmh -> loWidthTable;
        m_pcgmTranslation -> Collect(m_cpaGlyphs);  //  Collect all the handles
        m_cwaWidth.RemoveAll();
        m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize());

        for (unsigned u = 0; u < pwt -> dwRunNum; u++) {
            PWORD   pwWidth = 
                (PWORD) (pbwt + pwt -> WidthRun[u].loCharWidthOffset);
            for (unsigned   uGlyph = 0; 
                 uGlyph < pwt -> WidthRun[u].wGlyphCount; 
                 uGlyph++)

                //  Glyph handles start at 1, not 0!
                m_cwaWidth[uGlyph + -1 + pwt -> WidthRun[u].wStartGlyph] =
                    *pwWidth++;
                    
        }
    }
            
    //  Kerning Table, if any
    m_csoaKern.RemoveAll();

    if  (pufmh -> loKernPair) {
        PKERNDATA   pkd = (PKERNDATA) (cbaUFM.GetData() + pufmh -> loKernPair);
        for (unsigned u = 0; u < pkd -> dwKernPairNum; u++)
            m_csoaKern.Add(new CKern(pkd -> KernPair[u]));
    }

    //  Return triumphant to whoever deigned to need this service.
    return  TRUE;
}

/*****************************************************************************

  CUniString class

  This is a little helper class that will convert a CString to a UNICODE
  string, and take care of cleanup, etc., so the font storage code doesn't get
  any messier than it already will be.

******************************************************************************/

class CUniString : public CWordArray {
public:
    CUniString(LPCSTR lpstrInit);
    operator PCWSTR() const { return GetData(); }
    unsigned    GetSize() const { 
        return sizeof (WCHAR) * (unsigned) CWordArray::GetSize();
    }

    void    Write(CFile& cf) {
        cf.Write(GetData(), GetSize());
    }
};

CUniString::CUniString(LPCSTR lpstrInit) {
    SetSize(MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrInit, -1, NULL, 
        0));
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrInit, -1, GetData(), 
        GetSize());
}

/*****************************************************************************

  CFontInfo::Store

  This member function stores the UFM format information in the specified file
  by assembling it from the information we have cached in this class.

******************************************************************************/

BOOL    CFontInfo::Store(LPCTSTR lpstrFile) {

    try {   //  Any exxceptions, we'll just fail gracelessly

        CFile   cfUFM(lpstrFile, 
            CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

        //  First thing in the file is the header.

        UNIFM_HDR  ufmh = {sizeof ufmh, UNIFM_VERSION_1_0, 0, 
            (short) m_widTranslation, sizeof ufmh};

        //  Use Glyph Map default code page if at all possible.

        ufmh.ulDefaultCodepage = m_pcgmTranslation -> DefaultCodePage();

        //  Zero fill reserved bytes.

        memset((PBYTE) ufmh.dwReserved, 0, sizeof ufmh.dwReserved);
        

        //  Next is the UNIDRVINFO

        UNIDRVINFO udi = {sizeof udi};

        //  Invocation Strings affect the size, so get their specifics and
        //  save them, updating the affected size fields as we go.

        udi.SelectFont.dwofCommand = m_ciSelect.Length() ? udi.dwSize : 0;
        udi.dwSize += udi.SelectFont.dwcbCommand = m_ciSelect.Length();
        udi.UnSelectFont.dwofCommand = m_ciDeselect.Length() ? udi.dwSize : 0;
        udi.dwSize += udi.UnSelectFont.dwcbCommand = m_ciDeselect.Length();

        //  Pad this to keep everything DWORD aligned in the file image!

        unsigned    uAdjustUDI = (sizeof udi.dwSize  - 
            (udi.dwSize % sizeof udi.dwSize)) % sizeof udi.dwSize;

        ufmh.loIFIMetrics = ufmh.dwSize += udi.dwSize += uAdjustUDI;

        //  Initialize the UNIDRVINFO

        switch  (m_bLocation) {
            case    Download:
                udi.flGenFlags = UFM_SOFT;
                break;

            case    MainCartridge:
                udi.flGenFlags = UFM_CART | UFM_CART_MAIN;
                break;

            case    Cartridge:
                udi.flGenFlags = UFM_CART;
                break;

            default:    //  Resident;
                udi.flGenFlags = 0;
        }

        if  (m_bScalable)
            udi.flGenFlags |= UFM_SCALABLE;

        udi.wType = m_bTechnology;
        udi.wXRes = m_wXResolution;
        udi.wYRes = m_wYResolution;
        udi.wPrivateData = m_wPrivateData;

        udi.sYAdjust = m_sPreAdjustY;
        udi.sYMoved = m_sPostAdjustY;

        udi.sShift = m_sCenterAdjustment;
        udi.fCaps = m_bfGeneral ^ FLIP_FLAGS;

        memset((PSTR) udi.wReserved, 0, sizeof udi.wReserved);

        //  Time to bite the IFIMETRICS bullet

        IFIEXTRA    ifie = {0, 0, m_pcgmTranslation -> Glyphs(), 0, 0, 0};
        IFIMETRICS ifi = {sizeof ifi + sizeof ifie, sizeof ifie};
        ifi.lEmbedId = ifi.lItalicAngle = ifi.lCharBias = 0;
        ifi.dpCharSets = 0;
        ifi.jWinCharSet = m_bCharacterSet;
        m_bPitchAndFamily = (m_bPitchAndFamily & 0xF0) | 
            (IsVariableWidth() ? VARIABLE_PITCH : FIXED_PITCH);
        ifi.jWinPitchAndFamily = m_bPitchAndFamily;
        ifi.usWinWeight = m_wWeight;

        ifi.flInfo = FM_INFO_TECH_BITMAP | FM_INFO_1BPP | 
            FM_INFO_INTEGER_WIDTH | FM_INFO_NOT_CONTIGUOUS | 
            FM_INFO_RIGHT_HANDED;

        if  (DBCSFont())
            ifi.flInfo |= FM_INFO_DBCS_FIXED_PITCH;

        if  (!IsVariableWidth()) {
            ifi.flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
            if  (!DBCSFont())   //  DBCS is never constant width
                ifi.flInfo |= FM_INFO_CONSTANT_WIDTH;
        }

        if  (m_bScalable)
            ifi.flInfo |= FM_INFO_ISOTROPIC_SCALING_ONLY;

        ifi.fsType = FM_NO_EMBEDDING;
        ifi.fwdLowestPPEm = 1;
        ifi.fwdUnitsPerEm = m_wHeight - m_cwaSpecial[InternalLeading];
        
        ifi.fwdCapHeight = m_cwaSpecial[CapH];
        ifi.fwdSuperscriptXOffset = m_cwaSpecial[SuperMoveX];
        ifi.fwdSubscriptXOffset = m_cwaSpecial[SubMoveX];
        ifi.fwdSuperscriptXSize = m_cwaSpecial[SuperSizeX];
        ifi.fwdSubscriptXSize = m_cwaSpecial[SubSizeX];
        ifi.ptlCaret.x = m_cwaSpecial[ItalicAngle] ? (long)
            ((double) 10000.0 * 
            tan(((double) m_cwaSpecial[ItalicAngle]) / dConvert)) : 0;
        ifi.ptlCaret.y = m_cwaSpecial[ItalicAngle] ? 10000 : 1;
        ifi.fwdTypoAscender = ifi.fwdMacAscender = ifi.fwdWinAscender = 
            m_cwaSpecial[Baseline];
        ifi.fwdTypoDescender = ifi.fwdMacDescender = -(ifi.fwdWinDescender = 
            m_wHeight - ifi.fwdWinAscender);
        ifi.fwdTypoLineGap = ifi.fwdMacLineGap = m_cwaSpecial[InterlineGap];
        ifi.fwdXHeight = m_cwaSpecial[LowerX];
        ifi.fwdSuperscriptYOffset = m_cwaSpecial[SuperMoveY];
        ifi.fwdSubscriptYOffset = m_cwaSpecial[SubMoveY];
        ifi.fwdSuperscriptYSize = m_cwaSpecial[SuperSizeY];
        ifi.fwdSubscriptYSize = m_cwaSpecial[SubSizeY];
        ifi.fwdUnderscorePosition = m_cwaSpecial[UnderOffset];
        ifi.fwdUnderscoreSize = m_cwaSpecial[UnderSize];
        ifi.fwdStrikeoutPosition = m_cwaSpecial[StrikeOffset];
        ifi.fwdStrikeoutSize = m_cwaSpecial[StrikeSize];
        ifi.fwdAveCharWidth = m_wAverageWidth;
        ifi.fwdMaxCharInc = m_wMaximumIncrement;
        ifi.fsSelection = m_wfStyle;

        ifi.wcBreakChar = m_cwaSignificant[Break];
        ifi.wcDefaultChar = m_cwaSignificant[Default];
        ifi.chBreakChar = m_cbaSignificant[Break];
        ifi.chDefaultChar = m_cbaSignificant[Default];
        ifi.chFirstChar = m_cbaSignificant[First];
        ifi.chLastChar = m_cbaSignificant[Last];
        ifi.wcFirstChar = m_cwaSignificant[First];
        ifi.wcLastChar = m_cwaSignificant[Last];

        ifi.ptlBaseline.x = 1;
        ifi.ptlBaseline.y = 0;
        ifi.ptlAspect.x = udi.wXRes;
        ifi.ptlAspect.y = udi.wYRes;
        memcpy(ifi.achVendId, "Unkn", 4);
        ifi.cKerningPairs = m_csoaKern.GetSize();
        ifi.rclFontBox.left = 0;
        ifi.rclFontBox.top = ifi.fwdWinAscender;
        ifi.rclFontBox.right = ifi.fwdMaxCharInc;
        ifi.rclFontBox.bottom = ifi.fwdMacDescender;

        ifi.ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
        ifi.panose.bWeight = (m_wWeight >= FW_BOLD) ? PAN_WEIGHT_BOLD :
            (m_wWeight > FW_EXTRALIGHT) ? PAN_WEIGHT_MEDIUM : PAN_WEIGHT_LIGHT;

        ifi.panose.bFamilyType = ifi.panose.bSerifStyle = 
            ifi.panose.bProportion = ifi.panose.bContrast = 
            ifi.panose.bStrokeVariation = ifi.panose.bArmStyle = 
            ifi.panose.bLetterform = ifi.panose.bMidline = 
            ifi.panose.bXHeight = PAN_ANY;

        //  Convert and "place" the various name strings

        CUniString  cusUnique(m_csUnique), cusStyle(m_csStyle), 
            cusFace(m_csFace), cusFamily(m_csaFamily[0]);

        ifi.dpwszFamilyName = ifi.cjThis;
        for (int i = 1; i < m_csaFamily.GetSize(); i++) {
            CUniString cusWork(m_csaFamily[i]);
            cusFamily.Append(cusWork);
        }

        if  (m_csaFamily.GetSize() > 1) {
            cusFamily.Add(0);
            ifi.flInfo |= FM_INFO_FAMILY_EQUIV;
        }

        ifi.cjThis += cusFamily.GetSize();

        ifi.dpwszFaceName = ifi.cjThis;
        ifi.cjThis += cusFace.GetSize();
        ifi.dpwszUniqueName = ifi.cjThis;
        ifi.cjThis += cusUnique.GetSize();
        ifi.dpwszStyleName = ifi.cjThis;
        ifi.cjThis += cusStyle.GetSize();

        //  The next field must be DWORD aligned, so see what padding
        //  is needed.

        unsigned    uAdjustIFI = (sizeof ifi.cjThis - 
            (ifi.cjThis % sizeof ifi.cjThis)) % sizeof ifi.cjThis;

        ifi.cjThis += uAdjustIFI;
        
        //  Finally, Allow for the size of any Font Difference structures.

        unsigned    uSim = !!m_pcfdBold + !!m_pcfdItalic + !!m_pcfdBoth;

        ifi.dpFontSim = uSim ? ifi.cjThis : 0;

        ufmh.dwSize += ifi.cjThis += uSim * sizeof(FONTDIFF) + 
            !!uSim * sizeof(FONTSIM);

        //  Now, see if there is an EXTTEXTMETRIC- if so, fill it in.

        ufmh.loExtTextMetric = m_bScalable ? ufmh.dwSize : 0;

        EXTTEXTMETRIC etm;

        if  (m_bScalable) {
            ufmh.dwSize += etm.emSize = sizeof etm;
            etm.emPointSize = (short)((DWORD)((DWORD) m_wScaleDevice * 1440) /
                (DWORD) m_wXResolution);    //  Use DWORD for precision
            etm.emOrientation = m_bfScaleOrientation;
            etm.emMasterHeight = m_wScaleDevice;
            etm.emMinScale = m_wMinScale;
            etm.emMaxScale = m_wMaxScale;
            etm.emMasterUnits = m_wHeight - m_cwaSpecial[InternalLeading];
            etm.emKernPairs = m_csoaKern.GetSize();
            etm.emKernTracks = 0;

            //  Scads of special metrics

            etm.emCapHeight = m_cwaSpecial[CapH];
            etm.emXHeight = m_cwaSpecial[LowerX];
            etm.emSuperScript = m_cwaSpecial[SuperMoveY];
            etm.emSubScript = m_cwaSpecial[SubMoveY];
            etm.emSuperScriptSize = m_cwaSpecial[SuperSizeY];
            etm.emSubScriptSize = m_cwaSpecial[SubSizeY];
            etm.emUnderlineOffset = m_cwaSpecial[UnderOffset];
            etm.emUnderlineWidth = m_cwaSpecial[UnderSize];
            etm.emStrikeOutOffset = m_cwaSpecial[StrikeOffset];
            etm.emStrikeOutWidth = m_cwaSpecial[StrikeSize];
            etm.emDoubleUpperUnderlineOffset = //   Not supported- zero them
                etm.emDoubleLowerUnderlineOffset = 
                etm.emDoubleUpperUnderlineWidth = 
                etm.emDoubleLowerUnderlineWidth = 0;
            etm.emLowerCaseAscent = m_cwaSpecial[Lowerd];
            etm.emLowerCaseDescent = m_cwaSpecial[Lowerp];
            etm.emSlant = m_cwaSpecial[ItalicAngle];
        }

        //  Width table, but only if there is an associated GTT.

        ufmh.loWidthTable = IsVariableWidth() * ufmh.dwSize;

        if  (IsVariableWidth()) {
            //  For now, we just need to calculate the size of the table
            unsigned    uRuns = 0, uGlyphs = 0;

            if  (DBCSFont()) {  //DBCS
                //  Determine the number of runs needed
                unsigned u = (unsigned) m_cpaGlyphs.GetSize();
                do {
                    while   (u-- && !m_cwaWidth[u]); //  DBCS has 0 width
                    if  (u == (unsigned) -1)
                        break;  //  We're done!
                    uRuns++, uGlyphs++;
                    while   (u-- && m_cwaWidth[u])
                        uGlyphs++;
                }
                while   (u != (unsigned) -1);
            }
            else {
                uRuns++;
                uGlyphs = m_cwaWidth.GetSize();
            }

            ufmh.dwSize += sizeof (WIDTHTABLE) + --uRuns * sizeof (WIDTHRUN) +
                uGlyphs * sizeof (WORD);
        }
            
        //  Kerning Table, if any

        ufmh.loKernPair = CanKern() ? ufmh.dwSize : 0;

        //`A "secret" kern pair of all 0's must end this, so this size
        //  is in fact correct.  Also note that padding screws up the size of
        //  the KERNDATA structure, so the 
        if  (CanKern())
            ufmh.dwSize += 
            ((sizeof (KERNDATA) - sizeof (FD_KERNINGPAIR)) & 0xFFFC) + 
            ((1 + m_csoaKern.GetSize()) * sizeof (FD_KERNINGPAIR));
        //  All sizes have been calculated, and the important structures have
        //  been initialized.  Time to start writing all this great stuff!

        //  Header

        cfUFM.Write(&ufmh, sizeof ufmh);

        //  UNIDRVINFO

        cfUFM.Write(&udi, sizeof udi);
        m_ciSelect.WriteEncoding(cfUFM);
        m_ciDeselect.WriteEncoding(cfUFM);
        cfUFM.Write(ufmh.dwReserved, uAdjustUDI);   //  Padding

        //  IFIMETRICS, IFIEXTRA, and names, follwed by any padding

        cfUFM.Write(&ifi, sizeof ifi);
        cfUFM.Write(&ifie, sizeof ifie);
        cusFamily.Write(cfUFM);
        cusFace.Write(cfUFM);
        cusUnique.Write(cfUFM);
        cusStyle.Write(cfUFM);
        cfUFM.Write(ufmh.dwReserved, uAdjustIFI);   //  PAdding

        //  Any Font difference structures

        if  (m_pcfdBold || m_pcfdItalic || m_pcfdBoth) {
            FONTSIM fs;
            unsigned    uWhere = sizeof fs;

            fs.dpBold = m_pcfdBold ? uWhere : 0;
            uWhere += !!m_pcfdBold * sizeof (FONTDIFF);
            fs.dpItalic = m_pcfdItalic ? uWhere : 0;
            uWhere += !!m_pcfdItalic * sizeof (FONTDIFF);
            fs.dpBoldItalic = m_pcfdBoth ? uWhere : 0;

            cfUFM.Write(&fs, sizeof fs);

            if  (m_pcfdBold)
                m_pcfdBold -> Store(cfUFM, m_wfStyle | FM_SEL_BOLD);

            if  (m_pcfdItalic)
                m_pcfdItalic -> Store(cfUFM, m_wfStyle | FM_SEL_ITALIC);

            if  (m_pcfdBoth)
                m_pcfdBoth -> Store(cfUFM, 
                m_wfStyle | FM_SEL_BOLD| FM_SEL_ITALIC);
        }

        //  EXTTEXTMETRIC

        if  (m_bScalable)
            cfUFM.Write(&etm, sizeof etm);

        //  Width table

        if  (IsVariableWidth())
            if  (!DBCSFont()) {  
                //  Not DBCS- easy!  (Handles always start at 1
                WIDTHTABLE  wdt = { sizeof wdt, 1, 
                        {1, m_cpaGlyphs.GetSize(), sizeof wdt}};
                cfUFM.Write(&wdt, sizeof wdt);

                cfUFM.Write(m_cwaWidth.GetData(), 
                    m_cwaWidth.GetSize() * sizeof (WORD));
            }
            else {  //  This case is a bit nastier

                CByteArray  cbaTable;
                CWordArray  cwaSize;

                cbaTable.SetSize(sizeof(WIDTHTABLE) - sizeof(WIDTHRUN));
                PWIDTHTABLE pwdt = (PWIDTHTABLE) cbaTable.GetData();
                pwdt -> dwRunNum = 0;

                //  Calculate and fill in the WIDTHRUN structures and the
                //  Size array
                unsigned u = 0, uMax = (unsigned) m_cpaGlyphs.GetSize();
                do {
                    while   (u < uMax && !m_cwaWidth[u++]); 
                    if  (u == uMax)
                        break;  //  We're done!

                    //  We've found a run- lots of work to do

                    cbaTable.InsertAt(cbaTable.GetSize(), 0, 
                        sizeof (WIDTHRUN)); //  Add a run to the table
                    pwdt = (PWIDTHTABLE) cbaTable.GetData();
                    //  Remember the glyph handle is 1-based.
                    pwdt -> WidthRun[pwdt -> dwRunNum].wStartGlyph = --u + 1;
                    pwdt -> WidthRun[pwdt -> dwRunNum].wGlyphCount = 0;
                    pwdt -> WidthRun[pwdt -> dwRunNum].loCharWidthOffset =
                        cwaSize.GetSize() * sizeof (WORD);
                    do {
                        cwaSize.Add(m_cwaWidth[u]);
                        pwdt -> WidthRun[pwdt -> dwRunNum].wGlyphCount++;
                    }
                    while   (++u < uMax && m_cwaWidth[u]);
                    pwdt -> dwRunNum++; //  End of the run!
                }
                while   (u < uMax);

                //  OK, now we have to add the total size of the WIDTHTABLE
                //  to the various offsets, but we are otherwise ready to rock
                //  and roll.

                pwdt -> dwSize = cbaTable.GetSize();
                for (u = 0; u < pwdt -> dwRunNum; u++)
                    pwdt -> WidthRun[u].loCharWidthOffset += pwdt -> dwSize;

                //  At last- time to send 'em packing!
                cfUFM.Write(pwdt, pwdt -> dwSize);
                for (u = 0; u < pwdt -> dwRunNum; u++)
                    cfUFM.Write(cwaSize.GetData() + 
                    pwdt -> WidthRun[u].wStartGlyph - 1, 
                    pwdt -> WidthRun[u].wGlyphCount * sizeof (WORD));
            }

        //  Kern Pairs

        if  (CanKern()) {
            //  KERNDATA is DWORD-packed, but FD_KERNINGPAIR is WORD-packed
            //  the following trick code allows for any slop.
            KERNDATA    kd = {0xFFFC & (sizeof kd - sizeof kd.KernPair), 
                m_csoaKern.GetSize()};
            kd.dwSize += (1 + kd.dwKernPairNum) * sizeof kd.KernPair;
            
            cfUFM.Write(&kd, 0xFFFC & (sizeof kd - sizeof kd.KernPair));

            for (unsigned u = 0; u < m_csoaKern.GetSize(); u++)
                ((CKern *) m_csoaKern[u]) -> Store(cfUFM);

            //  Now for the "secret" sentinel- 
            CKern   ck; //  Just happens to 0-init!
            ck.Store(cfUFM);
        }
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    //  Return triumphant to whoever deigned to need this service.
    Changed(FALSE);
    return  TRUE;
}

/*****************************************************************************

  CFontInfo::CreateEditor

  This member function launches an editing view for the font.

******************************************************************************/

CMDIChildWnd*   CFontInfo::CreateEditor() {
    CFontInfoContainer* pcficMe= new CFontInfoContainer(this, FileName());

    //  Make up a cool title

    pcficMe -> SetTitle(m_pcbnWorkspace -> Name() + _TEXT(": ") + Name());

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt -> 
        CreateNewFrame(pcficMe, NULL);

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcficMe, TRUE);
        m_pcmdt -> AddDocument(pcficMe);
    }

    return  pcmcwNew;
}

/******************************************************************************

  CFontInfo::Serialize

  This is responsible for storing and restoring the entire maze of data in
  persistent object storage.

******************************************************************************/

void    CFontInfo::Serialize(CArchive& car) {
    //  We only serialize what's needed to use the UFM file in the editor,
    //  i.e., the glue needed to hold us in the driver workspace.

    CProjectNode::Serialize(car);    
}

/******************************************************************************

  CFontInfo::EnableSim

  This method is called to turn simulation on or off for the specified item.
  It receives a reference to the editor's pointer for the same item.

******************************************************************************/

void    CFontInfo::EnableSim(unsigned uSim, BOOL bOn, CFontDifference*& pcfd) {

    CFontDifference*&   pcfdTarget = 
        uSim ? (uSim == BothDiff) ? m_pcfdBoth : m_pcfdBold : m_pcfdItalic;

    //  Clear out any irrelevant calls

    if  (bOn == !!pcfd && pcfdTarget == pcfd)
        return;

    //  If this call is just to init pcfd, do it and leave

    if  (bOn && pcfdTarget) {
        pcfd = pcfdTarget;
        return;
    }

    if  (bOn)  
        pcfd = pcfdTarget = pcfd ? pcfd : new CFontDifference(m_wWeight, 
            m_wMaximumIncrement, m_wAverageWidth, 
            uSim == BoldDiff ? m_cwaSpecial[ItalicAngle] : 175,
            this);
    else
        pcfdTarget = NULL;  //  pcfd will already have been set correctly

    Changed();
}

/******************************************************************************

  CFontInfo::FillKern

  This preps the passed CListCtrl, if necessary, and fills it with the kerning
  information.

******************************************************************************/

void    CFontInfo::FillKern(CListCtrl& clcView) {
    for (unsigned u = 0; u < m_csoaKern.GetSize(); u++) {
        CString csWork;
        CKern&  ckThis = *(CKern *) m_csoaKern[u];

        csWork.Format("%d", ckThis.Amount());
        int idItem = clcView.InsertItem(u, csWork);
        clcView.SetItemData(idItem, u);

        csWork.Format("0x%X", ckThis.First());
        clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);

        csWork.Format("0x%X", ckThis.Second());
        clcView.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u);
    }
}

/******************************************************************************

  CFontInfo::AddKern

  This method adds an additional kerning pair into the array. and also inserts
  it into the list view.

******************************************************************************/

void    CFontInfo::AddKern(WORD wFirst, WORD wSecond, short sAmount, 
                           CListCtrl& clcView) {
    for (unsigned u = 0; u < KernCount(); u ++) {
        CKern&  ckThis = *(CKern *) m_csoaKern[u];
        if  (ckThis.Second() < wSecond)
            continue;
        if  (ckThis.Second() > wSecond)
            break;
        _ASSERT(ckThis.First() != wFirst);
        if  (ckThis.First() < wFirst)
            continue;
        break;
    }

    FD_KERNINGPAIR  fdkp = { wFirst, wSecond, sAmount };
    m_csoaKern.InsertAt(u, new CKern(fdkp));

    CString csWork;
    csWork.Format("%d", sAmount);
    int idItem = clcView.InsertItem(u, csWork);
    clcView.SetItemData(idItem, u);

    csWork.Format("0x%X", wFirst);
    clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);

    csWork.Format("0x%X", wSecond);
    clcView.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u);
    Changed();
}

/******************************************************************************

  CFontInfo::SetKernAmount

  This will change the kern amount entry for the specified item.

******************************************************************************/

void    CFontInfo::SetKernAmount(unsigned u, short sAmount) {
    if  (u >= KernCount())  return;

    CKern   &ckThis = *(CKern *) m_csoaKern[u];

    if  (sAmount == ckThis.Amount())    return;

    ckThis.SetAmount(sAmount);
    Changed();
}

/******************************************************************************

  CFontInfo::FillWidths

  This preps the passed CListCtrl, if necessary, and fills it with the 
  character width information.

******************************************************************************/

void    CFontInfo::FillWidths(CListCtrl& clcView) {
    CWaitCursor cwc;
    clcView.SetItemCount(m_cpaGlyphs.GetSize());
    for (int u = 0; u < m_cpaGlyphs.GetSize(); u++) {
        if  (DBCSFont() && !m_cwaWidth[u])
            continue;   //  Don't display these code points.
        CString csWork;
        CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaGlyphs[u];

        csWork.Format("%d", m_cwaWidth[u]);
        int idItem = clcView.InsertItem(u, csWork);
        clcView.SetItemData(idItem, u);

        csWork.Format("0x%X", cghThis.CodePoint());
        clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);
    }
}

/******************************************************************************

  CFontInfo::SetWidth

  This member sets the width of a glyph.  It also updates the Maximum and
  Average width information if the font is not a DBCS font.

******************************************************************************/

void    CFontInfo::SetWidth(unsigned uGlyph, WORD wWidth) {

    m_cwaWidth[uGlyph] = wWidth;

    if  (!DBCSFont())
        CalculateWidths();
}

/******************************************************************************

  CFontInfoContainer class

  This class encapsulates one CFontInfo structure, and is used as a document
  class so we can leverage the MFC document/view architecture for editing this
  information both within the contet of the driver, and as a stand-alone file.

******************************************************************************/

IMPLEMENT_DYNCREATE(CFontInfoContainer, CDocument)

/******************************************************************************

  CFontInfoContainer::CFontInfoContainer()

  This constructor is used when the document is dynamically created- this will
  be when the user opens an existing font file, or creates a new one.

******************************************************************************/

CFontInfoContainer::CFontInfoContainer() {
    m_bEmbedded = FALSE;
    m_pcfi = new CFontInfo;
    m_pcfi -> NoteOwner(*this);
}

/******************************************************************************

  CFontInfoContainer::CFontInfoContainer(CFontInfo *pcfi, CString csPath) {

  This constructor is called when we invoke an editing view from the driver
  editor.  It gives us the font information to view and the name of the file
  to generate if the user decies to save the data from this view.

******************************************************************************/

CFontInfoContainer::CFontInfoContainer(CFontInfo *pcfi, CString csPath) {
    m_pcfi = pcfi;
    m_bEmbedded = TRUE;
    SetPathName(csPath, FALSE);
    m_pcfi -> NoteOwner(*this); //  Even when embedded, we're editing a file.
}

/******************************************************************************

  CFontInfo::OnNewDocument

  This is an override- it is called when we are asked to create new font
  information from scratch.  For now, this will just fail.

******************************************************************************/

BOOL CFontInfoContainer::OnNewDocument() {
    AfxMessageBox(IDS_Unimplemented);
    return  FALSE;
	//  return  m_pcfi && CDocument::OnNewDocument();
}

/******************************************************************************

  CFontInfo::~CFontInfo

  Our erstwhile destructor must destroy the font info if this wasn't an
  embedded view.

******************************************************************************/

CFontInfoContainer::~CFontInfoContainer() {
    if  (!m_bEmbedded && m_pcfi)
        delete  m_pcfi;
}


BEGIN_MESSAGE_MAP(CFontInfoContainer, CDocument)
	//{{AFX_MSG_MAP(CFontInfoContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer diagnostics

#ifdef _DEBUG
void CFontInfoContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CFontInfoContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer serialization

void CFontInfoContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) 	{
		// TODO: add storing code here
	}
	else 	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer commands

/******************************************************************************

  CFontInfoContainer::OnSaveDocument

  This is called in response to a Save or Save As.  We pass it directly to the
  CFontInfo for processing, rather than using the base class implementation,
  which would serialize the document.

******************************************************************************/

BOOL CFontInfoContainer::OnSaveDocument(LPCTSTR lpszPathName) {
    return m_pcfi -> Store(lpszPathName);
}

/******************************************************************************

  CFontInfoContainer::OnOpenDocument

  For now, I can not allow this to be done, as no GTT file is available.

******************************************************************************/

BOOL CFontInfoContainer::OnOpenDocument(LPCTSTR lpstrFile) {
    /*m_pcfi -> SetFileName(lpstrFile);
    return m_pcfi -> Load();*/
    return  FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\fontinfo.h ===
/******************************************************************************

  Header File:  Generic Font Information.H

  This file contains a set of classes intended to incorporate the information
  currently stored in the various font metric and related structures.  These
  classes are serializable, and will be capable of being loaded from and fed to
  the various other formats.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(GENERIC_FONT_INFORMATION)
#define GENERIC_FONT_INFORMATION

/******************************************************************************

  CFontDifference

  This class handles the information content analogous to the FONTDIFF
  structure.

******************************************************************************/

class AFX_EXT_CLASS CFontDifference {
    CWordArray  m_cwaMetrics;
    CBasicNode  *m_pcbnOwner;

public:
    CFontDifference(WORD wWeight, WORD wMax, WORD wAverage, WORD wAngle,
        CBasicNode *pcbn) {
        m_cwaMetrics.Add(wWeight);
        m_cwaMetrics.Add(wMax);
        m_cwaMetrics.Add(wAverage);
        m_cwaMetrics.Add(wAngle);
        m_pcbnOwner = pcbn;
    }

    CFontDifference(PBYTE pb, CBasicNode *pcbn);    //  Init from memory image

    //  Attributes

    enum {Weight, Max, Average, Angle};

    WORD    Metric(unsigned u) { return m_cwaMetrics[u]; }

    //  operations
    enum {OK, TooBig, Reversed};    //  Returns from SetMetric

    WORD    SetMetric(unsigned u, WORD wNew);
    void    Store(CFile& cfStore, WORD wfSelection);
};

/******************************************************************************

  CFontInfo class

  This primarily encapsulates the UFM file, but it also has to handle some PFM
  and IF stuff, so it truly is generic.

******************************************************************************/

class AFX_EXT_CLASS CFontInfo : public CProjectNode {
    //  Conversion-related members
    CString         m_csSource; //  The original PFM file name
    CByteArray      m_cbaPFM;   //  Loaded image of the PFM file
    
    //  Now for the real data member list, which is extensive!

    CStringArray    m_csaFamily;
    CString         m_csStyle, m_csFace, m_csUnique;    //  Various names
    CWordArray      m_cwaSpecial;   //  Special, little-used metrics
    BYTE            m_bCharacterSet, m_bPitchAndFamily;
    WORD            m_wWeight, m_wHeight;

    WORD            m_wAverageWidth, m_wMaximumIncrement, m_wfStyle;

    CByteArray      m_cbaSignificant;   //  Significant char codes (e.g., break)
    CWordArray      m_cwaSignificant;

    //  Kerning structure- CSafeObArray which contains the kerning pairs

    CSafeObArray    m_csoaKern;

    CInvocation     m_ciSelect, m_ciDeselect;
    WORD            m_widTranslation;   //  Translation table ID
    CGlyphMap*      m_pcgmTranslation;
    CFontDifference *m_pcfdBold, *m_pcfdItalic, *m_pcfdBoth;    //  Simulations

    //  UNIDRVINFO fields worth noticing

    BYTE            m_bLocation;    //  Enumerated bnelow
    BYTE            m_bTechnology;  //  Scalable font technology- see below
    BYTE            m_bfGeneral;    //  Also enumerated in public
    BOOL            m_bScalable;    //  Set if the font can be scaled.
    WORD            m_wXResolution, m_wYResolution;
    short           m_sPreAdjustY, m_sPostAdjustY, m_sCenterAdjustment;
    WORD            m_wPrivateData;

    //  EXTTEXTMETRIC specific fields

    WORD    m_wMaxScale, m_wMinScale, m_wScaleDevice;
    BYTE    m_bfScaleOrientation;

    //  The width table is GTT-dependent, hence this member contains all of
    //  the glyphs (extracted from the GTT).  But the widths are maintaned
    //  in a locally maintained array.

    CPtrArray       m_cpaGlyphs;
    CWordArray      m_cwaWidth;
    CGlyphHandle&   Glyph(unsigned uid) { 
        return *(CGlyphHandle *) m_cpaGlyphs[uid]; 
    }

    //  Private conversion support routines
    BOOL    MapPFM();   //  Assure the PFM file is loaded

    //  Private Editor support routines
    BOOL    DBCSFont() const {  //  This looks right, but no OFFICIAL way seems
        return  m_bCharacterSet > 127 && m_bCharacterSet < 145; //  to exist
    }

    void    CalculateWidths();  //  When variable widths change...
    DECLARE_SERIAL(CFontInfo)

public:

    CFontInfo();
    CFontInfo(const CFontInfo& cfiRef, WORD widCTT);    //  For cloning of UFMs
    ~CFontInfo();

    //  Attributes- Conversion Support

    const CString&  SourceName() const { return m_csSource; }

    //  Attributes - Editing (general info page)
    
    const CString&  FaceName() const { return m_csFace; }
    const CString&  StyleName() const { return m_csStyle; }
    const CString&  UniqueName() const { return m_csUnique; }
    const CString&  Family(unsigned u) const { return m_csaFamily[u]; }
    unsigned        Families() const { 
        return (unsigned) m_csaFamily.GetSize(); 
    }

    enum {Italic = 1, Underscore, StrikeOut = 0x10};
    WORD            GetStyle() const { return m_wfStyle; }
    BOOL            IsScalable() const { return !!m_bScalable; }
    BOOL            IsVariableWidth() const { return !!m_cpaGlyphs.GetSize(); }
    BOOL            CanKern() const { return !!m_csoaKern.GetSize(); }

    //  Attributes- Special metrics

    enum {CapH, LowerX, SuperSizeX, SuperSizeY, SubSizeX, SubSizeY, SuperMoveX,
        SuperMoveY, SubMoveX, SubMoveY, ItalicAngle, UnderSize, UnderOffset, 
        StrikeSize, StrikeOffset, Baseline, InterlineGap, Lowerp, Lowerd, 
        InternalLeading};

    const short     SpecialMetric(unsigned uIndex) const { 
        return (short) m_cwaSpecial[uIndex]; 
    }

    const WORD      Translation() const { return m_widTranslation; }

    //  Attributes- Editing (General Page #2)

    enum {Resident, Download, MainCartridge, Cartridge };

    DWORD   Location() const { return m_bLocation; }

    enum {IntelliFont, TrueType, PPDS, CAPSL, Type1, Type2 };

    DWORD   Technology() const { return m_bLocation; }

    WORD    Resolution(BOOL bX = TRUE) const { 
        return bX ? m_wXResolution : m_wYResolution; 
    }

    int     BaselineAdjustment(BOOL bPrePrint = TRUE) const {
        return bPrePrint ? m_sPreAdjustY : m_sPostAdjustY;
    }

    int     CenterAdjustment() const { return m_sCenterAdjustment; }
    short   PrivateData() const { return (short) m_wPrivateData; }

    CString GTTDescription() const;

    //  Attributes- General Metrics page

    WORD    Family() const { return m_bPitchAndFamily & 0xF0; }
    WORD    CharSet() const { return m_bCharacterSet; }
    WORD    Weight() const { return m_wWeight; }
    WORD    Height() const { return m_wHeight; }
    WORD    MaxWidth() const { return m_wMaximumIncrement; }
    WORD    AverageWidth() const { return m_wAverageWidth; }

    enum    {First, Last, Default, Break};
    WORD    SignificantChar(WORD wid, BOOL bUnicode = TRUE) const {
        return bUnicode ? m_cwaSignificant[wid] : m_cbaSignificant[wid];
    }

    void    InterceptItalic(CPoint& cpt) const;

    //  Attributes- Flags on Selection Page

    enum {ItalicSim, UnderSim, UseCR, BoldSim, Unused, StrikeSim, UseBKSP};

    BOOL    SimFlag(WORD weFlag) const { 
        return !!(m_bfGeneral & (1 << weFlag)); 
    }

    //  Attributes- Scaling (EXTTEXTMETRICS)

    BYTE  ScaleOrientation() const { return m_bfScaleOrientation & 3; }
    WORD  ScaleUnits(BOOL bDevice = TRUE) const {
        return bDevice ? m_wScaleDevice : 
            m_wHeight - m_cwaSpecial[InternalLeading];
    }

    WORD  ScaleLimit(BOOL bMaximum = TRUE) const {
        return  bMaximum ? m_wMaxScale : m_wMinScale;
    }

    //  Attributes- Character Widths page

    enum    {Less, More, Equal};

    unsigned    CompareWidths(unsigned u1, unsigned u2);

    //  Attributes- Kerning page

    void        MapKerning(CSafeMapWordToOb& csmw2o1, 
                           CSafeMapWordToOb& csmw2o2,
                           CWordArray& cwaPoints);
    
    unsigned    KernCount() const { return (unsigned) m_csoaKern.GetSize(); }

    unsigned    CompareKernAmount(unsigned u1, unsigned u2) const;
    unsigned    CompareKernFirst(unsigned u1, unsigned u2) const;
    unsigned    CompareKernSecond(unsigned u1, unsigned u2) const;

        //  Operations- Framework

    void    SetSourceName(LPCTSTR lpstrNew);
    BOOL    GetTranslation();
    BOOL    Generate(CString csPath);
    void    SetTranslation(WORD w) { m_widTranslation = w; }
    void    SetTranslation(CGlyphMap* pcgm) { m_pcgmTranslation = pcgm; }

    BOOL    Load(); //  Load the UFM file so it can be edited
    BOOL    Store(LPCTSTR lpstrFileName);    //  Save as the specified UFM file

    virtual CMDIChildWnd*   CreateEditor();
    virtual void    Serialize(CArchive& car);

    //  Operations- Editor General Page

    void    SetFaceName(LPCTSTR lpstrNew) { m_csFace = lpstrNew; Changed(); }
    void    SetStyleName(LPCTSTR lpstrNew) { m_csStyle = lpstrNew; Changed(); }
    void    SetUniqueName(LPCTSTR lpstrNew) { 
        m_csUnique = lpstrNew; 
        Changed(); 
    }
    BOOL    AddFamily(LPCTSTR lpstrNew);
    void    RemoveFamily(LPCTSTR lpstrDead);

    void    SetStyle(WORD wStyle) { m_wfStyle = wStyle; Changed(); }

    void    ChangePitch(BOOL bFixed = FALSE);
    void    SetScalability(BOOL bOn);

    //  Operations- Font Command and flag page
    
    CInvocation&    Selector(BOOL bSelect = TRUE) {
        return bSelect ? m_ciSelect : m_ciDeselect;
    }

    void    ToggleSimFlag(WORD w) { m_bfGeneral ^= (1 << w); }

    //  Operations- Editor General Page 2

    void    SetLocation(int i) { 
        if  (BYTE (i) != m_bLocation) {
            m_bLocation = (BYTE) i; 
            Changed();
        }
    }

    void    SetTechnology(int i) { 
        if  (BYTE (i) != m_bTechnology) {
            m_bTechnology = (BYTE) i; 
            Changed();
        }
    }

    void    SetCenterAdjustment(int i) { 
        if  (i == m_sCenterAdjustment)
            return;
        m_sCenterAdjustment = i;
        Changed();
    }

    void    SetPrivateData(short s) {
        if  (s != (short) m_wPrivateData) {
            m_wPrivateData = (WORD) s;
            Changed();
        }
    }

    void    SetBaselineAdjustment(BOOL bPre, short sNew) {
        if  (sNew == (bPre ? m_sPreAdjustY : m_sPostAdjustY))
            return;
        if  (bPre)
            m_sPreAdjustY = sNew;
        else
            m_sPostAdjustY = sNew;
        Changed();
    }

    void    SetResolution(BOOL bX, WORD wNew) {
        if  (wNew == (bX ? m_wXResolution : m_wYResolution))
            return;
        if  (bX)
            m_wXResolution = wNew;
        else
            m_wYResolution = wNew;
        Changed();
    }

    //  Operations- Font metrics page

    void    SetSpecial(unsigned ufMetric, short sSpecial);

    void    SetMaxWidth(WORD wWidth);
    BOOL    SetHeight(WORD wHeight);
    void    SetWeight(WORD wWeight) { m_wWeight = wWeight; Changed(); }
    void    SetFamily(BYTE bNew) { 
        m_bPitchAndFamily &= 0xF;
        m_bPitchAndFamily |= (bNew & 0xF0);
        Changed();
    }

    BOOL    SetCharacterSet(BYTE bNew);

    enum {OK, InvalidChar, DoubleByte};

    WORD    SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode);

    //  Operations- Scaling Page

    enum {ScaleOK, Reversed, NotWindowed};

    WORD    SetScaleLimit(BOOL bMax, WORD wNew);
    WORD    SetDeviceEmHeight(WORD wNew);

    void    SetScaleOrientation(BYTE bfNew) { 
        if  (bfNew & 3 != m_bfScaleOrientation) {
            m_bfScaleOrientation = bfNew & 3;
            Changed();
        }
    }

    //  Operations- simulation / difference page

    enum {ItalicDiff, BoldDiff, BothDiff};

    CFontDifference *Diff(unsigned u) {

        return u ? u == BothDiff ? m_pcfdBoth : m_pcfdBold : m_pcfdItalic;
    }

    void    EnableSim(unsigned uSim, BOOL bOn, CFontDifference*& pcfd);

    //  Operations- Kerning page

    void    FillKern(CListCtrl& clcView);   //  Fill the control
    void    AddKern(WORD wFirst, WORD wSecond, short sAmount, 
            CListCtrl& clcView);
    void    RemoveKern(unsigned u) { m_csoaKern.RemoveAt(u); Changed(); }   
    void    SetKernAmount(unsigned u, short sAmount);

    //  Operations- Widths page
    void    FillWidths(CListCtrl& clcView); //  Fill the control
    void    SetWidth(unsigned uGlyph, WORD wWidth);

};

/******************************************************************************

  CFontInfoContainer class

  This CDocument-derived class contains one CFontInfo structure- it allows to 
  edit the font information either from the driver, os from an individual file.

******************************************************************************/

class AFX_EXT_CLASS CFontInfoContainer : public CDocument {
    BOOL        m_bEmbedded;
    CFontInfo   *m_pcfi;

protected:
	CFontInfoContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFontInfoContainer)

// Attributes
public:
    CFontInfo   *Font() { return m_pcfi; }
// Operations
public:

    //  First a constructor for launching a view from the driver view.
    CFontInfoContainer(CFontInfo *pcfi, CString csPath);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontInfoContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFontInfoContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontInfoContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\gtt.cpp ===
/******************************************************************************

  Source File:  Glyph Translation.CPP

  This implements the classes which encode glyph mapping information.

  Copyright (c) 1997 by Microsoft Corporation.  All rights reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-13-97  Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

#include    "StdAfx.H"
#include    "..\Resource.H"

#include    "GTT.H"
#include    <CodePage.H>

struct sRLE {
    enum {Direct = 10, Paired, LengthOffset, LengthIndexOffset, Offset};
    WORD    m_wFormat;
    WORD    m_widRLE;   //  Must have unique "magic" value 0x78FE
    DWORD   m_dwcbThis; //  Total size of the memory image.
    WCHAR   m_wcFirst, m_wcLast;
    //  Handle mapping data follows
    DWORD   m_dwcbImage;    //  Size of the handle mapping data only
    DWORD   m_dwFlag;
    DWORD   m_dwcGlyphs, m_dwcRuns;
};

union uencCTT {
    WORD    wOffset;
    BYTE    m_bDirect;      //  This member is used in GTT only!
    BYTE    abPaired[2];
};

struct sMapTableEntry {
    enum {Composed = 1, Direct = 2, Paired = 4, Format = 7, SingleByte, 
            DoubleByte = 0x10, DBCS = 0x18, Replace = 0x20, Add = 0x40, 
            Disable = 0x80, PredefinedMask = 0xE0};
    BYTE    m_bCodePageIndex, m_bfType;
    uencCTT m_uectt;
};

//  Since I don't build the map table in memory, there is no need to declare
//  the fact that the array of entries follows it
struct sMapTable {
    DWORD   m_dwcbImage, m_dwcEntries;
    sMapTable(unsigned ucEntries) { 
        m_dwcbImage = sizeof *this + ucEntries * sizeof (sMapTableEntry);
        m_dwcEntries = ucEntries; }
};

//  Use a static for Code Page information- gets the max benefit from caching

static CCodePageInformation ccpi;

/******************************************************************************
    CInvocation class implementation

******************************************************************************/

IMPLEMENT_SERIAL(CInvocation, CObject, 0)

void    CInvocation::Encode(BYTE c, CString& cs) const {
    if  (isprint(c))
        if  (c != _TEXT('\\'))
            cs = c;
        else
            cs = _TEXT("\\\\");
    else
        cs.Format(_TEXT("\\x%2.2x"), c);
}

/******************************************************************************

  CInvocation::Init

  This copies a series of bytes into the invocation.  Since the data structures
  used to represent these lend themselves most readily to this, this is the
  normal method used in reading info from a file.

******************************************************************************/

void    CInvocation::Init(PBYTE pb, unsigned ucb) {
    m_cbaEncoding.RemoveAll();

    while   (ucb--)
        m_cbaEncoding.Add(*pb++);
}

void    CInvocation::GetInvocation(CString& cs) const {
    CString csWork;

    cs.Empty();
    for (int i = 0; i < m_cbaEncoding.GetSize(); i++) {
        Encode(m_cbaEncoding[i], csWork);
        cs += csWork;
    }
}

//  This member converts a C-Style encoding of an invocation into
//  byte form and stores it.

void    CInvocation::SetInvocation(LPCTSTR lpstrNew) {

    CString csWork(lpstrNew);

    m_cbaEncoding.RemoveAll();

    while   (!csWork.IsEmpty()) {
        CString csClean = csWork.SpanExcluding("\\");

        if  (!csClean.IsEmpty()) {
            for (int i = 0; i < csClean.GetLength(); i++)
                m_cbaEncoding.Add((BYTE) csClean[i]);
            csWork = csWork.Mid(csClean.GetLength());
            continue;
        }

        //  OK, we have something to decode

        switch  (csWork[1]) {

            case    _TEXT('r'):
                m_cbaEncoding.Add(13);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('n'):
                m_cbaEncoding.Add(10);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('b'):
                m_cbaEncoding.Add('\b');
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('\t'):
                m_cbaEncoding.Add(9);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('x'):
            case    _TEXT('X'):
                {
                    
                    CString csNumber = csWork.Mid(2,2).SpanIncluding(
                        _TEXT("1234567890abcdefABCDEF"));

                    csWork = csWork.Mid(2 + csNumber.GetLength());
                    unsigned    u;

#if defined(UNICODE) || defined(_UNICODE)
#define _tsscanf    swscanf
#else
#define _tsscanf    sscanf
#endif

                    _tsscanf(csNumber, _TEXT("%x"), &u);
                    m_cbaEncoding.Add(u);
                    continue;
                }

                //  TODO: octal encodings are pretty common

            default:
                m_cbaEncoding.Add(
					(BYTE) csWork[(int)(csWork.GetLength() != 1)]);
                csWork = csWork.Mid(2);
                continue;
        }
    }

    //  We've done it!
}

//  This member function records the offset for its image (if any) and updates
//  the given offset to reflect this

void    CInvocation::NoteOffset(DWORD& dwOffset) {
    m_dwOffset = Length() ? dwOffset : 0;
    dwOffset += Length();
}

//  I/O routines, both native and document form

void    CInvocation::WriteSelf(CFile& cfTarget) const {
    DWORD   dwWork = Length();
    cfTarget.Write(&dwWork, sizeof dwWork);
    cfTarget.Write(&m_dwOffset, sizeof m_dwOffset);
}

void    CInvocation::WriteEncoding(CFile& cfTarget, BOOL bWriteLength) const {
    if  (bWriteLength) {
        WORD w = Length();
        cfTarget.Write(&w, sizeof w);
    }

    cfTarget.Write(m_cbaEncoding.GetData(), Length());
}

void    CInvocation::Serialize(CArchive& car) {
    CObject::Serialize(car);
    m_cbaEncoding.Serialize(car);
}

/******************************************************************************
    CGlyphHandle class implementation

******************************************************************************/

unsigned    CGlyphHandle::CompactSize() const {
    return  (m_ciEncoding.Length() < 3) ? 0 : m_ciEncoding.Length();
}

/******************************************************************************

  CGlyphHandle::operator ==

  Returns true if the encoding, code point, and code page IDs (but maybe not
  the indices) are the same.

******************************************************************************/

BOOL    CGlyphHandle::operator ==(CGlyphHandle& cghRef) {

    if  (cghRef.m_wCodePoint != m_wCodePoint || 
        cghRef.m_dwCodePage != m_dwCodePage ||
        m_ciEncoding.Length() != cghRef.m_ciEncoding.Length())
        return  FALSE;

    for (int i = 0; i < (int) m_ciEncoding.Length(); i++)
        if  (m_ciEncoding[i] != cghRef.m_ciEncoding[i])
            return  FALSE;

    return  TRUE;
}

/******************************************************************************

  CGlyphHandle::Init

  This function has three overloads, for intializing from direc, paired, or
  composed data.

******************************************************************************/

void    CGlyphHandle::Init(BYTE b, WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(&b, 1);
}

void    CGlyphHandle::Init(BYTE ab[2], WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(ab, 2);
}

void    CGlyphHandle::Init(PBYTE pb, unsigned ucb, WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(pb, ucb);
}

/******************************************************************************

  CGlyphHandle::operator =

  This is a copy (assignment) operator for the class.

******************************************************************************/

CGlyphHandle&   CGlyphHandle::operator =(CGlyphHandle& cghTemplate) {
    m_dwCodePage = cghTemplate.m_dwCodePage;
    m_dwidCodePage = cghTemplate.m_dwidCodePage;
    m_wCodePoint = cghTemplate.m_wCodePoint;
    m_ciEncoding = cghTemplate.m_ciEncoding;
    return  *this;
}

//  This member records the current offset for the data in RLE format, and
//  then updates it to account for the length of any data that will go into
//  the extra storage at the end of the file/

void    CGlyphHandle::RLEOffset(DWORD& dwOffset, const BOOL bCompact) {
    if  (m_ciEncoding.Length() < 3)
        return; //  Don't need it, and don't use it!

    m_dwOffset = dwOffset;

    dwOffset += bCompact ? CompactSize() : MaximumSize();
}

/******************************************************************************

  CGlyphHandle::GTTOffset

  This member records the current offset for where our data will go, then adds
  the length of the encoding string to it and updates the offset.  It will only
  be updated if the encoding must be composed data.  The encoding length
  includes a WORD length in the GTT world.  Data of 1 byte, or of 2 if DBCS or
  a Paired font, does not add any length.

******************************************************************************/

void    CGlyphHandle::GTTOffset(DWORD& dwOffset, BOOL bPaired) {
    if  (m_ciEncoding.Length() > 
         (unsigned) 1 + (bPaired || ccpi.IsDBCS(m_dwCodePage))) {
        m_dwOffset = dwOffset;
        dwOffset += m_ciEncoding.Length() + sizeof m_wIndex;
    }
    else
        m_dwOffset = 0;
}

//  These members write our vital stuff to a given file.

void    CGlyphHandle::WriteRLE(CFile& cfTarget, WORD wFormat) const {
    //  This is the RLE-specific glyph handle encoding
    
    union {
        DWORD   dwOffset;
        struct {
            union   {
                struct {
                    BYTE    bFirst, bSecond;
                };
                WORD    wOffset;
            };
            union   {
                struct {
                    BYTE    bIndexOrHiOffset, bLength;
                };
                WORD    wIndex;
            };
        };
    };

    switch  (wFormat) {
        case    sRLE::Direct:
        case    sRLE::Paired:

            bFirst = m_ciEncoding[0];
            bSecond = m_ciEncoding[1];
            wIndex = m_wIndex;
            break;

        case    sRLE::LengthIndexOffset:

            if  (!CompactSize()) { //  Encode it in the first two bytes
                bFirst = m_ciEncoding[0];
                bSecond = m_ciEncoding[1];
            }
            else
                wOffset = (WORD) m_dwOffset;

            bIndexOrHiOffset = (BYTE) m_wIndex;
            bLength = m_ciEncoding.Length();
            break;

        case    sRLE::LengthOffset:

            if  (!CompactSize()) { //  Encode it in the first two bytes
                bFirst = m_ciEncoding[0];
                bSecond = m_ciEncoding[1];
                bIndexOrHiOffset = (BYTE) m_wIndex;
                bLength = m_ciEncoding.Length();
                break;
            }
            
            dwOffset = m_dwOffset;
            bLength = m_ciEncoding.Length();
            break;

        case    sRLE::Offset:
            dwOffset = m_dwOffset;
            break;

        default:
            _ASSERTE(FALSE);
            //  Should probably throw an exception...
    }

    cfTarget.Write(&dwOffset, sizeof dwOffset);
}

/******************************************************************************

  CGlyphHandle::WriteGTT

  This member function writes the GTT map table entry for this glyph in the
  requested format.

******************************************************************************/

static BYTE abFlags[] = {sMapTableEntry::Replace, sMapTableEntry::Add,
sMapTableEntry::Disable};

void    CGlyphHandle::WriteGTT(CFile& cfTarget, BOOL bPredefined) const {
    sMapTableEntry  smte;

    smte.m_bCodePageIndex = (bPredefined && m_wPredefined == Removed) ? 
        0 : (BYTE) m_dwidCodePage;

    //  GTTOffset set m_dwOffset if Composed is needed.  Otherwise we can tell
    //  the proper flags by looking at the length and whether it is DBCS or not

    if  (m_dwOffset) {
        smte.m_uectt.wOffset = (WORD) m_dwOffset;
        smte.m_bfType = sMapTableEntry::Composed;
    }
    else {
        smte.m_bfType = ccpi.IsDBCS(m_dwCodePage) ?
            ((m_ciEncoding.Length() == 2) ? 
            sMapTableEntry::Paired : sMapTableEntry::Direct ) | 
            (ccpi.IsDBCS(m_dwCodePage, m_wCodePoint) ?
            sMapTableEntry::DoubleByte : sMapTableEntry::SingleByte) :
            (m_ciEncoding.Length() == 2) ? 
            sMapTableEntry::Paired : sMapTableEntry::Direct;

        smte.m_uectt.abPaired[0] = m_ciEncoding[0];
        smte.m_uectt.abPaired[1] = m_ciEncoding[1];
    }

    if  (bPredefined)
        smte.m_bfType |= abFlags[m_wPredefined];

    //  Just write it out!
    cfTarget.Write(&smte, sizeof smte);
}

/******************************************************************************

  CGlyphHandle::WriteEncoding

  This method writes the encoding to to the file in the desired format.  The
  formats are:

  GTT- write nothing if not composed.  If composed, write the length, and then
  the encoding.

  RLESmall- just the encoding
  RLEBig- the index and the encoding.

******************************************************************************/

void    CGlyphHandle::WriteEncoding(CFile& cfTarget, WORD wfHow) const {
    if  (!m_dwOffset)
        return; //  Nothing to write

    if  (wfHow == RLEBig)
        cfTarget.Write(&m_wIndex, sizeof m_wIndex);

    m_ciEncoding.WriteEncoding(cfTarget, wfHow == GTT);

}

/******************************************************************************

  CRunRecord class implementation

******************************************************************************/

CRunRecord::CRunRecord(CGlyphHandle *pcgh, CRunRecord *pcrrPrevious) {
    m_wFirst = pcgh -> CodePoint();
    m_wcGlyphs = 1;
    m_dwOffset = 0;
    m_cpaGlyphs.Add(pcgh);

    //  Maintain that old double chain!

    m_pcrrPrevious = pcrrPrevious;
    m_pcrrNext = m_pcrrPrevious -> m_pcrrNext;
    m_pcrrPrevious -> m_pcrrNext = this;
    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
}

/******************************************************************************

  CRunRecord::CRunRecord(CRunRecord *pcrrPrevious, WORD wFirst)

  This private constructor is the second tail record initializer.  It is called
  when a run is split due to a glyph deletion.  In this case, we need to hook
  into the chain, then fill in the details from our predecessor.  wFirst tells
  us where to begin extracting data from said predecessor.

******************************************************************************/

CRunRecord::CRunRecord(CRunRecord* pcrrPrevious, WORD wFirst) {
    m_pcrrPrevious = pcrrPrevious;
    m_pcrrNext = pcrrPrevious -> m_pcrrNext;

    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
    m_pcrrPrevious -> m_pcrrNext = this;

    m_wFirst = m_wcGlyphs = 0;
    m_dwOffset = 0;

    //  That's the normal empty initialization.  Now, er fill ourselves from
    //  our predecessor

    for (; wFirst < pcrrPrevious -> Glyphs(); wFirst++)
        Add(&pcrrPrevious -> Glyph(wFirst));
}

/******************************************************************************

  CRunRecord::CRunRecord(CRunRecord *pcrrPrevious)

  This private constructor is the third and final tail record initializer.  It
  makes an exact duplicate of the previous record, then links itself into the
  chain appropriately.

  This constructor is necessary when a new code point is inserted ahead of the
  earliest code point in the set of run records without extending the first 
  run.

******************************************************************************/

CRunRecord::CRunRecord(CRunRecord *pcrrPrevious) {
    m_wFirst = pcrrPrevious -> m_wFirst;
    m_wcGlyphs = pcrrPrevious -> m_wcGlyphs;
    m_pcrrNext = pcrrPrevious -> m_pcrrNext;
    m_pcrrPrevious = pcrrPrevious;
    m_pcrrPrevious -> m_pcrrNext = this;
    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
    m_cpaGlyphs.Copy(pcrrPrevious -> m_cpaGlyphs);
}

//  Initialize empty- this is used for the root record only

CRunRecord::CRunRecord() {
    m_wFirst = m_wcGlyphs = 0;
    m_dwOffset = 0;
    m_pcrrNext = m_pcrrPrevious = NULL;
}

CRunRecord::~CRunRecord() {
    if  (m_pcrrNext)
        delete  m_pcrrNext;
}

unsigned    CRunRecord::TotalGlyphs() const { 
    return m_pcrrNext ? 
        m_wcGlyphs + m_pcrrNext -> TotalGlyphs() : m_wcGlyphs;
}

BOOL    CRunRecord::MustCompose() const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        if  (GlyphData(u).CompactSize())
            return  TRUE;   //   No need to look further

    return  m_pcrrNext ? m_pcrrNext -> MustCompose() : FALSE;
}

unsigned    CRunRecord::ExtraNeeded(BOOL bCompact) {
    unsigned uNeeded = 0;

    for (unsigned u = 0; u < m_wcGlyphs; u++)
        uNeeded += bCompact ? Glyph(u).CompactSize() : Glyph(u).MaximumSize();

    return  uNeeded + (m_pcrrNext ? m_pcrrNext -> ExtraNeeded() : 0);
}

/******************************************************************************

  CRunRecord::GetGlyph()

  This returns the nth handle in the run.  We use recursion.  This could get
  bad enough in terms of performance (ony used to fill glyph map page in 
  editor) that we drop it, but I'll try it first.

******************************************************************************/

CGlyphHandle*   CRunRecord::GetGlyph(unsigned u) const {

    if  (u < m_wcGlyphs)
        return  (CGlyphHandle *) m_cpaGlyphs[u];
    return  m_pcrrNext ? m_pcrrNext -> GetGlyph(u - m_wcGlyphs) : NULL;
}

/******************************************************************************

  CRunRecord::Add

  This member adds a glyph to the set of run records.  This can mean adding an
  additional record at the beginning or end of the set, extending an existing 
  record at either the beginning or end, and in those cases, orentiay merging 
  two records together.

******************************************************************************/

void    CRunRecord::Add(CGlyphHandle *pcgh) {
    WCHAR   wcNew = pcgh -> CodePoint();
    //  If the glyph is already in the run, just update the info on it.

    if  (m_wcGlyphs && wcNew >= m_wFirst && wcNew < m_wFirst + m_wcGlyphs){
        m_cpaGlyphs.SetAt(wcNew - m_wFirst, pcgh);
        return;
    }

    //  If this is the first record, and the glyph falls ahead of our first
    //  entry, we must clone ourselves, and become a one-glyph run.  We cannot
    //  insert a record in front of oursleves as we are embedded in the
    //  glyph map structure directly.

    if  (m_wcGlyphs && wcNew < m_wFirst - 1) {
        //  This can only happen to the first record- otherwise the tail logic
        //  below would prevent this occurence

        _ASSERTE(!m_pcrrPrevious);

        //  Clone us, using the copy contructor

        CRunRecord  *pcrr = new CRunRecord(this);

        m_wFirst = pcgh -> CodePoint();
        m_wcGlyphs = 1;
        m_cpaGlyphs.RemoveAll();
        m_cpaGlyphs.Add(pcgh);
        return;
    }

    if  (m_wcGlyphs && wcNew != m_wFirst + m_wcGlyphs &&
         m_wFirst && wcNew != m_wFirst - 1) {

        //  This belongs in some other record- pass it down the line, or
        //  append a new one.

        if  (m_pcrrNext)
            //  If this falls ahead of the next record, we must insert one now

            if  (wcNew < m_pcrrNext -> m_wFirst - 1) 
                m_pcrrNext = new CRunRecord(pcgh, this);
            else
                m_pcrrNext -> Add(pcgh);
        else
            m_pcrrNext = new CRunRecord(pcgh, this);
    }
    else {
        //  We're adding either at the front or the back, so do it right!
        if  (m_wFirst > wcNew) {
            m_cpaGlyphs.InsertAt(0, pcgh);
            m_wFirst = wcNew;
        }
        else
            m_cpaGlyphs.Add(pcgh);

        //  This belonged here, so add it in- the root record begins with
        //  0 glyphs, so if this is the first, keep track of it.

        if  (!m_wcGlyphs++)
            m_wFirst = wcNew;

        //  If there is a following run, see if we need to merge it.

        if  (m_pcrrNext && 
             m_pcrrNext -> m_wFirst == m_wFirst + m_wcGlyphs) {
            //  Merge the records.

            m_cpaGlyphs.Append(m_pcrrNext -> m_cpaGlyphs);
            m_wcGlyphs += m_pcrrNext -> m_wcGlyphs;
            
            //  Time to update the list.  The class destructor removes the
            //  tail records, so that pointer must be set to NULL before the
            //  merged record is deleted.

            CRunRecord *pcrrDead = m_pcrrNext;

            m_pcrrNext = m_pcrrNext -> m_pcrrNext;

            if  (m_pcrrNext)
                m_pcrrNext -> m_pcrrPrevious = this;

            pcrrDead -> m_pcrrNext = NULL;  //  Avoid destructor overkill
            pcrrDead -> m_wcGlyphs = 0;     //  Ditto
            delete  pcrrDead;
        }
    }
}

/******************************************************************************

  CRunRecord::Delete

  This member deletes a given glyph from the set of runs.  Deleting an entry is
  messy- it means splitting the record, unless we were so fortunate as to
  merely lop off one of the ends.

******************************************************************************/

void    CRunRecord::Delete(WORD wCodePoint) {
    //  If this isn't the right record, recurse or return as appropriate

    if  (wCodePoint < m_wFirst)
        return;

    if  (wCodePoint >= m_wFirst + m_wcGlyphs) {
        if  (m_pcrrNext)
            m_pcrrNext -> Delete(wCodePoint);
        return;
    }

    WORD    wIndex = wCodePoint - m_wFirst;

    //  Did we get lucky and hit the first or the last?

    if  (!wIndex || wIndex == -1 + m_wcGlyphs) {
        //  If there is only one entry in this run, kill it.

        if  (m_wcGlyphs == 1) {
            if  (m_pcrrPrevious) {    //  Not the first, then die!
                m_pcrrPrevious -> m_pcrrNext = m_pcrrNext;
                if  (m_pcrrNext)
                    m_pcrrNext -> m_pcrrPrevious = m_pcrrPrevious;
                m_pcrrNext = NULL;  //  We no longer have a follwing
                delete  this;
                return;             //  It is finished
            }

            //  We are the first.  If there's someone after us, get their stuff
            //  and make it ours- otherwise, zero everything.

            if  (m_pcrrNext) {
                m_cpaGlyphs.Copy(m_pcrrNext -> m_cpaGlyphs);
                m_wFirst = m_pcrrNext -> m_wFirst;
                m_wcGlyphs = m_pcrrNext -> m_wcGlyphs;
                CRunRecord *pcrrVictim = m_pcrrNext;
                m_pcrrNext = m_pcrrNext -> m_pcrrNext;
                m_pcrrNext -> m_pcrrPrevious = this;
                pcrrVictim -> m_pcrrNext = NULL;
                delete  pcrrVictim;
            }
            else {
                m_cpaGlyphs.RemoveAll();
                m_wFirst = m_wcGlyphs = 0;
            }
            m_dwOffset = 0;
            return;
        }

        //  OK, we can now kill the offending entry

        m_cpaGlyphs.RemoveAt(wIndex);
        m_wcGlyphs--;

        //  Yes, the following line is trick code.  It's good for the soul...
        m_wFirst += !wIndex;
        return; //  The glyph, she be toast.
    }

    //  Alas, this means we must split the record.

    //  Since this means a new one must be made, let a new constructor do
    //  most of the dirty work for us.

    m_pcrrNext = new CRunRecord(this, wIndex + 1);

    _ASSERTE(m_pcrrNext);   //  We lose that, we might as well die...

    //  Delete everything after the offending member

    m_cpaGlyphs.RemoveAt(wIndex, m_wcGlyphs - wIndex);

    //  Well, that about settles it, eh!
    m_wcGlyphs = wIndex;
}

/******************************************************************************

  CRunRecord::Empty

  This method will be called if the glyph map is being re-initialized.  We set
  everything back to its initial state, and delete any tail records.

******************************************************************************/

void    CRunRecord::Empty() {

    if  (m_pcrrNext)
        delete  m_pcrrNext;

    m_pcrrNext = 0;

    m_wFirst = m_wcGlyphs = 0;

    m_cpaGlyphs.RemoveAll();
}

/******************************************************************************

  CRunRecord::NoteOffset

  This routine is given an offset which is to be managed in the run- the
  management needed differs depending upon the file image being produced, so
  we use a parameter to describe the tyoe being output.

  In any event, the offset is passed by reference, and updated by each run
  record in the set, in turn.

******************************************************************************/

void    CRunRecord::NoteOffset(DWORD& dwOffset, BOOL bRLE, BOOL bPaired) {
    if  (bRLE) {
        m_dwOffset = dwOffset;
        dwOffset += m_wcGlyphs * 
            ((CGlyphHandle *) m_cpaGlyphs[0]) -> RLESize();
    }
    else
        for (unsigned u = 0; u < Glyphs(); u++)
            Glyph(u).GTTOffset(dwOffset, bPaired);

    //  Recurse if there's more...
    if  (m_pcrrNext)
        m_pcrrNext -> NoteOffset(dwOffset, bRLE, bPaired);
}

//  This routine passes a DWORD to each glyph handle denoting where it can
//  store its extra data.  Each updates the offset, if necessary.

//  We then recursively call each descendant to do the same thing.

void    CRunRecord::NoteExtraOffset(DWORD &dwOffset, const BOOL bCompact) {

    for (unsigned u = 0; u < m_wcGlyphs; u++)
        Glyph(u).RLEOffset(dwOffset, bCompact);

    if  (m_pcrrNext)
        m_pcrrNext -> NoteExtraOffset(dwOffset, bCompact);
}

//  File output functions-  These are all basically recursive.  The callee does
//  its thing, then passes it on down the chain.  Since this is the order RLE
//  and GTT are written in, everything is fine.

void    CRunRecord::WriteSelf(CFile& cfTarget, BOOL bRLE) const {
    cfTarget.Write(this, Size(bRLE));
    if  (m_pcrrNext)
        m_pcrrNext -> WriteSelf(cfTarget, bRLE);
}

void    CRunRecord::WriteHandles(CFile& cfTarget, WORD wFormat) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteRLE(cfTarget, wFormat);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteHandles(cfTarget, wFormat);
}

//  Member for writing the total set of GTT Map Table Entries

void    CRunRecord::WriteMapTable(CFile& cfTarget, BOOL bPredefined) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteGTT(cfTarget, bPredefined);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteMapTable(cfTarget, bPredefined);
}

/******************************************************************************

  CRunRecord::WriteEncodings

  This calls each glyph in the run record in ascending order to have it write
  its encoding into the file in the given format.  It then recursively calls
  the next run record.

******************************************************************************/

void    CRunRecord::WriteEncodings(CFile& cfTarget, WORD wfHow) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteEncoding(cfTarget, wfHow);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteEncodings(cfTarget, wfHow);
}

/******************************************************************************

  CCodePageData class implementation

******************************************************************************/

/******************************************************************************

  CCodePageData::Invocation

  This member function returns (in C-style string declaration form) the data to
  send to the printer to perform the requested select/deselect of this code
  page.

******************************************************************************/

void    CCodePageData::Invocation(CString& csReturn, BOOL bSelect) const {
    if  (bSelect)
        m_ciSelect.GetInvocation(csReturn);
    else
        m_ciDeselect.GetInvocation(csReturn);
}

/******************************************************************************

  CCodePageData::SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect)

  This member function sets the select or deselect sring using a string which
  is decoded as a C-style string declaration.

******************************************************************************/

void    CCodePageData::SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect) {

    if  (bSelect)
        m_ciSelect.SetInvocation(lpstrInvoke);
    else
        m_ciDeselect.SetInvocation(lpstrInvoke);
}

/******************************************************************************

  CCodePageData::SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect)

  This member function initializes one of the two CInvocation members via its
  Init function.

******************************************************************************/

void    CCodePageData::SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect) {
    if  (bSelect)
        m_ciSelect.Init(pb, ucb);
    else
        m_ciDeselect.Init(pb, ucb);
}

/******************************************************************************

  CCodePageData::NoteOffsets

  This member function is passed an offset at which it will record its 
  invocation strings.  It simply funnels the call to each invocation member,
  which updates the value as appropriate.

******************************************************************************/

void    CCodePageData::NoteOffsets(DWORD& dwOffset) {
    m_ciSelect.NoteOffset(dwOffset);
    m_ciDeselect.NoteOffset(dwOffset);
}

//  Write the id and invocation location information to the file

void    CCodePageData::WriteSelf(CFile& cfTarget) {
    cfTarget.Write(&m_dwid, sizeof m_dwid);
    m_ciSelect.WriteSelf(cfTarget);
    m_ciDeselect.WriteSelf(cfTarget);
}

//  Write the invocation strings to a file.

void    CCodePageData::WriteInvocation(CFile& cfTarget) {
    m_ciSelect.WriteEncoding(cfTarget);
    m_ciDeselect.WriteEncoding(cfTarget);
}

/******************************************************************************

  CGlyphMap class implementation

******************************************************************************/

IMPLEMENT_SERIAL(CGlyphMap, CProjectNode, 0)

//  The GTT header

struct sGTTHeader {
    DWORD   m_dwcbImage;
    enum    {Version1Point0 = 0x10000};
    DWORD   m_dwVersion;
    DWORD   m_dwfControl;   //  Any flags defined?
    long    m_lidPredefined;
    DWORD   m_dwcGlyphs;
    DWORD   m_dwcRuns;
    DWORD   m_dwofRuns;
    DWORD   m_dwcCodePages;
    DWORD   m_dwofCodePages;
    DWORD   m_dwofMapTable;
    DWORD   m_dwReserved[2];
    sGTTHeader() { 
        memset(this, 0, sizeof *this);
        m_dwVersion = Version1Point0; 
        m_lidPredefined = CGlyphMap::NoPredefined;
        m_dwcbImage = sizeof *this;
    }
};

CSafeMapWordToOb    CGlyphMap::m_csmw2oPredefined;

/******************************************************************************

  CGlyphMap::Public

  This is a static member function which will return a pointer to one of the
  predefined GTT files, after loading it if necessary.

******************************************************************************/

CGlyphMap*  CGlyphMap::Public(WORD wID) {

    //  The easy part comes if it is already loaded

    CObject*    pco;

    if  (m_csmw2oPredefined.Lookup(wID, pco))
        return  (CGlyphMap*) pco;

    //  The hard part

    if  (!FindResource(AfxGetResourceHandle(), 
         MAKEINTRESOURCE(wID ? -(short) wID : IDR_CP1252),
         MAKEINTRESOURCE(IDR_GLYPHMAP)))
        return  NULL;   //  No such predefined table

    CGlyphMap   *pcgm = new CGlyphMap;
    pcgm -> m_csName.LoadString(IDS_DefaultPage + wID);

    pcgm -> SetID(wID);

    if  (pcgm -> Load()) {
        m_csmw2oPredefined[wID] = pcgm;
        return  pcgm;
    }

    delete  pcgm;   //  It didn't work
    return  NULL;
}

/******************************************************************************

  CGlyphMap::MergePredefined

  This merges in fresh glyph handles from the predefined GTT, then removes all
  glyphs destined for the gallows.

******************************************************************************/

void    CGlyphMap::MergePredefined() {
    if  (m_lidPredefined == NoPredefined)
        return;

    CWaitCursor cwc;    //  This takes a long time, I'll bet!

    CGlyphMap   *pcgm = Public((WORD) m_lidPredefined);

    if  (!pcgm)
        AfxThrowNotSupportedException();

    //  First, add any new code pages in the predefined GTT
    CMapWordToDWord cmw2dPageMap;   //  Map PDT code pages' indices to our own

    for (unsigned u = 0; u < pcgm -> CodePages(); u++) {
        for (unsigned u2 = 0; u2 < CodePages(); u2++)
            if  (PageID(u2) == pcgm -> PageID(u))
                break;

            if  (u2 == CodePages())
                AddCodePage(pcgm -> PageID(u));

            cmw2dPageMap[u] = u2;
    }

    CPtrArray   cpaTemplate;
    pcgm -> Collect(cpaTemplate);

    for (int i = 0; i < cpaTemplate.GetSize(); i++) {
        CGlyphHandle&   cghTemplate = *(CGlyphHandle *) cpaTemplate[i];
        CObject*    pco;

        if  (!m_csmw2oEncodings.Lookup(cghTemplate.CodePoint(), pco)) {
            //  Add this one, and map the code page info.
            CGlyphHandle*   pcgh = new CGlyphHandle;
            if  (!pcgh)
                AfxThrowMemoryException();

            *pcgh = cghTemplate;
            pcgh -> SetCodePage(cmw2dPageMap[cghTemplate.CodePage()], 
                pcgm -> PageID(cghTemplate.CodePage()));

            m_csmw2oEncodings[cghTemplate.CodePoint()] = pcgh;
            m_crr.Add(pcgh);
        }
    }

    //  Now, all of the new pages have been added.  We must remove all points
    //  listed as "Remove".

    Collect(cpaTemplate);   //  Get all of the handles for ourselves

    for (i = cpaTemplate.GetSize(); i--; ) {
        CGlyphHandle&   cgh = *(CGlyphHandle *) cpaTemplate[i];

        if  (cgh.Predefined() == CGlyphHandle::Removed)
            DeleteGlyph(cgh.CodePoint());
    }
}

/******************************************************************************

  CGlyphMap::UnmergePredefined

  This is the harder of the two predfined handlers, if that is conceivable.
  First (unless asked not to), glkyphs must be added to mark those missing from
  the predefined GTT.

  Then, the entire set is compared to the PDT, so they can be removed as
  equivalent, or flagged as added or modified.

******************************************************************************/

void    CGlyphMap::UnmergePredefined(BOOL bTrackRemovals) {
    if  (m_lidPredefined == NoPredefined)
        return;

    CWaitCursor cwc;    //  This takes a long time, I'll bet!

    CGlyphMap   *pcgm = Public((WORD) m_lidPredefined);

    if  (!pcgm)
        AfxThrowNotSupportedException();

    CPtrArray   cpaPDT;

    if  (bTrackRemovals) {
        pcgm -> Collect(cpaPDT);

        for (int i = 0; i < cpaPDT.GetSize(); i++) {
            CGlyphHandle&   cgh = *(CGlyphHandle*) cpaPDT[i];

            CObject*    pco;

            if  (m_csmw2oEncodings.Lookup(cgh.CodePoint(), pco))
                continue;

            //  This point was removed from the predefined set, so add it to
            //  ours, and mark it as such.

            CGlyphHandle    *pcghCorpse = new CGlyphHandle();

            if  (!pcghCorpse)
                AfxThrowMemoryException();

            *pcghCorpse = cgh;

            pcghCorpse -> SetPredefined(CGlyphHandle::Removed);

            m_csmw2oEncodings[cgh.CodePoint()] = pcghCorpse;
            m_crr.Add(pcghCorpse);
        }
    }

    //  Mark all of the glyphs in our set, now.  Also mark the code pages used

    Collect(cpaPDT);

    CMapWordToDWord cmw2dPages;

    for (int i = cpaPDT.GetSize(); i--; ) {
        CGlyphHandle&   cgh = *(CGlyphHandle*) cpaPDT[i];

        union {
            CObject         *pco;
            CGlyphHandle    *pcgh;
        };

        if  (pcgm -> m_csmw2oEncodings.Lookup(cgh.CodePoint(), pco))
            if  (*pcgh == cgh) {
                if  (cgh.Predefined() == CGlyphHandle::Removed)
                    continue;   //  Already accounted for

                if  (m_bPaired != pcgm -> m_bPaired && cgh.PairedRelevant())
                    cgh.SetPredefined(CGlyphHandle::Modified);
                else {
                    DeleteGlyph(cgh.CodePoint());    //  Unmodified
                    continue;
                }
            }
            else
                cgh.SetPredefined(CGlyphHandle::Modified);
        else
            cgh.SetPredefined(CGlyphHandle::Added);

        cmw2dPages[PageID(cgh.CodePage())]++;   //  Only track these pages
    }

    //  Remove the unused code pages, unless they have selections

    for (unsigned u = CodePages(); u--; )
        if  (!cmw2dPages[PageID(u)])
            if  (CodePage(u).NoInvocation())
                RemovePage(u, !u);
}

/******************************************************************************

  CGlyphMap::GenerateRuns

  This member will create the run records by iterating over the mapped glyph 
  handles.

******************************************************************************/

void    CGlyphMap::GenerateRuns() {
    if  (m_crr.TotalGlyphs() == Glyphs())
        return;

    for (POSITION pos = m_csmw2oEncodings.GetStartPosition(); pos;) {
        WORD    wValue;
        union {
            CObject     *pco;
            CGlyphHandle    *pcgh;
        };

        m_csmw2oEncodings.GetNextAssoc(pos, wValue, pco);
        m_crr.Add(pcgh);
    }
}

/******************************************************************************

  CGlyphMap::Serialize

  This member function serializes the Glyph map, i.e., loads or stores it into
  a persistent object store.  Only the project-level information is stored.

  The file will be loaded using the project-level data.

******************************************************************************/

void    CGlyphMap::Serialize(CArchive& car) {
    CProjectNode::Serialize(car);
    if  (car.IsLoading()) {
        car >> m_wID;
    }
    else {
        car << m_wID;
    }
}

/******************************************************************************

  CGlyphMap::CGlyphMap

  The class constructor, in addition to setting some default values, builds an
  array of IDs for the CProjectNode class from which it is derived to use in
  building the context menu in the driver/project view tree.

  It also allocates a single code page record for the current ANSI page, so we
  always have a default page.

******************************************************************************/

CGlyphMap::CGlyphMap() {
    m_cfn.SetExtension(_T(".GTT"));
    m_bPaired = FALSE;
    m_lidPredefined = NoPredefined;

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_RenameItem);

    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_GenerateOne);

    //  Initialy, let the default code page be the current ANSI page, if this
    //  is not a DBCS locale.  Otherwise, use 1252, as no DBCS CTT file can be
    //  generated with UniTool
    for (WORD w = 0; w < 256; w++)
        if  (IsDBCSLeadByte((BYTE) w))
            break;;
        m_csoaCodePage.Add(new CCodePageData(w < 256 ? 1252 : GetACP()));
}

/******************************************************************************

  CGlyphMap::CodePages(CDWordArray &cdaReturn)

  This overload fills a DWordArray with the code page IDs.

******************************************************************************/

void    CGlyphMap::CodePages(CDWordArray &cdaReturn) const {
    cdaReturn.RemoveAll();
    for (unsigned u = 0; u < CodePages(); u++)
        cdaReturn.Add(CodePage(u).Page());
}

/******************************************************************************

  CGlyphMap::PageName


  This member returns the name of a particular code page, by index.

******************************************************************************/

CString CGlyphMap::PageName(unsigned u) const {
    return  ccpi.Name(CodePage(u).Page());
}

/******************************************************************************

  CGlyphMap::Invocation

  This member returns (in C-style encoding) a string which is used to either
  select or deselect a given code page.

******************************************************************************/

void    CGlyphMap::Invocation(unsigned u, CString& csReturn, 
                              BOOL bSelect) const {
    CodePage(u).Invocation(csReturn, bSelect);
}

/******************************************************************************

  CGlyphMap::UndefinedPoints

  This member fills a map with all code points NOT in the current mapping, and
  maps them to their related code pages.  Thus only translatable points will be
  passed back to the caller.

******************************************************************************/

void    CGlyphMap::UndefinedPoints(CMapWordToDWord& cmw2dCollector) const {

    cmw2dCollector.RemoveAll();

    CWaitCursor cwc;
    
    for (unsigned u = 0; u < CodePages(); u++) {
        CWordArray  cwaPage;

        //  Collect the code points in the code page

        ccpi.Collect(PageID(u), cwaPage);
        union {
            CObject *pco;
            DWORD   dw;
        };

        //  Check the entries- if they haven't been mapped yet, and
        //  some earlier code page hasn't claimed them, add them.

        for (int i = 0; i < cwaPage.GetSize(); i++)
            if  (!m_csmw2oEncodings.Lookup(cwaPage[i], pco) &&
                 !cmw2dCollector.Lookup(cwaPage[i], dw))
                 cmw2dCollector[cwaPage[i]] = u;
    }
}

/******************************************************************************

  CGlyphMap::Load(CByteArray& cbaMap)

  This loads an image of a GTT into safe memory, whether it is predefined or
  a file.

******************************************************************************/

void    CGlyphMap::Load(CByteArray& cbaMap) const {
    try {
        int i = (short) m_wID;
        if  (i > 0 || i < Wansung) { //  Not a predefined ID
            CFile   cfGTT(m_cfn.FullName(), 
            CFile::modeRead | CFile::shareDenyWrite);

            cbaMap.SetSize(cfGTT.GetLength());
            cfGTT.Read(cbaMap.GetData(), cbaMap.GetSize());
            return;
        }
        HRSRC hrsrc = FindResource(AfxGetResourceHandle(), 
            MAKEINTRESOURCE(m_wID ? -(short) m_wID : IDR_CP1252), 
            MAKEINTRESOURCE(IDR_GLYPHMAP));

        if  (!hrsrc)
            return;

        HGLOBAL hg = LoadResource(AfxGetResourceHandle(), hrsrc);
        
        if  (!hg)
            return;

        LPVOID  lpv = LockResource(hg);

        if  (!lpv)
            return;

        cbaMap.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc));
        memcpy(cbaMap.GetData(), lpv, cbaMap.GetSize());
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, Name());
        AfxMessageBox(csMessage);
    }
}

/******************************************************************************

  CGlyphmap::SetSourceName

  This takes and stores the source file name so we can load and convert later.
  It also renames (or rather, sets the original name) for the GlyphMap using 
  the base file name.

******************************************************************************/

void    CGlyphMap::SetSourceName(LPCTSTR lpstrNew) {
    m_csSource = lpstrNew;

    m_csName = m_csSource.Mid(m_csSource.ReverseFind(_T('\\')) + 1);

    if  (m_csName.Find(_T('.')) >= 0)
        if  (m_csName.Right(4).CompareNoCase(_T(".CTT"))) {
            m_csName.SetAt(m_csName.Find(_T('.')), _T('_'));
            CProjectNode::Rename(m_csName);
        }
        else
            CProjectNode::Rename(m_csName.Left(m_csName.Find(_T('.'))));
    else
        CProjectNode::Rename(m_csName);
}

/******************************************************************************

  CGlyphMap::AddPoints

  This member adds one or more code points to the glyph map using the given 
  list of points and associated pages.

******************************************************************************/

void    CGlyphMap::AddPoints(CMapWordToDWord& cmw2dNew) {
    WORD        wKey;
    DWORD       dwixPage;
    CWaitCursor cwc;        //  This could be slow!
    
    for (POSITION pos = cmw2dNew.GetStartPosition(); pos; ) {
        cmw2dNew.GetNextAssoc(pos, wKey, dwixPage);

        //  Get the MBCS encoding of the Unicode point as the initial
        //  glyph encoding.

        CWordArray  cwaIn;
        CByteArray  cbaOut;

        cwaIn.Add(wKey);
        ccpi.Convert(cbaOut, cwaIn, CodePage(dwixPage).Page());

        //  Create the glyph and add it to the map

        CGlyphHandle    *pcgh = new CGlyphHandle;

        pcgh -> Init(cbaOut.GetData(), (unsigned) cbaOut.GetSize(), Glyphs(), 
            wKey);
        pcgh -> SetCodePage(dwixPage, CodePage(dwixPage).Page());
        m_csmw2oEncodings[wKey] = pcgh;
        m_crr.Add(pcgh);
    }
    Changed();  //  Don't forget to tell the container!
}

/******************************************************************************

  CGlyphMap::DeleteGlyph

  This member function removes a glyph from the map.  The most tricky part is
  updating the run records, but that's not this class' responsibility, is it?

******************************************************************************/

void    CGlyphMap::DeleteGlyph(WORD wCodePoint) {
    if  (!m_csmw2oEncodings.RemoveKey(wCodePoint))
        return;     //  This glyph is already toast!

    m_crr.Delete(wCodePoint);
    Changed();
}

/******************************************************************************

  CGlyphMap::RemovePage

  This member function removes a code page from the list of available pages.  
  Glyphs that used this page will be remapped to a second specified page.

******************************************************************************/

BOOL    CGlyphMap::RemovePage(unsigned uPage, unsigned uMapTo) {

    if  (uPage >= CodePages() || uMapTo >= CodePages())
        return  FALSE;

    //  Pretty simple- walk the map- first replace any instances, then 
    //  decrement any indices higher than uPage

    WORD    wKey;

    union {
        CObject*        pco;
        CGlyphHandle*   pcgh;
    };

    for (POSITION pos = m_csmw2oEncodings.GetStartPosition(); pos; ) {

        m_csmw2oEncodings.GetNextAssoc(pos, wKey, pco);

        if  (pcgh -> CodePage() == uPage)
            pcgh -> SetCodePage(uMapTo, CodePage(uMapTo).Page());

        if  (pcgh -> CodePage() > uPage)
            pcgh -> SetCodePage(pcgh -> CodePage() - 1, 
                CodePage(pcgh -> CodePage()).Page());
    }

    m_csoaCodePage.RemoveAt(uPage);

    return  TRUE;
}

/******************************************************************************

  CGlyphMap::ChangeCodePage

  This member function changes the code page for one ore more glyphs to a 
  different page.  At one time I thought remapping the code points would be
  required, but currently, the Unicode stays intact.  That seems a good feature
  for demand-driven implementation.

******************************************************************************/

//  This one changes the code page for one or more glyphs.
//  For now, we will simply keep the Unicode intact.  Eventually, a query
//  should be made about the intent, so we can remap through the existing
//  page, if that is what is desired.

void    CGlyphMap::ChangeCodePage(CPtrArray& cpaGlyphs, DWORD dwidNewPage) {
    for (unsigned u = 0; u < CodePages(); u++)
        if  (dwidNewPage == CodePage(u).Page())
            break;

    _ASSERTE(u < CodePages());

    if  (u >= CodePages())
        return;

    for (int i = 0; i < cpaGlyphs.GetSize(); i++)
        ((CGlyphHandle *) cpaGlyphs[i]) -> SetCodePage(u, dwidNewPage);

    Changed();
}

/******************************************************************************

  CGlyphMap::AddCodePage

  This member function adds a new code page to the list of pages used in this 
  table.

******************************************************************************/

void    CGlyphMap::AddCodePage(DWORD dwidNewPage) {
    m_csoaCodePage.Add(new CCodePageData(dwidNewPage));
    Changed();
}

/******************************************************************************

  CGlyphMap::SetPredefinedID

  This changes the predefined table used by the map.  If it really is a change,
  we must remove all non-modified points from any existing map, and then flesh
  out using the new one.

******************************************************************************/

void    CGlyphMap::UsePredefined(long lidNew) {
    if  (m_lidPredefined == lidNew)
        return; //  Didn't need to do this!

    if  (m_lidPredefined != NoPredefined)
        UnmergePredefined(lidNew != NoPredefined);

    m_lidPredefined = lidNew;

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    Changed();
}

/******************************************************************************

  CGlyphMap::SetInvocation

  This member changes the invocation string for selecting or unselecting a
  given code page.

******************************************************************************/

void    CGlyphMap::SetInvocation(unsigned u, LPCTSTR lpstrInvoke, 
                                 BOOL bSelect) {
    CodePage(u).SetInvocation(lpstrInvoke, bSelect);
    Changed();
}

/******************************************************************************

  CGlyphMap::ChangeEncoding

  This member is called when the user changes the encoding string used to 
  invoke a given code point.  This could be done via the glyph, but then the
  containing document won't know of the change, and thus the change could be
  inadvertently lost...

******************************************************************************/

void    CGlyphMap::ChangeEncoding(WORD wCodePoint, LPCTSTR lpstrNewInvoke) {

    union {
        CObject         *pco;
        CGlyphHandle    *pcgh;
    };

    if  (!m_csmw2oEncodings.Lookup(wCodePoint, pco) || !lpstrNewInvoke|| 
            !*lpstrNewInvoke)
        return; 

    pcgh -> NewEncoding(lpstrNewInvoke);

    Changed();
}

/******************************************************************************

  CGlyphMap::ConvertCTT()

  This member fuction initializes the glyphmap structure from a CTT file

******************************************************************************/

BOOL    CGlyphMap::ConvertCTT() {

    struct sCTT {
        enum {Composed, Direct, Paired};
        WORD    m_wFormat;
        BYTE    m_bFirstChar, m_bLastChar;
        union   {
            uencCTT m_uectt[1];
            BYTE    m_bDirect[1];
        };
    };

    //  If this map isn't empty, empty it now- at least of the glyph data

    m_csmw2oEncodings.RemoveAll();
    m_crr.Empty();

    CByteArray  cbaImage;
        
    try {

        CFile   cfCTT(m_csSource, CFile::modeRead | CFile::shareDenyWrite);

        cbaImage.SetSize(cfCTT.GetLength());

        cfCTT.Read(cbaImage.GetData(), cfCTT.GetLength());
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    union {
        PBYTE   pbCTT;
        sCTT*   psctt;
    };
    
    pbCTT = cbaImage.GetData();
    BYTE    bFirst = min(0x20, psctt -> m_bFirstChar),
            bLast = 0xFF;   //  Since we use a byte this is the max!
    unsigned ucGlyphs = 1 + bLast - bFirst;

    //  Convert the code points to Unicode
    CByteArray  cbaCode;
    CWordArray  cwaCode;
    
    for (unsigned u = 0; u < ucGlyphs; u++)
        cbaCode.Add(u + bFirst);

    //  Convert the data to Unicode using the selected code page.  This uses
    //  data stored from MultiByteToWideChar, so it is similar, except we can
    //  do this with code pages which might not be installed on the user's
    //  system.

    if  (ucGlyphs != ccpi.Convert(cbaCode, cwaCode, CodePage(0).Page())) {
        CString csWork;
        csWork.Format(IDS_NoUnicodePoint, u + bFirst, CodePage(0).Page());
        AfxMessageBox(csWork);
        return  FALSE; 
    }

    //  Since we add phony glyphs to the table (why, one wonders), we must mark
    //  them so we can manufacture equally phony encodings for them.
    for (u = 0; u < ucGlyphs; u++) {

        //  Now, let's record the Encoding

        CGlyphHandle  *pcghNew = new CGlyphHandle;
        unsigned uToUse = u + bFirst - psctt -> m_bFirstChar;

        switch  (psctt -> m_wFormat) {

            case    sCTT::Direct:
                if  (u + bFirst < psctt -> m_bFirstChar)
                    pcghNew -> Init((BYTE) u + bFirst, u,cwaCode[u]);
                else
                    pcghNew -> Init(psctt -> m_bDirect[uToUse], u, cwaCode[u]);
                break;

            case    sCTT::Paired:
                if  (u + bFirst < psctt -> m_bFirstChar)
                    pcghNew -> Init((BYTE) u + bFirst, u, cwaCode[u]);
                else
                    if  (psctt -> m_uectt[uToUse].abPaired[1])
                        pcghNew -> Init(psctt -> m_uectt[uToUse].abPaired, u,
                            cwaCode[u]);
                    else
                        pcghNew -> Init(psctt -> m_uectt[uToUse].abPaired[0], 
                            u, cwaCode[u]);
                break;

            case    sCTT::Composed:
                if  (u + bFirst < psctt -> m_bFirstChar) {
                    BYTE    bMe = u + bFirst;
                    pcghNew -> Init(&bMe, 1, u, cwaCode[u]);
                }
                else
                    pcghNew -> Init(pbCTT + psctt -> m_uectt[uToUse].wOffset, 
                        psctt -> m_uectt[uToUse + 1].wOffset -
                        psctt -> m_uectt[uToUse].wOffset, u, cwaCode[u]);
                break;

            default:    //  Don't accept anything else!
                AfxMessageBox(IDS_InvalidCTTFormat);
                return  FALSE;
        }   //  One map entry coded

        //  Code page index inits OK, but must know the page

        pcghNew -> SetCodePage(0, DefaultCodePage());

        m_csmw2oEncodings[cwaCode[u]] = pcghNew;
        m_crr.Add(pcghNew);
    }   //  Loop of generating entries

    m_bPaired = sCTT::Paired == psctt -> m_wFormat;
    return  TRUE;
}

/******************************************************************************

  CGlyphMap::Load()

  This initializes the glyphmap from a GTT format file.  Since this is the
  primary means of loading, it requires no parameters.

******************************************************************************/

BOOL    CGlyphMap::Load(LPCTSTR lpstrName) {

    //  Note the correct name and path- the rename checks may fail, since the
    //  file is opened elsewhere (possibly with sharing conflicts), so disable
    //  them, for now.  This code is a little sleazy- but the only time the
    //  file name isn't null is if the file's being opened.

    if  (FileTitle().IsEmpty() && lpstrName) {
        m_cfn.EnableCreationCheck(FALSE);
        SetFileName(lpstrName);
        m_cfn.EnableCreationCheck();
    }

    if  (Glyphs()) { //  If we already have them, we're already loaded!
        m_csoaCodePage.RemoveAll(); //  Clean it all up, and reload.
        m_csmw2oEncodings.RemoveAll();
        m_crr.Empty();
    }

    CByteArray  cbaGTT;

    union   {
        PBYTE   pbGTT;
        sGTTHeader  *psgtth;
    };

    Load(cbaGTT);   //  If this fails, it will post a reason why

    if  (!cbaGTT.GetSize())
        return  FALSE;

    pbGTT = cbaGTT.GetData();

    sMapTable*  psmt = (sMapTable *) (pbGTT + psgtth -> m_dwofMapTable);
    sMapTableEntry* psmte = (sMapTableEntry *)(psmt + 1);

    //  Before we go any further, let's do some validation

    if  (psgtth -> m_dwVersion != sGTTHeader::Version1Point0)
        return  FALSE;

    m_bPaired = FALSE;

    //  First, let's snarf up the code page info

    struct sInvocation {
        DWORD   m_dwSize, m_dwOffset;
    };

    struct sCodePageInfo {
        DWORD   m_dwPage;
        sInvocation m_siSelect, m_siDeselect;
    }   *psci = (sCodePageInfo *)(pbGTT + psgtth -> m_dwofCodePages);

    m_csoaCodePage.RemoveAll();

    for (unsigned u = 0; u < psgtth -> m_dwcCodePages; u++, psci++) {
        m_csoaCodePage.Add(new CCodePageData(psci -> m_dwPage));
        if  (!psci -> m_siSelect.m_dwSize != !psci -> m_siSelect.m_dwOffset ||
             !psci -> m_siDeselect.m_dwSize != 
             !psci -> m_siDeselect.m_dwOffset)
            return  FALSE;  //  The data is bogus!
        
        CodePage(u).SetInvocation(pbGTT + psci -> m_siSelect.m_dwOffset,
            psci -> m_siSelect.m_dwSize, TRUE);
        CodePage(u).SetInvocation(pbGTT + psci -> m_siDeselect.m_dwOffset,
            psci -> m_siDeselect.m_dwSize, FALSE);
    }

    //  Next, we need to walk the glyph run tables to decipher and use the map
    //  table.

    struct sGlyphRun {
        WORD    m_wFirst, m_wc;
    }   *psgr = (sGlyphRun *)(pbGTT + psgtth -> m_dwofRuns);

    _ASSERTE(psgtth -> m_dwcGlyphs == psmt -> m_dwcEntries);

    WORD    wIndex = 0;

    for (unsigned uRun = 0; uRun < psgtth -> m_dwcRuns; uRun++, psgr++)
        for (u = 0; u < psgr -> m_wc; u++, psmte++, wIndex++) {
            CGlyphHandle*   pcgh = new CGlyphHandle;

            switch  (psmte -> m_bfType & sMapTableEntry::Format) {
                case    sMapTableEntry::Direct:

                    pcgh -> Init((PBYTE) &psmte -> m_uectt, 1, wIndex, 
                        psgr -> m_wFirst + u);
                    break;

                case    sMapTableEntry::Paired:

                    pcgh -> Init(psmte -> m_uectt.abPaired, wIndex, 
                        psgr -> m_wFirst + u);

                    if  (!(psmte -> m_bfType & sMapTableEntry::DBCS))
                        m_bPaired = TRUE;

                    break;

                case    sMapTableEntry::Composed:

                    pcgh -> Init(pbGTT + psgtth -> m_dwofMapTable + 
                        psmte -> m_uectt.wOffset + sizeof wIndex, 
                        *(PWORD) (pbGTT + psgtth -> m_dwofMapTable + 
                        psmte -> m_uectt.wOffset), wIndex, 
                        psgr -> m_wFirst + u);
                    break;

                default:    //  Bad news- bad format
                    delete  pcgh;   //  No orphans needed!
                    return  FALSE;
            }

            //  Don't forget the code page ID!

            pcgh -> SetCodePage(psmte -> m_bCodePageIndex, 
                CodePage(psmte -> m_bCodePageIndex).Page());
            
            //  Mark this if it is to be disabled.

            if  (psmte -> m_bfType & sMapTableEntry::Disable)
                pcgh -> SetPredefined(CGlyphHandle::Removed);

            m_csmw2oEncodings[psgr -> m_wFirst + u] = pcgh;
            m_crr.Add(pcgh);
        }

    //  If we're predefined, Merge now.

    m_lidPredefined = psgtth -> m_lidPredefined;

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    return  TRUE;   //  We actually did it!
}

/******************************************************************************

  CGlyphMap::RLE

  This generates an RLE-format file image of the glyph map.

******************************************************************************/

BOOL    CGlyphMap::RLE(CFile& cfTarget) {

    sRLE    srle;

    srle.m_widRLE = 0x78FE;
    srle.m_wcFirst = m_crr.First();
    srle.m_wcLast = m_crr.Last();
    srle.m_dwFlag = 0;
    srle.m_dwcGlyphs = m_csmw2oEncodings.GetCount();
    srle.m_dwcRuns = m_crr.RunCount();
    srle.m_dwcbImage = 4 * sizeof srle.m_dwcbImage + srle.m_dwcRuns * 
         m_crr.Size();
    srle.m_dwcbThis = srle.m_dwcbImage + 3 * sizeof srle.m_dwcbThis +
        srle.m_dwcGlyphs * sizeof srle.m_dwcGlyphs;

    //  Determine the correct format, and thus the RLE size

    if  (!m_crr.MustCompose())
        srle.m_wFormat = m_bPaired ? sRLE::Paired : sRLE::Direct;
    else
        if  (srle.m_dwcGlyphs < 256 && 
             srle.m_dwcbThis + m_crr.ExtraNeeded() <= 0xffff) {
            srle.m_dwcbThis += m_crr.ExtraNeeded();
            srle.m_wFormat = sRLE::LengthIndexOffset;
        }
        else {
            srle.m_dwcbThis += m_crr.ExtraNeeded(FALSE);
            srle.m_wFormat = sRLE::LengthOffset;
        }

    //  We now need to feed the offset information down to the lower level
    //  classes, so that they are prepared to render their information to
    //  the target file.

    //  The first items encoded are the runs, which immediately follow the RLE
    //  header.

    DWORD   dwOffset = sizeof srle + srle.m_dwcRuns * m_crr.Size();

    m_crr.NoteOffset(dwOffset, TRUE, m_bPaired);

    //  If this requires extra data, it will be appearing after the FD_GLYPHSET
    
    if  (srle.m_wFormat == sRLE::LengthOffset || 
         srle.m_wFormat == sRLE::LengthIndexOffset)
        m_crr.NoteExtraOffset(dwOffset, 
            srle.m_wFormat == sRLE::LengthIndexOffset);

    _ASSERTE(dwOffset == srle.m_dwcbThis);

    //  We've got our data, we've got our file, and we've got a job to do.
    //  Hop to it!
    
    try {
        cfTarget.Write(&srle, sizeof srle);
        m_crr.WriteSelf(cfTarget);
        m_crr.WriteHandles(cfTarget, srle.m_wFormat);
        m_crr.WriteEncodings(cfTarget, srle.m_wFormat == sRLE::LengthOffset ?
            CGlyphHandle::RLEBig : CGlyphHandle::RLESmall);
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CGlyphMap::Glyph

  I tried to do this in the header, file but that lets it be in-line, and I
  don't want to export CRunRecord.

******************************************************************************/

CGlyphHandle*   CGlyphMap::Glyph(unsigned u) {
    return  m_crr.GetGlyph(u);
}

/******************************************************************************

  CGlyphMap::CreateEditor

  This member function overrides the CProjectNode function to create a new 
  CGlyphMapContainer document embedding this Glyph Map.  It then uses the
  appropriate document template to open a view on this document.

******************************************************************************/

CMDIChildWnd    *CGlyphMap::CreateEditor() {
    CGlyphMapContainer* pcgmcMe= new CGlyphMapContainer(this, FileName());

    //  Make up a cool title

    pcgmcMe -> SetTitle(m_pcbnWorkspace -> Name() + _TEXT(": ") + Name());

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt -> 
        CreateNewFrame(pcgmcMe, NULL);

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcgmcMe, TRUE);
        m_pcmdt -> AddDocument(pcgmcMe);
    }

    return  pcmcwNew;
}

/******************************************************************************

  CGlyphMap::Generate

  This member function generates the GTT format image of the current data.

  It returns a BOOL indicating success or failure.

******************************************************************************/

BOOL    CGlyphMap::Generate(CFile& cfGTT) {

    sGTTHeader  sgtth;

    //  First, take care of any predefined stuff, if we have to

    if  (m_lidPredefined != NoPredefined)
        UnmergePredefined(TRUE);

    sgtth.m_dwcGlyphs = Glyphs();
    sgtth.m_dwcRuns = m_crr.RunCount();
    sgtth.m_dwcCodePages = CodePages();
    sgtth.m_lidPredefined = m_lidPredefined;

    //  The run table is the first item after the header, so add in its size

    sgtth.m_dwofRuns = sgtth.m_dwcbImage;   //  Runs are first item
    sgtth.m_dwcbImage += sgtth.m_dwcRuns * m_crr.Size(FALSE);
    sgtth.m_dwofCodePages = sgtth.m_dwcbImage;  //  Code pages are next

    //  Code page selection strings immediately follow the Code page structures
    //  The code page information size must be padded to a DWORD multiple

    sgtth.m_dwcbImage += sgtth.m_dwcCodePages * CodePage(0).Size();
    for (unsigned u = 0; u < CodePages(); u++)
        CodePage(u).NoteOffsets(sgtth.m_dwcbImage);

    //  Save the amount of padding, as we'll write it later
    DWORD   dwPadding = (sizeof (DWORD) - 
        (sgtth.m_dwcbImage & (sizeof (DWORD) - 1))) & (sizeof (DWORD) - 1);

    sgtth.m_dwcbImage += dwPadding;

    sgtth.m_dwofMapTable = sgtth.m_dwcbImage;

    //  Map Table size determination

    sMapTable   smt(Glyphs());

    //  Fortunately for us, the following not only preps the data, it also
    //  updates the image size for us
    if  (m_crr.MustCompose())
        m_crr.NoteOffset(smt.m_dwcbImage, FALSE, m_bPaired);

    //  Final Size calculation
    sgtth.m_dwcbImage += smt.m_dwcbImage;

    //  Now, we just write it out

    try {
        cfGTT.Write(&sgtth, sizeof sgtth);  //  Header
        m_crr.WriteSelf(cfGTT, FALSE);      //  Glyph Runs
        for (unsigned u = 0; u < CodePages(); u++)
            CodePage(u).WriteSelf(cfGTT);   //  Code page structures

        for (u = 0; u < CodePages(); u++)
            CodePage(u).WriteInvocation(cfGTT); //  Code page invocations

        cfGTT.Write(((LPSTR) &dwPadding) + 1, dwPadding);  //  Pad with 0's

        //  Do the map table, and we are finished!
        cfGTT.Write(&smt, sizeof smt);
        m_crr.WriteMapTable(cfGTT, m_lidPredefined != NoPredefined);
        m_crr.WriteEncodings(cfGTT, CGlyphHandle::GTT);
    }
    catch   (CException * pce) {
        //  Take care of any predefined stuff, if we have to

        if  (m_lidPredefined != NoPredefined)
            MergePredefined();

        //  Feedback- something broke when it shouldn't have
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }
    //  Take care of any predefined stuff, if we have to

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    Changed(FALSE);

    return  TRUE;
}

/******************************************************************************

  CGlyphMapContainer class - this encases the glyph table UI when it is either
  embedded in the driver, or loaded directly from the GTT

******************************************************************************/

/******************************************************************************

  CGlyphMapContainer::CGlyphMapContainer()

  This default constructor is used whenever dynamic creation is used, which is
  most MFC usages of the document system.  It starts with an empty glyph map.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGlyphMapContainer, CDocument)

CGlyphMapContainer::CGlyphMapContainer() {
    m_pcgm = new CGlyphMap;
    m_pcgm -> NoteOwner(*this);
    m_bEmbedded = FALSE;
}

/******************************************************************************

  CGlyphMapContainer:CGlyphMapContainer(CGlyphMap *pvgm, CString csPath)

  This constructor override is used when we create a CGlyphMapContainer
  document from the driver/project level editor.  In this case, a digested
  map is passed, so no additional I/O us needed.

******************************************************************************/

CGlyphMapContainer::CGlyphMapContainer(CGlyphMap *pcgm, CString csPath) { 
    m_pcgm = pcgm;
    SetPathName(csPath, FALSE);
    m_bEmbedded = TRUE;
    m_pcgm -> NoteOwner(*this); //  This is the document being edited!
}

BOOL CGlyphMapContainer::OnNewDocument() {
	return  CDocument::OnNewDocument();
}

CGlyphMapContainer::~CGlyphMapContainer() {
    if  (!m_bEmbedded && m_pcgm)
        delete  m_pcgm;
}


BEGIN_MESSAGE_MAP(CGlyphMapContainer, CDocument)
	//{{AFX_MSG_MAP(CGlyphMapContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer diagnostics

#ifdef _DEBUG
void CGlyphMapContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CGlyphMapContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer serialization

void CGlyphMapContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
	}
	else {
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer commands

BOOL CGlyphMapContainer::OnSaveDocument(LPCTSTR lpszPathName) {

    //  We save via the glyph map's Generate function.

    CFile   cfGTT;
    if  (!cfGTT.Open(lpszPathName, CFile::modeCreate | CFile::modeWrite |
        CFile::shareExclusive))
        return  FALSE;
	
	return m_pcgm -> Generate(cfGTT);
}

/******************************************************************************

  CGlyphMapContainer::OnOpenDocument

  This overrides the typical MFC open document action, which is to open the
  document by serialization.  Instead, we use the CGlyphMap Load override for
  the GTT format to initialize the GlyphMap.

******************************************************************************/

BOOL CGlyphMapContainer::OnOpenDocument(LPCTSTR lpstrFile) {
    return m_pcgm -> Load(lpstrFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\fontinst.h ===
/******************************** MODULE HEADER *****************************
 * fontinst.h
 *      Structures used to determine the file layout of files generated
 *      by any font installers, and then read by us.
 *
 * HISTORY:
 *  15:53 on Mon 02 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 * Copyright (C) 1992   Microsoft Corporation.
 *
 ****************************************************************************/


/*
 *   Define the structure that heads each record in the font installer
 * files.  Basically it contains selection information and offsets
 * to the remaining data in this record.
 *   This structure is actually written to the file.  It is also the header
 * employed in the font resources in minidrivers - each font has one of these
 * at the beginning.
 */


//Reduced from 4 to three as WFontType is added.
//Reducde from three to two when dwETM was added
#define EXP_SIZE        2       /* DWORDS allowed for future expansion */

typedef struct
{
    WORD     cjThis;            /* Our size,  for consistency checking */
    WORD     wFlags;            /* Miscellaneous information */

    DWORD    dwSelBits;         /* Font availability information */

    DWORD    dwIFIMet;          /* Offset to the IFIMETRICS for this font */
    DWORD    dwCDSelect;        /* How to select/deselect this font */
    DWORD    dwCDDeselect;
    DWORD    dwWidthTab;        /* Width vector (proportional font) else 0 */
    DWORD    dwIdentStr;        /* Identification string */

    union
    {
        short    sCTTid;        /* Index into CTT data */
        DWORD    dwCTT;         /* Offset here to mapping data of some sort */
    } u;

    WORD     wXRes;             /* Resolution used for font metrics numbers */
    WORD     wYRes;             /* Ditto for the y coordinates */

    short    sYAdjust;          /* Adjust Y position before output - for  */
                                /* double height characters on dot matrix */
    short    sYMoved;           /* Cursor has shifted after printing font */

    short    fCaps;             /* Capabilities flags */

    WORD     wPrivateData;      /* Special purpose: e.g. DeskJet permutations */

    WORD     wFontType;         /* Type of Device font */

    WORD     wReserved;      	/* reserved for future use */

    DWORD    dwETM;             /* offset to ETM for this font 0 if there are none*/

    DWORD    dwMBZ[ EXP_SIZE ]; /* Must Be Zero: in case we need space */
	
} FI_DATA_HEADER;

/*
 *  The version ID.
 */

#define FDH_VER 0x100           /* 1.00 in BCD */

/*
 *  Flags bits.
 */
#define FDH_SOFT        0x0001  /* Softfont, thus needs downloading */
#define FDH_CART        0x0002  /* This is a cartridge font */
#define FDH_CART_MAIN   0x0004  /* Main (first) entry for this cartridge */

/*
 *  Selection criteria bits:  dwSelBits.  These bits are used as
 * follows.  During font installation,  the installer set the following
 * values as appropriate.  During initialisation,  the driver sets
 * up a mask of these bits,  depending upon the printer's abilities.
 * For example,  the FDH_SCALABLE bit is set only if the printer can
 * handle scalable fonts.   When the fonts are examined to see if
 * they are usable,  the following test is applied:
 *
 *      (font.dwSelBits & printer.dwSelBits) == font.dwSelBits
 *
 * If true,  the font is usable.
 */

#define FDH_LANDSCAPE   0x00000001      /* Font is landscape orientation */
#define FDH_PORTRAIT    0x00000002      /* Font is portrait */
#define FDH_OR_REVERSE  0x00000004      /* 180 degree rotation of above */
#define FDH_BITMAP      0x00000008      /* Bitmap font */
#define FDH_COMPRESSED  0x00000010      /* Data is compressed bitmap */
#define FDH_SCALABLE    0x00000020      /* Font is scalable */
#define FDH_CONTOUR     0x00000040      /* Intellifont contour */

#define FDH_ERROR       0x80000000      /* Set if some error condition */


/*
 *  The following structure should be returned from the specific
 * minidriver to the common font installer code.  It is used by
 * the common font installer code to generate the above structure
 * which is then placed in the font file.
 */

typedef  struct
{
    void  *pvData;      /* Address of data of importance */
    int    cBytes;      /* Number of bytes in the above */
}  DATA_SUM;

typedef  struct
{
    DATA_SUM   dsIFIMet;        /* IFIMETRICS */
    DATA_SUM   dsSel;           /* Selection string/whatever */
    DATA_SUM   dsDesel;         /* Deselection string */
    DATA_SUM   dsWidthTab;      /* Width tables (proportional font) */
    DATA_SUM   dsCTT;           /* Translation data */
    DATA_SUM   dsIdentStr;      /* Identification string (Dialog box etc) */
    DATA_SUM   dsETM;           /* EXTENDED TEXT METRICS */

    DWORD      dwSelBits;       /* Font availability information */

    WORD       wVersion;        /* Version ID */
    WORD       wFlags;          /* Miscellaneous information */

    WORD       wXRes;           /* X resolution of font */
    WORD       wYRes;           /* Y resolution */

    short      sYAdjust;        /* Adjust Y position before output - for  */
                                /* double height characters on dot matrix */
    short      sYMoved;         /* Cursor has shifted after printing font */


    WORD       fCaps;           /* Font/device caps */
    WORD       wFontType;         /* Type of Device font */
    WORD       wPrivateData;    /* Pad to DWORD multiple */
} FI_DATA;

/*
 *   RELATED FUNCTION PROTOTYPES.
 */


/*
 *   The function used to take an FI_DATA structure and write its contents
 * to the file whose handle is passed in.  The data is written out as
 * an FI_DATA_HEADER structure.
 */

int   iWriteFDH( HANDLE, FI_DATA * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\gtt.h ===
/******************************************************************************

  Header File:  Glyph Translation.H

  These classes define the mapping used from a Unicode or ANSI character to a
  character sequence to render said character on a printer.  They are content
  equivalent to the CTT, RLE and GTT formats used in the various flavors of the
  mini-driver architecture.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-13-97  Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(GLYPH_TRANSLATION)

#define GLYPH_TRANSLATION

#if defined(LONG_NAMES)
#include    "Project Node.H"
#else
#include    "ProjNode.H"
#endif

//  Win16 CTT formats- since these can't change, I've recoded them to suit.
//  Good thing, too- the mapping of direct was bogus- the union implies a word
//  aligned structure, but the fact is that direct data is byte-aligned.
class AFX_EXT_CLASS CInvocation : public CObject {
    CByteArray  m_cbaEncoding;
    DWORD       m_dwOffset;
    DECLARE_SERIAL(CInvocation)

    void        Encode(BYTE c, CString& cs) const;

public:

    CInvocation() {}
    void        Init(PBYTE pb, unsigned ucb);

    unsigned    Length() const { return m_cbaEncoding.GetSize(); }
    const unsigned  Size() const { return 2 * sizeof m_dwOffset; }

    void    GetInvocation(CString& csReturn) const;

    BYTE    operator[](unsigned u) const { 
        return u < Length() ? m_cbaEncoding[u] : 0;
    }

    CInvocation&    operator =(CInvocation& ciRef) {
        m_cbaEncoding.Copy(ciRef.m_cbaEncoding);
        return  *this;
    }

    void    SetInvocation(LPCTSTR lpstrNew);
    void    NoteOffset(DWORD& dwOffset);
    void    WriteSelf(CFile& cfTarget) const;
    void    WriteEncoding(CFile& cfTarget, BOOL bWriteLength = FALSE) const;
    virtual void    Serialize(CArchive& car);
};

//  The following class handles glyph handles and all associated details

class   CGlyphHandle : public CObject {

    CInvocation m_ciEncoding;
    DWORD       m_dwCodePage, m_dwidCodePage, m_dwOffset;
    WORD        m_wIndex;
    WORD        m_wCodePoint;   //  Unicode Representation of the glyph
    WORD        m_wPredefined;

public:

    CGlyphHandle() { 
        m_wPredefined = m_wIndex = 0; 
        m_dwCodePage = m_dwidCodePage = m_dwOffset = 0; 
    }

    //  Atributes

    const unsigned  RLESize() const { return sizeof m_dwCodePage; }
    unsigned    CodePage() const { return m_dwidCodePage; } //  Only ID matters
    WORD        CodePoint() const { return m_wCodePoint; }

    unsigned    CompactSize() const;

    unsigned    MaximumSize() const {
        return  CompactSize() ? 
            sizeof m_wIndex + ((CompactSize() + 1) & ~1) : 0;
    }

    void        GetEncoding(CString& csWhere) { 
        m_ciEncoding.GetInvocation(csWhere);
    }

    enum {Modified, Added, Removed};
    WORD    Predefined() const { return m_wPredefined; }
    BOOL    operator ==(CGlyphHandle& cghRef);
    BOOL    PairedRelevant() const { return m_ciEncoding.Length() == 2; }

    //  Operations

    void    Init(BYTE b, WORD wIndex, WORD wCode);
    void    Init(BYTE ab[2], WORD wIndex, WORD wCode);
    void    Init(PBYTE pb, unsigned ucb, WORD wIndex, WORD wCode);

    CGlyphHandle&   operator =(CGlyphHandle& cghTemplate);

    void    RLEOffset(DWORD& dwOffset, const BOOL bCompact);
    void    GTTOffset(DWORD& dwOffset, BOOL bPaired);

    void    SetCodePage(DWORD dwidPage, DWORD dwNewPage) {
        m_dwCodePage = dwNewPage;
        m_dwidCodePage = dwidPage;
    }

    void    NewEncoding(LPCTSTR lpstrNew) { 
        m_ciEncoding.SetInvocation(lpstrNew);
    }

    void    SetPredefined(WORD wNew) { m_wPredefined = wNew; }

    //  These write our contents for mini-driver files- they will throw
    //  exceptions on failure, so use an exception handler to handle errors

    void    WriteRLE(CFile& cfTarget, WORD wFormat) const;
    void    WriteGTT(CFile& cfTarget, BOOL bPredefined) const;

    enum    {GTT, RLEBig, RLESmall};    //  Desired encoding format
    void    WriteEncoding(CFile& cfTarget, WORD wfHow) const;
};

//  The next class maintains a record of the runs in the glyph set. It
//  generates and merges instances of itself as glyphs are added to the map.

class CRunRecord {
    WORD        m_wFirst, m_wcGlyphs;
    DWORD       m_dwOffset;    //  These are the image...
    CRunRecord  *m_pcrrNext, *m_pcrrPrevious;

    CPtrArray   m_cpaGlyphs;
    
    CRunRecord(CGlyphHandle *pcgh, CRunRecord* pcrrPrevious);
    CRunRecord(CRunRecord* crrPrevious, WORD wWhere);
    CRunRecord(CRunRecord* pcrrPrevious);

    CGlyphHandle&   Glyph(unsigned u) { 
        return *(CGlyphHandle *) m_cpaGlyphs[u];
    }

    const CGlyphHandle& GlyphData(unsigned u) const {
        return *(CGlyphHandle *) m_cpaGlyphs[u];
    }

public:

    CRunRecord();
    ~CRunRecord();

    unsigned        Glyphs() const { return m_wcGlyphs; }
    unsigned        TotalGlyphs() const;
    BOOL            MustCompose() const;
    unsigned        RunCount() const { 
        return 1 + (m_pcrrNext ? m_pcrrNext -> RunCount() : 0);
    }

    WORD            First() const { return m_wFirst; }
    WORD            Last() const { 
        return m_pcrrNext ? m_pcrrNext ->Last() : -1 + m_wFirst + m_wcGlyphs;
    }

    unsigned        ExtraNeeded(BOOL bCompact = TRUE);

    const unsigned  Size(BOOL bRLE = TRUE) const { 
        return  sizeof m_dwOffset << (unsigned) (!!bRLE); 
    }

    void    Collect(CPtrArray& cpaGlyphs) const {
        cpaGlyphs.Append(m_cpaGlyphs);
        if  (m_pcrrNext)    m_pcrrNext -> Collect(cpaGlyphs);
    }

    CGlyphHandle*   GetGlyph(unsigned u ) const;

#if defined(_DEBUG) //  While the linkage code seems to check out, keep this
                    //  around in case of later problems
    BOOL    ChainIntact() {
        _ASSERTE(m_wcGlyphs == m_cpaGlyphs.GetSize());
        for (unsigned u = 0; u < Glyphs(); u++) {
            _ASSERTE(Glyph(u).CodePoint() == m_wFirst + u);
        }
        return  !m_pcrrNext || m_pcrrNext -> m_pcrrPrevious == this &&
            m_pcrrNext -> ChainIntact();
    }
#endif

    //  Operations
    
    void    Add(CGlyphHandle *pcgh);
    void    Delete(WORD wCodePoint);
    void    Empty();
    
    void    NoteOffset(DWORD& dwOffset, BOOL bRLE, BOOL bPaired);
    void    NoteExtraOffset(DWORD& dwOffset, const BOOL bCompact);

    //  File output operations

    void    WriteSelf(CFile& cfTarget, BOOL bRLE = TRUE) const;
    void    WriteHandles(CFile& cfTarget, WORD wFormat) const;
    void    WriteMapTable(CFile& cfTarget, BOOL bPredefined) const;
    void    WriteEncodings(CFile& cfTarget, WORD wfHow) const;
};

class CCodePageData : public CObject {
    DWORD   m_dwid;
    CInvocation  m_ciSelect, m_ciDeselect;

public:

    CCodePageData() { m_dwid = 0; }
    CCodePageData(DWORD dwid) { m_dwid = dwid; }

    //  Attributes

    DWORD   Page() const { return m_dwid; }
    void    Invocation(CString& csReturn, BOOL bSelect) const;
    const unsigned  Size() const { 
        return sizeof m_dwid + 2 * m_ciSelect.Size(); 
    }

    BOOL    NoInvocation() const { 
        return !m_ciSelect.Length() && !m_ciDeselect.Length(); 
    }

    //  Operations
    void    SetPage(DWORD dwNewPage) { m_dwid = dwNewPage; }
    void    SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect);
    void    SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect);
    void    NoteOffsets(DWORD& dwOffset);
    void    WriteSelf(CFile& cfTarget);
    void    WriteInvocation(CFile& cfTarget);
};

//  This class is the generic class encompassing all glyph translation 
//  information.  We can use it to output any of the other forms.

class AFX_EXT_CLASS CGlyphMap : public CProjectNode {
    CSafeMapWordToOb    m_csmw2oEncodings;  //  All of the defined encodings
    CRunRecord          m_crr;
    long                m_lidPredefined;
    WORD                m_wID;              //  Resource ID (temporary)
    BOOL                m_bPaired;          //  Use paired encoding...
    CSafeObArray        m_csoaCodePage;     //  Code page(s) in this map

    //  Framework support (workspace)

    CString             m_csSource;         //  Source CTT File name

    //  Predefined GTT support- must be in this DLL

    static CSafeMapWordToOb m_csmw2oPredefined; //  Cache loaded PDTs here

    void            MergePredefined();  //  Use definitions to build "true" GTT
    void            UnmergePredefined(BOOL bTrackRemovals);
    
    void            GenerateRuns();

    CCodePageData&  CodePage(unsigned u) const { 
        return *(CCodePageData *) m_csoaCodePage[u];
    }

    DECLARE_SERIAL(CGlyphMap)
public:

    //  Predefined IDs, and a static function for retrieving predefined maps

    enum {Wansung = -18, ShiftJIS, GB2312, Big5ToTCA, Big5ToNSA86, JISNoANK,
            JIS, KoreanISC, Big5, CodePage863 = -3, CodePage850, CodePage437,
            DefaultPage, NoPredefined = 0xFFFF};

    static CGlyphMap*       Public(WORD wID);
    
    CGlyphMap();
    
    //  Attributes

    unsigned    CodePages() const { return m_csoaCodePage.GetSize(); }
    DWORD       DefaultCodePage() const { return CodePage(0).Page(); }

    unsigned    Glyphs() const { 
        return m_csmw2oEncodings.GetCount(); 
    }

    void        CodePages(CDWordArray& cdaReturn) const;
    unsigned    PageID(unsigned u) const { return CodePage(u).Page(); }
    long        PredefinedID() const { return m_lidPredefined; }

    CString     PageName(unsigned u) const;
    void        Invocation(unsigned u, CString& csReturn, BOOL bSelect) const;
    void        UndefinedPoints(CMapWordToDWord& cmw2dCollector) const;
    WORD        GetID() const { return m_wID; }
    BOOL        OverStrike() const { return m_bPaired; }
    const CString&  SourceName() { return m_csSource; }

    //  Operations- Framework support
    void    SetID(WORD wID) { m_wID = wID; }
    void    SetSourceName(LPCTSTR lpstrNew);
    void    Load(CByteArray&    cbaMap) const;  //  Load GTT image

    //  Operations- editor support

    void    AddPoints(CMapWordToDWord& cmw2dNew);   //  Add points and pages
    void    DeleteGlyph(WORD wGlyph);
    BOOL    RemovePage(unsigned uPage, unsigned uMapTo);

    void    SetDefaultCodePage(unsigned u) { CodePage(0).SetPage(u); }
    void    ChangeCodePage(CPtrArray& cpaGlyphs, DWORD dwidNewPage);
    void    AddCodePage(DWORD dwidNewPage);

    void    UsePredefined(long lidPredefined);

    void    SetInvocation(unsigned u, LPCTSTR lpstrInvoke, BOOL bSelect);
    void    ChangeEncoding(WORD wCodePoint, LPCTSTR lpstrInvoke);
    void    OverStrike(BOOL bOn) { m_bPaired = bOn; Changed();}

    BOOL    ConvertCTT();
    BOOL    Load(LPCTSTR lpstrName = NULL);
    BOOL    RLE(CFile& cfTarget);

    CGlyphHandle*   Glyph(unsigned u);

    //  Font editor support operations

    void    Collect(CPtrArray& cpaGlyphs) { //  Collect all glyph handles
        cpaGlyphs.RemoveAll();
        m_crr.Collect(cpaGlyphs);
    }

    virtual CMDIChildWnd*   CreateEditor();
    virtual BOOL            Generate(CFile& cfGTT);

    virtual void    Serialize(CArchive& car);
};

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer document

class AFX_EXT_CLASS CGlyphMapContainer : public CDocument {
    CGlyphMap   *m_pcgm;
    BOOL        m_bEmbedded;    //  From driver, or not?
protected:
	CGlyphMapContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGlyphMapContainer)

// Attributes
public:

    CGlyphMap*  GlyphMap() { return m_pcgm; }

// Operations
public:
    //  Constructor- used to create from driver info editor
    CGlyphMapContainer(CGlyphMap *pcgm, CString csPath);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMapContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGlyphMapContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGlyphMapContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\pfm2ifi.cpp ===
/*************************** Module Header **********************************
 * pfm2ifi
 *      Program to read Windows 3.1 PFM format data and convert to NT's
 *      IFIMETRICS data.  Note that since IFIMETRICS is somewhat more
 *      elaborate than PFM data,  some of the values are best guesses.
 *      These are made on the basis of educated guesses.
 *
 * Copyright (C) 1992,  Microsoft Corporation
 *
 ****************************************************************************/

#include        "StdAfx.h"
#if	!defined(WINNT)
#define WINNT
#define _X86_
#define _OLE2_H_
typedef unsigned long   DESIGNVECTOR, BLENDFUNCTION, TRIVERTEX;
#else
typedef unsigned long   DESIGNVECTOR;
#undef	DBG
#endif

#include        <winddi.h>

#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        "raslib.h"
#include        "fontinst.h"

#define	ALIAS_EXT    "._al"             /* The extension on an alias file */


/*   Function prototypes  */
char  **ppcGetAlias( HANDLE, const char * );


PBYTE MapFileA( LPCSTR, DWORD * );
BOOL  bValidatePFM( BYTE *, DWORD );

CD  *GetFontSel(HANDLE hHeap, FONTDAT *pFDat, int bSelect) {
    LOCD	    locd;		/* From originating data */
    CD		   *pCD;
    CD		   *pCDOut;		/* Copy data to here */


    locd = bSelect ? pFDat->DI.locdSelect : pFDat->DI.locdUnSelect;

    if( locd != -1 ) // (NOOCD extended to a long)
    {
	int   size;

	CD    cdTmp;			/* For alignment problems */


	pCD = (CD *)(pFDat->pBase + locd);

        /*
         *   The data pointed at by pCD may not be aligned,  so we copy
         * it into a local structure.  This local structure then allows
         * us to determine how big the CD really is (using it's length field),
         * so then we can allocate storage and copy as required.
         */

        memcpy( &cdTmp, (LPSTR)pCD, sizeof(CD) );

	/* Allocate storage area in the heap */

	size = cdTmp.wLength + sizeof(CD);

	pCDOut = (CD *)HeapAlloc( hHeap, 0, (size + 1) & ~0x1 );

	memcpy( pCDOut, (BYTE *)pCD, size );

	return  pCDOut;
    }

    return   0;
}

short   *GetWidthVector(HANDLE hHeap, FONTDAT *pFDat) {

    /*
     *    For debugging code,  verify that we have a width table!  Then,
     *  allocate memory and copy into it.
     */

    short  *pus;                /* Destination address */

    int     cb;                 /* Number of bytes required */

    /*
     *   There are LastChar - FirstChar width entries,  plus the default
     *  char.  And the widths are shorts.
     */
    cb = (pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 2) * sizeof( short );

    pus = (short *)HeapAlloc( hHeap, 0, cb );

    /*
     *   If this is a bitmap font,  then use the width table, but use
     *  the extent table (in PFMEXTENSION area) as these are ready to
     *  to scale.
     */


    if( pus )
    {
        BYTE   *pb;

        if( pFDat->pETM &&
            pFDat->pETM->emMinScale != pFDat->pETM->emMaxScale &&
            pFDat->PFMExt.dfExtentTable )
        {
            /*   Scalable,  so use the extent table */
            pb = pFDat->pBase + pFDat->PFMExt.dfExtentTable;
        }
        else
        {
            /*   Not scalable.  */
            pb = pFDat->pBase + sizeof( res_PFMHEADER );
        }

        memcpy( pus, pb, cb );
    }

    return  pus;
}

static void ConvFontRes(register FONTDAT *pFDat) {

    BYTE    *pb;		/* Miscellaneous operations */

    res_PFMHEADER    *pPFM;	/* The resource data format */
    res_PFMEXTENSION *pR_PFME;	/* Resource data PFMEXT format */


    /*
     *   Align the PFMHEADER structure.
     */

    pPFM = (res_PFMHEADER *)pFDat->pBase;

    pFDat->PFMH.dfType = pPFM->dfType;
    pFDat->PFMH.dfPoints = pPFM->dfPoints;
    pFDat->PFMH.dfVertRes = pPFM->dfVertRes;
    pFDat->PFMH.dfHorizRes = pPFM->dfHorizRes;
    pFDat->PFMH.dfAscent = pPFM->dfAscent;
    pFDat->PFMH.dfInternalLeading = pPFM->dfInternalLeading;
    pFDat->PFMH.dfExternalLeading = pPFM->dfExternalLeading;
    pFDat->PFMH.dfItalic = pPFM->dfItalic;
    pFDat->PFMH.dfUnderline = pPFM->dfUnderline;
    pFDat->PFMH.dfStrikeOut = pPFM->dfStrikeOut;

    pFDat->PFMH.dfWeight = DwAlign2( pPFM->b_dfWeight );

    pFDat->PFMH.dfCharSet = pPFM->dfCharSet;
    pFDat->PFMH.dfPixWidth = pPFM->dfPixWidth;
    pFDat->PFMH.dfPixHeight = pPFM->dfPixHeight;
    pFDat->PFMH.dfPitchAndFamily = pPFM->dfPitchAndFamily;

    pFDat->PFMH.dfAvgWidth = DwAlign2( pPFM->b_dfAvgWidth );
    pFDat->PFMH.dfMaxWidth = DwAlign2( pPFM->b_dfMaxWidth );

    pFDat->PFMH.dfFirstChar = pPFM->dfFirstChar;
    pFDat->PFMH.dfLastChar = pPFM->dfLastChar;
    pFDat->PFMH.dfDefaultChar = pPFM->dfDefaultChar;
    pFDat->PFMH.dfBreakChar = pPFM->dfBreakChar;

    pFDat->PFMH.dfWidthBytes = DwAlign2( pPFM->b_dfWidthBytes );

    pFDat->PFMH.dfDevice = DwAlign4( pPFM->b_dfDevice );
    pFDat->PFMH.dfFace = DwAlign4( pPFM->b_dfFace );
    pFDat->PFMH.dfBitsPointer = DwAlign4( pPFM->b_dfBitsPointer );
    pFDat->PFMH.dfBitsOffset = DwAlign4( pPFM->b_dfBitsOffset );


    /*
     *   The PFMEXTENSION follows the PFMHEADER structure plus any width
     *  table info.  The width table will be present if the PFMHEADER has
     *  a zero width dfPixWidth.  If present,  adjust the extension address.
     */

    pb = pFDat->pBase + sizeof( res_PFMHEADER );  /* Size in resource data */

    if( pFDat->PFMH.dfPixWidth == 0 )
	pb += (pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 2) * sizeof( short );

    pR_PFME = (res_PFMEXTENSION *)pb;

    /*
     *   Now convert the extended PFM data.
     */

    pFDat->PFMExt.dfSizeFields = pR_PFME->dfSizeFields;

    pFDat->PFMExt.dfExtMetricsOffset = DwAlign4( pR_PFME->b_dfExtMetricsOffset );
    pFDat->PFMExt.dfExtentTable = DwAlign4( pR_PFME->b_dfExtentTable );

    pFDat->PFMExt.dfOriginTable = DwAlign4( pR_PFME->b_dfOriginTable );
    pFDat->PFMExt.dfPairKernTable = DwAlign4( pR_PFME->b_dfPairKernTable );
    pFDat->PFMExt.dfTrackKernTable = DwAlign4( pR_PFME->b_dfTrackKernTable );
    pFDat->PFMExt.dfDriverInfo = DwAlign4( pR_PFME->b_dfDriverInfo );
    pFDat->PFMExt.dfReserved = DwAlign4( pR_PFME->b_dfReserved );

    memcpy( &pFDat->DI, pFDat->pBase + pFDat->PFMExt.dfDriverInfo,
						 sizeof( DRIVERINFO ) );

    /*
     *    Also need to fill in the address of the EXTTEXTMETRIC. This
     *  is obtained from the extended PFM data that we just converted!
     */

    if( pFDat->PFMExt.dfExtMetricsOffset )
    {
        /*
         *    This structure is only an array of shorts, so there is
         *  no alignment problem.  However,  the data itself is not
         *  necessarily aligned in the resource!
         */

        int    cbSize;
        BYTE  *pbIn;             /* Source of data to shift */

        pbIn = pFDat->pBase + pFDat->PFMExt.dfExtMetricsOffset;
        cbSize = DwAlign2( pbIn );

        if( cbSize == sizeof( EXTTEXTMETRIC ) )
        {
            /*   Simply copy it!  */
            memcpy( pFDat->pETM, pbIn, cbSize );
        }
        else
            pFDat->pETM = NULL;         /* Not our size, so best not use it */

    }
    else
        pFDat->pETM = NULL;             /* Is non-zero when passed in */

    return;
}

BOOL    ConvertPFMToIFI(LPCTSTR lpstrPFM, LPCTSTR lpstrIFI, 
                        LPCTSTR lpstrUniq) {
    int       cWidth;           /* Number of entries in width table */
    HANDLE    hheap;            /* Handle to heap for storage */
    HANDLE    hOut;             /* The output file */

    DWORD     dwSize;           /* Size of input file */

    char    **ppcAliasList;     /* The alias list of names,  if present */

    PWSTR     pwstrUniqNm;      /* Unique name */

    IFIMETRICS   *pIFI;

    CD       *pCDSel;           /* Font selection command descriptor */
    CD       *pCDDesel;         /* Deselection - typically not required */

    FI_DATA   fid;              /* Keep track of stuff in the file */

    FONTDAT   FDat;             /* Converted form of data */

    EXTTEXTMETRIC  etm;         /* Additional data on this font */
    INT     bPrint = 0;

    char    acMessage[100];

    /*
     *    Create us a heap,  since all the functions we steal from rasdd
     *  require that we pass a heap handle!
     */

    if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 ))) {
        /*   Not too good!  */
        wsprintf(acMessage, "HeapCreate() fails in pfm2ifi" );
        MessageBox(NULL, acMessage, NULL, MB_OK);

        return  FALSE;
    }

    cWidth = strlen(lpstrUniq);

    pwstrUniqNm = (PWSTR)HeapAlloc( hheap, 0, (cWidth + 1) * sizeof( WCHAR ) );

    MultiByteToWideChar( CP_ACP, 0, lpstrUniq, cWidth, pwstrUniqNm, cWidth );
    *(pwstrUniqNm + cWidth) = 0;

    /*
     *   Zero out the header structure.  This means we can ignore any
     * irrelevant fields, which will then have the value 0, which is
     * the value for not used.
     */

    memset( &fid, 0, sizeof( fid ) );
    memset( &FDat, 0, sizeof( FONTDAT ) );

    /*
     *   First step is to open the input file - this is done via MapFileA.
     *  We then pass the returned address around to various functions
     *  which do the conversion to something we understand.
     */

    if( !(FDat.pBase = MapFileA( lpstrPFM, &dwSize))) {
        wsprintf(acMessage, "Cannot open input file: %s", lpstrPFM);
        MessageBox(NULL, acMessage, NULL, MB_OK);

        return  FALSE;
    }

    /*
     *    Do some validation on the input file.
     */

    if  (!bValidatePFM( FDat.pBase, dwSize)) {
        wsprintf(acMessage, "%s is not a valid PFM file", lpstrPFM);

        return FALSE;
    }

    /*
     *    If there is a file with the same name as the input file, BUT with
     *  an extension of ._al, this is presumed to be an alias file.  An
     *  alias file consists of a set of alias names for this font.  The
     *  reason is that font names have not been very consistent,  so we
     *  provide aliases to the font mapper,  thus maintaining the format
     *  information for old documents.
     *    The file format is one alias per input line.  Names which
     *  are duplicates of the name in the PFM file will be ignored.
     */

    ppcAliasList = ppcGetAlias(hheap, lpstrPFM);

    FDat.pETM = &etm;               /* Important for scalable fonts */

    /*
     *   Create the output file.
     */

    hOut = CreateFile( lpstrIFI, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                                 FILE_ATTRIBUTE_NORMAL, 0);
    if( hOut == (HANDLE)-1) {
        wsprintf(acMessage, "Could not create output file '%s'", lpstrIFI);
        MessageBox(NULL, acMessage, NULL, MB_OK);
        return  FALSE;
    }

    /*
     *    Now have the data,  so civilise it: alignment etc.
     */

    ConvFontRes( &FDat );

    fid.fCaps = FDat.DI.fCaps;
    fid.wFontType = FDat.DI.wFontType; /* Device  FOnt Type */
    fid.wPrivateData = FDat.DI.wPrivateData;
    fid.sYAdjust = FDat.DI.sYAdjust;
    fid.sYMoved = FDat.DI.sYMoved;
    fid.wXRes = FDat.PFMH.dfHorizRes;
    fid.wYRes = FDat.PFMH.dfVertRes;

    /*
     *    Convert the font metrics.   Note that the last two parameters are
     * chosen with the understanding of how this function does its scaling.
     * Any changes to that method will require changes here too!!!
     */

    pIFI = FontInfoToIFIMetric( &FDat, hheap, pwstrUniqNm, ppcAliasList );
    fid.dsIFIMet.pvData = pIFI;

    if  (fid.dsIFIMet.pvData == 0) {
        /*   Should not happen!  */
        MessageBox(NULL, "Could not create IFIMETRICS", NULL, MB_OK);
        return  FALSE;
    }

    fid.dsIFIMet.cBytes = pIFI->cjThis;

    /*
     *    Also need to record which CTT is used for this font.  When the
     * resource is loaded,  this is turned into the address of the
     * corresponding CTT,  which is a resource somewhere else in the
     * mini-driver,  or in rasdd.
     */
    fid.dsCTT.cBytes = FDat.DI.sTransTab;

    /*
     *   Note that IFIMETRICS is only WORD aligned.  However,  since the
     *  following data only requires WORD alignment, we can ignore any
     *  lack of DWORD alignment.
     */

    /*
     *    If there is a width vector,  now is the time to extract it.
     *  There is one if dfPixWidth field in the PFM data is zero.
     */

    if( FDat.PFMH.dfPixWidth == 0 &&
        (fid.dsWidthTab.pvData = GetWidthVector( hheap, &FDat )) )
    {
        cWidth = pIFI->chLastChar - pIFI->chFirstChar + 1;
        fid.dsWidthTab.cBytes = cWidth * sizeof( short );
    }
    else
        fid.dsWidthTab.cBytes = 0;

    /*
     *    Finally,  the font selection/deselection strings.  These are
     *  byte strings,  sent directly to the printer.   Typically there
     *  is no deselection string.  These require WORD alignment,  and
     *  the GetFontSel function will round the size to that requirement.
     *  Since we follow the width tables,  WORD alignment is guaranteed.
     */

    if( pCDSel = GetFontSel( hheap, &FDat, 1 ) )
    {
        /*   Have a selection string,  so update the red tape etc.  */
        fid.dsSel.cBytes = HeapSize( hheap, 0, (LPSTR)pCDSel );
        fid.dsSel.pvData = pCDSel;
    }

    if( pCDDesel = GetFontSel( hheap, &FDat, 0 ) )
    {
        /*   Also have a deselection string,  so record its presence */
        fid.dsDesel.cBytes = HeapSize( hheap, 0, (LPSTR)pCDDesel );
        fid.dsDesel.pvData = pCDDesel;
    }

    if( FDat.pETM == NULL )
    {
        fid.dsETM.pvData = NULL;
        fid.dsETM.cBytes = 0;
    }
    else
    {
        fid.dsETM.pvData = (VOID*) &etm;
        fid.dsETM.cBytes = sizeof(etm);
    }

    /*
     *   Time to write the output file.
     */

    if( iWriteFDH( hOut, &fid ) < 0 )
        MessageBox(NULL, "CANNOT WRITE OUTPUT FILE", NULL, MB_OK);

    /*   All done,  so clean up and away  */
    UnmapViewOfFile( FDat.pBase );              /* Input no longer needed */

    HeapDestroy(hheap);               /* Probably not needed */
    CloseHandle(hOut);               //  Really, this would be a good idea!  

    return  TRUE;
}

/*
 *   An ASCII based copy of KentSe's mapfile function.
 */


/************************** Function Header *********************************
 * PVOID MapFileA( psz, pdwSize )
 *
 * Returns a pointer to the mapped file defined by psz.
 *
 * Parameters:
 *   psz   ASCII string containing fully qualified pathname of the
 *          file to map.
 *
 * Returns:
 *   Pointer to mapped memory if success, NULL if error.
 *
 * NOTE:  UnmapViewOfFile will have to be called by the user at some
 *        point to free up this allocation.
 *
 * History:
 *  11:32 on Tue 29 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *        Return the size of the file too.
 *
 *   05-Nov-1991    -by-    Kent Settle     [kentse]
 * Wrote it.
 ***************************************************************************/

PBYTE
MapFileA(LPCSTR psz, PDWORD pdwSize) {
    void   *pv;

    HANDLE  hFile, hFileMap;

    BY_HANDLE_FILE_INFORMATION  x;


    /*
     *    First open the file.  This is required to do the mapping, but
     *  it also allows us to find the size,  which is used for validating
     *  that we have something resembling a PFM file.
     */

    hFile = CreateFileA(psz, GENERIC_READ, FILE_SHARE_READ,
                             NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        printf( "MapFileA: CreateFileA( %s ) failed.\n", psz );

        return  NULL;
    }

    /*
     *   Find the size of the file now,  and set it in the caller's area.
     */

    if( GetFileInformationByHandle( hFile, &x ) )
        *pdwSize = x.nFileSizeLow;
    else
        *pdwSize = 0;

    // create the mapping object.

    if( !(hFileMap = CreateFileMappingA( hFile, NULL, PAGE_READONLY,
                                         0, 0, NULL )) )
    {
        printf( "MapFileA: CreateFileMapping failed.\n" );

        return  NULL;
    }

    // get the pointer mapped to the desired file.

    if( !(pv = MapViewOfFile( hFileMap, FILE_MAP_READ, 0, 0, 0 )) )
    {
        printf( "MapFileA: MapViewOfFile failed.\n" );

        return  NULL;
    }

    // now that we have our pointer, we can close the file and the
    // mapping object.

    if( !CloseHandle( hFileMap ) )
        printf( "MapFileA: CloseHandle( hFileMap ) failed.\n" );

    if( !CloseHandle( hFile ) )
        printf( "MapFileA: CloseHandle( hFile ) failed.\n" );

    return  (PBYTE) pv;
}



/************************** Function Header *******************************
 * bValidatePFM
 *      Look at a memory mapped PFM file,  and see if it seems reasonable.
 *
 * RETURNS:
 *      TRUE if OK,  else FALSE
 *
 * HISTORY:
 *  12:22 on Tue 29 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *      First version to improve usability of pfm2ifi.
 *
 **************************************************************************/

BOOL
bValidatePFM( PBYTE pBase, DWORD dwSize ) {

    DWORD    dwOffset;             /* Calculate offset of interest as we go */

    res_PFMHEADER     *rpfm;       /* In Win 3.1 format, UNALIGNED!! */
    res_PFMEXTENSION  *rpfme;      /* Final access to offset to DRIVERINFO */

    DRIVERINFO      di;            /* The actual DRIVERINFO data! */


    /*
     *    First piece of sanity checking is the size!  It must be at least
     *  as large as a PFMHEADER structure plus a DRIVERINFO structure.
     */

    if( dwSize < (sizeof( res_PFMHEADER ) + (sizeof( DRIVERINFO ) ) +
                  sizeof( res_PFMEXTENSION )) )
    {
        return  FALSE;
    }

    /*
     *    Step along to find the DRIVERINFO structure, as this contains
     *  some identifying information that we match to look for legitimacy.
     */
    rpfm = (res_PFMHEADER *)pBase;           /* Looking for fixed pitch */

    dwOffset = sizeof( res_PFMHEADER );

    if( rpfm->dfPixWidth == 0 )
    {
        /*   Proportionally spaced, so allow for the width table too! */
        dwOffset += (rpfm->dfLastChar - rpfm->dfFirstChar + 2) * sizeof( short );

    }

    rpfme = (res_PFMEXTENSION *)(pBase + dwOffset);

    /*   Next is the PFMEXTENSION data  */
    dwOffset += sizeof( res_PFMEXTENSION );

    if( dwOffset >= dwSize )
    {
        return  FALSE;
    }

    dwOffset = DwAlign4( rpfme->b_dfDriverInfo );

    if( (dwOffset + sizeof( DRIVERINFO )) > dwSize )
    {
        return   FALSE;
    }

    /*
     *    A memcpy is used because this data is typically not aigned. Ugh!
     */

    memcpy( &di, pBase + dwOffset, sizeof( di ) );


    if( di.sVersion > DRIVERINFO_VERSION )
    {
        return   FALSE;
    }

    return  TRUE;
}



/************************** Function Header *******************************
 * ppcGetAlias
 *      Return a pointer to an array of pointers to aliases for the given
 *      font name.
 *
 * RETURNS:
 *      Pointer to pointer to aliases;  0 on error.
 *
 * HISTORY:
 *  10:02 on Fri 28 May 1993    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 ***************************************************************************/


char   **
ppcGetAlias( HANDLE hheap, LPCSTR pcFile ) {


    char     *pcAlias;          /* The name of the alias file */
    char     *pcTmp;            /* Temporary stuffing around */
    char     *pcTmp2;           /* Yet more temporary stuffing around */

    char    **ppcRet;           /* The return value */

    FILE     *fAlias;           /* The alias file,  if there */



    ppcRet = (char  **)0;

    /*  The 5 is for the terminating NUL plus the characters "._al"  */
    pcAlias = (char *)HeapAlloc( hheap, 0, strlen( pcFile ) + 5 );

    if( pcAlias )
    {
        /*   Generate the file name, try to open it  */
        strcpy( pcAlias, pcFile );

        if( !(pcTmp = strrchr( pcAlias, '\\' )) )
        {
            /*   No \ in name - is there a /? */
            if( !(pcTmp = strrchr( pcAlias, '/' )) )
            {
                /*  Must be a simple name,  so point at the start of it */
                pcTmp = pcAlias;
            }
        }

        /*
         *    Now pcTmp points at the start of the last component of the
         *  file name.  IF this contains a '.',  then overwrite whatever
         *  follows by our extension,  otherwise add our extension to the end.
         */

        if( !(pcTmp2 = strrchr( pcTmp, '.' )) )
            pcTmp2 = pcTmp + strlen( pcTmp );


        strcpy( pcTmp2, ALIAS_EXT );

        fAlias = fopen( pcAlias, "r" );

        HeapFree( hheap, 0, (LPSTR)pcAlias );            /* No longer used */

        if( fAlias )
        {
            /*
             *    First,  read the file to count how many lines there are.
             *  Thus we can allocate the storage for the array of pointers.
             */

            char  acLine[ 256 ];              /* For reading the input line */
            int   iNum;                       /* Count the number of lines! */
            int   iIndex;                     /* Stepping through input */

            iNum = 0;
            while( fgets( acLine, sizeof( acLine ), fAlias ) )
                ++iNum;


            if( iNum )
            {
                /*  Some data available,  so allocate pointer and off we go */

                ++iNum;
                ppcRet = (char  **)HeapAlloc( hheap, 0, iNum * sizeof( char * ) );

                if( ppcRet )
                {

                    iIndex = 0;

                    rewind( fAlias );             /* Back to the start */

                    while( iIndex < iNum &&
                           fgets( acLine, sizeof( acLine ), fAlias ) )
                    {
                        /*
                         *   Do a little editing - delete leading space,
                         * trailing space + control characters.
                         */


                        pcTmp = acLine;

                        while( *pcTmp &&
                               (!isprint( *pcTmp ) || isspace( *pcTmp )) )
                                       ++pcTmp;


                        /*  Filter out the ending stuff too! */
                        pcTmp2 = pcTmp + strlen( pcTmp );

                        while( pcTmp2 > pcTmp &&
                               (!isprint( *pcTmp2 ) || isspace( *pcTmp2 )) )
                        {
                            /*
                             *   Zap it,  then onto the previous char. NOTE
                             * that this is not the best solution, but it
                             * is convenient.
                             */

                            *pcTmp2-- = '\0';            /* Zap the end */
                        }


                        ppcRet[ iIndex ] = (PSTR) HeapAlloc( hheap, 0,
                                                        strlen( pcTmp ) + 1 );

                        if( ppcRet[ iIndex ] )
                        {
                            /*  Copy input to new buffer */

                            strcpy( ppcRet[ iIndex ], pcTmp );
                            ++iIndex;              /* Next output slot */
                        }

                    }
                    ppcRet[ iIndex ] = NULL;
                }
            }
        }
    }

    return  ppcRet;
}

/************************* Function Header ********************************
 * strcpy2WChar
 *      Convert a char * string to a WCHAR string.  Basically this means
 *      converting each input character to 16 bits by zero extending it.
 *
 * RETURNS:
 *      Value of first parameter.
 *
 * HISTORY:
 *  12:35 on Thu 18 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Use the correct conversion method to Unicode.
 *
 *  09:36 on Thu 07 Mar 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 **************************************************************************/

 static PWSTR   strcpy2WChar(PWSTR pWCHOut, LPSTR lpstr) {

    /*
     *   Put buffering around the NLS function that does all this stuff.
     */

    int     cchIn;             /* Number of input chars */


    cchIn = strlen( lpstr ) + 1;

    MultiByteToWideChar( CP_ACP, 0, lpstr, cchIn, pWCHOut, cchIn );


    return  pWCHOut;
}

/*************************** Function Header *****************************
 * FontInfoToIFIMetric
 *      Convert the Win 3.1 format PFM data to NT's IFIMETRICS.  This is
 *      typically done before the minidrivers are built,  so that they
 *      can include IFIMETRICS, and thus have less work to do at run time.
 *
 * RETURNS:
 *      IFIMETRICS structure,  allocated from heap;  NULL on error
 *
 * HISTORY:
 *  13:58 on Fri 28 May 1993    -by-    Lindsay Harris   [lindsayh]
 *      Goes back a long way,  I am now adding the aliasing code.
 *
 **************************************************************************/

IFIMETRICS  * 
FontInfoToIFIMetric(FONTDAT *pFDat, HANDLE hheap, PWSTR pwstrUniqNm, 
                    char **ppcAliasList) {

    register  IFIMETRICS   *pIFI;

    FWORD  fwdExternalLeading;

    int    cWC;                 /* Number of WCHARS to add */
    int    cbAlloc;             /* Number of bytes to allocate */
    int    iI;                  /* Loop index */
    int    iCount;              /* Number of characters in Win 3.1 font */
    int    cAlias;              /* Number of aliases we have found */

    WCHAR *pwch;                /* For string manipulations */

    WCHAR   awcAttrib[ 256 ];   /* Generate attributes + BYTE -> WCHAR */
    BYTE    abyte[ 256 ];       /* Used (with above) to get wcLastChar etc */



    /*
     *    First step is to determine the length of the WCHAR strings
     *  that are placed at the end of the IFIMETRICS,  since we need
     *  to include these in our storage allocation.
     *
     *    There may also be an alias list.  If so, we need to include
     *  that in our calculation.   We have a NULL terminated array
     *  of pointers to the aliases,  one of which is most likely the
     *  name in the Win 3.1 format data.
     */


    cWC = 0;
    cAlias = 0;                /* No aliases is the default */

    if( ppcAliasList )
    {
        /*  There are aliases - count them and determine their size  */

        char   *pc;

        iI = 0;
        while( pc = ppcAliasList[ iI ] )
        {
            if( strcmp( pc, (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace ) )
            {
                /*   Not a match,  so add this one in too!  */

                cWC += strlen( pc ) + 1;            /* Terminating NUL */
                ++cAlias;
            }
            ++iI;
        }

        ++cWC;             /* There is an extra NUL to terminate the list */

    }


    cWC +=  3 * strlen( (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */

    /*
     *   Produce the desired attributes: Italic, Bold, Light etc.
     * This is largely guesswork,  and there should be a better method.
     */


    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';               /* Write out an empty string */

    if( pFDat->PFMH.dfItalic )
        wcscat( awcAttrib, L" Italic" );

    if( pFDat->PFMH.dfWeight >= 700 )
        wcscat( awcAttrib, L" Bold" );
    else
    {
        if( pFDat->PFMH.dfWeight < 200 )
            wcscat( awcAttrib, L" Light" );
    }

    /*
     *   The attribute string appears in 3 entries of IFIMETRICS,  so
     * calculate how much storage this will take.  NOTE THAT THE LEADING
     * CHAR IN awcAttrib is NOT placed in the style name field,  so we
     * subtract one in the following formula to account for this.
     */

    if( awcAttrib[ 0 ] )
        cWC += 3 * wcslen( awcAttrib ) - 1;

    cWC += wcslen( pwstrUniqNm ) + 1;   /* SHOULD BE PRINTER NAME */
    cWC += 4;                           /* Terminating nulls */

    cbAlloc = sizeof( IFIMETRICS ) + sizeof( WCHAR ) * cWC;

    pIFI = (IFIMETRICS *)HeapAlloc( hheap, 0, cbAlloc );

    ZeroMemory( pIFI, cbAlloc );               /* In case we miss something */

    pIFI->cjThis = cbAlloc;                    /* Everything */

    pIFI->cjIfiExtra = 0;   //  Correct for all pre 4.0

    /*   The family name:  straight from the FaceName - no choice?? */

    pwch = (WCHAR *)(pIFI + 1);         /* At the end of the structure */
    pIFI->dpwszFamilyName = (BYTE *)pwch - (BYTE *)pIFI;

    strcpy2WChar( pwch, (LPSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */
    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */

    /*
     *   Append the alias list to the end of this,  if there is an alias list.
     */

    if( cAlias )
    {
        /*  Found some aliases - add them on.   */

        char   *pc;

        cAlias = 0;
        while( pc = ppcAliasList[ cAlias ] )
        {
            if( strcmp( pc, (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace ) )
            {
                /*   Not a match,  so add this one in too!  */

                strcpy2WChar( pwch, pc );
                pwch += wcslen( pwch ) + 1;         /* Next slot to fill */
            }
            ++cAlias;
        }

        /*
         *   The list is terminated with a double NUL.
         */

        *pwch++ = L'\0';
    }

    /*   Now the face name:  we add bold, italic etc to family name */

    pIFI->dpwszFaceName = (BYTE *)pwch - (BYTE *)pIFI;

    strcpy2WChar( pwch, (LPSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */
    wcscat( pwch, awcAttrib );


    /*   Now the unique name - well, sort of, anyway */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszUniqueName = (BYTE *)pwch - (BYTE *)pIFI;

    wcscpy( pwch, pwstrUniqNm );        /* Append printer name for uniqueness */
    wcscat( pwch, L" " );
    wcscat( pwch, (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName) );

    /*  Onto the attributes only component */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszStyleName = (BYTE *)pwch - (BYTE *)pIFI;
    wcscat( pwch, &awcAttrib[ 1 ] );


#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "Rasdd!pfm2ifi: STACK CORRUPTED BY awcAttrib" );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;
    }


    if( ((BYTE *)(pwch + wcslen( pwch ) + 1)) > ((BYTE *)pIFI + cbAlloc) )
    {
        DbgPrint( "Rasdd!pfm2ifi: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwch + wcslen( pwch ) + 1)),
                ((BYTE *)pIFI + cbAlloc) );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;

    }
#endif

    pIFI->dpFontSim   = 0;
    {
        //int i;

        pIFI->lEmbedId     = 0;
        pIFI->lItalicAngle = 0;
        pIFI->lCharBias    = 0;
        /*for (i=0;i<IFI_RESERVED;i++)
            pIFI->alReserved[i] = 0;*/
        pIFI->dpCharSets=0;
    }
    pIFI->jWinCharSet = (BYTE)pFDat->PFMH.dfCharSet;


    if( pFDat->PFMH.dfPixWidth )
    {
        pIFI->jWinPitchAndFamily |= FIXED_PITCH;
        pIFI->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);
    }
    else
        pIFI->jWinPitchAndFamily |= VARIABLE_PITCH;


    pIFI->jWinPitchAndFamily |= (((BYTE) pFDat->PFMH.dfPitchAndFamily) & 0xf0);

    pIFI->usWinWeight = (USHORT)pFDat->PFMH.dfWeight;

//
// IFIMETRICS::flInfo
//
    pIFI->flInfo |=
        FM_INFO_TECH_BITMAP    |
        FM_INFO_1BPP           |
        FM_INFO_INTEGER_WIDTH  |
        FM_INFO_NOT_CONTIGUOUS |
        FM_INFO_RIGHT_HANDED;

    /*  Set the alias bit,  if we have added an alias!  */

    if( cAlias )
        pIFI->flInfo |= FM_INFO_FAMILY_EQUIV;


    /*
     *    A scalable font?  This happens when there is EXTTEXTMETRIC data,
     *  and that data has a min size different to the max size.
     */

    if( pFDat->pETM && (pFDat->pETM->emMinScale != pFDat->pETM->emMaxScale) )
    {
       pIFI->flInfo        |= FM_INFO_ISOTROPIC_SCALING_ONLY;
       pIFI->fwdUnitsPerEm  = pFDat->pETM->emMasterUnits;
    }
    else
    {
        pIFI->fwdUnitsPerEm =
            (FWORD) (pFDat->PFMH.dfPixHeight - pFDat->PFMH.dfInternalLeading);
    }

    pIFI->fsSelection =
        ((pFDat->PFMH.dfItalic            ) ? FM_SEL_ITALIC     : 0)    |
        ((pFDat->PFMH.dfUnderline         ) ? FM_SEL_UNDERSCORE : 0)    |
        ((pFDat->PFMH.dfStrikeOut         ) ? FM_SEL_STRIKEOUT  : 0)    |
        ((pFDat->PFMH.dfWeight >= FW_BOLD ) ? FM_SEL_BOLD       : 0) ;

    pIFI->fsType        = FM_NO_EMBEDDING;
    pIFI->fwdLowestPPEm = 1;


    /*
     * Calculate fwdWinAscender, fwdWinDescender, fwdAveCharWidth, and
     * fwdMaxCharInc assuming a bitmap where 1 font unit equals one
     * pixel unit
     */

    pIFI->fwdWinAscender = (FWORD)pFDat->PFMH.dfAscent;

    pIFI->fwdWinDescender =
        (FWORD)pFDat->PFMH.dfPixHeight - pIFI->fwdWinAscender;

    pIFI->fwdMaxCharInc   = (FWORD)pFDat->PFMH.dfMaxWidth;
    pIFI->fwdAveCharWidth = (FWORD)pFDat->PFMH.dfAvgWidth;

    fwdExternalLeading = (FWORD)pFDat->PFMH.dfExternalLeading;

//
// If the font was scalable, then the answers must be scaled up
// !!! HELP HELP HELP - if a font is scalable in this sense, then
//     does it support arbitrary transforms? [kirko]
//

    if( pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
    {
        /*
         *    This is a scalable font:  because there is Extended Text Metric
         *  information available,  and this says that the min and max
         *  scale sizes are different:  thus it is scalable! This test is
         *  lifted directly from the Win 3.1 driver.
         */

        int iMU,  iRel;            /* Adjustment factors */

        iMU  = pFDat->pETM->emMasterUnits;
        iRel = pFDat->PFMH.dfPixHeight;

        pIFI->fwdWinAscender = (pIFI->fwdWinAscender * iMU) / iRel;

        pIFI->fwdWinDescender = (pIFI->fwdWinDescender * iMU) / iRel;

        pIFI->fwdMaxCharInc = (pIFI->fwdMaxCharInc * iMU) / iRel;

        pIFI->fwdAveCharWidth = (pIFI->fwdAveCharWidth * iMU) / iRel;

        fwdExternalLeading = (fwdExternalLeading * iMU) / iRel;
    }

    pIFI->fwdMacAscender =    pIFI->fwdWinAscender;
    pIFI->fwdMacDescender = - pIFI->fwdWinDescender;

    pIFI->fwdMacLineGap   =  fwdExternalLeading;

    pIFI->fwdTypoAscender  = pIFI->fwdMacAscender;
    pIFI->fwdTypoDescender = pIFI->fwdMacDescender;
    pIFI->fwdTypoLineGap   = pIFI->fwdMacLineGap;

    if( pFDat->pETM )
    {
        /*
         *    Zero is a legitimate default for these.  If 0, gdisrv
         *  chooses some default values.
         */
        pIFI->fwdCapHeight = pFDat->pETM->emCapHeight;
        pIFI->fwdXHeight = pFDat->pETM->emXHeight;

        pIFI->fwdSubscriptYSize = pFDat->pETM->emSubScriptSize;
        pIFI->fwdSubscriptYOffset = pFDat->pETM->emSubScript;

        pIFI->fwdSuperscriptYSize = pFDat->pETM->emSuperScriptSize;
        pIFI->fwdSuperscriptYOffset = pFDat->pETM->emSuperScript;

        pIFI->fwdUnderscoreSize = pFDat->pETM->emUnderlineWidth;
        pIFI->fwdUnderscorePosition = pFDat->pETM->emUnderlineOffset;

        pIFI->fwdStrikeoutSize = pFDat->pETM->emStrikeOutWidth;
        pIFI->fwdStrikeoutPosition = pFDat->pETM->emStrikeOutOffset;

    }
    else
    {
        /*  No additional information, so do some calculations  */
        pIFI->fwdSubscriptYSize = pIFI->fwdWinAscender/4;
        pIFI->fwdSubscriptYOffset = -(pIFI->fwdWinAscender/4);

        pIFI->fwdSuperscriptYSize = pIFI->fwdWinAscender/4;
        pIFI->fwdSuperscriptYOffset = (3 * pIFI->fwdWinAscender)/4;

        pIFI->fwdUnderscoreSize = pIFI->fwdWinAscender / 12;
        if( pIFI->fwdUnderscoreSize < 1 )
            pIFI->fwdUnderscoreSize = 1;

        pIFI->fwdUnderscorePosition = -pFDat->DI.sUnderLinePos;

        pIFI->fwdStrikeoutSize     = pIFI->fwdUnderscoreSize;

        pIFI->fwdStrikeoutPosition = (FWORD)pFDat->DI.sStrikeThruPos;
        if( pIFI->fwdStrikeoutPosition  < 1 )
            pIFI->fwdStrikeoutPosition = (pIFI->fwdWinAscender + 2) / 3;
    }

    pIFI->fwdSubscriptXSize = pIFI->fwdAveCharWidth/4;
    pIFI->fwdSubscriptXOffset =  (3 * pIFI->fwdAveCharWidth)/4;

    pIFI->fwdSuperscriptXSize = pIFI->fwdAveCharWidth/4;
    pIFI->fwdSuperscriptXOffset = (3 * pIFI->fwdAveCharWidth)/4;



    pIFI->chFirstChar = pFDat->PFMH.dfFirstChar;
    pIFI->chLastChar  = pFDat->PFMH.dfLastChar;

    /*
     *   We now do the conversion of these to Unicode.  We presume the
     * input is in the ANSI code page,  and call the NLS converion
     * functions to generate proper Unicode values.
     */

    iCount = pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 1;

    for( iI = 0; iI < iCount; ++iI )
        abyte[ iI ] = iI + pFDat->PFMH.dfFirstChar;

    MultiByteToWideChar( CP_ACP, 0, (LPCSTR) abyte, iCount, awcAttrib, iCount );

    /*
     *   Now fill in the IFIMETRICS WCHAR fields.
     */

    pIFI->wcFirstChar = 0xffff;
    pIFI->wcLastChar = 0;

    /*   Look for the first and last  */
    for( iI = 0; iI < iCount; ++iI )
    {
        if( pIFI->wcFirstChar > awcAttrib[ iI ] )
            pIFI->wcFirstChar = awcAttrib[ iI ];

        if( pIFI->wcLastChar < awcAttrib[ iI ] )
            pIFI->wcLastChar = awcAttrib[ iI ];

    }

    pIFI->wcDefaultChar = awcAttrib[ pFDat->PFMH.dfDefaultChar ];
    pIFI->wcBreakChar = awcAttrib[ pFDat->PFMH.dfBreakChar ];

    pIFI->chDefaultChar = pFDat->PFMH.dfDefaultChar + pFDat->PFMH.dfFirstChar;
    pIFI->chBreakChar   = pFDat->PFMH.dfBreakChar   + pFDat->PFMH.dfFirstChar;


    if( pFDat->PFMH.dfItalic )
    {
    //
    // tan (17.5 degrees) = .3153
    //
        pIFI->ptlCaret.x      = 3153;
        pIFI->ptlCaret.y      = 10000;
    }
    else
    {
        pIFI->ptlCaret.x      = 0;
        pIFI->ptlCaret.y      = 1;
    }

    pIFI->ptlBaseline.x = 1;
    pIFI->ptlBaseline.y = 0;

    pIFI->ptlAspect.x =  pFDat->PFMH.dfHorizRes;
    pIFI->ptlAspect.y =  pFDat->PFMH.dfVertRes;

    pIFI->rclFontBox.left   = 0;
    pIFI->rclFontBox.top    =   (LONG) pIFI->fwdWinAscender;
    pIFI->rclFontBox.right  =   (LONG) pIFI->fwdMaxCharInc;
    pIFI->rclFontBox.bottom = - (LONG) pIFI->fwdWinDescender;

    pIFI->achVendId[0] = 'U';
    pIFI->achVendId[1] = 'n';
    pIFI->achVendId[2] = 'k';
    pIFI->achVendId[3] = 'n';

    pIFI->cKerningPairs = 0;

    pIFI->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    pIFI->panose.bFamilyType      = PAN_ANY;
    pIFI->panose.bSerifStyle      = PAN_ANY;
    if(pFDat->PFMH.dfWeight >= FW_BOLD)
    {
        pIFI->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else if (pFDat->PFMH.dfWeight > FW_EXTRALIGHT)
    {
        pIFI->panose.bWeight = PAN_WEIGHT_MEDIUM;
    }
    else
    {
        pIFI->panose.bWeight = PAN_WEIGHT_LIGHT;
    }
    pIFI->panose.bProportion      = PAN_ANY;
    pIFI->panose.bContrast        = PAN_ANY;
    pIFI->panose.bStrokeVariation = PAN_ANY;
    pIFI->panose.bArmStyle        = PAN_ANY;
    pIFI->panose.bLetterform      = PAN_ANY;
    pIFI->panose.bMidline         = PAN_ANY;
    pIFI->panose.bXHeight         = PAN_ANY;

    return   pIFI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\pfmconv.c ===
/******************************************************************************

  Source File:  PFMConv.C

  This file is a hack- NT Build can't traverse directories on a SOURCES= line,
  so this file #includes all of the files I need for PFM conversion from 
  elsewhere in the tree.

  Copyright c) 1997 by Microsoft Corporation

  Change History:
  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Created it, hope I never touch it
  again...

******************************************************************************/

#undef	DBG
#include "..\..\pfm2ufm\pfm2ufm.c"
#include "..\..\pfm2ufm\pfmconv.c"
#include	"..\..\..\..\lib\uni\fontutil.c"
#include	"..\..\..\..\lib\uni\globals.c"
#include	"..\..\..\..\lib\uni\unilib.c"
#include	"..\..\..\..\lib\uni\um\umlib.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\projnode.cpp ===
/******************************************************************************

  Source File:  Project Node.CPP

  This implements the CProjectNode class which alows individual nodes in the
  tree view to control their behavior without the control itself having to know
  what all that behavior is.

  The original header file (from the prototype) said this class didn't need an
  implementation file, but this no longer makes sense, so it's bite the bullet
  time here at Pretty Penny Enterprises...

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard#Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "..\Resource.H"
#if defined(LONG_NAMES)
#include    "Project Node.H"
#else
#include    "ProjNode.H"
#endif

IMPLEMENT_SERIAL(CBasicNode, CObject, 0)

CBasicNode::CBasicNode() { 
    m_pcmcwEdit = NULL; 
    m_pcdOwner = NULL;
    m_pctcOwner = NULL;
    m_hti = NULL;
    m_pcbnWorkspace = NULL;
}

CBasicNode::~CBasicNode() {
    if (m_pcmcwEdit)
        m_pcmcwEdit -> DestroyWindow();
}

//  Name ourselves and children- default to just our name, no children

void    CBasicNode::Fill(CTreeCtrl *pctcWhere, HTREEITEM htiParent) {
    m_pctcOwner = pctcWhere;
    m_hti = pctcWhere -> InsertItem(m_csName, htiParent);
    pctcWhere -> SetItemData(m_hti, (DWORD) this);
}

//  Display a context menu using the ID array, if it has any members

void    CBasicNode::ContextMenu(CWnd *pcw, CPoint cp) {

    if  (!m_cwaMenuID.GetSize())
        return;

    CMenu   cmThis;

    if  (!cmThis.CreatePopupMenu())
        return;

    for (int i = 0; i < m_cwaMenuID.GetSize(); i++) {

        if  (m_cwaMenuID[i]) {
            CString csWork;

            csWork.LoadString(m_cwaMenuID[i]);
            cmThis.AppendMenu(MF_STRING | MF_ENABLED, m_cwaMenuID[i], csWork);
        }
        else
            cmThis.AppendMenu(MF_SEPARATOR);
    }

    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cp.x, cp.y, pcw);
}



//  This override is called if our label is edited, or we are otherwise
//  renamed...
BOOL    CBasicNode::Rename(LPCTSTR lpstrNewName) {
    if  (!lpstrNewName)
        return  FALSE;

    if  (lpstrNewName == m_csName)
        return  TRUE;

    //  We'll return TRUE, unless the rename produces an exception
    try {
        m_csName = lpstrNewName;
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    WorkspaceChange();
    return  TRUE;
}

void    CBasicNode::Edit() {
    if  (!m_pcmcwEdit)
        m_pcmcwEdit = CreateEditor();
    else
        if  (IsWindow(m_pcmcwEdit -> m_hWnd))
            m_pcmcwEdit -> ActivateFrame();
}

/******************************************************************************\

  CBasicNode::Serialize

  Pretty simple- the names the only field we will be keeping...

******************************************************************************/

void    CBasicNode::Serialize(CArchive& car) {
    CObject::Serialize(car);
    if  (car.IsLoading())
        car >> m_csName;
    else
        car << m_csName;
}

/******************************************************************************

  CFixedNode implementation

******************************************************************************/

IMPLEMENT_DYNAMIC(CFixedNode, CBasicNode)

CFixedNode::CFixedNode(unsigned uidName, CSafeObArray& csoa, 
                       CMultiDocTemplate *pcmdt, CRuntimeClass *pcrc) :
    m_csoaDescendants(csoa) {
    m_uidName = uidName;
    m_pcmdt = pcmdt;
    m_pcrc = pcrc;
}

/******************************************************************************

  CFixedNode::Zap

  This method is called when an underlying object is to be destroyed.  It finds
  a matching pointer in the array, and then deletes that entry.

******************************************************************************/

void    CFixedNode::Zap(CBasicNode *pcbn) {
    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++)
        if  (pcbn == m_csoaDescendants[u]) {
            HTREEITEM   htiGone = pcbn -> Handle();

            m_csoaDescendants.RemoveAt(u);
            Changed();
            m_pctcOwner -> DeleteItem(htiGone);
            CString csWork;

            csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
            m_csName.LoadString(m_uidName);
            m_csName += csWork;
            m_pctcOwner -> SetItemText(m_hti, m_csName);
            return;
        }
}

/******************************************************************************

  CFixedNode::Import

  This member function will import one or more files of the given type if there
  is a document template and dynamic constructor available.  It uses the 
  template to customize the File Open dialog, and the constructor to build the
  elements.

******************************************************************************/

void    CFixedNode::Import() {
    if  (!m_pcmdt || !m_pcrc || !m_pcrc -> m_pfnCreateObject)
        return;

    CString csExtension, csFilter;

    m_pcmdt -> GetDocString(csExtension, CDocTemplate::filterExt); 
    m_pcmdt -> GetDocString(csFilter, CDocTemplate::filterName);
    csFilter += _T("|*") + csExtension + _T("||");

    CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        m_pctcOwner);

    if  (cfd.DoModal() != IDOK)
        return;

    //  Import all of the named files...

    for (POSITION pos = cfd.GetStartPosition(); pos; ) {

        //  Create the underlying object using dynamic creation.  Only a 
        //  CProjectNode has the required function, here.

        CProjectNode*   pcpn = (CProjectNode *) m_pcrc -> CreateObject();

        if  (!pcpn || !pcpn -> IsKindOf(RUNTIME_CLASS(CProjectNode))) {
            TRACE("Imported object not derived from CProjectNode");
            delete  pcpn;
            continue;
        }

        pcpn -> SetFileName(cfd.GetNextPathName(pos));
        pcpn -> Rename(pcpn -> FileTitle());
        pcpn -> NoteOwner(*m_pcdOwner);
        pcpn -> SetWorkspace(m_pcbnWorkspace);
        m_csoaDescendants.Add(pcpn);
        WorkspaceChange();
        pcpn -> EditorInfo(m_pcmdt);
        pcpn -> Fill(m_pctcOwner, m_hti);
    }

    //  Now, update our own appearance (get the count right)
    CString csWork;

    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);
}

/******************************************************************************

  CFixedNode::Fill

  This is a generic fill- the node names itself, then fills its node using the
  array of nodes given to it at init time.

******************************************************************************/

void    CFixedNode::Fill(CTreeCtrl *pctc, HTREEITEM hti) {
    CString csWork;

    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    CBasicNode::Fill(pctc, hti);
    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++)
        ((CBasicNode *) m_csoaDescendants[u]) -> Fill(pctc, m_hti);
    if  (m_pcmdt && m_pcrc && m_pcrc -> m_pfnCreateObject) {
        //  Insert the Import menu item
        m_cwaMenuID.InsertAt(0, ID_Import);
        m_cwaMenuID.InsertAt(1, (WORD) 0);
    }
}

/******************************************************************************

  CFileNode implementation

******************************************************************************/

IMPLEMENT_SERIAL(CFileNode, CBasicNode, 0);

CFileNode::CFileNode() {
    m_cwaMenuID.Add(ID_RenameItem);
    m_bEditPath = FALSE;
    m_bCheckForValidity = TRUE;
}

/******************************************************************************

  CFileNode::Rename

  If there is no name currently, then see if the named file can be created.
  The other case, means the file should already be on the disk, so it is a bit 
  trickier.

  First, check to see if the name violates the current naming conventions.  If
  so, reject it.  Then attempt to move the file.  IF the name is OK and the
  file is moved, set the new name in the item label.  Always returns FALSE.

******************************************************************************/

BOOL    CFileNode::Rename(LPCTSTR lpstrNew) {
    CString csNew = lpstrNew;

    if  (!lpstrNew) {   //  This only happens if the label edit was canceled.
        csNew.LoadString(IDS_FileName);
        if  (m_pctcOwner)
            m_pctcOwner -> SetItemText(m_hti, csNew + ViewName());
        WorkspaceChange();
        return  FALSE;
    }

    if  (m_csExtension.CompareNoCase(csNew.Right(m_csExtension.GetLength())))
        csNew += m_csExtension;
    if  (m_csName.IsEmpty()) {
        CFile   cfTemp;

        //  This check needs to be optional since in some instances, we know
        //  the name is valid because the file is open, and we're just trying
        //  to collect the name.

        if  (!cfTemp.Open(csNew, CFile::modeCreate | CFile::modeNoTruncate |
            CFile::modeWrite | CFile::shareDenyNone) && m_bCheckForValidity) {
            CString csWork, csDisplay;

            csWork.LoadString(IDS_InvalidFilename);
            csDisplay.Format(csWork, (LPCTSTR) csNew);
            AfxMessageBox(csDisplay);
            return  FALSE;
        }

        try {
            m_csPath = cfTemp.GetFilePath();
            m_csPath = m_csPath.Left(1 + m_csPath.ReverseFind(_T('\\')));
        }
        catch   (CException *pce) {
            pce -> ReportError();
            pce -> Delete();
            return  FALSE;
        }

        //  If the file type isn't registered, then GetFileTitle returns the
        //  extension, so strip it!

        csNew = cfTemp.GetFileTitle();
        if  (!m_csExtension.CompareNoCase(csNew.Right(
             m_csExtension.GetLength())))
            csNew = csNew.Left(csNew.GetLength() - m_csExtension.GetLength());

        return  CBasicNode::Rename(csNew);  //  OK from this path
    }

    //  Strip any path if it cannot be changed, and substitute the real one

    if  (!m_bEditPath)
        csNew = m_csPath + csNew.Mid(1 + csNew.ReverseFind(_T('\\')));

    try {
        LPSTR   lpstr;

        CFile::Rename(FullName(), csNew);

        GetFullPathName(csNew, MAX_PATH, csNew.GetBuffer(MAX_PATH), &lpstr);
        csNew.ReleaseBuffer();
        m_csPath = csNew.Left(1 + csNew.ReverseFind(_T('\\')));
        csNew = csNew.Mid(m_csPath.GetLength());
        m_csName = csNew.Left(csNew.GetLength() - 
            m_csExtension.GetLength());
        csNew.LoadString(IDS_FileName);
        if  (m_pctcOwner)
            m_pctcOwner -> SetItemText(m_hti, csNew + m_csName);
        WorkspaceChange();
        return  FALSE;  //  Force the change (above) to be kept.
    }
    catch   (CFileException *pcfe) {    //  Don't get a file name with statics
        if  (pcfe -> m_cause == ERROR_FILE_NOT_FOUND)
            csNew = FullName();
        pcfe -> m_strFileName = csNew;
        pcfe -> ReportError();
        pcfe -> Delete();
        return  FALSE;
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }
}

/******************************************************************************

  CFileNode::CanEdit

  This will return TRUE, but it will first have to remove the File Name: stuff
  from the label, so we can get a cleaner edit.

******************************************************************************/

BOOL    CFileNode::CanEdit() const {

    CEdit*   pce = m_pctcOwner -> GetEditControl();
    if  (pce)
        pce -> SetWindowText(m_bEditPath ? m_csPath + m_csName : m_csName);
    return  !!pce;
}

/******************************************************************************

  CFileNode::Fill

  We play a bit of a game here, changing our name temporarily to use the base 
  class implementation.

******************************************************************************/

void    CFileNode::Fill(CTreeCtrl* pctc, HTREEITEM htiParent) {
    CString csTemp = Name();

    m_csName.LoadString(IDS_FileName);
    m_csName += csTemp;
    CBasicNode::Fill(pctc, htiParent);
    m_csName = csTemp;
}

/******************************************************************************

  CFileNode::Serialize

  Since the name is civered by the base class, we only need to serialize the 
  boolean controlling long/short file names.

******************************************************************************/

void    CFileNode::Serialize(CArchive& car) {
    CBasicNode::Serialize(car);
    if  (car.IsLoading())
        car >> m_csPath;
    else
        car << m_csPath;
}

/******************************************************************************

  CProjectNode implementation

******************************************************************************/

IMPLEMENT_SERIAL(CProjectNode, CBasicNode, 0)

CProjectNode::CProjectNode() {
    m_pcmdt = NULL;
}

void    CProjectNode::Fill(CTreeCtrl *pctc, HTREEITEM hti) {
    CBasicNode::Fill(pctc, hti);
    m_cfn.SetWorkspace(m_pcbnWorkspace);
    m_cfn.Fill(pctc, m_hti);
}

void    CProjectNode::Serialize(CArchive& car) {
    CBasicNode::Serialize(car);
    m_cfn.Serialize(car);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\raslib.h ===
/************************** Module Header ***********************************
 * raslib.h
 *      Include file to provide prototypes and data types for the rasdd
 *      private library.
 *
 * Copyright (C) 1992 - 1993    Microsoft Corporation.
 *
 *****************************************************************************/

/*
 *   The simple way to turn ANSI to UNICODE>
 */


/*
 *   A convenient grouping for passing around information about the
 * Win 3.1 font information.
 */

typedef  struct
{
    BYTE           *pBase;      /* The base address of data area */
    DRIVERINFO      DI;         /* DRIVERINFO for this font */
    PFMHEADER       PFMH;       /* Properly aligned, not resource format */
    PFMEXTENSION    PFMExt;     /* Extended PFM data,  properly aligned! */
    EXTTEXTMETRIC  *pETM;       /* Extended text metric */
} FONTDAT;

/*
 *   Function prototypes for functions that convert Win 3.1 PFM style
 *  font info to the IFIMETRICS etc required by NT.
 */

/*   Convert PFM style metrics to IFIMETRICS  */
IFIMETRICS *FontInfoToIFIMetric( FONTDAT  *, HANDLE, PWSTR, char ** );

/*   Extract the Command Descriptors for (de)selecting a font */
CD *GetFontSel( HANDLE, FONTDAT *, int );


/*   Convert from non-aligned x86 format Win 3.1 data to aligned versions */
void ConvFontRes( FONTDAT * );

/*   Obtain the width vector - proportionally spaced fonts only */
short  *GetWidthVector( HANDLE, FONTDAT * );

/*
 *     Functions to return the integer value in a WORD or DWORD.  Functions
 *  do two operations:   first is to align the data,  second is to
 *  adjuest the byte order to the current machine.  The input is
 *  assumed to be little endian,  like the x86.
 */

extern "C" WORD   DwAlign2( BYTE * );
extern "C" DWORD  DwAlign4( BYTE * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Font Knowledge Base.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FontEdit.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\projnode.h ===
/******************************************************************************

  Header File:  Project Node.H

  This describes the Project Node.  This keeps the Project Control Window code
  simple, by having a project node which can create new intances of itself, 
  import itself from another source, edit itself, etc.  Most Menu and tree view
  notification messages wind up being handled by being passed to the currently
  selected node on the tree, which will be an instance of a class derived from
  this one.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:
  12-16-96  KjelgaardR@acm.org  Created it

******************************************************************************/

#if !defined(PROJECT_NODES)

#define PROJECT_NODES

#if defined(LONG_NAMES)
#include    "Utility Classes.H"
#else
#include    "Utility.H"
#endif

//  CBasicNode - base class for stuff we can manipulate

class AFX_EXT_CLASS CBasicNode : public CObject {
    DECLARE_SERIAL(CBasicNode)
    CBasicNode*     m_pcbnWorkspace;//  Basic Node for the workspace

protected:
    CString         m_csName;       //  These should always have a name...
    HTREEITEM       m_hti;          //  Handle in the owning tree view
    CTreeCtrl       *m_pctcOwner;   //  The window that owns us
    CMDIChildWnd    *m_pcmcwEdit;   //  The window we're being edited in.
    CDocument       *m_pcdOwner;    //  Document we are part of
    CWordArray      m_cwaMenuID;    //  Menu auto-fill

    void    WorkspaceChange() { 
        if  (m_pcbnWorkspace)
            m_pcbnWorkspace -> Changed();
    }

public:
    CBasicNode();
    ~CBasicNode();

    CString         Name() const { return m_csName; }

    HTREEITEM   Handle() const { return m_hti; }

    void    NoteOwner(CDocument& cdOwner) { m_pcdOwner = &cdOwner; }

    void    Changed(BOOL bModified = TRUE) { 
        if (m_pcdOwner) m_pcdOwner -> SetModifiedFlag(bModified); 
    }

    void    SetWorkspace(CBasicNode* pcbnWS) { m_pcbnWorkspace = pcbnWS; }

    //  Name ourselves and children- default to just our name, no children
    virtual void    Fill(CTreeCtrl *pctcWhere, 
                         HTREEITEM htiParent = TVI_ROOT);
    
    //  Overridable functions to allow polymorphic tree node handling
    virtual void            ContextMenu(CWnd *pcw, CPoint cp);
    virtual CMDIChildWnd    *CreateEditor() { return NULL; }
    virtual BOOL            CanEdit() const { return  TRUE; }
    virtual void            Delete() { }  //  Default is don't honor it!
    virtual void            Import() { }    //  Never at this level!
    //  This override is called if our label is edited, or we are otherwise
    //  renamed...
    virtual BOOL            Rename(LPCTSTR lpstrNewName);

    void    Edit();
    void    OnEditorDestroyed() { m_pcmcwEdit = NULL; }

    virtual void    Serialize(CArchive& car);
    
};

//  This is a special class for nodes with constant names.

class AFX_EXT_CLASS CFixedNode : public CBasicNode {
    unsigned        m_uidName;
    CSafeObArray    &m_csoaDescendants;
    CMultiDocTemplate*  m_pcmdt;    //  Used for importing data
    CRuntimeClass*      m_pcrc;     //  The second half of the import
    DECLARE_DYNAMIC(CFixedNode)

public:
    CFixedNode(unsigned uidName, CSafeObArray& csoa, 
               CMultiDocTemplate *pcmdt = NULL, CRuntimeClass *pcrc = NULL);

    void    SetMenu(CWordArray& cwaSpec) { m_cwaMenuID.Copy(cwaSpec); }

    //  GPD Deletion support

    void    Zap(CBasicNode * pcbn);

    virtual BOOL    CanEdit() const { return FALSE; }
    virtual void    Import();
    virtual void    Fill(CTreeCtrl *pctc, HTREEITEM hti);
};

class AFX_EXT_CLASS CFileNode : public CBasicNode {
    
    BOOL    m_bEditPath, m_bCheckForValidity;
    CString m_csExtension, m_csPath;

    DECLARE_SERIAL(CFileNode)

    const CString ViewName() { 
        return m_bEditPath ? m_csPath + m_csName : m_csName;
    }

public:
    CFileNode();

    //  Attributes
    CString FullName() const { return m_csPath + Name() + m_csExtension; }
    const CString   Path() const { return m_csPath; }
    const CString   Extension() const { return m_csExtension; }
    virtual BOOL    CanEdit() const;
    //  Operations
    void    SetExtension(LPCTSTR lpstrExt) { m_csExtension = lpstrExt; }
    void    AllowPathEdit(BOOL bOK = TRUE) { m_bEditPath = bOK; }
    void    EnableCreationCheck(BOOL bOn = TRUE) { m_bCheckForValidity = bOn; }

    //  Overriden CBasicNode operations

    virtual BOOL    Rename(LPCTSTR lpstrNewName);
    virtual void    Fill(CTreeCtrl* pctc, HTREEITEM htiParent);
    virtual void    Serialize(CArchive& car);
};

//  We bring it all together in a limited fashion at least, for the project
//  level node- it always contains a file name node.

class AFX_EXT_CLASS CProjectNode : public CBasicNode {
    DECLARE_SERIAL(CProjectNode)

protected:
    CMultiDocTemplate*  m_pcmdt;
    CFileNode           m_cfn;

public:
    CProjectNode();

    const CString   FileName() const { return m_cfn.FullName(); }
    const CString   FileTitle() const { return m_cfn.Name(); }

    BOOL    SetFileName(LPCTSTR lpstrNew) { return m_cfn.Rename(lpstrNew); }
    void    EditorInfo(CMultiDocTemplate* pcmdt) { m_pcmdt = pcmdt; }
    BOOL    ReTitle(LPCTSTR lpstrNewName) {
        return m_cfn.CBasicNode::Rename(lpstrNewName);
    }

    virtual void    Fill(CTreeCtrl *pctcWhere, 
                         HTREEITEM htiParent = TVI_ROOT);

    virtual void    Serialize(CArchive& car);
    
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\utility.h ===
/******************************************************************************

  Header File:  Utility Classes.H

  These classes are generally useful classes which can be used for a variety
  of purposes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(UTILITY_CLASSES)
#define UTILITY_CLASSES

/******************************************************************************

  CMapWordToDWord class

  This class uses CMapWordToPtr to do its dirty work.  When the need arises, I
  will make it serializable

******************************************************************************/

class AFX_EXT_CLASS CMapWordToDWord : public CMapWordToPtr {

public:
    unsigned    Count() const { return CMapWordToPtr::GetCount(); }
    BOOL        Lookup(WORD wKey, DWORD& dwItem) const;

    void        GetNextAssoc(POSITION& pos, WORD& wKey, DWORD& dwItem) const;

    DWORD&      operator[](WORD wKey);
};

/******************************************************************************

  CSafeObArray- This class, unlike CObArray, will delete any objects removed
  from the array.  Otherwise it is identical.

******************************************************************************/

class AFX_EXT_CLASS CSafeObArray : public CObject {
    CObArray    m_coa;
    DECLARE_SERIAL(CSafeObArray)
public:
    CSafeObArray() {}
    ~CSafeObArray();

    //  Attributes
    unsigned    GetSize() const { return (unsigned) m_coa.GetSize(); }
    CObject*    operator[](unsigned u) const { return m_coa.GetAt(u); }

    //Operations
    void    Add(CObject *pco) { m_coa.Add(pco); }
    void    InsertAt(unsigned uid, CObject *pco) { m_coa.InsertAt(uid, pco); }
    void    RemoveAll();
    void    RemoveAt(int i);
    void    SetAt(int i);
    void    Copy(const CObArray& coa);

    virtual void    Serialize(CArchive& car);
};

/******************************************************************************

  CSafeMapWordToOb

  This class encapsulates a CMapWordToOb object, but it does what the 
  documentation says the CMapWordToOb does, and definitely oes not do- delete
  the underling objects when the map no longer references them!

******************************************************************************/

class AFX_EXT_CLASS CSafeMapWordToOb : public CObject {
    CMapWordToOb    m_cmw2o;
    DECLARE_SERIAL(CSafeMapWordToOb)

public:
    CSafeMapWordToOb() {}
    ~CSafeMapWordToOb();

    //  Attributes

    unsigned    GetCount() const { return (unsigned) m_cmw2o.GetCount(); }

    BOOL    Lookup(WORD wKey, CObject*& pco) const { 
        return m_cmw2o.Lookup(wKey, pco);
    }

    POSITION    GetStartPosition() const { return m_cmw2o.GetStartPosition(); }

    void        GetNextAssoc(POSITION& pos, WORD& wKey, CObject*& pco) const {
        m_cmw2o.GetNextAssoc(pos, wKey, pco);
    }

    //  Operations

    CObject*&   operator[](WORD wKey);
    BOOL        RemoveKey(WORD wKey);
    void        RemoveAll();

    virtual void    Serialize(CArchive& car);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\writefnt.cpp ===
/******************************* MODULE HEADER *******************************
 * writefnt.c
 *      Function to take a FI_DATA_HEADER structure and write the data to
 *      the passed in file handle as a font record.  This layout is used
 *      in both minidrivers and the font installer font file.
 *
 * Copyright (C) 1992   Microsoft Corporation.
 *
 *****************************************************************************/

#include        "StdAfx.H"
#include        "fontinst.h"

/************************* Function Header *********************************
 * bWrite
 *      Writes data out to a file handle.  Returns TRUE on success.
 *      Functions as a nop if the size request is zero.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  17:38 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      # 1
 *
 ****************************************************************************/

static BOOL    bWrite(HANDLE hFile, PVOID pvBuf, int iSize ) {
    /*
     *   Simplify the ugly NT interface.  Returns TRUE if the WriteFile
     * call returns TRUE and the number of bytes written equals the
     * number of bytes desired.
     */

    
    BOOL   bRet;
    DWORD  dwSize;              /* Filled in by WriteFile */


    bRet = TRUE;

    if( iSize > 0 &&
        (!WriteFile( hFile, pvBuf, (DWORD)iSize, &dwSize, NULL ) ||
         (DWORD)iSize != dwSize) )
             bRet = FALSE;              /* Too bad */


    return  bRet;
}

/******************************* Function Header *****************************
 * iWriteFDH
 *      Write the FI_DATA_HEADER data out to our file.  We do the conversion
 *      from addresses to offsets, and write out any data we find.
 *
 * RETURNS:
 *      The number of bytes actually written; -1 for error, 0 for nothing.
 *
 * HISTORY:
 *  16:58 on Thu 05 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      Based on an experimental version first used in font installer.
 *
 *  17:11 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 *****************************************************************************/

int iWriteFDH(HANDLE hFile, FI_DATA *pFD) {
    /*
     *   Decide how many bytes will be written out.  We presume that the
     * file pointer is located at the correct position when we are called.
     */

    int  iSize;         /* Evaluate output size */


    FI_DATA_HEADER   fdh;       /* Header written to file */




    if  (!pFD)
        return  0;      /* Perhaps only deleting?  */

    memset( &fdh, 0, sizeof( fdh ) );           /* Zero for convenience */

    /*
     *  Set the miscellaneous flags etc.
     */

    fdh.cjThis = sizeof( fdh );

    fdh.fCaps = pFD->fCaps;
    fdh.wFontType= pFD->wFontType; /* Device Font Type */

    fdh.wXRes = pFD->wXRes;
    fdh.wYRes = pFD->wYRes;

    fdh.sYAdjust = pFD->sYAdjust;
    fdh.sYMoved = pFD->sYMoved;

    fdh.u.sCTTid = (short)pFD->dsCTT.cBytes;

    fdh.dwSelBits = pFD->dwSelBits;

    fdh.wPrivateData = pFD->wPrivateData;


    iSize = sizeof( fdh );              /* Our header already */
    fdh.dwIFIMet = iSize;               /* Location of IFIMETRICS */

    iSize += pFD->dsIFIMet.cBytes;              /* Bytes in struct */

    /*
     *   And there may be a width table too!  The pFD values are zero if none.
     */

    if( pFD->dsWidthTab.cBytes )
    {
        fdh.dwWidthTab = iSize;

        iSize += pFD->dsWidthTab.cBytes;
    }

    /*
     *  Finally are the select/deselect strings.
     */

    if( pFD->dsSel.cBytes )
    {
        fdh.dwCDSelect = iSize;
        iSize += pFD->dsSel.cBytes;
    }

    if( pFD->dsDesel.cBytes )
    {
        fdh.dwCDDeselect = iSize;
        iSize += pFD->dsDesel.cBytes;
    }

    /*
     *   There may also be some sort of identification string.
     */

    if( pFD->dsIdentStr.cBytes )
    {
        fdh.dwIdentStr = iSize;
        iSize += pFD->dsIdentStr.cBytes;
    }

    if( pFD->dsETM.cBytes )
    {
        fdh.dwETM = iSize;
        iSize += pFD->dsETM.cBytes;
    }


    /*
     *   Sizes all figured out,  so write the data!
     */

    if( !bWrite( hFile, &fdh, sizeof( fdh ) ) ||
        !bWrite( hFile, pFD->dsIFIMet.pvData, pFD->dsIFIMet.cBytes ) ||
        !bWrite( hFile, pFD->dsWidthTab.pvData, pFD->dsWidthTab.cBytes ) ||
        !bWrite( hFile, pFD->dsSel.pvData, pFD->dsSel.cBytes ) ||
        !bWrite( hFile, pFD->dsDesel.pvData, pFD->dsDesel.cBytes ) ||
        !bWrite( hFile, pFD->dsIdentStr.pvData, pFD->dsIdentStr.cBytes ) ||
        !bWrite( hFile, pFD->dsETM.pvData, pFD->dsETM.cBytes ) )
                return   -1;


    return  iSize;                      /* Number of bytes written */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontedit\utility.cpp ===
/******************************************************************************

  Header File:  Utility Classes.CPP

  These classes are generally useful classes which can be used for a variety
  of purposes.  I created this separate file for quicker reuse later, and also
  to avoid having to include some very specific header file just to get these
  general-purpose classes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "Utility Classes.H"
#else
#include    "Utility.H"
#endif

/******************************************************************************

  CMapWordToDWord class

  This class uses CMapWordToPtr to do its dirty work.  When the need arises, I
  will make it serializable

******************************************************************************/

BOOL    CMapWordToDWord::Lookup(WORD wKey, DWORD& dwItem) const {
    union {
        void*   pv;
        DWORD   dw;
    };

    if  (!CMapWordToPtr::Lookup(wKey, pv))
        return  FALSE;

    dwItem = dw;
    return  TRUE;
}

/******************************************************************************

  CMapWordToDWord::GetNextAssoc

  This is the map iteration method.  We call the same method on the bas class,
  and update the DWORD parameter if the underlying method is successful.

******************************************************************************/

void    CMapWordToDWord::GetNextAssoc(POSITION& pos, WORD& wKey, 
                                      DWORD& dwItem) const {
    union {
        void*   pv;
        DWORD   dw;
    };

    CMapWordToPtr::GetNextAssoc(pos, wKey, pv);

    dwItem = dw;
}

/******************************************************************************

  CMapWordToDWord::Operator[]

  This implements an l-value only operator usable for adding new associations or
  updating existing ones.

******************************************************************************/

DWORD&  CMapWordToDWord::operator[](WORD wKey) {
    return  (DWORD&) CMapWordToPtr::operator[](wKey);
}

/******************************************************************************

  CSafeObArray class implementation

  This provides a "Safe" CObArray class which can't leak!

******************************************************************************/

IMPLEMENT_SERIAL(CSafeObArray, CObject, 0);

/******************************************************************************

  CSafeObArray::~CSafeObArray

  The class destructor will delete the object foreach non-NULL pointer in the 
  array.

******************************************************************************/

CSafeObArray::~CSafeObArray() {
    for (unsigned u = 0; u < GetSize(); u++)
        if  (m_coa[u])
            delete  m_coa[u];
}

/******************************************************************************

  CSafeObArray::RemoveAll

  Almost the same as the destructor, isn't it?

******************************************************************************/

void    CSafeObArray::RemoveAll() {
    for (unsigned u = 0; u < GetSize(); u++)
        if  (m_coa[u])
            delete  m_coa[u];

    m_coa.RemoveAll();
}

/******************************************************************************

  CSafeObArray::RemoveAt

  This removes one element from the array- after deleting it, of course.

******************************************************************************/

void    CSafeObArray::RemoveAt(int i) {
    if  (m_coa[i])
        delete  m_coa[i];
    m_coa.RemoveAt(i);
}

/******************************************************************************

  CSafeObArray::Serialize

  I call the CObject serializer to maintain the proper typ einformation, then
  let the CObArray serialize itself.

******************************************************************************/

void    CSafeObArray::Serialize(CArchive& car) {
    if  (car.IsLoading())
        RemoveAll();

    CObject::Serialize(car);
    m_coa.Serialize(car);
}

/******************************************************************************

  CSafeMapWordToOb implementation

  Making the workd safe for maps.

******************************************************************************/

IMPLEMENT_SERIAL(CSafeMapWordToOb, CObject, 0)

/******************************************************************************

  CSafeMapWordToOb::~CSafeMapWordToOb

  The class destructor must ensure the underlying objects are deleted.

******************************************************************************/

CSafeMapWordToOb::~CSafeMapWordToOb() {
    WORD    wKey;
    CObject *pco;

    for (POSITION pos = m_cmw2o.GetStartPosition(); pos; ) {
        m_cmw2o.GetNextAssoc(pos, wKey, pco);
        if  (pco)
            delete  pco;
    }
}

/******************************************************************************

  CSafeMapWordToOb::operator[]

  The problem here is that this is used only to put elements in the map-
  therefore, I intercept the call and delete any existing item.  This could 
  cause problems if the same pointer is re-inserted into the map, but for now,
  I'll take my chances.

******************************************************************************/

CObject*&   CSafeMapWordToOb::operator[](WORD wKey) {
    CObject*&   pco = m_cmw2o.operator[](wKey);

    if  (pco)   delete  pco;
    return  pco;
}

/******************************************************************************

  CSafeMapWordToOb::RemoveKey

  Pretty Obvious- if there was an object there, remove it.

******************************************************************************/

BOOL    CSafeMapWordToOb::RemoveKey(WORD wKey) {

    CObject *pco;

    if  (!m_cmw2o.Lookup(wKey, pco))
        return  FALSE;

    if  (pco)
        delete  pco;

    return m_cmw2o.RemoveKey(wKey);
}

/******************************************************************************

  CSafeMapWordToOb::RemoveAll

  Again, this is pretty obvious- destroy anything that lives!

******************************************************************************/

void    CSafeMapWordToOb::RemoveAll() {
    WORD    wKey;
    CObject *pco;

    for (POSITION pos = m_cmw2o.GetStartPosition(); pos; ) {
        GetNextAssoc(pos, wKey, pco);
        if  (pco)
            delete  pco;
    }

    m_cmw2o.RemoveAll();
}

/******************************************************************************

  CSafeMapWordToOb::Serialize

  First, I depopulate the map if it is being loaded.  Then I call the CObject
  serializer to handle run-time typing checks, and then serialize the
  underlying map.

******************************************************************************/

void    CSafeMapWordToOb::Serialize(CArchive& car) {
    if  (car.IsLoading())
        RemoveAll();

    CObject::Serialize(car);
    m_cmw2o.Serialize(car);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\convert.c ===
/******************************************************************************

  Source File:	Convert.C

  This is an NT Build hack.  It includes all of the "C" files used for the
  converter, because Build can't handle directories beyond ..

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved

  A Pretty Penny Enterprises Production

  Change History:

  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Did the dirty deed

******************************************************************************/

#include	"..\..\GPC2GPD\PrEntry.C"
#include	"..\..\GPC2GPD\UiEntry.C"
#include	"..\..\GPC2GPD\Utils.C"
#include    "..\..\GPC2GPD\GPC2GPD.C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\glue.cpp ===
/******************************************************************************

  Source File:  Glue.CPP

  This file contains the functions needed to make the GPD parser code work on
  both platforms, as well as stubs to support function I do not need to supply.

  Copyright (c) 1997 by Microsoft Corporation,  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03/28/1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#undef  AFX_EXT_CLASS
#define AFX_EXT_CLASS   __declspec(dllimport)
#include    "..\FontEdit\ProjNode.H"
#undef  AFX_EXT_CLASS
#define AFX_EXT_CLASS   __declspec(dllexport)
#include    "Resource.H"
#include    "GPDFile.H"

//  I'll use a class to guarantee memory never leaks from here.

class   CMaps {
    CObArray    m_coaMaps;

public:
    CMaps() { m_coaMaps.Add(NULL); }
    ~CMaps() {
        for (int i = 0; i < m_coaMaps.GetSize(); i++)
            if  (m_coaMaps[i])
                delete  m_coaMaps[i];
    }
    unsigned    Count() { return m_coaMaps.GetSize(); }
    unsigned    HandleFor(CByteArray* cba) {
        for (unsigned u = 1; u < Count(); u++) {
            if  (!m_coaMaps[u]) {
                m_coaMaps[u] = cba;
                return  u;
            }
        }
        m_coaMaps.Add(cba);
        return  Count();
    }

    void    Free(unsigned u) {
        if  (!u || u >= Count() || !m_coaMaps[u])
            return;

        delete  m_coaMaps[u];
        m_coaMaps[u] = NULL;
    }
};

static CMaps    scmAll;

extern "C" unsigned MapFileIntoMemory(LPCWSTR pstrFile, PVOID *ppvData, 
                                      PDWORD pdwSize) {

    if  (!pstrFile || !ppvData || !pdwSize)
        return  0;

    CFile   cfMap;
    CByteArray* pcbaMap = new CByteArray;
    CString csFile(pstrFile);

    if  (!pcbaMap)
        return  0;

    if  (!cfMap.Open(csFile, CFile::modeRead | CFile::shareDenyWrite))
        return  0;

    try {
        pcbaMap -> SetSize(*pdwSize = cfMap.GetLength());
        cfMap.Read(pcbaMap -> GetData(), cfMap.GetLength());
        *ppvData = pcbaMap -> GetData();
        return  scmAll.HandleFor(pcbaMap);
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  0;
}

extern "C" void UnmapFileFromMemory(unsigned uFile) {
    scmAll.Free(uFile);
}

//  This one is just a stub to make the whole thing work for us- we don't use
//  the checksum- it's there for the end product to tell if a GPD file has
//  been altered since it was converted lase.

extern "C" DWORD    ComputeCrc32Checksum(PBYTE pbuf,DWORD dwCount, 
                                         DWORD dwChecksum) {
    return  dwCount ^ dwChecksum ^ (DWORD) pbuf;
}

static CStringArray*    pcsaLog = NULL;

void CModelData::SetLog() {
    m_csaConvertLog.RemoveAll();
    pcsaLog = &m_csaConvertLog;
}

extern "C" void DebugPrint(LPCTSTR pstrFormat, ...) {
    CString csOutput;
    va_list ap;

    va_start(ap, pstrFormat);
    vsprintf(csOutput.GetBuffer(1000), pstrFormat, ap);
    va_end(ap);
    csOutput.ReleaseBuffer();
    csOutput.TrimLeft();
    CStringArray&   csaError = *pcsaLog;

    if  (!csaError.GetSize()) {
        csaError.Add(csOutput);
        return;
    }

    if  (csaError[-1 + csaError.GetSize()].Find(_T('\n')) >= 0) {
        csaError[-1 + csaError.GetSize()].TrimRight();
        pcsaLog -> Add(csOutput);
    }
    else
        csaError[-1 + csaError.GetSize()] += csOutput;
}

/******************************************************************************

  MDSCreateFileW

  I implement a version of this API here which calls the ANSI API, so I can 
  compile the parser code with UNICODE on, but still run the resulting binary 
  on Win95.

******************************************************************************/

extern "C" HANDLE MDSCreateFileW(LPCWSTR lpstrFile, DWORD dwDesiredAccess,
                                 DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
                                 DWORD dwCreateFlags, DWORD dwfAttributes,
                                 HANDLE hTemplateFile) {
    CString csFile(lpstrFile);  //  Let CString conversions do the hard work!

    return  CreateFile(csFile, dwDesiredAccess, dwShareMode, lpsa, 
        dwCreateFlags, dwfAttributes, hTemplateFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\gpdfile.cpp ===
/******************************************************************************

  Source File:  Model Data.CPP

  Implementation of the code for handling GPC format data

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-19-97  Bob_Kjelgaard@Prodgy.Net    Created it

******************************************************************************/

#include    "StdAfx.h"
#undef  AFX_EXT_CLASS
#define AFX_EXT_CLASS   __declspec(dllimport)
#include    "..\FontEdit\ProjNode.H"
#include	"..\CodePage\CodePage.H"
#undef  AFX_EXT_CLASS
#define AFX_EXT_CLASS   __declspec(dllexport)
#include    "..\Resource.H"
#include    "Resource.H"
#include    "GPDFile.H"

/******************************************************************************

  COldMiniDriverData class

  This class is tasked with representing the GPC data.  It will begin life as
  a stub, although it could become more functional, later.

******************************************************************************/

/******************************************************************************

  ExtractList

  This is a private worker function.  It takes a pointer to a null-terminated
  list of WORD font IDs, with the nasty complication that the first two
  elements of the list represent the endpoints of a range.  It mashes these
  into a passed word map (of which we only use the indices).

******************************************************************************/

static void ExtractList(PWORD pw, CMapWordToDWord& cmw2d) {
    for (WORD w = *pw++; w && w < *pw; w++)
        cmw2d[w] = 0;

    if  (!w)
        return; //  The whole list was empty

    while   (*pw)   //  We start at the endpoint (which we haven't mapped yet)
        cmw2d[*pw++] = 0;
}

/******************************************************************************

  ColdMiniDriverData::Load

  This member function loads the mini-driver's GPC file, and extracts the 
  number of models, the CTT IDs, and the model name IDs.

******************************************************************************/

BOOL    COldMiniDriverData::Load(CFile& cfImage) {
    
    struct sGPCHeaderEntry {
        WORD    m_wOffset, m_wcbItem, m_wcItems;
    };

    struct sMaster {
        WORD    m_wX, m_wY;
    };

    struct sPrinterModelData {
        WORD    m_wcbSize;
        WORD    m_widName;  //  Stringtable id for model name.
        WORD    m_wfGeneral;    //  TODO:   Define enums
        WORD    m_wfCurves;     //  TODO:   Define enums
        WORD    m_wfLines;      //  TODO:   Define enums
        WORD    m_wfPolygons;   //  TODO:   Define enums
        WORD    m_wfText;       //  TODO:   Define enums
        WORD    m_wfClipping;   //  TODO:   Define enums
        WORD    m_wfRaster;;    //  TODO:   Define enums
        WORD    m_wfLandscapeText;  //  TODO:   Define enums
        WORD    m_wLeftMargin;  //  Left-hand unprintable area
        WORD    m_wMaximumWidth;    //  Of physica page
        sMaster m_smMaximum, m_smMinimum;   //  Max min page sizes
        WORD    m_widDefaultFont;
        WORD    m_wLookAhead;
        WORD    m_wMaxFontsPerPage;
        WORD    m_wcCartridges;
        WORD    m_widDefaultCTT;
        enum {PortraitFonts, LandscapeFonts, Resolution, PaperSize, 
            PaperQuality, PaperSource, PaperDestination, TextQuality,
            Compression, FontCartridge, Color, MemoryConfiguration};
        WORD    m_awofIndexLists[12];   //  Uses the preceding enum
        WORD    m_awIndices[16];        //  Ditto
        WORD    m_awVer3IndexLists[5];  //  Ditto
        WORD    m_wofDefaults;          //  List of defaults for index lists
        WORD    m_wReserved;
        DWORD   m_dwidICMManufactirer, m_dwidICMModel;
        DWORD   m_adwReserved[8];
    };

    struct sGPCFileHeader {
        WORD    m_widGPC;   //  0x7F00 or it isn't valid.
        WORD    m_wVersion; //  Final version is 3, there was a V2
        sMaster m_smMasterdpi;
        DWORD   m_dwoHeap;  //  The GPC data is maintained in one
        DWORD   m_dwcbFile; //  Total GPC Image size, heap and all
        enum {Default, PCL4, CAPSL, PPDS, TTY, DBCS};
        WORD    m_wTechnology;  //  Use the preceding enum
        enum {PrivateHelp = 1, OneDraftFont};
        WORD    m_wfGeneral;    //  Again, use the preceding enum
        char    m_acReserved[10];
        WORD    m_wcHeaderItems;    //  Number of valid header entries
        enum {ModelData, Resolution, PaperSize, PaperQuality, PaperSource, 
                PaperDestination, TextQuality, Compression, FontCartridge,
                PageControl, CursorMovement, FontSimulation, DeviceColor,
                RectangleFill, DownloadInfo, VectorPage, Carousel, PenInfo,
                LineInfo, BrushInfo, VectorOutput, PolyVectorOutput,
                VectorSupport, ImageControl, PrintDensity, ColorTracking, 
                MaximumDefined = 30};
        sGPCHeaderEntry m_asgpche[MaximumDefined];
    };

    struct sFontCartridge {
        WORD    m_wSize;    //  = 12
        WORD    m_widCartridge; //  In the string table
        WORD    m_wofPortraitList;
        WORD    m_wofLandscapeList;
        WORD    m_wfGeneral;
        WORD    m_wReserved;
    };

    //  In case we get called more than once, dump any old info...

    m_cbaImage.RemoveAll();
    m_csoaFonts.RemoveAll();
    m_cwaidCTT.RemoveAll();
    m_cwaidModel.RemoveAll();

    m_cbaImage.SetSize(cfImage.GetLength());

    cfImage.Read(m_cbaImage.GetData(), cfImage.GetLength());

    sGPCFileHeader  *psgfh = (sGPCFileHeader *) Image();

    if  (psgfh -> m_widGPC != 0x7F00 || psgfh -> m_wVersion > 0x3ff)
        return  FALSE;

    //  pull out the printer model data we care about- eventually, this may
    //  be all of it

    for (unsigned u = 0; 
         u < psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wcItems; 
         u++) {
        sPrinterModelData&  spmd = *(sPrinterModelData *) (Image() +
        psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wOffset +
            psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wcbItem * u);
        m_cwaidModel.Add(spmd.m_widName);
        m_cwaidCTT.Add(spmd.m_widDefaultCTT);
        //  Build the font list- I use a CMapWordToOb to handle the duplicate
        //  screening

        CMapWordToDWord&   cmw2dThis = * (new CMapWordToDWord);
        //  Extract the portrait resident fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::PortraitFonts])
            ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::PortraitFonts]), 
                cmw2dThis);
        //  Extract the landscape resident fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::LandscapeFonts])
            ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::LandscapeFonts]), 
                cmw2dThis);
        //  Extract the cartridge fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::FontCartridge]) {
            PWORD   pw = (PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::FontCartridge]);

            //  RAID    102890- Cartridge font index is 1-based, not 0-based

            while   (*pw) {
                sFontCartridge* psfc = (sFontCartridge *) (Image() + psgfh ->
                    m_asgpche[sGPCFileHeader::FontCartridge].m_wOffset + 
                    psgfh -> 
                    m_asgpche[sGPCFileHeader::FontCartridge].m_wcbItem * 
                    (-1 + *pw++));

                //  END RAID 102890

                //  Portrait

                if  (psfc -> m_wofPortraitList)
                    ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                        psfc -> m_wofPortraitList), cmw2dThis);

                //  Landscape

                if  (psfc -> m_wofLandscapeList)
                    ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                        psfc -> m_wofLandscapeList), cmw2dThis);
            }
        }

        //  Save the map in the font structure
        m_csoaFonts.Add(&cmw2dThis);
    }

    return  TRUE;
}

/******************************************************************************

  COldMiniDriverData::FontMap(unsigned u)

  This member returns the map which shows which fonts are used by the given 
  model.

******************************************************************************/

CMapWordToDWord&   COldMiniDriverData::FontMap(unsigned u) const {
    return  *(CMapWordToDWord *) m_csoaFonts[u];
}

/******************************************************************************

  COldMiniDriverData::NoteTranslation

  This records the fact that model nn must translate instances of font ID xxx
  to font ID y.
******************************************************************************/

void    COldMiniDriverData::NoteTranslation(unsigned uModel, unsigned uidOld,
                                            unsigned uidNew) {
    FontMap(uModel)[uidOld] = uidNew;
}

/******************************************************************************

  CModelData class

  This class encapsulates the GPD file.  It will start life as a big 
  CStringArray, but as the editor gets more sophisticated, it may gain
  additional members to speed processing and/or manipulation of the data.

******************************************************************************/

IMPLEMENT_SERIAL(CModelData, CProjectNode, 0)

/******************************************************************************

  CModelData::FillViewer

  This static member function is a callback for the rich edit control.  It
  receives a pointer to the CModelData in question, and calls its Fill from
  buffer member function.

******************************************************************************/

DWORD CALLBACK  CModelData::FillViewer(DWORD dwthis, LPBYTE lpb, LONG lcb, 
                                       LONG *plcb) {
    if  (!dwthis)
        return  TRUE;
    
    CModelData* pcmd = (CModelData *) dwthis;

    return pcmd -> Fill(lpb, lcb, plcb);
}

/******************************************************************************

  CModelData::FromViewer

  This is a stream callback for moving data from the edit control to the GPD
  class.  It receives a pointer to the CModelData being updated, and calls its
  UpdateFrom buffer member function to do the rest of the work

******************************************************************************/

DWORD CALLBACK  CModelData::FromViewer(DWORD dwthis, LPBYTE lpb, LONG lcb,
                                       LONG *plcb) {
    if  (!dwthis)
        return  TRUE;   //  Stop the madness

    CModelData* pcmd = (CModelData *) dwthis;

    return  pcmd -> UpdateFrom(lpb, lcb, plcb);
}

/******************************************************************************

  CModelData::Fill(LPBYTE lpb, LONG lcb, LONG *plcb)

  This private method fills a buffer from the GPD contents in CString form.
  An internal buffer is used to handle partially moved strings.

******************************************************************************/

DWORD CModelData::Fill(LPBYTE lpb, LONG lcb, LONG *plcb) {

    int iTotalLines = m_csaGPD.GetSize();

    if  (!m_cbaBuffer.GetSize() && m_iLine >= iTotalLines) {
        *plcb = 0;
        return  0;   //  We be done!
    }

    unsigned    ucb = (unsigned) lcb;

    union   {
        LPTSTR  lpstr;
        LPBYTE  lpbThis;
    };

    //  First, empty anything buffered previously

    lpbThis = lpb;

    if  (m_cbaBuffer.GetSize())
        if  ((unsigned) m_cbaBuffer.GetSize() <= ucb) {
            //  Cool- the entire line will fit in the buffer.
            memcpy(lpbThis, m_cbaBuffer.GetData(), m_cbaBuffer.GetSize());
            ucb -= m_cbaBuffer.GetSize();
            lpbThis += m_cbaBuffer.GetSize();
            m_cbaBuffer.RemoveAll();
        }
        else {
            memcpy(lpbThis, m_cbaBuffer.GetData(), ucb);
            m_cbaBuffer.RemoveAt(0, ucb);
            *plcb = lcb;
            return  0;
        }
            
    for (; ucb && m_iLine < iTotalLines; m_iLine++) {
        CString csLine = m_csaGPD[m_iLine];

        csLine += _TEXT("\r\n");

        if  ((csLine.GetLength()) * sizeof(TCHAR) <= ucb) {
            //  Cool- the entire line will fit in the buffer.
            memcpy(lpbThis, (LPCTSTR) csLine, 
                sizeof(TCHAR) * csLine.GetLength());
            ucb -= sizeof(TCHAR) * csLine.GetLength();
            lpstr += csLine.GetLength();
            continue;
        }

        //  This is a partial buffer- copy it to the internal buffer, and
        //  finish filling the original.

        m_cbaBuffer.SetSize(sizeof(TCHAR) * csLine.GetLength());
        memcpy(m_cbaBuffer.GetData(), (LPCTSTR) csLine, 
            sizeof(TCHAR) * csLine.GetLength());

        memcpy(lpbThis, m_cbaBuffer.GetData(), ucb);
        m_cbaBuffer.RemoveAt(0, ucb);
        ucb = 0;
    }

    *plcb = lcb - ucb;
    return  0;
}

/******************************************************************************

  CModelData::UpdateFrom(LPBYTE lpb, LONG lcb, LONG* plcb)

  This is a private member- an overload which adds the contents of the given
  buffer to the GPD CStringArray, by parsing it into strings.  A private buffer
  member is used to hold partial strings between calls.

******************************************************************************/

DWORD   CModelData::UpdateFrom(LPBYTE lpb, LONG lcb, LONG* plcb) {
    //  Copy the buffer to a byte buffer and null-terminate
    m_cbaBuffer.SetSize(1 + lcb);
    memcpy(m_cbaBuffer.GetData(), lpb, lcb);
    m_cbaBuffer.SetAt(-1 + m_cbaBuffer.GetSize(), 0);

    //  Convert to string and append to any buffered data.

    CString csWork(m_cbaBuffer.GetData());
    CString csEnd(_T("\r\x1A"));    //  These get dumped

    m_cbaBuffer.RemoveAll();

    m_csBuffer += csWork;

    //  Add any complete strings to the GPD contents.

    csWork = m_csBuffer.SpanExcluding(_T("\n"));

    while   (csWork.GetLength() != m_csBuffer.GetLength()) {
        m_csBuffer = m_csBuffer.Mid(csWork.GetLength() + 1);
        //  Remove any trailing whitespace.
        csWork.TrimRight();
        //  Add the string sans any leading control characters
        m_csaGPD.Add(csWork.Mid(csWork.SpanIncluding(csEnd).GetLength()));
        //  While we're here, remove any leading control characters from buffer
        m_csBuffer = 
            m_csBuffer.Mid(m_csBuffer.SpanIncluding(csEnd).GetLength());
        csWork = m_csBuffer.SpanExcluding(_T("\n"));
    }
    //  The leftover data (if any) may be used later...

    *plcb = lcb;
    return  0;
}

/******************************************************************************

  CModelData::Classify

  This method identifies the line numbers for each warning comment, error
  comment, and any other sort of comment, so they can later be syntax colored.

******************************************************************************/

/******************************************************************************

  CModelData::CModelData

  Constructs an empty CModelData object- includes building the Menu table

******************************************************************************/

CModelData::CModelData() {
    m_pcmdt = NULL;
    m_cfn.SetExtension(_T(".GPD"));
    m_cfn.AllowPathEdit();

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_RenameItem);

    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_Import);
    m_cwaMenuID.Add(ID_DeleteItem);

    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
}

/******************************************************************************

  CModelData::Load(CStdioFile csiofGPD)

  This overload loads the GPD from a text file directly.

******************************************************************************/

BOOL    CModelData::Load(CStdioFile& csiofGPD) {
    CString csWork;
    m_csaGPD.RemoveAll();
    while   (csiofGPD.ReadString(csWork)) {
        csWork.TrimRight(); //  Cut off the trailing line stuff
        m_csaGPD.Add(csWork);
    }

    //  Note the correct name and path- the rename checks may fail, since the
    //  file is opened elsewhere (possibly with sharing conflicts), so disable
    //  them, for now.

    if  (FileTitle().IsEmpty()) {
        m_cfn.EnableCreationCheck(FALSE);
        SetFileName(csiofGPD.GetFilePath());
        m_cfn.EnableCreationCheck();
    }
        
    return  TRUE;
}

/******************************************************************************

  CModelData::Load()

  This overload loads the GPD file from the disk using the stored name and path
  information.

******************************************************************************/

BOOL    CModelData::Load() {
    if  (FileTitle().IsEmpty())
        return  FALSE;

    try {
        CStdioFile  csiofGPD(FileName(),
            CFile::modeRead | CFile::shareDenyWrite);
        return  Load(csiofGPD);
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  FALSE;
}

/******************************************************************************

  CModelData::Store

  This method sends the GPD file to the disk.  Since GPD infromation can be
  easily edited with an external editor, this avoids replication and 
  consistency issues.

******************************************************************************/

BOOL    CModelData::Store(LPCTSTR lpstrPath) {

    //  Write the GPD file to the target location, with the traditional CR/LF
    //  separators.  If the given name is NULL, use the stored one.

    try {
        CStdioFile   csiofGPD(lpstrPath ? lpstrPath : 
            FileName(), CFile::modeCreate | CFile::modeWrite |
            CFile::shareExclusive | CFile::typeBinary);

        for (int i = 0; i < m_csaGPD.GetSize(); i++)
            csiofGPD.WriteString(m_csaGPD[i] + _T("\r\n"));
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    Changed(FALSE);

    return  TRUE;
}

/******************************************************************************

  CModelData::Parse

  This method is responsible for parsing the GPD file and collecting the
  resulting errors.

  The initial implementation will be a bit bizarre, because the GPD parser
  isn't stable, and converting it so it would work well for ma and then staying
  on top of the changes just doesn't make sense.

******************************************************************************/

extern "C" BOOL BcreateGPDbinary(LPCWSTR lpstrFile); //  The parser hook
extern "C" PVOID LoadRawBinaryData(LPCWSTR lpstrFile) ;
extern "C" PVOID InitBinaryData(PVOID pv, PVOID pv2, PVOID pv3) ;
extern "C" void FreeBinaryData(PVOID pInfoHdr);
extern "C" void UnloadRawBinaryData(PVOID pRawData) ;
extern "C" void UseLog(FILE *pfLog);

BOOL    CModelData::Parse() {

    //  Step 1: Establish the correct directory for the parser, and
    //  bang together a couple of file names

    CString csCurrent;

    GetCurrentDirectory(MAX_PATH + 1, csCurrent.GetBuffer(MAX_PATH + 1));
    csCurrent.ReleaseBuffer();

    SetCurrentDirectory(m_cfn.Path().Left(m_cfn.Path().ReverseFind(_T('\\'))));

    //  Step 2: Fake out the error logging interface so it actually tosees
    //  them all into a CString Array for us, the invoke the parser.

    SetLog();


    //  Step 3:  Convert the file name to Unicode so we don't have to tweak the
    //  parser code.

	CString	csFile = FileTitle() + _T(".GPD");
	CByteArray	cbaIn;
	CWordArray	cwaOut;
	cbaIn.SetSize(csFile.GetLength() + 1);
	lstrcpy((LPSTR) cbaIn.GetData(), csFile);
	CCodePageInformation	ccpi;
	ccpi.Convert(cbaIn, cwaOut, GetACP());

    if  (BcreateGPDbinary(cwaOut.GetData())) {
        PVOID   pRawData ;
        PVOID   pInfoHdr ;

        pRawData = LoadRawBinaryData(cwaOut.GetData());
        if(pRawData)
            pInfoHdr = InitBinaryData(pRawData, NULL, NULL);
        if  (pRawData && pInfoHdr)
            FreeBinaryData(pInfoHdr);
        if  (pRawData)
            UnloadRawBinaryData(pRawData) ;
        DeleteFile(FileTitle() + _T(".Bud"));
    }

    //  Finally, clean up the mess by restoring the original working 
    //  directory.

    SetCurrentDirectory(csCurrent);

    return  TRUE;
}

/******************************************************************************

  CModelData::RemoveError

  This removes the given error from the log.

******************************************************************************/

void    CModelData::RemoveError(unsigned u) {
    if  (u >= Errors())
        return;

    m_csaConvertLog.RemoveAt(u);
    Changed();
}

/******************************************************************************

  CModelData::Fill(CRichEditCtrl& crec)

  This overload fills the gven rich edit control with the GPD contents, either
  as currently cached in memory, or stored on the disk.

******************************************************************************/

void    CModelData::Fill(CRichEditCtrl& crec) {
	
	EDITSTREAM  es = {(DWORD) this, 0, FillViewer};
    m_iLine = 0;

    if  (!m_csaGPD.GetSize())
        Load();
	
    crec.StreamIn(SF_TEXT, es);
}

/******************************************************************************

  CModelData::UpdateFrom(CRichEditCtrl& crec)

  This overloaded member function discards the current GPD cache and refills
  it from the given edit control.

******************************************************************************/

void    CModelData::UpdateFrom(CRichEditCtrl& crec) {

    EDITSTREAM es = {(DWORD) this, 0, FromViewer};

    m_csaGPD.RemoveAll();

    m_csBuffer.Empty(); //  Just in case...

    crec.StreamOut(SF_TEXT, es);
    Changed();
}

/******************************************************************************

  CModelData::CreateEditor

  This member function launches an editing view for the GPD Data.

******************************************************************************/

CMDIChildWnd*   CModelData::CreateEditor() {
    CGPDContainer* pcgpdcMe= 
        new CGPDContainer(this, FileName());

    Load();

    //  Make up a cool title

    pcgpdcMe -> SetTitle(m_pcbnWorkspace -> Name() + _T(": ") + Name());

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt -> 
        CreateNewFrame(pcgpdcMe, NULL);

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcgpdcMe, TRUE);
        m_pcmdt -> AddDocument(pcgpdcMe);
    }

    return  pcmcwNew;
}

/******************************************************************************

  CModelData::Import

  This method walks one step up the tree and passes the call to the import
  method for the fixed node which owns us.

******************************************************************************/

void CModelData::Import() {
    ((CBasicNode *) m_pctcOwner -> 
        GetItemData(m_pctcOwner -> GetParentItem(m_hti))) -> Import();
}

/******************************************************************************

  CModelData::Delete

  This is called when the user presses the Delete key or selects the Delete
  menu item from an appropriate context menu.

  We use a modal dialog to ask whether the user intends to really remove the
  file from the workspace, and whether or not they wish to delete the 
  underlying file.

******************************************************************************/

void    CModelData::Delete() {
    CGPDDeleteQuery cgdq;


    cgdq.FileName(Name());

    if  (cgdq.DoModal() != IDYES)
        return;

    if  (cgdq.KillFile())
        DeleteFile(m_cfn.FullName());

    //  Walk back up the hierarchy to find the owning Fixed node, and
    //  remove us from the array for that node- since that member is a
    //  reference to the array, all will work as it should.

    CFixedNode&  cfnGPD = * (CFixedNode *) m_pctcOwner -> GetItemData(
        m_pctcOwner -> GetParentItem(m_hti));

    ASSERT(cfnGPD.IsKindOf(RUNTIME_CLASS(CFixedNode)));

    cfnGPD.Zap(this);

    //  WARNING:  the object pointed to by this has been deleted do NOTHING
    //  from this point on that could cause the pointer to be dereferenced!
}

/******************************************************************************

  CModelData::Serialize

  Stores the image, as we need it stored.

******************************************************************************/

void    CModelData::Serialize(CArchive& car) {
    CProjectNode::Serialize(car);
    m_csaConvertLog.Serialize(car);
}

/******************************************************************************

  CGPDContainer class implementation

  This class is a document class which contains one GPD file and its assorted
  control mechanisms

******************************************************************************/

IMPLEMENT_DYNCREATE(CGPDContainer, CDocument)

CGPDContainer::CGPDContainer(CModelData *pcmd, CString csPath) {
    m_bEmbedded = TRUE;
    m_pcmd = pcmd;
    SetPathName(csPath, FALSE);
    m_pcmd -> NoteOwner(*this);
}

CGPDContainer::CGPDContainer() {
    m_bEmbedded = FALSE;
    m_pcmd = new CModelData;
    m_pcmd -> NoteOwner(*this);
}

/******************************************************************************

  CGPDContainer::OnNewDocument

  We just pass it back to the default handler.  Could mean this one can be 
  toasted

******************************************************************************/

BOOL CGPDContainer::OnNewDocument() {
	return  CDocument::OnNewDocument();
}

/******************************************************************************

  CGPDContainer::~CGPDContainer

  If this wasn't created from the workspace, then zap the data!

******************************************************************************/

CGPDContainer::~CGPDContainer() {
    if  (!m_bEmbedded && m_pcmd)
        delete  m_pcmd;
}


BEGIN_MESSAGE_MAP(CGPDContainer, CDocument)
	//{{AFX_MSG_MAP(CGPDContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer diagnostics

#ifdef _DEBUG
void CGPDContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CGPDContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer serialization

void CGPDContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
	}
	else {
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer commands

/******************************************************************************

  CGPDContainer::OnSaveDocument

  We bypass the normal serialization process, and simple blast it to the drive.

******************************************************************************/

BOOL CGPDContainer::OnSaveDocument(LPCTSTR lpszPathName) {
    return  ModelData() -> Store(lpszPathName);
}

/******************************************************************************

  CDPSContainer::OnOpenDocument

  Again, blow off serialization- if I haven't figured out how to read a text
  file by now, I'm definitely in the wrong place.

******************************************************************************/

BOOL CGPDContainer::OnOpenDocument(LPCTSTR lpszPathName) {
    try {
        CStdioFile  csiofGPD(lpszPathName, CFile::modeRead | 
            CFile::shareDenyWrite | CFile::typeText);

        return  ModelData() -> Load(csiofGPD);
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }
        
    return  FALSE;
}

/******************************************************************************
 
  CGPDDeleteQuery dialog

  This implements the dialog that validates and verifies the removal of a GPD
  file from the workspace.

******************************************************************************/

CGPDDeleteQuery::CGPDDeleteQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CGPDDeleteQuery::IDD, pParent) {
	//{{AFX_DATA_INIT(CGPDDeleteQuery)
	m_csTarget = _T("");
	m_bRemoveFile = FALSE;
	//}}AFX_DATA_INIT
}


void CGPDDeleteQuery::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGPDDeleteQuery)
	DDX_Text(pDX, IDC_FileName, m_csTarget);
	DDX_Check(pDX, IDC_Remove, m_bRemoveFile);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGPDDeleteQuery, CDialog)
	//{{AFX_MSG_MAP(CGPDDeleteQuery)
	ON_BN_CLICKED(IDNO, OnNo)
	ON_BN_CLICKED(IDYES, OnYes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPDDeleteQuery message handlers

void CGPDDeleteQuery::OnYes() {
	if  (UpdateData())
        EndDialog(IDYES);
	
}

void CGPDDeleteQuery::OnNo() {
	EndDialog(IDNO);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\gpc2gpd.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpc2gpd.c

Abstract:

    GPC-to-GPD conversion program

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include    "StdAfx.H"

#undef  AFX_EXT_CLASS
#define AFX_EXT_CLASS   __declspec(dllimport)
#include    "..\FontEdit\ProjNode.H"
#undef  AFX_EXT_CLASS
#define AFX_EXT_CLASS   __declspec(dllexport)
#include    "Resource.H"
#include    "GPDFile.H"
#include    "..\..\GPC2GPD\GPC2GPD.H"

extern "C" void VOutputGlobalEntries(PCONVINFO pci, PCSTR pstrModelName, 
                                     PCSTR pstrResourceDLLName);

/******************************************************************************

  VPrintErros
  VOut

  These replace functions used in the command line converter.

******************************************************************************/

static void VPrintErrors(CStringArray& csaLog, DWORD dwError) {
    for (unsigned u = 0; u < NUM_ERRS; u++)
        if (dwError & gdwErrFlag[u])
            csaLog.Add(gpstrErrMsg[u]);
    for (u = 0; u < (unsigned) csaLog.GetSize(); u++)
        csaLog[u].TrimRight();  //  Trim off the white space, we won't need it
}

extern "C" void _cdecl
VOut(
    PCONVINFO pci,
    PSTR pstrFormat,
    ...)
/*++
Routine Description:
    This function formats a sequence of bytes and writes to the GPD file.

Arguments:
    pci - conversionr related info
    pstrFormat - the formatting string
    ... - optional arguments needed by formatting

Return Value:
    None
--*/
{
    va_list ap;
    BYTE aubBuf[MAX_GPD_ENTRY_BUFFER_SIZE];
    int iSize;

    va_start(ap, pstrFormat);
    iSize = vsprintf((PSTR)aubBuf, pstrFormat, ap);
    va_end(ap);
    if (pci->dwMode & FM_VOUT_LIST)
    {
        //
        // check for the extra comma before the closing bracket
        //
        if (aubBuf[iSize-4] == ',' && aubBuf[iSize-3] == ')')
        {
            aubBuf[iSize-4] = aubBuf[iSize-3];  // ')'
            aubBuf[iSize-3] = aubBuf[iSize-2];  // '\r'
            aubBuf[iSize-2] = aubBuf[iSize-1];  // '\n'
            iSize--;
        }
    }
    //  Memory exceptions should be all that's possible, but call any MFC
    //  exception a "file write error" for compatibility.
    try {
        CString csLine(aubBuf);
        //  If the previous line does not end in whitespace, add this one to it

        if  (pci -> pcsaGPD -> GetSize()) {
            CString&    csPrevious = 
                pci -> pcsaGPD -> ElementAt( -1 + pci -> pcsaGPD -> GetSize());
            if  (csPrevious.Right(1)[0] != _TEXT('\n')) {
                csPrevious += csLine;
                return;
            }
            csPrevious.TrimRight(); //  Remove the CR/LF combo.
        }
        pci -> pcsaGPD -> Add(csLine);
    }
    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        pci -> dwErrorCode |= ERR_WRITE_FILE;
    }
    // continue even if an error has occurred.
}

/******************************************************************************

  CModelData::Load(PCSTR pcstr, CString csResource, unsigned uModel,
                   CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert)

  This member function fills this instance by converting a model from the GPC 
  data pointed at by pcstr.

******************************************************************************/

BOOL    CModelData::Load(PCSTR pstr, CString csResource, unsigned uModel,
                         CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert) {

    CONVINFO    ci;     // structure to keep track conversion information

    //
    // check if we have all the arguments needed
    //
    if (!pstr || csResource.IsEmpty() || !uModel)
        return  FALSE;

    ZeroMemory((PVOID)&ci, sizeof(CONVINFO));

    //
    // Open the GPC file and map it into memory.
    //
    ci.pdh = (PDH) pstr;

    //
    // GPC file sanity check
    //
    if (ci.pdh->sMagic != 0x7F00 ||
        !(ci.pmd = (PMODELDATA)GetTableInfo(ci.pdh, HE_MODELDATA, uModel-1)) ||
        !(ci.ppc = (PPAGECONTROL)GetTableInfo(ci.pdh, HE_PAGECONTROL,
        ci.pmd->rgi[MD_I_PAGECONTROL]))) {
        ci.dwErrorCode |= ERR_BAD_GPCDATA;
        goto exit;
    }
    //
    // allocate dynamic buffers needed for conversion
    //
    if (!(ci.ppiSize=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSIZE].sCount*sizeof(PAPERINFO))) ||
        !(ci.ppiSrc=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSOURCE].sCount*sizeof(PAPERINFO))) ||
        !(ci.presinfo=(PRESINFO)MemAllocZ(ci.pdh->rghe[HE_RESOLUTION].sCount*sizeof(RESINFO))))
    {
        ci.dwErrorCode |= ERR_OUT_OF_MEMORY;
        goto exit;
    }

    //
    // generate GPD data
    //

    ci.pcsaGPD = &m_csaGPD;
    ci.pcmw2dFonts = &cmw2dFontMap;
// eigos /1/16/98
//    ci.dwStrType = wfGPDConvert % (1 + STR_RCID_SYSTEM_PAPERNAMES); //  Paranoid conversion...
    //rm - Use value macros (see stdnames.gpd) - fixes a want request
    ci.dwStrType = STR_MACRO;


    VOutputGlobalEntries(&ci, m_csName, csResource + _T(".Dll"));
    VOutputUIEntries(&ci);
    VOutputPrintingEntries(&ci);

    m_csaGPD[-1 + m_csaGPD.GetSize()].TrimRight();

exit:
    if (ci.ppiSize)
        MemFree(ci.ppiSize);
    if (ci.ppiSrc)
        MemFree(ci.ppiSrc);
    if  (ci.presinfo)
        MemFree(ci.presinfo);
    if (ci.dwErrorCode) {
        //
        // Open the log file and print out errors/warnings.
        // Borrow the GPD file name buffer.
        //
        VPrintErrors(m_csaConvertLog, ci.dwErrorCode);
    }

    return TRUE;
}

/******************************************************************************

  vMapFontList

  This procedure uses the CMapWordToDWord mapping in the CONVINFO structure to
  map font indices in font lists.  This is the final bit of skullduggery needed
  to make the mapping of a single PFM to multiple UFMs effective.

******************************************************************************/

extern "C" void vMapFontList(IN OUT PWORD pwFonts, IN DWORD dwcFonts, 
                             IN PCONVINFO pci) {

	//	If there are n fonts, or just one and the ID is 0 (happens if there are
	//	no device fonts.

    if  (!dwcFonts || (dwcFonts == 1 && !*pwFonts))
        return;

    CWordArray          cwaFonts;
    CMapWordToDWord&    cmw2dFonts = *pci -> pcmw2dFonts;

    WORD    wGreatest = 0;	//	Highest font ID in the new array

    for (unsigned uFont = 0; uFont < dwcFonts; uFont++) {
        WORD    widThis = pwFonts[uFont];

        if  (cmw2dFonts[widThis])    //  It will be 0 if unmapped
            widThis = (WORD) cmw2dFonts[widThis];

        if  (widThis > wGreatest) {	//	Is this the new end of the list?
            cwaFonts.Add(widThis);
            wGreatest = widThis;
            continue;
        }

        for (int i = 0; i < cwaFonts.GetSize(); i++)
            if  (cwaFonts[i] > widThis) {
                cwaFonts.InsertAt(i, widThis);
                break;
            }

        _ASSERT(i < cwaFonts.GetSize());
    }

    //  OK, the font list is corrected and is once again sorted.  Copy it back

    memcpy(pwFonts, cwaFonts.GetData(), dwcFonts * sizeof wGreatest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\modldata.cpp ===
/******************************************************************************

  Source File: Model Data Knowledge Base.CPP
  
  This implements the DLL initialization routines for the DLL, for starters.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-19-1997    Bob_Kjelgaard@Prodigy.Net   Created it

*******************************************************************************/

#include    "StdAfx.H"
#include    <AfxDllX.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  DllMain

  DLL initialization routine.  This has the responsibility of adding this DLL
  to the recognized sets of extensions, so the MFC methods for resource sharing
  will work properly.

******************************************************************************/

static AFX_EXTENSION_MODULE ModelDataKnowledgeBaseDLL = {NULL, NULL};

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH) {
		TRACE0("Model Data Knowledge Base.Dll Initializing!\n");
		
		if (!AfxInitExtensionModule(ModelDataKnowledgeBaseDLL, hInstance))
			return 0;

		new CDynLinkLibrary(ModelDataKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Model Data Knowledge Base.Dll Terminating!\n");
		AfxTermExtensionModule(ModelDataKnowledgeBaseDLL);
	}
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\gpdfile.h ===
/******************************************************************************

  Header File:  Model Data.H

  This defines a C++ class that manipulates (or at lest initially, understands)
  the GPC data file used in earlier versions of the Mini-Driver technology.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-19-97  Bob_Kjelgaard@Prodgy.Net    Created it

******************************************************************************/

class AFX_EXT_CLASS COldMiniDriverData {      //  comdd
    CWordArray  m_cwaidModel;   //  Model names of the printers
    CWordArray  m_cwaidCTT;     //  Default CTTs for each model
    CByteArray  m_cbaImage;     //  Image of the GPC file
    CSafeObArray    m_csoaFonts;    //  Font list per model as CWordArrays

public:
    COldMiniDriverData() {}
    BOOL    Load(CFile& cfImage);

//  Attributes
    unsigned    ModelCount() { return (unsigned) m_cwaidModel.GetSize(); }
    WORD        ModelName(unsigned u) const { return m_cwaidModel[u]; }
    WORD        DefaultCTT(unsigned u) const { return m_cwaidCTT[u]; }
    CMapWordToDWord&    FontMap(unsigned u) const;
    PCSTR       Image() const { return (PCSTR) m_cbaImage.GetData(); }

    //  Operations
    void    NoteTranslation(unsigned uModel, unsigned uFont, 
        unsigned uNewFont);
};

/******************************************************************************

  CModelData class

  This class handles the model data in GPD format.

******************************************************************************/

class AFX_EXT_CLASS CModelData : public CProjectNode {
    CStringArray        m_csaGPD, m_csaConvertLog;  //  GPD and error log
    
    //  Private syntax checking support
    void                SetLog();

    //  Private view support
    CByteArray  m_cbaBuffer;    //  Stream I/O buffer
    CString     m_csBuffer;     //  Stream I/O buffer (partial lines)
    int         m_iLine;
    static DWORD CALLBACK   FillViewer(DWORD dwCookie, LPBYTE lpBuff, LONG lcb,
                                       LONG *plcb);
    static DWORD CALLBACK   FromViewer(DWORD dwCookie, LPBYTE lpBuff, LONG lcb,
                                       LONG *plcb);
    DWORD Fill(LPBYTE lpBuff, LONG lcb, LONG *plcb);
    DWORD UpdateFrom(LPBYTE lpBuff, LONG lcb, LONG *plcb);

    DECLARE_SERIAL(CModelData)
public:
    CModelData();

    //  Attributes

    BOOL            HasErrors() const { return !!m_csaConvertLog.GetSize(); }
    unsigned        Errors() const { 
        return (unsigned) m_csaConvertLog.GetSize(); 
    }
    const CString   Error(unsigned u) const { return m_csaConvertLog[u]; }
    const int       LineCount() const { return m_csaGPD.GetSize(); }
    
    //  Operations - Document support

    BOOL    Load(PCSTR pcstr, CString csResource, unsigned uidModel,
                 CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert);
    BOOL    Load(CStdioFile& csiofGPD);
    BOOL    Load();
    BOOL    Store(LPCTSTR lpstrPath = NULL);
    void    UpdateEditor() {
        if  (m_pcmcwEdit)
            m_pcmcwEdit -> GetActiveDocument() -> UpdateAllViews(NULL);
    }

    //  Operations- syntax and error checking support

    BOOL    Parse();
    void    RemoveError(unsigned u);

    //  View support- it's easier done from here

    void    Fill(CRichEditCtrl& crec);
    void    UpdateFrom(CRichEditCtrl& crec);

    //  Framework support operations
    
    virtual CMDIChildWnd*   CreateEditor();
    virtual void            Import();
    virtual void            Delete();
    virtual void            Serialize(CArchive& car);
};

/******************************************************************************

  CGPDContainer class

  This class, derived from CDocument, contains the contents of a single GPD
  file in a conatiner suitable for the MFC document/view architecture.

******************************************************************************/

class AFX_EXT_CLASS CGPDContainer : public CDocument {
    BOOL        m_bEmbedded;
    CModelData  *m_pcmd;

protected:
	CGPDContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGPDContainer)

// Attributes
public:

    CModelData* ModelData() { return m_pcmd; }

// Operations
public:

    //  First a constructor for the Driver viewer to use to launch a GPD
    //  editor...

    CGPDContainer(CModelData *pcmd, CString csPath);

    void    OnFileSave() { CDocument::OnFileSave(); }
    void    OnFileSaveAs() { CDocument::OnFileSaveAs(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGPDContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGPDContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/******************************************************************************

  CGPDDeleteQuery class

  This class defines the dialog used for further inout and verification when a
  user requests deletion of a GPD file from a driver workspace.

******************************************************************************/

class CGPDDeleteQuery : public CDialog {
// Construction
public:
	CGPDDeleteQuery(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGPDDeleteQuery)
	enum { IDD = IDD_DeleteQuery };
	CString	m_csTarget;
	BOOL	m_bRemoveFile;
	//}}AFX_DATA

    void    FileName(LPCTSTR lpstr) { m_csTarget = lpstr; }
    BOOL    KillFile() const { return m_bRemoveFile; }
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDDeleteQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGPDDeleteQuery)
	afx_msg void OnNo();
	afx_msg void OnYes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\addcpt.h ===
/******************************************************************************

  Header File:  Add Code Points.H

  This defines the CAddCodePoints class, which uses passed lists to present a 
  list of code points and their associated code pages for selection.  This
  class should be usable for both the glyph map and font structure editors.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if defined(LONG_NAMES)
#include    <Utility Classes.H>
#else
#include    <Utility.H>
#endif

class CAddCodePoints : public CDialog {

    CMapWordToDWord&    m_cmw2dPoints;
    CDWordArray&        m_cdaPages;
    CString             m_csItem;   //  Name of the item being edited
// Construction
public:
	CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, CDWordArray& cda,
                   CString csItemName);

// Dialog Data
	//{{AFX_DATA(CAddCodePoints)
	enum { IDD = IDD_AddCodePoints };
	CListBox	m_clbList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddCodePoints)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddCodePoints)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ModlData.rc
//
#define IDD_DeleteQuery                 152
#define IDC_Remove                      1049
#define IDC_FileName                    1074

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\stdafx.cpp ===
/******************************************************************************

  Source File:  StdAfx.CPP
  
  This includes just the standard include files.  It is used to generate the
  precompiled header Model Data Knowledge Base.pch.  StdAfx.obj will contain 
  the pre-compiled type information.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  03-19-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\parser.c ===
/******************************************************************************

  Source File:	Parser.C

  This is an NT Build hack.  It includes all of the "C" files used for the
  GPD parser, because Build can't handle directories beyond ..

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved

  A Pretty Penny Enterprises Production

  Change History:

  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Did the dirty deed

******************************************************************************/

#define	UNICODE
#define	_UNICODE

#undef	WINVER	//	Undo the MFC weirdness
#define	WINVER	0x0500
#define	_DEBUG_H_
#include "lib.h"

extern void _cdecl DebugPrint(PCSTR, ...);

#define	ERR(x)	DebugPrint x
#define	WARNING(x) DebugPrint x
#define	VERBOSE(x)
#define	ASSERT(x)
#define RIP(x)

//	Parser files
#if defined(WIN32)
#include	"..\..\..\..\parsers\gpd\command.c"
#include	"..\..\..\..\parsers\gpd\constrnt.c"
#include	"..\..\..\..\parsers\gpd\framwrk1.c"
#include	"..\..\..\..\parsers\gpd\helper1.c"
#include	"..\..\..\..\parsers\gpd\installb.c"
#include	"..\..\..\..\parsers\gpd\macros1.c"
#include	"..\..\..\..\parsers\gpd\postproc.c"
#include	"..\..\..\..\parsers\gpd\semanchk.c"
#include	"..\..\..\..\parsers\gpd\shortcut.c"
#include	"..\..\..\..\parsers\gpd\snapshot.c"
#include	"..\..\..\..\parsers\gpd\snaptbl.c"
#include	"..\..\..\..\parsers\gpd\state1.c"
#include	"..\..\..\..\parsers\gpd\state2.c"
#include	"..\..\..\..\parsers\gpd\token1.c"
#include	"..\..\..\..\parsers\gpd\value1.c"
#else
#include	"..\..\..\parsers\gpd\command.c"
#include	"..\..\..\parsers\gpd\constrnt.c"
#include	"..\..\..\parsers\gpd\framwrk1.c"
#include	"..\..\..\parsers\gpd\helper1.c"
#include	"..\..\..\parsers\gpd\installb.c"
#include	"..\..\..\parsers\gpd\macros1.c"
#include	"..\..\..\parsers\gpd\postproc.c"
#include	"..\..\..\parsers\gpd\semanchk.c"
#include	"..\..\..\parsers\gpd\shortcut.c"
#include	"..\..\..\parsers\gpd\snapshot.c"
#include	"..\..\..\parsers\gpd\snaptbl.c"
#include	"..\..\..\parsers\gpd\state1.c"
#include	"..\..\..\parsers\gpd\state2.c"
#include	"..\..\..\parsers\gpd\token1.c"
#include	"..\..\..\parsers\gpd\value1.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\addcdpt.cpp ===
/******************************************************************************

  Source File:  Add Code Points.CPP

  This implements the CAddCodePoints class, which manages a dialog that allows
  the user to add additional code points to a glyph set.

  Copyright (c) 1997 by Microsoft Corporation.  All rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "addcdpt.h"
#include    "codepage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CCodePageInformation* pccpi = NULL ;

/******************************************************************************

  CAddCodePoints::CAddCodePoints

  The class constructor primarily initializes the base class and reference
  members.

******************************************************************************/

CAddCodePoints::CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d,
                               CDWordArray& cda, CString csItemName)
	: CDialog(CAddCodePoints::IDD, pParent), m_cmw2dPoints(cmw2d),
    m_cdaPages(cda) {
    m_csItem = csItemName;

	// Allocate a CCodePageInformation class if needed.

	if (pccpi == NULL)
		pccpi = new CCodePageInformation ;

    for (int i= 0; i < m_cdaPages.GetSize(); i++)
        m_csaNames.Add(pccpi->Name(m_cdaPages[i]));
    m_pos = 0;
    m_uTimer = 0;
	//{{AFX_DATA_INIT(CAddCodePoints)
	//}}AFX_DATA_INIT
}

/******************************************************************************

  CAddCodePoints::DoDataExchange

  DDX override for the dialog- I'm not sure I need to keep this around.

******************************************************************************/

void CAddCodePoints::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddCodePoints)
	DDX_Control(pDX, IDC_Banner, m_cpcBanner);
	DDX_Control(pDX, IDC_GlyphList, m_clbList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddCodePoints, CDialog)
	//{{AFX_MSG_MAP(CAddCodePoints)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CAddCodePoints::OnInitDialog

  This is the primary dialog intialization member.  It uses the passed
  information to customize the title, then kicks off a timer so the UI appears
  while the list box is filled.

******************************************************************************/

BOOL CAddCodePoints::OnInitDialog() {
	CDialog::OnInitDialog();

    GetWindowText(m_csHolder);
    SetWindowText(m_csHolder + m_csItem);
	
	m_uTimer = (unsigned)SetTimer(IDD, 10, NULL);

    if  (!m_uTimer) {   //  No timer- fall back to filling the box slowly
        CWaitCursor cwc;
        OnTimer(m_uTimer);
    }
	
	return TRUE;  // No need to change the default focus
}

/******************************************************************************

  CAddCodePoints::OnOK

  This is called when the OK button is pressed.  We check the selection state
  of each item in the list.  If it is not selected, we remove it from the map.

  Thus, we return a map with only the desired entries to the caller.

******************************************************************************/

void CAddCodePoints::OnOK() {

    CWaitCursor cwc;    //  This could get slow

    for (unsigned u = 0; u < (unsigned) m_clbList.GetCount(); u++)
        if  (!m_clbList.GetSel(u))
            m_cmw2dPoints.RemoveKey((WORD) m_clbList.GetItemData(u));

	CDialog::OnOK();
}

/******************************************************************************

  CAddCodePoints::OnInitDialog

  This is invoked after the timer expires.  It uses the passed information to
  fill the code point list.

******************************************************************************/

void CAddCodePoints::OnTimer(UINT nIDEvent) {

    if  (nIDEvent != m_uTimer)	{
	    CDialog::OnTimer(nIDEvent);
        return;
    }
	
	WORD        wKey;
    DWORD       dwIndex;
    CString     csWork;

    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);

    if  (!m_pos) {
        m_cpcBanner.SetRange(0, (int)m_cmw2dPoints.GetCount() - 1);
        m_cpcBanner.SetStep(1);
        m_cpcBanner.SetPos(0);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        if  (m_uTimer)
            m_clbList.EnableWindow(FALSE);
        else {
            m_clbList.LockWindowUpdate();
            m_clbList.ResetContent();
        }

        m_pos = m_cmw2dPoints.GetStartPosition();
    }

    //  Put in just 100 items, unless the timer is off

    for (unsigned u = 0; m_pos && (!m_uTimer || u < 100); u++) {
        m_cmw2dPoints.GetNextAssoc(m_pos, wKey, dwIndex);

        csWork.Format(_TEXT("%4.4X: "), wKey);
        csWork += m_csaNames[dwIndex];

        int id = m_clbList.AddString(csWork);
        m_clbList.SetItemData(id, wKey);
    }

    if  (!m_pos) {
        if  (m_uTimer)
            m_clbList.EnableWindow(TRUE);
        else
            m_clbList.UnlockWindowUpdate();
        m_uTimer = 0;
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_HIDE);
        SetFocus();
    }

    if  (m_uTimer) {
        m_cpcBanner.OffsetPos(u);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        m_uTimer = (unsigned)SetTimer(IDD, 10, NULL);
        if  (!m_uTimer) {
            CWaitCursor cwc;    //  Might be a while...
            m_clbList.EnableWindow(TRUE);
            m_clbList.LockWindowUpdate();
            OnTimer(m_uTimer);
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\childfrm.h ===
/******************************************************************************

  Header File:  Child Frame.H

  This defines the CChildFrame class, which is the MFC CMDIChild with some
  minor wrapping around it.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

// Child Frame.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(CHILD_FRAME_CLASS)
#define CHILD_FRAME_CLASS

class CChildFrame : public CMDIChildWnd {
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************

  CToolTipPage class

  This class implements a page that displays tool tips for its controls using
  strings from the string table matching the control IDs.  Derive from this
  class, and everything else works just as it ought to!

******************************************************************************/

class CToolTipPage : public CPropertyPage {

    CString m_csTip;    //  Can't use auto variables or you lose them!

// Construction
public:
	CToolTipPage(int id);
	~CToolTipPage();

// Dialog Data
	//{{AFX_DATA(CToolTipPage)
	enum { IDD = IDD_TIP };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CToolTipPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg void    OnNeedText(LPNMHDR pnmh, LRESULT *plr);
	// Generated message map functions
	//{{AFX_MSG(CToolTipPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	unsigned	m_uHelpID ;		// Help ID if nonzero
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\childfrm.cpp ===
/******************************************************************************

  Source File:  Child Frame.CPP

  This implements the class for MDI child windows' frames in this application.
  Our primary change is that in most cases, the frame window is not sizable,
  since we use property sheets so extensively.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"

#include    "Child Frame.H"
#else
#include    "MiniDev.H"
#include    "ChildFrm.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame() {
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame() {
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
						     
	cs.style = WS_CHILD | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE ;//| WS_MINIMIZEBOX;	// Raid 8350

	
	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const {
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const {
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

/******************************************************************************

  CToolTipPage class implementation

  Derive from this class rather than CPropertyPage if you wish to use to use
  tool tips on your property page.

******************************************************************************/

CToolTipPage::CToolTipPage(int id) : CPropertyPage(id) {
	//{{AFX_DATA_INIT(CToolTipPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_uHelpID = 0 ;
}

CToolTipPage::~CToolTipPage() {
}

void CToolTipPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CToolTipPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CToolTipPage, CPropertyPage)
	//{{AFX_MSG_MAP(CToolTipPage)
	//}}AFX_MSG_MAP
    ON_NOTIFY(TTN_NEEDTEXT, 0, OnNeedText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolTipPage message handlers

/******************************************************************************

  CToolTipPage::OnInitDialog

  This message handler is simple- it simply uses CWnd::EnableToolTips to turn
  on tool tips for this page.

******************************************************************************/

BOOL CToolTipPage::OnInitDialog() {
	CPropertyPage::OnInitDialog();
	
	EnableToolTips(TRUE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/******************************************************************************

  CToolTipPage::OnNeedText

  This handles the tool tip notification message that tip text is needed.  This
  notification is handled by using the control's ID as the key to the string 
  table.

******************************************************************************/

void    CToolTipPage::OnNeedText(LPNMHDR pnmh, LRESULT *plr) {
    TOOLTIPTEXT *pttt = (TOOLTIPTEXT *) pnmh;

    long    lid = ((long) (pttt -> uFlags & TTF_IDISHWND)) ? 
        (long)GetWindowLong((HWND) pnmh -> idFrom, GWL_ID) : (long)pnmh -> idFrom;

    m_csTip.LoadString(lid);
    m_csTip.TrimLeft();
    m_csTip.TrimRight();
    if  (m_csTip.IsEmpty())
        m_csTip.Format("Window ID is %X", lid);
    pttt -> lpszText = const_cast <LPTSTR> ((LPCTSTR) m_csTip);
}


/******************************************************************************

  CToolTipPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1) if it is found AND
  the class that uses CToolTipPage as a base class has set the help ID.

******************************************************************************/

BOOL CToolTipPage::PreTranslateMessage(MSG* pMsg) 
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1 && m_uHelpID != 0) {
		AfxGetApp()->WinHelp(m_uHelpID) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\modldata\stdafx.h ===
/******************************************************************************

  Source File:  StdAfx.H
  
  Standard MFC include file for standard system include files, or project-
  specific include files that are used frequently, but are changed 
  infrequently.

  Tip o' the day:  If you're going to work on one of these for a while,
  move it out of here, or your compile times will become ghastly!

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-19-1997    Bob_Kjelgaard@Prodigy.Net   Created it (with App Wizard)

******************************************************************************/

#if !defined(AFX_STDAFX_H__2AA73AC6_A043_11D0_821E_00A02465E051__INCLUDED_)
#define AFX_STDAFX_H__2AA73AC6_A043_11D0_821E_00A02465E051__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include    <AfxWin.H>         // MFC core and standard components
#include    <AfxExt.H>         // MFC extensions

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include    <AfxCmn.H>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2AA73AC6_A043_11D0_821E_00A02465E051__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\codepage.h ===
/******************************************************************************

  Header File:  Code Page Knowledge Base.H

  This encapsulates a C++ class that will provide
  all of the basic information needed to manage and translate code pages for the 
  Minidriver Development Tool.

  Copyright (c) 1997 by Microsoft Corporation

******************************************************************************/

#ifndef	RICKS_FIND
#define	RICKS_FIND

class CCodePageInformation {
    DWORD   m_dwidMapped, m_dwidIn, m_dwidOut;  //  CP cached in each array
    CByteArray  m_cbaMap;                       //  Raw Map
    CWordArray  m_cwaIn, m_cwaOut;              //  Full MB2Uni and Uni2MB maps

    BOOL    Load(DWORD dwidMap);                //  Load the support page
    BOOL    Map(BOOL bUnicode);                 //  Map the requested direction
    BOOL    GenerateMap(DWORD dwidMap) const;   //  Create resource for RC file
                                                //  based on this code page

public:

    CCodePageInformation();

    //  Attributes

    const unsigned  InstalledCount() const;     //  Code pages in )S
    const unsigned  MappedCount() const;        //  Code pages in RC file
    const unsigned  SupportedCount() const;     //  Code pages supported by OS

    const DWORD     Installed(unsigned u) const;    //  Retrieve one
    const DWORD     Mapped(unsigned u) const;       //  Retrieve one
    void            Mapped(CDWordArray& cdwaReturn) const;  //  The IDs
    const DWORD     Supported(unsigned u) const;    //  Retrieve one

    CString         Name(DWORD dw) const;           //  Name of the code page
                                                    //  cf RC file
    BOOL            IsInstalled(DWORD dwPage) const;
    BOOL            HaveMap(DWORD dwPage) const;

    //  DBCS query- is page DBCS?  if so is this code point DBCS?

    BOOL            IsDBCS(DWORD dwidPage);
    BOOL            IsDBCS(DWORD dwidPage, WORD wCodePoint); 

    //  Operations
    unsigned        Convert(CByteArray& cbaMBCS, CWordArray& cbaWC, 
                            DWORD dwidPage);

    BOOL            GenerateAllMaps() const;        //  Gen resources for any 
                                                    //  installed & unsupported
    BOOL            Collect(DWORD dwidMap, CWordArray& cwaWhere, 
                            BOOL bUnicode = TRUE);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\addcdpt.h ===
/******************************************************************************

  Header File:  Add Code Points.H

  This defines the CAddCodePoints class, which uses passed lists to present a 
  list of code points and their associated code pages for selection.  This
  class should be usable for both the glyph map and font structure editors.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "Utility.H"

class CAddCodePoints : public CDialog {

    CMapWordToDWord&    m_cmw2dPoints;
    CDWordArray&        m_cdaPages;
    CString             m_csItem;   //  Name of the item being edited
    CStringArray        m_csaNames; //  Names of the pages.
    unsigned            m_uTimer;   //  Timer ID
    POSITION            m_pos;      //  Position in input list
    CString             m_csHolder;
// Construction
public:
	CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, CDWordArray& cda,
                   CString csItemName);

// Dialog Data
	//{{AFX_DATA(CAddCodePoints)
	enum { IDD = IDD_AddCodePoints };
	CProgressCtrl	m_cpcBanner;
	CListBox	m_clbList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddCodePoints)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddCodePoints)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontinst.h ===
/******************************** MODULE HEADER *****************************
 * fontinst.h
 *      Structures used to determine the file layout of files generated
 *      by any font installers, and then read by us.
 *
 * HISTORY:
 *  15:53 on Mon 02 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 * Copyright (C) 1992   Microsoft Corporation.
 *
 ****************************************************************************/


/*
 *   Define the structure that heads each record in the font installer
 * files.  Basically it contains selection information and offsets
 * to the remaining data in this record.
 *   This structure is actually written to the file.  It is also the header
 * employed in the font resources in minidrivers - each font has one of these
 * at the beginning.
 */


//Reduced from 4 to three as WFontType is added.
//Reducde from three to two when dwETM was added
#define EXP_SIZE        2       /* DWORDS allowed for future expansion */

typedef struct
{
    WORD     cjThis;            /* Our size,  for consistency checking */
    WORD     wFlags;            /* Miscellaneous information */

    DWORD    dwSelBits;         /* Font availability information */

    DWORD    dwIFIMet;          /* Offset to the IFIMETRICS for this font */
    DWORD    dwCDSelect;        /* How to select/deselect this font */
    DWORD    dwCDDeselect;
    DWORD    dwWidthTab;        /* Width vector (proportional font) else 0 */
    DWORD    dwIdentStr;        /* Identification string */

    union
    {
        short    sCTTid;        /* Index into CTT data */
        DWORD    dwCTT;         /* Offset here to mapping data of some sort */
    } u;

    WORD     wXRes;             /* Resolution used for font metrics numbers */
    WORD     wYRes;             /* Ditto for the y coordinates */

    short    sYAdjust;          /* Adjust Y position before output - for  */
                                /* double height characters on dot matrix */
    short    sYMoved;           /* Cursor has shifted after printing font */

    short    fCaps;             /* Capabilities flags */

    WORD     wPrivateData;      /* Special purpose: e.g. DeskJet permutations */

    WORD     wFontType;         /* Type of Device font */

    WORD     wReserved;      	/* reserved for future use */

    DWORD    dwETM;             /* offset to ETM for this font 0 if there are none*/

    DWORD    dwMBZ[ EXP_SIZE ]; /* Must Be Zero: in case we need space */
	
} FI_DATA_HEADER;

/*
 *  The version ID.
 */

#define FDH_VER 0x100           /* 1.00 in BCD */

/*
 *  Flags bits.
 */
#define FDH_SOFT        0x0001  /* Softfont, thus needs downloading */
#define FDH_CART        0x0002  /* This is a cartridge font */
#define FDH_CART_MAIN   0x0004  /* Main (first) entry for this cartridge */

/*
 *  Selection criteria bits:  dwSelBits.  These bits are used as
 * follows.  During font installation,  the installer set the following
 * values as appropriate.  During initialisation,  the driver sets
 * up a mask of these bits,  depending upon the printer's abilities.
 * For example,  the FDH_SCALABLE bit is set only if the printer can
 * handle scalable fonts.   When the fonts are examined to see if
 * they are usable,  the following test is applied:
 *
 *      (font.dwSelBits & printer.dwSelBits) == font.dwSelBits
 *
 * If true,  the font is usable.
 */

#define FDH_LANDSCAPE   0x00000001      /* Font is landscape orientation */
#define FDH_PORTRAIT    0x00000002      /* Font is portrait */
#define FDH_OR_REVERSE  0x00000004      /* 180 degree rotation of above */
#define FDH_BITMAP      0x00000008      /* Bitmap font */
#define FDH_COMPRESSED  0x00000010      /* Data is compressed bitmap */
#define FDH_SCALABLE    0x00000020      /* Font is scalable */
#define FDH_CONTOUR     0x00000040      /* Intellifont contour */

#define FDH_ERROR       0x80000000      /* Set if some error condition */


/*
 *  The following structure should be returned from the specific
 * minidriver to the common font installer code.  It is used by
 * the common font installer code to generate the above structure
 * which is then placed in the font file.
 */

typedef  struct
{
    void  *pvData;      /* Address of data of importance */
    int    cBytes;      /* Number of bytes in the above */
}  DATA_SUM;

typedef  struct
{
    DATA_SUM   dsIFIMet;        /* IFIMETRICS */
    DATA_SUM   dsSel;           /* Selection string/whatever */
    DATA_SUM   dsDesel;         /* Deselection string */
    DATA_SUM   dsWidthTab;      /* Width tables (proportional font) */
    DATA_SUM   dsCTT;           /* Translation data */
    DATA_SUM   dsIdentStr;      /* Identification string (Dialog box etc) */
    DATA_SUM   dsETM;           /* EXTENDED TEXT METRICS */

    DWORD      dwSelBits;       /* Font availability information */

    WORD       wVersion;        /* Version ID */
    WORD       wFlags;          /* Miscellaneous information */

    WORD       wXRes;           /* X resolution of font */
    WORD       wYRes;           /* Y resolution */

    short      sYAdjust;        /* Adjust Y position before output - for  */
                                /* double height characters on dot matrix */
    short      sYMoved;         /* Cursor has shifted after printing font */


    WORD       fCaps;           /* Font/device caps */
    WORD       wFontType;         /* Type of Device font */
    WORD       wPrivateData;    /* Pad to DWORD multiple */
} FI_DATA;

/*
 *   RELATED FUNCTION PROTOTYPES.
 */


/*
 *   The function used to take an FI_DATA structure and write its contents
 * to the file whose handle is passed in.  The data is written out as
 * an FI_DATA_HEADER structure.
 */

int   iWriteFDH( HANDLE, FI_DATA * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\codepage.cpp ===
/******************************************************************************

  Source File:  Code Page Knowledge Base.CPP

  This implements the code page knowledge base.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-22-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
//#include    <AfxDllx.h>
#include    "Resource.H"
#if defined(LONG_NAMES)
#include    "Code Page Knowledge Base.H"
#else
#include    "CodePage.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***	Commented out because this code is no longer in a DLL.

static AFX_EXTENSION_MODULE CodePageKnowledgeBaseDLL = { NULL, NULL };
static HINSTANCE hi;

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) {
        hi = hInstance;
		TRACE0("Code Page Knowledge Base.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(CodePageKnowledgeBaseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(CodePageKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Code Page Knowledge Base.DLL Terminating!\n");
	}
	return 1;   // ok
}
*/


static CDWordArray      cdaInstalled, cdaSupported, cdaMapped;

static BOOL CALLBACK    EnumProc(LPTSTR lpstrName) {
    cdaSupported.Add(atoi(lpstrName));
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::Load

  This loads the selected code page into the cache, if it isn't already there.

******************************************************************************/

BOOL    CCodePageInformation::Load(DWORD dwidPage) {

    if  (dwidPage == m_dwidMapped)
        return  TRUE;   //  Already done!

    if  (dwidPage > 65535)  //  We map words for code pages in civilized lands
        return  FALSE;

    HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE((WORD) dwidPage),
        MAKEINTRESOURCE(MAPPING_TABLE));
// raid 43537 
    if (!hrsrc)
		return FALSE;


    HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);

    if  (!hgMap)
        return  FALSE;  //  This should never happen!

    LPVOID lpv = LockResource(hgMap);

    if  (!lpv)
        return  FALSE;

    try {
        m_cbaMap.RemoveAll();
        m_cbaMap.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc));
        memcpy(m_cbaMap.GetData(), lpv, (size_t)m_cbaMap.GetSize());
    }

    catch   (CException * pce) {
        m_dwidMapped = 0;
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    m_dwidMapped = dwidPage;
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::Map

  This creates either the in or out of unicode translation table, as requested,
  using the loaded map.

******************************************************************************/

BOOL    CCodePageInformation::Map(BOOL bUnicode) {

    if  (!m_dwidMapped)
        return  FALSE;

    DWORD&  dwid = bUnicode ? m_dwidOut : m_dwidIn;

    if  (m_dwidMapped == dwid)
        return  TRUE;

    struct MB2WCMap {
        WORD    m_wMBCS;
        WORD    m_wWC;
    }   *psMap = (MB2WCMap *) m_cbaMap.GetData();

    if  (!psMap)
        return  0;

    DWORD   dwcEntries = (DWORD)m_cbaMap.GetSize() / sizeof *psMap;
    CWordArray&  cwaMap = bUnicode ? m_cwaOut : m_cwaIn;

    try {

        cwaMap.RemoveAll();
        cwaMap.InsertAt(0, 0xFFFF, 65536);  //  This is always an invalid value

        while   (dwcEntries--)
            if  (bUnicode)
                cwaMap[psMap[dwcEntries].m_wWC] = psMap[dwcEntries].m_wMBCS;
            else
                cwaMap[psMap[dwcEntries].m_wMBCS] = psMap[dwcEntries].m_wWC;
    }

    catch   (CException * pce) {
        dwid = 0;
        cwaMap.RemoveAll();
        pce -> ReportError();
        pce -> Delete();
        return  0;
    }

    dwid = m_dwidMapped;
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation constructor

  If the statistics haven't been initialized, do it now.  Otherwise, this is
  trivial.

******************************************************************************/

CCodePageInformation::CCodePageInformation() {
    m_dwidMapped = m_dwidIn = m_dwidOut = 0;
    //  Initialize the statics if we need to.

    if  (cdaInstalled.GetSize())
        return;

    EnumSystemCodePages(&EnumProc, CP_INSTALLED);
    cdaInstalled.Copy(cdaSupported);
    cdaSupported.RemoveAll();
    EnumSystemCodePages(&EnumProc, CP_SUPPORTED);

    //  Build a list of mappable code pages

    for (DWORD  dw = 400; dw < 32767; dw++)
        if  (HaveMap(dw))
            cdaMapped.Add(dw);
}

const unsigned  CCodePageInformation::SupportedCount() const {
    return  (unsigned) cdaSupported.GetSize();
}

const unsigned  CCodePageInformation::InstalledCount() const {
    return  (unsigned) cdaInstalled.GetSize();
}

const unsigned  CCodePageInformation::MappedCount() const {
    return  (unsigned) cdaMapped.GetSize();
}

const DWORD CCodePageInformation::Supported(unsigned u) const {
    return  cdaSupported[u];
}

const DWORD CCodePageInformation::Installed(unsigned u) const {
    return  cdaInstalled[u];
}

const DWORD CCodePageInformation::Mapped(unsigned u) const {
    return  cdaMapped[u];
}

/******************************************************************************

  CCodePageInformation::Mapped(CDWordArray& cdaReturn)

  Fills the given array with all of the mapped code page IDs.

******************************************************************************/

void    CCodePageInformation::Mapped(CDWordArray& cdaReturn) const {
    cdaReturn.Copy(cdaMapped);
}

CString  CCodePageInformation::Name(DWORD dwidPage) const {

    CString csTemp;
    csTemp.LoadString(dwidPage);
    csTemp.TrimLeft();
    csTemp.TrimRight();

    if   (csTemp.IsEmpty())
        csTemp.Format(_TEXT("Code Page %d"), dwidPage);
    return  csTemp;
}

/******************************************************************************

  CCodePageInformation::IsInstalled

  Rturns true if the font is either installed in the OS or one of our
  resources.

******************************************************************************/

BOOL    CCodePageInformation::IsInstalled(DWORD dwidPage) const {
    for (unsigned u = 0; u < MappedCount(); u++)
        if  (Mapped(u) == dwidPage)
            return  TRUE;
    for (u = 0; u < InstalledCount(); u++)
        if  (Installed(u) == dwidPage)
            return  TRUE;

    return  FALSE;
}

/******************************************************************************

  CCodePageInformation::GenerateMap

  This private member generates a map representing the available one-to-one
  transformations in an installed code page, and writes it to a file using
  the code page id to form a unique name

******************************************************************************/

BOOL    CCodePageInformation::GenerateMap(DWORD dwidMap) const {

    //  If we can't get Code Page info for it, vanish

    CPINFO  cpi;

    if  (!GetCPInfo(dwidMap, &cpi))
        return  FALSE;

    CWordArray  cwaMap;

    for (unsigned u = 0; u < 65536; u++) {
        unsigned    uTo = 0;
        BOOL        bInvalid;

        int icTo = WideCharToMultiByte(dwidMap, 0, (PWSTR) &u, 1, (PSTR) &uTo,
            sizeof u, NULL, &bInvalid);

        if  (bInvalid)
            continue;   //  Character wasn't any good...

        _ASSERTE((unsigned) icTo <= cpi.MaxCharSize);

        //  OK, we mapped one- but, before we go on, make sure it also works
        //  in the other direction, since the U2M does some jiggering

        unsigned u3 = 0;

        MultiByteToWideChar(dwidMap, 0, (PSTR) &uTo, 2, (PWSTR) &u3, 2);

        if  (u3 != u)
            continue;   //  Not a one-for one? Not interested...

        cwaMap.Add((WORD)uTo);
        cwaMap.Add((WORD)u);
    }

    //  OK, we've got the down and dirty details- now, generate the file...

    try {
        CString csName;
        csName.Format(_TEXT("WPS%u.CTT"), dwidMap);

        CFile   cfOut(csName,
            CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

        //  Write the tranlated pairs

        cfOut.Write(cwaMap.GetData(), (unsigned)(cwaMap.GetSize() * sizeof(WORD)));
    }

    catch(CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::GenerateAllMaps

  This member will generate an MBCS -> Unicode one-to-one mapping table for all
  installed code pages in the user's system for which we do not now have maps.

******************************************************************************/

BOOL    CCodePageInformation::GenerateAllMaps() const {

    BOOL    bReturn = TRUE;

    for (unsigned u = InstalledCount(); u--; )
        if  (!HaveMap(Installed(u)) && !GenerateMap(Installed(u)))
            bReturn = FALSE;

    return  bReturn;
}

/******************************************************************************

  CCodePageInformation::HaveMap

  Reports that the map is one of our resources (or isn't, as the case may be).

******************************************************************************/

BOOL    CCodePageInformation::HaveMap(DWORD dwidMap) const {
    return  (dwidMap < 65536) ? !!FindResource(AfxGetResourceHandle(),
        MAKEINTRESOURCE((WORD) dwidMap), MAKEINTRESOURCE(MAPPING_TABLE)) :
        FALSE;
}

/******************************************************************************

  CCodePageInformation::IsDBCS(DWORD dwidPage)

  This is actually pretty simple- if the translation table is smaller than 1024
  bytes (256 encodings), it isn't DBCS.

******************************************************************************/

BOOL    CCodePageInformation::IsDBCS(DWORD dwidPage) {
    if  (!Load(dwidPage))
        return  FALSE;  //  May be optimistic, but we'll find out...

    return  m_cbaMap.GetSize() > 1024;
}

/******************************************************************************

  CCodePageInformation::IsDBCS(DWORD dwidPage, WORD wCodePoint)

  If the page isn't DBCS, we're done.  Otherwise, make sure the Unicode->MBCS
  map is loaded, and get the answer from there.

******************************************************************************/

BOOL    CCodePageInformation::IsDBCS(DWORD dwidPage, WORD wCodePoint) {
    if  (!IsDBCS(dwidPage))
        return  FALSE;

    if  (!Map(TRUE))
        return  FALSE;  //  Just say no, because the error's already been told

    //  0xFFFF is invalid, hence SBCS (default always must be)

    _ASSERTE(m_cwaOut[wCodePoint] != 0xFFFF);

    return ((WORD) (1 + m_cwaOut[wCodePoint])) > 0x100;
}

/******************************************************************************

  CCodePageInformation::Convert

  This is one of the workhorses- it loads the given code page, and maps the
  given character strings one way or the other, depending upon which is empty.

******************************************************************************/

unsigned    CCodePageInformation::Convert(CByteArray& cbaMBCS,
                                          CWordArray& cwaWC,
                                          DWORD dwidPage){

    if  (!cbaMBCS.GetSize() == !cwaWC.GetSize())    //  Must be clear which way
        return  0;

    if  (!Load(dwidPage) || !Map((int)cwaWC.GetSize()))
        return  0;

    CWordArray& cwaMap = cwaWC.GetSize() ? m_cwaOut : m_cwaIn;
    try {
        if  (cbaMBCS.GetSize()) {
            cwaWC.RemoveAll();
            for   (int i = 0; i < cbaMBCS.GetSize();) {
                WORD    wcThis = cbaMBCS[i];

                if  (cwaMap[wcThis] == 0xFFFF) {    //  No SBCS mapping
                    wcThis += cbaMBCS[i + 1] << 8;
                    if  (cwaMap[wcThis] == 0xFFFF) {    //  No DBCS, either?
                        _ASSERTE(FALSE);
                        return  0;  //  We have failed to convert!
                    }
                }
                cwaWC.Add(cwaMap[wcThis]);
                i += 1 + (wcThis > 0xFF);
            }
        }
        else {
            cbaMBCS.RemoveAll();
            for (int i = 0; i < cwaWC.GetSize(); i++) {
                if  (cwaMap[cwaWC[i]] == 0xFFFF) {
                    _ASSERTE(0);
                    return  0;
                }
                cbaMBCS.Add((BYTE) cwaMap[cwaWC[i]]);
                if  (0xFF < cwaMap[cwaWC[i]])
                    cbaMBCS.Add((BYTE)(cwaMap[cwaWC[i]] >> 8));
            }
        }
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  0;
    }

    return  (unsigned)cwaWC.GetSize();    //  Correct conversion count either way!
}

/******************************************************************************

  CCodePageInformation::Collect

  This member fills a passed CWordArray with either the domain or range of the
  mapping function.  In either case, the array is in ascending order.

******************************************************************************/

BOOL    CCodePageInformation::Collect(DWORD dwidPage, CWordArray& cwaCollect,
                                      BOOL bUnicode) {

    if  (!Load(dwidPage) || !Map(bUnicode))
        return  FALSE;

    CWordArray& cwaMap = bUnicode ? m_cwaOut : m_cwaIn;
    cwaCollect.RemoveAll();

    //  Code points < 0x20 always map, but aren't usable, so screen them out

    try {
        for (unsigned u = 0x20; u < (unsigned) cwaMap.GetSize(); u++)
            if  (~(int)(short)cwaMap[u])    //  0xFFFF means not mapped!
                cwaCollect.Add((WORD)u);
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\comctrls.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  comctrls.cpp
//
//
//	NOTES:		an FWORD is a short int
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <gpdparse.h>
#include "comctrls.H"
#include <stdlib.h>


/////////////////////////////////////////////////////////////////////////////
// The functions defined below for CEditControlEditBox and CEditControlListBox
// are used to implement a lighter weight, more general purpose Edit control
// than the UFM Editor specific classes that are defined above.  (A normal
// Edit Box is part of this Edit Control, too.)

/////////////////////////////////////////////////////////////////////////////
// CEditControlEditBox - Manages the Edit Box part of the Edit Control that
//						 is used to hold the field name.

CEditControlEditBox::CEditControlEditBox(CEditControlListBox* pceclb)
{
	// Save a pointer to the corresponding list box.

	m_pceclb = pceclb ;
}

CEditControlEditBox::~CEditControlEditBox()
{
}


BEGIN_MESSAGE_MAP(CEditControlEditBox, CEdit)
	//{{AFX_MSG_MAP(CEditControlEditBox)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditControlEditBox message handlers

void CEditControlEditBox::OnKillfocus()
{
	// Make sure the value is saved back into the list box.

	m_pceclb->SaveValue() ;	
}


/////////////////////////////////////////////////////////////////////////////
// CEditControlListBox

CEditControlListBox::CEditControlListBox(CEdit* pce,
										 CEditControlEditBox* pceceb)
{
	// Save pointers to the other 2 controls that make up the Edit Control

	m_pceName = pce ;
	m_pcecebValue = pceceb ;

	m_bReady = false ;			// Not ready for operations yet
	m_nCurSelIdx = -1 ;			// Nothing is selected yet
}


CEditControlListBox::~CEditControlListBox()
{
}


BEGIN_MESSAGE_MAP(CEditControlListBox, CListBox)
	//{{AFX_MSG_MAP(CEditControlListBox)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelchange)
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblclk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


bool CEditControlListBox::Init(CStringArray& csamodels, CStringArray& csafiles,
							   int ntabstop)
{
	int		n ;					// Loop counter and temp var

	// Make sure the list box is empty.

	ResetContent() ;

	// Set the position of the list box's tabstop.  This value is passed in
	// because it is a dialog box specific value.

	SetTabStops(1, &ntabstop) ;

	// Now combine the model names and file names and add them to the listbox.

	//csafiles[0] = "MMMMMMMM" ;
	CString cs ;
	int nummodels = (int)csamodels.GetSize() ;
	for (n = 0 ; n < nummodels ; n++) {
		cs = csamodels[n] + _T("\t") + csafiles[n] ;
		AddString(cs) ;
	} ;

	// Set the file name length limit.

	m_pcecebValue->SetLimitText(8) ;

	// Initialize (zap) the contents of the edit boxes

	m_pceName->SetWindowText(_T("")) ;
	m_pcecebValue->SetWindowText(_T("")) ;

	// Reset the currently selected entry index

	m_nCurSelIdx = -1 ;

	// Make sure the list box has the focus.

	SetFocus() ;

	// Everything is ready to go now

	m_bReady = true ;
	return TRUE ;
}


/******************************************************************************
	
  CEditControlListBox::GetGPDInfo

  Load the provided array(s) with the field values and, optionally, the field
  names.

******************************************************************************/

bool CEditControlListBox::GetGPDInfo(CStringArray& csavalues,
									 CStringArray* pcsanames /*= NULL*/)
{
	// First, make sure that the last value changed in the edit control
	// is saved.

	SaveValue() ;

	// Size the array(s) based on the number of entries in the list box.
	// Note: An empty list box is not an error.

	int numents = GetCount() ;
	if (numents <= 0)
		return true ;
	csavalues.SetSize(numents) ;
	if (pcsanames)
		pcsanames->SetSize(numents) ;

	// Loop through each entry in the list box, separate the entries into name
	// and value parts, and save the appropriate parts of the entry.

	CString csentry, csname, csvalue ;
	int npos ;
	for (int n = 0 ; n < numents ; n++) {
		GetText(n, csentry) ;
		npos = csentry.Find(_T('\t')) ;
		csvalue = csentry.Mid(npos + 1) ;
		csavalues[n] = csvalue ;
		if (pcsanames) {
			csname = (npos > 0) ? csentry.Left(npos) : _T("") ;
			pcsanames->SetAt(n, csname) ;
		} ;
	} ;
	
	return true ;
}

	
void CEditControlListBox::SelectLBEntry(int nidx, bool bsave /*=false*/)
{
	// Select the specified entry

	SetCurSel(nidx) ;

	// If the caller doesn't want to save the previous selection, clear the
	// current selection index.

	if (!bsave)
		m_nCurSelIdx = -1 ;
	
	// Update the edit control.

	OnSelchange() ;
} ;

	
void CEditControlListBox::SaveValue(void)
{
	// Do nothing if the edit control is not ready or nothing is loaded into
	// the edit boxes.

	if (!m_bReady || m_nCurSelIdx == -1)
		return ;

	// Get the string from the value edit box and from the selected entry in
	// the list box.

	CString csvalue, csentry ;
	m_pcecebValue->GetWindowText(csvalue) ;
	GetText(m_nCurSelIdx, csentry) ;

	// Replace the value in the entry with the value from the edit box and put
	// the new entry back into the list box.

	int npos = csentry.Find(_T('\t')) ;
	csentry = csentry.Left(npos + 1) + csvalue ;
	DeleteString(m_nCurSelIdx) ;
	InsertString(m_nCurSelIdx, csentry) ;
}


/////////////////////////////////////////////////////////////////////////////
// CEditControlListBox message handlers

void CEditControlListBox::OnSelchange()
{
	// Do nothing if the edit control isn't ready, yet.

	if (!m_bReady)
		return ;

	// Do nothing if the selection didn't really change

	int nidx = GetCurSel() ;
	if (nidx == m_nCurSelIdx)
		return ;

	// Save the current value

	SaveValue() ;

	// Get the index of the currently selected list box entry.  Return without
	// doing anything else if no entry is selected.

	if (nidx == LB_ERR)
		return ;

	// Get the listbox entry and split it into name and value components.

	CString csentry, csname, csvalue ;
	GetText(nidx, csentry) ;
	int npos = csentry.Find(_T('\t')) ;
	csname = (npos > 0) ? csentry.Left(npos) : _T("") ;
	csvalue = csentry.Mid(npos + 1) ;

	// Load the name into the name edit box and the value into the value edit
	// box.

	m_pceName->SetWindowText(csname) ;
	m_pcecebValue->SetWindowText(csvalue) ;

	// Save the index of the currently selected entry

	m_nCurSelIdx = nidx ;
}


void CEditControlListBox::OnDblclk()
{
	// Do nothing if the edit control isn't ready, yet.

	if (!m_bReady)
		return ;

	// Do nothing if no item is selected in the list box.

	if (GetCurSel() == LB_ERR)
		return ;

	// Load the edit boxes

	OnSelchange() ;

	// Set the focus to the value control
	
	m_pcecebValue->SetFocus() ;
}




/////////////////////////////////////////////////////////////////////////////
// The functions implement below the CFullEditListCtrl and CFELCEditBox
// classes.  Together, they implement support a List Control in Report View
// in which subitems can be editted too, complete rows can be selected, and
// the data can be sorted by numeric or text columns.  CFELCEditBox is a
// helper class that is only used by CFullEditListCtrl.
//

CFELCEditBox::CFELCEditBox()
{
}


CFELCEditBox::~CFELCEditBox()
{
}


BEGIN_MESSAGE_MAP(CFELCEditBox, CEdit)
	//{{AFX_MSG_MAP(CFELCEditBox)
	ON_WM_KILLFOCUS()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFELCEditBox message handlers

/******************************************************************************

  CFELCEditBox::OnKeyDown

  Handle the Escape (cancel) and Return (save) keys.

******************************************************************************/

void CFELCEditBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// Get a pointer to the owning list control

	CFullEditListCtrl* plist = (CFullEditListCtrl*) GetParent() ;
	ASSERT (plist);

	// Handle the interesting keys

	switch (nChar) {
		// End editing without saving

		case VK_ESCAPE:
			DefWindowProc(WM_KEYDOWN, 0, 0) ;	// Is this right???
			plist->EndEditing(false) ;
			break ;

		// Save contents and end editing

		case VK_RETURN:
			DefWindowProc(WM_KEYDOWN, 0, 0) ;	// Is this right???
			plist->EndEditing(true) ;
			break ;

		// Save contents, end editing, and begin editing next cell

		case VK_TAB:
			DefWindowProc (WM_KEYDOWN, 0, 0) ;	// Is this right???
			if (!(plist->EndEditing(true)))
				return ;
			plist->EditCurRowSpecCol(plist->GetCurCol() + 1) ;
			break ;

		// Process the key normally

		default:
			CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
	} ;
}


/******************************************************************************

  CFELCEditBox::OnKillFocus

  Just hide the edit box when it looses the focus.  The contents are "lost".

******************************************************************************/

void CFELCEditBox::OnKillFocus(CWnd* pNewWnd)
{
	// Save whatever is in the edit box first.

	CFullEditListCtrl* pList = (CFullEditListCtrl*)GetParent ();
	ASSERT (pList);
	pList->SaveValue() ;
	
	CEdit::OnKillFocus(pNewWnd);
	
	ShowWindow (SW_HIDE);
}


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CFullEditListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CFullEditListCtrl)
	ON_WM_CREATE()
	ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl::CFullEditListCtrl - Constructor

CFullEditListCtrl::CFullEditListCtrl()
{
	// Initialize member variable(s)

	m_pciColInfo = NULL ;
	m_nRow = m_nColumn = m_nNumColumns = -1 ;
	m_nNextItemData = 1 ;
	m_pcoOwner = NULL ;		
	m_dwCustEditFlags = m_dwToggleFlags = m_dwMiscFlags = 0 ;
}


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl::~CFullEditListCtrl - Destructor

CFullEditListCtrl::~CFullEditListCtrl()
{
	// Free memory used

	if (m_pciColInfo != NULL)
		delete m_pciColInfo ;
}


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl message handlers

int CFullEditListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// I don't think anything else needs to be done here.

	return (CWnd::OnCreate(lpCreateStruct));
}

	
/******************************************************************************

  CFullEditListCtrl::InitControl

  Handles control "global" initialization for CFullEditListCtrl.

  Args:
	dwaddlexstyles	Extend styles for list control
	numrows			Number of rows of data that will be loaded into the control
	numcols			Number of columns of data that will be loaded into control
	dwtoggleflags	Flags describing if/how a column in the list can be toggled
					(See TF_XXXX definitions in comctrls.cpp.)
	neditlen		Optional max length of edittable column data strings
	dwmiscflags		Miscellaneous flags for controlling the list control
					(See MF_XXXX definitions in comctrls.cpp.)

  Note:
	  The two main initialization routines, InitControl() for global
	  initialization and InitLoadColumn() for column specific initialization,
	  require a lot of arguments already and I don't want to clutter them with
	  more.  Be that as it may, this control is still being enhanced so I have
	  added extra initialization routines when needed.  They are called
	  ExtraInit_XXXX().  Read the comment header for each routine to find out
	  what they do and when/if they should be called.  These routines may handle
	  a mixture of list global and/or per column initialization.

******************************************************************************/

void CFullEditListCtrl::InitControl(DWORD dwaddlexstyles, int numrows,
									int numcols, DWORD dwtoggleflags/*=0*/,
									int neditlen/*=0*/, int dwmiscflags /*=0*/)
{
	// Add any additional, extended styles to the list control.

	if (dwaddlexstyles != 0) {
		DWORD dwExStyle = (DWORD)SendMessage (LVM_GETEXTENDEDLISTVIEWSTYLE);
		dwExStyle |= dwaddlexstyles;
		SendMessage (LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwExStyle);
	} ;

	// Set the number of rows in the list control.

	SetItemCount(numrows) ;

	// Allocate the structures used to track info on each column.

	if (m_pciColInfo != NULL)
		delete m_pciColInfo ;
	m_pciColInfo = new COLINFO[numcols] ;
	m_nNumColumns = numcols ;

	// Create and initialize the edit control used for subitem editing.

	VERIFY(m_edit.Create(ES_AUTOHSCROLL | WS_BORDER | WS_CHILD,
						 CRect(0,0,0,0), this, 2));
	m_edit.SetFont(GetFont()) ;
	if (neditlen > 0)
		m_edit.LimitText(neditlen) ;

	// Save the next item data number to use when and if new rows are inserted
	// after the columns are initially loaded.

	m_nNextItemData = numrows + 1 ;

	// Save the toggle amd miscellaneous flags

	m_dwToggleFlags = dwtoggleflags ;
	m_dwMiscFlags = dwmiscflags ;
}


/******************************************************************************

  CFullEditListCtrl::InitLoadColumn

  Initialize and load a specific CFullEditListCtrl column.

  Args:
	ncolnum			Column number to initialize/load
	strlabel		Column label
	nwidth			Width of column or flag specifying how to compute width
	nwidthpad		+ or - adjustment to column width
	beditable		True iff the column is editable
	bsortable		True iff the rows can be sorted on this column
	cdtdatatype		The type of data in the column
	pcoadata		Pointer to array containing the columns data
	lpctstrtoggle	If toggle-able column, the column's toggle string

  Note:
	  The two main initialization routines, InitControl() for global
	  initialization and InitLoadColumn() for column specific initialization,
	  require a lot of arguments already and I don't want to clutter them with
	  more.  Be that as it may, this control is still being enhanced so I have
	  added extra initialization routines when needed.  They are called
	  ExtraInit_XXXX().  Read the comment header for each routine to find out
	  what they do and when/if they should be called.  These routines may handle
	  a mixture of list global and/or per column initialization.

******************************************************************************/

int CFullEditListCtrl::InitLoadColumn(int ncolnum, LPCSTR strlabel, int nwidth,
								      int nwidthpad, bool beditable,
									  bool bsortable, COLDATTYPE cdtdatatype,
									  CObArray* pcoadata,
									  LPCTSTR lpctstrtoggle/*= NULL*/)
{
	// Insert the column.  Everything except numeric data is left justified.
	// Numeric data is right justified.
	
	int nfmt ;
	switch (cdtdatatype) {
		case COLDATTYPE_STRING:
		case COLDATTYPE_TOGGLE:
		case COLDATTYPE_CUSTEDIT:
			nfmt = LVCFMT_LEFT ;
			break ;
		case COLDATTYPE_INT:
		case COLDATTYPE_FLOAT:
			nfmt = LVCFMT_RIGHT ;
			break ;
		default:
			nfmt = LVCFMT_LEFT;	//raid 116584 prefix
			ASSERT(0) ;
	}
	VERIFY(InsertColumn(ncolnum, strlabel, nfmt, -1, ncolnum - 1) >= 0) ;

	// Set flags based on how the column width should be set and initialize it
	// when necessary.

	bool bcompwidth, bwidthremainder ;
	if (bcompwidth = (nwidth == COMPUTECOLWIDTH)) {
		nwidth = GetStringWidth(strlabel) + 4 ;		// Start with width of label
		bwidthremainder = false ;
	} else
		bwidthremainder = (nwidth == SETWIDTHTOREMAINDER) ;

	// Get the number (sub)items to be loaded into the column

	int numitems = (int)pcoadata->GetSize() ;

	// Load the data into the column.  If the data aren't strings, they are
	// converted into strings first.  If some of the data may be editted with
	// a custom edit routine, add elipses to those strings.  The width is
	// checked when necessary.

	CString csitem ;
	for (int n = 0 ; n < numitems ; n++) {
		// Get the string to load.

		switch (cdtdatatype) {
			case COLDATTYPE_INT:
				csitem.Format("%d", pcoadata->GetAt(n)) ;
				break ;
			case COLDATTYPE_STRING:
			case COLDATTYPE_TOGGLE:
				csitem = ((CStringArray*) pcoadata)->GetAt(n) ;
				break ;
			case COLDATTYPE_CUSTEDIT:
				csitem = ((CStringArray*) pcoadata)->GetAt(n) ;
				ASSERT(m_cuiaCustEditRows.GetSize()) ;
				if (m_cuiaCustEditRows[n])
					csitem += _T("  ...") ;
				break ;
			default:
				ASSERT(0) ;
		} ;

		// Save the width of the current item if it is the longest found so far
		// and the width needs to be computed.

		if (bcompwidth)
			if (nwidth < GetStringWidth(csitem))
				nwidth = GetStringWidth(csitem) ;

		// Load the item into the appropriate row and column

		if (ncolnum == 0) {
			VERIFY(InsertItem(n, csitem) != -1) ;
			SetItemData(n, n);
		} else
			VERIFY(SetItem(n, ncolnum, LVIF_TEXT,  csitem, -1, 0, 0, n)) ;
	} ;

	// Determine the column width when the remainder is required and then set it.

	if (bwidthremainder) {
		CRect cr ;
		GetWindowRect(cr) ;
		nwidth = cr.Width() - 4 ;
		for (n = 0 ; n < ncolnum ; n++)
			nwidth -= (m_pciColInfo + n)->nwidth ;
	} ;
	SetColumnWidth(ncolnum, nwidth + nwidthpad) ;

	// Save info about the column

	PCOLINFO pci = (m_pciColInfo + ncolnum) ;
	pci->nwidth = nwidth ;		
	pci->beditable = beditable ;
	pci->cdttype = cdtdatatype ;
	pci->bsortable = bsortable ;
	pci->basc = false ;
	pci->lpctstrtoggle = lpctstrtoggle ;

	// Return the width of the column

	return nwidth ;
}


/******************************************************************************

  CFullEditListCtrl::ExtraInit_CustEditCol

  This routine is called when *ONE* column in the list control contains some
  cells whose contents are editted by a custom edit routine.  When such a
  cell is selected, one of the list's owner's member functions is called to
  manage the work (show dlg, etc) needed to edit the cell's contents.  Some of
  the column's cells are editted normally.  The rest are edited via a
  custom edit routine.  Cuiacusteditrows contains data that indicates which
  cells are which.

  Args:
	ncolnum				Custom edit column number
	pcoowner			Pointer to this class instance's owner
	dwcusteditflags		Custom edit flags
	cuiacusteditrows	Rows in ncolnum that require custom editting

  Note:
	When needed, this routine should be called once; after InitControl() and
	before the InitLoadColumn() call for the custom edit column.

    InitLoadColumn() should be called for this column with COLDATTYPE_CUSTEDIT
	as one of its parameters.

******************************************************************************/

bool CFullEditListCtrl::ExtraInit_CustEditCol(int ncolnum, CObject* pcoowner,
											  DWORD dwcusteditflags,
											  CUIntArray& cuiacusteditrows,
											  LPCELLEDITPROC lpcelleditproc)
{
	// Fail if the column number is invalid

	if (ncolnum < 0 || ncolnum >= m_nNumColumns)
		return false ;

	// Save copies of the input parameters for later use.

	m_pcoOwner = pcoowner ;
	m_dwCustEditFlags = dwcusteditflags ;
	m_cuiaCustEditRows.Copy(cuiacusteditrows) ;
	m_lpCellEditProc = lpcelleditproc ;

	return true ;
}


BOOL CFullEditListCtrl::GetPointRowCol(LPPOINT lpPoint, int& iRow, int& iCol,
									   CRect& rect)
{
	BOOL bFound = FALSE;

	// Get row number

	iRow = HitTest (CPoint (*lpPoint));
	if (-1 == iRow)
		return bFound;

	// Get the column number and the cell dimensions

	return (GetColCellRect(lpPoint, iRow, iCol, rect)) ;
}
	
	
BOOL CFullEditListCtrl::GetColCellRect(LPPOINT lpPoint, int& iRow, int& iCol,
									   CRect& rect)
{
	BOOL bFound = FALSE ;

	// Get the dimensions for the entire row.

	VERIFY(GetItemRect(iRow, rect, LVIR_BOUNDS)) ;

	// Prepare to get the width of each column in the row.

	int iCntr = 0 ;
	LV_COLUMN lvc ;
	ZeroMemory(&lvc, sizeof (LV_COLUMN)) ;
	lvc.mask = LVCF_WIDTH ;

	// Get the dimensions of each column until the one containing the point is
	// found.

	while (GetColumn(iCntr, &lvc)) {
		rect.right = rect.left + lvc.cx ;
		if (rect.PtInRect (*lpPoint)) {
			bFound = TRUE ;
			iCol = iCntr ;
			break ;
		} ;
		rect.left = rect.right ;			
		iCntr++ ;
		ZeroMemory (&lvc, sizeof (LV_COLUMN)) ;
		lvc.mask = LVCF_WIDTH ;
	} ;

	// Return TRUE if the point is found in a cell.  Otherwise, FALSE.

	return bFound ;
}


void CFullEditListCtrl::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult)
{
	*pResult = 0 ;				// Result always 0

	// Find out what point on the list control was clicked

	CPoint point ;
	VERIFY (::GetCursorPos(&point)) ;
	//TRACE("***OnDblclk: GetCursorPos x = %d  y = %d", point.x, point.y) ;
	ScreenToClient(&point) ;
	//TRACE("  ---  ScreenToClient x = %d  y = %d\n", point.x, point.y) ;
	
	// Exit if the "click point" can't be mapped to a cell (item) on the list
	// control.

	int iRow = -1, iCol = -1 ;
	CRect rect ;
	if (!GetPointRowCol(&point, iRow, iCol, rect))
		return ;
	//TRACE("***OnDblclk: Passed GetPointRowCol() call.\n") ;

	// Exit if the cell cannot be made completely visible.  Then get the cell's
	// position and dimensions again because it might have moved.

	if (!EnsureVisible(iRow, false))
		return ;
	CRect rect2 ;
	VERIFY(GetItemRect(iRow, rect2, LVIR_BOUNDS)) ;
	rect.top = rect2.top ;
	rect.bottom = rect2.bottom ;

	// If the column is not editable (editability takes precedence), check for
	// and - when appropriate - handle togglability.  Then exit.

	PCOLINFO pci = m_pciColInfo + iCol ;
	if (!pci->beditable) {
		if (!CheckHandleToggleColumns(iRow, iCol, pci))
			CheckHandleCustEditColumn(iRow, iCol, pci) ;
		return ;
	} ;

	// If the row/column contains a "subordinate dialog" cell that can be
	// handled, do it and return.

	if (CheckHandleCustEditColumn(iRow, iCol, pci))
		return ;

	// It is ok to edit the cell normally so fire up, position, and load the
	// edit box.

	m_nRow = iRow ;
	m_nColumn = iCol ;
	CString strTemp = GetItemText(iRow, iCol) ;
	m_edit.SetWindowText(strTemp) ;
	m_edit.MoveWindow(rect) ;
	m_edit.SetSel(0, -1) ;
	m_edit.ShowWindow(SW_SHOW) ;
	m_edit.SetFocus() ;
}


void CFullEditListCtrl::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	// Save any value that was being edited and hide the edit box to end
	// editing.

	SaveValue() ;
	m_edit.ShowWindow (SW_HIDE);
	
	*pResult = 0;				
}


BOOL CFullEditListCtrl::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
		case WM_KEYDOWN:
		case WM_KEYUP:
			if (this == GetFocus())
			{
				switch (pMsg->wParam)
				{
					case VK_END:
					case VK_HOME:
					case VK_UP:
					case VK_DOWN:
					case VK_INSERT:
					case VK_RETURN:
						SendMessage (pMsg->message, pMsg->wParam, pMsg->lParam);
						return TRUE;
				}
			}
			else if (&m_edit == GetFocus ())
			{
				switch (pMsg->wParam)
				{
					case VK_END:
					case VK_HOME:
					case VK_LEFT:
					case VK_RIGHT:
					case VK_RETURN:
					case VK_ESCAPE:
					case VK_TAB:
						m_edit.SendMessage (pMsg->message, pMsg->wParam, pMsg->lParam);
			            return TRUE;
				}
			}
	}
	return CWnd::PreTranslateMessage(pMsg);
}


void CFullEditListCtrl::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)
{
	// Prepare to check the key

	LV_KEYDOWN* pKeyDown = (LV_KEYDOWN*) pNMHDR ;
	*pResult = 0 ;
	CString strPrompt ;
	UINT iSelCount ;

	// Process the keys we're interested in.

	switch (pKeyDown->wVKey) {
		// Edit the first column of the first selected row.

		case VK_RETURN:
			EditCurRowSpecCol(0) ;
			break ;

		// Delete all of the selected rows.  (Don't do anything if the
		// MF_IGNOREDELETE miscellaneous flag is set.)

		case VK_DELETE:
			if (m_dwMiscFlags & MF_IGNOREDELETE)
				return ;
			iSelCount = GetSelectedCount ();
			if (0 == iSelCount)
				return;
			strPrompt.LoadString(IDS_Delete2ItemQuery) ;
			if (IDYES == MessageBox (strPrompt, NULL, MB_YESNO | MB_ICONQUESTION))
			{
				int	iSelIndex = GetNextItem (-1, LVNI_SELECTED);
				int nrow = iSelIndex ;
				while (iSelIndex != -1)
				{
					VERIFY (DeleteItem (iSelIndex));
					iSelIndex = GetNextItem (-1, LVNI_SELECTED);
				}
				if (nrow > -1)
					SendChangeNotification(nrow, 0) ;
			}
			SetFocus ();
			break ;

		// Insert a row and begin editing it.  (Don't do anything if the
		// MF_IGNOREINSERT miscellaneous flag is set.)

		case VK_INSERT:
			if (m_dwMiscFlags & MF_IGNOREINSERT)
				return ;
			// Add a new row above the selected row or at the bottom of the
			// list if nothing is selected.

			int iIndex = GetNextItem (-1, LVNI_SELECTED);
			if (-1 == iIndex)
				iIndex = GetItemCount ();
			ASSERT (-1 != iIndex);
			InsertItem (iIndex, "");
			SetItemData(iIndex, m_nNextItemData++) ;

			// Make sure that the new row is visible and the only one selected.

			SingleSelect(iIndex) ;
			
			// Get the size and position of column 0 in the new row.

			CRect rect;
			GetItemRect (iIndex, rect, LVIR_BOUNDS);
			rect.right = rect.left + GetColumnWidth (0);

			// Start editing column 0.

			m_nRow = iIndex ;
			m_nColumn = 0 ;
			m_edit.MoveWindow (rect);
			m_edit.SetWindowText ("");
			m_edit.ShowWindow (SW_SHOW);
			m_edit.SetFocus ();
			break ;
	} ;
}


bool CFullEditListCtrl::SaveValue()
{
	//TRACE("In SaveValue()\n") ;

	// Just return false if the edit box isn't visible/editing.

	if (!m_edit.IsWindowVisible()) {
		//TRACE("Leaving SaveValue() because edit box not visible.\n") ;
		return false ;
	} ;
	
	// Get the position and size of the edit box now that we know it is
	// visible.

	CRect rect ;
	m_edit.GetWindowRect(rect) ;
	ScreenToClient(rect) ;

	// Prepare to find out what row/column is being edited.

	POINT pt ;
	pt.x = rect.left ;
	pt.y = rect.top ;
	int iRow = -1, iCol = -1 ;

	// If the list box cell can be determined, save the edit box's contents in
	// that cell.

	if (GetPointRowCol(&pt, iRow, iCol, rect)) {
		CString strTemp ;
		m_edit.GetWindowText(strTemp) ;
		VERIFY(SetItemText(iRow, iCol, strTemp)) ;
		SendChangeNotification(iRow, iCol) ;
	} ;

	// The text in the edit box was saved in the appropriate list box cell
	// when it can be so return true to indicate this.

	return true ;
}


void CFullEditListCtrl::HideEditBox()
{
	m_edit.ShowWindow(SW_HIDE);
	SetFocus() ;
}


bool CFullEditListCtrl::GetColumnData(CObArray* pcoadata, int ncolnum)
{
	// Fail if the column number is bad.

	if (ncolnum < 0 || ncolnum >= m_nNumColumns)
		return false ;

	// Clear and then initialize the array

	pcoadata->RemoveAll() ;
	int numitems = GetItemCount() ;
	PCOLINFO pci = m_pciColInfo + ncolnum ;
	switch (pci->cdttype) {
		case COLDATTYPE_STRING:
		case COLDATTYPE_TOGGLE:
		case COLDATTYPE_CUSTEDIT:
			// Extra initialization needed for string arrays.
			((CStringArray*) pcoadata)->SetSize(numitems) ;
			break ;
		default:
			pcoadata->SetSize(numitems) ;
	} ;

	// Declare and initialize the Item structure

	LV_ITEM lvi ;
	char	acitemtext[4096] ;
	lvi.mask = LVIF_TEXT ;
	lvi.iSubItem = ncolnum ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 4095 ;
	int npos ;
	CString cscell ;

	// Load the column's data into the array in a way based on the data type.

	for (int n = 0 ; n < numitems ; n++) {
		lvi.iItem = n ;
		VERIFY(GetItem(&lvi)) ;
		switch ((m_pciColInfo + ncolnum)->cdttype) {
			case COLDATTYPE_INT:
				((CUIntArray*) pcoadata)->SetAt(n, atoi(acitemtext)) ;
				//TRACE("Set col %d sub %d to %d\n", ncolnum, n, ((CUIntArray*) pcoadata)->GetAt(n)) ;
				break ;
			case COLDATTYPE_STRING:
			case COLDATTYPE_TOGGLE:
				((CStringArray*) pcoadata)->SetAt(n, acitemtext) ;
				//TRACE("Set col %d sub %d to '%s'\n", ncolnum, n, ((CStringArray*) pcoadata)->GetAt(n)) ;
				break ;
			case COLDATTYPE_CUSTEDIT:
				cscell = acitemtext ;
				if ((npos = cscell.Find(_T("  ..."))) >= 0)
					cscell = cscell.Left(npos) ;
				((CStringArray*) pcoadata)->SetAt(n, cscell) ;
				//TRACE("Set col %d sub %d to '%s'\n", ncolnum, n, ((CStringArray*) pcoadata)->GetAt(n)) ;
				break ;
			default:
				ASSERT(0) ;
		} ;
	} ;

	// Return true because the columns data was saved.

	return true ;
}


bool CFullEditListCtrl::SetColumnData(CObArray* pcoadata, int ncolnum)
{
	// Get the number (sub)items to be loaded into the column.  If there are
	// more (sub)items than there are rows, add extra rows.

	int numitems = (int)pcoadata->GetSize() ;
	int noldnumitems = GetItemCount() ;
	if (numitems > noldnumitems) {
		SetItemCount(numitems) ;
		m_nNextItemData = numitems + 1 ;
	} ;

	// Load the data into the column.  If the data aren't strings, they are
	// converted into strings first.  The width is checked when necessary.

	CString csitem ;
	COLDATTYPE cdtdatatype = (m_pciColInfo + ncolnum)->cdttype ;
	for (int n = 0 ; n < numitems ; n++) {
		// Get the string to load.

		switch (cdtdatatype) {
			case COLDATTYPE_INT:
				csitem.Format("%d", pcoadata->GetAt(n)) ;
				break ;
			case COLDATTYPE_STRING:
			case COLDATTYPE_TOGGLE:
			case COLDATTYPE_CUSTEDIT:
				csitem = ((CStringArray*) pcoadata)->GetAt(n) ;
				break ;
			default:
				ASSERT(0) ;
		} ;

		// Load the item into the appropriate row and column

		if (n >= noldnumitems && ncolnum == 0) {
			VERIFY(InsertItem(n, csitem) != -1) ;
			SetItemData(n, n);
		} else
			VERIFY(SetItem(n, ncolnum, LVIF_TEXT,  csitem, -1, 0, 0, n)) ;
	} ;

	return true ;
}


void CFullEditListCtrl::SetCurRow(int nrow)
{
	// First remove the focus and selection from any rows that have it now.

	int nr = -1 ;
	for ( ; (nr = GetNextItem(nr, LVNI_SELECTED)) != -1 ; ) 
		SetItem(nr,0,LVIF_STATE,NULL,-1,LVIS_SELECTED,0,nr) ;

	// Now set the new row.

	SetItem(nrow, 0, LVIF_STATE, NULL, -1, LVIS_FOCUSED+LVIS_SELECTED,
		    LVIS_FOCUSED+LVIS_SELECTED, nrow) ;
	m_nRow = nrow ;
}


int CALLBACK CFullEditListCtrl::SortListData(LPARAM lp1, LPARAM lp2, LPARAM lp3)
{
	// Get pointer to associated class instance

	CFullEditListCtrl* pcfelc = (CFullEditListCtrl*) lp3 ;

	// Try to find the item indexes.  This should not fail.

	LV_FINDINFO lvfi ;
	lvfi.flags = LVFI_PARAM ;
	lvfi.lParam = lp1 ;
	int nitem1, nitem2 ;
	VERIFY((nitem1 = pcfelc->FindItem(&lvfi)) != -1) ;
	lvfi.lParam = lp2 ;
	VERIFY((nitem2 = pcfelc->FindItem(&lvfi)) != -1) ;

	// Now get the item data.  Again, this should not fail.

	LV_ITEM lvi1, lvi2 ;
	char	acitemtext1[4096], acitemtext2[4096] ;
	lvi1.mask = lvi2.mask = LVIF_TEXT ;
	lvi1.iItem = nitem1	;
	lvi2.iItem = nitem2 ;
	lvi1.iSubItem = lvi2.iSubItem = pcfelc->m_nSortColumn ;
	lvi1.pszText = acitemtext1 ;
	lvi2.pszText = acitemtext2 ;
	lvi1.cchTextMax = lvi2.cchTextMax = 4095 ;
	VERIFY(pcfelc->GetItem(&lvi1)) ;
	VERIFY(pcfelc->GetItem(&lvi2)) ;

	// Convert the item text when necessary and compare the items.

	int ncompresult, inum1, inum2 ;
	PCOLINFO pci = pcfelc->m_pciColInfo + pcfelc->m_nSortColumn ;
	switch (pci->cdttype) {
		case COLDATTYPE_INT:
			inum1 = atoi(acitemtext1) ;
			inum2 = atoi(acitemtext2) ;
			ncompresult = inum1 - inum2 ;
			break ;
		case COLDATTYPE_STRING:
		case COLDATTYPE_TOGGLE:
		case COLDATTYPE_CUSTEDIT:
			ncompresult = _stricmp(acitemtext1, acitemtext2) ;
			break ;
		default:
			ASSERT(0) ;
	} ;

	// Return the result of the comparison.  Reverse it before returning if
	// sorting in descending order.

	return ((pci->basc) ? ncompresult : 0 - ncompresult) ;
}


void CFullEditListCtrl::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	// Save any in progress editing and shut it down before doing anything else.

	EndEditing(true) ;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
	// Get the sort column and send it to the sort control routine.

	SortControl(pNMListView->iSubItem) ;
	
	*pResult = 0;
}


bool CFullEditListCtrl::SortControl(int nsortcolumn)
{
    CWaitCursor cwc ;

	// Save any in progress editing and shut it down before doing anything else.

	EndEditing(true) ;

	// Get a pointer to the column info structure

	PCOLINFO pci = m_pciColInfo + nsortcolumn ;

	// If the column is not sortable, just return false.

	if (!pci->bsortable)
		return false ;

	// Save the sort column, reverse the sort flag, and then sort the data.

	m_nSortColumn = nsortcolumn ;
	pci->basc = !pci->basc ;
	SortItems(SortListData, (LPARAM) this) ;

	// Data should have been sorted so...

	return true ;
}


void CFullEditListCtrl::SingleSelect(int nitem)
{
	int		nselitem ;			// Selected item index

	// First, deselect all of the currently selected rows.

	nselitem = -1 ;
	while ((nselitem = GetNextItem(nselitem, LVNI_SELECTED)) != -1)
		SetItemState(nselitem, 0, LVIS_SELECTED | LVIS_FOCUSED) ;

	// Now select the requested row (item) and make it visible.

	SetItemState(nitem, LVIS_SELECTED | LVIS_FOCUSED,
				 LVIS_SELECTED | LVIS_FOCUSED) ;
	EnsureVisible(nitem, false) ;
}


bool CFullEditListCtrl::GetRowData(int nrow, CStringArray& csafields)
{
	// Fail if the requested row number is too large.

	if (nrow > GetItemCount())
		return false ;

	// Make sure that the string array is large enough to hold all of the
	// strings in a row.  IE, the row's item text and all of the subitems'
	// text.

	if (m_nNumColumns > csafields.GetSize())
		csafields.SetSize(m_nNumColumns) ;

	// Declare and initialize the Item structure

	LV_ITEM lvi ;
	char	acitemtext[4096] ;
	lvi.iItem = nrow ;
	lvi.mask = LVIF_TEXT ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 4095 ;

	// Get each field in the row and copy it into the fields array.

	for (int n = 0 ; n < m_nNumColumns ; n++) {
		lvi.iSubItem = n ;
		VERIFY(GetItem(&lvi)) ;
		csafields[n] = acitemtext ;
	} ;

	// All went well so...

	return true ;
}


bool CFullEditListCtrl::EndEditing(bool bsave)
{
	// Save the new value first if requested.  Return if there is nothing to
	// save or - when not saving - if nothing is being edited.

	if (bsave) {
		if (!SaveValue())
			return false ;
	} else
		if (!m_edit.IsWindowVisible())
			return false ;

	// Now hide the edit box and give the focus back to the list control.

	m_edit.ShowWindow(SW_HIDE) ;
	SetFocus() ;

	// Mission accomplished so...

	return true ;
}


bool CFullEditListCtrl::EditCurRowSpecCol(int ncolumn)
{
	// Save the specified column number.  If it is too big, reset it to 0.
	// If the column isn't editable, try the next one.  Return false if an
	// editable column can't be found.

	for (int n = 0 ; n < m_nNumColumns ; n++, ncolumn++) {
		if (ncolumn >= m_nNumColumns)
			ncolumn = 0 ;
 		if ((m_pciColInfo + ncolumn)->beditable)
			break ;
	} ;
	if (n < m_nNumColumns)
		m_nColumn = ncolumn ;
	else
		return false ;

	// Get the first currently selected row number.  Use row number 0 if no
	// row is selected.

	if ((m_nRow = GetNextItem(-1, LVNI_SELECTED)) == -1)
		m_nRow = 0 ;

	// Make the current row, the only selected row and make sure it is visible.

	SingleSelect(m_nRow) ;

	// Now determine the dimensions of the specified column.  Begin this by
	// getting the dimensions of the entire row...

	CRect	rect ;
	VERIFY(GetItemRect(m_nRow, rect, LVIR_BOUNDS)) ;

	// ...Finish by looping through all of the columns getting their dimensions
	// and using those dimensions to adjust the left side of the rectangle
	// until the current column is reached.  Then adjust the right side of the
	// rectangle.

	LV_COLUMN lvc ;
	for (int ncol = 0 ; ncol <= m_nColumn ; ncol++) {
		ZeroMemory(&lvc, sizeof(LV_COLUMN)) ;
		lvc.mask = LVCF_WIDTH ;
		GetColumn(ncol, &lvc) ;
		if (ncol < m_nColumn)
			rect.left += lvc.cx ;
	} ;
	rect.right = rect.left + lvc.cx ;

	// Load, position, size, and show the edit box.

	CString strTemp = GetItemText(m_nRow, m_nColumn) ;
	m_edit.SetWindowText(strTemp) ;
	m_edit.MoveWindow(rect) ;
	m_edit.SetSel(0, -1) ;
	m_edit.ShowWindow(SW_SHOW) ;
	m_edit.SetFocus() ;

	return true ;
}


void CFullEditListCtrl::OnVScroll(UINT nSBCode, UINT nPos,
								  CScrollBar* pScrollBar)
{
	// Things get screwy if the list control scrolls while an item is being
	// edited so end editing before allowing scrolling to take place.

	EndEditing(true) ;
	
	CListCtrl::OnVScroll(nSBCode, nPos, pScrollBar);
}


void CFullEditListCtrl::OnHScroll(UINT nSBCode, UINT nPos,
								  CScrollBar* pScrollBar)
{
	// Things get screwy if the list control scrolls while an item is being
	// edited so end editing before allowing scrolling to take place.

	EndEditing(true) ;
	
	CListCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
}


/******************************************************************************

  CFullEditListCtrl::CheckHandleToggleColumns

  First check to see if the row or column has togglable.  If not, just return.
  If the row is togglable, find the togglable column (cell).  Then either set
  its contents if it is empty or clear it if it is not empty.

  Return true if a toggle-able column was found and toggled.  Otherwise, return
  false.

******************************************************************************/

bool CFullEditListCtrl::CheckHandleToggleColumns(int nrow, int ncol,
												 PCOLINFO pci)
{
	// Return if there is no togglable column in this list.

	if (!(m_dwToggleFlags & TF_HASTOGGLECOLUMNS))
		return false ;

	// If a specific togglable column must be clicked and that column was not
	// clicked, just return.

	if (m_dwToggleFlags & TF_CLICKONCOLUMN) {
		if (pci->cdttype != COLDATTYPE_TOGGLE)
			return false ;
	
	// If any part of the row can be double-clicked to toggle the togglable
	// column, find that column.  Return if there is no such column.

	} else {
		pci = m_pciColInfo ;
		for (ncol = 0 ; ncol < m_nNumColumns ; ncol++, pci++) {
			if (pci->cdttype == COLDATTYPE_TOGGLE)
				break ;
		} ;
		if (ncol >= m_nNumColumns)
			return false ;
	} ;

	// Get the contents of the specified cell.

	CString strcell = GetItemText(nrow, ncol) ;

	// If the cell is empty, load it with the toggle string.  If the cell is
	// not empty, clear its contents.

	if (strcell.IsEmpty())
		VERIFY(SetItemText(nrow, ncol, pci->lpctstrtoggle)) ;
	else
		VERIFY(SetItemText(nrow, ncol, _T(""))) ;
	SendChangeNotification(nrow, ncol) ;

	return true ;
}


/******************************************************************************

  CFullEditListCtrl::CheckHandleCustEditColumn

  First check to see if the row or column may contain a cell may be one that is
  only editable with a custom edit routine.  If not, just return.  Next,
  make sure that the cell not only might be of this type but actually is of this
  type.  If not, just return.

  Now, get the contents of the selected cell and remove the ellipses from the
  end of it.  (The ellipses will be replaced before the new string is put back
  into the cell.)

  Next, comes the tricky part.  Use the owner class pointer to call the routine
  in that class which will manage the work of editting the cell's contents.
  Although CFullEditListCtrl is supposed to be a generic class, this routine
  must know what the owner class is so that the management routine can be
  called.  This means that extra, owner class specific, code must be added to
  this routine each time a new owner class is added that uses this feature in
  CFullEditListCtrl.

  If the edit request was handled via a subordinate dialog box, return true.
  Otherwise, return false.

******************************************************************************/

bool CFullEditListCtrl::CheckHandleCustEditColumn(int nrow, int ncol,
											      PCOLINFO pci)
{
	// Return if there is no custom edit column in this list.

	if (!(m_dwCustEditFlags & CEF_HASTOGGLECOLUMNS))
		return false ;

	// Return if the selected row does not contain a custom edit cell.

	int n = (int)m_cuiaCustEditRows.GetSize() ;
	ASSERT(m_cuiaCustEditRows.GetSize()) ;
	if (nrow >= m_cuiaCustEditRows.GetSize() || m_cuiaCustEditRows[nrow] == 0)
		return false ;

	// If a specific custom edit column must be clicked and that column was not
	// clicked, just return.

	if (m_dwCustEditFlags & CEF_CLICKONCOLUMN) {
		if (pci->cdttype != COLDATTYPE_CUSTEDIT)
			return false ;
	
	// If any part of the row can be double-clicked to edit the custom edit
	// column, find that column.  Return if there is no such column.

	} else {
		pci = m_pciColInfo ;
		for (ncol = 0 ; ncol < m_nNumColumns ; ncol++, pci++) {
			if (pci->cdttype == COLDATTYPE_CUSTEDIT)
				break ;
		} ;
		if (ncol >= m_nNumColumns)
			return false ;
	} ;

	// Get the contents of the specified cell and remove the ellipses from the
	// end of it.

	CString strcell = GetItemText(nrow, ncol) ;
	int npos ;
	if ((npos = strcell.Find(_T("  ..."))) >= 0)
		strcell = strcell.Left(npos) ;

	// Find the class for the owner and use that information to call the
	// management routine.  If this routine "fails" or is cancelled, return
	// true without updating the cell.

	bool brc ;
	brc = (*m_lpCellEditProc)(m_pcoOwner, nrow, ncol, &strcell) ;
	if (!brc)
		return true ;

	// Add the ellipses back on to the cell's new contents and update the cell.

	strcell += _T("  ...") ;
	VERIFY(SetItemText(nrow, ncol, strcell)) ;
	SendChangeNotification(nrow, ncol) ;
	SetFocus() ;

	return true ;
}


void CFullEditListCtrl::SendChangeNotification(int nrow, int ncol)
{
	// Do nothing if the owner does not want to be notified of a change in one
	// of the cells in the list control.

	if (!(m_dwMiscFlags & MF_SENDCHANGEMESSAGE))
		return ;

	// Send the message

	::PostMessage(GetParent()->m_hWnd, WM_LISTCELLCHANGED, nrow, ncol) ;
}



/////////////////////////////////////////////////////////////////////////////
// CFlagsListBox

CFlagsListBox::CFlagsListBox()
{
	m_bReady = false ;
	m_nGrpCnt = 0 ;
}

CFlagsListBox::~CFlagsListBox()
{
}


BEGIN_MESSAGE_MAP(CFlagsListBox, CListBox)
	//{{AFX_MSG_MAP(CFlagsListBox)
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblclk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/******************************************************************************

  CFlagsListBox::Init

  Save the parameters that are used to control the behaviour of the list box.
  Set the list box's tab stop.  Then build the list box items based on the
  flag names and settings and load them into the list box.

  Args:
	csafieldnames		Flag field names
	dwsettings			Current flag setting(s)
	cuiaflaggroupings	Indexes for related groups of flags
	ngrpcnt				Number of flag groups
	lptstrsetstring		String to display when a flag is set
	ntabstop			List box tab stop, sets column widths
	bnoclear			True iff dbl-clk doesn't clear a flag that is set
	nocleargrp			-1 or only 0-based group number that bnoclear applies to

  ***  IMPORTANT NOTE  ***
  See OnDblclk() to find out how the data in m_cuiaFlagGroupings and m_nGrpCnt
  are interpreted.

******************************************************************************/

bool CFlagsListBox::Init(CStringArray& csafieldnames, DWORD dwsettings,
						 CUIntArray& cuiaflaggroupings, int ngrpcnt,
						 LPTSTR lptstrsetstring, int ntabstop,
						 bool bnoclear /*=false*/, int nocleargrp /*=-1*/)
{
	// Check parameters

	ASSERT(csafieldnames.GetSize())	;
	ASSERT(cuiaflaggroupings.GetSize() >= (ngrpcnt * 2)) ;
	ASSERT(lptstrsetstring)	;
	ASSERT(ntabstop > 0) ;

	// Copy parameters needed later

	m_cuiaFlagGroupings.Copy(cuiaflaggroupings) ;	
	m_nGrpCnt = ngrpcnt ;				
	m_csSetString = lptstrsetstring ;			
	m_nNumFields = (int)csafieldnames.GetSize() ;
	m_bNoClear = bnoclear ;
	m_nNoClearGrp = nocleargrp ;

	// Make sure the list box is empty.

	ResetContent() ;

	// Set the position of the list box's tabstop.  This value is passed in
	// because it is a dialog box specific value.

	SetTabStops(1, &ntabstop) ;

	// Now combine the field names and settings and add them to the listbox.

	CString cs ;
	int nbit = 1 ;
	for (int n = 0 ; n < m_nNumFields ; n++, nbit <<= 1) {
		cs = (dwsettings & nbit) ? m_csSetString : _T("") ;
		cs = csafieldnames[n] + _T("\t") + cs ;
		AddString(cs) ;
	} ;

	// Make sure the list box has the focus.

	SetFocus() ;

	// All went well so...

	m_bReady = true ;
	return true ;
}


/******************************************************************************

  CFlagsListBox::Init2

  The flag settings in pcssettings are in the form of a hex number represented
  as a string that may begin with "0x".  For example, "0xA23" and "A23".  Turn
  this string into a DWORD and pass this DWORD plus the rest of the parameters
  to the other form of this function that takes the settings parameter as a
  DWORD.  It does the rest of the work.

  Args:
	csafieldnames		Flag field names
	pcssettings			Current flag setting(s)
	cuiaflaggroupings	Indexes for related groups of flags
	ngrpcnt				Number of flag groups
	lptstrsetstring		String to display when a flag is set
	ntabstop			List box tab stop, sets column widths
	bnoclear			True iff dbl-clk doesn't clear a flag that is set
	nocleargrp			-1 or only 0-based group number that bnoclear applies to

  ***  IMPORTANT NOTE  ***
  See OnDblclk() to find out how the data in m_cuiaFlagGroupings and m_nGrpCnt
  are interpreted.

******************************************************************************/

bool CFlagsListBox::Init2(CStringArray& csafieldnames, CString* pcssettings,
						  CUIntArray& cuiaflaggroupings, int ngrpcnt,
						  LPTSTR lptstrsetstring, int ntabstop,
						  bool bnoclear /*=false*/, int nocleargrp /*=-1*/)
{
	// Turn pcssettings into a dword.  (Skip passed "0x" if it is on the
	// beginning of the string.)

	LPTSTR lptstr, lptstr2 ;
	lptstr = pcssettings->GetBuffer(16) ;
	int n = pcssettings->GetLength() ;
	*(lptstr + n) = 0 ;
	if (*(lptstr + 1) == 'x')
		lptstr += 2 ;
	DWORD dwsettings = strtoul(lptstr, &lptstr2, 16) ;
	
	// The other Init() finishes the job.

	return (Init(csafieldnames, dwsettings, cuiaflaggroupings, ngrpcnt,
				 lptstrsetstring, ntabstop, bnoclear, nocleargrp)) ;
}


/******************************************************************************

  CFlagsListBox::GetNewFlagDWord()

  Read the settings of the flags in the list box to determine the new flag
  dword.  Then return it.

******************************************************************************/

DWORD CFlagsListBox::GetNewFlagDWord()
{
	DWORD dwflags = 0 ;			// Flag dword built here
	DWORD dwbit = 1 ;			// Used to set bits that are on

	// Loop through each flag in the list box

	CString csentry, csvalue ;
	int npos ;
	for (int n = 0 ; n < m_nNumFields ; n++, dwbit <<= 1) {
		// Get the current flag and isolate its setting.

		GetText(n, csentry) ;
		npos = csentry.Find(_T('\t')) ;
		csvalue = csentry.Mid(npos + 1) ;

		// If the current flag is set, turn on its bit in dwflags.

		if (csvalue.GetLength())
			dwflags |= dwbit ;
	} ;

	// Return the flag DWORD.

	return dwflags ;
}


/******************************************************************************

  CFlagsListBox::GetNewFlagString()

  Use the other version of this routine to get the DWORD version of the flags.
  Then convert it to a string a save it in csflags.  "0x" may or may not be
  prepended to the string.

******************************************************************************/

void CFlagsListBox::GetNewFlagString(CString* pcsflags, bool badd0x /*=true*/)
{
	// Get the DWORD version of the flag.

	DWORD dwflags = GetNewFlagDWord() ;

	// Format the flags as a string and prepend "0x" when requested.

	if (badd0x)
		pcsflags->Format("0x%x", dwflags) ;
	else
		pcsflags->Format("%x", dwflags) ;
}


/////////////////////////////////////////////////////////////////////////////
// CFlagsListBox message handlers

/******************************************************************************

  CFlagsListBox::OnDblclk()

  First, toggle the setting of the selected item.  At least, that is what is
  usually done first.  If m_bNoClear is set and the user has asked to clear a
  flag, don't do this or anything else.  Just return.  Use m_bNoClear when at
  least one flag must always be set.  See #4 for more information on m_bNoClear.

  Next, process the rest of the flags in the items flag group.  The following
  things can happen based on the group:
	1.	If the item is not in a group, do nothing else.  This is useful when
		any combination of flags can be set.  The most efficient way to do this
		is by setting m_nGrpCnt to 0.
	2.	The item indexes in m_cuiaFlagGroupings that contain the selected item
		are positive.  Only one of the specified flags can be set.  If the
		selected item was set, clear the rest of the flags in the group.
	3.	The item indexes in m_cuiaFlagGroupings that contain the selected item
		are negative.  (The absolute value of the indexes is used for tests.)
		Change the state of the other flags in the group, too.  Generally, this
		only makes sense in a two flag group where one and only one of the flags
		MUST be selected.
	4.  If m_bNoClear is set and m_nNoClearGrp = -1, m_bNoClear affects all
		flags.  If m_nNoClearGrp is >= 0, it refers to the single group that
		m_bNoClear affects.

******************************************************************************/

void CFlagsListBox::OnDblclk()
{
	// Do nothing if the edit control isn't ready, yet.

	if (!m_bReady)
		return ;

	// Do nothing if no item is selected in the list box.

	int nselitem ;
	if ((nselitem = GetCurSel()) == LB_ERR)
		return ;

	// Get the listbox entry and split it into name and value components.

	CString csentry, csname, csvalue ;
	GetText(nselitem, csentry) ;
	int npos = csentry.Find(_T('\t')) ;
	csname = (npos > 0) ? csentry.Left(npos) : _T("") ;
	csvalue = csentry.Mid(npos + 1) ;

	// Find the flag grouping for the selected flag.

	int n, nidx ;
	for (n = nidx = 0 ; n < m_nGrpCnt ; n++, nidx += 2)
		if (abs(m_cuiaFlagGroupings[nidx]) <= nselitem
		 && abs(m_cuiaFlagGroupings[nidx+1]) >= nselitem)
			break ;

	// Determine the flags current state.  If it is set and m_bNoClear == true,
	// don't do anything based on the value of m_nNoClearGrp.  Just return.

	bool boldstate = !csvalue.IsEmpty() ;
	if (m_bNoClear && boldstate && (m_nNoClearGrp == -1 || m_nNoClearGrp == n))
		return ;

	// Change the state of the selected flag.

	csvalue = (boldstate) ? _T("") : m_csSetString ;
	csentry = csname + _T('\t') + csvalue ;
	DeleteString(nselitem) ;
	InsertString(nselitem, csentry) ;
	
	// Do nothing else if the selected flag is not in a flag grouping.

	if (n >= m_nGrpCnt)	{
		SetCurSel(nselitem) ;
		return ;
	} ;

	// Find out if this group has to have a flag set.  If it doesn't and the
	// selected flag was cleared, there is nothing left to do.

	bool bmustset = ((int) m_cuiaFlagGroupings[nidx+1]) < 0 ;
	if (!bmustset && boldstate)	{
		SetCurSel(nselitem) ;
		return ;
	} ;

	// Loop through all of the flags in the current group.  Change the setting
	// of all flags in the group -- EXCEPT the selected flag -- to the old value
	// of the selected flag.

	n = abs(m_cuiaFlagGroupings[nidx+1]) ;
	csvalue = (boldstate) ? m_csSetString : _T("") ;
	for (nidx = abs(m_cuiaFlagGroupings[nidx]) ; nidx <= n ; nidx++) {
		if (nidx == nselitem)
			continue ;
		GetText(nidx, csentry) ;
		npos = csentry.Find(_T('\t')) ;
		csname = (npos > 0) ? csentry.Left(npos + 1) : _T("") ;
		csentry = csname + csvalue ;
		DeleteString(nidx) ;
		InsertString(nidx, csentry) ;
	} ;

	// Make sure that the flag selected by the user is still selected and
	// return.

	SetCurSel(nselitem) ;
	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontedit.cpp ===
/******************************************************************************

  Source File:  Font Knowledge Base.CPP

  This handles the DLL initialization and termination code needed for the DLL
  to work as an AFX Extension DLL.  It was created by App Wizard, and probably
  will see little modification.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  03-07-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
//#include    <AfxDllx.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***	Commented out because this file is no longer part of a DLL.

static AFX_EXTENSION_MODULE FontKnowledgeBaseDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) 	{
		TRACE0("Font Knowledge Base.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(FontKnowledgeBaseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(FontKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Font Knowledge Base.DLL Terminating!\n");
	}
	return 1;   // ok
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontinfo.cpp ===
/******************************************************************************

  Source File:  Generic Font Information.CPP

  This implements the CFontInfo and all related classes, which describe printer
  fonts in all the detail necessary to satisfy all these different operating
  systems.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Began work on this monster
  02-01-1998    norzilla@asccessone.com aka Rick Mallonee  rewrote nearly the whole thing.

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include	"utility.h"
#include    "FontInfo.H"
#include    "ChildFrm.H"     //  Definition of Tool Tips Property Page class
#include	"comctrls.h"
#include    "FontView.H"
#include	<uni16res.h>
#include	"rcfile.h"
#include    "ProjRec.H"

static const double gdConvertRadToDegree = 900.0 / atan2(1.0, 0.0);		//  A handy constant for converting radians to 10's of a degree
static CCodePageInformation* pccpi = NULL ;								//  Use a static CCodePageInformation to derive more benefit from caching

/******************************************************************************

  CKern

  This class encapsulates the kerning pair structure.  It's pretty trivial.
  The CFontInfo class maintains an array of these.
%
******************************************************************************/

class CKern : public CObject
{
    FD_KERNINGPAIR  m_fdkp;
public:
    CKern() { m_fdkp.wcFirst = m_fdkp.wcSecond = m_fdkp.fwdKern = 0; }
    CKern(FD_KERNINGPAIR& fdkp) { m_fdkp = fdkp; }
    CKern(WCHAR wcf, WCHAR wcs, short sa) {
				m_fdkp.wcFirst = wcf ;
				m_fdkp.wcSecond = wcs ;
				m_fdkp.fwdKern = sa ;
	}

    WCHAR   First() const { return m_fdkp.wcFirst; }
    WCHAR   Second() const { return m_fdkp.wcSecond; }
    short   Amount() const { return m_fdkp.fwdKern; }

    void    SetAmount(short sNew) { m_fdkp.fwdKern = sNew; }
    void    SetAll(WCHAR wcf, WCHAR wcs, short sa) {
				m_fdkp.wcFirst = wcf ;
				m_fdkp.wcSecond = wcs ;
				m_fdkp.fwdKern = sa ;
	}

    void    Store(CFile& cf) { cf.Write(&m_fdkp, sizeof m_fdkp); }
};

/******************************************************************************

  CFontDifference class

  This class handles the requisite information content for the Font Difference
  structure involved with Font Simulation.

******************************************************************************/
CFontDifference::CFontDifference(PBYTE pb, CBasicNode *pcbn)
{
    FONTDIFF    *pfd = (FONTDIFF *) pb;
    m_pcbnOwner = pcbn;

    m_cwaMetrics.Add(pfd -> usWinWeight);
    m_cwaMetrics.Add(pfd -> fwdMaxCharInc);
    m_cwaMetrics.Add(pfd -> fwdAveCharWidth);

	// NOTE:	The conversion done in this statement is reversed in a statement
	//			in the CFontDifference::Store() routine.  For whatever reason,
	//			this two steps can repeatedly reduce the user supplied value by
	//			1.  To prevent this, 1 is added back in the following statement.
	
    m_cwaMetrics.Add((WORD) (gdConvertRadToDegree *
        atan2((double) pfd -> ptlCaret.x, (double) pfd -> ptlCaret.y)) + 1);
}

/******************************************************************************

  CFontDifference::SetMetric

  This function will modify one of the four metrics, if it is new, and it meets
  our criteria (Max >= Average, 0 <= Angle < 900, Weight <= 1000).  Errors are
  reported via a public enum return code.

******************************************************************************/
WORD    CFontDifference::SetMetric(unsigned u, WORD wNew)
{
    if  (wNew == m_cwaMetrics[u]) return  OK;

	/* Verification isn't needed and removing it solves other problems in the
	   UFM Editor.

    switch  (u)
		{
		case Max:     if  (wNew < m_cwaMetrics[Average]) return  Reversed;
				      break;

		case Average: if  (wNew > m_cwaMetrics[Max])     return  Reversed;
					  break;

		case Weight:  if  (wNew > 1000)  return  TooBig;
					  break;

		default:      if  (wNew > 899)   return  TooBig;					//  Angle
		}
	*/
	gdConvertRadToDegree;
    m_cwaMetrics[u] = wNew;
    m_pcbnOwner -> Changed();
    return  OK;
}

/******************************************************************************

  CFontDifference::Store(CFile& cf)

  This member creates a FONTDIFF structure, fills it, and writes it to the
  given file.  The big calculation is the x and y components for the italic
  angle, if there is one.

******************************************************************************/

void    CFontDifference::Store(CFile& cf, WORD wfSelection)
{
    FONTDIFF    fd = {0, 0, 0, 0, m_cwaMetrics[Weight], wfSelection,
					  m_cwaMetrics[Average], m_cwaMetrics[Max]};

    fd.bWeight = (m_cwaMetrics[Weight] >= FW_BOLD) ? PAN_WEIGHT_BOLD :
				 (m_cwaMetrics[Weight] > FW_EXTRALIGHT) ?
				 PAN_WEIGHT_MEDIUM : PAN_WEIGHT_LIGHT;

	if(gdConvertRadToDegree)				// raid 116588 Prefix :: constant value;
		fd.ptlCaret.x = !m_cwaMetrics[Angle] ? 0 :
			(long) (10000.0 * tan(((double) m_cwaMetrics[Angle]) / gdConvertRadToDegree));

    fd.ptlCaret.y = m_cwaMetrics[Angle] ? 10000 : 1;

    cf.Write(&fd, sizeof fd);
}

/******************************************************************************
	And now, for the hardest working class in show business (and a personal friend
	of mine):

  CFontInfo class

  This class encapsulates all of the font knowledge this application needs.

******************************************************************************/

IMPLEMENT_SERIAL(CFontInfo, CProjectNode, 0)

/******************************************************************************

  CFontInfo::MapPFM

  This loads a PFM format file, if it isn't already loaded.

******************************************************************************/

BOOL    CFontInfo::MapPFM() {

    if  (m_cbaPFM.GetSize())
        return  TRUE;   //  Already has been loaded!

    try {
        CFile   cfLoad(m_csSource, CFile::modeRead | CFile::shareDenyWrite);
        m_cbaPFM.SetSize(cfLoad.GetLength());
        cfLoad.Read(m_cbaPFM.GetData(), cfLoad.GetLength());
    }

    catch   (CException   *pce) {
        pce -> ReportError();
        pce -> Delete();
        m_cbaPFM.RemoveAll();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CFontInfo::GetTranslation

  This loads a PFM format file and gets the default CTT ID from it.  Nothing
  else is done.

******************************************************************************/

extern "C"  int ICttID2GttID(long lPredefinedCTTID);

int     CFontInfo::GetTranslation(CSafeObArray& csoagtts)
{
    //  PFM file structures- these are declared at this level to keep them off
    //  the master class list for the project.

#pragma pack(1) //  The following is byte-aligned

    struct sPFMHeader {
        WORD    m_wType, m_wPoints, m_wVertRes, m_wHorizRes, m_wAscent,
                m_wInternalLeading, m_wExternalLeading;
        BYTE    m_bfItalic, m_bfUnderline, m_bfStrikeOut;
        WORD    m_wWeight;
        BYTE    m_bCharSet;
        WORD    m_wPixWidth, m_wPixHeight;
        BYTE    m_bfPitchAndFamily;
        WORD    m_wAvgWidth, m_wMaxWidth;
        BYTE    m_bFirstChar, m_bLastChar, m_bDefaultChar, m_bBreakChar;
        WORD    m_wcbWidth;
        DWORD   m_dwDevice, m_dwFace, m_dwBitsPointer, m_dwofBits;
        BYTE    m_bReserved;
    };

    struct sPFMExtension {
        WORD    m_wcbRemaining; //  From this point on
        DWORD   m_dwofExtMetrics, m_dwofExtentTable, m_dwofOriginTable,
                m_dwofPairKernTable, m_dwofTrackKernTable, m_dwofDriverInfo,
                m_dwReserved;
    };

#pragma pack (2)    //  Everything else has word alignment

    struct sOldKernPair {
        union {
            BYTE m_abEach[2];
            WORD m_wBoth;
        };
        short m_sAmount;
    };

    struct sKernTrack {
        short m_sDegree, m_sMinSize, m_sMinAmount, m_sMaxSize, m_sMaxAmount;
    };

    struct sPFMDriverInfo {
        enum {CurrentVersion = 0x200};
        enum {CannotItalicize = 1, CannotUnderline, SendCRAfterUsing = 4,
                CannotMakeBold = 8, CannotDoubleUnderline = 0x10,
                CannotStrikeThru = 0x20, BackspaceForPairs = 0x40};
        WORD    m_wcbThis, m_wVersion, m_wfCapabilities, m_widThis, m_wAdjustY,
                m_wYMovement, m_widCTT, m_wUnderlinePosition,
                m_wDoubleUnderlinePosition, m_wStrikeThruPosition;
        DWORD   m_dwofSelect, m_dwofDeselect;
        WORD    m_wPrivateData;   /* Used in DeskJet driver for font enumerations */
        short   m_sShiftFromCenter;
        enum {HPIntelliFont, TrueType, PPDSScalable, CapsL, OEMType1, OEMType2};
        WORD    m_wFontType;
    };

#pragma pack()  //  We now return control to you

    if  (!MapPFM())
        return  -IDS_FileReadError ;

    //  Now, map out the rest of the pieces of the structure.

    union {
            BYTE        *pbPFM; //  Base of the file for offsets!
            sPFMHeader  *pspfmh;
    };

    pbPFM = m_cbaPFM.GetData();

    //  Screen out evil files- part 1: is length sufficient?

    unsigned    uSize = sizeof (sPFMHeader) + sizeof (sPFMExtension) +
         sizeof (sPFMDriverInfo);
    if  ((unsigned) m_cbaPFM.GetSize() < uSize)
         return -IDS_PFMTooSmall ;

    //  YA Sanity check

    if  (pspfmh -> m_bLastChar < pspfmh -> m_bFirstChar)
         return -IDS_PFMCharError ;

    //  Width table, if there is one.

    WORD    *pwWidth = pspfmh -> m_wPixWidth ? NULL : (PWORD) (pspfmh + 1);
    uSize += !!pwWidth * sizeof (WORD) *
        (2 + pspfmh -> m_bLastChar - pspfmh -> m_bFirstChar);

    //  Screen out evil files- part 2: is length still sufficient?

    if  ((unsigned) m_cbaPFM.GetSize() < uSize)
         return -IDS_PFMTooSmall ;

    //  PFMExtension follows width table, otherwise the header

    sPFMExtension   *pspfme = pwWidth ? (sPFMExtension *)
        (pwWidth + 2 + pspfmh -> m_bLastChar - pspfmh -> m_bFirstChar) :
        (sPFMExtension *) (pspfmh + 1);

    //  Penultimate sanity check- is the driver info offset real?

    if  ((unsigned) m_cbaPFM.GetSize() <
         pspfme -> m_dwofDriverInfo + sizeof (sPFMDriverInfo))
        return  -IDS_BadPFMInfoOffset ;

    //  Text Metrics, DriverInfo and others are pointed at by PFM
    //  Extension.

    sPFMDriverInfo  *pspfmdi =
        (sPFMDriverInfo *) (pbPFM + pspfme -> m_dwofDriverInfo);

    //  Final sanity check- is the driver info version real?

    if  (pspfmdi -> m_wVersion > sPFMDriverInfo::CurrentVersion)
        return  -IDS_BadPFMInfoVersion ;

	// See if the original CTT ID needs to be converted to a new codepage
	// number.  If not, leave it alone.  In any case, set the font's GTT ID.

	//TRACE("GetTrans: UFM = %s   CTT ID = %d    GTT ID = %d\n", Name(), pspfmdi -> m_widCTT, ICttID2GttID((long) (short) pspfmdi -> m_widCTT)) ;
	//    m_widTranslation = (WORD) ICttID2GttID((long) (short) pspfmdi -> m_widCTT);				// rm ori
    m_lGlyphSetDataRCID = (WORD) ICttID2GttID((long) (short) pspfmdi -> m_widCTT);			// rm new
	
	
	if (!m_lGlyphSetDataRCID)  {	// Raid 135623

		switch (pspfmh ->m_bCharSet) {
			case  SHIFTJIS_CHARSET:
					m_lGlyphSetDataRCID = -17;
					break;
			case GB2312_CHARSET:
					m_lGlyphSetDataRCID = -16;
					break;
			case HANGEUL_CHARSET:
			case JOHAB_CHARSET:
					m_lGlyphSetDataRCID = -18;
					break;
			case CHINESEBIG5_CHARSET:
					m_lGlyphSetDataRCID = -10;
					break;
		} ;
	} ;
	// GTTs will be renumbered when the new, W2K RC file is written.  Because of
	// this, the GTT ID set above needs to be translated to the new number.  This
	// number corresponds to the GTT's position in GlyphTable.  NOTE: The ID is
	// not changed if it is <= 0.  (The IDs in the GlyphMaps will be changed in
	// CDriverResources::LoadFontData().)

	if (m_lGlyphSetDataRCID > 0 && m_lGlyphSetDataRCID == pspfmdi->m_widCTT) {
        for (unsigned uGTT = 0; uGTT < csoagtts.GetSize(); uGTT++)
            if (m_lGlyphSetDataRCID 
			 == ((LONG) ((CGlyphMap *) csoagtts[uGTT])->nGetRCID()))
                m_lGlyphSetDataRCID = uGTT + 1 ;
	} ;
	
	Changed();
    return  0 ;
}

/******************************************************************************

  CFontInfo::CalculateWidths()

  This member function is needed whenever a change is made to a variable pitch
  font's width table, or equally well, whenever an arbitrary table is picked up
  by a formerly fixed pitch font.  It calculates the width using the approved
  algorithm (average means average of 26 lower-case plus the space, unless they
  don't exist, in which case it is of all non-zero widths).

******************************************************************************/

void    CFontInfo::CalculateWidths()
{
//    m_wMaximumIncrement = 0;												//  Assume max width is 0, then prove otherwise.  Also collect the
																			//  raw information needed to correctly calculate the average width.

    unsigned    uPointsToAverage = 0, uOverallWidth = 0, uAverageWidth = 0,
				uZeroPoints = 0;

    for (unsigned u = 0; u < (unsigned) m_cpaGlyphs.GetSize(); u++)
		{
        WORD    wWidth = m_cwaWidth[u];;
		m_IFIMETRICS.fwdMaxCharInc = max(m_IFIMETRICS.fwdMaxCharInc, wWidth);					// rm new
//        m_wMaximumIncrement = max(m_wMaximumIncrement, wWidth);				// rm ori

        uOverallWidth += wWidth;
        if  (!wWidth)   uZeroPoints++;
//        if  (Glyph(u).CodePoint() == m_cwaSignificant[Break] ||				// rm ori
        if  (Glyph(u).CodePoint() == m_IFIMETRICS.wcBreakChar ||					// rm new
             (Glyph(u).CodePoint() >= (WORD) 'a' &&
             Glyph(u).CodePoint() <= (WORD) 'z'))
			{
            uAverageWidth += wWidth;
            uPointsToAverage++;
			}
		}

    //  If we averaged 27 points, then this is the correct width.  Otherwise,
    //  We average all of the widths.   cf the IFIMETRICS description in DDK


    m_IFIMETRICS.fwdAveCharWidth = (uPointsToAverage == 27) ?							// rm new

//    m_wAverageWidth = (uPointsToAverage == 27) ?										// rm ori
        (WORD) (0.5 + ((double) uAverageWidth) / 27.0) :
        (WORD) (0.5 + (((double) uOverallWidth) / (double) (u - uZeroPoints)));
}

/******************************************************************************

  CFontInfo::CFontInfo()

  This class constructor has a lot of work to do.  Not only does it have to
  initialize 5 zillion fields, it has to build the context menu list, and a few
  other glorious items of that ilk.

******************************************************************************/

CFontInfo::CFontInfo()
 {

	m_fEXTTEXTMETRIC = FALSE;		// rm new

    m_pcmdt = NULL;
    m_pcgmTranslation = NULL;
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
    m_cfn.SetExtension(_T(".UFM"));
	m_ulDefaultCodepage = 0 ;
	m_bRCIDChanged = 0 ;	// raid 0003

//    m_bCharacterSet = m_bPitchAndFamily = 0;										// rm   no longer needed

//    m_wMaximumIncrement = m_wfStyle = m_wWeight =  m_wAverageWidth  =				// rm ori
//        m_wHeight = m_widTranslation = 0;											// rm ori
    m_wHeight = 0;
	m_lGlyphSetDataRCID = 0;										// rm new

//    m_bLocation = m_bTechnology = m_bfGeneral = 0;								// rm ori
//    m_wType = m_fCaps = 0;														// rm   no longer needed
//    m_bScalable = FALSE;															// rm   no longer needed

//    m_wXResolution =  m_wYResolution = m_wPrivateData = 0;						// rm ori
//    m_sPreAdjustY =  m_sPostAdjustY =  m_sCenterAdjustment = 0;					// rm ori

//    m_wXRes = m_wYRes = m_wPrivateData = 0;										// rm   no longer needed
//    m_sYAdjust =  m_sYMoved = m_sCenterAdjustment = 0;							// rm   no longer needed

    m_wMaxScale = m_wMinScale = m_wScaleDevice = 0;
//    m_bfScaleOrientation = 0;

    m_cwaSpecial.InsertAt(0, 0, 1 + InternalLeading);    //  Initialize this array.

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_CopyItem);
    m_cwaMenuID.Add(ID_RenameItem);
    m_cwaMenuID.Add(ID_DeleteItem);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);

	// Allocate a CCodePageInformation class if needed.

	if (pccpi == NULL)
		pccpi = new CCodePageInformation ;

	// Assume the font is NOT being loaded from a workspace.

	m_bLoadedByWorkspace = false ;

	// Assume that a GTT/CP will be found for the UFM.

	m_bWSLoadButNoGTTCP = false ;

	// Another method is used for now.
	//
	// // Assume there is no width table offset and that the font not variable
	// // pitch.  These variables are both used to determine if this is a variable
	// // pitch font.
	//
	// m_loWidthTable = 0 ;
	// m_IFIMETRICS.jWinPitchAndFamily = 0 ;

	m_ctReloadWidthsTimeStamp = (time_t) 0 ;	// Widths never reloaded
}

/******************************************************************************

  CFontInfo::CFontInfo(const CFontInfo& cfiRef, WORD widCTT)

  This class constructor duplicates an existing font, but changes the CTT ID,
  and generates a new name and file name accordingly

******************************************************************************/

CFontInfo::CFontInfo(const CFontInfo& cfiRef, WORD widCTT) // r31
{

	m_fEXTTEXTMETRIC = FALSE;		// rm new

    m_pcmdt = cfiRef.m_pcmdt;
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
    m_pcgmTranslation = NULL;
    m_cfn.SetExtension(_T(".UFM"));
    CString csWork;

    //  Generate what will hopefully be a unique file name for the UFM
	
	ReTitle(cfiRef.Name()) ;
	m_cfn.UniqueName(true, true, cfiRef.m_cfn.Path()) ;
    //m_cfn.Rename(cfiRef.m_cfn.Path() + cfiRef.Name() + csWork);

    // Generate a new display name for the UFM using the CTT number

	csWork.Format(_T("(CTT %d)"), (long)(short)widCTT); // r 31
    m_csSource = cfiRef.m_csSource;
    Rename(cfiRef.Name() + csWork);

//    m_bCharacterSet = m_bPitchAndFamily = 0;										// rm   no longer needed

//    m_wMaximumIncrement = m_wfStyle = m_wWeight =  m_wAverageWidth =				// rm ori
        m_wHeight = 0;

//    m_bLocation = m_bTechnology = m_bfGeneral = 0;								// rm ori
//    m_wType = m_fCaps = 0;														// rm no longer needed
//    m_bScalable = FALSE;															// rm   no longer needed

//    m_wXResolution =  m_wYResolution = m_wPrivateData = 0;						// rm ori
//    m_sPreAdjustY =  m_sPostAdjustY =  m_sCenterAdjustment = 0;					// rm ori

//    m_wXRes = m_wYRes = m_wPrivateData = 0;										// rm   no longer needed
//    m_sYAdjust =  m_sYMoved = m_sCenterAdjustment = 0;							// rm   no longer needed

    m_wMaxScale = m_wMinScale = m_wScaleDevice = 0;
//    m_bfScaleOrientation = 0;

    m_cwaSpecial.InsertAt(0, 0, 1 + InternalLeading);    //  Initialize this array.

//    m_widTranslation = widCTT;														// rm ori
	m_lGlyphSetDataRCID = widCTT;														// rm new
    //  Build the context menu control
    m_cwaMenuID.Copy(cfiRef.m_cwaMenuID);

	// Allocate a CCodePageInformation class if needed.

	if (pccpi == NULL)
		pccpi = new CCodePageInformation ;

	// Assume the font is NOT being loaded from a workspace.

	m_bLoadedByWorkspace = false ;

	// Assume that a GTT/CP will be found for the UFM.

	m_bWSLoadButNoGTTCP = false ;

	m_ctReloadWidthsTimeStamp = (time_t) 0 ;	// Widths never reloaded
}

CFontInfo::~CFontInfo()
{
    if  (m_pcfdBold)    delete  m_pcfdBold;
    if  (m_pcfdItalic)  delete  m_pcfdItalic;
    if  (m_pcfdBoth)    delete  m_pcfdBoth;
}

/******************************************************************************

  CFontInfo::GTTDescription

  This returns a CString naming the GTT associated with this font.  It will
  come from the workspace if the font is a resource, or the string table, if it
  is predefined.

******************************************************************************/

CString CFontInfo::GTTDescription() const {
    if  (m_pcgmTranslation)
        return  m_pcgmTranslation -> Name();

    CString csName;


//  if  ((short) m_widTranslation <= 0)											// rm ori
    if  ((short) m_lGlyphSetDataRCID <= 0)	// r31  re visit					// rm new
//      csName.LoadString(IDS_DefaultPage + (short) m_widTranslation);			// rm ori
        csName.LoadString(IDS_DefaultPage + (short) m_lGlyphSetDataRCID);		// rm new

    if  (!csName.GetLength())
//      csName.Format(IDS_ResourceID, (short) m_widTranslation);				// rm ori
        csName.Format(IDS_ResourceID, (short) m_lGlyphSetDataRCID);				// rm new

    return  csName;
}

/******************************************************************************

  CFontInfo::InterceptItalic

  This calculates where a line drawn at the italic slant angle would intercept
  a rectangle the height of the ascender, and twice the maximum width of the
  font.  It is used to help draw the image of this line in the font editor.

******************************************************************************/
/*
void    CFontInfo::InterceptItalic(CPoint& cpt) const {
    if  (!m _cwaSpecial[ItalicAngle]) {  //  Nothing
        cpt.x = 5;
        cpt.y = 0;
        return;
    }

    //  First, assume we will hit the top- it's almost always true.

    cpt.x = 5 + (long) (0.5 + tan(((double) m _cwaSpecial[ItalicAngle]) /
        gdConvertRadToDegree) * ((double) m_IFIMETRICS.fwdWinAscender);							// rm new
//        gdConvertRadToDegree) * ((double) m _cwaSpecial[Baseline]));							rm ori

    if  (cpt.x <= -5 + 2 * m_wMaximumIncrement) {
        cpt.y = 0;
        return;
    }

    //  OK, assume the opposite

    cpt.y = (long) (0.5 + tan(((double) (900 - m _cwaSpecial[ItalicAngle])) /
        gdConvertRadToDegree) * ((double) (-10 + 2 * m_wMaximumIncrement)));
    cpt.x = -5 + 2 * m_wMaximumIncrement;
}
*/

/******************************************************************************

  CFontInfo::CompareWidths

  This compares the character widths for two indices, and returns, Less, More,
  or Equal, as need be.  It is not const, because Glyph() is not, and I've
  already got a bazillion member functions.

******************************************************************************/

unsigned    CFontInfo::CompareWidths(unsigned u1, unsigned u2) {

    _ASSERT(IsVariableWidth() && u1 < (unsigned) m_cpaGlyphs.GetSize() &&
        u2 < (unsigned) m_cpaGlyphs.GetSize());

    return  (m_cwaWidth[u1] < m_cwaWidth[u2]) ? Less :
        (m_cwaWidth[u1] > m_cwaWidth[u2]) ? More : Equal;
}

/******************************************************************************

  CFontInfo::MapKerning

  This maps out the available code points, and the kern pairs in both
  directions, into a CWordArray and a pair of CSafeMapWordToObs (where the
  underlying CObjects are CMapWordToDWords), respectively.  This allows the
  Add Kerning Pair dialog to screen out already defined pairs, and invalid code
  points.

******************************************************************************/

void    CFontInfo::MapKerning(CSafeMapWordToOb& csmw2o1,
                              CSafeMapWordToOb& csmw2o2,
                              CWordArray& cwaPoints) {

    //  If this isn't variable width, then we'll need to suck up some glyph
    //  data, temporarily.

    BOOL    bDispose = !IsVariableWidth();

    if  (bDispose)
        m_pcgmTranslation -> Collect(m_cpaGlyphs);

	unsigned rm =  m_pcgmTranslation->Glyphs();			// rm

    for (unsigned u = 0; u < m_pcgmTranslation -> Glyphs(); u++)
        if  (!DBCSFont() || Glyph(u).CodePoint() < 0x80)
            cwaPoints.Add(Glyph(u).CodePoint());
        else
            break;

    if  (bDispose)
        m_cpaGlyphs.RemoveAll();

    for (u = 0; u < m_csoaKern.GetSize(); u++) {
        CKern&  ck = *(CKern *) m_csoaKern[u];

        union {
            CObject         *pco;
            CMapWordToDWord *pcmw2d;
        };

        //  Map first word to second

        if  (csmw2o1.Lookup(ck.First(), pco)) {
            _ASSERT(!pcmw2d -> operator[](ck.Second()));
            pcmw2d -> operator[](ck.Second()) = (DWORD) ck.Amount();
        }
        else {
            CMapWordToDWord *pcmw2d = new CMapWordToDWord;
            pcmw2d -> operator[](ck.Second()) = (DWORD) ck.Amount();
            csmw2o1[ck.First()] = pcmw2d;
        }

        //  Now the other direction

        if  (csmw2o2.Lookup(ck.Second(), pco)) {
            _ASSERT(!pcmw2d -> operator[](ck.First()));
            pcmw2d -> operator[](ck.First()) = (DWORD) ck.Amount();
        }
        else {
            CMapWordToDWord *pcmw2d = new CMapWordToDWord;
            pcmw2d -> operator[](ck.First()) = (DWORD) ck.Amount();
            csmw2o2[ck.Second()] = pcmw2d;
        }
    }
}

/******************************************************************************

  CFontInfo::CompareKernAmount

    This is an editor sort helper- it tells how two kern amounts compare by
    index.

******************************************************************************/

unsigned    CFontInfo::CompareKernAmount(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.Amount() < ck2.Amount()) ? Less :
    (ck1.Amount() > ck2.Amount()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::CompareKernFirst

    This is an editor sort helper- it tells how two kern first characters
    compare by index.

******************************************************************************/

unsigned    CFontInfo::CompareKernFirst(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.First() < ck2.First()) ? Less :
    (ck1.First() > ck2.First()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::CompareKernSecond

    This is an editor sort helper- it tells how two kern second characters
    compare by index.

******************************************************************************/

unsigned    CFontInfo::CompareKernSecond(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.Second() < ck2.Second()) ? Less :
    (ck1.Second() > ck2.Second()) ? More : Equal;
}


/******************************************************************************
		
	CFontInfo::GetKernFirst

    Return the kerning pairs' first character.

******************************************************************************/

WCHAR CFontInfo::GetKernFirst(unsigned u) const
{
    CKern   &ck = *(CKern *) m_csoaKern[u] ;

    return (ck.First()) ;
}


/******************************************************************************

	CFontInfo::GetKernSecond

    Return the kerning pairs' second character.

******************************************************************************/

WCHAR CFontInfo::GetKernSecond(unsigned u) const
{
    CKern   &ck = *(CKern *) m_csoaKern[u] ;
    return (ck.Second()) ;
}


/******************************************************************************

	CFontInfo::GetKernAmount

    Return the kerning pairs' kerning amount.

******************************************************************************/

short CFontInfo::GetKernAmount(unsigned u) const
{
    CKern   &ck = *(CKern *) m_csoaKern[u] ;
    return (ck.Amount()) ;
}


/******************************************************************************

  CFontInfo::SetSourceName

  This takes and stores the source file name so we can load and convert later.
  This takes and stores the name for the project node for this UFM.  It begins
  with the PFM file name.  If the extension is PFM, it is used.  Otherwise, the
  dot in the file name is changed to an underscore and the whole thing is used.

******************************************************************************/

void    CFontInfo::SetSourceName(LPCTSTR lpstrNew) {

    m_csSource = lpstrNew;

    m_csName = m_csSource.Mid(m_csSource.ReverseFind(_T('\\')) + 1);

    if  (m_csName.Find(_T('.')) >= 0)
        if  (m_csName.Right(4).CompareNoCase(_T(".PFM"))) {
            m_csName.SetAt(m_csName.Find(_T('.')), _T('_'));
            CProjectNode::Rename(m_csName);
        }
        else
            CProjectNode::Rename(m_csName.Left(m_csName.Find(_T('.'))));
    else
        CProjectNode::Rename(m_csName);
}


/******************************************************************************

  CFontInfo::SetFileName

  This sets the new file name.  It is done differently than in SetSourceName()
  because the base file name must not be more than 8 characters long.  (The
  extra info is left in the node name by SetSourceName() because it is useful
  there and it has no length limit.)

******************************************************************************/

BOOL CFontInfo::SetFileName(LPCTSTR lpstrNew)
{
	CString		csnew ;			// CString version of input parameter

	csnew = lpstrNew ;

	// If the input filespec contains an extension, remove it and pass the
	// resulting string to the file node's rename routine.  Otherwise, just
	// pass the original string to the rename routine.
	//
	// This check is complicated by the fact that one of the path components
	// might have a dot in it too.  We need to check for the last dot and make
	// sure it comes before a path separator.

    if  (csnew.ReverseFind(_T('.')) > csnew.ReverseFind(_T('\\')))
		return m_cfn.Rename(csnew.Left(csnew.ReverseFind(_T('.')))) ;
	else
		return m_cfn.Rename(csnew) ;
}


/******************************************************************************

  CFontInfo::Generate

  This member generates the font information in one of the supported forms.  I
  determine the desired form from the file's extension.

******************************************************************************/

BOOL ConvertPFMToIFI(LPCTSTR lpstrPFM, LPCTSTR lpstrIFI, LPCTSTR lpstrUniq);

extern "C" {

    BOOL    BConvertPFM(LPBYTE lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT,
                        PWSTR pwstrUnique, LPCTSTR lpstrUFM, int iGTTID);
    DWORD   DwGetCodePageFromGTTID(LONG lPredefinedCTTId);
}

int    CFontInfo::Generate(CString csPath)
{
    CString csExtension = csPath.Right(4);
    csExtension.MakeUpper();
    
    if  (csExtension == _T(".IFI"))
        return  ConvertPFMToIFI(m_csSource, csPath, m_csUnique);
    if  (csExtension == _T(".UFM")) {
        if  (!m_pcgmTranslation) {
            //CString csWork;

//            csWork.Format(IDS_BadCTTID, (LPCTSTR) m_csSource, (long) (short) m_widTranslation);			// rm ori
            //csWork.Format(IDS_BadCTTID, (LPCTSTR) m_csSource, (long) (short) m_lGlyphSetDataRCID);			// rm new


            //AfxMessageBox(csWork);
            return  IDS_BadCTTID;
        }

        //  Determine whether a GTT file or code page is to be used
//        DWORD   dwCodePage = DwGetCodePageFromCTTID((LONG) - (short) m_widTranslation);							// rm ori
        DWORD   dwCodePage = DwGetCodePageFromGTTID((LONG) - (short) m_lGlyphSetDataRCID);	 // r 31						// rm new

        //  Load the GTT file, if we need to.  This handles predefined, as well

        CByteArray  cbaMap;

        m_pcgmTranslation -> Load(cbaMap);

        if  (!cbaMap.GetSize())
            return  IDS_UFMGenError ;

        //  Load the PFM file into memory (should already be there)

        if  (!MapPFM())
            return  IDS_UFMGenError ;  //  Couldn't load PFM- impossible at this point!

        //  Convert the unique name string to Unicode

        CByteArray  cbaIn;
        CWordArray  cwaOut;

        cbaIn.SetSize(1 + m_csUnique.GetLength());
        lstrcpy((LPSTR) cbaIn.GetData(), (LPCTSTR) m_csUnique);
        pccpi->Convert(cbaIn, cwaOut, GetACP());

        //  DO IT!

		//TRACE("%s UFM has CP = %d and RCID = %d\n", Name(), dwCodePage, m_lGlyphSetDataRCID) ;

		// If both the code page and GTT ID are 0, set the code page to 1252.

		if (dwCodePage == 0 && m_lGlyphSetDataRCID == 0)
			dwCodePage = 1252 ;

		//TRACE("*** GTT Pointer = %d\n", cbaMap.GetData()) ;
		ASSERT(cbaMap.GetData()) ;
        BOOL brc = BConvertPFM(m_cbaPFM.GetData(), dwCodePage, cbaMap.GetData(),
//            cwaOut.GetData(), FileName(), (short) m_widTranslation);										// rm ori
            cwaOut.GetData(), FileName(), (short) m_lGlyphSetDataRCID);	//r 31 short -> INT									// rm new
		return ((brc) ? 0 : IDS_UFMGenError) ;

//        return  BConvertPFM(m_cbaPFM.GetData(), dwCodePage, cbaMap.GetData(),
////            cwaOut.GetData(), FileName(), (short) m_widTranslation);										// rm ori
//            cwaOut.GetData(), FileName(), (short) m_lGlyphSetDataRCID);										// rm new
    }
    return  0 ;
}

/******************************************************************************

  CFontInfo::AddFamily

  This searches for the given name in the list of families, and adds it if it
  is not there.  It returns TRUE if it succeeded.

******************************************************************************/

BOOL    CFontInfo::AddFamily(LPCTSTR lpstrNew) {

    for (unsigned u = 0; u < Families(); u++)
        if  (!Family(u).CompareNoCase(lpstrNew))
            break;

    if  (u < Families())
        return  FALSE;  //  Already have it!

    try {
        m_csaFamily.Add(lpstrNew);
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    Changed();
    return  TRUE;
}

/******************************************************************************

  CFontInfo::RemoveFamily

  This function removes the given family name from the list of aliases.  This
  code is more robust than it needs to be- it'll remove duplicates, even though
  the add code won't allow them to be added.  No telling what the input data
  looks like, though, is there?

******************************************************************************/

void    CFontInfo::RemoveFamily(LPCTSTR lpstrDead) {

    for (unsigned u = 0; u < Families(); u ++)
        if  (!Family(u).CompareNoCase(lpstrDead)) {
            m_csaFamily.RemoveAt(u--);  //  Decrement so we don't miss one
            Changed();
        }
}

/*****************************************************************************

  CFontInfo::ChangePitch

  We exploit the fact that the widths are maintained in the CGlyphMap
  (actually the CGlyphHandle) class.  All this method need do for a variable
  font flipping to fixed is to toss out the m_cpaGlyphs member's content.  To
  flip to variable, collect the handles, then check the first one's width- if
  it's non-zero, then a previous transition from variable to fixed is being
  undone, and we can recycle the old values, thus keeping any edits that may
  have been lost.  Otherwise, the trick code comes- the initial values get
  filled- what's tricky is that for a DBCS character set, only the SBCS values
  less than 0x80 can be variable.

******************************************************************************/

void    CFontInfo::ChangePitch(BOOL bFixed)
{

    if  (bFixed == !IsVariableWidth())
        return; //  Nothing to change!

    if  (bFixed)
		{
        m_cpaGlyphs.RemoveAll();    //  CPtrArray doesn't delete anything

        m_IFIMETRICS.fwdAveCharWidth = DBCSFont() ? (1 + m_IFIMETRICS.fwdMaxCharInc) >> 1 : m_IFIMETRICS.fwdMaxCharInc;		// rm new

//       m_wAverageWidth = DBCSFont() ? (1 + m_IFIMETRICS.fwdMaxCharInc) >> 1 : m_IFIMETRICS.fwdMaxCharInc;					// rm ori
//        m_wAverageWidth = DBCSFont() ? (1 + m_wMaximumIncrement) >> 1 : m_wMaximumIncrement;
        Changed();
        return;
		}

    if  (!m_pcgmTranslation)    return; //  Can't do this with no GTT available

    m_pcgmTranslation -> Collect(m_cpaGlyphs);
    if  (!m_cwaWidth.GetSize())
        m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize());
    Changed();  //  It sure has...

    if  (!m_cpaGlyphs.GetSize() || m_cwaWidth[0])
		{  //  Update the maximum and average width if this is not DBCS
        if  (!DBCSFont())
            CalculateWidths();
        return; //  We did all that needed to be done
		}

    if  (!DBCSFont()) {

        for (int i = 0; i < m_cpaGlyphs.GetSize(); i++)
            m_cwaWidth[i] = m_IFIMETRICS.fwdMaxCharInc;  //m_wMaximumIncrement;			// rm ori, rm new

        return;
    }

    for (int i = 0; i < m_cpaGlyphs.GetSize() && Glyph(i).CodePoint() < 0x80;)
            m_cwaWidth[i++] = m_IFIMETRICS.fwdAveCharWidth;					//m_wAverageWidth; 		// rm ori, rm new  //  In DBCS, this is always it
}

/*****************************************************************************

  CFontInfo::SetScalability

  This is called to turn scalability on or off.  All that really needs to be
  done is to establish values for the maximum and minimum scale, the font ->
  device units mapping members, and the lowercase ascender /descender, if this
  is the first time this information has changed.

******************************************************************************/

/*void    CFontInfo::SetScalability(BOOL bOn) {

    if  (IsScalable() == !!bOn)
        return; //  Nothing to change

    if  (!bOn) {
        m_bScalable = FALSE;
        Changed();
        return;
    }

    m_bScalable = TRUE;
    Changed();

    if  (m_wMaxScale && m_wMinScale && m_wMaxScale != m_wMinScale)
        return; //  We've already got data.

    m_wMaxScale = m_wMinScale = m_wScaleDevice = m_wHeight - m_InternalLeading
//        m_wHeight - m _cwaSpecial[InternalLeading];

    //  Flaky, but set the initial max and min to +- 1 point from nominal

    m_wMaxScale += m_wYResolution / 72;
    m_wMinScale -= m_wYResolution / 72;

    //  Finally, set the lowercase ascender and descender to simple defaults

    m_Lowerd = m_IFIMETRICS.fwdWinAscender - m_InternalLeading;
    m_Lowerp = m_wHeight - m_IFIMETRICS.fwdWinAscender;
}
*/


/*****************************************************************************

  CFontInfo::SetSpecial

  This adjusts anything that may need adjusting if a special metric is
  altered.

******************************************************************************/

void    CFontInfo::SetSpecial(unsigned ufMetric, short sSpecial)
{
    if  (m_cwaSpecial[ufMetric] == (WORD) sSpecial)  return; //  Nothing changed

    m_cwaSpecial[ufMetric] = (WORD) sSpecial;

    switch  (ufMetric)
		{
		case    InternalLeading:

			//  Adjust the scaling factors if need be
			if  (m_wScaleDevice > m_wHeight - sSpecial) m_wScaleDevice = m_wHeight - sSpecial;

			if  (m_wMinScale > m_wHeight - sSpecial)    m_wMinScale = m_wHeight - sSpecial;
		}

    Changed();
}



/*****************************************************************************

  CFontInfo::SetMaxWidth

  This is not as simple as it might seem.  If the font is variable, don't do
  it.  If it is not, then if it is DBCS, set the average width to 1/2 the new
  maximum.  Otherwise, set it also to the maximum.

******************************************************************************/

void    CFontInfo::SetMaxWidth(WORD wWidth)
{
    if  (IsVariableWidth()) return;

    if  (wWidth == m_IFIMETRICS.fwdMaxCharInc) return; //  Nothing to do!
//    if  (wWidth == m_wMaximumIncrement) return; //  Nothing to do!

	m_IFIMETRICS.fwdMaxCharInc = wWidth;										// rm new

//    m_wMaximumIncrement = wWidth;												// rm ori

	
    m_IFIMETRICS.fwdAveCharWidth = DBCSFont() ? (wWidth + 1) >> 1 : wWidth;		// rm new

//    m_wAverageWidth = DBCSFont() ? (wWidth + 1) >> 1 : wWidth;				// rm old

    Changed();
}

/*****************************************************************************

  CFontInfo::SetHeight

  This member checks to see if the new height is non-zero and new.  If so, it
  uses it for the new height, then adjusts all of the possibly affected
  special metrics so they continue to meet the constraints.

******************************************************************************/

BOOL    CFontInfo::SetHeight(WORD wHeight)
{
    if  (!wHeight || wHeight == m_wHeight) return  FALSE;

    m_wHeight = wHeight;


//    short   sBaseline = (short) (min(wHeight, m _cwaSpecial[Baseline]));		// rm ori
    short   sBaseline = (short) (min(wHeight, m_IFIMETRICS.fwdWinAscender));

    for (unsigned u = 0; u <= InternalLeading; u++)
		{
        switch  (u)
			{
			case    InterlineGap:
					if  (m_cwaSpecial[u] > 2 * wHeight)  m_cwaSpecial[u] = 2 * wHeight;
					continue;

			case    UnderOffset:
			case    SubMoveY:
			case    Lowerd:

					if  ((short) m_cwaSpecial[u] < sBaseline - wHeight)
						m_cwaSpecial[u] = sBaseline - wHeight;
					continue;

			case    UnderSize:

					if  (m_cwaSpecial[u] > wHeight - (unsigned) sBaseline)
						 m_cwaSpecial[u] = wHeight = (unsigned) sBaseline;

					if  (!m_cwaSpecial[u]) m_cwaSpecial[u] = 1;
					continue;

			case    SuperSizeX:
			case    SubSizeX:
			case    SuperMoveX:
			case    SubMoveX:
			case    ItalicAngle:
					continue;   //  These aren't affected

			default:
					if  (m_cwaSpecial[u] > (unsigned) sBaseline)
					m_cwaSpecial[u] = sBaseline;
			}
		}

    //  Adjust the scaling factors if need be
    if  (m_wScaleDevice > m_wHeight - m_InternalLeading)  //m _cwaSpecial[InternalLeading])
        m_wScaleDevice = m_wHeight - m_InternalLeading;  //m _cwaSpecial[InternalLeading];
    if  (m_wMinScale > m_wHeight - m_InternalLeading)		//m _cwaSpecial[InternalLeading])
        m_wMinScale = m_wHeight - m_InternalLeading;		//m _cwaSpecial[InternalLeading];

    Changed();

    return  TRUE;
}

/*****************************************************************************

  CFontInfo::SetCharacterSet

  This one is a bit tricky- the new character set must be compatible with the
  GTT file associated with this font.  So we need to check it before we pass
  on it.

  ASSUMPTIONS:
  (1)  Things are bulletproof enough that the existing character set will
  already pass this test.

******************************************************************************/

BOOL    CFontInfo::SetCharacterSet(BYTE bNew) {
    unsigned u;

    switch  (bNew) {
    case    SHIFTJIS_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 932)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    HANGEUL_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 949)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    CHINESEBIG5_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 950)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    GB2312_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 936)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    default:
        //  Don't accept any DBCS codepages
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            switch  (m_pcgmTranslation -> PageID(u)) {
            case    932:
            case    936:
            case    949:
            case    950:
            case    1361:   //  Johab- but it isn't in the converter!
                return  FALSE;
        }
    }

//    if  (m_bCharacterSet != bNew) {											// rm - need to replace this functionality
//        m_bCharacterSet = bNew;
        Changed();
//    }

    return  TRUE;
}

/******************************************************************************

  CFontInfo::SetSignificant

  This member is called to change the value of one of the significant code
  points (break character or default) encoded in the font.  Doing this
  correctly means getting the ANSI and UNICODE versions of the code point, and
  discarding any out-of-range values.

  This function returns an encoded value indicating success or cause of
  failure.

******************************************************************************/

WORD    CFontInfo::SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode)
{
//    _ASSERT(wItem > Last && wItem <= Break);										// rm no longer needed

    if  (!bUnicode && wChar > 255) return  DoubleByte;

    CWaitCursor cwc;    //  Unfortunately, if not Unicode, this is slow

    CPtrArray               cpaGlyphs;
    CWordArray              cwa;
    CByteArray              cba;
    CDWordArray             cdaPage;

    m_pcgmTranslation -> Collect(cpaGlyphs);
    m_pcgmTranslation -> CodePages(cdaPage);

    for (int i = 0; i < cpaGlyphs.GetSize(); i++)
		{
        CGlyphHandle& cgh = *(CGlyphHandle *) cpaGlyphs[i];

        if  (bUnicode)
			{
            if  (cgh.CodePoint() == wChar)
				{
                cwa.Add(wChar);
                pccpi->Convert(cba, cwa, cdaPage[cgh.CodePage()]);
                break;
				}
			}
        else
			{
            if  (i)
                cwa.SetAt(0, cgh.CodePoint());
            else
                cwa.Add(cgh.CodePoint());

            pccpi->Convert(cba, cwa, cdaPage[cgh.CodePage()]);

            if  (cba.GetSize() == 1 && cba[0] == (BYTE) wChar)
                break;
            cba.RemoveAll();    //  So we can try again
			}
		}

    if  (i == cpaGlyphs.GetSize())	return  InvalidChar;
    if  (cba.GetSize() != 1)		return  DoubleByte;

    //  OK, we passed all of the hurdles

//	if (m_cwaSignificant[wItem] == cwa[0])  return  OK; //  Nothing changed!!!!			// rm ori - no longer needed, incorporated below


	if (wItem == Default)
		{
		if (m_IFIMETRICS.wcDefaultChar == cwa[0])  return  OK;						//  Nothing changed!!!!
		m_IFIMETRICS.wcDefaultChar = cwa[0];
		m_IFIMETRICS.chDefaultChar = cba[0];
		}
	else
		{
		m_IFIMETRICS.wcBreakChar = cwa[0];
		m_IFIMETRICS.chBreakChar = cba[0];
		}

//    m_cwaSignificant[wItem] = cwa[0];													// rm ori no longer needed
//    m_cbaSignificant[wItem] = cba[0];													// rm ori no longer needed
    Changed();
    return  OK;
}

/******************************************************************************

  CFontInfo::SetScaleLimit

  This member receives a proposed new maximum or minimum font size in device
  units.  First, it is compared to the existing size, for a quick exit.  Then
  we check to see that the ordering of the limits and the nominal size is
  preserved.  If it is not, we describe the problem and leave.  Otherwise, we
  update the value, and note that the font information has changed.

******************************************************************************/

WORD    CFontInfo::SetScaleLimit(BOOL bMax, WORD wNew) {

    if  (wNew == (bMax ? m_wMaxScale : m_wMinScale))
        return  ScaleOK;

    if  (bMax ? wNew <= m_wMinScale : wNew >= m_wMaxScale)
        return  Reversed;

    if  (bMax ? wNew < m_wScaleDevice : wNew > m_wScaleDevice)
        return  NotWindowed;

    if  (bMax)
        m_wMaxScale = wNew;
    else
        m_wMinScale = wNew;

    Changed();
    return  ScaleOK;
}

/******************************************************************************

  CFontInfo::SetDeviceEmHeight

  This member sets the units used for determing the conversion from font units
  (in which all metrics are given) to device units.  The checking is similar to
  that above, except here, we need to make sure that the font units are always
  of equal or greater resolution than the device units.

******************************************************************************/

WORD    CFontInfo::SetDeviceEmHeight(WORD wNew)
{

    if  (wNew == m_wScaleDevice)
        return  ScaleOK;

    if  (wNew > m_wHeight - m_InternalLeading)				//m _cwaSpecial[InternalLeading])
        return  Reversed;

    if  (wNew < m_wMinScale || wNew > m_wMaxScale)
        return  NotWindowed;

    m_wScaleDevice = wNew;

    Changed();
    return  ScaleOK;
}


/******************************************************************************

  CFontInfo::Load

  This member function loads the UFM file, finally initializing all of the
  tons of individual values we're trying to pretend we know how to manage
  here.

  IA64 : 1. conversion change loXXX in UNIFI_HDR to 8 byte aligned
         2. this part also changed accordingly
		 3. what if we load 32 bit UFM(not conversion in new source) in IA64?
			->1. Need to new converstion tool from UFM32 to UFM64
			->2. this tool Can't be embedded in MDT because this take some time 
					(loading ->checking -> storing after that structure on every loXXX)


******************************************************************************/

BOOL    CFontInfo::Load(bool bloadedbyworkspace /*= false*/)
{
	// Save the load location flag.

	m_bLoadedByWorkspace = bloadedbyworkspace ;

	// Prepare to open the file.

    CFile   cfUFM;
	char pszFullName[128] = "";
	strcpy (pszFullName, (const char *) m_cfn.FullName());

	// Open the UFM file

    if  (!cfUFM.Open(m_cfn.FullName(), CFile::modeRead | CFile::shareDenyWrite)) {
		CString csMessage;
		csMessage.Format(IDS_LoadFailure, (LPCTSTR) m_cfn.FullName());
		AfxMessageBox(csMessage);
		return  FALSE;
	}

    // Get the length of the UFM file.  If it is too short to be correctly
	// formed, complain and return FALSE; ie, load failure.

	int i = cfUFM.GetLength() ;
	if (i < sizeof(UNIFM_HDR)) {
		CString csmsg ;
		csmsg.Format(IDS_UFMTooSmallError, m_cfn.NameExt()) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return FALSE ;
	} ;
	
	CByteArray  cbaUFM;			// Loaded with file's contents

	//  Try to load the file- proclaim defeat on any exception.

    try	{																			
        cbaUFM.SetSize(i);
        cfUFM.Read(cbaUFM.GetData(), (unsigned)cbaUFM.GetSize());
	}
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, (LPCTSTR) m_cfn.FullName());
        AfxMessageBox(csMessage);
        return  FALSE;
	}

//------------------------------------------------------------------------------------------------------------------------------------------
    PUNIFM_HDR  pufmh = (PUNIFM_HDR) cbaUFM.GetData();								//  UNIFM_HDR

	m_ulDefaultCodepage = (WORD) pufmh -> ulDefaultCodepage;		
    m_lGlyphSetDataRCID = (WORD) pufmh -> lGlyphSetDataRCID;							//  Store the GTT ID

//------------------------------------------------------------------------------------------------------------------------------------------
	union {		//raid 154639	
		  PBYTE       pbudi;
		  PUNIDRVINFO pudi;
		  };    
	pudi = (PUNIDRVINFO) (cbaUFM.GetData() + pufmh->loUnidrvInfo);		//  UNIDRVINFO
	if (!pudi -> dwSize || !pudi -> wXRes || !pudi -> wYRes)  //raid 154639	
		pbudi +=4;   // normally converion from 32 bit OS.
	memcpy((void *) &m_UNIDRVINFO, pudi, sizeof(UNIDRVINFO));							//	Bulk copy everything

    if  (pudi -> SelectFont.loOffset)    										//   Fill in the two invocation strings - why it is
        m_ciSelect.Init((PBYTE) pudi + pudi->SelectFont.loOffset,					//     the offset is NULL and the count is garbage
            pudi->SelectFont.dwCount);												//     when there is none is beyond me, but so be it.

    if  (pudi->UnSelectFont.loOffset)
        m_ciDeselect.Init((PBYTE) pudi + pudi->UnSelectFont.loOffset,
            pudi->UnSelectFont.dwCount);
 //------------------------------------------------------------------------------------------------------------------------------------------
																					//  IFIMETRICS																		
	union {
		  PBYTE       pbIFI;
		  PIFIMETRICS pIFI;
		  };

    pbIFI = cbaUFM.GetData() + pufmh->loIFIMetrics; 								//  Assign byte pointer to file IFIMETRICS data
	if (!pIFI -> cjThis || !pIFI ->chLastChar)  //raid 154639	
		pbIFI +=4;
	
	memcpy((void *) &m_IFIMETRICS, pIFI, sizeof(IFIMETRICS) );							//	Bulk copy everything

	if (     !(m_IFIMETRICS.fsSelection & FM_SEL_REGULAR)								//  If font isn't defined as regular, or bold,
		 &&  !(m_IFIMETRICS.fsSelection & FM_SEL_BOLD)  )								//   then just set it to regular.
		m_IFIMETRICS.fsSelection |= FM_SEL_REGULAR;

																						//-----------------------------------------------------
    m_csUnique = (PWSTR) (pbIFI + pIFI->dpwszUniqueName);								//  dpwszUniqueName
    m_csStyle  = (PWSTR) (pbIFI + pIFI->dpwszStyleName);								//  dpwszStyleName
    m_csFace   = (PWSTR) (pbIFI + pIFI->dpwszFaceName);									//  dpwszFaceName
																						//-----------------------------------------------------									
    m_csaFamily.RemoveAll();															//  Just in case it isn't clean

    PWSTR   pwstrFamily = (PWSTR) (pbIFI + pIFI->dpwszFamilyName);						//  dpwszFamilyName
    CString csWork(pwstrFamily);														//  Let CString handle the Unicode conversions for us,	
    m_csaFamily.Add(csWork);
    pwstrFamily += 1 + wcslen(pwstrFamily);

    if  (pIFI->flInfo & FM_INFO_FAMILY_EQUIV)
        while   (*pwstrFamily)
			{
            csWork = pwstrFamily;
            m_csaFamily.Add(csWork);
            pwstrFamily += 1 + wcslen(pwstrFamily);
			}
																						//-----------------------------------------------------
	m_ItalicAngle	  = (WORD) (gdConvertRadToDegree *									//  m_ItalicAngle
					    atan2((double) pIFI->ptlCaret.x, (double) pIFI->ptlCaret.y));

    m_wHeight		  = m_IFIMETRICS.fwdWinAscender	 + m_IFIMETRICS.fwdWinDescender;	//  m_wHeight		// rm new
	m_InternalLeading = m_wHeight - m_IFIMETRICS.fwdUnitsPerEm;							//  fwdUnitsPerEm	// rm new

 //------------------------------------------------------------------------------------------------------------------------------------------
	
	// Try to find and load the GTT referenced by this UFM iff this UFM is being
	// loaded directly.

	if (!m_bLoadedByWorkspace)
		if (!FindAndLoadGTT()) {
			CString csmsg;
			csmsg.Format(IDS_NoGTTForUFMFatalError, m_cfn.NameExt()) ;
			AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
			return FALSE ;
		} ;

	// DEAD_BUG:	This is a good place to add code to find and associate the UFM
	//			with its GTT so that the UFM doesn't have to be loaded twice
	//			when the UFM is loaded as part of a workspace load.
    //
	//  best solution is just skipping EXTTEXTMETRIC, but almost no influence.
 //------------------------------------------------------------------------------------------------------------------------------------------
	if ( !m_pcgmTranslation && m_bLoadedByWorkspace )
		return FALSE;
		//  EXTTEXTMETRIC

	for (i = 0; i < 26; i++)														// Preload zeroes into the m_EXTTEXTMETRIC structure.
		*(SHORT *)((SHORT *)&m_EXTTEXTMETRIC + i) = 0;

//raid 154639	
	union {
		  PBYTE           pbetm;
		  PEXTTEXTMETRIC  petm;
		  };

    petm = (PEXTTEXTMETRIC) (pufmh->loExtTextMetric ?					//  Get pointer - if EXTTEXTMETRIC data exists
                           (cbaUFM.GetData() + pufmh->loExtTextMetric) : NULL);
    if  (petm)
		{
		if (!petm -> emSize || !petm -> emPointSize)
			pbetm += 4;

		m_fSave_EXT = TRUE;

		m_fEXTTEXTMETRIC = TRUE;

		memcpy((void *) &m_EXTTEXTMETRIC, petm, sizeof(EXTTEXTMETRIC) );				// Bulk copy everything

        m_wMinScale   = m_EXTTEXTMETRIC.emMinScale;
        m_wMaxScale   = m_EXTTEXTMETRIC.emMaxScale;
        m_Lowerd	  = m_EXTTEXTMETRIC.emLowerCaseAscent;
        m_Lowerp	  = m_EXTTEXTMETRIC.emLowerCaseDescent;
		m_ItalicAngle = m_EXTTEXTMETRIC.emSlant;
//        m_bfScaleOrientation = (BYTE) m_EXTTEXTMETRIC.emOrientation;
        m_wScaleDevice = m_EXTTEXTMETRIC.emMasterHeight;
		}

//------------------------------------------------------------------------------------------------------------------------------------------

	if  (pIFI->dpFontSim)																//  FONTSIM, if any.
    	{
        union {
              PBYTE   pbfs;
              FONTSIM *pfs;
			  };

        pbfs = pbIFI + pIFI -> dpFontSim;

		if (m_pcfdBold) 	delete  m_pcfdBold;														//  If we're reloading, clean these up!			
        if (m_pcfdItalic)	delete  m_pcfdItalic;
        if (m_pcfdBoth)		delete  m_pcfdBoth;

        if (pfs->dpBold)        m_pcfdBold   = new CFontDifference(pbfs + pfs->dpBold, this);		//  Bold simulation
        if (pfs->dpItalic)	    m_pcfdItalic = new CFontDifference(pbfs + pfs->dpItalic, this);		//  Italic Simulation
        if (pfs->dpBoldItalic)	m_pcfdBoth   = new CFontDifference(pbfs + pfs->dpBoldItalic, this);	//  Bold Italic Simulation
		}

//------------------------------------------------------------------------------------------------------------------------------------------
																						
    //if  (m_pcgmTranslation && (m_loWidthTable = pufmh -> loWidthTable))					//  WIDTH TABLE, but only if there is an associated GTT.
    
	if  (m_pcgmTranslation && pufmh->loWidthTable ) //pufmh->loWidthTable)											//  WIDTH TABLE, but only if there is an associated GTT.
		{
        union {
              PBYTE       pbwt;
              PWIDTHTABLE pwt;
			  };

        pbwt = cbaUFM.GetData() + pufmh -> loWidthTable;
// dwSize has problem ; there are case: dwAdd_ in pfm2ifi has not 4 byte, so dwSize has number in some case
// data before wGlyphCount is dwRunNum: impossible to beyond ff ff 00 00 (65536), as long as dwAdd is 4,2 not 1 & dwRun > 256 		
// nicer solution is required : BUG_BUG.
		if( !pwt ->dwSize || !pwt ->WidthRun ->wGlyphCount)  
			pbwt += 4;

        m_pcgmTranslation -> Collect(m_cpaGlyphs);											//  Collect all the handles
				m_pcgmTranslation -> Collect(m_cpaOldGlyphs);  //244123	
		//244123	// when delete glyph, memory is occupied with dddd, so we have to save original data in here
		m_cwaOldGlyphs.SetSize(m_cpaOldGlyphs.GetSize()) ;
		for (  i = 0 ; i < m_cpaOldGlyphs.GetSize() ; i ++ ) { 
			CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaOldGlyphs[i];
			m_cwaOldGlyphs.SetAt(i,cghThis.CodePoint() ) ;
		}

        m_cwaWidth.RemoveAll();
        if (m_cpaGlyphs.GetSize() > 0)
			m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize());


		unsigned uWidth = (unsigned)m_cwaWidth.GetSize();												// rm fix VC compiler problem?
		unsigned uWidthIdx ;

        for (unsigned u = 0; u < pwt->dwRunNum; u++)
			{
            PWORD   pwWidth = (PWORD) (pbwt + pwt->WidthRun[u].loCharWidthOffset);

            for (unsigned   uGlyph = 0; uGlyph < pwt->WidthRun[u].wGlyphCount; uGlyph++)
				{
				// For whatever reason, there are times when the index value is
				// < 0 or > uWidth.  An AV would occur if m_cwaWidth were allowed
				// to be indexed by such a value.  Just keep this from happening
				// for now.  A better fix is needed.  BUG_BUG : won't fix

				uWidthIdx = uGlyph + -1 + pwt->WidthRun[u].wStartGlyph ;					//  Glyph handles start at 1, not 0!
				if ((int) uWidthIdx < 0) {
					//AfxMessageBox("Negative width table index") ;
					//TRACE("***Negative width table index (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					continue ;
				} else if (uWidthIdx >= uWidth) {
					//AfxMessageBox("Width table index (%d) > table size") ;
					//TRACE("***Width table index (%d) > table size (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, uWidth, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					break ;												//  rm fix VC IDE compiler problem?
				} ;

                //m_cwaWidth[uGlyph + -1 + pwt->WidthRun[u].wStartGlyph] = *pwWidth++;		//  Glyph handles start at 1, not 0!
                m_cwaWidth[uWidthIdx] = *pwWidth++;											
				}
			}
		}

//------------------------------------------------------------------------------------------------------------------------------------------
    m_csoaKern.RemoveAll();																//  KERNING TABLE, if any
 
    if  (pufmh -> loKernPair)
		{
		union {
              PBYTE       pbkd;
              PKERNDATA   pkd;
			  };

        pkd = (PKERNDATA) (cbaUFM.GetData() + pufmh -> loKernPair);
		if (!pkd ->dwSize || !pkd->KernPair ->wcSecond || !pkd->KernPair ->wcFirst)
			pbkd += 4;

		unsigned rm = pkd->dwKernPairNum;													// rm - debugging
        for (unsigned u = 0; u < pkd -> dwKernPairNum; u++)
            m_csoaKern.Add(new CKern(pkd -> KernPair[u]));
		}
//------------------------------------------------------------------------------------------------------------------------------------------

    return  TRUE;																		//  Return triumphant to whoever deigned to need this service.
}


/*****************************************************************************

  CFontInfo::FindAndLoadGTT

  This function is called when a UFM is being loaded directly.  Its job is to
  find the associated GTT, load it, and set the UFM's pointer to this GTT.  If
  this fails, the user is told that no changes to this UFM can be saved if he
  decides to continue loading it.

  True is returned if a GTT was found and loaded.  Return false if the GTT
  wasn't loaded and the user doesn't want to continue to load the UFM.

******************************************************************************/

bool CFontInfo::FindAndLoadGTT()
{
	// Load a predefined GTT/codepage if that is what is referenced by the UFM.

	CGlyphMap* pcgm ;
	pcgm = CGlyphMap::Public((WORD)Translation(), (WORD) m_ulDefaultCodepage, 0,
							 GetFirst(), GetLast()) ;
    if (pcgm) {
        SetTranslation(pcgm) ;
		m_pcgmTranslation->NoteOwner(*m_pcdOwner) ;	// Is this right/necessary?
		m_bLoadedByWorkspace = true ;
		return true ;
	} ;

	// Looks like no easy way out.  Now I need to try to find and read the
	// corresponding RC file so that it can be read to find a filespec for this
	// UFM's GTT.  First, build a file spec for the RC file.  Assume it is in
	// the directory above the one containing this UFM.

	CString csrcfspec(FilePath()) ;
	if (csrcfspec.GetLength() > 3)
		csrcfspec = csrcfspec.Left(csrcfspec.GetLength() - 1) ;
	csrcfspec = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\')) + 1) ;
	CString csrcpath(csrcfspec.Left(csrcfspec.GetLength() - 1)) ;
	csrcfspec += _T("*.rc") ;

	// I don't know the name of the RC file so look for it in the specified
	// directory.  Assume that the file is the first RC file in the directory
	// that is NOT called "common.rc".

	CFileFind cff ;
	CString cstmp ;
	BOOL bfound = cff.FindFile(csrcfspec) ;
	bool breallyfound = false ;
	while (bfound) {
		bfound = cff.FindNextFile() ;
		cstmp = cff.GetFileTitle() ;
		cstmp.MakeLower() ;
		if (cstmp != _T("common")) {
			csrcfspec = cff.GetFilePath() ;
			breallyfound = true ;
			break ;
		} ;
	} ;

	// Prepare to ask the user what to do if any of the next few steps fail.

	CString csnext ;
	csnext.Format(IDS_StandAloneFontLoad, m_cfn.NameExt()) ;

	// If the RC file is not found, ...
	
	if (!breallyfound) {
		// ...Ask the user if he wants to tell us where it is.  If he says no,
		// ask if he want to stop or open it restricted.

		cstmp.Format(IDS_RCForUFMPrompt, m_cfn.NameExt()) ;
		if (AfxMessageBox(cstmp, MB_YESNO+MB_ICONQUESTION) == IDNO)
			return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

		// Prompt the use for the path to the RC file.  If he cancels, ask if
		// he want to stop or open it restricted.

		// Prompt the user for a new RC file.  If the operation is canceled,
		// ask if he wants to stop or open it restricted.

		cstmp.LoadString(IDS_CommonRCFile) ;
		CFileDialog cfd(TRUE, _T(".RC"), NULL,
						OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, cstmp) ;
		cfd.m_ofn.lpstrInitialDir = csrcpath ;
		if (cfd.DoModal() != IDOK)
			return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

		// Prepare to check the new filespec

		csrcfspec = cfd.GetPathName() ;
		csrcpath = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\'))) ;
	} ;

	// I've got an RC filespec now so try to open it and read its contents.
	// If the operation fails, ask if he wants to stop or open it restricted.

    CStringArray csarclines ;
    if  (!LoadFile(csrcfspec, csarclines))
		return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

	// Now try to find the line in the RC file that contains the ID for this
	// UFM's GTT.  If the operation fails, ask if he wants to stop or open it
	// restricted.

	for (int n = 0 ; n < csarclines.GetSize() ; n++) {
		if (csarclines[n].Find(_T("RC_GTT")) == -1)
			continue ;
		if (atoi(csarclines[n]) == Translation())
			break ;
	} ;
	if (n >= csarclines.GetSize())
		return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

	// The GTT filespec in the RC file should be relative to the location of
	// the RC file.  So, combine the filespec with the RC file path to get
	// the complete filespec for the GTT file.

	CString csgttfspec ;
	int nloc = csarclines[n].ReverseFind(_T(' ')) ;
	csgttfspec = csarclines[n].Right(csarclines[n].GetLength() - nloc - 1) ;
	csgttfspec = csrcpath + _T("\\") + csgttfspec ;

	// Allocate a new Glyph class instance, initialize it, and load it.  If the
	// operations fails, ask if the user wants to stop or open it restricted.

	pcgm = new CGlyphMap ;
	pcgm->nSetRCID((int) Translation()) ;
	pcgm->NoteOwner(*m_pcdOwner) ;	// Is this right/necessary?
	if (!pcgm->Load(csgttfspec))
		return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

	// The GTT has been loaded so set the UFM's GTT pointer variable, set
	// m_bLoadedByWorkspace since everything has been fixed up as if it had
	// been loaded from a workspace, and return true to indicate success.

	SetTranslation(pcgm) ;
	m_bLoadedByWorkspace = true ;
	return true ;
}


/*****************************************************************************

  CUniString class

  This is a little helper class that will convert a CString to a UNICODE
  string, and take care of cleanup, etc., so the font storage code doesn't get
  any messier than it already will be.

******************************************************************************/

class CUniString : public CWordArray
{
public:
    CUniString(LPCSTR lpstrInit);
    operator PCWSTR() const { return GetData(); }
    unsigned    GetSize() const { return sizeof (WCHAR) * (unsigned) CWordArray::GetSize(); }

    void    Write(CFile& cf)  { cf.Write(GetData(), GetSize()); }
};

CUniString::CUniString(LPCSTR lpstrInit)
{
    SetSize(MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrInit, -1, NULL, 0));
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrInit, -1, GetData(), GetSize());
}





/*****************************************************************************

  CFontInfo::Store

  This member function stores the UFM format information in the specified file
  by assembling it from the information we have cached in this class.

//	typedef struct _UNIDRVINFO
//	{
//	    DWORD   dwSize;			// Size of this structure
//	    DWORD   flGenFlags;		// General flags
//	    WORD    wType;			// Type of the font like CAPSL
//	    WORD    fCaps;			// Font Capability flags
//	    WORD    wXRes;			// Horizontal resolution of the font
//	    WORD    wYRes;			// Vertical Resolution of the font
//	    short   sYAdjust;		// Vertical Cursor position Adjustment
//	    short   sYMoved;		// Adjustment to Y position after printing
//	    WORD    wPrivateData; 	// For backward compatibility, don't show in UI.
//	    short   sShift; 		// For backward compatibility, don't show in UI.	
//	    INVOCATION SelectFont;
//	    INVOCATION UnSelectFont;
//	    WORD    wReserved[4];
//	}  UNIDRVINFO, *PUNIDRVINFO;
//
//
//  And now, ladies and gentlemen, direct from the pages of WINDDI.H,
//  I present to you:
//
//  "rather than adding the fields of IFIEXTRA  to IFIMETRICS itself
//   we add them as a separate structure. This structure, if present at all,
//   lies below IFIMETRICS in memory.
//   If IFIEXTRA is present at all, ifi.cjIfiExtra (formerly ulVersion)
//   will contain size of IFIEXTRA including any reserved fields.
//   That way ulVersion = 0 (NT 3.51 or less) printer minidrivers
//   will work with NT 4.0."
//
//	typedef struct _IFIEXTRA
//	{
//	    ULONG    ulIdentifier;   // used for Type 1 fonts only
//	    PTRDIFF  dpFontSig;      // nontrivial for tt only, at least for now.
//	    ULONG    cig;            // maxp->numGlyphs, # of distinct glyph indicies
//	    PTRDIFF  dpDesignVector; // offset to design vector for mm instances
//	    PTRDIFF  dpAxesInfoW;    // offset to full axes info for base mm font
//	    ULONG    aulReserved[1]; // in case we need even more stuff in the future
//	} IFIEXTRA, *PIFIEXTRA;
//	
******************************************************************************/

BOOL    CFontInfo::Store(LPCTSTR lpstrFile, BOOL bStoreFormWokspace)
{
	// Fonts loaded standalone cannot be saved because m_pcgmTranslation is not
	// set.  Tell the user and exit.  TRUE is returned to keep this from
	// happening again.

	if (!m_bLoadedByWorkspace) {
		CString csmsg ;
		csmsg.LoadString(IDS_CantStoreStandAlone) ;
		AfxMessageBox(csmsg) ;
		return TRUE ;
	} ;
    
	DWORD dwAdd_UniDrv = 0;
	DWORD dwAdd_IFI = 0;
	DWORD dwAdd_ExtTextM = 0;
	DWORD dwAdd_WidthTable = 0;
	DWORD dwAdd_KerPair = 0;

//	DWORD dwAdd_SelectedFont;
//	DWORD dwAdd_UnSelectedFont;

	static const BYTE InsertZero[8] = {0,0,0,0,0,0,0,0};

	const short OS_BYTE = 0x08;
	// If a UFM loaded from a workspace can't be saved normally because it did
	// not have a valid GTT/CP, call another routine to handle this case and
	// return whatever it returns.

	if (m_bWSLoadButNoGTTCP)
		return StoreGTTCPOnly(lpstrFile) ;

    try {																		//  Any exxceptions, we'll just fail gracelessly

        CFile   cfUFM(lpstrFile,												//  Create/open the output file.
            CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);
//------------------------------------------------------------------------------------------------------------------------------------------
																				// UNIFM_HDR
        UNIFM_HDR  ufmh = {sizeof ufmh, UNIFM_VERSION_1_0, 0,										// Create the output UNIFM_HDR
            (short) m_lGlyphSetDataRCID, sizeof ufmh};												// rm new
																		

//		int q = m_pcgmTranslation -> m_csoaCodePage.GetSize();										// rm test
//		int r = m_pcgmTranslation -> CodePages();													// rm test

//        ufmh.ulDefaultCodepage = m_pcgmTranslation -> CodePage(0).Page();							// rm test

		// Previously, the default code page in the UFM's GTT was always saved.
		// This ignored the user's changes in the UFM editor.  Now, the user's
		// choice is saved if it is valid (other checking done in other places).
		// Otherwise, the GTT's default code page is used when there is a GTT
		// associated with the UFM.  If not, assert.

		if (m_ulDefaultCodepage > 0)
			ufmh.ulDefaultCodepage = m_ulDefaultCodepage ;
		else if (m_pcgmTranslation)
			ufmh.ulDefaultCodepage = m_pcgmTranslation->DefaultCodePage() ;
		else
			ASSERT(0) ;
        //ufmh.ulDefaultCodepage = m_pcgmTranslation -> DefaultCodePage();							// Use Glyph Map default code page if at all possible.

		memset((PBYTE) ufmh.dwReserved, 0, sizeof ufmh.dwReserved);									// Zero fill reserved bytes.

//------------------------------------------------------------------------------------------------------------------------------------------
		ufmh.loUnidrvInfo = ufmh.dwSize;														// UNIDRVINFO
		if (dwAdd_UniDrv = ufmh.loUnidrvInfo & 0x07) {
			dwAdd_UniDrv = OS_BYTE - dwAdd_UniDrv;
			ufmh.loUnidrvInfo += dwAdd_UniDrv;
		}

        m_UNIDRVINFO.dwSize = sizeof (UNIDRVINFO);

        m_UNIDRVINFO.SelectFont.loOffset = m_ciSelect.Length() ? m_UNIDRVINFO.dwSize : 0;		// Invocation Strings affect the size,
/*			if (dwAdd_SelectedFont = m_UNIDRVINFO.SelectFont.loOffset & 0x07) {
			dwAdd_SelectedFont += OS_BYTE - dwAdd_SelectedFont;
			m_UNIDRVINFO.SelectFont.loOffset += dwAdd_SelectedFont;
		} */
		m_UNIDRVINFO.dwSize += m_UNIDRVINFO.SelectFont.dwCount = m_ciSelect.Length();			//  so get their specifics and
        
		m_UNIDRVINFO.UnSelectFont.loOffset = m_ciDeselect.Length() ? m_UNIDRVINFO.dwSize : 0;	//  store them, updating the affected
/*			if (dwAdd_UnSelectedFont = m_UNIDRVINFO.UnSelectFont.loOffset & 0x07) {
			dwAdd_UnSelectedFont += OS_BYTE - dwAdd_UnSelectedFont;
			ufmh.loUnidrvInfo += dwAdd_UnSelectedFont;
		} */
		m_UNIDRVINFO.dwSize += m_UNIDRVINFO.UnSelectFont.dwCount = m_ciDeselect.Length();		//  size fields as we go.

        unsigned    uAdjustUDI = (4 - (m_UNIDRVINFO.dwSize % 4)) % 4;	// you can delte this							// Pad this to keep everything
																									//  DWORD aligned in the file image!
        ufmh.loIFIMetrics = ufmh.dwSize += m_UNIDRVINFO.dwSize += uAdjustUDI + dwAdd_UniDrv;						//  Store IFIMETRICS offset
		
		if (dwAdd_IFI = ufmh.loIFIMetrics & 0x07) {
			dwAdd_IFI = OS_BYTE - dwAdd_IFI;
			ufmh.loIFIMetrics += dwAdd_IFI;
        }
		memset((PSTR) m_UNIDRVINFO.wReserved, 0, sizeof m_UNIDRVINFO.wReserved);					//  zero out reserved section.

//------------------------------------------------------------------------------------------------------------------------------------------

        IFIEXTRA    ifie = {0, 0, m_pcgmTranslation->Glyphs(), 0, 0, 0};		// Create the IFIEXTRA structure.
//------------------------------------------------------------------------------------------------------------------------------------------
																				// IFIMETRICS

        IFIMETRICS ifi = {sizeof ifi + sizeof ifie, sizeof ifie};				// Create the output IFIMETRICS structure, being sure to add
																				//  in the size of the IFIMETRICS structure, as well as the
																				//  size of the IFIEXTRA structure.

//	int iSizeOf_IFIMETRICS = sizeof(IFIMETRICS);

//	memcpy((void *) &ifi, (void *) &m_IFIMETRICS, iSizeOf_IFIMETRICS );			// IFIMETRICS structure

																				// Store the IFIMETRICS data

        ifi.lEmbedId = ifi.lItalicAngle = ifi.lCharBias = 0;					//

		ifi.dpCharSets = 0;														//  dpCharSets = 0 for now

        ifi.jWinCharSet			  = m_IFIMETRICS.jWinCharSet;					//  jWinCharSet				// rm new
        ifi.jWinPitchAndFamily	  = m_IFIMETRICS.jWinPitchAndFamily;			//  jWinPitchAndFamily		// rm new
        ifi.usWinWeight			  = m_IFIMETRICS.usWinWeight;					//  usWinWeight				// rm new
		ifi.flInfo			 	  = m_IFIMETRICS.flInfo;						//  flInfo					// rm new
        ifi.fsSelection			  = m_IFIMETRICS.fsSelection;					//  fsSelection				// rm new
        ifi.fsType				  = FM_NO_EMBEDDING;							//  fsType					// rm new

        ifi.fwdUnitsPerEm		  = m_IFIMETRICS.fwdUnitsPerEm;					//  fwdUnitsPerEm			// rm new
        ifi.fwdLowestPPEm		  = m_IFIMETRICS.fwdLowestPPEm;					//  fwdLowestPPEm			// rm new

		ifi.fwdWinAscender		  = m_IFIMETRICS.fwdWinAscender;				//  fwdWinAscender			// rm new
		ifi.fwdWinDescender		  = m_IFIMETRICS.fwdWinDescender;				//  fwdWinDescender			// rm new

		ifi.fwdMacAscender		  = m_IFIMETRICS.fwdWinAscender;				//  fwdMacAscender			// rm replaced
		ifi.fwdMacDescender		  = m_IFIMETRICS.fwdWinAscender - m_wHeight;	//  fwdMacDescender			// rm replaced

		ifi.fwdMacLineGap		  = m_IFIMETRICS.fwdMacLineGap;					//  fwdMacLineGap

        ifi.fwdTypoAscender		  = m_IFIMETRICS.fwdWinAscender;				//  fwdTypoAscender			// rm replaced
        ifi.fwdTypoDescender	  = m_IFIMETRICS.fwdWinAscender - m_wHeight;	//  fwdTypoDescender		// rm replaced

        ifi.fwdTypoLineGap		  = m_IFIMETRICS.fwdMacLineGap;					//  fwdTypoLineGap

        ifi.fwdAveCharWidth		  = m_IFIMETRICS.fwdAveCharWidth;				//  fwdAveCharWidth			// rm new
        ifi.fwdMaxCharInc		  = m_IFIMETRICS.fwdMaxCharInc;					//  fwdMaxCharInc			// rm new


        ifi.fwdCapHeight		  = m_IFIMETRICS.fwdCapHeight;					//  fwdCapHeight			// rm new
        ifi.fwdXHeight			  = m_IFIMETRICS.fwdXHeight;					//  fwdXHeight				// rm new
        ifi.fwdSubscriptXSize     = m_IFIMETRICS.fwdSubscriptXSize;				//  fwdSubscriptXSize		// rm new
        ifi.fwdSubscriptYSize	  = m_IFIMETRICS.fwdSubscriptYSize;				//  fwdSubscriptYSize		// rm new
        ifi.fwdSubscriptXOffset   = m_IFIMETRICS.fwdSubscriptXOffset;			//  fwdSubscriptXOffset		// rm new
        ifi.fwdSubscriptYOffset   = m_IFIMETRICS.fwdSubscriptYOffset;			//  fwdSuperscriptYOffset	// rm new
        ifi.fwdSuperscriptXSize   = m_IFIMETRICS.fwdSuperscriptXSize;			//  fwdSuperscriptXSize		// rm new
        ifi.fwdSuperscriptYSize   = m_IFIMETRICS.fwdSuperscriptYSize;			//  fwdSubscriptYOffset		// rm new
        ifi.fwdSuperscriptXOffset = m_IFIMETRICS.fwdSuperscriptXOffset;			//  fwdSuperscriptXOffset	// rm new
        ifi.fwdSuperscriptYOffset = m_IFIMETRICS.fwdSuperscriptYOffset;			//  fwdSuperscriptYOffset	// rm new


        ifi.fwdUnderscoreSize	  = m_IFIMETRICS.fwdUnderscoreSize;				//	fwdUnderscoreSize		// rm new
        ifi.fwdUnderscorePosition = m_IFIMETRICS.fwdUnderscorePosition;			//	fwdUnderscorePosition	// rm new
        ifi.fwdStrikeoutSize	  = m_IFIMETRICS.fwdStrikeoutSize;				//  fwdStrikeoutSize		// rm new
        ifi.fwdStrikeoutPosition  = m_IFIMETRICS.fwdStrikeoutPosition;			//  fwdStrikeoutPosition	// rm new
//------------------------------------------------------------------------------------------------------------------------------------------

        ifi.chFirstChar			  = m_IFIMETRICS.chFirstChar;					//  chFirstChar				// rm new
        ifi.chLastChar			  = m_IFIMETRICS.chLastChar;					//  chLastChar				// rm new
        ifi.chDefaultChar		  = m_IFIMETRICS.chDefaultChar;					//  chDefaultChar			// rm new
        ifi.chBreakChar			  = m_IFIMETRICS.chBreakChar;					//  chBreakChar				// rm new

        ifi.wcFirstChar			  = m_IFIMETRICS.wcFirstChar;					//  wcFirstChar				// rm new
        ifi.wcLastChar			  = m_IFIMETRICS.wcLastChar;					//  wcLastChar				// rm new
        ifi.wcDefaultChar		  = m_IFIMETRICS.wcDefaultChar;					//  wcDefaultChar			// rm new
        ifi.wcBreakChar			  = m_IFIMETRICS.wcBreakChar;					//  wcBreakChar				// rm new

        ifi.ptlBaseline.x		  = m_IFIMETRICS.ptlBaseline.x;					//  ptlBaseline.x
        ifi.ptlBaseline.y		  = m_IFIMETRICS.ptlBaseline.y;					//  ptlBaseline.y

        ifi.ptlAspect.x			  = m_IFIMETRICS.ptlAspect.x;					//  ptlAspect.x				// rm new
        ifi.ptlAspect.y			  = m_IFIMETRICS.ptlAspect.y;					//  ptlAspect.y				// rm new

//------------------------------------------------------------------------------------------------------------------------------------------
//      ifi.ptlBaseline.x		  = 1;											//  ptlBaseline.x
//      ifi.ptlBaseline.y		  = 0;											//  ptlBaseline.y
//
//      ifi.ptlAspect.x			  = m_UNIDRVINFO.wXRes;							//  ptlAspect.x				// rm new
//      ifi.ptlAspect.y			  = m_UNIDRVINFO.wYRes;							//  ptlAspect.y				// rm new
//------------------------------------------------------------------------------------------------------------------------------------------

        ifi.ptlCaret.x			  = m_IFIMETRICS.ptlCaret.x;					//  ptlCaret.x				// rm new
        ifi.ptlCaret.y			  = m_IFIMETRICS.ptlCaret.y;					//  ptlCaret.y				// rm new
		

//        ifi.ptlCaret.x		  = m_ItalicAngle ? (long) ((double) 10000.0 * 							//  ptlCaret.x			// rm ori
//											tan(((double) m_ItalicAngle) / gdConvertRadToDegree)) : 0;
//        ifi.ptlCaret.y		  = m_ItalicAngle ? 10000 : 1;											//  ptlCaret.y			// rm ori

//------------------------------------------------------------------------------------------------------------------------------------------
        memcpy(ifi.achVendId, "Unkn", 4);										//  achVendId				// rm ori
//------------------------------------------------------------------------------------------------------------------------------------------

        ifi.cKerningPairs		  = m_csoaKern.GetSize();						//  cKerningPairs			// rm ori

//------------------------------------------------------------------------------------------------------------------------------------------
        ifi.rclFontBox.left		  = m_IFIMETRICS.rclFontBox.left;				//  rclFontBox.left			// rm new
        ifi.rclFontBox.top		  = m_IFIMETRICS.rclFontBox.top;				//  rclFontBox.top			// rm new
        ifi.rclFontBox.right	  = m_IFIMETRICS.rclFontBox.right;				//  rclFontBox.right		// rm new
        ifi.rclFontBox.bottom	  = m_IFIMETRICS.rclFontBox.bottom;				//  rclFontBox.bottom		// rm new

//------------------------------------------------------------------------------------------------------------------------------------------
        ifi.ulPanoseCulture		  = FM_PANOSE_CULTURE_LATIN;					//  ulPanoseCulture			// rm ori
//------------------------------------------------------------------------------------------------------------------------------------------

																				//  panose .bWeight			// rm ori
        ifi.panose.bWeight	      = (m_IFIMETRICS.usWinWeight >= FW_BOLD) ? PAN_WEIGHT_BOLD :
                                    (m_IFIMETRICS.usWinWeight > FW_EXTRALIGHT) ? PAN_WEIGHT_MEDIUM : PAN_WEIGHT_LIGHT;

        ifi.panose.bFamilyType	    = m_IFIMETRICS.panose.bFamilyType;			//  panose	// rm new
		ifi.panose.bSerifStyle      = m_IFIMETRICS.panose.bSerifStyle;
        ifi.panose.bProportion      = m_IFIMETRICS.panose.bProportion;
		ifi.panose.bContrast        = m_IFIMETRICS.panose.bContrast;
        ifi.panose.bStrokeVariation = m_IFIMETRICS.panose.bStrokeVariation;
		ifi.panose.bArmStyle		= m_IFIMETRICS.panose.bArmStyle;
        ifi.panose.bLetterform		= m_IFIMETRICS.panose.bLetterform;
		ifi.panose.bMidline			= m_IFIMETRICS.panose.bMidline;
        ifi.panose.bXHeight			= m_IFIMETRICS.panose.bXHeight;


//        ifi.panose.bFamilyType = ifi.panose.bSerifStyle = 					//  panose	// rm ori
//            ifi.panose.bProportion = ifi.panose.bContrast =
//            ifi.panose.bStrokeVariation = ifi.panose.bArmStyle =
//            ifi.panose.bLetterform = ifi.panose.bMidline =
//            ifi.panose.bXHeight = PAN_ANY;

//------------------------------------------------------------------------------------------------------------------------------------------
																				//  Convert and "place" the various name strings
        CUniString  cusUnique(m_csUnique), cusStyle(m_csStyle),
            cusFace(m_csFace), cusFamily(m_csaFamily[0]);

        ifi.dpwszFamilyName = ifi.cjThis;
        for (int i = 1; i < m_csaFamily.GetSize(); i++)
			{
			CUniString cusWork(m_csaFamily[i]);
			cusFamily.Append(cusWork);
			}

        if  (m_csaFamily.GetSize() > 1)
			{
            cusFamily.Add(0);
            ifi.flInfo |= FM_INFO_FAMILY_EQUIV;
			}

        ifi.cjThis += cusFamily.GetSize();

        ifi.dpwszFaceName = ifi.cjThis;
        ifi.cjThis += cusFace.GetSize();
        ifi.dpwszUniqueName = ifi.cjThis;
        ifi.cjThis += cusUnique.GetSize();
        ifi.dpwszStyleName = ifi.cjThis;
        ifi.cjThis += cusStyle.GetSize();
//------------------------------------------------------------------------------------------------------------------------------------------
																			    //  The next field must be DWORD aligned, so see what padding
																			    //  is needed.

        unsigned    uAdjustIFI = (sizeof ifi.cjThis -
            (ifi.cjThis % sizeof ifi.cjThis)) % sizeof ifi.cjThis;

        ifi.cjThis += uAdjustIFI;

        unsigned    uSim = !!m_pcfdBold + !!m_pcfdItalic + !!m_pcfdBoth;		//  Finally, Allow for the size of any Font Difference structures.

        ifi.dpFontSim = uSim ? ifi.cjThis : 0;
        ufmh.dwSize += ifi.cjThis += uSim * sizeof(FONTDIFF) + !!uSim * sizeof(FONTSIM) + dwAdd_IFI;


//------------------------------------------------------------------------------------------------------------------------------------------
																				// EXTTEXTMETRIC

		ufmh.loExtTextMetric = 0;													// Preset ufm exttextmetric offset to 0.

		if(m_fSave_EXT)																// If user wants to save the EXTTEXTMETRIC data
			{
			ufmh.loExtTextMetric = ufmh.dwSize;										// Set ufm exttextmetric offset. Note, this
																			//  offset just happens to be the current ufmh.dwSize.
			if(dwAdd_ExtTextM = ufmh.loExtTextMetric & 0x07){
				dwAdd_ExtTextM = OS_BYTE - dwAdd_ExtTextM;
				ufmh.loExtTextMetric += dwAdd_ExtTextM;
			}
			
			ufmh.dwSize += m_EXTTEXTMETRIC.emSize = sizeof(EXTTEXTMETRIC);			// Increase size of ufmh.dwSize to accomodate
																					//  exttextmetric structure.
			ufmh.dwSize +=dwAdd_ExtTextM;
		}
//------------------------------------------------------------------------------------------------------------------------------------------
																				// CHARACTER WIDTHS DATA

																					// Calculate size of width table (if there is one)														
//raid 154639					
        ufmh.loWidthTable = IsVariableWidth() * ufmh.dwSize;						//   set ufm width table offset. Note, this

		if(dwAdd_WidthTable = ufmh.loWidthTable & 0x07){                  	//   offset just happens to be the current ufmh.dwSize.
			dwAdd_WidthTable = OS_BYTE - dwAdd_WidthTable;
			ufmh.loWidthTable += dwAdd_WidthTable;
		}
			
        if  (IsVariableWidth())														//  Width table, but only if there is an associated GTT.
			{																		//  For now, we just need to calculate the size of the table
            unsigned    uRuns = 0, uGlyphs = 0;

            if  (DBCSFont())														//  DBCS
				{
                unsigned u = (unsigned) m_cpaGlyphs.GetSize();						//  Determine the number of runs needed
                do
					{
                    while   (u-- && !m_cwaWidth[u]);								//  DBCS has 0 width
                    if  (u == (unsigned) -1) break;									//  We're done!

                    uRuns++, uGlyphs++;
                    while   (u-- && m_cwaWidth[u])
                        uGlyphs++;
					}
					while   (u != (unsigned) -1);
				}
            else
				{
                uRuns++;
                uGlyphs = (unsigned)m_cwaWidth.GetSize();
				}

            ufmh.dwSize += sizeof (WIDTHTABLE) + --uRuns * sizeof (WIDTHRUN) +
                uGlyphs * sizeof (WORD) + dwAdd_WidthTable;
			}
 
//------------------------------------------------------------------------------------------------------------------------------------------
																				// KERNING PAIRS DATA

																					// Calculate size of Kerning table (if there is one)														
        ufmh.loKernPair = CanKern() ? ufmh.dwSize : 0;								//   set ufm Kerning table offset. Note, this
																					//   offset just happens to be the current ufmh.dwSize.

        																					// A "secret" kern pair of all 0's must end this,
																					//  so this size is in fact correct.  Also note that
																					//   padding screws up the size of the KERNDATA structure.
        if  (CanKern()){
			if(dwAdd_KerPair = ufmh.loKernPair & 0x07) {                 	//   offset just happens to be the current ufmh.dwSize.
				dwAdd_KerPair = OS_BYTE - dwAdd_KerPair;
				ufmh.loKernPair += dwAdd_KerPair;
			}
            ufmh.dwSize +=
            ((sizeof (KERNDATA) - sizeof (FD_KERNINGPAIR)) & 0xFFFC) +
            ((1 + m_csoaKern.GetSize()) * sizeof (FD_KERNINGPAIR)) + dwAdd_KerPair;
		}
//------------------------------------------------------------------------------------------------------------------------------------------
																				//  All sizes have been calculated, and the important structures have
																				//  been initialized.  Time to start writing all this great stuff!
//------------------------------------------------------------------------------------------------------------------------------------------
		
        cfUFM.Write(&ufmh, sizeof ufmh);										//  write UNIFM_HDR Header

//------------------------------------------------------------------------------------------------------------------------------------------
		if (dwAdd_UniDrv)
			cfUFM.Write(InsertZero, dwAdd_UniDrv);

		cfUFM.Write(&m_UNIDRVINFO, sizeof m_UNIDRVINFO);						//  write UNIDRVINFO	// rm new
/*		if (dwAdd_SelectedFont)
			cfUFM.Write (InsertZero,dwAdd_SelectedFont); */
		m_ciSelect.WriteEncoding(cfUFM);
		
/*		if (dwAdd_UnSelectedFont)
			cfUFM.Write (InsertZero,dwAdd_UnSelectedFont); */
        m_ciDeselect.WriteEncoding(cfUFM);

        cfUFM.Write(ufmh.dwReserved, uAdjustUDI);								//  write Padding

//------------------------------------------------------------------------------------------------------------------------------------------
        if (dwAdd_IFI)
			cfUFM.Write(InsertZero, dwAdd_IFI);

		cfUFM.Write(&ifi, sizeof ifi);											//  write IFIMETRICS
        cfUFM.Write(&ifie, sizeof ifie);										//  write IFIEXTRA
        cusFamily.Write(cfUFM);													//  write "Family"
        cusFace.Write(cfUFM);													//  write "Face"
        cusUnique.Write(cfUFM);													//  write "Unique name"
        cusStyle.Write(cfUFM);													//  write "Style"
        cfUFM.Write(ufmh.dwReserved, uAdjustIFI);								//  write Padding

//------------------------------------------------------------------------------------------------------------------------------------------
        if  (m_pcfdBold || m_pcfdItalic || m_pcfdBoth)							//  Any Font difference structures
			{
            FONTSIM fs;
            unsigned    uWhere = sizeof fs;

            fs.dpBold = m_pcfdBold ? uWhere : 0;
            uWhere += !!m_pcfdBold * sizeof (FONTDIFF);
            fs.dpItalic = m_pcfdItalic ? uWhere : 0;
            uWhere += !!m_pcfdItalic * sizeof (FONTDIFF);
			//TRACE("Italic metrics = %d, %d %d %d\n", m_pcfdItalic->Metric(0), m_pcfdItalic->Metric(1), m_pcfdItalic->Metric(2), m_pcfdItalic->Metric(3)) ;
            fs.dpBoldItalic = m_pcfdBoth ? uWhere : 0;

            cfUFM.Write(&fs, sizeof fs);


            if  (m_pcfdBold)   m_pcfdBold->Store(cfUFM, m_IFIMETRICS.fsSelection | FM_SEL_BOLD);							// rm new
            if  (m_pcfdItalic) m_pcfdItalic->Store(cfUFM, m_IFIMETRICS.fsSelection | FM_SEL_ITALIC);
            if  (m_pcfdBoth)   m_pcfdBoth->Store(cfUFM, m_IFIMETRICS.fsSelection | FM_SEL_BOLD| FM_SEL_ITALIC);

		
//            if  (m_pcfdBold)   m_pcfdBold->Store(cfUFM, m_wfStyle | FM_SEL_BOLD);							// rm ori
//            if  (m_pcfdItalic) m_pcfdItalic->Store(cfUFM, m_wfStyle | FM_SEL_ITALIC);
//            if  (m_pcfdBoth)   m_pcfdBoth->Store(cfUFM, m_wfStyle | FM_SEL_BOLD| FM_SEL_ITALIC);
			}

//------------------------------------------------------------------------------------------------------------------------------------------
		if (m_fSave_EXT)														// write EXTTEXTMETRIC
			if (dwAdd_ExtTextM)
			cfUFM.Write(InsertZero, dwAdd_ExtTextM);
			cfUFM.Write(&m_EXTTEXTMETRIC, sizeof(EXTTEXTMETRIC) );
//------------------------------------------------------------------------------------------------------------------------------------------
																				//  Width table

        if  (IsVariableWidth())
            if  (!DBCSFont())														//  Not DBCS - easy!  (Handles always start at 1
				{

                WIDTHTABLE  wdt = { sizeof wdt, 1,
                        {1, (WORD)m_cpaGlyphs.GetSize(), sizeof wdt}};
				if(dwAdd_WidthTable)  // 154639
					cfUFM.Write(InsertZero, dwAdd_WidthTable);
                cfUFM.Write(&wdt, sizeof wdt);

                cfUFM.Write(m_cwaWidth.GetData(),
						(unsigned)(m_cwaWidth.GetSize() * sizeof (WORD)));
				}
            else																	//  DBCS - This case is a bit nastier
				{
                CByteArray  cbaTable;
                CWordArray  cwaSize;

                cbaTable.SetSize(sizeof(WIDTHTABLE) - sizeof(WIDTHRUN));
                PWIDTHTABLE pwdt = (PWIDTHTABLE) cbaTable.GetData();
                pwdt -> dwRunNum = 0;

																					//  Calculate and fill in the WIDTHRUN structures and the
																					//  Size array
                unsigned u = 0, uMax = (unsigned) m_cpaGlyphs.GetSize();
                do
					{
                    while   (u < uMax && !m_cwaWidth[u++]);
                    if  (u == uMax)  break;											//  We're done!

																					//  We've found a run- lots of work to do

                    cbaTable.InsertAt(cbaTable.GetSize(), 0,						//  Add a run to the table
                        sizeof (WIDTHRUN));
                    pwdt = (PWIDTHTABLE) cbaTable.GetData();						//  Remember the glyph handle is 1-based.
                    pwdt->WidthRun[pwdt->dwRunNum].wStartGlyph = --u + 1;
                    pwdt->WidthRun[pwdt->dwRunNum].wGlyphCount = 0;
                    pwdt->WidthRun[pwdt->dwRunNum].loCharWidthOffset =
									(DWORD)(cwaSize.GetSize() * sizeof (WORD));
                    do
						{
                        cwaSize.Add(m_cwaWidth[u]);
                        pwdt -> WidthRun[pwdt->dwRunNum].wGlyphCount++;
						}
						while   (++u < uMax && m_cwaWidth[u]);
                    pwdt->dwRunNum++;												//  End of the run!
					}
					while   (u < uMax);
																					//  OK, now we have to add the total size of the WIDTHTABLE
																					//  to the various offsets, but we are otherwise ready to rock
																					//  and roll.

                pwdt->dwSize = (DWORD)cbaTable.GetSize();
                for (u = 0; u < pwdt->dwRunNum; u++)
                    pwdt->WidthRun[u].loCharWidthOffset += pwdt->dwSize;
				
				if(dwAdd_WidthTable)  // 154639
					cfUFM.Write(InsertZero, dwAdd_WidthTable);
																
                cfUFM.Write(pwdt, pwdt -> dwSize);									//  write width table
                for (u = 0; u < pwdt -> dwRunNum; u++)
                    cfUFM.Write(cwaSize.GetData() +
                    pwdt -> WidthRun[u].wStartGlyph - 1,
                    pwdt -> WidthRun[u].wGlyphCount * sizeof (WORD));
				}

//------------------------------------------------------------------------------------------------------------------------------------------
        if  (CanKern())															//  Kern Pairs
			{	
            //  KERNDATA is DWORD-packed, but FD_KERNINGPAIR is WORD-packed
            //  the following trick code allows for any slop.
            KERNDATA    kd = {0xFFFC & (sizeof kd - sizeof kd.KernPair),
							  m_csoaKern.GetSize()};
            kd.dwSize += (1 + kd.dwKernPairNum) * sizeof kd.KernPair;

			if(dwAdd_KerPair)  // 154639
				cfUFM.Write(InsertZero, dwAdd_KerPair);

            cfUFM.Write(&kd, 0xFFFC & (sizeof kd - sizeof kd.KernPair));

            for (unsigned u = 0; u < m_csoaKern.GetSize(); u++)	{
                CKern *pck = (CKern *) m_csoaKern[u] ;
				WCHAR wcf = pck->First()  ;
				WCHAR wcs = pck->Second() ;
				short sa  = pck->Amount() ;
                ((CKern *) m_csoaKern[u]) -> Store(cfUFM);
			} ;

            //  Now for the "secret" sentinel-
            CKern   ck; //  Just happens to 0-init!
            ck.Store(cfUFM);
			}
    }

//------------------------------------------------------------------------------------------------------------------------------------------
    catch   (CException *pce)
		{
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
		}
	if(!bStoreFormWokspace)	//raid 244123
		Changed(FALSE);
    return  TRUE;																//  Return triumphant to whoever deigned to need this service.
}


/*****************************************************************************

  CFontInfo::StoreGTTCPOnly

  When a UFM is loaded during a workspace load and the UFM does not have a 
  valid GTT or CP, the UFM cannot be saved normally because there are several
  parts of the UFM that were not loaded correctly or at all because of the
  missing data.  

  When this situation is detected, this routine is called so the - supposedly -
  good info in the disk file is not overwritten by bad data.  In addition,
  Store() will blow when it tries to use nonexistent UFM data.

  This routine will just save the what we hope is corrected GTT and/or CP data.
  This is done without changing any of the other data in the file.  Next, the
  UFM is reloaded.  If all goes well, the UFM is correctly loaded so that
  normal editting and saving can be performed from this point on.

  TRUE is returned if the GTT and CP are successfully saved.  Otherwise, FALSE
  is returned.

******************************************************************************/

BOOL    CFontInfo::StoreGTTCPOnly(LPCTSTR lpstrFile)
{
	// Remind the user about what is going to happen.

	AfxMessageBox(IDS_GTTCPOnlySaved, MB_ICONINFORMATION) ;

	// Perform the steps required to update the GTT/CP in the UFM file.

    try {
		// Begin by opening the file in a way that will not truncate existing
		// files.

		UINT nopenflags = CFile::modeNoTruncate | CFile::modeCreate  ;
		nopenflags |= CFile::modeWrite | CFile::shareExclusive  ;
        CFile cfufm(lpstrFile, nopenflags) ;

		// Seek to the file positon that we want change.

        UNIFM_HDR ufmh ;
		DWORD dwseekpos ;
		dwseekpos = (DWORD)PtrToUlong(&ufmh.ulDefaultCodepage) - (DWORD)PtrToUlong(&ufmh) ;
		cfufm.Seek(dwseekpos, CFile::begin) ;

		// Load the fields in the UFM header that we want to save and write
		// them out.

		ufmh.ulDefaultCodepage = m_ulDefaultCodepage ;
		ufmh.lGlyphSetDataRCID = m_lGlyphSetDataRCID ;
		UINT nwritebytes = sizeof(ufmh.ulDefaultCodepage) 
						   + sizeof(ufmh.lGlyphSetDataRCID) ;
		cfufm.Write((void*) &ufmh.ulDefaultCodepage, nwritebytes) ;

		// Move the file pointer to the end of the file and close it.

		cfufm.SeekToEnd() ;
		cfufm.Close() ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return FALSE ;
	} ;
    Changed(FALSE) ;

	// If the UFM was loaded from a workspace, try to use the workspace data to
	// find and load a pointer to the new GTT and finish loading the font.

	m_pcgmTranslation = NULL ;
	if (m_bLoadedByWorkspace) {
	    CDriverResources* pcdr = (CDriverResources*) GetWorkspace() ;
		if (pcdr)
			pcdr->LinkAndLoadFont(*this, false) ;
		else
			Load(false) ;

	// If the UFM was loaded stand alone the first time, reload it the same way
	// and let the load routine handle finding the GTT info.

	} else
		Load(false) ;

	// If reloading the UFM successfully associated a GTT or CP with the UFM,
	// clear the m_bWSLoadButNoGTTCP flag.  Then tell the user that the UFM
	// can be editted normally now.

	if (m_pcgmTranslation) {
		SetNoGTTCP(false) ;
		CString csmsg ;
		csmsg.Format(IDS_UFMOKNow, Name()) ;
		AfxMessageBox(csmsg, MB_ICONINFORMATION) ;
	} ;

	// All went well so...

	return TRUE ;
}


/*****************************************************************************

  CFontInfo::CreateEditor

  This member function launches an editing view for the font.

******************************************************************************/

CMDIChildWnd*   CFontInfo::CreateEditor()
{
    CFontInfoContainer* pcficMe= new CFontInfoContainer(this, FileName());

    pcficMe -> SetTitle(m_pcbnWorkspace -> Name() + _TEXT(": ") + Name());	//  Make up a cool title

    CMDIChildWnd    *pcmcwNew;
	pcmcwNew = (CMDIChildWnd *) m_pcmdt->CreateNewFrame(pcficMe, NULL);

    if  (pcmcwNew)
		{
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcficMe, TRUE);
        m_pcmdt -> AddDocument(pcficMe);
		}
	
    return  pcmcwNew;
}

/******************************************************************************

  CFontInfo::Serialize

  This is responsible for storing and restoring the entire maze of data in
  persistent object storage.

******************************************************************************/

void    CFontInfo::Serialize(CArchive& car) {
    //  We only serialize what's needed to use the UFM file in the editor,
    //  i.e., the glue needed to hold us in the driver workspace.

    CProjectNode::Serialize(car);
}


/*****************************************************************************

  CFontInfo::GetFontSimDataPtr

  Return a pointer to the requested font simulation data.

******************************************************************************/

CWordArray* CFontInfo::GetFontSimDataPtr(int nid)
{
	switch (nid) {
		case ItalicDiff:
			if (m_pcfdItalic == NULL)
				ASSERT(0) ;
			return m_pcfdItalic->GetFontSimDataPtr() ;
		case BoldDiff:
			if (m_pcfdBold == NULL)
				ASSERT(0) ;
			return m_pcfdBold->GetFontSimDataPtr() ;
		case BothDiff:
			if (m_pcfdBoth == NULL)
				ASSERT(0) ;
			return m_pcfdBoth->GetFontSimDataPtr() ;
		default:
			ASSERT(0) ;
	} ;

	// This point should never be reached.

	return NULL ;
}


/******************************************************************************

  CFontInfo::EnableSim

  This method is called to turn simulation on or off for the specified item.
  It receives a reference to the editor's pointer for the same item.

******************************************************************************/

void    CFontInfo::EnableSim(unsigned uSim, BOOL bOn, CFontDifference*& pcfd)
{

    CFontDifference*&   pcfdTarget = uSim ? (uSim == BothDiff) ? m_pcfdBoth : m_pcfdBold : m_pcfdItalic;

    if  (bOn == !!pcfd && pcfdTarget == pcfd)  return;		//  Clear out any irrelevant calls

    if  (bOn && pcfdTarget)									//  If this call is just to init pcfd, do it and leave
		{
        pcfd = pcfdTarget;
        return;
		}



    if  (bOn)
//        pcfd = pcfdTarget = pcfd ? pcfd : new CFontDifference(m_wWeight, m_wMaximumIncrement, m_wAverageWidth,			// rm ori
//															  uSim == BoldDiff ? m _cwaSpecial[ItalicAngle] : 175, this);

        pcfd = pcfdTarget = pcfd ? pcfd : new CFontDifference(m_IFIMETRICS.usWinWeight, m_IFIMETRICS.fwdMaxCharInc, m_IFIMETRICS.fwdAveCharWidth,
															  uSim == BoldDiff ? m_ItalicAngle : 175, this);
    else
        pcfdTarget = NULL;  //  pcfd will already have been set correctly

    Changed();
}


/******************************************************************************

  CFontInfo::FillKern

  This preps the passed CListCtrl, if necessary, and fills it with the kerning
  information.

******************************************************************************/

void    CFontInfo::FillKern(CListCtrl& clcView)
{
    for (unsigned u = 0; u < m_csoaKern.GetSize(); u++)
		{
        CString csWork;
        CKern&  ckThis = *(CKern *) m_csoaKern[u];

        csWork.Format("%d", ckThis.Amount());
        int idItem = clcView.InsertItem(u, csWork);
        clcView.SetItemData(idItem, u);

        csWork.Format("0x%X", ckThis.First());
        clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);

        csWork.Format("0x%X", ckThis.Second());
        clcView.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u);
		}
}


/******************************************************************************

  CFontInfo::LoadBadKerningInfo

  Check the kerning pairs to see if they reference code points that are not in
  the UFM's GTT.  If any are found, load them into the specified list control.
  Return true if any bad kerning pairs were found.  Otherwise, return false.

******************************************************************************/

bool CFontInfo::LoadBadKerningInfo(CListCtrl& clcbaddata)
{
	// Declare the variables needed to check for bad kerning data

	unsigned unumkerns = m_csoaKern.GetSize() ;
    CString cs ;
	bool bfoundbad = false ;

	// Loop through each kerning class and check it.

    for (unsigned u = 0 ; u < unumkerns ; u++) {
        CKern& ckThis = *(CKern *) m_csoaKern[u] ;

		// If each code point in this kerning pair is still a valid code point
		// for the GTT, skip this kerning pair.

		if (CodePointInGTT(ckThis.First()) && CodePointInGTT(ckThis.Second()))
			continue ;

		// Add this kerning pair's data to the list of bad data.

        cs.Format("%d", ckThis.Amount()) ;
        int idItem = clcbaddata.InsertItem(u, cs) ;
        clcbaddata.SetItemData(idItem, u) ;

        cs.Format("0x%X", ckThis.First()) ;
        clcbaddata.SetItem(idItem, 1, LVIF_TEXT, cs, -1, 0, 0, u) ;

        cs.Format("0x%X", ckThis.Second()) ;
        clcbaddata.SetItem(idItem, 2, LVIF_TEXT, cs, -1, 0, 0, u) ;

		bfoundbad = true ;
	} ;

	return bfoundbad ;
}


/******************************************************************************

  CFontInfo::CodePointInGTT

  Return true if the specified code point is in the GTT.  Otherwise, return
  false.

******************************************************************************/

bool CFontInfo::CodePointInGTT(WORD wcodepoint)
{
	int nelts = (int)m_cpaGlyphs.GetSize() ;// Number of elements in glyphs array
	int nleft, nright, ncheck ;				// Variables needed to search array
	WORD wgttcp ;

	// Try to find the codepoint in the GTT

	for (nleft = 0, nright = nelts - 1 ; nleft <= nright ; ) {
		ncheck = (nleft + nright) >> 1 ;
		
		wgttcp = ((CGlyphHandle *) m_cpaGlyphs[ncheck])->CodePoint() ;
		//TRACE("Key[%d] = '0x%x', CP = '0x%x'\n", ncheck, wgttcp, wcodepoint) ;
		
		if (wgttcp > wcodepoint)
			nright = ncheck - 1 ;
		else if (wgttcp < wcodepoint)
			nleft = ncheck + 1 ;
		else
			return true ;	//*** Return true here if match found.
	} ;							

	// Return false here because no match found.

	return false	;
}


/******************************************************************************

  CFontInfo::AddKern

  This method adds an additional kerning pair into the array. and also inserts
  it into the list view.

******************************************************************************/

void    CFontInfo::AddKern(WORD wFirst, WORD wSecond, short sAmount,
                           CListCtrl& clcView) {
    for (unsigned u = 0; u < KernCount(); u ++) {
        CKern&  ckThis = *(CKern *) m_csoaKern[u];
        if  (ckThis.Second() < wSecond)
            continue;
        if  (ckThis.Second() > wSecond)
            break;
        _ASSERT(ckThis.First() != wFirst);
        if  (ckThis.First() < wFirst)
            continue;
        break;
    }

    FD_KERNINGPAIR  fdkp = { wFirst, wSecond, sAmount };
    m_csoaKern.InsertAt(u, new CKern(fdkp));

    CString csWork;
    csWork.Format("%d", sAmount);
    int idItem = clcView.InsertItem(u, csWork);
    clcView.SetItemData(idItem, u);

    csWork.Format("0x%X", wFirst);
    clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);

    csWork.Format("0x%X", wSecond);
    clcView.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u);
    Changed();
}

/******************************************************************************

  CFontInfo::SetKernAmount

  This will change the kern amount entry for the specified item.

******************************************************************************/

void    CFontInfo::SetKernAmount(unsigned u, short sAmount) {
    if  (u >= KernCount())  return;

    CKern   &ckThis = *(CKern *) m_csoaKern[u];

    if  (sAmount == ckThis.Amount())    return;

    ckThis.SetAmount(sAmount);
    Changed();
}


/******************************************************************************

  CFontInfo::MakeKernCopy

  Make a copy of the kerning pairs table.

******************************************************************************/

void CFontInfo::MakeKernCopy()
{
	// Find out how many entries are in the kerning pairs table.

	int numkerns = m_csoaKern.GetSize() ;

	// Get rid of any entries already in the kerning copy table and set it to
	// the correct size.

	m_csoaKernCopy.RemoveAll() ;
	m_csoaKernCopy.SetSize(numkerns) ;

	// Copy the kerning pairs table entries one at a time so that a new	CKern
	// class instance can be allocated, initialized, and saved.

	CKern* pck ;
	for (int n = 0 ; n < numkerns ; n++) {
		pck = new CKern(((CKern*) m_csoaKern[n])->First(),
						((CKern*) m_csoaKern[n])->Second(),
						((CKern*) m_csoaKern[n])->Amount()) ;
		m_csoaKernCopy.SetAt(n, pck) ;
	} ;
}


/******************************************************************************

  CFontInfo::FillWidths

  This preps the passed CListCtrl, if necessary, and fills it with the
  character width information.

******************************************************************************/

void    CFontInfo::FillWidths(CListCtrl& clcView)
{
    CWaitCursor cwc;
    clcView.SetItemCount((int)m_cpaGlyphs.GetSize());
    for (int u = 0; u < m_cpaGlyphs.GetSize(); u++) {
        if  (DBCSFont() && !m_cwaWidth[u])
            continue;   //  Don't display these code points.
        CString csWork;
        CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaGlyphs[u];

        csWork.Format("%d", m_cwaWidth[u]);
        int idItem = clcView.InsertItem(u, csWork);
        clcView.SetItemData(idItem, u);

        csWork.Format("0x%04X", cghThis.CodePoint());
        clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);
    }
}


/******************************************************************************

  CFontInfo::WidthsTableIsOK

  Perform the only consistency check on the widths table that I can think of:
  Make sure that there aren't more widths in the UFM than there are Glyphs in
  the GTT.  Return true if the table appears to be ok.  Otherwise, return false.

******************************************************************************/

bool CFontInfo::WidthsTableIsOK()
{
	return (m_cwaWidth.GetSize() <=	m_cpaGlyphs.GetSize()) ;
}


/******************************************************************************

  CFontInfo::SetWidth

  This member sets the width of a glyph.  It also updates the Maximum and
  Average width information if the font is not a DBCS font and the user
  requests it.

******************************************************************************/

void    CFontInfo::SetWidth(unsigned uGlyph, WORD wWidth, bool bcalc /*=true*/)
{
    m_cwaWidth[uGlyph] = wWidth;

    if (bcalc && !DBCSFont())
        CalculateWidths();
}


/******************************************************************************

  CFontInfo::CompareGlyphsEx(WORD wOld, WORD wNew, CLinkedList* pcll)

to Do ; check the old glyph table and new, then change the old linked list 
		according to the new glyph table.

parameter : wOld, wNew ; code point index of new, old glyph table
			CLinkedList* pcll ; linked node containing the codepoint data

return : new linked list of new gtt.

******************************************************************************/

CLinkedList* CFontInfo::CompareGlyphsEx(WORD wOld, WORD wNew, CLinkedList* pcll)
{	// pcll
	static UINT_PTR  dwLinked ;
	static CLinkedList* pcllpre = NULL ;
	static CLinkedList* pclltmp = NULL ;
	static int ncOldGlyphs ; 
	static int ncNewGlyphs ; 
	
	if (wOld == 0 && wNew == 0 ) {
		dwLinked = (UINT_PTR)pcll ;
		ncNewGlyphs  = (int)m_cwaNewGlyphs.GetSize() ;
		ncOldGlyphs  = (int)m_cwaOldGlyphs.GetSize() ;
	
		}
	if (wNew >= ncNewGlyphs && wOld >= ncOldGlyphs ) {
		pcllpre = NULL ;
		return (CLinkedList*) dwLinked;
	}

	// delete at the end of the glyphs tree
	if (wOld < ncOldGlyphs && wNew >= ncNewGlyphs ) {
		pcllpre = pcll->Next ;
		delete pcll ;
		return CompareGlyphsEx(++wOld,wNew,pcllpre) ;
	}

	// add at the end of the glyphs tree
	// BUG_BUG :: this is called at the second end of the code points.
	// added coded is located between seconde end and first end.  // almost fixed. 
	if (wNew < ncNewGlyphs && wOld >= ncOldGlyphs - 1 && m_cwaOldGlyphs[wOld] <= m_cwaNewGlyphs[wNew] ) {
		
		CLinkedList* pcllnew = new CLinkedList ;
		if (!pcllnew) {
			CString csError ; 
			csError.LoadString(IDS_ResourceError) ;
			AfxMessageBox(csError,MB_ICONEXCLAMATION) ;
			return (CLinkedList*) dwLinked;		
		}
		pcllnew->data = 0 ;
		pcll->Next = pcllnew ;
		return CompareGlyphsEx(wOld,++wNew,pcll->Next) ;

	}
	
	// Delete
	if (m_cwaOldGlyphs[wOld] < m_cwaNewGlyphs[wNew] ) {
		
		if (!pcllpre || (pcllpre == pcll) ) {
			pcllpre = pcll->Next ;
			dwLinked = (UINT_PTR)pcllpre ;
			delete pcll ;	 
			return CompareGlyphsEx(++wOld, wNew,pcllpre) ;
			
		}
		else{
			if (pclltmp && pclltmp->Next == pcllpre->Next ) 
				pcllpre = pclltmp ;
			pcllpre->Next = pcll->Next ;
			delete pcll ; 
			return CompareGlyphsEx(++wOld, wNew,pcllpre->Next ) ;
		}	
	}// Add
	else if (m_cwaOldGlyphs[wOld] > m_cwaNewGlyphs[wNew] ) {
		CLinkedList * pcllnew = new CLinkedList ;

		pcllnew->data = 0 ;
		if (!pcllpre)  {
			dwLinked = (UINT_PTR) pcllnew ; 
			pcllpre = pcllnew ;
			pcllnew ->Next = pcll ;
		}
		else {  // problem when pcllnew->next == pcll
			if (pclltmp && pclltmp == pcllpre->Next ) 
				pcllpre = pclltmp ;
			pcllnew ->Next = pcllpre->Next ;

			pcllpre->Next = pcllnew ;
			pclltmp = pcllnew ;
			
		}
		return CompareGlyphsEx(wOld, ++wNew,pcllnew ->Next) ;
	} // no change
	else {
		pcllpre = pcll ;
		return CompareGlyphsEx(++wOld,++wNew,pcll->Next ) ;

	}
}





/******************************************************************************

  CFontInfo::CheckReloadWidths

  It is possible that the code points in the UFM's GTT have changed.  If that
  is the case, reload the widths info so that they can use the new code point
  info.

  Return true if the widths were reloaded.  Otherwise, return false.

  NOTE: This function uses several pieces of CFontInfo::Load().  If changes
  are made to those pieces of code, similar changes may need be made in Load()
  too.
  
  sunggch : Modify the code in order to synchronize the Widthtable with 
				GTT change (add or delete code point)
			Get m_cwaWidth from the CompareGlyphsEx instead of UFM load table
******************************************************************************/

DWORD CLinkedList::m_dwSize ;
#define MAX_CODE_COUNT 1000 
bool CFontInfo::CheckReloadWidths()
{
	// Do nothing if this class was loaded standalone or it has no GTT pointer.

	if (!m_bLoadedByWorkspace || m_pcgmTranslation == NULL)
		return false ;

	// Do nothing if the GTT has not changes since the last time the UFM's
	// widths were reloaded.

	if (m_pcgmTranslation->m_ctSaveTimeStamp <= m_ctReloadWidthsTimeStamp && !IsRCIDChanged())
		return false ;

	// Open the UFM file

    CFile cfUFM ;
    if  (!cfUFM.Open(m_cfn.FullName(), CFile::modeRead | CFile::shareDenyWrite))
		return false ;

	//  Try to load the file- proclaim defeat on any exception.

	CByteArray cbaUFM ;			// Loaded with file's contents
    try	{																			
        cbaUFM.SetSize(cfUFM.GetLength()) ;
        cfUFM.Read(cbaUFM.GetData(), (unsigned)cbaUFM.GetSize()) ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return false ;
	} ;				

    PUNIFM_HDR  pufmh = (PUNIFM_HDR) cbaUFM.GetData() ;		// UNIFM_HDR

	// Do nothing if there is no width table except update the timestamp so that
	// this code isn't executed again.

    if (pufmh->loWidthTable == NULL) {
		m_ctReloadWidthsTimeStamp = CTime::GetCurrentTime() ;
        return false ;
	} ;

    union {
		PBYTE       pbwt ;
        PWIDTHTABLE pwt ;
	} ;
	
	pbwt = cbaUFM.GetData() + pufmh->loWidthTable ;
	
	// Synchronization of UFM width and Gtt is only supported in the SBCS.
	// BUG_BUG : the interupt happend in the DBCS gtt.
	int oldGlyphs = PtrToInt((PVOID)m_cpaGlyphs.GetSize());
	m_pcgmTranslation->Collect(m_cpaGlyphs) ;		
	
	m_cwaNewGlyphs.SetSize(m_cpaGlyphs.GetSize()) ;
	
	if (!DBCSFont() && m_cpaGlyphs.GetSize() < MAX_CODE_COUNT && oldGlyphs < MAX_CODE_COUNT && m_cwaOldGlyphs.GetSize()) {
	
		for (int i = 0 ; i < m_cpaGlyphs.GetSize() ; i ++ ) {
		CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaGlyphs[i];
		m_cwaNewGlyphs.SetAt(i,cghThis.CodePoint() ) ;
		}
		CLinkedList* pcll = new CLinkedList ;
		CLinkedList* pcll_pre  = NULL ;
		UINT_PTR dwLinked = (UINT_PTR) pcll ;

		// convert WordArray into LinkedList 
		for( i = 0 ; i < m_cwaWidth.GetSize() ; i ++ ) {
			pcll->data = m_cwaWidth[i];
			pcll->Next = new CLinkedList ;  // at the end of array, it create redundant one more CLinkedList;
			pcll = pcll->Next ;
		}
	
		dwLinked = (UINT_PTR)CompareGlyphsEx(0,0,(CLinkedList* )dwLinked) ;

		int size = CLinkedList::Size() ;
		
		m_cwaWidth.RemoveAll() ;
		m_cwaWidth.SetSize(m_cwaNewGlyphs.GetSize()) ;
		ASSERT(size >= m_cwaNewGlyphs.GetSize() ) ;

		CLinkedList* pgarbage = NULL ;
		for ( pcll =(CLinkedList*) dwLinked, i = 0 ; i < m_cwaNewGlyphs.GetSize() ; i++ ,pgarbage=pcll, pcll = pcll->Next ) {
			m_cwaWidth[i] = pcll->data ;
			delete pgarbage;
		}
		
		
		m_cwaOldGlyphs.RemoveAll();
		m_cwaOldGlyphs.Copy(m_cwaNewGlyphs) ;

	}
	else {

		// Collect all the handles
		
		m_pcgmTranslation->Collect(m_cpaGlyphs) ;		
		m_cwaWidth.RemoveAll() ;

		if (m_cpaGlyphs.GetSize() > 0)
			m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize()) ;

		unsigned uWidth = (unsigned)m_cwaWidth.GetSize();												
		unsigned uWidthIdx ;

		// Build the widths table.

		for (unsigned u = 0; u < pwt->dwRunNum; u++) {
			PWORD   pwWidth = (PWORD) (pbwt + pwt->WidthRun[u].loCharWidthOffset) ;

			unsigned uGlyph = 0 ;
			for ( ; uGlyph < pwt->WidthRun[u].wGlyphCount ; uGlyph++) {
				// For whatever reason, there are times when the index value is
				// < 0 or > uWidth.  An AV would occur if m_cwaWidth were allowed
				// to be indexed by such a value.  Just keep this from happening
				// for now.  A better fix is needed.  BUG_BUG : won't fix

				//  Glyph handles start at 1, not 0!

				uWidthIdx = uGlyph + -1 + pwt->WidthRun[u].wStartGlyph ;					
				if ((int) uWidthIdx < 0) {
					//AfxMessageBox("Negative width table index") ;
					//TRACE("***Negative width table index (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					continue ;
				} else if (uWidthIdx >= uWidth) {
					//AfxMessageBox("Width table index (%d) > table size") ;
					//TRACE("***Width table index (%d) > table size (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, uWidth, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					break ;												//  rm fix VC IDE compiler problem?
				} ;

				//m_cwaWidth[uGlyph + -1 + pwt->WidthRun[u].wStartGlyph] = *pwWidth++;		//  Glyph handles start at 1, not 0!
				m_cwaWidth[uWidthIdx] = *pwWidth++;											
			} ;
		} ;

}
	// The widths were successfully reloaded so update the reload time and
	// return true.

	m_ctReloadWidthsTimeStamp = CTime::GetCurrentTime() ;
	return true ;
}


/******************************************************************************

  CFontInfo::GetFirstPFM
  CFontInfo::GetLastPFM

******************************************************************************/

WORD CFontInfo::GetFirstPFM()
{
	res_PFMHEADER    *pPFM ;
	pPFM = (res_PFMHEADER *) m_cbaPFM.GetData() ;
	return ((WORD) pPFM->dfFirstChar) ;
	//return ((WORD) ((res_PFMHEADER *) m_cbaPFM.GetData())->dfFirstChar) ;
}

WORD CFontInfo::GetLastPFM()
{
	res_PFMHEADER    *pPFM ;
	pPFM = (res_PFMHEADER *) m_cbaPFM.GetData() ;
	return ((WORD) pPFM->dfLastChar) ;
	//return ((WORD) ((res_PFMHEADER *) m_cbaPFM.GetData())->dfLastChar) ;
}




/******************************************************************************

  CFontInfoContainer class

  This class encapsulates one CFontInfo structure, and is used as a document
  class so we can leverage the MFC document/view architecture for editing this
  information both within the contet of the driver, and as a stand-alone file.

******************************************************************************/

IMPLEMENT_DYNCREATE(CFontInfoContainer, CDocument)

/******************************************************************************

  CFontInfoContainer::CFontInfoContainer()

  This constructor is used when the document is dynamically created- this will
  be when the user opens an existing font file, or creates a new one.

******************************************************************************/

CFontInfoContainer::CFontInfoContainer() {
    m_bEmbedded = FALSE;
    m_pcfi = new CFontInfo;
    m_pcfi -> NoteOwner(*this);
}

/******************************************************************************

  CFontInfoContainer::CFontInfoContainer(CFontInfo *pcfi, CString csPath) {

  This constructor is called when we invoke an editing view from the driver
  editor.  It gives us the font information to view and the name of the file
  to generate if the user decies to save the data from this view.

******************************************************************************/

CFontInfoContainer::CFontInfoContainer(CFontInfo *pcfi, CString csPath) {
    m_pcfi = pcfi;
    m_bEmbedded = TRUE;
    SetPathName(csPath, FALSE);
    m_pcfi -> NoteOwner(*this); //  Even when embedded, we're editing a file.
}

/******************************************************************************

  CFontInfoContainer::OnNewDocument

  This is an override- it is called when we are asked to create new font
  information from scratch.  For now, this will just fail.

******************************************************************************/

BOOL CFontInfoContainer::OnNewDocument() {
//	AfxMessageBox(IDS_Unimplemented);		 // raid 104822 temp
//  return  FALSE;

	return  m_pcfi && CDocument::OnNewDocument();// raid 104822  temp
}

/******************************************************************************

  CFontInfoContainer::~CFontInfoContainer

  Our erstwhile destructor must destroy the font info if this wasn't an
  embedded view; ie, the UFM was loaded standalone.  
  
  It should also destroy the font's GTT iff the UFM was loaded standalone and
  the GTT was based on a real, file-based GTT; not a code page loaded as a GTT 
  and not one of the predefined, built-in GTTs.  (In the latter case, the
  predefined GTTs are freed when the program exits.)

******************************************************************************/

CFontInfoContainer::~CFontInfoContainer()
{
	if  (!m_bEmbedded && m_pcfi) {
		int ngttid = (int) (short) m_pcfi->m_lGlyphSetDataRCID ;

		if (m_pcfi->m_pcgmTranslation && ngttid != 0)
			if ((ngttid < CGlyphMap::Wansung || ngttid > CGlyphMap::Big5) 
			 && (ngttid < CGlyphMap::CodePage863 || ngttid > CGlyphMap::CodePage437)
			 && ngttid != -IDR_CP1252)
				delete m_pcfi->m_pcgmTranslation ;
        delete  m_pcfi ;
	} ;
}


BEGIN_MESSAGE_MAP(CFontInfoContainer, CDocument)
	//{{AFX_MSG_MAP(CFontInfoContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer diagnostics

#ifdef _DEBUG
void CFontInfoContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CFontInfoContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer serialization

void CFontInfoContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) 	{
		// TODO: add storing code here
	}
	else 	{
		// TODO: add loading code here
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer commands

/******************************************************************************

  CFontInfoContainer::SaveModified
	
  o If the file is saved, get rid of the copy of the kerning pairs table.
	Otherwise, restore the saved copy of the original kerning pairs table.

******************************************************************************/

BOOL CFontInfoContainer::SaveModified()
{
	m_UFMSaved = false ;		// No save attempt made yet.

	// If the file needs to be saved prompt the user about it and do it if the
	// user concurs.  Save the result so I can tell if the document is going
	// to close.

	BOOL bclose = CDocument::SaveModified() ;

	// If the doc is not closing, just return bclose without doing anything
	// else.

	if (!bclose)
		return bclose ;

	// If the file was saved, the kerning table copy is no longer needed so zap
	// it in a way that will free all associated memory.

	if (m_UFMSaved)
		m_pcfi->m_csoaKernCopy.RemoveAll() ;

	// Otherwise, the user wants to revert back to the original kern copy.  So,
	// zap the kerning table and replace it with the copy.

	else {
		m_pcfi->m_csoaKern.RemoveAll() ;	// This frees ALL associated memory
		m_pcfi->m_csoaKern.Copy(m_pcfi->m_csoaKernCopy) ;

		// Now clear the copy in a way that will not delete the class instances
		// referenced by it because copies of those pointers are in m_csoaKern
		// now.

		CObArray* pcoacopy = m_pcfi->m_csoaKernCopy.GetCOA() ;
		pcoacopy->RemoveAll() ;
	} ;

	// Return whatever CDocument::SaveModified() returned.
	
	return bclose ;
}


/******************************************************************************

  CFontInfoContainer::PublicSaveModified

  The Class Wizard made SaveModified() a protected class and I didn't want to
  change that.  Instead, I added this routine so that outsiders can call it.

******************************************************************************/

BOOL CFontInfoContainer::PublicSaveModified()
{
	return (SaveModified()) ;
}


/******************************************************************************

  CFontInfoContainer::OnSaveDocument

  This is called in response to a Save or Save As.  We pass it directly to the
  CFontInfo for processing, rather than using the base class implementation,
  which would serialize the document.  (Actually saving the UFM is the last --
  ie, final -- thing this routine does.)

  Before the document is actually saved, validate the contents of the UFM.  If
  the UFM passes all of the checks or the user doesn't want to fix the problems,
  continue processing.  Otherwise, return FALSE to make sure the document is
  left open.

  Once the UFM has been validated, copy the data in the UFM Editor's controls
  back into the CFontInfo class instance.  New data is maintain in the editor
  until this point so that the CFontInfo class instance is not updated
  unnecessarily.  That would be a problem since the UFMs are always kept
  loaded in CFontInfo class instances.  That means that even unsaved data that
  the user wanted to discard would still be displayed the next time the UFM
  is loaded into the editor.  Keeping unsaved data in the editor allows it to
  be discarded without affecting the CFontInfo class so the problem is avoided.

******************************************************************************/

BOOL CFontInfoContainer::OnSaveDocument(LPCTSTR lpszPathName)
{
	// Get a pointer to the associate view class instance.

	POSITION pos = GetFirstViewPosition() ;
	ASSERT(pos != NULL) ;
	CFontViewer* pcfv = (CFontViewer*) GetNextView(pos) ;
	
	// Call the view class to validate the UFM's contents.  If one of the
	// checks fails and the user wants to fix it, do not close the document.
	
	// if rcid changed, upgraded the Widthtable.
	if (m_pcfi->IsRCIDChanged() && m_bEmbedded) 
		pcfv->HandleCPGTTChange(true) ;

	// validate the value of the UFMs	
	if (pcfv != NULL && pcfv->ValidateSelectedUFMDataFields())
		return FALSE ;


	// Update the UFM's fields with the new data in the editor.

	if (pcfv != NULL && pcfv->SaveEditorDataInUFM())
		return FALSE ;

	m_UFMSaved = true ;			// Indicate that an attempt to save will be made

    return m_pcfi -> Store(lpszPathName);
}


/******************************************************************************

  CFontInfoContainer::OnOpenDocument

******************************************************************************/

BOOL CFontInfoContainer::OnOpenDocument(LPCTSTR lpstrFile)
{
	// SetFileName() is just called to set a few variables.  (Since the file
	// exists, we don't need to do a creation check.)

	m_pcfi->m_cfn.EnableCreationCheck(FALSE) ;
	m_pcfi->SetFileName(lpstrFile) ;

	// Load the UFM and mark it as a file that cannot be saved.  That is the
	// case when a UFM is loaded standalone because its associated GTT is not
	// loaded too.  (Some data that is saved in the UFM comes from the GTT.)

    return m_pcfi->Load(false) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\comctrls.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	comctrls.h
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include    "FontInfo.H"

#ifndef		MDT_COMON_CONTROLS
#define		MDT_COMON_CONTROLS 1


/////////////////////////////////////////////////////////////////////////////
// The classes defined below (CEditControlEditBox, CEditControlListBox)	are
// used to implement a lighter weight, general purpose Edit control than the
// UFM Editor specific classes that are defined above.  (A normal Edit Box is
// part of this Edit Control, too.)

class CEditControlListBox ;		// Forward class declaration

/////////////////////////////////////////////////////////////////////////////
// CEditControlEditBox window

class CEditControlEditBox : public CEdit
{
	CEditControlListBox*	m_pceclb ;	// Pointer to related list box control

// Construction
public:
	CEditControlEditBox(CEditControlListBox* pceclb) ;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditControlEditBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditControlEditBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditControlEditBox)
	afx_msg void OnKillfocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CEditControlListBox window

class CEditControlListBox : public CListBox
{
	CEdit*					m_pceName ;
	CEditControlEditBox*	m_pcecebValue ;
	bool					m_bReady ;			// True iff ready for operations
	int						m_nCurSelIdx ;		// Currently selected item's index

// Construction
public:
	CEditControlListBox(CEdit* pce, CEditControlEditBox* pceceb) ;
	
// Attributes
public:

// Operations
public:
	bool Init(CStringArray& csamodels, CStringArray& csafiles, int ntabstop) ;
	void SaveValue(void) ;
	bool GetGPDInfo(CStringArray& csavalues, CStringArray* pcsanames = NULL) ;
	void SelectLBEntry(int nidx, bool bsave = false) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditControlListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditControlListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditControlListBox)
	afx_msg void OnSelchange();
	afx_msg void OnDblclk();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// The classes defined below are for the CFullEditListCtrl and CFELCEditBox 
// classes.  Together, they support a List Control in Report View
// in which subitems can be edited too, complete rows can be selected, and
// the data can be sorted by numeric or text columns.  CFELCEditBox is a
// helper class that is only used by CFullEditListCtrl.
//

/////////////////////////////////////////////////////////////////////////////
// CFELCEditBox Class

class CFELCEditBox : public CEdit
{
// Construction
public:
	CFELCEditBox() ;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFELCEditBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFELCEditBox() ;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFELCEditBox)
	afx_msg void OnKillFocus(CWnd* pNewWnd) ;
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


// The following structure(s), enumeration(s), and definitions are used with 
// CFullEditListCtrl.

typedef enum {
	COLDATTYPE_INT = 0, COLDATTYPE_STRING, COLDATTYPE_FLOAT, COLDATTYPE_TOGGLE,
	COLDATTYPE_CUSTEDIT
} COLDATTYPE ;


typedef struct _COLINFO {		// Maintains info on each column
	int			nwidth ;		// The column width
	bool		beditable ;		// True iff the column is editable
	COLDATTYPE	cdttype ;		// The type of data in the column
	bool		bsortable ;		// True iff the rows can be sorted on this column
	bool		basc ;			// True iff the column has been sort ascended
	LPCTSTR		lpctstrtoggle ;	// If toggle type, pointer to toggle string
} COLINFO, *PCOLINFO ;


#define	COMPUTECOLWIDTH		-1
#define SETWIDTHTOREMAINDER	-2


// The following flags are used to indicate the toggle state of the list's
// columns.  These values are assigned to m_dwToggleFlags.

#define	TF_HASTOGGLECOLUMNS	1	// The list has toggle column(s)
#define TF_CLICKONROW		2	// Dbl-Clking on row toggles single column
#define TF_CLICKONCOLUMN	4	// Must dbl-clk on column (cell) to toggle it


// The following flags are used to indicate which one - if any - of the list's
// column's data may be modified via a custom edit routine in the class'
// owner.  These values are assigned to m_dwCustEditFlags.
								
#define	CEF_HASTOGGLECOLUMNS	1	// The list has a custom edit column
#define CEF_CLICKONROW			2	// Dbl-Clking on row activates single column
#define CEF_CLICKONCOLUMN		4	// Must dbl-clk on cell to activate dialog


// Miscellaneous flags used to control the behaviour of CFullEditListCtrl.
// These flags are passed to InitControl() in its dwmiscflags parameter.

#define MF_SENDCHANGEMESSAGE	1	// Send WM_LISTCELLCHANGED messages
#define MF_IGNOREINSERT			2	// Ignore INS key
#define MF_IGNOREDELETE			4	// Ignore DEL key
#define MF_IGNOREINSDEL			6	// Ignore INS and DEL key


// This message is sent - when requested - to a CFullEditListCtrl class 
// instance's owner whenever a list cell is changed after the list had been
// initialized.  (Yes, this really is better than having the owner handle
// LVN_ITEMCHANGED messages.)

#define WM_LISTCELLCHANGED		(WM_USER + 999)


// A function of this type is passed to	ExtraInit_CustEditCol() and called by
// CheckHandleCustEditColumn() when nonstandard editting is needed for a 
// specific cell.

typedef bool (CALLBACK* LPCELLEDITPROC) (CObject* pcoowner, int nrow, int ncol,
						 			     CString* pcscontents) ;


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl Class

class CFullEditListCtrl : public CListCtrl
{
// Constructor
public:
	CFullEditListCtrl();
	~CFullEditListCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFullEditListCtrl)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	CFELCEditBox m_edit;

// Message maps
	//{{AFX_MSG(CFullEditListCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	PCOLINFO	m_pciColInfo ;		// Ptr to array of structs with column info
	int			m_nNumColumns ;		// The number of columns in the list
	int			m_nSortColumn ;		// Number of column being sorted
	int			m_nNextItemData ;	// Next item data number to use
	int			m_nRow ;			// Row being edited
	int			m_nColumn ;			// Column being edited
	DWORD		m_dwToggleFlags ;	// Flags indicating toggle flag for list
	DWORD		m_dwMiscFlags ;		// Misc flags used to control list's actions
	CObject*  	m_pcoOwner ;		// Pointer to class that owns this one
	DWORD 		m_dwCustEditFlags ;	// Flags describing custom edit column
	CUIntArray	m_cuiaCustEditRows ;// Array indicating specific cust edit rows
	LPCELLEDITPROC	m_lpCellEditProc ;	// Ptr to custom cell editing proc

public:
	bool CheckHandleToggleColumns(int nrow, int ncol, PCOLINFO pci) ;
	void InitControl(DWORD dwaddlexstyles, int numrows, int numcols, 
					 DWORD dwtoggleflags = 0, int neditlen = 0, 
					 int dwmiscflags = 0) ;
	int  InitLoadColumn(int ncolnum, LPCSTR strlabel, int nwidth, int nwidthpad, 
						bool beditable, bool bsortable, COLDATTYPE cdtdatatype,
				        CObArray* pcoadata, LPCTSTR lpctstrtoggle = NULL) ;
	bool ExtraInit_CustEditCol(int ncolnum, CObject* pcoowner, 
							   DWORD dwcusteditflags, 
							   CUIntArray& cuiacusteditrows,
							   LPCELLEDITPROC lpcelleditproc) ;
	bool CheckHandleCustEditColumn(int nrow, int ncol, PCOLINFO pci) ;
	BOOL GetPointRowCol(LPPOINT lpPoint, int& iRow, int& iCol, CRect& rect) ;
	BOOL GetColCellRect(LPPOINT lpPoint, int& iRow, int& iCol, CRect& rect) ;
	bool SaveValue() ;
	void HideEditBox() ;
	bool GetColumnData(CObArray* pcoadata, int ncolnum) ;
	bool SetColumnData(CObArray* pcoadata, int ncolnum) ;
	static int CALLBACK SortListData(LPARAM lp1, LPARAM lp2, LPARAM lp3) ;
	bool SortControl(int nsortcolumn) ;
	void SingleSelect(int nitem) ;
	bool GetRowData(int nrow, CStringArray& csafields) ;
	int	 GetNumColumns() { return m_nNumColumns ; } 
	bool GetColSortOrder(int ncol) { 
		ASSERT(ncol >= 0 && ncol <= m_nNumColumns) ;
		return ((m_pciColInfo + ncol)->basc) ;
	} ;
	bool EndEditing(bool bsave) ;
	bool EditCurRowSpecCol(int ncolumn) ;
	int	 GetCurRow() { return m_nRow ; }
	void SetCurRow(int nrow) ;
	int	 GetCurCol() { return m_nColumn ; }
	void SendChangeNotification(int nrow, int ncol)	;
} ;


/////////////////////////////////////////////////////////////////////////////
// CFlagsListBox window

class CFlagsListBox : public CListBox
{
// Construction
public:
	CFlagsListBox();

// Attributes
public:
	bool		m_bReady ;				// True iff listbox has been initialized
	CUIntArray	m_cuiaFlagGroupings ;	// Flag groupings array
	int			m_nGrpCnt ;				// Number of flag groupings
	CString		m_csSetString ;			// String used to indicate a bit is set
	int			m_nNumFields ;			// Number of flag fields in list box
	bool		m_bNoClear ;			// True iff can't clear flags directly
	int			m_nNoClearGrp ;			// Group for which m_bNoClear applies

// Operations
public:
	bool Init(CStringArray& csafieldnames, DWORD dwsettings, 
			  CUIntArray& cuiaflaggroupings, int ngrpcnt, 
			  LPTSTR lptstrsetstring, int ntabstop, bool bnoclear = false,
			  int nocleargrp = -1) ;
	bool Init2(CStringArray& csafieldnames, CString* pcssettings, 
			  CUIntArray& cuiaflaggroupings, int ngrpcnt, 
			  LPTSTR lptstrsetstring, int ntabstop, bool bnoclear = false,
			  int nocleargrp = -1) ;
	DWORD GetNewFlagDWord()	;
	void GetNewFlagString(CString* pcsflags, bool badd0x = true) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFlagsListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFlagsListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFlagsListBox)
	afx_msg void OnDblclk();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif	// #define MDT_COMON_CONTROLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\convert.c ===
/******************************************************************************

  Source File:	Convert.C

  This is an NT Build hack.  It includes all of the "C" files used for the
  converter, because Build can't handle directories beyond ..

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved

  A Pretty Penny Enterprises Production

  Change History:

  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Did the dirty deed

******************************************************************************/

#include	"..\GPC2GPD\PrEntry.C"
#include	"..\GPC2GPD\UiEntry.C"
#include	"..\GPC2GPD\Utils.C"
#include    "..\GPC2GPD\GPC2GPD.C"

VOID
CopyStringA(
    OUT PSTR    pstrDest,
    IN PCSTR    pstrSrc,
    IN INT      iDestSize
    )

/*++
 *
 * Routine Description:
 * 
 *     Copy ANSI string from source to destination
 *     
 * Arguments:
 *     
 *     pstrDest - Points to the destination buffer
 *     pstrSrc - Points to source string
 *     iDestSize - Size of destination buffer (in characters)
 *                 
 * Return Value:
 *                 
 *     NONE
 *                     
 * Note:
 *                     
 *     If the source string is shorter than the destination buffer,
 *     unused chars in the destination buffer is filled with NUL.
 *                             
 *
--*/

{
    PSTR    pstrEnd;

    ASSERT(pstrDest && pstrSrc && iDestSize > 0);
    pstrEnd = pstrDest + (iDestSize - 1);

    while ((pstrDest < pstrEnd) && (*pstrDest++ = *pstrSrc++) != NUL)
        NULL;

    while (pstrDest <= pstrEnd)
        *pstrDest++ = NUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontview.cpp ===
/******************************************************************************

  Source File:  Font Viewer.CPP

  This implements the various classes that make up the font editor for the
  studio.  The editor is basically a property sheet with a sizable collection
  of pages.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-05-1997    Bob_Kjelgaard@Prodigy.Net



	NOTES:		an FWORD is a short int

	The PANOSE structure describes the PANOSE font-classification values for a TrueType font.
	These characteristics are then used to associate the font with other fonts of similar appearance but different names.

	typedef struct tagPANOSE { // pnse
		BYTE bFamilyType;
		BYTE bSerifStyle;
		BYTE bWeight;
		BYTE bProportion;
		BYTE bContrast;
		BYTE bStrokeVariation;
		BYTE bArmStyle;
		BYTE bLetterform;
		BYTE bMidline;
		BYTE bXHeight;
	} PANOSE


******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "ChildFrm.H"    //  Definition of Tool Tips Property Page class
#include    "comctrls.h"
#include	<stdlib.h>
#include    "FontView.H"	//  FontView.H also includes comctrls.h
#include	"rcfile.h"


/******************************************************************************

  CFontViewer class- this is the guy who owns the overall control of the view,
  although he wisely delegates the work to the MFC Property Sheet class and the
  other view classes.  I should be so wise.

******************************************************************************/

IMPLEMENT_DYNCREATE(CFontViewer, CView)

CFontViewer::CFontViewer() {
}

CFontViewer::~CFontViewer() {
}


BEGIN_MESSAGE_MAP(CFontViewer, CView)
	//{{AFX_MSG_MAP(CFontViewer)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontViewer drawing

void CFontViewer::OnDraw(CDC* pDC) {	CDocument* pDoc = GetDocument();}

CFontInfo   * gpCFontInfo;

/******************************************************************************

  CFontViewer::OnInitialUpdate

  This handles the initial update of the view, meaning all of the background
  noise of creation is essentially complete.

  I initialize the property pages by pointing each to the underlying CFontInfo,
  add them to the property sheet as needed, then create the sheet, position it
  so it aligns with the view, then adjust the owning frame's size and style so
  that everything looks like it really belongs where it is.

******************************************************************************/

void CFontViewer::OnInitialUpdate()
{
	CFontInfo   *pcfi = GetDocument()->Font();

	gpCFontInfo = pcfi;

    if  (pcfi->Name().IsEmpty())
		{
        pcfi->Rename(GetDocument()->GetTitle());
        GetDocument()->SetModifiedFlag(FALSE);			//  Rename sets it
		}

    m_cps.Construct(IDR_MAINFRAME, this);

    // Each property page needs a pointer to the fontinfo class

    m_cfhp.Init(pcfi, (CFontInfoContainer*) GetDocument(), this);
    m_cfimp.Init(pcfi);
    m_cfemp.Init(pcfi);
    m_cfwp.Init(pcfi);
    m_cfkp.Init(pcfi);

	// Add each property page to the property sheet
    m_cps.AddPage(&m_cfhp);
    m_cps.AddPage(&m_cfimp);
    m_cps.AddPage(&m_cfemp);
    m_cps.AddPage(&m_cfwp);
    m_cps.AddPage(&m_cfkp);

	//  Create the property sheet

    m_cps.Create(this, WS_CHILD, WS_EX_CLIENTEDGE);

    //  Get the bounding rectangle, and use it to set the frame size,
    //  after first using it to align the origin with this view.

    CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	// Position property sheet within the child frame

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);								
																			
    GetParentFrame()->CalcWindowRect(crPropertySheet);
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	CView::OnInitialUpdate();
    m_cps.ShowWindow(SW_SHOWNA);
  //  GetParentFrame() -> ShowWindow(SW_SHOW);
}


/******************************************************************************

  CFontViewer::OnActivateView

  For some reason, the property sheet does not get the focus when the frame is
  activated (probably the view class takes it away from us).  This little gem
  makes sure keyboard users don't get miffed by this.

******************************************************************************/

void    CFontViewer::OnActivateView(BOOL bActivate, CView* pcvActivate,CView* pcvDeactivate)
{
    //  In case the base class does anything else of value, pass it on...

	CView::OnActivateView(bActivate, pcvActivate, pcvDeactivate);

    if  (bActivate)
        m_cps.SetFocus();
}


/******************************************************************************

  CFontViewer::OnDestroy

  This override is used to inform the embedded font that we are being
  destroyed.  If we were created by the font, then it will NULL its pointer
  to us, and won't try to destroy us when it is destroyed.

******************************************************************************/

void CFontViewer::OnDestroy()
{
	CView::OnDestroy();
	
	if  (GetDocument() -> Font())
        GetDocument() -> Font() -> OnEditorDestroyed();
}


/******************************************************************************

  CFontViewer::ValidateUFM

  This routine manages UFM field validation.  The data to be validated is in
  the controls on the property pages and in various other member variables
  because this is the data the user has just modified.  It is the most up to
  data.  Data is not saved back into the CFontInfo class until the user closes
  the document (essentially, the UFM Editor) and says to save its contents.

  Each page function is called to perform the validation on the fields diplayed
  on its page.  If a check fails and the user wants to fix the problem, true
  is returned.  Otherwise, false is returned.

  Note:
	Not every field in the UFM is validated.  Only those specified by Ganesh
	Pandey, MS Printer Driver Development team, are checked.  The fields are
	listed in the Minidriver Development Tool Work List revision 5.  See the
	ValidateUFMFields() routines in each page clase for more details.

******************************************************************************/
				
bool CFontViewer::ValidateSelectedUFMDataFields()
{
	// Validate data on the headers page.

	if (m_cfhp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfhp) ;
		m_cfhp.m_cfelcUniDrv.SetFocus() ;
		return true ;
	} ;

	// Validate data on the IFIMetrics page.

	if (m_cfimp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfimp) ;
		return true ;
	} ;

	// Validate data on the ExtMetrics page.

	if (m_cfemp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfemp) ;
		m_cfemp.m_cfelcExtMetrics.SetFocus() ;
		return true ;
	} ;

	// Validate data on the widths page.

	if (m_cfwp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfwp) ;
		return true ;
	} ;

	// Validate data on the kerning pairs page.

	if (m_cfkp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfkp) ;
		return true ;
	} ;

	// All checks passed or the user doesn't want to fix the problems...

	return false ;
}


/******************************************************************************

  CFontViewer::SaveEditorDataInUFM

  Manage saving all editor data.  By "save", I mean copy all of the data
  collected in the UFM Editor's controls back into the correct variables and
  structures in the CFontInfo class instance associated with this instance of
  the UFM Editor.  See CFontInfoContainer::OnSaveDocument() for	more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/
				
bool CFontViewer::SaveEditorDataInUFM()
{
	// Save data on the headers page.

	if (m_cfhp.SavePageData())
		return true ;

	// Save data on the IFIMetrics page.

	if (m_cfimp.SavePageData())
		return true ;

	// Save data on the ExtMetrics page.

	if (m_cfemp.SavePageData())
		return true ;

	// Save data on the widths page.

	if (m_cfwp.SavePageData())
		return true ;

	// Save data on the kerning pairs page.

	if (m_cfkp.SavePageData())
		return true ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CFontViewer::HandleCPGTTChange


******************************************************************************/

void CFontViewer::HandleCPGTTChange(bool bgttidchanged)
{
	// Get a ptr to the doc class and a pointer to the font class.

	CFontInfoContainer* pcfic = GetDocument() ;
	CFontInfo *pcfi = pcfic->Font();

	// Save the UFM.  Bail if this doesn't work for some reason.

	// If the UFM was loaded stand alone and there is a GTT to free, do it.
	// (Code pages loaded as GTTs are not freed here.  That is done at program
	// exit.)  Always clear the GTT pointer.

    if  (!pcfic->m_bEmbedded && pcfi) {
		if (pcfi->m_pcgmTranslation && pcfi->m_lGlyphSetDataRCID != 0)
			delete pcfi->m_pcgmTranslation ;
	} ;
	pcfi->m_pcgmTranslation = NULL ;

	// If the UFM was loaded from a workspace, try to use the workspace data to
	// find and load a pointer to the new GTT and finish loading the font.

	if (pcfic->m_bEmbedded) {
	    CDriverResources* pcdr = (CDriverResources*) pcfi->GetWorkspace() ;
		pcdr->LinkAndLoadFont(*pcfi, false, true ) ; // raid 0003

	// If the UFM was loaded stand alone the first time, reload it the same way
	// and let the load routine handle finding the GTT info.

	} else
		pcfi->Load(false) ;

	// If the widths page has been initialized already, reload the widths list
	// control with the updated data and reset the associated member variables.
	pcfi->CheckReloadWidths() ;
	pcfi->SetRCIDChanged(false) ;
	// check the widthtable existence instead initializ of the  m_clcView
//	if (m_cfwp.m_bInitDone) {	raid 0003
	if (m_cfwp.m_bInitDone) {
		m_cfwp.InitMemberVars() ;
		m_cfwp.m_clcView.DeleteAllItems() ;
		pcfi->FillWidths(m_cfwp.m_clcView) ;
		m_cfwp.m_clcView.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED,
									   LVIS_SELECTED | LVIS_FOCUSED) ;
	} ;

	// If the kerning page has been initialized already, reload the kerning list
	// control with the updated data and reset the associated member variables.

	if (m_cfkp.m_bInitDone) {
		m_cfkp.InitMemberVars() ;
		m_cfkp.m_clcView.DeleteAllItems() ;
		pcfi->FillKern(m_cfkp.m_clcView) ;
		pcfi->MakeKernCopy() ;
	} ;

	// Check the state of the widths and kerning tables.  Then display the
	// results.

	CWidthKernCheckResults cwkcr(pcfi) ;
	cwkcr.DoModal() ;
}


/******************************************************************************

  CheckUFMString, CheckUFMGrter0, CheckUFMNotEq0, CheckUFMBool

  These 4 routines are used to optimize UFM validation checks.  Each one does
  a different kind of check.  If the check fails, an error message is displayed.
  If the user wants to fix the problem, the routine will select the appropriate
  field and return true.  Otherwise, they return false.

  CheckUFMBool is different in one respect.  The comparison is maded in the
  calling function and the result is passed to CheckUFMBool as a parameter.

******************************************************************************/

bool CheckUFMString(CString& csdata, CString& cspage, LPTSTR pstrfieldname,
					int nfld, CFullEditListCtrl& cfelc)
{
	csdata.TrimLeft() ;
	csdata.TrimRight() ;

	if (csdata.GetLength() == 0) {
		CString csmsg ;
		csmsg.Format(IDS_EmptyStrError, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

		
bool CheckUFMGrter0(CString& csdata, CString& cspage, LPTSTR pstrfieldname,
					int nfld, CFullEditListCtrl& cfelc)
{
	if (atoi(csdata) <= 0) {
		CString csmsg ;
		csmsg.Format(IDS_LessEqZeroError, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

	
bool CheckUFMNotEq0(int ndata, CString& cspage, LPTSTR pstrfieldname,
					int nfld, CFullEditListCtrl& cfelc)
{
	if (ndata == 0) {
		CString csmsg ;
		csmsg.Format(IDS_EqualsZeroError, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

	
bool CheckUFMBool(bool bcompres, CString& cspage, LPTSTR pstrfieldname,
				  int nfld, CFullEditListCtrl& cfelc, int nerrorid)
{
	if (bcompres) {
		CString csmsg ;
		csmsg.Format(nerrorid, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

	
/******************************************************************************

  CFontWidthsPage property page class

  This class handles the UFM editor Character Widths page.  It is derived from
  the Tool Tip Page class.  The page consists of a list view control in which
  the code points and their associated widths are displayed.

******************************************************************************/

/******************************************************************************

  CFontWidthsPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lp3)

  This is a private static member function- a callback for sorting the list.
  The first two parameters are the LPARAM members of two list view items- in
  this case, the indices of two code points.  The final one is supplied by the
  caller of the sort routine.  In this case, it is a pointer to the caller.

  Handling it is trivial- dereference the this pointer, and let the private
  member function for sorting handle it.

******************************************************************************/

int CALLBACK    CFontWidthsPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lp3) {
    CFontWidthsPage *pcfwp = (CFontWidthsPage *) lp3;
    _ASSERT(pcfwp);

    return  pcfwp -> Sort(lp1, lp2);
}

/******************************************************************************

  CFontWidthsPage::Sort(unsigned id1, unsigned id2)

  This is a private member function which compares the two glyph handles at the
  two indices given by the established sort criteria.

  It returns negative for 1 < 2, positive for 1 > 2, and 0 for 1 = 2- pretty
  standard stuff.

  The sort column member determines the order of precedence in which the
  sorting is to be done, while the SortDescending member is a bitfield showing
  the sort direction in each column.

*******************************************************************************/

int CFontWidthsPage::Sort(UINT_PTR id1, UINT_PTR id2) {

    //  If the Primnary sort is by widths- weed it out first.

    if  (!m_iSortColumn)
        switch  (m_pcfi -> CompareWidths((unsigned)id1, (unsigned)id2)) {
        case    CFontInfo::More:
            return  (m_bSortDescending & 1) ? -1 : 1;
        case    CFontInfo::Less:
            return  (m_bSortDescending & 1) ? 1 : -1;
        }

    //  Sort is by Unicode point- this is always well-ordered
    //  Furthermore, the glyph handles are always in ascending order, making
    //  This test trivial.

    return  (!(m_bSortDescending & 2) ^ (id1 < id2)) ? 1 : -1;
}


CFontWidthsPage::CFontWidthsPage() : CToolTipPage(CFontWidthsPage::IDD)
{
	//{{AFX_DATA_INIT(CFontWidthsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = false;
	m_uHelpID = HID_BASE_RESOURCE + IDR_FONT_VIEWER ;
    InitMemberVars() ;
}


/******************************************************************************

  CFontWidthsPage::InitMemberVars

  Initialize the member variables that must be initialized both during
  construction and when the UFM is reloaded because of a GTT or CP change.

******************************************************************************/

void CFontWidthsPage::InitMemberVars()
{
    m_bSortDescending = 0;
    m_iSortColumn = 1;
}


CFontWidthsPage::~CFontWidthsPage() {
}


void CFontWidthsPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontWidthsPage)
	DDX_Control(pDX, IDC_CharacterWidths, m_clcView);
	//}}AFX_DATA_MAP
}


/******************************************************************************

  CFontWidthsPage::OnSetActive

  This member will be called by the framework when the page is made active.
  The base class gets this first, and it will initialize everything the first
  time.

  This is here to update the view on subsequent activations, so we can
  seamlessly handle changes from fixed to variable pitch and back.

******************************************************************************/

BOOL    CFontWidthsPage::OnSetActive() {
    if  (!CToolTipPage::OnSetActive())
        return  FALSE;

    //  IsVariableWidth is either 0 or 1, so == is safe, here
	
    if  (m_pcfi -> IsVariableWidth() == !!m_clcView.GetItemCount())
        return  TRUE;   //  Everything is copacetic
	
    if  (m_clcView.GetItemCount())
        m_clcView.DeleteAllItems();
    else
        m_pcfi -> FillWidths(m_clcView);

    m_clcView.EnableWindow(m_pcfi -> IsVariableWidth());

    return  TRUE;
}

BEGIN_MESSAGE_MAP(CFontWidthsPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontWidthsPage)
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_CharacterWidths, OnEndlabeleditCharacterWidths)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CharacterWidths, OnColumnclickCharacterWidths)
	ON_NOTIFY(LVN_KEYDOWN, IDC_CharacterWidths, OnKeydownCharacterWidths)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontWidthsPage message handlers

/******************************************************************************

  CFontWidthsPage::OnInitDialog

  This member function initializes the list view and fills it with the font
  width information.  Before doing this, check to see if the font's width info
  should be reloaded.  (See CFontInfo::CheckReloadWidths() for more info.)

******************************************************************************/

BOOL CFontWidthsPage::OnInitDialog()
{
	CToolTipPage::OnInitDialog();
	
	m_pcfi->CheckReloadWidths()  ;	// Update font width info when necessary

    CString csWork;
    csWork.LoadString(IDS_WidthColumn0);

    m_clcView.InsertColumn(0, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 0);

    csWork.LoadString(IDS_WidthColumn1);

    m_clcView.InsertColumn(1, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 1);
	
    m_pcfi -> FillWidths(m_clcView);
    m_clcView.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED,
        LVIS_SELECTED | LVIS_FOCUSED);
	
	m_bInitDone = true ;
	return TRUE;
}



/******************************************************************************

  CFontWidthsPage::OnEndlabeleditCharacterWidths

  This is where we find out the user actually wanted to change the width of a
  character.  So, not too surprisingly, we do just that (and also update the
  maximum and average widths if this isn't a DBCS font).

******************************************************************************/

void CFontWidthsPage::OnEndlabeleditCharacterWidths(NMHDR* pnmh, LRESULT* plr)
{
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;
	
	*plr = 0;   //  Assume failure

    if  (!plvdi -> item.pszText) //  Editing canceled?
        return;

	// Get and trim the new width string.

    CString csNew(plvdi -> item.pszText);
    csNew.TrimRight();
    csNew.TrimLeft();

	// Complain if the new width contains invalid characters.

    if  (csNew.SpanIncluding("1234567890").GetLength() != csNew.GetLength()) {
        AfxMessageBox(IDS_InvalidNumberFormat);
        return;
    }

	// Do not update the CFontInfo class now anymore.  This should be done
	// later.  We should mark the class as having changed so that we are
	// prompted to save this data later.

    //m_pcfi -> SetWidth(plvdi -> item.iItem, (WORD) atoi(csNew));
	m_pcfi -> Changed() ;
    *plr = TRUE;
}


/******************************************************************************

  CFontWidthsPage::OnColumnClickCharacterWidths

  This little ditty tells us one of the column headers was clicked.  We
  obligingly either change sort direction or precednce to match, and then sort
  the list.

******************************************************************************/

void CFontWidthsPage::OnColumnclickCharacterWidths(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    if  (m_iSortColumn == pnmlv -> iSubItem)
        m_bSortDescending ^= 1 << m_iSortColumn;    //  Flip sort direction
    else
        m_iSortColumn = pnmlv -> iSubItem;

    m_clcView.SortItems(Sort, (LPARAM) this);    //  Sort the list!
	
	*plr = 0;
}

/******************************************************************************

  CFontWidthsPage::OnKeydownCharacterWidths

  I'd hoped to do thiw when ENTER was pressed, but finding out which class is
  eating the keystroke took too long.  Here, we look for F2 as the key to
  signal the need to edit the width of interest.

  Pretty straightforward- find out who has the focus and is selected, and edit
  their label.

******************************************************************************/

void    CFontWidthsPage::OnKeydownCharacterWidths(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN * plvkd = (LV_KEYDOWN *) pnmh;

	*plr = 0;

    if  (plvkd -> wVKey != VK_F2)
        return;

    int idItem = m_clcView.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);

    if  (idItem == -1)
        return;

    CEdit   *pce = m_clcView.EditLabel(idItem);

    if  (pce)
        pce -> ModifyStyle(0, ES_NUMBER);
}


/******************************************************************************

  CFontWidthsPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

******************************************************************************/

bool CFontWidthsPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// Only verify widths if this is a variable pitch font.

	if (!m_pcfi->IsVariableWidth())
		return false ;

	// If there are no widths, there is nothing to validate.

	int numitems = m_clcView.GetItemCount() ;
	if (numitems == 0)
		return false ;

	// Loop through each width

	LV_ITEM lvi ;
	lvi.mask = LVIF_TEXT ;
	lvi.iSubItem = 0 ;
	char acitemtext[16] ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 15 ;
	CString csmsg ;
	for (int n = 0 ; n < numitems ; n++) {
		// Get info about the item

		lvi.iItem = n ;
		m_clcView.GetItem(&lvi) ;

		// Make sure each width is > 0.

		if (atoi(lvi.pszText) <= 0) {
			csmsg.Format(IDS_BadWidth, n) ;
			if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
				m_clcView.SetItemState(n, LVIS_SELECTED | LVIS_FOCUSED,
									   LVIS_SELECTED | LVIS_FOCUSED) ;
				m_clcView.EnsureVisible(n, false) ;
				m_clcView.SetFocus() ;
				return true ;
			} ;
		} ;
	} ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontWidthsPage::SavePageData

  Save the data in the widths page back into the CFontInfo class instance that
  was used to load this page.  See CFontInfoContainer::OnSaveDocument() for
  more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontWidthsPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// If there are no widths, there is nothing to save.

	int numitems = m_clcView.GetItemCount() ;

	if (numitems == 0)
		return false ;

	// Prepare to save the widths

	LV_ITEM lvi ;
	lvi.mask = LVIF_TEXT ;
	lvi.iSubItem = 0 ;
	char acitemtext[16] ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 15 ;
	numitems-- ;

	// Loop through each width
	
	for (int n = 0 ; n <= numitems ; n++) {
		// Get info about the item

		lvi.iItem = n ;
		m_clcView.GetItem(&lvi) ;

		// Save the current width.  When the last width is saved, make sure that
		// the new average width is calculated.

		m_pcfi->SetWidth(n, (WORD) atoi(lvi.pszText), (n == numitems)) ;
	} ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CAddKernPair dialog class

  This class handles the dialog displayed when the user wishes to add a kern
  pair to the kern pair array.

  This class is used by the CFontKerningPage class

******************************************************************************/

class CAddKernPair : public CDialog {
    CSafeMapWordToOb    &m_csmw2oFirst, &m_csmw2oSecond;
    CWordArray          &m_cwaPoints;
    WORD                m_wFirst, m_wSecond;

// Construction
public:
	CAddKernPair(CSafeMapWordToOb& cmsw2o1, CSafeMapWordToOb& cmsw2o2,
        CWordArray& cwaPoints, CWnd* pParent);

    WORD    First() const { return m_wFirst; }
    WORD    Second() const { return m_wSecond; }

// Dialog Data
	//{{AFX_DATA(CAddKernPair)
	enum { IDD = IDD_AddKernPair };
	CButton	m_cbOK;
	CComboBox	m_ccbSecond;
	CComboBox	m_ccbFirst;
	short     	m_sAmount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddKernPair)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddKernPair)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeKernFirst();
	afx_msg void OnSelchangeKernSecond();
	afx_msg void OnChangeKernAmount();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAddKernPair::CAddKernPair(CSafeMapWordToOb& csmw2o1,
                           CSafeMapWordToOb& csmw2o2, CWordArray& cwaPoints,
                           CWnd* pParent)
	: CDialog(CAddKernPair::IDD, pParent), m_csmw2oFirst(csmw2o1),
    m_csmw2oSecond(csmw2o2), m_cwaPoints(cwaPoints) {
	//{{AFX_DATA_INIT(CAddKernPair)
	m_sAmount = 0;
	//}}AFX_DATA_INIT
    m_wFirst = m_wSecond = 0;
}

void CAddKernPair::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddKernPair)
	DDX_Control(pDX, IDOK, m_cbOK);
	DDX_Control(pDX, IDC_KernSecond, m_ccbSecond);
	DDX_Control(pDX, IDC_KernFirst, m_ccbFirst);
	DDX_Text(pDX, IDC_KernAmount, m_sAmount);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddKernPair, CDialog)
	//{{AFX_MSG_MAP(CAddKernPair)
	ON_CBN_SELCHANGE(IDC_KernFirst, OnSelchangeKernFirst)
	ON_CBN_SELCHANGE(IDC_KernSecond, OnSelchangeKernSecond)
	ON_EN_CHANGE(IDC_KernAmount, OnChangeKernAmount)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddKernPair message handlers

/******************************************************************************

  CAddKernPair::OnInitDialog

  This member function initializes the dialog box, by filling both combo boxes,
  and disabling the OK button.

******************************************************************************/

BOOL    CAddKernPair::OnInitDialog() {
    CDialog::OnInitDialog();    //  Initialize everything

    //  Fill in the first combo box

    CString csWork;
	int rm = (int)m_cwaPoints.GetSize();	// rm
    for (int i = 0; i < m_cwaPoints.GetSize(); i++) {
        csWork.Format("%4.4X", m_cwaPoints[i]);
        int id = m_ccbFirst.AddString(csWork);
        m_ccbFirst.SetItemData(id, m_cwaPoints[i]);
    }

    m_ccbFirst.SetCurSel(0);
    OnSelchangeKernFirst(); //  Fill the second box with this code.

    m_cbOK.EnableWindow(FALSE);

	return  TRUE;
}

/******************************************************************************

  CAddKernPair::OnSelchangeKernFirst

  This member is called whenever the selection changes in the first character
  combo box.  It screens out any already paired characters from the second
  character combo box, while preserving the currently selected character (if
  possible).

******************************************************************************/

void    CAddKernPair::OnSelchangeKernFirst() {
	int id = m_ccbFirst.GetCurSel();

    if  (id < 0)
        return;

    m_wFirst = (WORD) m_ccbFirst.GetItemData(id);

    //  See which character is selected in the second box, so we can keep it
    //  if it is still valid.

    id = m_ccbSecond.GetCurSel();

    m_wSecond = (id > -1) ? (WORD) m_ccbSecond.GetItemData(id) : 0;
    m_ccbSecond.ResetContent();
    CString csWork;

    for (id = 0; id < m_cwaPoints.GetSize(); id++) {

        union {
            CObject *pco;
            CMapWordToDWord *pcmw2dFirst;
        };

        DWORD   dwIgnore;

        if  (m_csmw2oFirst.Lookup(m_wFirst, pco) &&
            pcmw2dFirst -> Lookup(m_cwaPoints[id], dwIgnore)) {
            //  There is already a kern pair for this second point
            //  Don't include it in the list, and drop it if it is
            //  the currently selected second point.
            if  (m_wSecond == m_cwaPoints[id])
                m_wSecond = 0;
            continue;
        }

        csWork.Format("%4.4X", m_cwaPoints[id]);

        int id2 = m_ccbSecond.AddString(csWork);
        m_ccbSecond.SetItemData(id2, m_cwaPoints[id]);
        if  (m_wSecond == m_cwaPoints[id])
            m_ccbSecond.SetCurSel(id2);
    }

    if  (!m_wSecond) {
        m_ccbSecond.SetCurSel(0);
        m_wSecond = (WORD) m_ccbSecond.GetItemData(0);
    }
}

/******************************************************************************

  CAddKernPair::OnSelchangeKernSecond

  This member is called whenever the selection changes in the second character
  combo box.  It screens out any already paired characters from the first
  character combo box, while preserving the currently selected character (if
  possible).

******************************************************************************/

void    CAddKernPair::OnSelchangeKernSecond() {
	int id = m_ccbSecond.GetCurSel();

    if  (id < 0)
        return;

    m_wSecond = (WORD) m_ccbSecond.GetItemData(id);

    //  See which character is selected in the first box, so we can keep it
    //  if it is still valid.

    id = m_ccbFirst.GetCurSel();

    m_wFirst = (id > -1) ? (WORD) m_ccbFirst.GetItemData(id) : 0;
    m_ccbFirst.ResetContent();

    CString csWork;

    for (id = 0; id < m_cwaPoints.GetSize(); id++) {

        union {
            CObject *pco;
            CMapWordToDWord *pcmw2dSecond;
        };

        DWORD   dwIgnore;

        if  (m_csmw2oSecond.Lookup(m_wSecond, pco) &&
            pcmw2dSecond -> Lookup(m_cwaPoints[id], dwIgnore)) {
            //  There is already a kern pair for this first point
            //  Don't include it in the list, and drop it if it is
            //  the currently selected first point.
            if  (m_wFirst == m_cwaPoints[id])
                m_wFirst = 0;
            continue;
        }

        csWork.Format("%4.4X", m_cwaPoints[id]);

        int id2 = m_ccbFirst.AddString(csWork);
        m_ccbFirst.SetItemData(id2, m_cwaPoints[id]);
        if  (m_wFirst == m_cwaPoints[id])
            m_ccbFirst.SetCurSel(id2);
    }

    if  (!m_wFirst) {
        m_ccbFirst.SetCurSel(0);
        m_wFirst = (WORD) m_ccbFirst.GetItemData(0);
    }
}

/******************************************************************************

  CAddKernPair::OnChangeKernAmount

  This member gets called when a change is made to the amount edit box.  It
  enables the OK button if a non-zero amount seems to be there.  The DDX/DDV
  functions called from OnOK (by default) will handle any garbage that may
  have been entered, so this needn't be a complete screen.

******************************************************************************/

void    CAddKernPair::OnChangeKernAmount() {

    //  Don't use DDX/DDV, as it will complain if the user's just typed a
    //  minus sign. All we care about is the amount is non-zero, so we can
    //  enable/disable the OK button, as needed.
	// raid 27265
	INT iValue = (INT) GetDlgItemInt(IDC_KernAmount);
	if (iValue < -32767 || iValue > 32767 )
		iValue = 0;					// end raid
    m_cbOK.EnableWindow(!! iValue );// GetDlgItemInt(IDC_KernAmount));
}

/******************************************************************************

  CFontKerningPage class

  This class handles the font kerning page- the UI here consists of a list view
  showing the pairs- the view can be sorted several ways, and pairs can be
  added or deleted.

******************************************************************************/

/******************************************************************************

  CFontKerningPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis)

  This is a static private function used to interface the listview's sort
  callback requirements (to which this adheres) to the classes sort routine,
  which follows.

******************************************************************************/

int CALLBACK    CFontKerningPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis) {
    CFontKerningPage    *pcfkp = (CFontKerningPage *) lpThis;

    return  pcfkp -> Sort((unsigned)lp1, (unsigned)lp2);
}

/******************************************************************************

  CFontKerningPage::Sort(unsigned u1, unsigned u2)

  This member returns -1, 0, 0r 1 to indiciate if the kern pair at index u1 is
  less than, equal to, or greater than the pair at u2, respectively.  The sort
  criteria are based on the internal control members.

******************************************************************************/

int CFontKerningPage::Sort(unsigned u1, unsigned u2) {
    for (unsigned u = 0; u < 3; u++) {
        switch  (m_uPrecedence[u]) {
        case    Amount:
            switch  (m_pcfi -> CompareKernAmount(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 1) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 1) ? -1 : 1;
            }
            continue;   //  If they are equal

        case    First:
            switch  (m_pcfi -> CompareKernFirst(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 2) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 2) ? -1 : 1;
            }
            continue;   //  If they are equal

        default:    //  Assume this is always second
            switch  (m_pcfi -> CompareKernSecond(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 4) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 4) ? -1 : 1;
            }
            continue;   //  If they are equal
        }
    }

	// Tell the user that there is something wrong with the kerning table
	// instead of asserting.

    //_ASSERT(FALSE);
	CString csmsg ;
	csmsg.Format(IDS_BadKernPairError, u1, m_pcfi->GetKernAmount(u1),
				 m_pcfi->GetKernFirst(u1), m_pcfi->GetKernSecond(u1)) ;
	AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;

    return  0;  //  This should never happen- two items should never be equal
}


/******************************************************************************

  CFontKerningPage Constructor, destructor, message map, and DDX/DDV.

  Except for some trivial construction, all of this is pretty standard MFC
  wizard-maintained stuff.

******************************************************************************/

CFontKerningPage::CFontKerningPage() : CToolTipPage(CFontKerningPage::IDD)
{
	//{{AFX_DATA_INIT(CFontKerningPage)
	//}}AFX_DATA_INIT

	m_bInitDone = false;
	m_uHelpID = HID_BASE_RESOURCE + IDR_FONT_VIEWER ;
    InitMemberVars() ;
}


/******************************************************************************

  CFontKerningPage::InitMemberVars

  Initialize the member variables that must be initialized both during
  construction and when the UFM is reloaded because of a GTT or CP change.

******************************************************************************/

void CFontKerningPage::InitMemberVars()
{
    m_idSelected = -1;
    m_ufDescending = 0;
    m_uPrecedence[0] = Second;  //  This is the default precedence in UFM
    m_uPrecedence[1] = First;
    m_uPrecedence[2] = Amount;
}


CFontKerningPage::~CFontKerningPage() {
}


void CFontKerningPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontKerningPage)
	DDX_Control(pDX, IDC_KerningTree, m_clcView);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontKerningPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontKerningPage)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_KEYDOWN, IDC_KerningTree, OnKeydownKerningTree)
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_KerningTree, OnEndlabeleditKerningTree)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_KerningTree, OnColumnclickKerningTree)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_AddItem, OnAddItem)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_ChangeAmount, OnChangeAmount)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontKerningPage message handlers

/******************************************************************************

  CFontKerningPage::OnSetActive

  Kerning only makes sense for variable pitch fonts, so if this font has
  changed, we will enable/disable, and change what we display accordingly.

******************************************************************************/

BOOL    CFontKerningPage::OnSetActive()
{
    if  (!CToolTipPage::OnSetActive())
        return  FALSE ;

	int rm1 = m_pcfi->IsVariableWidth() ;									// rm debugging only
	int rm2 = m_clcView.GetItemCount() ;									// rm debugging only

	// Reworked code to fix Raid Bug 163816...
	// Enable the list control based on whether or not this is a variable
	// pitched font.

    m_clcView.EnableWindow(m_pcfi->IsVariableWidth()) ;

	// First time in this routine.  Make sure the list is empty.  Then load
	// it with this font's kerning info if the font has variable pitch.

    m_clcView.DeleteAllItems();
    if  (m_pcfi->IsVariableWidth())	{
        m_pcfi -> FillKern(m_clcView) ;
        m_clcView.SortItems(Sort, (LPARAM) this) ;
	} ;

    return  TRUE ;

	/*	Rick's original code
    if  (m_pcfi->IsVariableWidth() == !!m_clcView.GetItemCount())			//  IsVariableWidth is either 0 or 1, so == is safe, here
        return  TRUE;														//  Everything is copacetic

    m_clcView.EnableWindow(m_pcfi -> IsVariableWidth());

    if  (m_clcView.GetItemCount())
        m_clcView.DeleteAllItems();
    else
		{
        m_pcfi -> FillKern(m_clcView);
        m_clcView.SortItems(Sort, (LPARAM) this);
		}

    return  TRUE;
	*/
}


/******************************************************************************

  CFontKerningPage::OnInitDialog

  This member handles initialization of the dialog.  In this case, we format
  and fill in the kerning tree, if there is one to fill in.  In addition, a
  copy is made of the kerning pairs table so that changes can be discarded
  when necessary.

******************************************************************************/

BOOL CFontKerningPage::OnInitDialog()
{
	CToolTipPage::OnInitDialog();

    CString csWork;

    csWork.LoadString(IDS_KernColumn0);

    m_clcView.InsertColumn(0, csWork, LVCFMT_CENTER,
        (3 * m_clcView.GetStringWidth(csWork)) >>
        1, 0);

    csWork.LoadString(IDS_KernColumn1);

    m_clcView.InsertColumn(1, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 1);

    csWork.LoadString(IDS_KernColumn2);

    m_clcView.InsertColumn(2, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 2);
	
    m_pcfi -> FillKern(m_clcView);
    m_pcfi -> MakeKernCopy();
	
	m_bInitDone = true ;
	return TRUE;
}


/******************************************************************************

  CFontKerningPage::OnContextMenu

  This member function is called whenever the user right-clicks the mouse
  anywhere within the dialog.  If it turns out not to have been within the list
  control, we ignore it.  Otherwise, we put up an appropriate context menu.

******************************************************************************/

void    CFontKerningPage::OnContextMenu(CWnd* pcwnd, CPoint cpt)
{

    if  (pcwnd -> m_hWnd != m_clcView.m_hWnd)						//  Clicked with in the list?
		{															//  Note, will also fail if list is disabled
        CToolTipPage::OnContextMenu(pcwnd, cpt);
        return;
		}

    CPoint  cptThis(cpt);   //  For hit test purposes, we will adjust this.
    m_clcView.ScreenToClient(&cptThis);

    cptThis.x = 5;  //  An arbitrary point sure to be within the label.

    m_idSelected = m_clcView.HitTest(cptThis);
    if  (m_idSelected == -1) {   //  Nothing selected, allow the "Add" item
        CMenu   cmThis;
        CString csWork;

        cmThis.CreatePopupMenu();
        csWork.LoadString(ID_AddItem);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
        cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y,
            this);

        return;
    }

    //  We'll draw our own selection rectangle covering the entire item
    CRect   crItem;

    m_clcView.GetItemRect(m_idSelected, crItem, LVIR_BOUNDS);

    CDC *pcdc = m_clcView.GetDC();

    pcdc -> InvertRect(crItem);
    m_clcView.ReleaseDC(pcdc);

    CMenu   cmThis;
    CString csWork;

    cmThis.CreatePopupMenu();
    csWork.LoadString(ID_ChangeAmount);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeAmount, csWork);
    cmThis.AppendMenu(MF_SEPARATOR);
    csWork.LoadString(ID_AddItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
    csWork.LoadString(ID_DeleteItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_DeleteItem,
        csWork);
    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y,
        this);

    //  Undo the selection rectangle

    pcdc = m_clcView.GetDC();

    pcdc -> InvertRect(crItem);
    m_clcView.ReleaseDC(pcdc);
}

/******************************************************************************

  CFontKerningPage::OnAddItem

  This member will be called whenever the user asks to add an additional
  kerning pair to the list.

******************************************************************************/

void    CFontKerningPage::OnAddItem() {
    CSafeMapWordToOb    csmw2oFirst, csmw2oSecond;
    CWordArray  cwaPoints;

    m_pcfi -> MapKerning(csmw2oFirst, csmw2oSecond, cwaPoints);
    CAddKernPair    cakp(csmw2oFirst, csmw2oSecond, cwaPoints, this);

    if  (cakp.DoModal() == IDOK) {
        m_pcfi -> AddKern(cakp.First(), cakp.Second(), cakp.m_sAmount,
            m_clcView);
    }
}

/******************************************************************************

  CFontKerningPage::OnDeleteItem

  This will be called if we try to delete an item from the context menu.

******************************************************************************/

void    CFontKerningPage::OnDeleteItem() {
    if  (m_idSelected < 0)
        return; //  Nothing to delete?

    m_pcfi -> RemoveKern((unsigned)m_clcView.GetItemData(m_idSelected));
    m_clcView.DeleteItem(m_idSelected);
    m_idSelected = -1;
}

/******************************************************************************

  CFontKerningPage::OnChangeAmount

  This is called when the user selects the menu item stating they wish to
  change the kerning amount.  It just needs to initiate a label edit.

******************************************************************************/

void    CFontKerningPage::OnChangeAmount() {
    if  (m_idSelected < 0)
        return;

    m_clcView.EditLabel(m_idSelected);
    m_idSelected = -1;
}

/******************************************************************************

  CFontKerningPage::OnKeydownKerningTree

  This is called most of the time when a key is pressed while the list control
  has the keyboard focus.  Unfortunately, the enter key is one of those we do
  not get to see.

  Currently, the F2, F10, and delete keys get special processing.  F2 opens
  an edit label on the current item, while F10 displays the context menu, and
  the delete key deletes it.

******************************************************************************/

void    CFontKerningPage::OnKeydownKerningTree(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN  *plvkd = (LV_KEYDOWN *) pnmh;
	*plr = 0;

    m_idSelected = m_clcView.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);
    if  (m_idSelected < 0) {
        if  (plvkd -> wVKey == VK_F10)  //  Do an add item, in this case.
            OnAddItem();
        return;
    }
	
    switch  (plvkd -> wVKey) {
    case    VK_F2:
        m_clcView.EditLabel(m_idSelected);
        break;

    case    VK_DELETE:
        OnDeleteItem();
        break;

    case    VK_F10:
        {
            CRect   crItem;

            m_clcView.GetItemRect(m_idSelected, crItem, LVIR_LABEL);
            m_clcView.ClientToScreen(crItem);
            OnContextMenu(&m_clcView, crItem.CenterPoint());
            break;
        }
    }
}

/******************************************************************************

  CFontKerningPage::OnEndLabelEdit

  This method gets called when the user finishes editing a kern amount, either
  by canceling it or pressing the enter key.

******************************************************************************/

void    CFontKerningPage::OnEndlabeleditKerningTree(NMHDR* pnmh, LRESULT* plr){
	LV_DISPINFO *plvdi = (LV_DISPINFO*) pnmh;	
	*plr = 0;   //  Assume failure

    if  (!plvdi -> item.pszText) //  Editing canceled?
        return;

    CString csNew(plvdi -> item.pszText);

    csNew.TrimRight();
    csNew.TrimLeft();

	// A negative kerning amount is OK so csTemp is not needed.  Use csNew in
	// the following if statement instead of csTemp.
	//
    //CString csTemp = (csNew[1] == _T('-')) ? csNew.Mid(1) : csNew;

    if (csNew.SpanIncluding("-1234567890").GetLength() != csNew.GetLength()) {
        AfxMessageBox(IDS_InvalidNumberFormat);
        return;
    }

    m_pcfi -> SetKernAmount((unsigned)plvdi -> item.lParam, (WORD) atoi(csNew));
    *plr = TRUE;
}

/******************************************************************************

  CFontKerningPage::OnColumnclikKerningTree

  This member gets called whn one of the sort headers is clicked.  If it is
  already the primary column, we revers the sort order fot that column.
  Otherwise, we retain the current order, and make this column the primary
  column, moving the other columns down in precedence.

******************************************************************************/

void    CFontKerningPage::OnColumnclickKerningTree(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW *pnmlv = (NM_LISTVIEW*) pnmh;
	*plr = 0;

    if  (m_uPrecedence[0] == (unsigned) pnmlv -> iSubItem)
        m_ufDescending ^= (1 << pnmlv -> iSubItem);
    else {
        if  (m_uPrecedence[2] == (unsigned) pnmlv -> iSubItem)
            m_uPrecedence[2] = m_uPrecedence[1];
        m_uPrecedence[1] = m_uPrecedence[0];
        m_uPrecedence[0] = pnmlv -> iSubItem;
    }

    m_clcView.SortItems(Sort, (LPARAM) this);
}


/******************************************************************************

  CFontKerningPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

******************************************************************************/

bool CFontKerningPage::ValidateUFMFields()
{
	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontKerningPage::SavePageData

  Save the data in the kerning page back into the CFontInfo class instance that
  was used to load this page.  See CFontInfoContainer::OnSaveDocument() for
  more info.

  In this particular case, no work needs to be done.  Kerning pairs are kept in
  CFontInfo in a more complex collection of classes and arrays than any of the
  other data.  Because of this, a backup copy of the kerning data is made so
  that the editor can continue to update the main copy of the data.  If the
  user chooses not to save his changes, the backup is restored.  See
  CFontInfoContainer::SaveModified() for more information.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontKerningPage::SavePageData()
{
	// All went well so...

	return false ;
}


// Below are globals, definitions, and constants that are useful in
// CFontHeaderPage.  They are put here so that others who include fontview.h
// don't get copies of them.

LPTSTR apstrUniWTypes[] = {
	_T("DF_TYPE_HPINTELLIFONT"), _T("DF_TYPE_TRUETYPE"), _T("DF_TYPE_PST1"),
	_T("DF_TYPE_CAPSL"), _T("DF_TYPE_OEM1"), _T("DF_TYPE_OEM2"), _T("UNDEFINED")
} ;
const int nNumValidWTypes = 6 ;


const CString csHex = _T("0x%x") ;	// Format strings
const CString csDec = _T("%d") ;
const CString csPnt = _T("{%d, %d}") ;


#define HDR_GENFLAGS	0		// These definitions are used in the code and
#define HDR_TYPE		1		// data structures that refer to the 3 UFM
#define HDR_CAPS		2		// Header fields edited with sub dialog boxes.


static bool CALLBACK CHP_SubOrdDlgManager(CObject* pcoowner, int nrow, int ncol,
						 				  CString* pcscontents)
{
	CDialog* pdlg =NULL;				// Loaded with ptr to dialog box class to call

	// Use the row number to determine the dialog box to invoke.

	switch (nrow) {
		case HDR_GENFLAGS:
			pdlg = new CGenFlags(pcscontents) ;
			break ;
		case HDR_TYPE:
			pdlg = new CHdrTypes(pcscontents) ;
			break ;
		case HDR_CAPS:
			pdlg = new CHdrCaps(pcscontents) ;
			break ;
		default:
			ASSERT(0) ;
	} ;
//RAID 43540) Prefix

	if(pdlg==NULL){
		AfxMessageBox(IDS_ResourceError);
		return false;
	  
	};
// END RAID

	// Invoke the dialog box.  The dlg will update scontents.  Return true if
	// the dlg returns true.  Otherwise, return false.

	if (pdlg->DoModal() == IDOK)
		return true ;
	else
		return false ;
}


/////////////////////////////////////////////////////////////////////////////
// CFontHeaderPage property page

IMPLEMENT_DYNCREATE(CFontHeaderPage, CPropertyPage)

CFontHeaderPage::CFontHeaderPage() : CPropertyPage(CFontHeaderPage::IDD)
{
	//{{AFX_DATA_INIT(CFontHeaderPage)
	m_csDefaultCodePage = _T("");
	m_csRCID = _T("");
	//}}AFX_DATA_INIT

	m_bInitDone = false ;
}


CFontHeaderPage::~CFontHeaderPage()
{
}


void CFontHeaderPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontHeaderPage)
	DDX_Control(pDX, IDC_UniDrvLst, m_cfelcUniDrv);
	DDX_Text(pDX, IDC_DefaultCodepageBox, m_csDefaultCodePage);
	DDV_MaxChars(pDX, m_csDefaultCodePage, 6);
	DDX_Text(pDX, IDC_GlyphSetDataRCIDBox, m_csRCID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontHeaderPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFontHeaderPage)
	ON_EN_CHANGE(IDC_DefaultCodepageBox, OnChangeDefaultCodepageBox)
	ON_EN_CHANGE(IDC_GlyphSetDataRCIDBox, OnChangeGlyphSetDataRCIDBox)
	ON_EN_KILLFOCUS(IDC_DefaultCodepageBox, OnKillfocusDefaultCodepageBox)
	ON_EN_KILLFOCUS(IDC_GlyphSetDataRCIDBox, OnKillfocusGlyphSetDataRCIDBox)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontHeaderPage message handlers

/******************************************************************************

  CFontHeaderPage::OnInitDialog

  Initialize this page of the editor's property sheet.  This means loading UFM
  header/UNIDRV info from the FontInfo class into the controls and configuring
  the list control so that it will properly display and edit the data in it.
  The list control is also told that the first 3 fields in the UNIDRV
  structure are edited by subordinate dialog boxes.

******************************************************************************/

BOOL CFontHeaderPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog() ;

	// Load the code page and RC ID boxes with data from the FontInfo class

	m_csDefaultCodePage.Format(csDec, m_pcfi->m_ulDefaultCodepage) ;
	m_csRCID.Format(csDec, (int) (short) m_pcfi->m_lGlyphSetDataRCID) ; //raid 135627
//	m_sRCID = (short) m_pcfi->m_lGlyphSetDataRCID ;
	UpdateData(FALSE) ;

	// Initialize the list control.  We want full row select.  There are 9 rows
	// and 2 columns.  Nothing is togglable and the max length of an entry is
	// 256 characters.  Send change notifications and ignore insert/delete
	// characters.

	const int numfields = 9 ;
	m_cfelcUniDrv.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 256,
							 MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Init and load the field names column; col 0.  Start by loading an array
	// with the field names.

	CStringArray csacoldata	;	// Holds column data for list control
	csacoldata.SetSize(numfields) ;
	csacoldata[HDR_GENFLAGS] = _T("flGenFlags") ;
	csacoldata[HDR_TYPE] = _T("wType") ;
	csacoldata[HDR_CAPS] = _T("fCaps") ;
	csacoldata[3] = _T("wXRes") ;
	csacoldata[4] = _T("wYRes") ;
	csacoldata[5] = _T("sYAdjust") ;
	csacoldata[6] = _T("sYMoved") ;
	csacoldata[7] = _T("SelectFont") ;
	csacoldata[8] = _T("UnSelectFont") ;
	m_cfelcUniDrv.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 10, false, false,
								COLDATTYPE_STRING, (CObArray*) &csacoldata) ;

	// Tell the list control that some of the values must be editted with
	// a subordinate dialog box; fields 0, 1, & 2.

	CUIntArray cuia ;
	cuia.SetSize(numfields) ;
	cuia[HDR_GENFLAGS] = cuia[HDR_TYPE] = cuia[HDR_CAPS] = 1 ;
	//cuia[3] = cuia[4] = cuia[5] = cuia[6] = cuia[7] = cuia[8] = 0 ;
	m_cfelcUniDrv.ExtraInit_CustEditCol(1, this,
									   CEF_HASTOGGLECOLUMNS+CEF_CLICKONROW,
									   cuia, CHP_SubOrdDlgManager) ;

	// Init and load the values column.  The data must be pulled out of the
	// FontInfo class and converted to strings so that they can be loaded
	// into the list control.

	int n ;
	csacoldata[0].Format(csHex, m_pcfi->m_UNIDRVINFO.flGenFlags) ;
	n = m_pcfi->m_UNIDRVINFO.wType ;
	csacoldata[1] = (n < nNumValidWTypes) ?
		apstrUniWTypes[n] : apstrUniWTypes[nNumValidWTypes] ;
	csacoldata[2].Format(csHex, m_pcfi->m_UNIDRVINFO.fCaps) ;
	csacoldata[3].Format(csDec, m_pcfi->m_UNIDRVINFO.wXRes) ;
	csacoldata[4].Format(csDec, m_pcfi->m_UNIDRVINFO.wYRes) ;
	csacoldata[5].Format(csDec, m_pcfi->m_UNIDRVINFO.sYAdjust) ;
	csacoldata[6].Format(csDec, m_pcfi->m_UNIDRVINFO.sYMoved) ;
    m_pcfi->Selector().GetInvocation(csacoldata[7]) ;
    m_pcfi->Selector(FALSE).GetInvocation(csacoldata[8]) ;
	m_cfelcUniDrv.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -11, true,
								false, COLDATTYPE_CUSTEDIT,
								(CObArray*) &csacoldata) ;

	m_bInitDone = true ;	// Initialization is done now
	return TRUE;			// return TRUE unless you set the focus to a control
							// EXCEPTION: OCX Property Pages should return FALSE
}


void CFontHeaderPage::OnChangeDefaultCodepageBox()
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;
}


void CFontHeaderPage::OnChangeGlyphSetDataRCIDBox()
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return ;

	// Mark the UFM as being dirty.
	
	m_pcfi->Changed() ;

	// raid 0003 ; handle the load the width table when change the gttRCID
	
	CString csRCID =  m_csRCID ;
	UpdateData() ;
	if (csRCID != m_csRCID ) {
		m_pcfi->SetRCIDChanged(true) ;
		m_pcfi->SetTranslation((WORD)atoi(m_csRCID)) ;
	}
	
}


LRESULT CFontHeaderPage::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;

	return TRUE ;
}


void CFontHeaderPage::OnKillfocusDefaultCodepageBox()
{
	// Don't worry about a new cp if there is a GTT ID.

	if (m_pcfi->m_lGlyphSetDataRCID != 0)
		return ;

	CheckHandleCPGTTChange(m_csDefaultCodePage, IDS_CPID) ;
}

// this method need to be changed ; just checke the RCID validity: is it 
// exist or not ? don't do anything.
void CFontHeaderPage::OnKillfocusGlyphSetDataRCIDBox()
{
	CString csRCID;
//	csRCID.Format("%d",m_csRCID);	// raid 135627 , raid 0003

	CheckHandleCPGTTChange(m_csRCID, IDS_GTTID) ;
}


/******************************************************************************

  CFontHeaderPage::CheckHandleCPGTTChange

  Determine if the fonts code page / GTT RC ID has changed.  If it has, ask
  the user if he wants to update the data based on the change.  If he does,
  call the UFM Editor's view class instance to manage UFM saving, reloading,
  and kerning/widths table checking.

******************************************************************************/

void CFontHeaderPage::CheckHandleCPGTTChange(CString& csfieldstr, UINT ustrid)
{
	// There is nothing to do if the UFM hasn't changed.

	if (!m_pcfic->IsModified())
		return ;

	// Do nothing if the UFM does not describe a variable width font.  (In this
	// case, there is no valid kerning or width data.)

	if (!m_pcfi->IsVariableWidth())
		return ;

	// Do nothing if the cp/gtt has not really changed.

	CString cs(csfieldstr) ;
	UpdateData() ;
	if (cs == csfieldstr)
		return ;

	// Tell the user that some or all of the data in the widths and kerning
	// tables may have been invalidated by the CP/GTT ID change.  Ask them if
	// they want the tables updated.

	CString csmsg ;
	cs.LoadString(ustrid) ;
	csmsg.Format(IDS_GTTCPChangedMsg, cs) ;
	if (AfxMessageBox(csmsg, MB_ICONINFORMATION+MB_YESNO) == IDNO)
		return ;

	// Call the view class to manage the table updating.

	m_pcfv->HandleCPGTTChange(ustrid == IDS_GTTID) ;
}
	

/******************************************************************************

  CFontHeaderPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

  DEAD_BUG
  The UFM Field Validation doc says that the codepage and GTT ID should be
  validated.  I have not done this for two reason.  First, these checks are
  made by the workspace consistency checking code.  Second, the information
  needed to validate these fields are not currently available to this class and
  it would take a lot of work to make the information available.

******************************************************************************/

bool CFontHeaderPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// Get the column of data that contains the fields we need to validate.

	CStringArray csadata ;
	m_cfelcUniDrv.GetColumnData((CObArray*) &csadata, 1) ;

	CString csmsg ;				// Holds error messages
	CString cspage(_T("UNIDRVINFO")) ;

	// wXRes must be > 0

	if (CheckUFMGrter0(csadata[3], cspage, _T("wXRes"), 3, m_cfelcUniDrv))
		return true ;

	// wYRes must be > 0

	if (CheckUFMGrter0(csadata[4], cspage, _T("wYRes"), 4, m_cfelcUniDrv))
		return true ;

	// SelectFont cannot be blank/empty.

	if (CheckUFMString(csadata[7], cspage, _T("SelectFont"), 7, m_cfelcUniDrv))
		return true ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontHeaderPage::SavePageData

  Save the data in the header page back into the CFontInfo class instance that
  was used to load this page.  See CFontInfoContainer::OnSaveDocument() for
  more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontHeaderPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// Save the default CP and GTT RCID.

	UpdateData() ;
	m_pcfi->m_ulDefaultCodepage = (ULONG) atol(m_csDefaultCodePage) ;
	m_pcfi->m_lGlyphSetDataRCID = (WORD) atoi(m_csRCID) ;	// raid 135627
//	m_pcfi->m_lGlyphSetDataRCID = (WORD) m_sRCID;

	// Get the rest of the data out of the list control.

	CStringArray csadata ;
	m_cfelcUniDrv.GetColumnData((CObArray*) &csadata, 1) ;

	// Save the UNIDRVINFO data.

	UNIDRVINFO* pudi = &m_pcfi->m_UNIDRVINFO ;
	LPTSTR pstr2 ;
	pudi->flGenFlags = strtoul(csadata[0].Mid(2), &pstr2, 16) ;

	CString cs = csadata[1] ;
	for (int n = 0 ; n < nNumValidWTypes ; n++) {
		if (apstrUniWTypes[n] == csadata[1])
			pudi->wType = (WORD) n ;
	} ;

	pudi->fCaps = (WORD) strtoul(csadata[2].Mid(2), &pstr2, 16) ;

	pudi->wXRes = (WORD) atoi(csadata[3]) ;
	pudi->wYRes = (WORD) atoi(csadata[4]) ;
	pudi->sYAdjust = (SHORT)  atoi(csadata[5]) ;
	pudi->sYMoved = (SHORT)  atoi(csadata[6]) ;
	
    m_pcfi->Selector().SetInvocation(csadata[7]) ;
    m_pcfi->Selector(FALSE).SetInvocation(csadata[8]) ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CFontHeaderPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1).

******************************************************************************/

BOOL CFontHeaderPage::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_FONT_VIEWER) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}


// Below are globals, definitions, and constants that are useful in
// CFontIFIMetricsPage.  They are put here so that others who include fontview.h
// don't get copies of them.

#define IFI_FAMILYNAME	0		// These definitions are used in the code and
#define IFI_FONTSIM		4		// data structures that refer to the 12 UFM
#define IFI_WINCHARSET	5		// IFIMetrics fields edited with subordinate
#define IFI_WINPITCHFAM	6		// dialog boxes.                            
#define IFI_INFO		8		
#define IFI_SELECTION	9
#define IFI_BASELINE	38
#define IFI_ASPECT		39
#define IFI_CARET		40
#define IFI_FONTBOX		41
#define IFI_PANOSE		44

// RAID       : add extra charset (from johab_charset), change symbo-charset as 2.
LPTSTR apstrWinCharSet[] = {
	_T("ANSI_CHARSET"),   _T("SYMBOL_CHARSET"),     _T("SHIFTJIS_CHARSET"),
	_T("HANGEUL_CHARSET"),_T("CHINESEBIG5_CHARSET"),_T("GB2312_CHARSET"),
	_T("OEM_CHARSET"), 	  _T("JOHAB_CHARSET"),      _T("HEBREW_CHARSET"),    
	_T("ARABIC_CHARSET"), 	_T("GREEK_CHARSET"),    _T("TURKISH_CHARSET"),
    _T("VIETNAMESE_CHARSET"),_T("THAI_CHARSET"), _T("EASTEUROPE_CHARSET"),
	_T("RUSSIAN_CHARSET"), 	_T("BALTIC_CHARSET"), _T("UNDEFINED")
} ;
int anWinCharSetVals[] = {0, 2, 128, 129, 136,134,255,130,177,178,161,
							162,163,222,238,204,186,1} ;
const int nWinCharSet = 18 ;


// The first array contains the base control IDs for each of the groups of edit
// controls that contain font simulation data.  The second array indicates the
// number of edit boxes in each group.

static unsigned auBaseFontSimCtrlID[] =
	{IDC_ItalicWeight, IDC_BoldWeight, IDC_BIWeight} ;
static unsigned auNumFontSimCtrls[] = {4, 3, 4} ;


/******************************************************************************

  ParseCompoundNumberString

  There are several IFIMetrics fields that are displayed as strings in the form
  "{x, y, ...z}".  This routine parses out the individual numbers (in string
  form) and saves them in a string array.

  Args:
	csaindvnums		The individual numeric strings
	pcscompnumstr	Pointer to the compound number string that is parsed
	ncount			The number of numbers to parse out of pcscompnumstr

******************************************************************************/

void ParseCompoundNumberString(CStringArray& csaindvnums,
							   CString* pcscompnumstr, int ncount)
{
	// Make sure the string array has the right number of entries in it.

	csaindvnums.SetSize(ncount) ;

	// Make a copy of pcscompnumstr that can be torn apart.  (Do no include
	// the first curly brace in the string.

	CString cs(pcscompnumstr->Mid(1)) ;

	// Get the first ncount - 1 number strings.

	int n, npos ;
	for (n = 0 ; n < ncount - 1 ; n++) {
		npos = cs.Find(_T(',')) ;
		csaindvnums[n] = cs.Left(npos) ;
		cs = cs.Mid(npos + 2) ;
	} ;

	// Save the last number in the compound string.

	csaindvnums[n] = cs.Left(cs.Find(_T('}'))) ;
}


static bool CALLBACK CIP_SubOrdDlgManager(CObject* pcoowner, int nrow, int ncol,
						 				  CString* pcscontents)
{
	CDialog* pdlg = NULL ;				// Loaded with ptr to dialog box class to call

	// Use the row number to determine the dialog box to invoke.

	switch (nrow) {
		case IFI_FAMILYNAME:
			pdlg = new CFIFIFamilyNames(pcscontents,
										(CFontIFIMetricsPage*) pcoowner) ;
			break ;
		case IFI_FONTSIM:	
			pdlg = new CFIFIFontSims(pcscontents,
									 (CFontIFIMetricsPage*) pcoowner) ;
			break ;
		case IFI_WINCHARSET:
			pdlg = new CFIFIWinCharSet(pcscontents) ;
			break ;
		case IFI_WINPITCHFAM:
			pdlg = new CFIFIWinPitchFamily(pcscontents) ;
			break ;
		case IFI_INFO:	
			pdlg = new CFIFIInfo(pcscontents) ;
			break ;
		case IFI_SELECTION:	
			pdlg = new CFIFISelection(pcscontents) ;
			break ;
		case IFI_BASELINE:
		case IFI_ASPECT:
		case IFI_CARET:
			pdlg = new CFIFIPoint(pcscontents) ;
			break ;
		case IFI_FONTBOX:
			pdlg = new CFIFIRectangle(pcscontents) ;
			break ;
		case IFI_PANOSE:
			pdlg = new CFIFIPanose(pcscontents) ;
			break ;
		default:
			ASSERT(0) ;
	} ;
// raid 43541 Prefix

	if(pdlg == NULL){
		AfxMessageBox(IDS_ResourceError);
		return false;
	}

	// Invoke the dialog box.  The dlg will update pscontents.  Return true if
	// the dlg returns IDOK.  Otherwise, return false.

	if (pdlg->DoModal() == IDOK)
		return true ;
	else
		return false ;
}


/////////////////////////////////////////////////////////////////////////////
// CFontIFIMetricsPage property page

IMPLEMENT_DYNCREATE(CFontIFIMetricsPage, CPropertyPage)

CFontIFIMetricsPage::CFontIFIMetricsPage() : CPropertyPage(CFontIFIMetricsPage::IDD)
{
	//{{AFX_DATA_INIT(CFontIFIMetricsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = false ;

	// Initialize as no enabled font simulations

	m_cuiaFontSimStates.SetSize(3) ;
	m_cuiaSimTouched.SetSize(3) ;
	for (int n = 0 ; n < 3 ; n++)
		m_cuiaFontSimStates[n] = m_cuiaSimTouched[n] = 0 ;
}

CFontIFIMetricsPage::~CFontIFIMetricsPage()
{
}

void CFontIFIMetricsPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontIFIMetricsPage)
	DDX_Control(pDX, IDC_IFIMetricsLst, m_cfelcIFIMetrics);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontIFIMetricsPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFontIFIMetricsPage)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontIFIMetricsPage message handlers

BOOL CFontIFIMetricsPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();
	
	// Initialize the list control.  We want full row select.  There are 45 rows
	// and 2 columns.  Nothing is togglable and the max length of an entry is
	// 256 characters.  Send change notifications and ignore insert/delete
	// characters.

	const int numfields = 45 ;
	m_cfelcIFIMetrics.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 256,
								 MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Init and load the field names column; col 0.  Start by loading an array
	// with the field names.

	CStringArray csacoldata	;	// Holds column data for list control
	csacoldata.SetSize(numfields) ;
	IFILoadNamesData(csacoldata) ;
	m_cfelcIFIMetrics.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 20, false,
									false, COLDATTYPE_STRING,
									(CObArray*) &csacoldata) ;

	// Tell the list control that some of the values must be editted with
	// a subordinate dialog box.

	CUIntArray cuia ;
	cuia.SetSize(numfields) ;
	cuia[IFI_FAMILYNAME] = cuia[IFI_FONTSIM] = 1 ;
	cuia[IFI_WINCHARSET] = cuia[IFI_WINPITCHFAM] = cuia[IFI_INFO] = 1 ;
	cuia[IFI_SELECTION] = cuia[IFI_BASELINE] = cuia[IFI_ASPECT] = 1 ;
	cuia[IFI_CARET] = cuia[IFI_FONTBOX] = cuia[IFI_PANOSE] = 1 ;
	m_cfelcIFIMetrics.ExtraInit_CustEditCol(1, this,
									       CEF_HASTOGGLECOLUMNS+CEF_CLICKONROW,
										   cuia, CIP_SubOrdDlgManager) ;

	// Init and load the values column.  The data must be pulled out of the
	// FontInfo class / IFIMETRICS structure and converted to strings so that
	// they can be loaded into the list control.

	IFILoadValuesData(csacoldata) ;
	m_cfelcIFIMetrics.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -37, true,
								    false, COLDATTYPE_CUSTEDIT,
								    (CObArray*) &csacoldata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFontIFIMetricsPage::IFILoadNamesData(CStringArray& csacoldata)
{
	csacoldata[IFI_FAMILYNAME]  = _T("dpwszFamilyName") ;
	csacoldata[1]  = _T("dpwszStyleName") ;
	csacoldata[2]  = _T("dpwszFaceName") ;
	csacoldata[3]  = _T("dpwszUniqueName") ;
	csacoldata[IFI_FONTSIM]  = _T("dpFontSim") ;
	csacoldata[IFI_WINCHARSET]  = _T("jWinCharSet") ;
	csacoldata[IFI_WINPITCHFAM]  = _T("jWinPitchAndFamily") ;
	csacoldata[7]  = _T("usWinWeight") ;
	csacoldata[IFI_INFO]  = _T("flInfo") ;
	csacoldata[IFI_SELECTION] = _T("fsSelection") ;
	csacoldata[10] = _T("fwdUnitsPerEm") ;
	csacoldata[11] = _T("fwdLowestPPEm") ;					 
	csacoldata[12] = _T("fwdWinAscender") ;					 
	csacoldata[13] = _T("fwdWinDescender") ;					 
	csacoldata[14] = _T("fwdAveCharWidth") ;					 
	csacoldata[15] = _T("fwdMaxCharInc") ;					 
	csacoldata[16] = _T("fwdCapHeight") ;						 
	csacoldata[17] = _T("fwdXHeight") ;						 
	csacoldata[18] = _T("fwdSubscriptXSize") ;				 
	csacoldata[19] = _T("fwdSubscriptYSize") ;				 
	csacoldata[20] = _T("fwdSubscriptXOffset") ;				 
	csacoldata[21] = _T("fwdSubscriptYOffset") ;				 
	csacoldata[22] = _T("fwdSuperscriptXSize") ;				 
	csacoldata[23] = _T("fwdSuperscriptYSize") ;				 
	csacoldata[24] = _T("fwdSuperscriptXOffset") ;			 
	csacoldata[25] = _T("fwdSuperscriptYOffset") ;			 
	csacoldata[26] = _T("fwdUnderscoreSize") ;				 
	csacoldata[27] = _T("fwdUnderscorePosition") ;			 
	csacoldata[28] = _T("fwdStrikeoutSize") ;					 
	csacoldata[29] = _T("fwdStrikeoutPosition") ;				 
	csacoldata[30] = _T("chFirstChar") ;						 
	csacoldata[31] = _T("chLastChar") ;						 
	csacoldata[32] = _T("chDefaultChar") ;					 
	csacoldata[33] = _T("chBreakChar") ;						 
	csacoldata[34] = _T("wcFirstChar") ;						 
	csacoldata[35] = _T("wcLastChar") ;						 
	csacoldata[36] = _T("wcDefaultChar") ;					 
	csacoldata[37] = _T("wcBreakChar") ;						 
	csacoldata[IFI_BASELINE] = _T("ptlBaseline") ;
	csacoldata[IFI_ASPECT] = _T("ptlAspect") ;
	csacoldata[IFI_CARET] = _T("ptlCaret") ;
	csacoldata[IFI_FONTBOX] = _T("rclFontBox { L T R B }") ;
	csacoldata[42] = _T("achVendId") ;
	csacoldata[43] = _T("ulPanoseCulture") ;
	csacoldata[IFI_PANOSE] = _T("panose") ;
}


void CFontIFIMetricsPage::IFILoadValuesData(CStringArray& csacoldata)
{
	// Only the first family name is displayed on the IFI page
	//raid 104822
	if (m_pcfi->m_csaFamily.GetSize())
	csacoldata[IFI_FAMILYNAME] = m_pcfi->m_csaFamily.GetAt(0) ;	
	
	csacoldata[1] = m_pcfi->m_csStyle ;
	csacoldata[2] = m_pcfi->m_csFace ;
	csacoldata[3] = m_pcfi->m_csUnique ;
	
	// There is too much fontsim data to display on the IFI page so just
	// describe it.  A subordinate dialog box is used to display/edit the data.

	csacoldata[IFI_FONTSIM] = _T("Font Simulation Dialog") ;
	
	IFIMETRICS*	pifi = &m_pcfi->m_IFIMETRICS ;	// Minor optimization

	// Translate jWinCharSet into a descriptive string that can be displayed.

	csacoldata[IFI_WINCHARSET] = apstrWinCharSet[nWinCharSet - 1] ;
	for (int n = 0 ; n < (nWinCharSet - 1) ; n++)
		if (pifi->jWinCharSet == anWinCharSetVals[n]) {
			csacoldata[IFI_WINCHARSET] = apstrWinCharSet[n] ;
			break ;
		} ;

	// Before saving the WinPitch value, make sure that at least one of the FF
	// flags is set.  Use FF_DONTCARE (4) when none are set.

	n = pifi->jWinPitchAndFamily ;
//raid 32675 : kill 2 lines
//	if (n < 4)
//		n |= 4 ;
	csacoldata[IFI_WINPITCHFAM].Format(csHex, n) ;
	
	csacoldata[7].Format("%hu",  pifi->usWinWeight) ;
	csacoldata[IFI_INFO].Format(csHex, pifi->flInfo) ;
	csacoldata[IFI_SELECTION].Format(csHex, pifi->fsSelection) ;

	// Format and save fwdUnitsPerEm, fwdLowestPPEm, fwdWinAscender,
	// fwdWinDescender.

	short* ps = &pifi->fwdUnitsPerEm ;
	for (n = 0 ; n < 4 ; n++)											
		csacoldata[10+n].Format(csDec, *ps++) ;

	ps = &pifi->fwdAveCharWidth;									
	for (n = 0 ; n < 16 ; n++)
		csacoldata[14+n].Format(csDec, *ps++) ;

	BYTE* pb = (BYTE*) &pifi->chFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		csacoldata[30+n].Format(csDec, *pb++) ;
	
	unsigned short* pus = (unsigned short*) &pifi->wcFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		csacoldata[34+n].Format(csHex, *pus++) ;

	// Format and save the points

	csacoldata[IFI_BASELINE].Format(csPnt,
		pifi->ptlBaseline.x, pifi->ptlBaseline.y) ;
	csacoldata[IFI_ASPECT].Format(csPnt, pifi->ptlAspect.x, pifi->ptlAspect.y) ;
	csacoldata[IFI_CARET].Format(csPnt, pifi->ptlCaret.x, pifi->ptlCaret.y) ;
		
	csacoldata[IFI_FONTBOX].Format("{%d, %d, %d, %d}", pifi->rclFontBox.left,
		pifi->rclFontBox.top, pifi->rclFontBox.right, pifi->rclFontBox.bottom) ;
					
	csacoldata[42].Format("%c%c%c%c", pifi->achVendId[0], pifi->achVendId[1],
						  pifi->achVendId[2], pifi->achVendId[3]) ;

	csacoldata[43].Format("%lu", pifi->ulPanoseCulture) ;

	csacoldata[IFI_PANOSE].Format("{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d}",
					  pifi->panose.bFamilyType, pifi->panose.bSerifStyle,
					  pifi->panose.bWeight,   pifi->panose.bProportion,
					  pifi->panose.bContrast, pifi->panose.bStrokeVariation,
					  pifi->panose.bArmStyle, pifi->panose.bLetterform,
					  pifi->panose.bMidline,  pifi->panose.bXHeight) ;
}


LRESULT CFontIFIMetricsPage::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;

	return TRUE ;
}


CWordArray* CFontIFIMetricsPage::GetFontSimDataPtr(int nid)
{
	// Return a pointer to the requested font simulation data.

	switch (nid) {
		case CFontInfo::ItalicDiff:
			return &m_cwaBold ;
		case CFontInfo::BoldDiff:
			return &m_cwaItalic ;
		case CFontInfo::BothDiff:
			return &m_cwaBoth ;
		default:
			ASSERT(0) ;
	} ;

	// This point should never be reached.

	return &m_cwaBold ;
}


/******************************************************************************

  CFontIFIMetricsPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return false.

******************************************************************************/

bool CFontIFIMetricsPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// Get the column of data that contains the fields we need to validate.

	CStringArray csadata ;
	m_cfelcIFIMetrics.GetColumnData((CObArray*) &csadata, 1) ;

	CString csmsg ;				// Holds error messages
	CString cspage(_T("IFIMETRICS")) ;

	LPTSTR apstrsflds[] = {		// These string fields are checked below
		_T("dpwszFamilyName"), _T("dpwszStyleName"), _T("dpwszFaceName"),
		_T("dpwszUniqueName")
	} ;

	// Check to see if any of the string entries are blank/empty.

	for (int n = 0 ; n < 4 ; n++) {
		if (CheckUFMString(csadata[n],cspage,apstrsflds[n],n,m_cfelcIFIMetrics))
			return true ;
	} ;

	// If this UFM describes a variable pitch font, make sure that
	// fwdUnitsPerEm > 0.

	if (m_pcfi->IsVariableWidth())
		if (CheckUFMGrter0(csadata[10], cspage, _T("fwdUnitsPerEm"), 10,
						   m_cfelcIFIMetrics))
			return true ;

	LPTSTR apstrgflds[] = {		// These fields are checked below
		_T("fwdWinAscender"), _T("fwdWinDescender"), _T("fwdAveCharWidth"),
		_T("fwdMaxCharInc"), _T("fwdUnderscoreSize"), _T("fwdStrikeoutSize")
	} ;
	int angfidxs[] = {12, 13, 14, 15, 26, 28} ;

	// All of the following fields must be > 0.

	LPTSTR pstr, pstr2 ;
	for (int n2 = 0 ; n2 < 6 ; n2++) {
		n = angfidxs[n2] ;
		pstr = apstrgflds[n2] ;
		if (CheckUFMGrter0(csadata[n], cspage, pstr, n, m_cfelcIFIMetrics))
			return true ;
	} ;

	// fwdUnderscorePosition must be < 0

	bool bres = atoi(csadata[27]) >= 0 ;
	if (CheckUFMBool(bres, cspage, _T("fwdUnderscorePosition"), 27,
					 m_cfelcIFIMetrics, IDS_GrterEqZeroError))
		return true ;

	// fwdStrikeoutPosition must be >= 0

	bres = atoi(csadata[29]) < 0 ;
	if (CheckUFMBool(bres, cspage, _T("fwdStrikeoutPosition"), 29,
					 m_cfelcIFIMetrics, IDS_LessZeroError))
		return true ;

	LPTSTR apstrnzflds[] = {	// These fields are checked below
		_T("chFirstChar"), _T("chLastChar"), _T("chDefaultChar"),
		_T("chBreakChar"), _T("wcFirstChar"), _T("wcLastChar"),
		_T("wcDefaultChar"), _T("wcBreakChar")
	} ;

	// All of the following fields must be != 0.

	int nfval ;
	for (n = 30, n2 = 0 ; n <= 37 ; n++, n2++) {
		pstr = csadata[n].GetBuffer(16) ;
		if (*(pstr+1) != _T('x'))
			nfval = atoi(pstr) ;
		else
			nfval = strtoul((pstr+2), &pstr2, 16) ;
		pstr = apstrnzflds[n2] ;
		if (CheckUFMNotEq0(nfval, cspage, pstr, n, m_cfelcIFIMetrics))
			return true ;
	} ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontIFIMetricsPage::SavePageData

  Save the data in the IFIMETRICS page back into the CFontInfo class instance
  that was used to load this page.  See CFontInfoContainer::OnSaveDocument()
  for more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontIFIMetricsPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// Save the family name(s) if there are new ones.

	int n, numents = (int)m_csaFamilyNames.GetSize() ;
	if (numents > 0) {
		m_pcfi->m_csaFamily.RemoveAll() ;
		for (n = 0 ; n < numents ; n++)
			m_pcfi->AddFamily(m_csaFamilyNames[n]) ;
	} ;

	// Get the contents of the values contents.  This isn't needed for all
	// fields but most of it will be needed.

	CStringArray csadata ;
	m_cfelcIFIMetrics.GetColumnData((CObArray*) &csadata, 1) ;

	m_pcfi->m_csStyle = csadata[1] ;
	m_pcfi->m_csFace = csadata[2] ;
	m_pcfi->m_csUnique = csadata[3] ;

	SaveFontSimulations() ;		// Do just that

	IFIMETRICS*	pifi = &m_pcfi->m_IFIMETRICS ;	// Minor optimization
	LPTSTR pstr ;

	// For the time being, dpCharSets should always be 0.

	pifi->dpCharSets = 0 ;

	// Set jWinCharSet.  Don't change it if the setting is unknown.

	for (n = 0 ; n < (nWinCharSet - 1) ; n++)
		if (csadata[IFI_WINCHARSET] == apstrWinCharSet[n]) {
			pifi->jWinCharSet = (BYTE)anWinCharSetVals[n] ;
			break ;
		} ;
	
	pifi->jWinPitchAndFamily = (UCHAR) strtoul(csadata[IFI_WINPITCHFAM].Mid(2), &pstr, 16) ;
	pifi->usWinWeight = (USHORT)atoi(csadata[7]) ;
	pifi->flInfo = strtoul(csadata[IFI_INFO].Mid(2), &pstr, 16) ;
	pifi->fsSelection = (USHORT) strtoul(csadata[IFI_SELECTION].Mid(2), &pstr, 16) ;

	short* ps = &pifi->fwdUnitsPerEm ;
	for (n = 0 ; n < 4 ; n++)											
		*ps++ = (SHORT)atoi(csadata[10+n]) ;

	ps = &pifi->fwdAveCharWidth;									
	for (n = 0 ; n < 16 ; n++)
		*ps++ = (SHORT)atoi(csadata[14+n]) ;

	BYTE* pb = (BYTE*) &pifi->chFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		*pb++ = (BYTE)atoi(csadata[30+n]) ;
	
	unsigned short* pus = (unsigned short*) &pifi->wcFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		*pus++ = (USHORT) strtoul(csadata[34+n].Mid(2), &pstr, 16) ;

	// Format and save the points

	CStringArray csa ;
	POINTL* ppl = &pifi->ptlBaseline ;
	for (n = 0 ; n < 3 ; n++, ppl++) {
		ParseCompoundNumberString(csa, &csadata[IFI_BASELINE+n], 2) ;
		ppl->x = atoi(csa[0]) ;
		ppl->y = atoi(csa[1]) ;
	} ;
		
	ParseCompoundNumberString(csa, &csadata[IFI_FONTBOX], 4) ;
	pifi->rclFontBox.left = atoi(csa[0]) ;
	pifi->rclFontBox.top = atoi(csa[1]) ;
	pifi->rclFontBox.right = atoi(csa[2]) ;
	pifi->rclFontBox.bottom = atoi(csa[3]) ;
					
	for (n = 0 ; n < 4 ; n++)
		pifi->achVendId[n] = csadata[42].GetAt(n) ;

	pifi->ulPanoseCulture = atoi(csadata[43]) ;

	ParseCompoundNumberString(csa, &csadata[IFI_PANOSE], 10) ;
	pb = (BYTE*) &pifi->panose ;
	for (n = 0 ; n < 10 ; n++)
		*pb++ = (BYTE)atoi(csa[n]) ;

	// All went well so...

	return false ;
}


void CFontIFIMetricsPage::SaveFontSimulations()
{
	unsigned udataidx, unumdata, u2 ;	// Each var defined below
	CWordArray* pcwasimdata ;
	CFontDifference* pcfdxx ;
	CFontDifference*& pcfd = pcfdxx ;

	// Loop through each simulation in the dialog box.

	for (unsigned u = IDC_EnableItalicSim ; u <= IDC_EnableBISim ; u++) {
		// Turn the control id into a data index that can be used to reference
		// font simulation data in this and other class instances.

		udataidx = u - IDC_EnableItalicSim ;
		ASSERT(udataidx <= CFontInfo::BothDiff) ;

		// If this simulation was not touched, it does not need to change.

		//u2 = m_cuiaSimTouched[udataidx] ;
		if (!m_cuiaSimTouched[udataidx])
			continue ;

		// Get a pointer to the current simulation in the CFontInfo class
		// instance.

		pcfd = NULL ;
		m_pcfi->EnableSim(udataidx, TRUE, pcfd) ;

		// If the simulation is enabled, make sure the CFontInfo class
		// instance's simulation is loaded with the most up to date data.
	
		if (m_cuiaFontSimStates[udataidx]) {
			unumdata = auNumFontSimCtrls[udataidx] ;
			pcwasimdata = GetFontSimDataPtr(udataidx) ;
			for (u2 = 0 ; u2 < unumdata ; u2++)
				pcfd->SetMetric(u2, (*pcwasimdata)[u2]) ;
		
		// If the simulation is disabled, make sure the CFontInfo class instance
		// gets rid of its pointer to this simulation and then free the memory
		// allocated for it.

		} else {
			m_pcfi->EnableSim(udataidx, FALSE, pcfd) ;
			delete pcfd ;
		} ;
	} ;
}


/////////////////////////////////////////////////////////////////////////////
// CFontExtMetricPage property page

IMPLEMENT_DYNCREATE(CFontExtMetricPage, CPropertyPage)

CFontExtMetricPage::CFontExtMetricPage() : CPropertyPage(CFontExtMetricPage::IDD)
{
	//{{AFX_DATA_INIT(CFontExtMetricPage)
	m_bSaveOnClose = FALSE;
	//}}AFX_DATA_INIT

	m_bInitDone = false ;
}

CFontExtMetricPage::~CFontExtMetricPage()
{
}

void CFontExtMetricPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontExtMetricPage)
	DDX_Control(pDX, IDC_ExtMetricsLst, m_cfelcExtMetrics);
	DDX_Check(pDX, IDC_SaveCloseChk, m_bSaveOnClose);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontExtMetricPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFontExtMetricPage)
	ON_BN_CLICKED(IDC_SaveCloseChk, OnSaveCloseChk)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontExtMetricPage message handlers

BOOL CFontExtMetricPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();
	
	// Initialize the list control.  We want full row select.  There are 24 rows
	// and 2 columns.  Nothing is togglable and the max length of an entry is
	// 256 characters.  Send change notifications and ignore insert/delete
	// characters.

	const int numfields = 24 ;
	m_cfelcExtMetrics.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 256,
								 MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Init and load the field names column; col 0.  Start by loading an array
	// with the field names.

	CStringArray csacoldata	;	// Holds column data for list control
	csacoldata.SetSize(numfields) ;
	EXTLoadNamesData(csacoldata) ;
	m_cfelcExtMetrics.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 10, false,
									false, COLDATTYPE_STRING,
									(CObArray*) &csacoldata) ;

	// Init and load the values column.  The data must be pulled out of the
	// FontInfo class / EXTMETRICS structure so that they can be loaded into
	// the list control.
	//
	// The first (emSize) and last (emKernTracks) EXTMETRICS fields are not
	// displayed.  EmSize is not user editable and emKernTracks is not
	// supported under NT.

	CUIntArray cuiacoldata ;
	cuiacoldata.SetSize(numfields) ;
	PSHORT ps = &m_pcfi->m_EXTTEXTMETRIC.emPointSize ;
	for (int n = 0 ; n < numfields ; n++, ps++)
		cuiacoldata[n] = (unsigned) (int) *ps ;
	m_cfelcExtMetrics.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -28, true,
								    false, COLDATTYPE_INT,
								    (CObArray*) &cuiacoldata) ;

	// Determine if the ExtTextMetrics data is valid.  Use this info to set or
	// clear the "Save On Close" checkbox and also use it enable or disable the
	// data list box.

	m_bSaveOnClose = (m_pcfi->m_fEXTTEXTMETRIC != 0) ;
	UpdateData(false) ;
	m_cfelcExtMetrics.EnableWindow(m_bSaveOnClose) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFontExtMetricPage::EXTLoadNamesData(CStringArray& csacoldata)
{
	csacoldata[0]  = _T("emPointSize") ;
	csacoldata[1]  = _T("emOrientation") ;
	csacoldata[2]  = _T("emMasterHeight") ;
	csacoldata[3]  = _T("emMinScale") ;
	csacoldata[4]  = _T("emMaxScale") ;
	csacoldata[5]  = _T("emMasterUnits") ;
	csacoldata[6]  = _T("emCapHeight") ;
	csacoldata[7]  = _T("emXHeight") ;
	csacoldata[8]  = _T("emLowerCaseAscent") ;
	csacoldata[9]  = _T("emLowerCaseDescent") ;
	csacoldata[10] = _T("emSlant") ;
	csacoldata[11] = _T("emSuperScript") ;
	csacoldata[12] = _T("emSubScript") ;
	csacoldata[13] = _T("emSuperScriptSize") ;
	csacoldata[14] = _T("emSubScriptSize") ;
	csacoldata[15] = _T("emUnderlineOffset") ;
	csacoldata[16] = _T("emUnderlineWidth") ;
	csacoldata[17] = _T("emDoubleUpperUnderlineOffset") ;
	csacoldata[18] = _T("emDoubleLowerUnderlineOffset") ;
	csacoldata[19] = _T("emDoubleUpperUnderlineWidth") ;
	csacoldata[20] = _T("emDoubleLowerUnderlineWidth") ;
	csacoldata[21] = _T("emStrikeOutOffset") ;
	csacoldata[22] = _T("emStrikeOutWidth") ;
	csacoldata[23] = _T("emKernPairs") ;
}


void CFontExtMetricPage::OnSaveCloseChk()
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return ;

	// Get the new state of the check box and use it to enable/disable the data
	// list control.

	UpdateData() ;
	m_cfelcExtMetrics.EnableWindow(m_bSaveOnClose) ;
	
	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;
}


LRESULT CFontExtMetricPage::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;

	return TRUE ;
}


/******************************************************************************

  CFontExtMetricPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

******************************************************************************/

bool CFontExtMetricPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// There is nothing that needs to be checked if the data on this page will
	// not be saved.

	UpdateData() ;
	if (!m_bSaveOnClose)
		return false ;

	// Get the column of data that contains the fields we need to validate.

	CUIntArray cuiadata ;
	m_cfelcExtMetrics.GetColumnData((CObArray*) &cuiadata, 1) ;

	CString csmsg ;				// Holds error messages
	CString cspage(_T("EXTMETRICS")) ;

	// There are three fields that should only be validated if this is a
	// variable pitch font.

	if (m_pcfi->IsVariableWidth()) {
		LPTSTR apstrsnzflds[] = {
			_T("emMinScale"), _T("emMaxScale"), _T("emMasterUnits")
		} ;

		// Make sure that emMinScale != emMaxScale.

		bool bres = ((int) cuiadata[3]) == ((int) cuiadata[4]) ;
		CString cs = cspage + _T(" ") ;
		cs += apstrsnzflds[0] ;
		if (CheckUFMBool(bres, cs, apstrsnzflds[1], 3, m_cfelcExtMetrics,
						 IDS_EqFieldsError))
			return true ;

		// Now make sure that the apstrsnzflds fields are nonzero.

		int n, n2 ;
		for (n = 3, n2 = 0 ; n <= 5 ; n++, n2++) {
			if (CheckUFMNotEq0(cuiadata[n], cspage, apstrsnzflds[n2], n,
							   m_cfelcExtMetrics))
				return true ;
		} ;
	} ;

	// emUnderLineOffset must be < 0

	bool bres = ((int) cuiadata[15]) >= 0 ;
	if (CheckUFMBool(bres, cspage, _T("emUnderLineOffset"), 15,
					 m_cfelcExtMetrics, IDS_GrterEqZeroError))
		return true ;

	// emUnderLineOffset must be nonzero

	int ndata = (int) cuiadata[16] ;
	if (CheckUFMNotEq0(ndata, cspage, _T("emUnderlineWidth"), 16,
					   m_cfelcExtMetrics))
		return true ;

	// emStrikeOutOffset must be > 0

	CString cs ;
	cs.Format("%d", (int) cuiadata[21]) ;
	if (CheckUFMGrter0(cs, cspage, _T("emStrikeOutOffset"), 21,
					   m_cfelcExtMetrics))
		return true ;

	// emStrikeOutWidth must be > 0

	cs.Format("%d", (int) cuiadata[22]) ;
	if (CheckUFMGrter0(cs, cspage, _T("emStrikeOutWidth"), 22,
					   m_cfelcExtMetrics))
		return true ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontExtMetricPage::SavePageData

  Save the data in the EXTMETRICS page back into the CFontInfo class instance
  that was used to load this page.  See CFontInfoContainer::OnSaveDocument()
  for more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontExtMetricPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// Get the data out of the control and save it into the 24, editable
	// EXTMETRICS fields.

	CUIntArray cuiadata ;
	m_cfelcExtMetrics.GetColumnData((CObArray*) &cuiadata, 1) ;
	PSHORT ps = &m_pcfi->m_EXTTEXTMETRIC.emPointSize ;
	for (int n = 0 ; n < 24 ; n++, ps++)
		*ps = (short) cuiadata[n] ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CFontExtMetricPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1).

******************************************************************************/

BOOL CFontExtMetricPage::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_FONT_VIEWER) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}


/////////////////////////////////////////////////////////////////////////////
// CGenFlags dialog


CGenFlags::CGenFlags(CWnd* pParent /*=NULL*/)
	: CDialog(CGenFlags::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CGenFlags::CGenFlags(CString* pcsflags, CWnd* pParent /*= NULL*/)
	: CDialog(CGenFlags::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGenFlags)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CGenFlags::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGenFlags)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGenFlags, CDialog)
	//{{AFX_MSG_MAP(CGenFlags)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGenFlags message handlers

BOOL CGenFlags::OnInitDialog()
{
	CDialog::OnInitDialog() ;

	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(3) ;
	csafieldnames[0] = _T("UFM_SOFT") ;
	csafieldnames[1] = _T("UFM_CART") ;
	csafieldnames[2] = _T("UFM_SCALABLE") ;
	
	// Allocate and fill the flag groupings array.  There are 2 flag groups in
	// this flag dword.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(4) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = 1 ;
	cuiaflaggroupings[2] = 2 ;
	cuiaflaggroupings[3] = 2 ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 2,
					  lptstrSet, 105, false) ;
	
	return TRUE ; // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CGenFlags::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CHdrTypes dialog


CHdrTypes::CHdrTypes(CWnd* pParent /*=NULL*/)
	: CDialog(CHdrTypes::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CHdrTypes::CHdrTypes(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CHdrTypes::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHdrTypes)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CHdrTypes::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHdrTypes)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHdrTypes, CDialog)
	//{{AFX_MSG_MAP(CHdrTypes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHdrTypes message handlers

BOOL CHdrTypes::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array.  While doing this, determine the
	// current (single) flag setting.

	CStringArray csafieldnames ;
	csafieldnames.SetSize(nNumValidWTypes) ;
	DWORD dwsettings, dwbit = 1 ;
	for (int n = 0 ; n < nNumValidWTypes ; n++, dwbit <<= 1) {
		csafieldnames[n] = apstrUniWTypes[n] ;
		if (csafieldnames[n] == *m_pcsFlags)
			dwsettings = dwbit ;
	} ;

	// Allocate and fill the flag groupings array.  There is only one flag
	// group.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(2) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = nNumValidWTypes - 1 ;

	// Initialize the flags list.

	m_cflbFlags.Init(csafieldnames, dwsettings, cuiaflaggroupings, 1, lptstrSet,
					 110, true) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CHdrTypes::OnOK()
{
	// Get the value of the single flag that was selected.

	DWORD dwflag = m_cflbFlags.GetNewFlagDWord() ;
	
	// Use the selected flag to determine the new flag name to display.

	DWORD dwbit = 1 ;
	for (int n = 0 ; n < nNumValidWTypes ; n++, dwbit <<= 1) {
		if (dwbit == dwflag) {
			*m_pcsFlags = apstrUniWTypes[n] ;
			break ;
		} ;
	} ;

	// Blow if a matching flag was not found.  This should never happen.

	ASSERT(n < nNumValidWTypes) ;

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CHdrCaps dialog


CHdrCaps::CHdrCaps(CWnd* pParent /*=NULL*/)
	: CDialog(CHdrCaps::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CHdrCaps::CHdrCaps(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CHdrCaps::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHdrCaps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CHdrCaps::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHdrCaps)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHdrCaps, CDialog)
	//{{AFX_MSG_MAP(CHdrCaps)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHdrCaps message handlers

BOOL CHdrCaps::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(7) ;
	csafieldnames[0] = _T("DF_NOITALIC") ;
	csafieldnames[1] = _T("DF_NOUNDER") ;
	csafieldnames[2] = _T("DF_XM_CR") ;
	csafieldnames[3] = _T("DF_NO_BOLD") ;
	csafieldnames[4] = _T("DF_NO_DOUBLE_UNDERLINE") ;
	csafieldnames[5] = _T("DF_NO_STRIKETHRU") ;
	csafieldnames[6] = _T("DF_BKSP_OK") ;
	
	// Allocate flag groupings array.  Don't put anything in it because any
	// combination of flags can be set.

	CUIntArray cuiaflaggroupings ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 0,
					  lptstrSet, 123, false) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CHdrCaps::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIFamilyNames dialog

CFIFIFamilyNames::CFIFIFamilyNames(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFamilyNames::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIFamilyNames::CFIFIFamilyNames(CString* pcsfirstname,
								   CFontIFIMetricsPage* pcfimp,
								   CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFamilyNames::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIFamilyNames)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsFirstName = pcsfirstname ;
	m_pcfimp = pcfimp ;
}


void CFIFIFamilyNames::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIFamilyNames)
	DDX_Control(pDX, IDC_NamesLst, m_cfelcFamilyNames);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIFamilyNames, CDialog)
	//{{AFX_MSG_MAP(CFIFIFamilyNames)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIFamilyNames message handlers

BOOL CFIFIFamilyNames::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Get the current list of family names.  If the names have been changed
	// before in this editting session, the names will be in this dialog's
	// parent page.  If not, the names are in the associated UFM.

	CStringArray	csadata, *pcsadata ;
	if (m_pcfimp->m_csaFamilyNames.GetSize())
		pcsadata = &m_pcfimp->m_csaFamilyNames ;
	else
		pcsadata = &m_pcfimp->m_pcfi->m_csaFamily ;
	int numfields = (int)pcsadata->GetSize() ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 256 characters.

	m_cfelcFamilyNames.InitControl(LVS_EX_FULLROWSELECT, numfields, 1, 0, 256,
								  MF_SENDCHANGEMESSAGE) ;

	// Init and load the family names column.

	m_cfelcFamilyNames.InitLoadColumn(0, _T("Name"), SETWIDTHTOREMAINDER, 0,
									  true, true, COLDATTYPE_STRING,
									  (CObArray*) pcsadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIFamilyNames::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new names out of the list control and delete any empty entries.
	
	CStringArray csa ;
	m_cfelcFamilyNames.GetColumnData((CObArray*) &csa, 0) ;
	for (int n = (int)csa.GetSize() - 1 ; n >= 0 ; n--)
		if (csa[n].IsEmpty())
			csa.RemoveAt(n) ;

	// If there are no names left in the list, complain, and return without
	// closing the dialog.

	if (csa.GetSize() == 0) {
		AfxMessageBox(IDS_NoFamilyNamesError, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	// Save the new array of family names into the IFI page's member variable.
	// (The new data is saved there instead of in the UFM because the user may
	// decide later that he doesn't want to save his UFM changes.)  Then update
	// the string containing the first family name so that it can be displayed
	// on the IFI page.

	m_pcfimp->m_csaFamilyNames.RemoveAll() ;
	m_pcfimp->m_csaFamilyNames.Copy(csa) ;
	*m_pcsFirstName = csa[0] ;

	// Mark the UFM dirty and wrap things up.

	m_pcfimp->m_pcfi->Changed() ;
	CDialog::OnOK();
}


LRESULT CFIFIFamilyNames::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the family names list has changed.

	m_bChanged = true ;

	return TRUE ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims dialog


CFIFIFontSims::CFIFIFontSims(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFontSims::IDD, pParent)
{
	ASSERT(0) ;
}


CFIFIFontSims::CFIFIFontSims(CString* pcsfontsimdata,
							 CFontIFIMetricsPage* pcfimp,
							 CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFontSims::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIFontSims)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pcsFontSimData = pcsfontsimdata ;
	m_pcfimp = pcfimp ;
	m_bInitDone = m_bChanged = false ;

	// Initialze the "font sim groups have been loaded" flags array.

	int numgrps = CFontInfo::BothDiff - CFontInfo::ItalicDiff + 1 ;
	m_cuiaFontSimGrpLoaded.SetSize(numgrps) ;
	for (int n = 0 ; n < numgrps ; n++)
		m_cuiaFontSimGrpLoaded[n] = 0 ;
}


void CFIFIFontSims::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIFontSims)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIFontSims, CDialog)
	//{{AFX_MSG_MAP(CFIFIFontSims)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_EnableItalicSim, IDC_EnableBISim, OnSetAnySimState)
    ON_CONTROL_RANGE(EN_CHANGE, IDC_ItalicWeight, IDC_BoldItalicSlant, OnChangeAnyNumber)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims message handlers

BOOL CFIFIFontSims::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Loop through each set of font simulation controls to enable/disable
	// them and load them from the appropriate source when necessary.

	for (int n = IDC_EnableItalicSim ; n <= IDC_EnableBISim ; n++) {
		InitSetCheckBox(n) ;
		OnSetAnySimState(n) ;	// DEAD_BUG - May not be necessary.
	}
	
	m_bInitDone = true ;		// Initialization done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIFontSims::OnOK()
{
	unsigned udataidx, ufirstdataid, unumdata, u2 ;	// Each var defined below
	CWordArray* pcwasimdata ;

	// If nothing changed, call OnCancel() to close just the dialog box so 
	// that the program doesn't think that any of the font simulations changed.
	// This will keep the programming from prompting the user to save the UFM
	// even though nothing has actually changed.

	if (!m_bChanged) {
		CDialog::OnCancel() ;
		return ;
	} ;

	// Loop through each simulation in the dialog box.

	for (unsigned u = IDC_EnableItalicSim ; u <= IDC_EnableBISim ; u++) {
		// Turn the control id into a data index that can be used to reference
		// font simulation data in this and other class instances.

		udataidx = u - IDC_EnableItalicSim ;
		ASSERT(udataidx <= CFontInfo::BothDiff) ;

		// Save the state of this simulation but don't save any of its data if
		// it is disabled.
	
		m_pcfimp->m_cuiaFontSimStates[udataidx] = IsDlgButtonChecked(u) ;
		if (m_pcfimp->m_cuiaFontSimStates[udataidx] == 0)
			continue ;

		// Get the ID of the first edit box in the simulation and the number of
		// pieces of data (ie, edit boxes) in this simulation.

		ufirstdataid = auBaseFontSimCtrlID[udataidx] ;
		unumdata = auNumFontSimCtrls[udataidx] ;

		// The data is saved in the class' parent so that the CFontInfo data is
		// not changed before the user has agreed that the new data should be
		// saved.  Get a pointer to the appropriate array and make sure it is
		// sized correctly.

		pcwasimdata = m_pcfimp->GetFontSimDataPtr(udataidx) ;
		pcwasimdata->SetSize(unumdata) ;

		// Get the data in this font simulation group.

		for (u2 = 0 ; u2 < unumdata ; u2++)
			(*pcwasimdata)[u2] = (USHORT)GetDlgItemInt(ufirstdataid + u2, NULL, false) ;
	} ;

	CDialog::OnOK() ;
}


/******************************************************************************

  CFIFIFontSims::OnSetAnySimState

  Called when any simulation is enabled or disabled.  Updates the UI
  appropriately.  Decode which simulation it is, and init any values we
  ought to.

******************************************************************************/

void CFIFIFontSims::OnSetAnySimState(unsigned ucontrolid)
{
	// Get the state of the check box.	

    unsigned ucheckboxstate = IsDlgButtonChecked(ucontrolid) ;

	// Turn the control id into a data index that can be used to reference font
	// simulation data in this and other class instances.

	unsigned udataidx = ucontrolid - IDC_EnableItalicSim ;
	ASSERT(udataidx <= CFontInfo::BothDiff) ;

	// Get the ID of the first edit box in the simulation whose state has
	// changed and the number of pieces of data (ie, edit boxes) in this
	// simulation.

	unsigned ufirstdataid = auBaseFontSimCtrlID[udataidx] ;
	unsigned unumdata = auNumFontSimCtrls[udataidx] ;

	// Set the state of the corresponding edit boxes to that of their check
	// box.

	for (unsigned u = 0 ; u < unumdata ; u++)
        GetDlgItem(ufirstdataid + u)->EnableWindow(ucheckboxstate) ;

	// If this dialog box has been initialized, set the changed flag and set the
	// touched flag for this simulation.

	if (m_bInitDone) {
		m_bChanged = true ;
		m_pcfimp->m_cuiaSimTouched[udataidx] = 1 ;
	} ;

	// Nothing else needs to be done in one of two cases.  First, if the
	// controls were just disabled.  Second, if the controls have already
	// been loaded.  Return if either is the case.

	if (ucheckboxstate == 0 || m_cuiaFontSimGrpLoaded[udataidx] != 0)
		return ;

	// Note that the font sim group is about to be loaded so that it won't
	// happen again.

	m_cuiaFontSimGrpLoaded[udataidx] = 1 ;

	// Determine where to get the data for this font sim group. The data in this
	// class' parent class (CFontIFIMetricsPage) always takes precedence if it
	// is there because it will be the most up to date.  It is possible that
	// there is no data to load.  In this case, load the sim group with default
	// data from the IFIMETRICS structure and then return.

	CWordArray* pcwasimdata = m_pcfimp->GetFontSimDataPtr(udataidx) ;
	if (pcwasimdata->GetSize() == 0) {
		if (m_pcfimp->m_pcfi->Diff(udataidx) == NULL) {
			IFIMETRICS*	pim = &m_pcfimp->m_pcfi->m_IFIMETRICS ;			
			SetDlgItemInt(ufirstdataid + 0, pim->usWinWeight) ;
			SetDlgItemInt(ufirstdataid + 1, pim->fwdMaxCharInc) ;
			SetDlgItemInt(ufirstdataid + 2, pim->fwdAveCharWidth) ;
			if (ucontrolid != IDC_EnableBoldSim)
				SetDlgItemInt(ufirstdataid + 3, 175) ;
			return ;
		} ;
		pcwasimdata = m_pcfimp->m_pcfi->GetFontSimDataPtr(udataidx) ;
	} ;

	// Load the controls that will display the font sim group's data with
	// the existing font sim data.
//RAID 43542) PREFIX 

	if(pcwasimdata == NULL ){
		AfxMessageBox(IDS_ResourceError);
		return ;
	}
// END RAID
	for (u = 0 ; u < unumdata ; u++)
        SetDlgItemInt(ufirstdataid + u, (*pcwasimdata)[u]) ;

	// We're done now so...

	return ;
}


void CFIFIFontSims::OnChangeAnyNumber(unsigned ucontrolid)
{
	// Do nothing if this dialog box has not been initialized.

	if (!m_bInitDone)
		return ;

	// Set the changed flag.

	m_bChanged = true ;

	// Determine which simulation was just changed and set its touched flag.

	int n = 0 ;
	if (ucontrolid >= auBaseFontSimCtrlID[1])
		n++ ;
	if (ucontrolid >= auBaseFontSimCtrlID[2])
		n++ ;
	m_pcfimp->m_cuiaSimTouched[n] = 1 ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims implementation

void CFIFIFontSims::InitSetCheckBox(int ncontrolid)
{		
	// Turn the control id into a data index that can be used to reference font
	// simulation data in this and other class instances.

	int ndataidx = ncontrolid - IDC_EnableItalicSim ;

	// Determine what data to use to set/clear this check box.  The data in this
	// class' parent class (CFontIFIMetricsPage) always takes precedence if it
	// is there because it will be the most up to date.

	int ncheckboxstate ;
	CWordArray* pcwasimdata = m_pcfimp->GetFontSimDataPtr(ndataidx) ;
	if (pcwasimdata->GetSize() > 0)
		ncheckboxstate = (int) m_pcfimp->m_cuiaFontSimStates[ndataidx] ;
	else
		ncheckboxstate = m_pcfimp->m_pcfi->Diff(ndataidx) != NULL ;

	// Now that the check box's state is known, set it.

    CheckDlgButton(ncontrolid, ncheckboxstate) ;
}


/******************************************************************************

  CFontIFIMetricsPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1).

******************************************************************************/

BOOL CFontIFIMetricsPage::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_FONT_VIEWER) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinCharSet dialog


CFIFIWinCharSet::CFIFIWinCharSet(CWnd* pParent /*=NULL*/)
	: CDialog(CHdrTypes::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIWinCharSet::CFIFIWinCharSet(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIWinCharSet::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIWinCharSet)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFIWinCharSet::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIWinCharSet)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIWinCharSet, CDialog)
	//{{AFX_MSG_MAP(CFIFIWinCharSet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinCharSet message handlers

BOOL CFIFIWinCharSet::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Don't display the unknown field name.  Compute a new count to make this
	// happen.

	int numfields = nWinCharSet - 1 ;

	// Allocate and load the field names array.  While doing this, determine the
	// current (single) flag setting.

	CStringArray csafieldnames ;
	csafieldnames.SetSize(numfields) ;
	DWORD dwsettings, dwbit = 1 ;
	bool bmatchfound = false ;
	for (int n = 0 ; n < numfields ; n++, dwbit <<= 1) {
		csafieldnames[n] = apstrWinCharSet[n] ;
		if (csafieldnames[n] == *m_pcsFlags) {
			dwsettings = dwbit ;
			bmatchfound = true ;
		} ;
	} ;

	// Assert if no matching setting was found.

	ASSERT(bmatchfound) ;	//delte the line : raid 104822

	// Allocate and fill the flag groupings array.  There is only one flag
	// group.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(2) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = numfields - 1 ;

	// Initialize the flags list.

	m_cflbFlags.Init(csafieldnames, dwsettings, cuiaflaggroupings, 1, lptstrSet,
					 109, true) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIWinCharSet::OnOK()
{
	// Get the value of the single flag that was selected.

	DWORD dwflag = m_cflbFlags.GetNewFlagDWord() ;
	
	// Use the selected flag to determine the new flag name to display.

	DWORD dwbit = 1 ;
	for (int n = 0 ; n < nWinCharSet ; n++, dwbit <<= 1) {
		if (dwbit == dwflag) {
			*m_pcsFlags = apstrWinCharSet[n] ;
			break ;
		} ;
	} ;

	// Blow if a matching flag was not found.  This should never happen.

	ASSERT(n < nWinCharSet) ;

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinPitchFamily dialog


CFIFIWinPitchFamily::CFIFIWinPitchFamily(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIWinPitchFamily::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIWinPitchFamily::CFIFIWinPitchFamily(CString* pcsflags,
										 CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIWinPitchFamily::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIWinPitchFamily)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFIWinPitchFamily::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIWinPitchFamily)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIWinPitchFamily, CDialog)
	//{{AFX_MSG_MAP(CFIFIWinPitchFamily)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinPitchFamily message handlers

BOOL CFIFIWinPitchFamily::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(8) ;
	csafieldnames[0] = _T("FIXED_PITCH") ;
	csafieldnames[1] = _T("VARIABLE_PITCH") ;
	csafieldnames[2] = _T("FF_DONTCARE") ;
	csafieldnames[3] = _T("FF_ROMAN") ;
	csafieldnames[4] = _T("FF_SWISS") ;
	csafieldnames[5] = _T("FF_MODERN") ;
	csafieldnames[6] = _T("FF_SCRIPT") ;
	csafieldnames[7] = _T("FF_DECORATIVE") ;
	
	// Allocate flag groupings array.  Allocate space for and initialize the
	// two flag groups.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(4) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = -1 ;
	cuiaflaggroupings[2] = 2 ;
	cuiaflaggroupings[3] = 7 ;

	// The FlagsListBox used to display and edit values is not exactly right
	// for this field because the high half of jWinPitchAndFamily contains a
	// value; NOT a single bit flag.  So, the value sent to m_cflbFlags.Init2()
	// must be converted into a flag that the function can display correctly.
	// (This is easier than writing a new class that understands value fields
	// instead of flag fields.)

	DWORD dwv1, dwv2 ;
	LPTSTR lptstr, lptstr2 ;
	lptstr = m_pcsFlags->GetBuffer(16) ;
	int n = m_pcsFlags->GetLength() ;
	*(lptstr + n) = 0 ;
	if (*(lptstr + 1) == 'x')
		lptstr += 2 ;
	dwv2 = strtoul(lptstr, &lptstr2, 16) ;
	dwv1 = dwv2 & 3 ;
	dwv2 -= dwv1 ;
	dwv2 >>= 4 ;
	dwv2++ ;
	//dwv2 += 2 ;
	dwv2 = (2 << dwv2) + dwv1 ;
		
	// Initialize and load the flags list.

	m_cflbFlags.Init(csafieldnames, dwv2, cuiaflaggroupings, 2,
					 lptstrSet, 108, true, 1) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIWinPitchFamily::OnOK()
{
	// The FlagsListBox used to display and edit values is not exactly right
	// for this field because the high half of jWinPitchAndFamily contains a
	// value; NOT a single bit flag.  So, the value returned by 
	// m_cflbFlags.GetNewFlagDWord() is not right for this field.  Isolate the
	// Family bit and turn it into the correct Family value.

	DWORD dwv, dwv1, dwv2 ;
	dwv = m_cflbFlags.GetNewFlagDWord() ;
	dwv1 = dwv & 3 ;
	dwv >>= 3 ;
	dwv2 = 0 ;
	if (dwv >= 1) {
		for (dwv2 = 1 ; dwv > 1 ; dwv2++)
			dwv >>= 1 ;
	} ;
	dwv = dwv1 + (dwv2 << 4) ;
	m_pcsFlags->Format("0x%02x", dwv) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIInfo dialog


CFIFIInfo::CFIFIInfo(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIInfo::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIInfo::CFIFIInfo(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIInfo::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIInfo)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFIInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIInfo)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIInfo, CDialog)
	//{{AFX_MSG_MAP(CFIFIInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIInfo message handlers

BOOL CFIFIInfo::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	InfoLoadNamesData(csafieldnames) ;
	
	// Allocate flag groupings array.  Don't put anything in it because any
	// combination of flags can be set.

	CUIntArray cuiaflaggroupings ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 0,
					  lptstrSet, 168, false) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIInfo::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


void CFIFIInfo::InfoLoadNamesData(CStringArray& csafieldnames)
{
	csafieldnames.SetSize(32) ;
	csafieldnames[0]  = _T("FM_INFO_TECH_TRUETYPE") ;
	csafieldnames[1]  = _T("FM_INFO_TECH_BITMAP") ;
	csafieldnames[2]  = _T("FM_INFO_TECH_STROKE") ;
	csafieldnames[3]  = _T("FM_INFO_TECH_OUTLINE_NOT_TRUETYPE") ;
	csafieldnames[4]  = _T("FM_INFO_ARB_XFORMS") ;
	csafieldnames[5]  = _T("FM_INFO_1BPP") ;
	csafieldnames[6]  = _T("FM_INFO_4BPP") ;
	csafieldnames[7]  = _T("FM_INFO_8BPP") ;
	csafieldnames[8]  = _T("FM_INFO_16BPP") ;
	csafieldnames[9]  = _T("FM_INFO_24BPP") ;
	csafieldnames[10] = _T("FM_INFO_32BPP") ;
	csafieldnames[11] = _T("FM_INFO_INTEGER_WIDTH") ;
	csafieldnames[12] = _T("FM_INFO_CONSTANT_WIDTH") ;
	csafieldnames[13] = _T("FM_INFO_NOT_CONTIGUOUS") ;
	csafieldnames[14] = _T("FM_INFO_TECH_MM") ;
	csafieldnames[15] = _T("FM_INFO_RETURNS_OUTLINES") ;
	csafieldnames[16] = _T("FM_INFO_RETURNS_STROKES") ;
	csafieldnames[17] = _T("FM_INFO_RETURNS_BITMAPS") ;
	csafieldnames[18] = _T("FM_INFO_DSIG") ;
	csafieldnames[19] = _T("FM_INFO_RIGHT_HANDED") ;
	csafieldnames[20] = _T("FM_INFO_INTEGRAL_SCALING") ;
	csafieldnames[21] = _T("FM_INFO_90DEGREE_ROTATIONS") ;
	csafieldnames[22] = _T("FM_INFO_OPTICALLY_FIXED_PITCH") ;
	csafieldnames[23] = _T("FM_INFO_DO_NOT_ENUMERATE") ;
	csafieldnames[24] = _T("FM_INFO_ISOTROPIC_SCALING_ONLY") ;
	csafieldnames[25] = _T("FM_INFO_ANISOTROPIC_SCALING_ONLY") ;
	csafieldnames[26] = _T("FM_INFO_MM_INSTANCE") ;
	csafieldnames[27] = _T("FM_INFO_FAMILY_EQUIV") ;
	csafieldnames[28] = _T("FM_INFO_DBCS_FIXED_PITCH") ;
	csafieldnames[29] = _T("FM_INFO_NONNEGATIVE_AC") ;
	csafieldnames[30] = _T("FM_INFO_IGNORE_TC_RA_ABLE") ;
	csafieldnames[31] = _T("FM_INFO_TECH_TYPE1") ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFISelection dialog


CFIFISelection::CFIFISelection(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFISelection::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFISelection::CFIFISelection(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFISelection::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFISelection)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFISelection::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFISelection)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFISelection, CDialog)
	//{{AFX_MSG_MAP(CFIFISelection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFISelection message handlers

BOOL CFIFISelection::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(7) ;
	csafieldnames[0] = _T("FM_SEL_ITALIC") ;
	csafieldnames[1] = _T("FM_SEL_UNDERSCORE") ;
	csafieldnames[2] = _T("FM_SEL_NEGATIVE") ;
	csafieldnames[3] = _T("FM_SEL_OUTLINED") ;
	csafieldnames[4] = _T("FM_SEL_STRIKEOUT") ;
	csafieldnames[5] = _T("FM_SEL_BOLD") ;
	csafieldnames[6] = _T("FM_SEL_REGULAR") ;
	
	// Allocate flag groupings array.  Put info on one group in it; the last two
	// flags.  The first five can be ignored in the groupings array because any
	// combination of them can be set.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(2) ;
	cuiaflaggroupings[0] = -5 ;
	cuiaflaggroupings[1] = -6 ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 1,
					  lptstrSet, 109, false) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFISelection::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIPoint dialog


CFIFIPoint::CFIFIPoint(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPoint::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIPoint::CFIFIPoint(CString* pcspoint, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPoint::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIPoint)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsPoint = pcspoint ;
}


void CFIFIPoint::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIPoint)
	DDX_Control(pDX, IDC_PointsLst, m_cfelcPointLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIPoint, CDialog)
	//{{AFX_MSG_MAP(CFIFIPoint)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIPoint message handlers

BOOL CFIFIPoint::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	const int numfields = 2 ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 16 characters.  We also
	// want change notification and to suppress acting on INS/DEL keys.

	m_cfelcPointLst.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 16,
							   MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Load the point field names into an array and use them to initialize the
	// first column.

	CStringArray csadata ;
	csadata.SetSize(numfields) ;
	csadata[0] = _T("X") ;
	csadata[1] = _T("Y") ;
	m_cfelcPointLst.InitLoadColumn(0, _T("Point"), COMPUTECOLWIDTH, 20, false,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	// Parse the X and Y values out of the string from the IFI page.

	ParseCompoundNumberString(csadata, m_pcsPoint, numfields) ;
	
	// Init and load the point values column.

	m_cfelcPointLst.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -20, true,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIPoint::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new point values out of the list control.
	
	CStringArray csadata ;
	m_cfelcPointLst.GetColumnData((CObArray*) &csadata, 1) ;

	// If either value is blank, complain and return without closing the
	// dialog.

	if (csadata[0].GetLength() == 0 || csadata[1].GetLength() == 0) {
		AfxMessageBox(IDS_MissingFieldError, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	// Format the new point values for display.

	m_pcsPoint->Format("{%s, %s}", csadata[0], csadata[1]) ;

	// Wrap things up.

	CDialog::OnOK();
}


LRESULT CFIFIPoint::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the dialog box is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the a point value has changed.

	m_bChanged = true ;

	return TRUE ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIRectangle dialog


CFIFIRectangle::CFIFIRectangle(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIRectangle::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIRectangle::CFIFIRectangle(CString* pcsrect, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIRectangle::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIRectangle)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsRect = pcsrect ;
}


void CFIFIRectangle::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIRectangle)
	DDX_Control(pDX, IDC_RectLst, m_cfelcSidesLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIRectangle, CDialog)
	//{{AFX_MSG_MAP(CFIFIRectangle)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIRectangle message handlers

BOOL CFIFIRectangle::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	const int numfields = 4 ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 16 characters.  We also
	// want change notification and to suppress acting on INS/DEL keys.

	m_cfelcSidesLst.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 16,
							   MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Load the point field names into an array and use them to initialize the
	// first column.

	CStringArray csadata ;
	csadata.SetSize(numfields) ;
	csadata[0] = _T("Left") ;
	csadata[1] = _T("Top") ;
	csadata[2] = _T("Right") ;
	csadata[3] = _T("Bottom") ;
	m_cfelcSidesLst.InitLoadColumn(0, _T("Side"), COMPUTECOLWIDTH, 20, false,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	// Parse the side values out of the string from the IFI page.

	ParseCompoundNumberString(csadata, m_pcsRect, numfields) ;
	
	// Init and load the side values column.

	m_cfelcSidesLst.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -20, true,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIRectangle::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new rectangle values out of the list control.
	
	CStringArray csadata ;
	m_cfelcSidesLst.GetColumnData((CObArray*) &csadata, 1) ;

	// If any value is blank, complain and return without closing the
	// dialog.

	int numentries = (int)csadata.GetSize() ;
	for (int n = 0 ; n < numentries ; n++) {
		if (csadata[n].GetLength() == 0) {
			AfxMessageBox(IDS_MissingFieldError, MB_ICONEXCLAMATION) ;
			return ;
		} ;
	} ;

	// Format the new point values for display.

	m_pcsRect->Format("{%s, %s, %s, %s}", csadata[0], csadata[1], csadata[2],
					  csadata[3]) ;

	// Wrap things up.

	CDialog::OnOK();
}


LRESULT CFIFIRectangle::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the dialog box is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the a rectange value has changed.

	m_bChanged = true ;

	return TRUE ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIPanose dialog


CFIFIPanose::CFIFIPanose(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPanose::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIPanose::CFIFIPanose(CString* pcspanose, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPanose::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIPanose)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsPanose = pcspanose ;
}


void CFIFIPanose::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIPanose)
	DDX_Control(pDX, IDC_PanoseLst, m_cfelcPanoseLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIPanose, CDialog)
	//{{AFX_MSG_MAP(CFIFIPanose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIPanose message handlers

BOOL CFIFIPanose::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	const int numfields = 10 ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 3 characters.  We also
	// want change notification and to suppress acting on INS/DEL keys.

	m_cfelcPanoseLst.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 3,
							    MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Load the point field names into an array and use them to initialize the
	// first column.

	CStringArray csadata ;
	csadata.SetSize(numfields) ;
	csadata[0] = _T("bFamilyType") ;
	csadata[1] = _T("bSerifStyle") ;
	csadata[2] = _T("bWeight") ;
	csadata[3] = _T("bProportion") ;
	csadata[4] = _T("bContrast") ;
	csadata[5] = _T("bStrokeVariation") ;
	csadata[6] = _T("bArmStyle") ;
	csadata[7] = _T("bLetterform") ;
	csadata[8] = _T("bMidline") ;
	csadata[9] = _T("bXHeight") ;
	m_cfelcPanoseLst.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 15, false,
								   false, COLDATTYPE_STRING,
								   (CObArray*) &csadata) ;

	// Parse the panose values out of the string from the IFI page.

	ParseCompoundNumberString(csadata, m_pcsPanose, numfields) ;
	
	// Init and load the side values column.

	m_cfelcPanoseLst.InitLoadColumn(1, _T("Value (0 - 255)"),
								   SETWIDTHTOREMAINDER, -16, true, false,
								   COLDATTYPE_STRING, (CObArray*) &csadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIPanose::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new panose values out of the list control.
	
	CStringArray csadata ;
	m_cfelcPanoseLst.GetColumnData((CObArray*) &csadata, 1) ;

	// If any value is blank, complain and return without closing the
	// dialog.

	int numentries = (int)csadata.GetSize() ;
	for (int n = 0 ; n < numentries ; n++) {
		if (csadata[n].GetLength() == 0) {
			AfxMessageBox(IDS_MissingFieldError, MB_ICONEXCLAMATION) ;
			return ;
		} ;
	} ;

	// Format the new panose values for display.

	m_pcsPanose->Format("{%s, %s, %s, %s, %s, %s, %s, %s, %s, %s}", csadata[0],
						csadata[1], csadata[2], csadata[3], csadata[4],
						csadata[5], csadata[6], csadata[7], csadata[8],
						csadata[9]) ;

	// Wrap things up.

	CDialog::OnOK();
}


LRESULT CFIFIPanose::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the dialog box is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the a panose value has changed.

	m_bChanged = true ;

	return TRUE ;
}




/////////////////////////////////////////////////////////////////////////////
// CWidthKernCheckResults dialog


CWidthKernCheckResults::CWidthKernCheckResults(CWnd* pParent /*=NULL*/)
	: CDialog(CWidthKernCheckResults::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CWidthKernCheckResults::CWidthKernCheckResults(CFontInfo* pcfi,
											   CWnd* pParent /*=NULL*/)
	: CDialog(CWidthKernCheckResults::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWidthKernCheckResults)
	m_csKernChkResults = _T("");
	m_csWidthChkResults = _T("");
	//}}AFX_DATA_INIT

	// Save the pointer to the font info class

	m_pcfi = pcfi ;
}


void CWidthKernCheckResults::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWidthKernCheckResults)
	DDX_Control(pDX, IDC_BadKerningPairs, m_clcBadKernPairs);
	DDX_Text(pDX, IDC_KernTblResults, m_csKernChkResults);
	DDX_Text(pDX, IDC_WidthTblResults, m_csWidthChkResults);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWidthKernCheckResults, CDialog)
	//{{AFX_MSG_MAP(CWidthKernCheckResults)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWidthKernCheckResults message handlers

/******************************************************************************

  CWidthKernCheckResults::OnInitDialog

  Perform what consistency checks there are that can easily be done on the
  widths and kerning tables.  Then display the results in this dialog box.

******************************************************************************/

BOOL CWidthKernCheckResults::OnInitDialog()
{
	CDialog::OnInitDialog() ;
	
	// Load the appropriate message depending on the state of the widths table.

	if (m_pcfi->WidthsTableIsOK())
		m_csWidthChkResults.LoadString(IDS_WidthsTableOK) ;
	else
		m_csWidthChkResults.LoadString(IDS_WidthsTableTooBig) ;

	// Initialize the bad kerning info list control.

    CString csWork ;
    csWork.LoadString(IDS_KernColumn0) ;
    m_clcBadKernPairs.InsertColumn(0, csWork, LVCFMT_CENTER,
        (3 * m_clcBadKernPairs.GetStringWidth(csWork)) >> 1, 0) ;
    csWork.LoadString(IDS_KernColumn1) ;
    m_clcBadKernPairs.InsertColumn(1, csWork, LVCFMT_CENTER,
        m_clcBadKernPairs.GetStringWidth(csWork) << 1, 1) ;
    csWork.LoadString(IDS_KernColumn2) ;
    m_clcBadKernPairs.InsertColumn(2, csWork, LVCFMT_CENTER,
        m_clcBadKernPairs.GetStringWidth(csWork) << 1, 2) ;

	// Load any bad kerning info in the list control for display and use the
	// existence of this data to determine the appropriate message to display.

	if (m_pcfi->LoadBadKerningInfo(m_clcBadKernPairs))
		m_csKernChkResults.LoadString(IDS_KerningTableBadEnts) ;
	else
		m_csKernChkResults.LoadString(IDS_KerningTableOK) ;

	UpdateData(FALSE) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\freeze.h ===
void InitFreeze(HWND hedit, void** ppunk, void** ppdoc, long* plcount) ;
void Freeze(void* pdoc, long* plcount) ;
void Unfreeze(void* pdoc, long* plcount) ;
void ReleaseFreeze(void** ppunk, void** ppdoc) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\freeze.cpp ===
/******************************************************************************

  Source File:  Freeze.CPP

  This file implements the REC freezing and unfreezing routines.

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include	<tom.h>


#ifdef	DEFINE_GUID
#undef	DEFINE_GUID
#endif
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUID(IID_ITextDocument,0x8CC497C0L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);


/******************************************************************************

  InitFreeze

  Get the COM pointers needed to freeze and unfreeze a Rich Edit Control.

******************************************************************************/

void InitFreeze(HWND hedit, void** ppunk, void** ppdoc, long* plcount)
{
	::SendMessage(hedit, EM_GETOLEINTERFACE, 0, (LPARAM) ppunk) ;
	ASSERT(*ppunk != NULL) ;

	((IUnknown *) *ppunk)->QueryInterface(IID_ITextDocument, ppdoc) ;
	ASSERT(*ppdoc != NULL) ;
	
	*plcount = 0 ;

	TRACE("FRZ:  punk = %x\tpdoc = %x\n", *ppunk, *ppdoc) ;
}


/******************************************************************************

  Freeze

  Freeze a Rich Edit Control.

******************************************************************************/

void Freeze(void* pdoc, long* plcount)
{
	ASSERT(pdoc != NULL) ;
	((ITextDocument *) pdoc)->Freeze(plcount) ;
}


/******************************************************************************

  Unfreeze

  Unfreeze a Rich Edit Control.

******************************************************************************/

void Unfreeze(void* pdoc, long* plcount)
{
	ASSERT(pdoc != NULL) ;
	((ITextDocument *) pdoc)->Unfreeze(plcount) ;
}


/******************************************************************************

  ReleaseFreeze

  Release the COM pointers used to freeze and unfreeze a Rich Edit Control.

******************************************************************************/

void ReleaseFreeze(void** ppunk, void** ppdoc) 
{
	if (*ppdoc)
		((ITextDocument *) *ppdoc)->Release() ;
	if (*ppunk)
		((IUnknown *) *ppunk)->Release() ;
	*ppdoc = *ppunk = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontinfo.h ===
/******************************************************************************

  Header File:  Generic Font Information.H

  This file contains a set of classes intended to incorporate the information
  currently stored in the various font metric and related structures.  These
  classes are serializable, and will be capable of being loaded from and fed to
  the various other formats.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(GENERIC_FONT_INFORMATION)
#define GENERIC_FONT_INFORMATION

#include    "GTT.H"
#include    "CodePage.H"
#include    "resource.h"
#include    "Llist.h"

/*
//  These are used to glue in UFM-specific stuff

struct INVOCATION {
    DWORD   dwcbCommand;    //  Byte size of string
    DWORD   dwofCommand;    //  Offset in the file to the string
};
*/

//  `Yes, this is a bit sleazy, but DirectDraw has nothing now or ever to
//  do with this tool, so why waste time tracking down more files?

/*
#define __DD_INCLUDED__
typedef DWORD   PDD_DIRECTDRAW_GLOBAL, PDD_SURFACE_LOCAL, DESIGNVECTOR,
                DD_CALLBACKS, DD_HALINFO,
                DD_SURFACECALLBACKS, DD_PALETTECALLBACKS, VIDEOMEMORY;
*/

//#define INVOCATION   int
#define DESIGNVECTOR int											// We need lots of stuff from winddi.h and fmnewfm.h,
																	//  but the compiler whines, so I will cheat and provide a bogus
#include    "winddi.h"												//  definition for DESIGNVECTOR, which we never use anyway, so it's
#include    "fmnewfm.h"												//  okay, right?  What a hack!
#include    <math.h>



/******************************************************************************

  CFontDifference

  This class handles the information content analogous to the FONTDIFF
  structure.

******************************************************************************/

class CFontDifference
{
    CWordArray  m_cwaMetrics;
    CBasicNode  *m_pcbnOwner;

public:
    CFontDifference(WORD wWeight, WORD wMax, WORD wAverage, WORD wAngle, CBasicNode *pcbn)
		{
        m_cwaMetrics.Add(wWeight);
        m_cwaMetrics.Add(wMax);
        m_cwaMetrics.Add(wAverage);
        m_cwaMetrics.Add(wAngle);
        m_pcbnOwner = pcbn;
		}

    CFontDifference(PBYTE pb, CBasicNode *pcbn);    //  Init from memory image

    //  Attributes

    enum {Weight, Max, Average, Angle};

    WORD    Metric(unsigned u)
			{
			int bob = 5;
			return m_cwaMetrics[u];
			}

    //  operations
    enum {OK, TooBig, Reversed};    //  Returns from SetMetric

    WORD		SetMetric(unsigned u, WORD wNew);
    void		Store(CFile& cfStore, WORD wfSelection);
	CWordArray* GetFontSimDataPtr() { return &m_cwaMetrics ; }
};

/******************************************************************************

  CFontInfo class

  This primarily encapsulates the UFM file, but it also has to handle some PFM
  and IF stuff, so it truly is generic.

******************************************************************************/

class CFontInfo : public CProjectNode
{
	// True iff the font was loaded by the workspace OR the font was loaded
	// directly AND its GTT/CP was found and loaded.

	bool	m_bLoadedByWorkspace ;
	
	// The flag above has many uses now so another flag is needed.  This flag
	// is only set when the UFM is being loaded by a workspace and no GTT/CP
	// could be loaded for it.

	bool	m_bWSLoadButNoGTTCP ;

	//DWORD   m_loWidthTable ;			// Width table offset from UFM file.  Used as
										// part of variable font determination.

public:

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			//  UNIFM_HDR

ULONG			m_ulDefaultCodepage;	
WORD			m_lGlyphSetDataRCID;										//  Translation table ID			// rm new

	const WORD      Translation() const		{ return m_lGlyphSetDataRCID; }										// rm new
	void			SetTranslation(WORD w)	{ m_lGlyphSetDataRCID = w; }										// rm new


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UNIDRVINFO		m_UNIDRVINFO;												//  UNIDRVINFO						// rm new

BOOL			m_fScalable;

CInvocation     m_ciSelect, m_ciDeselect;																	// rm moved from below

CInvocation&    Selector(BOOL bSelect = TRUE)
					{ return bSelect ? m_ciSelect : m_ciDeselect; }												// rm moved from below

CString GTTDescription() const;

//	IFIMETRICS  //////////////////////////////////////////////// ////////////
private:
    CString&  Family(unsigned u) { return m_csaFamily[u]; }
public:
	IFIMETRICS		m_IFIMETRICS;																// rm new

    WORD    SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode);

enum    {Default, Break};													// Used to set the wcDefaultChar, wcBreakChar,
																			//  chDefaultChar, and chBreakChar.
enum {OK, InvalidChar, DoubleByte};											// Return values for SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode)


WORD m_InternalLeading;
WORD m_Lowerd;
WORD m_Lowerp;
WORD m_ItalicAngle;

CStringArray    m_csaFamily;
CString         m_csStyle, m_csFace, m_csUnique;							//  Various names

CWordArray      m_cwaSpecial;												//  Special, little-used metrics
//BYTE            m_bCharacterSet, m_bPitchAndFamily;						// rm no longer needede
WORD            m_wWeight, m_wHeight;

//WORD            m_wAverageWidth,  m_wMaximumIncrement, m_wfStyle;		// rm no longer needede

//CByteArray      m_cbaSignificant;											//  Significant char codes (e.g., break)
//CWordArray      m_cwaSignificant;																		// rm absorbed into m_IFIMETRICS


//    const CString&  StyleName() const			{ return m_csStyle; }
//    const CString&  FaceName() const			{ return m_csFace; }
//    const CString&  UniqueName() const			{ return m_csUnique; }
    unsigned        Families() const			{ return (unsigned) m_csaFamily.GetSize(); }

//    void    SetStyleName(LPCTSTR lpstrNew)	{ m_csStyle = lpstrNew;		Changed(); }
//    void    SetFaceName(LPCTSTR lpstrNew)	{ m_csFace = lpstrNew;		Changed(); }
    void    SetUniqueName(LPCTSTR lpstrNew) { m_csUnique = lpstrNew;	Changed(); }				// used by rcfile.cpp
    BOOL    AddFamily(LPCTSTR lpstrNew);
    void    RemoveFamily(LPCTSTR lpstrDead);


//    WORD    Family() const						{ return m_bPitchAndFamily & 0xF0; }			// rm no longer needed
//    WORD    CharSet() const						{ return m_bCharacterSet; }						// rm no longer needed
//    WORD    Weight() const						{ return m_wWeight; }								// rm no longer needed
    WORD    Height() const						{ return m_wHeight; }

//    WORD    MaxWidth() const					{ return m_wMaximumIncrement; }							// rm no longer needed
//    WORD    AverageWidth() const				{ return m_wAverageWidth; }								// rm no longer needed

//    enum    {Old_First, Last, Default, Break};
//    WORD    SignificantChar(WORD wid, BOOL bUnicode = TRUE) const										// rm no longer needed
//				{ return bUnicode ? m_cwaSignificant[wid] : m_cbaSignificant[wid];  }

//    void    InterceptItalic(CPoint& cpt) const;														// rm no longer needed


//    void    SetFamily(BYTE bNew)	{ m_bPitchAndFamily &= 0xF;	m_bPitchAndFamily |= (bNew & 0xF0);		// rm no longer needed
//									 Changed();	}
    BOOL    SetCharacterSet(BYTE bNew);
//    void    SetWeight(WORD wWeight) { m_wWeight = wWeight; Changed(); }								// rm no longer needed
    BOOL    SetHeight(WORD wHeight);
    void    SetMaxWidth(WORD wWidth);

    void    SetSpecial(unsigned ufMetric, short sSpecial);




    enum {Italic = 1, Underscore, StrikeOut = 0x10};



    void    ChangePitch(BOOL bFixed = FALSE);


    enum {	CapH, LowerX, SuperSizeX, SuperSizeY,			//
			SubSizeX, SubSizeY, SuperMoveX, SuperMoveY,
			SubMoveX, SubMoveY, ItalicAngle, UnderSize,
			UnderOffset, StrikeSize, StrikeOffset,
			oldBaseline,
			/*Baseline, */  InterlineGap, Lowerp, Lowerd,
			InternalLeading};

    const short     SpecialMetric(unsigned uIndex) const	{ return (short) m_cwaSpecial[uIndex]; }


	BOOL    DBCSFont() const															// rm new
		{ return  m_IFIMETRICS.jWinCharSet > 127 && m_IFIMETRICS.jWinCharSet < 145; }	//  This looks right, but no OFFICIAL way seems to exist


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			// FONT SIMULATIONS

CFontDifference *m_pcfdBold, *m_pcfdItalic, *m_pcfdBoth;					//  Simulations

enum {ItalicDiff, BoldDiff, BothDiff};

//    CFontDifference *Diff(unsigned u) {	return u ? u == BothDiff ? m_pcfdBoth : m_pcfdBold : m_pcfdItalic;	}

    CFontDifference *  Diff(unsigned u)
		{
		CFontDifference * FontDiff = m_pcfdBold;							// preset return value

		if (!u)				FontDiff = m_pcfdItalic;
		if (u == BothDiff)  FontDiff = m_pcfdBoth;
		return FontDiff;	
		}

    void    EnableSim(unsigned uSim, BOOL bOn, CFontDifference * & pcfd);
	CWordArray* GetFontSimDataPtr(int nid) ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EXTTEXTMETRIC	m_EXTTEXTMETRIC;											//	EXTTEXTMETRIC structure
BOOL			m_fEXTTEXTMETRIC;													// rm new
BOOL			m_fSave_EXT;

WORD    m_wMaxScale, m_wMinScale, m_wScaleDevice;
//BYTE    m_bfScaleOrientation;


//	BYTE  ScaleOrientation() const
//		  { return m_bfScaleOrientation & 3; }
	WORD  ScaleUnits(BOOL bDevice = TRUE) const
		  { return bDevice ? m_wScaleDevice : m_wHeight - m_InternalLeading; }		// m _cwaSpecial[InternalLeading];

	WORD  ScaleLimit(BOOL bMaximum = TRUE) const
		  { return  bMaximum ? m_wMaxScale : m_wMinScale; }


	enum {ScaleOK, Reversed, NotWindowed};

	WORD    SetScaleLimit(BOOL bMax, WORD wNew);
	WORD    SetDeviceEmHeight(WORD wNew);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			//  FRAMEWORK OPERATIONS

CString         m_csSource;													//  The original PFM file name
CByteArray      m_cbaPFM;													//  Loaded image of the PFM file


	BOOL    MapPFM();														//  Assure the PFM file is loaded

DECLARE_SERIAL(CFontInfo)

public:
	void SetRCIDChanged(bool bFlags) { m_bRCIDChanged = bFlags ; } ;
	bool IsRCIDChanged() {return m_bRCIDChanged ; } ; 
	
	CLinkedList* CompareGlyphsEx(WORD wOld, WORD wNew, CLinkedList* pcll);

	
    CFontInfo();
    CFontInfo(const CFontInfo& cfiRef, WORD widCTT);						//  For cloning of UFMs
    ~CFontInfo();


    BOOL    Load(bool bloadedbyworkspace = false);							//  Load the UFM file so it can be edited
    BOOL    Store(LPCTSTR lpstrFileName, BOOL bStoreFromWorkspace = FALSE);	// raid 244123								//  Save as the specified UFM file
    BOOL    StoreGTTCPOnly(LPCTSTR lpstrFileName);							//  Save the UFM's GTT and CP fields

    virtual CMDIChildWnd*   CreateEditor();
    virtual void    Serialize(CArchive& car);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			//  ATTRIBUTES - CONVERSION SUPPORT

    const CString&  SourceName() const			{ return m_csSource; }

    void    SetSourceName(LPCTSTR lpstrNew);
    BOOL    SetFileName(LPCTSTR lpstrNew) ;
    int     GetTranslation(CSafeObArray& csoagtts);
    //int     GetTranslation();
    int     Generate(CString csPath);
//    void    SetTranslation(WORD w) { m_widTranslation = w; }					// rm ori - moved to new section
    void    SetTranslation(CGlyphMap* pcgm) { m_pcgmTranslation = pcgm; }

	// The following functions return the character range for the mapping table
	// in the UFM's corresponding GTT.  These are needed when a GTT needs to be
	// built for the UFM.

	WORD	GetFirst() { return ((WORD) m_IFIMETRICS.chFirstChar) ; }
	WORD	GetLast() { return ((WORD) m_IFIMETRICS.chLastChar) ; }
	WORD	GetFirstPFM() ;
	WORD	GetLastPFM() ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			// CHARACTER WIDTHS PAGE

CGlyphMap*      m_pcgmTranslation;

CPtrArray       m_cpaGlyphs;
CPtrArray       m_cpaOldGlyphs;
CWordArray		m_cwaOldGlyphs ;
CWordArray		m_cwaNewGlyphs ;

CWordArray      m_cwaWidth;

	CTime	m_ctReloadWidthsTimeStamp ;	// The last time width info was reloaded

	CGlyphHandle&   Glyph(unsigned uid)
					{return *(CGlyphHandle *) m_cpaGlyphs[uid];}

    //BOOL IsVariableWidth() const
	//	{ return (m_loWidthTable || (m_IFIMETRICS.jWinPitchAndFamily & 2)) ; }
    BOOL            IsVariableWidth() const
						{ return !!m_cpaGlyphs.GetSize(); }					//  When variable widths change...
	
	void    CalculateWidths();								
	bool	CheckReloadWidths() ;	

enum    {Less, More, Equal};
    unsigned    CompareWidths(unsigned u1, unsigned u2);

    void    FillWidths(CListCtrl& clcView);									// Fill the control
    void    SetWidth(unsigned uGlyph, WORD wWidth, bool bcalc = true);
	bool	WidthsTableIsOK() ;

	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			// KERNING PAGE
	// Kerning structure- CSafeObArray which contains the kerning pairs.  Also,
	// a copy of m_csoaKern used during editing to make sure m_csoaKern isn't
	// permanently changed without user ok.

	CSafeObArray    m_csoaKern ;
	CSafeObArray    m_csoaKernCopy ;

    BOOL        CanKern() const	    { return !!m_csoaKern.GetSize(); }

    void        MapKerning(CSafeMapWordToOb& csmw2o1,
			               CSafeMapWordToOb& csmw2o2,
						   CWordArray& cwaPoints);

    unsigned    KernCount() const	{ return (unsigned) m_csoaKern.GetSize(); }

    unsigned    CompareKernAmount(unsigned u1, unsigned u2) const;
    unsigned    CompareKernFirst (unsigned u1, unsigned u2) const;
    unsigned    CompareKernSecond(unsigned u1, unsigned u2) const;
	WCHAR		GetKernFirst(unsigned u) const ;
	WCHAR		GetKernSecond(unsigned u) const ;
	short		GetKernAmount(unsigned u) const ;


    void    FillKern(CListCtrl& clcView);					//  Fill the control
    void    AddKern(WORD wFirst, WORD wSecond, short sAmount, CListCtrl& clcView);
    void    RemoveKern(unsigned u) { m_csoaKern.RemoveAt(u); Changed(); }
    void    SetKernAmount(unsigned u, short sAmount);
	void	MakeKernCopy() ;
	bool	LoadBadKerningInfo(CListCtrl& clcbaddata) ;
	bool	CodePointInGTT(WORD wcodepoint) ;
	void	SetNoGTTCP(bool bval) { m_bWSLoadButNoGTTCP = bval ; }

private:
	bool m_bRCIDChanged;
	bool FindAndLoadGTT();
};



/******************************************************************************

  CFontInfoContainer class

  This CDocument-derived class contains one CFontInfo structure- it allows to
  edit the font information either from the driver, os from an individual file.

******************************************************************************/

class CFontInfoContainer : public CDocument
{
    CFontInfo   *m_pcfi;
	bool		m_UFMSaved ;	// True iff an attempt to save the associated
								// UFM was just made.
protected:
	CFontInfoContainer();      // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFontInfoContainer)

// Attributes
public:
    BOOL        m_bEmbedded;	// UFM loaded from workspace
    CFontInfo   *Font() { return m_pcfi; }
// Operations
public:

    //  First a constructor for launching a view from the driver view.
    CFontInfoContainer(CFontInfo *pcfi, CString csPath);
	BOOL PublicSaveModified();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontInfoContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFontInfoContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontInfoContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpc2gpd.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpc2gpd.c

Abstract:

    GPC-to-GPD conversion program

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include    "StdAfx.H"

#include    "ProjNode.H"
#include    "Resource.H"
#include    "GPDFile.H"
#include    "..\GPC2GPD\GPC2GPD.H"

extern "C" void VOutputGlobalEntries(PCONVINFO pci, PCSTR pstrModelName, 
                                     PCSTR pstrResourceDLLName, 
									 PCSTR pstrGPDFileName);

/******************************************************************************

  VPrintErros
  VOut

  These replace functions used in the command line converter.

******************************************************************************/

static void VPrintErrors(CStringArray& csaLog, DWORD dwError) {
    for (unsigned u = 0; u < NUM_ERRS; u++)
        if (dwError & gdwErrFlag[u])
            csaLog.Add(gpstrErrMsg[u]);
    for (u = 0; u < (unsigned) csaLog.GetSize(); u++)
        csaLog[u].TrimRight();  //  Trim off the white space, we won't need it
}

extern "C" void _cdecl
VOut(
    PCONVINFO pci,
    PSTR pstrFormat,
    ...)
/*++
Routine Description:
    This function formats a sequence of bytes and writes to the GPD file.

Arguments:
    pci - conversionr related info
    pstrFormat - the formatting string
    ... - optional arguments needed by formatting

Return Value:
    None
--*/
{
    va_list ap;
    BYTE aubBuf[MAX_GPD_ENTRY_BUFFER_SIZE];
    int iSize;

    va_start(ap, pstrFormat);
    iSize = vsprintf((PSTR)aubBuf, pstrFormat, ap);
    va_end(ap);
    if (pci->dwMode & FM_VOUT_LIST)
    {
        //
        // check for the extra comma before the closing bracket
        //
        if (aubBuf[iSize-4] == ',' && aubBuf[iSize-3] == ')')
        {
            aubBuf[iSize-4] = aubBuf[iSize-3];  // ')'
            aubBuf[iSize-3] = aubBuf[iSize-2];  // '\r'
            aubBuf[iSize-2] = aubBuf[iSize-1];  // '\n'
            iSize--;
        }
    }
    //  Memory exceptions should be all that's possible, but call any MFC
    //  exception a "file write error" for compatibility.
    try {
        CString csLine(aubBuf);
        //  If the previous line does not end in whitespace, add this one to it

        if  (pci -> pcsaGPD -> GetSize()) {
            CString&    csPrevious = 
                pci -> pcsaGPD -> ElementAt( -1 + pci -> pcsaGPD -> GetSize());
            if  (csPrevious.Right(1)[0] != _TEXT('\n')) {
                csPrevious += csLine;
                return;
            }
            csPrevious.TrimRight(); //  Remove the CR/LF combo.
        }
        pci -> pcsaGPD -> Add(csLine);
    }
    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        pci -> dwErrorCode |= ERR_WRITE_FILE;
    }
    // continue even if an error has occurred.
}

/******************************************************************************

  CModelData::Load(PCSTR pcstr, CString csResource, unsigned uModel,
                   CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert)

  This member function fills this instance by converting a model from the GPC 
  data pointed at by pcstr.

******************************************************************************/

BOOL    CModelData::Load(PCSTR pstr, CString csResource, unsigned uModel,
                         CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert) {

    CONVINFO    ci;     // structure to keep track conversion information

    //
    // check if we have all the arguments needed
    //
    if (!pstr || csResource.IsEmpty() || !uModel)
        return  FALSE;

    ZeroMemory((PVOID)&ci, sizeof(CONVINFO));

    //
    // Open the GPC file and map it into memory.
    //
    ci.pdh = (PDH) pstr;

    //
    // GPC file sanity check
    //
    if (ci.pdh->sMagic != 0x7F00 ||
        !(ci.pmd = (PMODELDATA)GetTableInfo(ci.pdh, HE_MODELDATA, uModel-1)) ||
        !(ci.ppc = (PPAGECONTROL)GetTableInfo(ci.pdh, HE_PAGECONTROL,
        ci.pmd->rgi[MD_I_PAGECONTROL]))) {
        ci.dwErrorCode |= ERR_BAD_GPCDATA;
        goto exit;
    }

    //
    // allocate dynamic buffers needed for conversion
    //
    if (!(ci.ppiSize=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSIZE].sCount*sizeof(PAPERINFO))) ||
        !(ci.ppiSrc=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSOURCE].sCount*sizeof(PAPERINFO))) ||
        !(ci.presinfo=(PRESINFO)MemAllocZ(ci.pdh->rghe[HE_RESOLUTION].sCount*sizeof(RESINFO))))
    {
        ci.dwErrorCode |= ERR_OUT_OF_MEMORY;
        goto exit;
    }

    //
    // generate GPD data
    //

    ci.pcsaGPD = &m_csaGPD;
    ci.pcmw2dFonts = &cmw2dFontMap;
// eigos /1/16/98
//    ci.dwStrType = wfGPDConvert % (1 + STR_RCID_SYSTEM_PAPERNAMES); //  Paranoid conversion...
    //rm - Use value macros (see stdnames.gpd) - fixes a want request
    ci.dwStrType = STR_MACRO;

	// Emit RCID_DMPAPER_SYSTEM_NAME
	// Done by v-erike on 3/30/98.  Requested by patryan

	ci.bUseSystemPaperNames = TRUE ;

    VOutputGlobalEntries(&ci, m_csName, csResource + _T(".Dll"), FileTitleExt());
    VOutputUIEntries(&ci);
    VOutputPrintingEntries(&ci);

    m_csaGPD[-1 + m_csaGPD.GetSize()].TrimRight();

exit:
    if (ci.ppiSize)
        MemFree(ci.ppiSize);
    if (ci.ppiSrc)
        MemFree(ci.ppiSrc);
    if  (ci.presinfo)
        MemFree(ci.presinfo);
    if (ci.dwErrorCode) {
        //
        // Open the log file and print out errors/warnings.
        // Borrow the GPD file name buffer.
        //
        VPrintErrors(m_csaConvertLog, ci.dwErrorCode);
    }

    return TRUE;
}

/******************************************************************************

  vMapFontList

  This procedure uses the CMapWordToDWord mapping in the CONVINFO structure to
  map font indices in font lists.  This is the final bit of skullduggery needed
  to make the mapping of a single PFM to multiple UFMs effective.

******************************************************************************/

extern "C" void vMapFontList(IN OUT PWORD pwFonts, IN DWORD dwcFonts, 
                             IN PCONVINFO pci) {

	//	If there are n fonts, or just one and the ID is 0 (happens if there are
	//	no device fonts.

    if  (!dwcFonts || (dwcFonts == 1 && !*pwFonts))
        return;

    CWordArray          cwaFonts;
    CMapWordToDWord&    cmw2dFonts = *pci -> pcmw2dFonts;

    WORD    wGreatest = 0;	//	Highest font ID in the new array

    for (unsigned uFont = 0; uFont < dwcFonts; uFont++) {
        WORD    widThis = pwFonts[uFont];

        if  (cmw2dFonts[widThis])    //  It will be 0 if unmapped
            widThis = (WORD) cmw2dFonts[widThis];

        if  (widThis > wGreatest) {	//	Is this the new end of the list?
            cwaFonts.Add(widThis);
            wGreatest = widThis;
            continue;
        }

        for (int i = 0; i < cwaFonts.GetSize(); i++)
            if  (cwaFonts[i] > widThis) {
                cwaFonts.InsertAt(i, widThis);
                break;
            }

        _ASSERT(i < cwaFonts.GetSize());
    }

    //  OK, the font list is corrected and is once again sorted.  Copy it back

    memcpy(pwFonts, cwaFonts.GetData(), dwcFonts * sizeof wGreatest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\glue.cpp ===
/******************************************************************************

  Source File:  Glue.CPP

  This file contains the functions needed to make the GPD parser code work on
  both platforms, as well as stubs to support function I do not need to supply.

  Copyright (c) 1997 by Microsoft Corporation,  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03/28/1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "ProjNode.H"
#include    "Resource.H"
#include    "GPDFile.H"

//  I'll use a class to guarantee memory never leaks from here.

class   CMaps {
    CObArray    m_coaMaps;

public:
    CMaps() { m_coaMaps.Add(NULL); }
    ~CMaps() {
        for (int i = 0; i < m_coaMaps.GetSize(); i++)
            if  (m_coaMaps[i])
                delete  m_coaMaps[i];
    }
    unsigned    Count() { return (unsigned)m_coaMaps.GetSize(); }
    unsigned    HandleFor(CByteArray* cba) {
        for (unsigned u = 1; u < Count(); u++) {
            if  (!m_coaMaps[u]) {
                m_coaMaps[u] = cba;
                return  u;
            }
        }
        m_coaMaps.Add(cba);
        return  Count();
    }

    void    Free(unsigned u) {
        if  (!u || u >= Count() || !m_coaMaps[u])
            return;

        delete  m_coaMaps[u];
        m_coaMaps[u] = NULL;
    }
};

static CMaps    scmAll;

extern "C" unsigned MapFileIntoMemory(LPCWSTR pstrFile, PVOID *ppvData,
                                      PDWORD pdwSize) {

    if  (!pstrFile || !ppvData || !pdwSize)
        return  0;

    CFile   cfMap;
    CByteArray* pcbaMap = new CByteArray;
    CString csFile(pstrFile);

    if  (!pcbaMap)
        return  0;

    if  (!cfMap.Open(csFile, CFile::modeRead | CFile::shareDenyWrite))
        return  0;

    try {
        pcbaMap -> SetSize(*pdwSize = cfMap.GetLength());
        cfMap.Read(pcbaMap -> GetData(), cfMap.GetLength());
        *ppvData = pcbaMap -> GetData();
        return  scmAll.HandleFor(pcbaMap);
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  0;
}

extern "C" void UnmapFileFromMemory(unsigned uFile) {
    scmAll.Free(uFile);
}

//  This one is just a stub to make the whole thing work for us- we don't use
//  the checksum- it's there for the end product to tell if a GPD file has
//  been altered since it was converted lase.

extern "C" DWORD    ComputeCrc32Checksum(PBYTE pbuf,DWORD dwCount,
                                         DWORD dwChecksum) {
    return  dwCount ^ dwChecksum ^ (PtrToUlong(pbuf));
}

// The next two variables are used to control how and when GPD parsing/conversion
// log messages are saved.
//		pcsaLog				Ptr to string array to load with messages
//		bEnableLogging		True iff logging is enabled

static CStringArray*    pcsaLog = NULL ;
static bool			    bEnableLogging = false ;


/******************************************************************************

  CModelData::SetLog

  Prepare to log parse/conversion error and warning messages.

******************************************************************************/

void CModelData::SetLog()
{
    m_csaConvertLog.RemoveAll() ;
    pcsaLog = &m_csaConvertLog ;
	bEnableLogging = true ;
}


/******************************************************************************

  CModelData::EndLog

  Turn off parse/conversion error and warning message logging.

******************************************************************************/

void CModelData::EndLog()
{
    pcsaLog = NULL ;
	bEnableLogging = false ;
}


/******************************************************************************

  DebugPrint

  This routine is called to log the parsing/conversion error and warning
  messages.

******************************************************************************/

extern "C" void DebugPrint(LPCTSTR pstrFormat, ...)
{
    CString csOutput;
    va_list ap;

	// Don't do anything if logging is not enabled.

	if (!bEnableLogging)
		return ;

    va_start(ap, pstrFormat);
    vsprintf(csOutput.GetBuffer(1000), pstrFormat, ap);
    va_end(ap);
    csOutput.ReleaseBuffer();
    csOutput.TrimLeft();
    CStringArray&   csaError = *pcsaLog;

	// If this routine is being called when we're NOT recording problems with a
	// GPD, display the message when debugging.

	if (pcsaLog == NULL) {
		CString csmsg ;
		csmsg.LoadString(IDS_XXXUnexpectedCPError) ;
		csmsg += csOutput ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
//#ifdef _DEBUG
//		afxDump << csOutput ;
//		if (csOutput.Right(1) != _T("\n"))
//			afxDump << _T("\n") ;
//#endif
		return ;
	} ;

    if  (!csaError.GetSize()) {
        csaError.Add(csOutput);
        return;
    }

    if  (csaError[-1 + csaError.GetSize()].Find(_T('\n')) >= 0) {
        csaError[-1 + csaError.GetSize()].TrimRight();
        pcsaLog -> Add(csOutput);
    }
    else
        csaError[-1 + csaError.GetSize()] += csOutput;
}

/******************************************************************************

  MDSCreateFileW

  I implement a version of this API here which calls the ANSI API, so I can
  compile the parser code with UNICODE on, but still run the resulting binary
  on Win95.

******************************************************************************/

extern "C" HANDLE MDSCreateFileW(LPCWSTR lpstrFile, DWORD dwDesiredAccess,
                                 DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
                                 DWORD dwCreateFlags, DWORD dwfAttributes,
                                 HANDLE hTemplateFile) {
    CString csFile(lpstrFile);  //  Let CString conversions do the hard work!

    return  CreateFile(csFile, dwDesiredAccess, dwShareMode, lpsa,
        dwCreateFlags, dwfAttributes, hTemplateFile);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontview.h ===
/******************************************************************************

  Header File:  Font Viewer.H

  This defines the classes used in viewing and editing font information for the
  studio.  The view consists of a property sheet with three pages to allow
  viewing and editing of the large quantity of data that describes the font.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-05-1997    Bob_Kjelgaard@Prodigy.Net   Created it.
  12-30-1997    Richard Mallonee			rewrote it totally

******************************************************************************/

#if !defined(AFX_FONTVIEW_H__D9456262_745B_11D2_AEDD_00C04FA30E4A__INCLUDED_)
#define AFX_FONTVIEW_H__D9456262_745B_11D2_AEDD_00C04FA30E4A__INCLUDED_


// Constants useful to the UFM Editor code.

const CString csField(_T("Field")) ;
const CString csValue(_T("Value")) ;


/******************************************************************************

  CFontWidthsPage class

  This class implements the character widths page for the font editor

******************************************************************************/

class CFontWidthsPage : public CToolTipPage
{
    CFontInfo   *m_pcfi;
    BYTE        m_bSortDescending;
    int         m_iSortColumn;

    static int CALLBACK Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis);

    int Sort(UINT_PTR id1, UINT_PTR id2);

// Construction
public:
	CFontWidthsPage();
	~CFontWidthsPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }
	void	InitMemberVars() ;
	bool	ValidateUFMFields() ;
	bool	SavePageData() ;

	bool	m_bInitDone ;

// Dialog Data
	//{{AFX_DATA(CFontWidthsPage)
	enum { IDD = IDD_CharWidths };
	CListCtrl	m_clcView;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontWidthsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontWidthsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEndlabeleditCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontKerningPage class

  This class handles the Font Kerning structures, if there are any to be had.

******************************************************************************/

class CFontKerningPage : public CToolTipPage
{
    CFontInfo   *m_pcfi;
    int         m_idSelected;   //  Tracks selected item 
    unsigned    m_ufDescending; //  Sort order flags by column- 0 = Ascending;
    unsigned    m_uPrecedence[3];   //  Sort precedence, by column

    static int CALLBACK Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis);

    int Sort(unsigned u1, unsigned u2);

    enum    {Amount, First, Second};    //  Internal enum to control sorting

// Construction
public:
	CFontKerningPage();
	~CFontKerningPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }
	void	InitMemberVars() ;
	bool	ValidateUFMFields() ;
	bool	SavePageData() ;

	bool	m_bInitDone ;

// Dialog Data
	//{{AFX_DATA(CFontKerningPage)
	enum { IDD = IDD_KerningPairs };
	CListCtrl	m_clcView;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontKerningPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontKerningPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKeydownKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndlabeleditKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
    afx_msg void OnAddItem();
    afx_msg void OnDeleteItem();
    afx_msg void OnChangeAmount();
	DECLARE_MESSAGE_MAP()

};


class CFontViewer ;


/////////////////////////////////////////////////////////////////////////////
// CFontHeaderPage dialog

class CFontHeaderPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CFontHeaderPage)

// Attributes
public:
    CFontInfo*		m_pcfi ;		// UFM to display and edit
	CFontInfoContainer*	m_pcfic ;	// Parent document class
	bool			m_bInitDone ;	// True iff the page has been initialized
	CFontViewer*	m_pcfv ;		// Ptr to grandparent view class

// Construction
public:
	CFontHeaderPage();
	~CFontHeaderPage();

// Dialog Data
	//{{AFX_DATA(CFontHeaderPage)
	enum { IDD = IDD_UFM1_Header };
	CFullEditListCtrl	m_cfelcUniDrv;
	CString	m_csDefaultCodePage;
	CString	m_csRCID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontHeaderPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontHeaderPage)
	afx_msg void OnChangeDefaultCodepageBox();
	afx_msg void OnChangeGlyphSetDataRCIDBox();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusDefaultCodepageBox();
	afx_msg void OnKillfocusGlyphSetDataRCIDBox();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()

	void CheckHandleCPGTTChange(CString& csfieldstr, UINT ustrid) ;

public:

    void Init(CFontInfo *pcfi, CFontInfoContainer* pcfic, CFontViewer* pcfv) {
		m_pcfi = pcfi ;
		m_pcfic = pcfic ;
		m_pcfv = pcfv ;
	}
	bool ValidateUFMFields() ;
	bool SavePageData() ;
};


/////////////////////////////////////////////////////////////////////////////
// CFontIFIMetricsPage dialog

class CFontIFIMetricsPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CFontIFIMetricsPage)

// Attributes
public:
    CFontInfo		*m_pcfi ;			// UFM to display and edit
	bool			m_bInitDone ;		// True iff the page is initialized
	CStringArray	m_csaFamilyNames ;	// New UFM family names
    CWordArray		m_cwaBold ;			// New font simulation data
    CWordArray		m_cwaItalic ;		// New font simulation data
    CWordArray		m_cwaBoth ;			// New font simulation data
	CUIntArray		m_cuiaFontSimStates;// Is each font sim enabled?
	CUIntArray		m_cuiaSimTouched ;  // Has a font sim changed in any way?

// Construction
public:
	CFontIFIMetricsPage();
	~CFontIFIMetricsPage();

// Dialog Data
	//{{AFX_DATA(CFontIFIMetricsPage)
	enum { IDD = IDD_UFM2_IFIMetrics };
	CFullEditListCtrl	m_cfelcIFIMetrics;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontIFIMetricsPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontIFIMetricsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()

	void IFILoadNamesData(CStringArray& csacoldata) ;
	void IFILoadValuesData(CStringArray& csacoldata) ;
	
public:
    void Init(CFontInfo *pcfi) { m_pcfi = pcfi ; }
	CWordArray* GetFontSimDataPtr(int nid) ;
	bool ValidateUFMFields() ;
	bool SavePageData() ;
	void SaveFontSimulations() ;
};


/////////////////////////////////////////////////////////////////////////////
// CFontExtMetricPage dialog

class CFontExtMetricPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CFontExtMetricPage)

// Attributes
public:
    CFontInfo   *m_pcfi ;
	bool		m_bInitDone ;	// True iff the page has been initialized

// Construction
public:
	CFontExtMetricPage();
	~CFontExtMetricPage();

// Dialog Data
	//{{AFX_DATA(CFontExtMetricPage)
	enum { IDD = IDD_UFM3_ExtMetrics };
	CFullEditListCtrl	m_cfelcExtMetrics;
	BOOL	m_bSaveOnClose;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontExtMetricPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontExtMetricPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSaveCloseChk();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()

	void EXTLoadNamesData(CStringArray& csacoldata) ;

public:
    void Init(CFontInfo *pcfi) { m_pcfi = pcfi ; }
	bool ValidateUFMFields() ;
	bool SavePageData() ;
};


/////////////////////////////////////////////////////////////////////////////
// CWidthKernCheckResults dialog

class CWidthKernCheckResults : public CDialog
{
// Construction
public:
	CWidthKernCheckResults(CWnd* pParent = NULL);   // standard constructor
	CWidthKernCheckResults(CFontInfo* pcfi, CWnd* pParent = NULL);   

// Dialog Data
	//{{AFX_DATA(CWidthKernCheckResults)
	enum { IDD = IDD_WidthKernCheckResults };
	CListCtrl	m_clcBadKernPairs;
	CString	m_csKernChkResults;
	CString	m_csWidthChkResults;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWidthKernCheckResults)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Atrributes
public:
	CFontInfo*	m_pcfi ;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWidthKernCheckResults)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  CFontViewer class
//
//  This is the CView-derived class which implements the font viewer.  It 
//  actually uses CPropertySheet and the preceding property page classes to do
//  most of its work.
//    
//    CFontHeaderPage	  m_cfhp 
//    CFontIFIMetricsPage m_cfimp 
//	  CFontExtMetricPage  m_cfemp 
//    CFontWidthsPage     m_cfwp 
//    CFontKerningPage    m_cfkp 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CFontViewer : public CView
{
    CPropertySheet      m_cps ;

	// Pages that make up the property sheet

    CFontHeaderPage		m_cfhp ; 
	CFontIFIMetricsPage m_cfimp ;
	CFontExtMetricPage  m_cfemp ;
    CFontWidthsPage     m_cfwp ;
    CFontKerningPage    m_cfkp ;


protected:
	CFontViewer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFontViewer)

// Attributes
public:
    CFontInfoContainer  *GetDocument() { return (CFontInfoContainer *) m_pDocument;   }

// Operations
public:
	bool ValidateSelectedUFMDataFields() ;
	bool SaveEditorDataInUFM() ;
	void HandleCPGTTChange(bool bgttidchanged) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontViewer)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFontViewer();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontViewer)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


// This string is used by a lot of the UFM Editor's subordinate dialog boxes.

const LPTSTR lptstrSet = _T("Set") ;


/////////////////////////////////////////////////////////////////////////////
// CGenFlags dialog

class CGenFlags : public CDialog
{
// Construction
public:
	CGenFlags(CWnd* pParent = NULL);   // standard constructor
	CGenFlags(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of GenFlags

// Dialog Data
	//{{AFX_DATA(CGenFlags)
	enum { IDD = IDD_UFM1S_GenFlags };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGenFlags)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenFlags)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CHdrTypes dialog

class CHdrTypes : public CDialog
{
// Construction
public:
	CHdrTypes(CWnd* pParent = NULL);   // standard constructor
	CHdrTypes(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CHdrTypes)
	enum { IDD = IDD_UFM1S_Types };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHdrTypes)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHdrTypes)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CHdrCaps dialog

class CHdrCaps : public CDialog
{
// Construction
public:
	CHdrCaps(CWnd* pParent = NULL);   // standard constructor
	CHdrCaps(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of fCaps

// Dialog Data
	//{{AFX_DATA(CHdrCaps)
	enum { IDD = IDD_UFM1S_Caps };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHdrCaps)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHdrCaps)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIFamilyNames dialog

class CFIFIFamilyNames : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the page has been initialized
	bool		m_bChanged ;	// True iff the names list changed
	CFontIFIMetricsPage*	m_pcfimp ;	// Ptr to IFIMetrics page
	CString*	m_pcsFirstName ;// First family name displayed in IFI page
	
// Construction
public:
	CFIFIFamilyNames(CWnd* pParent = NULL);   // standard constructor
	CFIFIFamilyNames(CString* pcsfirstname, CFontIFIMetricsPage* pcfimp, 
					 CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIFamilyNames)
	enum { IDD = IDD_UFM2S_Family };
	CFullEditListCtrl	m_cfelcFamilyNames;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIFamilyNames)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIFamilyNames)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims dialog

class CFIFIFontSims : public CDialog
{
// Attributes
public:
	CFontIFIMetricsPage*	m_pcfimp ;	// Ptr to IFIMetrics page
	CString*	m_pcsFontSimData ;		// 1st family name displayed in IFI page
	bool		m_bChanged ;			// True iff amy font sim info changed
	bool		m_bInitDone ;			// True iff the page has been init'ed
	CUIntArray	m_cuiaFontSimGrpLoaded ;// When font sim groups have been loaded

// Construction
public:
	CFIFIFontSims(CWnd* pParent = NULL);   // standard constructor
	CFIFIFontSims(CString* pcsfontsimdata, CFontIFIMetricsPage* pcfimp, 
	 			  CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIFontSims)
	enum { IDD = IDD_UFM2S_FontSims };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIFontSims)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIFontSims)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    afx_msg void OnSetAnySimState(unsigned ucontrolid) ;
    afx_msg void OnChangeAnyNumber(unsigned ucontrolid) ;
	DECLARE_MESSAGE_MAP()

	void InitSetCheckBox(int ncontrolid) ;
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinCharSet dialog

class CFIFIWinCharSet : public CDialog
{
// Construction
public:
	CFIFIWinCharSet(CWnd* pParent = NULL);   // standard constructor
	CFIFIWinCharSet(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFIWinCharSet)
	enum { IDD = IDD_UFM2S_WinCharSet };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIWinCharSet)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIWinCharSet)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinPitchFamily dialog

class CFIFIWinPitchFamily : public CDialog
{
// Construction
public:
	CFIFIWinPitchFamily(CWnd* pParent = NULL);   // standard constructor
	CFIFIWinPitchFamily(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFIWinPitchFamily)
	enum { IDD = IDD_UFM2S_WinPitchFamily };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIWinPitchFamily)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIWinPitchFamily)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIInfo dialog

class CFIFIInfo : public CDialog
{
// Construction
public:
	CFIFIInfo(CWnd* pParent = NULL);   // standard constructor
	CFIFIInfo(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFIInfo)
	enum { IDD = IDD_UFM2S_Info };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIInfo)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void InfoLoadNamesData(CStringArray& csafieldnames) ;
} ;


/////////////////////////////////////////////////////////////////////////////
// CFIFISelection dialog

class CFIFISelection : public CDialog
{
// Construction
public:
	CFIFISelection(CWnd* pParent = NULL);   // standard constructor
	CFIFISelection(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFISelection)
	enum { IDD = IDD_UFM2S_Selection };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFISelection)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFISelection)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIPoint dialog

class CFIFIPoint : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the dlg has been initialized
	bool		m_bChanged ;	// True iff the point list changed
	CString*	m_pcsPoint ;	// Point info to/from IFI page

// Construction
public:
	CFIFIPoint(CWnd* pParent = NULL);   // standard constructor
	CFIFIPoint(CString* pcspoint, CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIPoint)
	enum { IDD = IDD_UFM2S_Point };
	CFullEditListCtrl	m_cfelcPointLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIPoint)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIPoint)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIRectangle dialog

class CFIFIRectangle : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the dlg has been initialized
	bool		m_bChanged ;	// True iff the point list changed
	CString*	m_pcsRect ;		// Rectangle info to/from IFI page

// Construction
public:
	CFIFIRectangle(CWnd* pParent = NULL);   // standard constructor
	CFIFIRectangle(CString* pcsrect, CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIRectangle)
	enum { IDD = IDD_UFM2S_Rect };
	CFullEditListCtrl	m_cfelcSidesLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIRectangle)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIRectangle)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIPanose dialog

class CFIFIPanose : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the dlg has been initialized
	bool		m_bChanged ;	// True iff the point list changed
	CString*	m_pcsPanose ;	// Panose info to/from IFI page

// Construction
public:
	CFIFIPanose(CWnd* pParent = NULL);   // standard constructor
	CFIFIPanose(CString* pcspanose, CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIPanose)
	enum { IDD = IDD_UFM2S_Panose };
	CFullEditListCtrl	m_cfelcPanoseLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIPanose)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIPanose)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FONTVIEW_H__D9456262_745B_11D2_AEDD_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdfile.h ===
/******************************************************************************

  Header File:  Model Data.H

  This defines a C++ class that manipulates (or at lest initially, understands)
  the GPC data file used in earlier versions of the Mini-Driver technology.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-19-97  Bob_Kjelgaard@Prodgy.Net    Created it

******************************************************************************/

#if !defined(GPD_FILE_INFORMATION)
#define GPD_FILE_INFORMATION


class CStringTable ;


class COldMiniDriverData {      //  comdd
    CWordArray  m_cwaidModel;   //  Model names of the printers
    CWordArray  m_cwaidCTT;     //  Default CTTs for each model
    CByteArray  m_cbaImage;     //  Image of the GPC file
    CSafeObArray m_csoaFonts;   //  Font list per model as CWordArrays
	CUIntArray	m_cuaSplitCodes;//	Contains multiple GPC codes.  See
								//  SplitMultiGPCs() and SplitCodes.
	CStringArray m_csaSplitNames; // Correct model names for split GPC entries

public:
    COldMiniDriverData() {}
	~COldMiniDriverData() ;
    BOOL    Load(CFile& cfImage);

//  Attributes

    unsigned    ModelCount() { return (unsigned) m_cwaidModel.GetSize(); }
    WORD        ModelName(unsigned u) const { return m_cwaidModel[u]; }
    WORD        DefaultCTT(unsigned u) const { return m_cwaidCTT[u]; }
    CMapWordToDWord&    FontMap(unsigned u) const;
    PCSTR       Image() const { return (PCSTR) m_cbaImage.GetData(); }

	// The following codes are used to indicate if a GPC manages multiple
	// printer models so its "name" must split into individual model names
	// and its data copied into multiple GPCs.

	enum SplitCodes {
		NoSplit,		// GPC represents one model so no splitting occurs
		FirstSplit,		// First model of a multiple model GPC
		OtherSplit		// One of the other models of a multiple model GPC
	} ;

	// Get, set or insert a model's split code

	SplitCodes GetSplitCode(unsigned u) {
		return ((SplitCodes) m_cuaSplitCodes[u]) ;
	}
	void SetSplitCode(unsigned u, SplitCodes sc) {
		m_cuaSplitCodes[u] = (unsigned) sc ;
	}
	void InsertSplitCode(unsigned u, SplitCodes sc) {
		m_cuaSplitCodes.InsertAt(u, (unsigned) sc) ;
	}

	// Get a split entry's correct model name

	CString& SplitModelName(unsigned u) { return m_csaSplitNames[u] ; }

    //  Operations
    void    NoteTranslation(unsigned uModel, unsigned uFont,
        unsigned uNewFont);
	bool SplitMultiGPCs(CStringTable& cstdriversstrings) ;
};

/******************************************************************************

  CModelData class

  This class handles the model data in GPD format.

******************************************************************************/

class CModelData : public CProjectNode {
    CStringArray        m_csaGPD, m_csaConvertLog;  //  GPD and error log

    //  Private syntax checking support
    void                SetLog();
    void                EndLog();

    //  Private view support
    CByteArray  m_cbaBuffer;    // Stream I/O buffer
    CString     m_csBuffer;     // Stream I/O buffer (partial lines)
    int         m_iLine;		// Currently GPD line number to load/store
    static DWORD CALLBACK   FillViewer(DWORD_PTR dwCookie, LPBYTE lpBuff, LONG lcb,
                                       LONG *plcb);
    static DWORD CALLBACK   FromViewer(DWORD_PTR dwCookie, LPBYTE lpBuff, LONG lcb,
                                       LONG *plcb);
    DWORD Fill(LPBYTE lpBuff, LONG lcb, LONG *plcb);
    DWORD UpdateFrom(LPBYTE lpBuff, LONG lcb, LONG *plcb);

	// Workspace completeness and tidiness checking related variables

	bool				m_bTCUpdateNeeded ;	// True iff IDs need to be updated
	int*				m_pnUFMRCIDs ;		// Ptr to UFM RC IDs in the GPD
	int					m_nNumUFMsInGPD ;	// Number if UFMs in the GPD
	int*				m_pnStringRCIDs ;	// Ptr to string RC IDs in the GPD
	int					m_nNumStringsInGPD ;// Number if strings in the GPD
	PVOID				m_pvRawData ;		// Ptr to GPD Parser data

    DECLARE_SERIAL(CModelData)
public:
	void SetKeywordValue(CString csfile, CString csKeyword, CString csValue,bool bSource = false);
	CString GetKeywordValue(CString csfile, CString csKeyword);
	CModelData();
    ~CModelData();

    //  Attributes

    BOOL            HasErrors() const { return !!m_csaConvertLog.GetSize(); }
    unsigned        Errors() const {
        return (unsigned) m_csaConvertLog.GetSize();
    }
    const CString   Error(unsigned u) const { return m_csaConvertLog[u]; }
    const int       LineCount() const { return (int)m_csaGPD.GetSize(); }

    //  Operations - Document support

    BOOL    Load(PCSTR pcstr, CString csResource, unsigned uidModel,
                 CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert);
    BOOL    Load(CStdioFile& csiofGPD);
    BOOL    Load();
    BOOL    Store(LPCTSTR lpstrPath = NULL);
    BOOL    BkupStore();
    BOOL    Restore();
    void    UpdateEditor() {
        if  (m_pcmcwEdit)
            m_pcmcwEdit -> GetActiveDocument() -> UpdateAllViews(NULL);
    }

    //  Operations- syntax and error checking support

    BOOL    Parse(int nerrorlevel = 0);
    void    RemoveError(unsigned u);

    //  View support- it's easier done from here

    void    Fill(CRichEditCtrl& crec);
    void    UpdateFrom(CRichEditCtrl& crec);

    //  Framework support operations

    virtual CMDIChildWnd*   CreateEditor();
    virtual void            Import();
    virtual void            Serialize(CArchive& car);

	// Workspace completeness checking support routines

	bool		UpdateResIDs(bool bufmids) ;
	int			GetUFMRCID(unsigned urcidx) { return *(m_pnUFMRCIDs + urcidx) ; }
	int			GetStringRCID(unsigned urcidx) { return *(m_pnStringRCIDs + urcidx) ; }
	unsigned	NumUFMsInGPD() { return m_nNumUFMsInGPD ; }
	unsigned	NumStringsInGPD() { return m_nNumStringsInGPD ; }

	
};

/******************************************************************************

  CGPDContainer class

  This class, derived from CDocument, contains the contents of a single GPD
  file in a conatiner suitable for the MFC document/view architecture.

******************************************************************************/

class CGPDContainer : public CDocument {

    // TRUE iff the GPD Editor was started from the Workspace View.  FALSE if
	// the GPD Editor was started from the File Open command.

	BOOL        m_bEmbedded;

    CModelData  *m_pcmd;

protected:
	CGPDContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGPDContainer)

// Attributes
public:

    CModelData* ModelData() { return m_pcmd; }
	BOOL		GetEmbedded() { return m_bEmbedded ; }

// Operations
public:

    //  First a constructor for the Driver viewer to use to launch a GPD
    //  editor...

    CGPDContainer(CModelData *pcmd, CString csPath);

    void    OnFileSave() { CDocument::OnFileSave(); }
    void    OnFileSaveAs() { CDocument::OnFileSaveAs(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGPDContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGPDContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdfile.cpp ===
/******************************************************************************

  Source File:  Model Data.CPP

  Implementation of the code for handling GPC format data

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-19-97  Bob_Kjelgaard@Prodgy.Net    Created it

******************************************************************************/

#include    "StdAfx.h"
#include    "ProjNode.H"
#include	"CodePage.H"
#include    "Resource.H"
#include    "GPDFile.H"
#include    "utility.H"
#include	"minidev.h"		


/******************************************************************************

  COldMiniDriverData class

  This class is tasked with representing the GPC data.  It will begin life as
  a stub, although it could become more functional, later.

******************************************************************************/

/******************************************************************************

  ExtractList

  This is a private worker function.  It takes a pointer to a null-terminated
  list of WORD font IDs, with the nasty complication that the first two
  elements of the list represent the endpoints of a range.  It mashes these
  into a passed word map (of which we only use the indices).

******************************************************************************/

static void ExtractList(PWORD pw, CMapWordToDWord& cmw2d) {
    for (WORD w = *pw++; w && w < *pw; w++)
        cmw2d[w] = 0;

    if  (!w)
        return; //  The whole list was empty

    while   (*pw)   //  We start at the endpoint (which we haven't mapped yet)
        cmw2d[*pw++] = 0;
}


COldMiniDriverData::~COldMiniDriverData()
{
	// The m_csoaFonts array has some duplicate entries in it because of GPC
	// entries that reference multiple printer models.  We must zap those
	// duplicate entries so the data won't be deleted twice in the CSafeObArray
	// destructor.  That would cause an AV.

	for (unsigned u = 0 ; u < m_csoaFonts.GetSize() ; u++) {
		if (GetSplitCode(u) != NoSplit)
			m_csoaFonts.SetAt(u, NULL) ;
	} ;
}


/******************************************************************************

  ColdMiniDriverData::Load

  This member function loads the mini-driver's GPC file, and extracts the
  number of models, the CTT IDs, and the model name IDs.

******************************************************************************/

BOOL    COldMiniDriverData::Load(CFile& cfImage) {

    struct sGPCHeaderEntry {
        WORD    m_wOffset, m_wcbItem, m_wcItems;
    };

    struct sMaster {
        WORD    m_wX, m_wY;
    };

    struct sPrinterModelData {
        WORD    m_wcbSize;
        WORD    m_widName;  //  Stringtable id for model name.
        WORD    m_wfGeneral;    //  TODO:   Define enums
        WORD    m_wfCurves;     //  TODO:   Define enums
        WORD    m_wfLines;      //  TODO:   Define enums
        WORD    m_wfPolygons;   //  TODO:   Define enums
        WORD    m_wfText;       //  TODO:   Define enums
        WORD    m_wfClipping;   //  TODO:   Define enums
        WORD    m_wfRaster;;    //  TODO:   Define enums
        WORD    m_wfLandscapeText;  //  TODO:   Define enums
        WORD    m_wLeftMargin;  //  Left-hand unprintable area
        WORD    m_wMaximumWidth;    //  Of physica page
        sMaster m_smMaximum, m_smMinimum;   //  Max min page sizes
        WORD    m_widDefaultFont;
        WORD    m_wLookAhead;
        WORD    m_wMaxFontsPerPage;
        WORD    m_wcCartridges;
        WORD    m_widDefaultCTT;
        enum {PortraitFonts, LandscapeFonts, Resolution, PaperSize,
            PaperQuality, PaperSource, PaperDestination, TextQuality,
            Compression, FontCartridge, Color, MemoryConfiguration};
        WORD    m_awofIndexLists[12];   //  Uses the preceding enum
        WORD    m_awIndices[16];        //  Ditto
        WORD    m_awVer3IndexLists[5];  //  Ditto
        WORD    m_wofDefaults;          //  List of defaults for index lists
        WORD    m_wReserved;
        DWORD   m_dwidICMManufactirer, m_dwidICMModel;
        DWORD   m_adwReserved[8];
    };

    struct sGPCFileHeader {
        WORD    m_widGPC;   //  0x7F00 or it isn't valid.
        WORD    m_wVersion; //  Final version is 3, there was a V2
        sMaster m_smMasterdpi;
        DWORD   m_dwoHeap;  //  The GPC data is maintained in one
        DWORD   m_dwcbFile; //  Total GPC Image size, heap and all
        enum {Default, PCL4, CAPSL, PPDS, TTY, DBCS};
        WORD    m_wTechnology;  //  Use the preceding enum
        enum {PrivateHelp = 1, OneDraftFont};
        WORD    m_wfGeneral;    //  Again, use the preceding enum
        char    m_acReserved[10];
        WORD    m_wcHeaderItems;    //  Number of valid header entries
        enum {ModelData, Resolution, PaperSize, PaperQuality, PaperSource,
                PaperDestination, TextQuality, Compression, FontCartridge,
                PageControl, CursorMovement, FontSimulation, DeviceColor,
                RectangleFill, DownloadInfo, VectorPage, Carousel, PenInfo,
                LineInfo, BrushInfo, VectorOutput, PolyVectorOutput,
                VectorSupport, ImageControl, PrintDensity, ColorTracking,
                MaximumDefined = 30};
        sGPCHeaderEntry m_asgpche[MaximumDefined];
    };

    struct sFontCartridge {
        WORD    m_wSize;    //  = 12
        WORD    m_widCartridge; //  In the string table
        WORD    m_wofPortraitList;
        WORD    m_wofLandscapeList;
        WORD    m_wfGeneral;
        WORD    m_wReserved;
    };

    //  In case we get called more than once, dump any old info...

    m_cbaImage.RemoveAll();
    m_csoaFonts.RemoveAll();
    m_cwaidCTT.RemoveAll();
    m_cwaidModel.RemoveAll();

    m_cbaImage.SetSize(cfImage.GetLength());

    cfImage.Read(m_cbaImage.GetData(), cfImage.GetLength());

    sGPCFileHeader  *psgfh = (sGPCFileHeader *) Image();

    if  (psgfh -> m_widGPC != 0x7F00 || psgfh -> m_wVersion > 0x3ff)
        return  FALSE;

    //  Suck out the printer model data we care about- eventually, this may
    //  be all of it

    for (unsigned u = 0;
         u < psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wcItems;
         u++) {
        sPrinterModelData&  spmd = *(sPrinterModelData *) (Image() +
        psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wOffset +
            psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wcbItem * u);
        m_cwaidModel.Add(spmd.m_widName);
        m_cwaidCTT.Add(spmd.m_widDefaultCTT);
        //  Build the font list- I use a CMapWordToOb to handle the duplicate
        //  screening

        CMapWordToDWord&   cmw2dThis = * (new CMapWordToDWord);
        //  Extract the portrait resident fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::PortraitFonts])
            ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::PortraitFonts]),
                cmw2dThis);
        //  Extract the landscape resident fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::LandscapeFonts])
            ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::LandscapeFonts]),
                cmw2dThis);
        //  Extract the cartridge fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::FontCartridge]) {
            PWORD   pw = (PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::FontCartridge]);

            //  RAID    102890- Cartridge font index is 1-based, not 0-based

            while   (*pw) {
                sFontCartridge* psfc = (sFontCartridge *) (Image() + psgfh ->
                    m_asgpche[sGPCFileHeader::FontCartridge].m_wOffset +
                    psgfh ->
                    m_asgpche[sGPCFileHeader::FontCartridge].m_wcbItem *
                    (-1 + *pw++));

                //  END RAID 102890

                //  Portrait

                if  (psfc -> m_wofPortraitList)
                    ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                        psfc -> m_wofPortraitList), cmw2dThis);

                //  Landscape

                if  (psfc -> m_wofLandscapeList)
                    ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                        psfc -> m_wofLandscapeList), cmw2dThis);
            }
        }

        //  Save the map in the font structure
        m_csoaFonts.Add(&cmw2dThis);
    }

    return  TRUE;
}


/******************************************************************************

  COldMiniDriverData::SplitMultiGPCs

  The Load() function has loaded information about each GPC entry into this
  class' member variables.  The problem is that there are some GPC entries
  that are used to manage multiple models.  This routine is used to "split"
  the data for these entries into single model "sections".  Actually, what
  happens is that new member variables entries are allocated for each model
  and the GPC entry's data is copied into them.  Next, a flag is set to
  mark this copy.

******************************************************************************/

bool COldMiniDriverData::SplitMultiGPCs(CStringTable& cstdriversstrings)
{
	// Make sure the data arrays are the same size.

	ASSERT(m_cwaidModel.GetSize() == m_cwaidCTT.GetSize()) ;
	ASSERT(m_cwaidModel.GetSize() == (int) m_csoaFonts.GetSize()) ;

	// Size the split codes array and split models names array to the current
	// number of GPC entries.

	m_cuaSplitCodes.SetSize(m_cwaidModel.GetSize()) ;
	m_csaSplitNames.SetSize(m_cwaidModel.GetSize()) ;
				
	// Declare the variables needed for the processing in the following loops.

	unsigned u, u2 ;			// Looping/indexing variables
	int nloc ;					// Location of "%" in model name
	CString csentryname ;	
	int nlen ;					// Length of csentryname/csmodelname

	// Loop through each GPC entry...

    for (u = 0 ; u < ModelCount(); u++) {

		// If the GPC entry's model name contains no percent signs, the entry
		// only references one model.  Note this and continue.

		csentryname = cstdriversstrings[ModelName(u)] ;
		if ((nloc = csentryname.Find(_T('%'))) == -1) {
			SetSplitCode(u, NoSplit) ;
			continue ;
		} ;

		// The entry references multiple models.  Mark the entry as the first
		// one and save its correct single model name.

		SetSplitCode(u, FirstSplit) ;
		m_csaSplitNames[u] = csentryname.Left(nloc) ;

		// Copy the entry's data into new elements of the data arrays.  One
		// new set of data elements are allocated for each additional model
		// referenced by the entry.

		nlen = csentryname.GetLength() ;
		for (u2 = u + 1 ; nloc != -1 ; u2++, u++) {
			m_cwaidModel.InsertAt(u2, m_cwaidModel[u]) ;
			m_cwaidCTT.InsertAt(u2, m_cwaidCTT[u]) ;
			m_csoaFonts.InsertAt(u2, m_csoaFonts[u]) ;
			InsertSplitCode(u2, OtherSplit) ;

			// Look for the next percent sign in the entry's name.  (Make sure
			// we don't reference passed the end of the string while doing
			// this.)

			if (nloc + 2 < nlen) {
				csentryname = csentryname.Mid(nloc + 1) ;
				nlen = csentryname.GetLength() ;
				nloc = csentryname.Find(_T('%')) ;
			} else
				break ;

			// Save the model name for the new entry.

			if (nloc == -1)
				m_csaSplitNames.InsertAt(u2, csentryname) ;
			else
				m_csaSplitNames[u] = csentryname.Left(nloc) ;
		} ;
	} ;

	// All went well so...

	return true ;
}


/******************************************************************************

  COldMiniDriverData::FontMap(unsigned u)

  This member returns the map which shows which fonts are used by the given
  model.

******************************************************************************/

CMapWordToDWord&   COldMiniDriverData::FontMap(unsigned u) const {
    return  *(CMapWordToDWord *) m_csoaFonts[u];
}

/******************************************************************************

  COldMiniDriverData::NoteTranslation

  This records the fact that model nn must translate instances of font ID xxx
  to font ID y.
******************************************************************************/

void    COldMiniDriverData::NoteTranslation(unsigned uModel, unsigned uidOld,
                                            unsigned uidNew) {
    FontMap(uModel)[(WORD)uidOld] = uidNew;
}

/******************************************************************************

  CModelData class

  This class encapsulates the GPD file.  It will start life as a big
  CStringArray, but as the editor gets more sophisticated, it may gain
  additional members to speed processing and/or manipulation of the data.

******************************************************************************/

IMPLEMENT_SERIAL(CModelData, CProjectNode, 0)


/******************************************************************************

  CModelData::FillViewer

  This static member function is a callback for the rich edit control.  It
  receives a pointer to the CModelData in question, and calls its Fill from
  buffer member function.

  Args:
	DWORD	dwthis		Pointer to the CModelData in question
	LPBYTE	lpb			Pointer to the buffer to fill
	LONG	lcb			Number of bytes to read
	LONG   *plcb		Number of bytes actually read is saved here

  Returns:
    TRUE (failure) if class instance pointer is NULL.  Otherwise, whatever
	Fill() returns.

******************************************************************************/

DWORD CALLBACK  CModelData::FillViewer(DWORD_PTR dwthis, LPBYTE lpb, LONG lcb,
                                       LONG *plcb) {
    if  (!dwthis)
        return  TRUE;

    CModelData* pcmd = (CModelData *) dwthis;

    return pcmd -> Fill(lpb, lcb, plcb);
}


/******************************************************************************

  CModelData::FromViewer

  This is a stream callback for moving data from the edit control to the GPD
  class.  It receives a pointer to the CModelData being updated, and calls its
  UpdateFrom buffer member function to do the rest of the work

******************************************************************************/

DWORD CALLBACK  CModelData::FromViewer(DWORD_PTR dwthis, LPBYTE lpb, LONG lcb,
                                       LONG *plcb) {
    if  (!dwthis)
        return  TRUE;   //  Stop the madness

    CModelData* pcmd = (CModelData *) dwthis;

    return  pcmd -> UpdateFrom(lpb, lcb, plcb);
}


/******************************************************************************

  CModelData::Fill(LPBYTE lpb, LONG lcb, LONG *plcb)

  This private method fills a buffer from the GPD contents in CString form.
  An internal buffer is used to handle partially moved strings.

******************************************************************************/

DWORD CModelData::Fill(LPBYTE lpb, LONG lcb, LONG *plcb) {

    int iTotalLines = (int)m_csaGPD.GetSize();	// Get the # of lines in the GPD

	// If the temp buffer is empty and the next line to read is greater than
	// the number of lines in the GPD, the REC has been loaded.  We're done.

    if  (!m_cbaBuffer.GetSize() && m_iLine >= iTotalLines) {
        *plcb = 0;
        return  0;
    }

    unsigned    ucb = (unsigned) lcb;	// Number of bytes still wanted

    union   {
        LPTSTR  lpstr;
        LPBYTE  lpbThis;
    };

    //  First, empty anything buffered previously

    lpbThis = lpb;

	// If there is data left over from a line partially loaded into the REC
	// before..

    if  (m_cbaBuffer.GetSize())

		// ...If the partial line will fit into the REC buffer, copy it
		// into the buffer, update variables to indicate this, and continue.

        if  ((unsigned) m_cbaBuffer.GetSize() <= ucb) {
            memcpy(lpbThis, m_cbaBuffer.GetData(), (size_t)m_cbaBuffer.GetSize());
            ucb -= (unsigned)m_cbaBuffer.GetSize();
            lpbThis += m_cbaBuffer.GetSize();
            m_cbaBuffer.RemoveAll();

		// ...If the partial line won't fit in the REC buffer, copy the
		// portion of it that will fit into the REC buffer, remove those bytes
		// from the line buffer, and return because nothing more can be loaded.

		} else {
            memcpy(lpbThis, m_cbaBuffer.GetData(), ucb);
            m_cbaBuffer.RemoveAt(0, ucb);
            *plcb = lcb;
            return  0;
        }

	// Line by line, copy as much data as possible into the REC's buffer.

    for (; ucb && m_iLine < iTotalLines; m_iLine++) {
		// Get the next GPD line and add CR LF to it.

        CString csLine = m_csaGPD[m_iLine];
        csLine += _TEXT("\r\n");

		// If the entire line will fit into the REC's buffer, copy it in.  Then
		// update all pointers, counters, etc and then check the next line.

        if  ((csLine.GetLength()) * sizeof(TCHAR) <= ucb) {
            memcpy(lpbThis, (LPCTSTR) csLine,
                sizeof(TCHAR) * csLine.GetLength());
            ucb -= sizeof(TCHAR) * csLine.GetLength();
            lpstr += csLine.GetLength();
            continue;
        }

		// If this point is reached, the current line will not fit in the REC's
		// buffer so first copy the line into the temp buffer.  Then copy the
		// portion of the line that will fit into the REC's buffer.  Last,
		// update the buffers, pointers, and counters.

        m_cbaBuffer.SetSize(sizeof(TCHAR) * csLine.GetLength());
        memcpy(m_cbaBuffer.GetData(), (LPCTSTR) csLine,
            sizeof(TCHAR) * csLine.GetLength());
        memcpy(lpbThis, m_cbaBuffer.GetData(), ucb);
        m_cbaBuffer.RemoveAt(0, ucb);
        ucb = 0;
    }

	// Save the number of bytes load and return 0 to indicate success.

    *plcb = lcb - ucb;
    return  0;
}


/******************************************************************************

  CModelData::UpdateFrom(LPBYTE lpb, LONG lcb, LONG* plcb)

  This is a private member- an overload which adds the contents of the given
  buffer to the GPD CStringArray, by parsing it into strings.  A private buffer
  member is used to hold partial strings between calls.

******************************************************************************/

DWORD   CModelData::UpdateFrom(LPBYTE lpb, LONG lcb, LONG* plcb) {
    //  Copy the buffer to a byte buffer and null-terminate
    m_cbaBuffer.SetSize(1 + lcb);
    memcpy(m_cbaBuffer.GetData(), lpb, lcb);
    m_cbaBuffer.SetAt(-1 + m_cbaBuffer.GetSize(), 0);

    //  Convert to string and append to any buffered data.

    CString csWork(m_cbaBuffer.GetData());
    CString csEnd(_T("\r\x1A"));    //  These get dumped

    m_cbaBuffer.RemoveAll();

    m_csBuffer += csWork;

    //  Add any complete strings to the GPD contents.

    csWork = m_csBuffer.SpanExcluding(_T("\n"));

    while   (csWork.GetLength() != m_csBuffer.GetLength()) {
        m_csBuffer = m_csBuffer.Mid(csWork.GetLength() + 1);
        //  Remove any trailing whitespace.
        csWork.TrimRight();
        //  Add the string sans any leading control characters
        m_csaGPD.Add(csWork.Mid(csWork.SpanIncluding(csEnd).GetLength()));
        //  While we're here, remove any leading control characters from buffer
        m_csBuffer =
            m_csBuffer.Mid(m_csBuffer.SpanIncluding(csEnd).GetLength());
        csWork = m_csBuffer.SpanExcluding(_T("\n"));
    }
    //  The leftover data (if any) may be used later...

    *plcb = lcb;
    return  0;
}

/******************************************************************************

  CModelData::Classify

  This method identifies the line numbers for each warning comment, error
  comment, and any other sort of comment, so they can later be syntax colored.

******************************************************************************/

/******************************************************************************

  CModelData::CModelData

  Constructs an empty CModelData object- includes building the Menu table

******************************************************************************/

CModelData::CModelData() {
    m_pcmdt = NULL;
    m_cfn.SetExtension(_T(".GPD"));
    m_cfn.AllowPathEdit();

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_CopyItem);
    m_cwaMenuID.Add(ID_RenameItem);
    m_cwaMenuID.Add(ID_DeleteItem);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);

	// Initialize the variables needed for workspace completeness and tidiness
	// checking.

	m_bTCUpdateNeeded = false ;	
	m_pnUFMRCIDs = m_pnStringRCIDs = NULL ;
	m_nNumUFMsInGPD = m_nNumStringsInGPD = 0 ;
	m_pvRawData = NULL ;
}


/******************************************************************************

  CModelData::~CModelData()

  Free, unload, and delete the data used for completeness and tidiness checks.

******************************************************************************/

extern "C" void UnloadRawBinaryData(PVOID pRawData) ;

CModelData::~CModelData()
{
	// If the GPD has been parsed...

    if  (m_pvRawData) {

		// Free the parsed data

        UnloadRawBinaryData(m_pvRawData) ;

		// Delete the parsed data file

		try {
			CString cs ;
			cs = FilePath() + FileTitle() + _T(".BUD") ;
			DeleteFile(cs) ;
		}
		catch (CException *pce) {
			pce->ReportError();
			pce->Delete();
		}

		// Delete each of the resource lists that exist

		if (m_pnUFMRCIDs)
			delete m_pnUFMRCIDs ;
		if (m_pnStringRCIDs)
			delete m_pnStringRCIDs ;
	} ;
}


/******************************************************************************

  CModelData::Load(CStdioFile csiofGPD)

  This overload loads the GPD from a text file directly.

******************************************************************************/

BOOL    CModelData::Load(CStdioFile& csiofGPD)
{
    CString csWork;				// Used to read the GPD file's contents

	// Initialize the string array used to hold the GPD file's contents

    m_csaGPD.RemoveAll();

	// Load the GPD into the string array one line at a time.

    while   (csiofGPD.ReadString(csWork)) {
        csWork.TrimRight(); //  Cut off the trailing line stuff
        m_csaGPD.Add(csWork);
    }

    //  Set the correct name and path when necessary.  The rename checks may
    //  fail since the file is opened elsewhere (possibly with sharing
    //  conflicts), so disable them while the name is set.

    if  (FileTitle().IsEmpty()) {
        m_cfn.EnableCreationCheck(FALSE);
        SetFileName(csiofGPD.GetFilePath());
        m_cfn.EnableCreationCheck();
    }

	// All went well so...

    return  TRUE;
}


/******************************************************************************

  CModelData::Load()

  This overload loads the GPD file from the disk using the stored name and path
  information.

******************************************************************************/

BOOL    CModelData::Load()
{
	// There is nothing to load if no file has been associated with this
	// instance of CModelData.

    if  (FileTitle().IsEmpty())
        return  FALSE;

    // Open the GPD file and call another load routine to finish the work.

	try {
        CStdioFile  csiofGPD(FileName(),
            CFile::modeRead | CFile::shareDenyWrite);
        return  Load(csiofGPD);
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  FALSE;
}


/******************************************************************************

  CModelData::Store

  This method sends the GPD file to the disk.  Since GPD infromation can be
  easily edited with an external editor, this avoids replication and
  consistency issues.

******************************************************************************/

BOOL    CModelData::Store(LPCTSTR lpstrPath) {

	int n =	(int)m_csaGPD.GetSize() ;
	CString cs = m_csaGPD[0] ;

    //  Write the GPD file to the target location, with the traditional CR/LF
    //  separators.  If the given name is NULL, use the stored one.

    try {
        CStdioFile   csiofGPD(lpstrPath ? lpstrPath :
            FileName(), CFile::modeCreate | CFile::modeWrite |
            CFile::shareExclusive | CFile::typeBinary);

        for (int i = 0; i < m_csaGPD.GetSize(); i++)
            csiofGPD.WriteString(m_csaGPD[i] + _T("\r\n"));
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    Changed(FALSE);

    return  TRUE;
}


/******************************************************************************

  CModelData::BkupStore

  Backup the original contents of the GPD to file called "BKUP_GPD" before
  calling Store() to save the file.

  Return TRUE if the backup and storing succeed.  Otherwise, return FALSE.

******************************************************************************/

BOOL    CModelData::BkupStore()
{
	// Build the backup file's filespec

	CString csbkfspec = m_cfn.Path() ;
	if (csbkfspec[csbkfspec.GetLength() - 1] != _T('\\'))
		csbkfspec += _T("\\") ;
	csbkfspec += _T("BKUP_GPD") ;

	// raid 9730 : bug caused by "Read-Only"
	CFileStatus rStatus;
	CFile::GetStatus(FileName(), rStatus);
	// Back up the file. 
    try {
        if (rStatus.m_attribute & 0x01 || !CopyFile(FileName(), csbkfspec, FALSE)) {//end raid
			csbkfspec.Format(IDS_GPDBackupFailed, FileTitleExt()) ;
			if (AfxMessageBox(csbkfspec, MB_YESNO + MB_ICONQUESTION) == IDNO)
				return FALSE  ;
		} ;
    }
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return  FALSE ;
    } ; 

	// Now do a normal store operation.

	return (Store()) ;
}


/******************************************************************************

  CModelData::Restore

  Copy the file "BKUP_GPD" to the GPD file to restore the GPD's original
  contents.  If the restore operation is successful, delete the backup file.

  Return nonzero if this succeeds.  Otherwise, return FALSE.

******************************************************************************/

BOOL    CModelData::Restore()
{
	// Build the backup file's filespec

	CString csbkfspec = m_cfn.Path() ;
	if (csbkfspec[csbkfspec.GetLength() - 1] != _T('\\'))
		csbkfspec += _T("\\") ;
	csbkfspec += _T("BKUP_GPD") ;

	// Restore the file.

    try {
        if (CopyFile(csbkfspec, FileName(), FALSE)) {
			DeleteFile(csbkfspec) ;
			return TRUE ;
		} else
			return FALSE ;
    }
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return  FALSE ;
    } ;
}


/******************************************************************************

  CModelData::Parse

  This method is responsible for parsing the GPD file and collecting the
  resulting errors.

  The initial implementation will be a bit bizarre, because the GPD parser
  isn't stable, and converting it so it would work well for ma and then staying
  on top of the changes just doesn't make sense.

******************************************************************************/

extern "C" BOOL BcreateGPDbinary(LPCWSTR lpstrFile, DWORD dwVerbosity);
                                                        //  The parser hook
extern "C" PVOID LoadRawBinaryData(LPCWSTR lpstrFile) ;
extern "C" PVOID InitBinaryData(PVOID pv, PVOID pv2, PVOID pv3) ;
extern "C" void FreeBinaryData(PVOID pInfoHdr);
extern "C" void UseLog(FILE *pfLog);

//extern "C" DWORD gdwVerbosity ;

BOOL    CModelData::Parse(int nerrorlevel)
{
	//  Step 0: Set the error level.  This is 0 by default.

    //  Step 1: Establish the correct directory for the parser, and
    //  bang together a couple of file names

    CString csCurrent ;

    GetCurrentDirectory(MAX_PATH + 1, csCurrent.GetBuffer(MAX_PATH + 1));
    csCurrent.ReleaseBuffer();

    SetCurrentDirectory(m_cfn.Path().Left(m_cfn.Path().ReverseFind(_T('\\'))));

    //  Step 2: Fake out the error logging interface so it actually tosses
    //  them all into a CString Array for us, the invoke the parser.

    SetLog();


    //  Step 3:  Convert the file name to Unicode so we don't have to tweak the
    //  parser code.

	CString	csFile = FileTitle() + _T(".GPD");
	CByteArray	cbaIn;
	CWordArray	cwaOut;
	cbaIn.SetSize(csFile.GetLength() + 1);
	lstrcpy((LPSTR) cbaIn.GetData(), csFile);
	CCodePageInformation	ccpi;
	ccpi.Convert(cbaIn, cwaOut, GetACP());

    if  (BcreateGPDbinary((PWSTR)cwaOut.GetData(), nerrorlevel)) {
        PVOID   pRawData ;
        PVOID   pInfoHdr ;

        pRawData = LoadRawBinaryData((PWSTR)cwaOut.GetData());

        if(pRawData)
            pInfoHdr = InitBinaryData(pRawData, NULL, NULL);
        if  (pRawData && pInfoHdr)
            FreeBinaryData(pInfoHdr);
        if  (pRawData)
            UnloadRawBinaryData(pRawData) ;
        DeleteFile(FileTitle() + _T(".Bud"));
    }

    //  Finally, clean up the mess by restoring the original working
    //  directory and turn off logging.

    SetCurrentDirectory(csCurrent);
	EndLog() ;

    return  TRUE;
}

/******************************************************************************

  CModelData::RemoveError

  This removes the given error from the log.

******************************************************************************/

void    CModelData::RemoveError(unsigned u) {
    if  (u >= Errors())
        return;

    m_csaConvertLog.RemoveAt(u);
    Changed();
}


/******************************************************************************

  CModelData::Fill(CRichEditCtrl& crec)

  This overload fills the gven rich edit control with the GPD contents, either
  as currently cached in memory, or stored on the disk.

******************************************************************************/

void    CModelData::Fill(CRichEditCtrl& crec)
{
	// Prepare to load the rich edit control (REC) with the GPD data

	EDITSTREAM  es = {(DWORD_PTR) this, 0, FillViewer};
    m_iLine = 0;

    // If the GPD is not in memory yet, read it in before loading the REC.

	if  (!m_csaGPD.GetSize())
        Load();
	
	// Load the GPD into the REC.

    crec.StreamIn(SF_TEXT, es);
}


/******************************************************************************

  CModelData::UpdateFrom(CRichEditCtrl& crec)

  This overloaded member function discards the current GPD cache and refills
  it from the given edit control.

******************************************************************************/

void    CModelData::UpdateFrom(CRichEditCtrl& crec) {

    EDITSTREAM es = {(DWORD_PTR) this, 0, FromViewer};

    m_csaGPD.RemoveAll();

    m_csBuffer.Empty(); //  Just in case...

    crec.StreamOut(SF_TEXT, es);
    Changed();
}


/******************************************************************************

  CModelData::CreateEditor

  This member function launches an editing view for the GPD Data.

******************************************************************************/

CMDIChildWnd*   CModelData::CreateEditor()
{
	// Create a new document class instance for the new editor

    CGPDContainer* pcgpdcMe=
        new CGPDContainer(this, FileName());

	// Read in the GPD

    Load();

    //  Make up a cool title

    pcgpdcMe -> SetTitle(m_pcbnWorkspace -> Name() + _T(": ") + Name());

	// Build a frame for the editor and attach the doc class to it

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt ->
        CreateNewFrame(pcgpdcMe, NULL);

	// Update the new frame/view

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcgpdcMe, TRUE);
        m_pcmdt -> AddDocument(pcgpdcMe);
    }

	// Return the new frame pointer

    return  pcmcwNew;
}


/******************************************************************************

  CModelData::Import

  This method walks one step up the tree and passes the call to the import
  method for the fixed node which owns us.

******************************************************************************/

void CModelData::Import() {
    ((CBasicNode *) m_pctcOwner ->
        GetItemData(m_pctcOwner -> GetParentItem(m_hti))) -> Import();
}


/******************************************************************************

  CModelData::Serialize

  Stores the image, as we need it stored.

******************************************************************************/

void    CModelData::Serialize(CArchive& car) {
    CProjectNode::Serialize(car);

	//TRACE("\n%s has %d strings:\n", Name(), m_csaConvertLog.GetSize()) ;
	//for (int n = 0 ; n < m_csaConvertLog.GetSize() ; n++)
	//	TRACE("   %d: %s\n", n, m_csaConvertLog[n]) ;

	m_csaConvertLog.Serialize(car);
}


/******************************************************************************

  CModelData::UpdateResIDs

  This routine will make sure that the specified resource ID list is up to
  date.  There are several steps that must be taken to accomplish this goal:
	1.	Free/invalidate old resource lists and related information if the GPD
		has changed.
	2.  Parse the GPD and load its data if this is needed.
	3.	If step 2 is taken or the requested resource list is unitialized, get
		that data.

******************************************************************************/

//#define	RESLISTSIZE		16		// Initial resource list size

// Declarations for the GPD Parser routine that will get resource ID lists.

extern "C" BOOL GetGPDResourceIDs(LPINT lpiresarray, int numelts, LPINT lpicount,	
								  BOOL brestype, PVOID prawdata) ;

bool	CModelData::UpdateResIDs(bool bufmids)
{
	//TRACE("gdwVerbosity = %d\n", gdwVerbosity) ;

	// If the GPD has changed so the resource data needs to be updated...

	if (m_bTCUpdateNeeded) {
		if (m_pvRawData) {		// Free the old preparsed data if there is any
			UnloadRawBinaryData(m_pvRawData) ;
			m_pvRawData = NULL ;
		} ;
		if (m_pnUFMRCIDs) {		// Free the old UFM RC ID list if there is one
			delete m_pnUFMRCIDs ;
			m_pnUFMRCIDs = NULL ;
			m_nNumUFMsInGPD = 0 ;
		} ;
		if (m_pnStringRCIDs) {	// Free the old string RC ID list if there is one
			delete m_pnStringRCIDs ;
			m_pnStringRCIDs = NULL ;
			m_nNumStringsInGPD = 0 ;
		} ;
		m_bTCUpdateNeeded = false ;
	} ;

	// Parse and load the GPD data if this is needed.  If either of these steps
	// fail, return false because the resource list cannot be updated.

	if (!m_pvRawData) {
		try {
			WCHAR   wstrfilename[MAX_PATH] ;
			CString cs ;
			cs = FileName() ;
			MultiByteToWideChar(CP_ACP, 0, FileName(), -1, wstrfilename, MAX_PATH) ;
			//gdwVerbosity = 4 ;
			if (!BcreateGPDbinary(wstrfilename, 0))
				return false ;
			if ((m_pvRawData = LoadRawBinaryData(wstrfilename)) == NULL)
				return false ;
		}
		catch (CException *pce) {
			pce->ReportError() ;
			pce->Delete() ;
			return false ;
		}
	} ;

	// If the requested resource list is already up to date, just return true.

	if ((bufmids && m_pnUFMRCIDs) || (!bufmids && m_pnStringRCIDs))
		return true ;

	// Allocate space for the resource list

	int*	pn = NULL ;
	int		ncnt = -1 ;
	//pn = new int[RESLISTSIZE + 2] ;

	// Try to get the requested resource ID list.  If this fails because the
	// array used to hold the IDs isn't big enough, reallocate the array and
	// try to get the IDs again.  If this fails again, generate a hard error.

	GetGPDResourceIDs(pn, 0, &ncnt, bufmids, m_pvRawData) ;
	pn = new int[ncnt + 2] ;
	VERIFY(GetGPDResourceIDs(pn, ncnt, &ncnt, bufmids, m_pvRawData)) ;

	//if (GetGPDResourceIDs(pn, RESLISTSIZE, &ncnt, bufmids, m_pvRawData)) {
	//	delete pn ;
	//	pn = new int[ncnt + 2] ;
	//	VERIFY(!GetGPDResourceIDs(pn, ncnt, &ncnt, bufmids, m_pvRawData)) ;
	//} ;

	// Update the specific resource ID variables based with the info collected
	// above.

	if (bufmids) {
		m_pnUFMRCIDs = pn ;
		m_nNumUFMsInGPD = ncnt ;
	} else {
		m_pnStringRCIDs = pn ;
		m_nNumStringsInGPD = ncnt ;
	} ;

	// All went well so...

	return true ;
}


/******************************************************************************
//RAID 17897

  CModelData::GetKeywordValue

  Get the value of keyword in Gpd file, 

Arguments : 
 csFileName ; file path of gpd file 
 csKeyword  : section name such as *GpdFileVersion: , *ModleName:

Return :
 Success : return section value (string)
 Failue  : return csFileName : file path as it come
*****************************************************************************8*/


CString CModelData::GetKeywordValue(CString csfile, CString csKeyword)
{	
	CFile cf;
	CString  csModel,csline;
	int offset;
	
	CStringArray csaData;
	
	if(!LoadFile(csfile,csaData)){	// call global function in minidev.h(which is include for this fucntion)
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csfile);
		AfxMessageBox(csErr,MB_OK);
		return csfile;
	}

	for(int i=0; i<csaData.GetSize();i++){
		csline = csaData[i];
		if(-1 ==(offset=csline.Find(csKeyword)))
			continue;
		else
		{
			csModel = csline.Mid(offset+csKeyword.GetLength());

			return csModel.Mid(csModel.Find(_T('"'))+1,csModel.ReverseFind(_T('"'))
				+ - csModel.Find(_T('"')) - 1 );	// cancel  : "
			
			
		}
	}
	return csfile;
}
/***************************************************************************************
	CModelData::SetKeywordValue
Set the keyword value 

Arguments:
csfile ; target file gpd file name
csKeyword : target keyword ex) *GPDFilename
csValue : value of keyworkd ex)*GPDFilename= g;\nt\dirver\mm.gpd


*****************************************************************************************/

void CModelData::SetKeywordValue(CString csfile, CString csKeyword, CString csValue,bool bSource)
{
	CFile cf;
	int offset;
	CString csline;
	CStringArray csaData;
	
	if(!LoadFile(csfile,csaData)){
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csfile);
		AfxMessageBox(csErr,MB_OK);
	}


	for(int i=0; i<csaData.GetSize();i++){
		csline = csaData[i];
		if(-1 ==(offset=csline.Find(csKeyword)))
			continue;
		else
		{
			csline.Empty();
			if(bSource )
				csline = csKeyword + _T("=") + csValue ;
			else
				csline = csKeyword +_T(": ")+ _T('"') + csValue + _T('"');
			
			csaData[i]= csline;
			m_csaGPD.Copy(csaData);
			Store(csfile);
			return ;
		}
	}
}
	
	
			


/******************************************************************************

  CGPDContainer class implementation

  This class is a document class which contains one GPD file and its assorted
  control mechanisms

******************************************************************************/

IMPLEMENT_DYNCREATE(CGPDContainer, CDocument)

// This version of the constructor is called when the GPD Editor is started
// from the Workspace View.

CGPDContainer::CGPDContainer(CModelData *pcmd, CString csPath)
{
    m_bEmbedded = TRUE ;		// Called from Workspace View
    m_pcmd = pcmd;
    SetPathName(csPath, FALSE);
    m_pcmd -> NoteOwner(*this);
}


// This version of the constructor is called when the GPD Editor is started
// from the File Open command.

CGPDContainer::CGPDContainer()
{
    m_bEmbedded = FALSE;		// Called from File Open menu
    m_pcmd = new CModelData;
    m_pcmd -> NoteOwner(*this);
}


/******************************************************************************

  CGPDContainer::OnNewDocument

  We just pass it back to the default handler.  Could mean this one can be
  toasted

******************************************************************************/

BOOL CGPDContainer::OnNewDocument() {
	return  CDocument::OnNewDocument();
}

/******************************************************************************

  CGPDContainer::~CGPDContainer

  If this wasn't created from the workspace, then zap the data!

******************************************************************************/

CGPDContainer::~CGPDContainer() {
    if  (!m_bEmbedded && m_pcmd)
        delete  m_pcmd;
}


BEGIN_MESSAGE_MAP(CGPDContainer, CDocument)
	//{{AFX_MSG_MAP(CGPDContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer diagnostics

#ifdef _DEBUG
void CGPDContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CGPDContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer serialization

void CGPDContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
	}
	else {
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer commands

/******************************************************************************

  CGPDContainer::OnSaveDocument

  First, make sure that the document is up to date.  See CGPDViewer::OnUpdate()
  for more information.  Then, we bypass the normal serialization process, and
  simple blast it to the drive.

******************************************************************************/

BOOL CGPDContainer::OnSaveDocument(LPCTSTR lpszPathName)
{
	UpdateAllViews(NULL, 0x4545, (CObject*) 0x4545) ;

    return  ModelData()->Store(lpszPathName) ;
}

/******************************************************************************

  CDPSContainer::OnOpenDocument

  Again, blow off serialization- if I haven't figured out how to read a text
  file by now, I'm definitely in the wrong place.

******************************************************************************/

BOOL CGPDContainer::OnOpenDocument(LPCTSTR lpszPathName) {
    try {
        CStdioFile  csiofGPD(lpszPathName, CFile::modeRead |
            CFile::shareDenyWrite | CFile::typeText);

        return  ModelData() -> Load(csiofGPD);
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  FALSE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdview.h ===
/******************************************************************************

  Header File:  GPD Viewer.H

  This defines the class which implements the GPD viewer / editor.  Looks
  pretty painless for the nonce.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03/24/1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_)
#define AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGPDViewer : public CRichEditView {
    int         m_iLine, m_iTopLineColored; //  Used for work items
    UINT        m_uTimer;					//  Identifier for change timer
    CDialogBar  m_cdbActionBar;				//  Holds GPD related controls/info
    CStatusBar  m_csb;						//  Manages the GPD Editor's status bar
    CFindReplaceDialog  m_cfrd;				//  Unused at this (6/29/98) time
    BOOL        m_bInColor, m_bStart;       //  Flags to avoid recursion
	int			m_nErrorLevel ;				//  Parser verbosity level
	bool		m_bEditingAidsEnabled ;		//  True iff editing aids are enabled
	void*		m_punk ;					//  Used to freeze REC display
	void*		m_pdoc ;					//  Used to freeze REC display
	long		m_lcount ;					//  Used to freeze REC display
	bool		m_bVScroll ;				//  True iff VScroll msg handled

    void        MarkError(unsigned u);
    void        CreateActionBar();
    void        LoadErrorListBox();
    void        Color();
    unsigned    TextColor(int i, int& nstartchar, int& nendchar);
	unsigned	CommentColor(CString csphrase, int ncomloc, CString csline, 
							 int& nstartchar, int& nendchar) ;
	unsigned	KeywordColor(CString csphrase, int nkeyloc, CString csline, 
							 int& nstartchar, int& nendchar) ;
	bool		IsRECLineVisible(int nline = -1) ;
	static LPTSTR	alptstrStringIDKeys[] ;	// Keywords with string ID values
	static LPTSTR	alptstrUFMIDKeys[] ;	// Keywords with UFM ID values

protected: // create from serialization only
	CGPDViewer();
	DECLARE_DYNCREATE(CGPDViewer)

// Attributes
public:
    CGPDContainer*  GetDocument() { return (CGPDContainer *) m_pDocument; }

// Operations
public:
    void        UpdateNow();
	void		FreezeREC() ;
	void		UnfreezeREC() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDViewer)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL
    virtual HRESULT QueryAcceptData(LPDATAOBJECT lpdo, CLIPFORMAT FAR *pcf,
        DWORD dwUnused, BOOL bReally, HGLOBAL hgMetaFile);

// Implementation
public:
	virtual ~CGPDViewer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    afx_msg void    OnSelChange(LPNMHDR pnmh, LRESULT *plr);
      
	// Generated message map functions
	//{{AFX_MSG(CGPDViewer)
	afx_msg void OnDestroy();
	afx_msg void OnFileParse();
	afx_msg void OnChange();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnVscroll();
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileErrorLevel();
	afx_msg void OnGotoGPDLineNumber();
	afx_msg void OnSrchNextBtn();
	afx_msg void OnSrchPrevBtn();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnSelchangeErrorLst();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnEditEnableAids();
	afx_msg void OnEditPaste();
	afx_msg void OnEditCut();
	afx_msg void OnFileInf();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ChangeSelectedError(int nchange) ;
	bool SearchTheREC(bool bforward) ; 
	int  ReverseSearchREC(CRichEditCtrl& crec, FINDTEXTEX& fte, int norgcpmin, 
						  int norgcpmax) ;
	bool GotoMatchingBrace() ;
	bool IsBraceToMatch(CString& cssel, TCHAR& chopen, TCHAR& chclose, 
						bool bchecksecondchar, bool& bsearchup, CHARRANGE cr, 
						int& noffset) ;
	void InitGPDKeywordArray() ;
} ;


#define	MIN_PARSER_VERBOSITY	0
#define	MAX_PARSER_VERBOSITY	4


/////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////
// CGotoLine dialog

class CGotoLine : public CDialog
{
	int		m_nMaxLine ;		// Maximum allowable line number
	int		m_nLineNum ;		// Line number entered by user

// Construction
public:
	CGotoLine(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGotoLine)
	enum { IDD = IDD_GotoLine };
	CEdit	m_ceGotoBox;
	CString	m_csLineNum;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGotoLine)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGotoLine)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void	SetMaxLine(int nmax) { m_nMaxLine = nmax ; }
	int 	GetMaxLine() { return m_nMaxLine ; }
	int 	GetLineNum() { return m_nLineNum ; }
};




/////////////////////////////////////////////////////////////////////////////
// CErrorLevel dialog

class CErrorLevel : public CDialog
{
// Construction
public:
	CErrorLevel(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CErrorLevel)
	enum { IDD = IDD_ErrorLevel };
	CComboBox	m_ccbErrorLevel;
	int		m_nErrorLevel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CErrorLevel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CErrorLevel)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void	SetErrorLevel(int nerrlev) { m_nErrorLevel = nerrlev ; }
	int		GetErrorLevel() { return m_nErrorLevel ; }
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gtt.cpp ===
/******************************************************************************

  Source File:  Glyph Translation.CPP

  This implements the classes which encode glyph mapping information.

  Copyright (c) 1997 by Microsoft Corporation.  All rights reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-13-97  Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

#include    "StdAfx.H"
#include    "Resource.H"

// Psuedo definition of DESIGNVECTOR.
#if (_WIN32_WINNT < 0x0500)
typedef unsigned long DESIGNVECTOR;
#endif

#include    "GTT.H"
#include    <CodePage.H>
#include    <wingdi.h>
#include    <winddi.h>
#include    <prntfont.h>
#include    <uni16res.h>
#define _FMNEWFM_H_
#include	"ProjRec.h"
#include    "ChildFrm.H"
#include    "GTTView.H"
#include    "minidev.h"

extern "C"
BOOL
BConvertCTT2GTT(
    IN     HANDLE             hHeap,
    IN     PTRANSTAB          pCTTData,
    IN     DWORD              dwCodePage,
    IN     WCHAR              wchFirst,
    IN     WCHAR              wchLast,
    IN     PBYTE              pCPSel,
    IN     PBYTE              pCPUnSel,
    IN OUT PUNI_GLYPHSETDATA *ppGlyphSetData,
    IN     DWORD              dwGlySize);

extern "C"
PUNI_GLYPHSETDATA
PGetDefaultGlyphset(
	IN		HANDLE		hHeap,
	IN		WORD		wFirstChar,
	IN		WORD		wLastChar,
	IN		DWORD		dwCodePage) ;

struct sRLE {
    enum {Direct = 10, Paired, LengthOffset, LengthIndexOffset, Offset};
    WORD    m_wFormat;
    WORD    m_widRLE;   //  Must have unique "magic" value 0x78FE
    DWORD   m_dwcbThis; //  Total size of the memory image.
    WCHAR   m_wcFirst, m_wcLast;
    //  Handle mapping data follows
    DWORD   m_dwcbImage;    //  Size of the handle mapping data only
    DWORD   m_dwFlag;
    DWORD   m_dwcGlyphs, m_dwcRuns;
};

union uencCTT {
    WORD    wOffset;
    BYTE    m_bDirect;      //  This member is used in GTT only!
    BYTE    abPaired[2];
};

struct sMapTableEntry {
    enum {Composed = 1, Direct = 2, Paired = 4, Format = 7, SingleByte,
            DoubleByte = 0x10, DBCS = 0x18, Replace = 0x20, Add = 0x40,
            Disable = 0x80, PredefinedMask = 0xE0};
    BYTE    m_bCodePageIndex, m_bfType;
    uencCTT m_uectt;
};

//  Since I don't build the map table in memory, there is no need to declare
//  the fact that the array of entries follows it
struct sMapTable {
    DWORD   m_dwcbImage, m_dwcEntries;
    sMapTable(unsigned ucEntries) {
        m_dwcbImage = sizeof *this + ucEntries * sizeof (sMapTableEntry);
        m_dwcEntries = ucEntries; }
};

//  Use a static for Code Page information- gets the max benefit from caching

static CCodePageInformation* pccpi = NULL ;                                //  Use a static CCodePageInformation to derive more benefit from caching

/******************************************************************************
    CInvocation class implementation

******************************************************************************/

IMPLEMENT_SERIAL(CInvocation, CObject, 0)

void    CInvocation::Encode(BYTE c, CString& cs) const {
    if  (isprint(c))
        if  (c != _TEXT('\\'))
            cs = c;
        else
            cs = _TEXT("\\\\");
    else
        cs.Format(_TEXT("\\x%2.2x"), c);
}

/******************************************************************************

  CInvocation::Init

  This copies a series of bytes into the invocation.  Since the data structures
  used to represent these lend themselves most readily to this, this is the
  normal method used in reading info from a file.

******************************************************************************/

void    CInvocation::Init(PBYTE pb, unsigned ucb) {
    m_cbaEncoding.RemoveAll();

    while   (ucb--)
        m_cbaEncoding.Add(*pb++);
}

void    CInvocation::GetInvocation(CString& cs) const {
    CString csWork;

    cs.Empty();
    for (int i = 0; i < m_cbaEncoding.GetSize(); i++) {
        Encode(m_cbaEncoding[i], csWork);
        cs += csWork;
    }
}

//  This member converts a C-Style encoding of an invocation into
//  byte form and stores it.

void    CInvocation::SetInvocation(LPCTSTR lpstrNew) {

    CString csWork(lpstrNew);

    m_cbaEncoding.RemoveAll();

    while   (!csWork.IsEmpty()) {
        CString csClean = csWork.SpanExcluding("\\");

        if  (!csClean.IsEmpty()) {
            for (int i = 0; i < csClean.GetLength(); i++)
                m_cbaEncoding.Add((BYTE) csClean[i]);
            csWork = csWork.Mid(csClean.GetLength());
            continue;
        }

		// A backslash has been found.  If the string ends with a backslash, we
		// can't let the function assert in the switch statement so just return
		// and ignore the terminating backslash.  Yes, I know the string is
		// invalid if it ends this way but, according to MS, this isn't a field
		// they want validated.

		if (csWork.GetLength() <= 1)
			return ;

        // OK, we have something to decode

        switch  (csWork[1]) {

            case    _TEXT('r'):
                m_cbaEncoding.Add(13);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('n'):
                m_cbaEncoding.Add(10);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('b'):
                m_cbaEncoding.Add('\b');
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('\t'):
                m_cbaEncoding.Add(9);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('x'):
            case    _TEXT('X'):
                {

                    CString csNumber = csWork.Mid(2,2).SpanIncluding(
                        _TEXT("1234567890abcdefABCDEF"));

                    csWork = csWork.Mid(2 + csNumber.GetLength());
                    unsigned    u;

#if defined(UNICODE) || defined(_UNICODE)
#define _tsscanf    swscanf
#else
#define _tsscanf    sscanf
#endif

                    _tsscanf(csNumber, _TEXT("%x"), &u);
                    m_cbaEncoding.Add((BYTE)u);
                    continue;
                }

                //  TODO: octal encodings are pretty common

            default:
                m_cbaEncoding.Add(
                    (BYTE) csWork[(int)(csWork.GetLength() != 1)]);
                csWork = csWork.Mid(2);
                continue;
        }
    }

    //  We've done it!
}

//  This member function records the offset for its image (if any) and updates
//  the given offset to reflect this

void    CInvocation::NoteOffset(DWORD& dwOffset) {
    m_dwOffset = Length() ? dwOffset : 0;
    dwOffset += Length();
}

//  I/O routines, both native and document form

void    CInvocation::WriteSelf(CFile& cfTarget) const {
    DWORD   dwWork = Length();
    cfTarget.Write(&dwWork, sizeof dwWork);
    cfTarget.Write(&m_dwOffset, sizeof m_dwOffset);
}

void    CInvocation::WriteEncoding(CFile& cfTarget, BOOL bWriteLength) const {
    if  (bWriteLength) {
        WORD w = (WORD)Length();
        cfTarget.Write(&w, sizeof w);
    }

    cfTarget.Write(m_cbaEncoding.GetData(), Length());
}

void    CInvocation::Serialize(CArchive& car) {
    CObject::Serialize(car);
    m_cbaEncoding.Serialize(car);
}

/******************************************************************************
    CGlyphHandle class implementation

******************************************************************************/


CGlyphHandle::CGlyphHandle()
{
    m_wPredefined = m_wIndex = 0;
    m_dwCodePage = m_dwidCodePage = m_dwOffset = 0;

    // Allocate a CCodePageInformation class if needed.

    if (pccpi == NULL)
        pccpi = new CCodePageInformation ;
}


unsigned    CGlyphHandle::CompactSize() const {
    return  (m_ciEncoding.Length() < 3) ? 0 : m_ciEncoding.Length();
}

/******************************************************************************

  CGlyphHandle::operator ==

  Returns true if the encoding, code point, and code page IDs (but maybe not
  the indices) are the same.

******************************************************************************/

BOOL    CGlyphHandle::operator ==(CGlyphHandle& cghRef) {

    if  (cghRef.m_wCodePoint != m_wCodePoint ||
        cghRef.m_dwCodePage != m_dwCodePage ||
        m_ciEncoding.Length() != cghRef.m_ciEncoding.Length())
        return  FALSE;

    for (int i = 0; i < (int) m_ciEncoding.Length(); i++)
        if  (m_ciEncoding[i] != cghRef.m_ciEncoding[i])
            return  FALSE;

    return  TRUE;
}

/******************************************************************************

  CGlyphHandle::Init

  This function has three overloads, for intializing from direc, paired, or
  composed data.

******************************************************************************/

void    CGlyphHandle::Init(BYTE b, WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(&b, 1);
}

void    CGlyphHandle::Init(BYTE ab[2], WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(ab, 2);
}

void    CGlyphHandle::Init(PBYTE pb, unsigned ucb, WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(pb, ucb);
}

/******************************************************************************

  CGlyphHandle::operator =

  This is a copy (assignment) operator for the class.

******************************************************************************/

CGlyphHandle&   CGlyphHandle::operator =(CGlyphHandle& cghTemplate) {
    m_dwCodePage = cghTemplate.m_dwCodePage;
    m_dwidCodePage = cghTemplate.m_dwidCodePage;
    m_wCodePoint = cghTemplate.m_wCodePoint;
    m_ciEncoding = cghTemplate.m_ciEncoding;
    return  *this;
}

//  This member records the current offset for the data in RLE format, and
//  then updates it to account for the length of any data that will go into
//  the extra storage at the end of the file/

void    CGlyphHandle::RLEOffset(DWORD& dwOffset, const BOOL bCompact) {
    if  (m_ciEncoding.Length() < 3)
        return; //  Don't need it, and don't use it!

    m_dwOffset = dwOffset;

    dwOffset += bCompact ? CompactSize() : MaximumSize();
}

/******************************************************************************

  CGlyphHandle::GTTOffset

  This member records the current offset for where our data will go, then adds
  the length of the encoding string to it and updates the offset.  It will only
  be updated if the encoding must be composed data.  The encoding length
  includes a WORD length in the GTT world.  Data of 1 byte, or of 2 if DBCS or
  a Paired font, does not add any length.

******************************************************************************/

void    CGlyphHandle::GTTOffset(DWORD& dwOffset, BOOL bPaired) {
    if  (m_ciEncoding.Length() >
         (unsigned) 1 + (bPaired || pccpi->IsDBCS(m_dwCodePage))) {
        m_dwOffset = dwOffset;
        dwOffset += m_ciEncoding.Length() + sizeof m_wIndex;
    }
    else
        m_dwOffset = 0;
}

//  These members write our vital stuff to a given file.

void    CGlyphHandle::WriteRLE(CFile& cfTarget, WORD wFormat) const {
    //  This is the RLE-specific glyph handle encoding

    union {
        DWORD   dwOffset;
        struct {
            union   {
                struct {
                    BYTE    bFirst, bSecond;
                };
                WORD    wOffset;
            };
            union   {
                struct {
                    BYTE    bIndexOrHiOffset, bLength;
                };
                WORD    wIndex;
            };
        };
    };

    switch  (wFormat) {
        case    sRLE::Direct:
        case    sRLE::Paired:

            bFirst = m_ciEncoding[0];
            bSecond = m_ciEncoding[1];
            wIndex = m_wIndex;
            break;

        case    sRLE::LengthIndexOffset:

            if  (!CompactSize()) { //  Encode it in the first two bytes
                bFirst = m_ciEncoding[0];
                bSecond = m_ciEncoding[1];
            }
            else
                wOffset = (WORD) m_dwOffset;

            bIndexOrHiOffset = (BYTE) m_wIndex;
            bLength = (BYTE)m_ciEncoding.Length();
            break;

        case    sRLE::LengthOffset:

            if  (!CompactSize()) { //  Encode it in the first two bytes
                bFirst = m_ciEncoding[0];
                bSecond = m_ciEncoding[1];
                bIndexOrHiOffset = (BYTE) m_wIndex;
                bLength = (BYTE)m_ciEncoding.Length();
                break;
            }

            dwOffset = m_dwOffset;
            bLength = (BYTE)m_ciEncoding.Length();
            break;

        case    sRLE::Offset:
            dwOffset = m_dwOffset;
            break;

        default:
            _ASSERTE(FALSE);
            //  Should probably throw an exception...
    }

    cfTarget.Write(&dwOffset, sizeof dwOffset);
}

/******************************************************************************

  CGlyphHandle::WriteGTT

  This member function writes the GTT map table entry for this glyph in the
  requested format.

******************************************************************************/

static BYTE abFlags[] = {sMapTableEntry::Replace, sMapTableEntry::Add,
sMapTableEntry::Disable};

void    CGlyphHandle::WriteGTT(CFile& cfTarget, BOOL bPredefined) const {
    sMapTableEntry  smte;

    smte.m_bCodePageIndex = (bPredefined && m_wPredefined == Removed) ?
        0 : (BYTE) m_dwidCodePage;

    //  GTTOffset set m_dwOffset if Composed is needed.  Otherwise we can tell
    //  the proper flags by looking at the length and whether it is DBCS or not

    if  (m_dwOffset) {
        smte.m_uectt.wOffset = (WORD) m_dwOffset;
        smte.m_bfType = sMapTableEntry::Composed;
    }
    else {
        smte.m_bfType = pccpi->IsDBCS(m_dwCodePage) ?
            ((m_ciEncoding.Length() == 2) ?
            sMapTableEntry::Paired : sMapTableEntry::Direct ) |
            (pccpi->IsDBCS(m_dwCodePage, m_wCodePoint) ?
            sMapTableEntry::DoubleByte : sMapTableEntry::SingleByte) :
            (m_ciEncoding.Length() == 2) ?
            sMapTableEntry::Paired : sMapTableEntry::Direct;

        smte.m_uectt.abPaired[0] = m_ciEncoding[0];
        smte.m_uectt.abPaired[1] = m_ciEncoding[1];
    }

    if  (bPredefined)
        smte.m_bfType |= abFlags[m_wPredefined];

    //  Just write it out!
    cfTarget.Write(&smte, sizeof smte);
}

/******************************************************************************

  CGlyphHandle::WriteEncoding

  This method writes the encoding to to the file in the desired format.  The
  formats are:

  GTT- write nothing if not composed.  If composed, write the length, and then
  the encoding.

  RLESmall- just the encoding
  RLEBig- the index and the encoding.

******************************************************************************/

void    CGlyphHandle::WriteEncoding(CFile& cfTarget, WORD wfHow) const {
    if  (!m_dwOffset)
        return; //  Nothing to write

    if  (wfHow == RLEBig)
        cfTarget.Write(&m_wIndex, sizeof m_wIndex);

    m_ciEncoding.WriteEncoding(cfTarget, wfHow == GTT);

}

/******************************************************************************

  CRunRecord class implementation

******************************************************************************/

CRunRecord::CRunRecord(CGlyphHandle *pcgh, CRunRecord *pcrrPrevious) {
    m_wFirst = pcgh -> CodePoint();
    m_wcGlyphs = 1;
    m_dwOffset = 0;
    m_cpaGlyphs.Add(pcgh);

    //  Maintain that old double chain!

    m_pcrrPrevious = pcrrPrevious;
    m_pcrrNext = m_pcrrPrevious -> m_pcrrNext;
    m_pcrrPrevious -> m_pcrrNext = this;
    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
}

/******************************************************************************

  CRunRecord::CRunRecord(CRunRecord *pcrrPrevious, WORD wFirst)

  This private constructor is the second tail record initializer.  It is called
  when a run is split due to a glyph deletion.  In this case, we need to hook
  into the chain, then fill in the details from our predecessor.  wFirst tells
  us where to begin extracting data from said predecessor.

******************************************************************************/

CRunRecord::CRunRecord(CRunRecord* pcrrPrevious, WORD wFirst) {
    m_pcrrPrevious = pcrrPrevious;
    m_pcrrNext = pcrrPrevious -> m_pcrrNext;

    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
    m_pcrrPrevious -> m_pcrrNext = this;

    m_wFirst = m_wcGlyphs = 0;
    m_dwOffset = 0;

    //  That's the normal empty initialization.  Now, er fill ourselves from
    //  our predecessor

    for (; wFirst < pcrrPrevious -> Glyphs(); wFirst++)
        Add(&pcrrPrevious -> Glyph(wFirst));
}

/******************************************************************************

  CRunRecord::CRunRecord(CRunRecord *pcrrPrevious)

  This private constructor is the third and final tail record initializer.  It
  makes an exact duplicate of the previous record, then links itself into the
  chain appropriately.

  This constructor is necessary when a new code point is inserted ahead of the
  earliest code point in the set of run records without extending the first
  run.

******************************************************************************/

CRunRecord::CRunRecord(CRunRecord *pcrrPrevious) {
    m_wFirst = pcrrPrevious -> m_wFirst;
    m_wcGlyphs = pcrrPrevious -> m_wcGlyphs;
    m_pcrrNext = pcrrPrevious -> m_pcrrNext;
    m_pcrrPrevious = pcrrPrevious;
    m_pcrrPrevious -> m_pcrrNext = this;
    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
    m_cpaGlyphs.Copy(pcrrPrevious -> m_cpaGlyphs);
}

//  Initialize empty- this is used for the root record only

CRunRecord::CRunRecord() {
    m_wFirst = m_wcGlyphs = 0;
    m_dwOffset = 0;
    m_pcrrNext = m_pcrrPrevious = NULL;
}

CRunRecord::~CRunRecord() {
    if  (m_pcrrNext)
        delete  m_pcrrNext;
}

unsigned    CRunRecord::TotalGlyphs() const {
    return m_pcrrNext ?
        m_wcGlyphs + m_pcrrNext -> TotalGlyphs() : m_wcGlyphs;
}

BOOL    CRunRecord::MustCompose() const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        if  (GlyphData(u).CompactSize())
            return  TRUE;   //   No need to look further

    return  m_pcrrNext ? m_pcrrNext -> MustCompose() : FALSE;
}

unsigned    CRunRecord::ExtraNeeded(BOOL bCompact) {
    unsigned uNeeded = 0;

    for (unsigned u = 0; u < m_wcGlyphs; u++)
        uNeeded += bCompact ? Glyph(u).CompactSize() : Glyph(u).MaximumSize();

    return  uNeeded + (m_pcrrNext ? m_pcrrNext -> ExtraNeeded() : 0);
}

/******************************************************************************

  CRunRecord::GetGlyph()

  This returns the nth handle in the run.  We use recursion.  This could get
  bad enough in terms of performance (ony used to fill glyph map page in
  editor) that we drop it, but I'll try it first.

******************************************************************************/

CGlyphHandle*   CRunRecord::GetGlyph(unsigned u) const {

    if  (u < m_wcGlyphs)
        return  (CGlyphHandle *) m_cpaGlyphs[u];
    return  m_pcrrNext ? m_pcrrNext -> GetGlyph(u - m_wcGlyphs) : NULL;
}

/******************************************************************************

  CRunRecord::Add

  This member adds a glyph to the set of run records.  This can mean adding an
  additional record at the beginning or end of the set, extending an existing
  record at either the beginning or end, and in those cases, orentiay merging
  two records together.

******************************************************************************/

void    CRunRecord::Add(CGlyphHandle *pcgh) {
    WCHAR   wcNew = pcgh -> CodePoint();
    //  If the glyph is already in the run, just update the info on it.

    if  (m_wcGlyphs && wcNew >= m_wFirst && wcNew < m_wFirst + m_wcGlyphs){
        m_cpaGlyphs.SetAt(wcNew - m_wFirst, pcgh);
        return;
    }

    //  If this is the first record, and the glyph falls ahead of our first
    //  entry, we must clone ourselves, and become a one-glyph run.  We cannot
    //  insert a record in front of oursleves as we are embedded in the
    //  glyph map structure directly.

    if  (m_wcGlyphs && wcNew < m_wFirst - 1) {
        //  This can only happen to the first record- otherwise the tail logic
        //  below would prevent this occurence

        _ASSERTE(!m_pcrrPrevious);

        //  Clone us, using the copy contructor

        CRunRecord  *pcrr = new CRunRecord(this);

        m_wFirst = pcgh -> CodePoint();
        m_wcGlyphs = 1;
        m_cpaGlyphs.RemoveAll();
        m_cpaGlyphs.Add(pcgh);
        return;
    }

    if  (m_wcGlyphs && wcNew != m_wFirst + m_wcGlyphs &&
         wcNew != m_wFirst - 1) {

        //  This belongs in some other record- pass it down the line, or
        //  append a new one.

        if  (m_pcrrNext)
            //  If this falls ahead of the next record, we must insert one now

            if  (wcNew < m_pcrrNext -> m_wFirst - 1)
                m_pcrrNext = new CRunRecord(pcgh, this);
            else
                m_pcrrNext -> Add(pcgh);
        else
            m_pcrrNext = new CRunRecord(pcgh, this);
    }
    else {
        //  We're adding either at the front or the back, so do it right!
        if  (m_wFirst > wcNew) {
            m_cpaGlyphs.InsertAt(0, pcgh);
            m_wFirst = wcNew;
        }
        else
            m_cpaGlyphs.Add(pcgh);

        //  This belonged here, so add it in- the root record begins with
        //  0 glyphs, so if this is the first, keep track of it.

        if  (!m_wcGlyphs++)
            m_wFirst = wcNew;

        //  If there is a following run, see if we need to merge it.

        if  (m_pcrrNext &&
             m_pcrrNext -> m_wFirst == m_wFirst + m_wcGlyphs) {
            //  Merge the records.

            m_cpaGlyphs.Append(m_pcrrNext -> m_cpaGlyphs);
            m_wcGlyphs += m_pcrrNext -> m_wcGlyphs;

            //  Time to update the list.  The class destructor removes the
            //  tail records, so that pointer must be set to NULL before the
            //  merged record is deleted.

            CRunRecord *pcrrDead = m_pcrrNext;

            m_pcrrNext = m_pcrrNext -> m_pcrrNext;

            if  (m_pcrrNext)
                m_pcrrNext -> m_pcrrPrevious = this;

            pcrrDead -> m_pcrrNext = NULL;  //  Avoid destructor overkill
            pcrrDead -> m_wcGlyphs = 0;     //  Ditto
            delete  pcrrDead;
        }
    }
}

/******************************************************************************

  CRunRecord::Delete

  This member deletes a given glyph from the set of runs.  Deleting an entry is
  messy- it means splitting the record, unless we were so fortunate as to
  merely lop off one of the ends.

******************************************************************************/

void    CRunRecord::Delete(WORD wCodePoint) {
    //  If this isn't the right record, recurse or return as appropriate

    if  (wCodePoint < m_wFirst)
        return;

    if  (wCodePoint >= m_wFirst + m_wcGlyphs) {
        if  (m_pcrrNext)
            m_pcrrNext -> Delete(wCodePoint);
        return;
    }

    WORD    wIndex = wCodePoint - m_wFirst;

    //  Did we get lucky and hit the first or the last?

    if  (!wIndex || wIndex == -1 + m_wcGlyphs) {
        //  If there is only one entry in this run, kill it.

        if  (m_wcGlyphs == 1) {
            if  (m_pcrrPrevious) {    //  Not the first, then die!
                m_pcrrPrevious -> m_pcrrNext = m_pcrrNext;
                if  (m_pcrrNext)
                    m_pcrrNext -> m_pcrrPrevious = m_pcrrPrevious;
                m_pcrrNext = NULL;  //  We no longer have a follwing
                delete  this;
                return;             //  It is finished
            }

            //  We are the first.  If there's someone after us, get their stuff
            //  and make it ours- otherwise, zero everything.

            if  (m_pcrrNext) {
                m_cpaGlyphs.Copy(m_pcrrNext -> m_cpaGlyphs);
                m_wFirst = m_pcrrNext -> m_wFirst;
                m_wcGlyphs = m_pcrrNext -> m_wcGlyphs;
                CRunRecord *pcrrVictim = m_pcrrNext;
                m_pcrrNext = m_pcrrNext -> m_pcrrNext;
				if (m_pcrrNext)	// Raid 118880: BUG_BUG: m_pcrrNext become zero when deleted 1252 defalt with add code points
					m_pcrrNext -> m_pcrrPrevious = this;
                pcrrVictim -> m_pcrrNext = NULL;
                delete  pcrrVictim;
            }
            else {
                m_cpaGlyphs.RemoveAll();
                m_wFirst = m_wcGlyphs = 0;
            }
            m_dwOffset = 0;
            return;
        }

        //  OK, we can now kill the offending entry

        m_cpaGlyphs.RemoveAt(wIndex);
        m_wcGlyphs--;

        //  Yes, the following line is trick code.  It's good for the soul...
        m_wFirst += !wIndex;
        return; //  The glyph, she be toast.
    }

    //  Alas, this means we must split the record.

    //  Since this means a new one must be made, let a new constructor do
    //  most of the dirty work for us.

    m_pcrrNext = new CRunRecord(this, wIndex + 1);

    _ASSERTE(m_pcrrNext);   //  We lose that, we might as well die...

    //  Delete everything after the offending member

    m_cpaGlyphs.RemoveAt(wIndex, m_wcGlyphs - wIndex);

    //  Well, that about settles it, eh!
    m_wcGlyphs = wIndex;
}

/******************************************************************************

  CRunRecord::Empty

  This method will be called if the glyph map is being re-initialized.  We set
  everything back to its initial state, and delete any tail records.

******************************************************************************/

void    CRunRecord::Empty() {

    if  (m_pcrrNext)
        delete  m_pcrrNext;

    m_pcrrNext = 0;

    m_wFirst = m_wcGlyphs = 0;

    m_cpaGlyphs.RemoveAll();
}

/******************************************************************************

  CRunRecord::NoteOffset

  This routine is given an offset which is to be managed in the run- the
  management needed differs depending upon the file image being produced, so
  we use a parameter to describe the tyoe being output.

  In any event, the offset is passed by reference, and updated by each run
  record in the set, in turn.

******************************************************************************/

void    CRunRecord::NoteOffset(DWORD& dwOffset, BOOL bRLE, BOOL bPaired) {
    if  (bRLE) {
        m_dwOffset = dwOffset;
        dwOffset += m_wcGlyphs *
            ((CGlyphHandle *) m_cpaGlyphs[0]) -> RLESize();
    }
    else
        for (unsigned u = 0; u < Glyphs(); u++)
            Glyph(u).GTTOffset(dwOffset, bPaired);

    //  Recurse if there's more...
    if  (m_pcrrNext)
        m_pcrrNext -> NoteOffset(dwOffset, bRLE, bPaired);
}

//  This routine passes a DWORD to each glyph handle denoting where it can
//  store its extra data.  Each updates the offset, if necessary.

//  We then recursively call each descendant to do the same thing.

void    CRunRecord::NoteExtraOffset(DWORD &dwOffset, const BOOL bCompact) {

    for (unsigned u = 0; u < m_wcGlyphs; u++)
        Glyph(u).RLEOffset(dwOffset, bCompact);

    if  (m_pcrrNext)
        m_pcrrNext -> NoteExtraOffset(dwOffset, bCompact);
}

//  File output functions-  These are all basically recursive.  The callee does
//  its thing, then passes it on down the chain.  Since this is the order RLE
//  and GTT are written in, everything is fine.

void    CRunRecord::WriteSelf(CFile& cfTarget, BOOL bRLE) const {
    cfTarget.Write(this, Size(bRLE));
    if  (m_pcrrNext)
        m_pcrrNext -> WriteSelf(cfTarget, bRLE);
}

void    CRunRecord::WriteHandles(CFile& cfTarget, WORD wFormat) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteRLE(cfTarget, wFormat);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteHandles(cfTarget, wFormat);
}

//  Member for writing the total set of GTT Map Table Entries

void    CRunRecord::WriteMapTable(CFile& cfTarget, BOOL bPredefined) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteGTT(cfTarget, bPredefined);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteMapTable(cfTarget, bPredefined);
}

/******************************************************************************

  CRunRecord::WriteEncodings

  This calls each glyph in the run record in ascending order to have it write
  its encoding into the file in the given format.  It then recursively calls
  the next run record.

******************************************************************************/

void    CRunRecord::WriteEncodings(CFile& cfTarget, WORD wfHow) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteEncoding(cfTarget, wfHow);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteEncodings(cfTarget, wfHow);
}

/******************************************************************************

  CCodePageData class implementation

******************************************************************************/

/******************************************************************************

  CCodePageData::Invocation

  This member function returns (in C-style string declaration form) the data to
  send to the printer to perform the requested select/deselect of this code
  page.

******************************************************************************/

void    CCodePageData::Invocation(CString& csReturn, BOOL bSelect) const {
    if  (bSelect)
        m_ciSelect.GetInvocation(csReturn);
    else
        m_ciDeselect.GetInvocation(csReturn);
}

/******************************************************************************

  CCodePageData::SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect)

  This member function sets the select or deselect sring using a string which
  is decoded as a C-style string declaration.

******************************************************************************/

void    CCodePageData::SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect) {

    if  (bSelect)
        m_ciSelect.SetInvocation(lpstrInvoke);
    else
        m_ciDeselect.SetInvocation(lpstrInvoke);
}

/******************************************************************************

  CCodePageData::SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect)

  This member function initializes one of the two CInvocation members via its
  Init function.

******************************************************************************/

void    CCodePageData::SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect) {
    if  (bSelect)
        m_ciSelect.Init(pb, ucb);
    else
        m_ciDeselect.Init(pb, ucb);
}

/******************************************************************************

  CCodePageData::NoteOffsets

  This member function is passed an offset at which it will record its
  invocation strings.  It simply funnels the call to each invocation member,
  which updates the value as appropriate.

******************************************************************************/

void    CCodePageData::NoteOffsets(DWORD& dwOffset) {
    m_ciSelect.NoteOffset(dwOffset);
    m_ciDeselect.NoteOffset(dwOffset);
}

//  Write the id and invocation location information to the file

void    CCodePageData::WriteSelf(CFile& cfTarget) {
    cfTarget.Write(&m_dwid, sizeof m_dwid);
    m_ciSelect.WriteSelf(cfTarget);
    m_ciDeselect.WriteSelf(cfTarget);
}

//  Write the invocation strings to a file.

void    CCodePageData::WriteInvocation(CFile& cfTarget) {
    m_ciSelect.WriteEncoding(cfTarget);
    m_ciDeselect.WriteEncoding(cfTarget);
}

/******************************************************************************

  CGlyphMap class implementation

******************************************************************************/

IMPLEMENT_SERIAL(CGlyphMap, CProjectNode, 0)

//  The GTT header

struct sGTTHeader {
    DWORD   m_dwcbImage;
    enum    {Version1Point0 = 0x10000};
    DWORD   m_dwVersion;
    DWORD   m_dwfControl;   //  Any flags defined?
    long    m_lidPredefined;
    DWORD   m_dwcGlyphs;
    DWORD   m_dwcRuns;
    DWORD   m_dwofRuns;
    DWORD   m_dwcCodePages;
    DWORD   m_dwofCodePages;
    DWORD   m_dwofMapTable;
    DWORD   m_dwReserved[2];
    sGTTHeader() {
        memset(this, 0, sizeof *this);
        m_dwVersion = Version1Point0;
        m_lidPredefined = CGlyphMap::NoPredefined;
        m_dwcbImage = sizeof *this;
    }
};

CSafeMapWordToOb    CGlyphMap::m_csmw2oPredefined;

/******************************************************************************

  CGlyphMap::Public

  This is a static member function which will return a pointer to one of the
  predefined GTT files, after loading it if necessary.

******************************************************************************/

CGlyphMap* CGlyphMap::Public(WORD wID, WORD wCP/*= 0*/, DWORD dwDefCP/*= 0*/,
							 WORD wFirst/*= 0*/, WORD wLast/*= 255*/)
{
	//TRACE("***  First char = %d\t\tLast char = %d\n", wFirst, wLast) ;
	
	// If a GTT in this driver is needed, return NULL to force the
	// program to go get it.

	if (((short) wID) > 0)
		return NULL ;

	// If no GTT ID is set, use the code page that is passed in.  If no code
	// page is passed in, use the project's default code page.  If there is
	// no project, use 1252 as the default code page.

	if (wID == 0)
		if ((wID = wCP) == 0)
			if ((wID = (WORD) dwDefCP) == 0)
				wID = 1252 ;

	// Check to see if wID is set to one of the Far East codepages that are 
	// built into the MDT.  If that is the case, change it to the resource ID
	// for that code page.

	switch (wID) {
		case 932:
			wID = -17 ;
			break ;
		case 936:
			wID = -16 ;
			break ;
		case 949:
			wID = -18 ;
			break ;
		case 950:
			wID = -10 ;
			break ;
	} ;

	// If the ID is 1252, switch to the resource ID for CP 1252.

	if (wID == 1252)
		wID = -IDR_CP1252 ;

    // The easy part comes if it is already loaded

    CObject*    pco ;
    if  (m_csmw2oPredefined.Lookup(wID, pco))
        return  (CGlyphMap*) pco ;

    //// DEAD_BUG - The program can't load huge GTTs so just return NULL.
    //
    //if ((short) wID >= -18 || (short) wID <= -10)
    //    return NULL ;

    // Manage loading a predefined code page or building a GTT based on a code
	// page.  Begin by declaring/initializing a class instance for it.

    CGlyphMap *pcgm = new CGlyphMap ;
	TCHAR acbuf[32] ;
    if (FindResource(AfxGetResourceHandle(),
					 MAKEINTRESOURCE((((short) wID) < 0) ? -(short) wID : wID),
					 MAKEINTRESOURCE(IDR_GLYPHMAP)))
		pcgm->m_csName.LoadString(IDS_DefaultPage + wID) ;
	else {
		strcpy(acbuf, _T("CP ")) ;
		_itoa(wID, &acbuf[3], 10) ;
		pcgm->m_csName = acbuf ;
	} ;
    pcgm->nSetRCID((int) wID) ;
	pcgm->m_wFirstChar = wFirst ;
	pcgm->m_wLastChar = wLast ;
	pcgm->m_bResBldGTT = true ;

	// Load/build the GTT.  If this works, add it to the list of "predefined"
	// GTTs and return a pointer to it.

    if  (pcgm->Load()) {
        m_csmw2oPredefined[wID] = pcgm ;
        return pcgm ;
    } ;

	// Clean up and return NULL if the load/build fails.

    delete pcgm ;
    return NULL ;
}

/******************************************************************************

  CGlyphMap::MergePredefined

  This merges in fresh glyph handles from the predefined GTT, then removes all
  glyphs destined for the gallows.

******************************************************************************/

void    CGlyphMap::MergePredefined() {
    if  (m_lidPredefined == NoPredefined)
        return;

    CWaitCursor cwc;    //  This takes a long time, I'll bet!

    CGlyphMap   *pcgm = Public((WORD) m_lidPredefined);

    if  (!pcgm)
        AfxThrowNotSupportedException();

    //  First, add any new code pages in the predefined GTT
    CMapWordToDWord cmw2dPageMap;   //  Map PDT code pages' indices to our own

    for (unsigned u = 0; u < pcgm -> CodePages(); u++) {
        for (unsigned u2 = 0; u2 < CodePages(); u2++)
            if  (PageID(u2) == pcgm -> PageID(u))
                break;

            if  (u2 == CodePages())
                AddCodePage(pcgm -> PageID(u));

            cmw2dPageMap[(WORD)u] = u2;
    }

    CPtrArray   cpaTemplate;
    pcgm -> Collect(cpaTemplate);

    for (int i = 0; i < cpaTemplate.GetSize(); i++) {
        CGlyphHandle&   cghTemplate = *(CGlyphHandle *) cpaTemplate[i];
        CObject*    pco;

        if  (!m_csmw2oEncodings.Lookup(cghTemplate.CodePoint(), pco)) {
            //  Add this one, and map the code page info.
            CGlyphHandle*   pcgh = new CGlyphHandle;
            if  (!pcgh)
                AfxThrowMemoryException();

            *pcgh = cghTemplate;
            pcgh -> SetCodePage(cmw2dPageMap[(WORD)cghTemplate.CodePage()],
                pcgm -> PageID(cghTemplate.CodePage()));

            m_csmw2oEncodings[cghTemplate.CodePoint()] = pcgh;
            m_crr.Add(pcgh);
        }
    }

    //  Now, all of the new pages have been added.  We must remove all points
    //  listed as "Remove".

    Collect(cpaTemplate);   //  Get all of the handles for ourselves

    for (i = (int)cpaTemplate.GetSize(); i--; ) {
        CGlyphHandle&   cgh = *(CGlyphHandle *) cpaTemplate[i];

        if  (cgh.Predefined() == CGlyphHandle::Removed)
            DeleteGlyph(cgh.CodePoint());
    }
}

/******************************************************************************

  CGlyphMap::UnmergePredefined

  This is the harder of the two predfined handlers, if that is conceivable.
  First (unless asked not to), glkyphs must be added to mark those missing from
  the predefined GTT.

  Then, the entire set is compared to the PDT, so they can be removed as
  equivalent, or flagged as added or modified.

******************************************************************************/

void    CGlyphMap::UnmergePredefined(BOOL bTrackRemovals) {
    if  (m_lidPredefined == NoPredefined)
        return;

    CWaitCursor cwc;    //  This takes a long time, I'll bet!

    CGlyphMap   *pcgm = Public((WORD) m_lidPredefined);

    if  (!pcgm)
        AfxThrowNotSupportedException();

    CPtrArray   cpaPDT;

    if  (bTrackRemovals) {
        pcgm -> Collect(cpaPDT);

        for (int i = 0; i < cpaPDT.GetSize(); i++) {
            CGlyphHandle&   cgh = *(CGlyphHandle*) cpaPDT[i];

            CObject*    pco;

            if  (m_csmw2oEncodings.Lookup(cgh.CodePoint(), pco))
                continue;

            //  This point was removed from the predefined set, so add it to
            //  ours, and mark it as such.

            CGlyphHandle    *pcghCorpse = new CGlyphHandle();

            if  (!pcghCorpse)
                AfxThrowMemoryException();

            *pcghCorpse = cgh;

            pcghCorpse -> SetPredefined(CGlyphHandle::Removed);

            m_csmw2oEncodings[cgh.CodePoint()] = pcghCorpse;
            m_crr.Add(pcghCorpse);
        }
    }

    //  Mark all of the glyphs in our set, now.  Also mark the code pages used

    Collect(cpaPDT);

    CMapWordToDWord cmw2dPages;

    for (int i = (int)cpaPDT.GetSize(); i--; ) {
        CGlyphHandle&   cgh = *(CGlyphHandle*) cpaPDT[i];

        union {
            CObject         *pco;
            CGlyphHandle    *pcgh;
        };

        if  (pcgm -> m_csmw2oEncodings.Lookup(cgh.CodePoint(), pco))
            if  (*pcgh == cgh) {
                if  (cgh.Predefined() == CGlyphHandle::Removed)
                    continue;   //  Already accounted for

                if  (m_bPaired != pcgm -> m_bPaired && cgh.PairedRelevant())
                    cgh.SetPredefined(CGlyphHandle::Modified);
                else {
                    DeleteGlyph(cgh.CodePoint());    //  Unmodified
                    continue;
                }
            }
            else
                cgh.SetPredefined(CGlyphHandle::Modified);
        else
            cgh.SetPredefined(CGlyphHandle::Added);

        cmw2dPages[(WORD)PageID(cgh.CodePage())]++;   //  Only track these pages
    }

    //  Remove the unused code pages, unless they have selections

    for (unsigned u = CodePages(); u--; )
        if  (!cmw2dPages[(WORD)PageID(u)])
            if  (CodePage(u).NoInvocation())
                RemovePage(u, !u);
}

/******************************************************************************

  CGlyphMap::GenerateRuns

  This member will create the run records by iterating over the mapped glyph
  handles.

******************************************************************************/

void    CGlyphMap::GenerateRuns() {
    if  (m_crr.TotalGlyphs() == Glyphs())
        return;

    for (POSITION pos = m_csmw2oEncodings.GetStartPosition(); pos;) {
        WORD    wValue;
        union {
            CObject     *pco;
            CGlyphHandle    *pcgh;
        };

        m_csmw2oEncodings.GetNextAssoc(pos, wValue, pco);
        m_crr.Add(pcgh);
    }
}

/******************************************************************************

  CGlyphMap::Serialize

  This member function serializes the Glyph map, i.e., loads or stores it into
  a persistent object store.  Only the project-level information is stored.

  The file will be loaded using the project-level data.

  Note:	There was a second copy of the GTT's RC ID saved in the MDW file.
		Because it could get out of sync with the one in the CGlyphMap's
		CRCIDNode instance, the copy of the ID read/written by this routine
		is no longer used.  A bogus value is written and the number read is
		discarded.  This "ID" is still kept in the MDW file so that no new MDW
		version is needed.

******************************************************************************/

void    CGlyphMap::Serialize(CArchive& car) 
{
	WORD	w = (WORD)0;		// Used to read/write bogus RC ID in MDW file.

    CProjectNode::Serialize(car) ;

    if  (car.IsLoading()) {
        car >> w ;
    }
    else {
        car << w ;
    }
}

/******************************************************************************

  CGlyphMap::CGlyphMap

  The class constructor, in addition to setting some default values, builds an
  array of IDs for the CProjectNode class from which it is derived to use in
  building the context menu in the driver/project view tree.

  It also allocates a single code page record for the current ANSI page, so we
  always have a default page.

******************************************************************************/

CGlyphMap::CGlyphMap() {
    m_cfn.SetExtension(_T(".GTT"));
    m_bPaired = FALSE;
    m_lidPredefined = NoPredefined;

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_CopyItem);
    m_cwaMenuID.Add(ID_RenameItem);
    m_cwaMenuID.Add(ID_DeleteItem);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    //m_cwaMenuID.Add(0);
    //m_cwaMenuID.Add(ID_GenerateOne);

    //  Initialy, let the default code page be the current ANSI page, if this
    //  is not a DBCS locale.  Otherwise, use 1252, as no DBCS CTT file can be
    //  generated with UniTool
    for (WORD w = 0; w < 256; w++)
        if  (IsDBCSLeadByte((BYTE) w))
            break;
    m_csoaCodePage.Add(new CCodePageData(w < 256 ? 1252 : GetACP()));

    // Allocate a CCodePageInformation class if needed.

    if (pccpi == NULL)
        pccpi = new CCodePageInformation ;

	// Assume that the GTT's data should be read from a file.

	m_bResBldGTT = false ;

	m_ctSaveTimeStamp = (time_t) 0 ;	// The GTT has not been saved
}

/******************************************************************************

  CGlyphMap::CodePages(CDWordArray &cdaReturn)

  This overload fills a DWordArray with the code page IDs.

******************************************************************************/

void    CGlyphMap::CodePages(CDWordArray &cdaReturn) const {
    cdaReturn.RemoveAll();
    for (unsigned u = 0; u < CodePages(); u++)
        cdaReturn.Add(CodePage(u).Page());
}

/******************************************************************************

  CGlyphMap::PageName


  This member returns the name of a particular code page, by index.

******************************************************************************/

CString CGlyphMap::PageName(unsigned u) const {
    return  pccpi->Name(CodePage(u).Page());
}

/******************************************************************************

  CGlyphMap::Invocation

  This member returns (in C-style encoding) a string which is used to either
  select or deselect a given code page.

******************************************************************************/

void    CGlyphMap::Invocation(unsigned u, CString& csReturn,
                              BOOL bSelect) const {
    CodePage(u).Invocation(csReturn, bSelect);
}

/******************************************************************************

  CGlyphMap::UndefinedPoints

  This member fills a map with all code points NOT in the current mapping, and
  maps them to their related code pages.  Thus only translatable points will be
  passed back to the caller.

******************************************************************************/

void    CGlyphMap::UndefinedPoints(CMapWordToDWord& cmw2dCollector) const {

    cmw2dCollector.RemoveAll();

    CWaitCursor cwc;

    for (unsigned u = 0; u < CodePages(); u++) {
        CWordArray  cwaPage;

        //  Collect the code points in the code page

        pccpi->Collect(PageID(u), cwaPage);
        union {
            CObject *pco;
            DWORD   dw;
        };

        //  Check the entries- if they haven't been mapped yet, and
        //  some earlier code page hasn't claimed them, add them.

        for (int i = 0; i < cwaPage.GetSize(); i++)
            if  (!m_csmw2oEncodings.Lookup(cwaPage[i], pco) &&
                 !cmw2dCollector.Lookup(cwaPage[i], dw))
                 cmw2dCollector[cwaPage[i]] = u;
    }
}

/******************************************************************************

  CGlyphMap::Load(CByteArray& cbaMap)

  This loads an image of a GTT into safe memory, whether it is predefined or
  a file.

******************************************************************************/

//void    CGlyphMap::Load(CByteArray& cbaMap) const 
void    CGlyphMap::Load(CByteArray& cbaMap)
{
	short	xxx = (short) ((CProjectNode*) this)->nGetRCID() ;	// The GTT's RC ID
	short	sid = (short) nGetRCID() ;	// The GTT's RC ID

    try {
		// Try to load the GTT from a file when the GTT should not be loaded
		// from a resource or built.

        if  (!m_bResBldGTT 
		 && (sid > 0 || (sid < Wansung && sid != -IDR_CP1252))) {
            CFile   cfGTT(m_cfn.FullName(),
            CFile::modeRead | CFile::shareDenyWrite);

            cbaMap.SetSize(cfGTT.GetLength());
            cfGTT.Read(cbaMap.GetData(), (unsigned)cbaMap.GetSize());
            return;
        } ;

		// If the GTT is a resource, load it from there.
// raid 441362
		if(MAKEINTRESOURCE((sid < 0) ? -sid : sid) == NULL)
			return;

        HRSRC hrsrc = FindResource(AfxGetResourceHandle(),
            MAKEINTRESOURCE((sid < 0) ? -sid : sid),
            MAKEINTRESOURCE(IDR_GLYPHMAP));
        if  (hrsrc) {
			HGLOBAL hg = LoadResource(AfxGetResourceHandle(), hrsrc) ;
			if  (!hg)
				return ;
			LPVOID  lpv = LockResource(hg) ;
			if  (!lpv)
				return ;
			cbaMap.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc)) ;
			memcpy(cbaMap.GetData(), lpv, (size_t)cbaMap.GetSize()) ;
			return ;
		} ;

		//AfxMessageBox("GTT building code reached.") ;

		// If all else fails, try to generate a GTT based on the code page ID
		// that should be in m_wID if this point is reached.

        HANDLE   hheap ;
        UNI_GLYPHSETDATA *pGTT ;
        if (!(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024))) {
			AfxMessageBox(IDS_HeapInGLoad) ;
			return ;
		} ;
		pGTT = PGetDefaultGlyphset(hheap, m_wFirstChar, m_wLastChar,
								   (DWORD) sid) ;
		if (pGTT == NULL) {
			HeapDestroy(hheap) ;		//raid 116600 Prefix
			AfxMessageBox(IDS_PGetFailedInGLoad) ;
			return ;
		} ;
		cbaMap.SetSize(pGTT->dwSize) ;
		memcpy(cbaMap.GetData(), pGTT, (size_t)cbaMap.GetSize()) ;
		HeapDestroy(hheap) ;
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, Name());
        AfxMessageBox(csMessage);
    }
}

/******************************************************************************

  CGlyphmap::SetSourceName

  This takes and stores the source file name so we can load and convert later.
  It also renames (or rather, sets the original name) for the GlyphMap using
  the base file name.

******************************************************************************/

void    CGlyphMap::SetSourceName(LPCTSTR lpstrNew) {
    m_csSource = lpstrNew;

    m_csName = m_csSource.Mid(m_csSource.ReverseFind(_T('\\')) + 1);

    if  (m_csName.Find(_T('.')) >= 0)
        if  (m_csName.Right(4).CompareNoCase(_T(".CTT"))) {
            m_csName.SetAt(m_csName.Find(_T('.')), _T('_'));
            CProjectNode::Rename(m_csName);
        }
        else
            CProjectNode::Rename(m_csName.Left(m_csName.Find(_T('.'))));
    else
        CProjectNode::Rename(m_csName);
}


/******************************************************************************

  CGlyphMap::SetFileName

  This sets the new file name.  It is done differently than in SetSourceName()
  because the base file name must not be more than 8 characters long.  (The
  extra info is left in the node name by SetSourceName() because it is useful
  there and it has no length limit.)

******************************************************************************/

BOOL CGlyphMap::SetFileName(LPCTSTR lpstrNew)
{
    CString        csnew ;            // CString version of input parameter

    csnew = lpstrNew ;

    // If the input filespec contains an extension, remove it and pass the
    // resulting string to the file node's rename routine.  Otherwise, just
    // pass the original string to the rename routine.
    //
    // This check is complicated by the fact that one of the path components
    // might have a dot in it too.  We need to check for the last dot and make
    // sure it comes before a path separator.

    if  (csnew.ReverseFind(_T('.')) > csnew.ReverseFind(_T('\\')))
        return m_cfn.Rename(csnew.Left(csnew.ReverseFind(_T('.')))) ;
    else
        return m_cfn.Rename(csnew) ;
}


/******************************************************************************

  CGlyphMap::AddPoints

  This member adds one or more code points to the glyph map using the given
  list of points and associated pages.

******************************************************************************/

void    CGlyphMap::AddPoints(CMapWordToDWord& cmw2dNew) {
    WORD        wKey;
    DWORD       dwixPage;
    CWaitCursor cwc;        //  This could be slow!

    for (POSITION pos = cmw2dNew.GetStartPosition(); pos; ) {
        cmw2dNew.GetNextAssoc(pos, wKey, dwixPage);

        //  Get the MBCS encoding of the Unicode point as the initial
        //  glyph encoding.

        CWordArray  cwaIn;
        CByteArray  cbaOut;

        cwaIn.Add(wKey);
        pccpi->Convert(cbaOut, cwaIn, CodePage(dwixPage).Page());

        //  Create the glyph and add it to the map

        CGlyphHandle    *pcgh = new CGlyphHandle;

        pcgh -> Init(cbaOut.GetData(), (unsigned) cbaOut.GetSize(), (WORD)Glyphs(),
            wKey);
        pcgh -> SetCodePage(dwixPage, CodePage(dwixPage).Page());
        m_csmw2oEncodings[wKey] = pcgh;
        m_crr.Add(pcgh);
    }
    Changed();  //  Don't forget to tell the container!
}

/******************************************************************************

  CGlyphMap::DeleteGlyph

  This member function removes a glyph from the map.  The most tricky part is
  updating the run records, but that's not this class' responsibility, is it?

******************************************************************************/

void    CGlyphMap::DeleteGlyph(WORD wCodePoint) {
    if  (!m_csmw2oEncodings.RemoveKey(wCodePoint))
        return;     //  This glyph is already toast!

    m_crr.Delete(wCodePoint);
    Changed();
}

/******************************************************************************

  CGlyphMap::RemovePage

  This member function removes a code page from the list of available pages.
  Glyphs that used this page will be remapped to a second specified page.

******************************************************************************/

BOOL    CGlyphMap::RemovePage(unsigned uPage, unsigned uMapTo, bool bDelete /* bDelete = FALSE */) {

     if  (uPage >= CodePages() || uMapTo >= CodePages())
        return  FALSE;

    //  Pretty simple- walk the map- first replace any instances, then
    //  decrement any indices higher than uPage

    WORD    wKey;

    union {
        CObject*        pco;
        CGlyphHandle*   pcgh;
    };

    for (POSITION pos = m_csmw2oEncodings.GetStartPosition(); pos; ) {

        m_csmw2oEncodings.GetNextAssoc(pos, wKey, pco);
		if (!bDelete){	 
			if  (pcgh -> CodePage() == uPage)
				pcgh -> SetCodePage(uMapTo, CodePage(uMapTo).Page());
			if  (pcgh -> CodePage() > uPage)
				pcgh -> SetCodePage(pcgh -> CodePage() - 1,
					CodePage(pcgh -> CodePage()).Page());
		}	
		else {   // raid 118880
		if (pcgh -> CodePage() == uPage)
			DeleteGlyph(pcgh -> CodePoint() ) ;  // delete m_csm2oEncodings, RunRecord
		    
		else if (pcgh -> CodePage() > uPage)
            pcgh -> SetCodePage(pcgh -> CodePage() - 1,
                CodePage(pcgh -> CodePage()).Page());
		}

    }

    m_csoaCodePage.RemoveAt(uPage);

	// Marke the GTT as dirty and then return success.
	Changed();
    return  TRUE;
}

/******************************************************************************

  CGlyphMap::ChangeCodePage

  This member function changes the code page for one ore more glyphs to a
  different page.  At one time I thought remapping the code points would be
  required, but currently, the Unicode stays intact.  That seems a good feature
  for demand-driven implementation.

******************************************************************************/

//  This one changes the code page for one or more glyphs.
//  For now, we will simply keep the Unicode intact.  Eventually, a query
//  should be made about the intent, so we can remap through the existing
//  page, if that is what is desired.

void    CGlyphMap::ChangeCodePage(CPtrArray& cpaGlyphs, DWORD dwidNewPage) {
    for (unsigned u = 0; u < CodePages(); u++)
        if  (dwidNewPage == CodePage(u).Page())
            break;

    _ASSERTE(u < CodePages());

    if  (u >= CodePages())
        return;

    for (int i = 0; i < cpaGlyphs.GetSize(); i++)
        ((CGlyphHandle *) cpaGlyphs[i]) -> SetCodePage(u, dwidNewPage);

    Changed();
}

/******************************************************************************

  CGlyphMap::AddCodePage

  This member function adds a new code page to the list of pages used in this
  table.

******************************************************************************/

void    CGlyphMap::AddCodePage(DWORD dwidNewPage) {
    m_csoaCodePage.Add(new CCodePageData(dwidNewPage));
    Changed();
}

/******************************************************************************

  CGlyphMap::SetPredefinedID

  This changes the predefined table used by the map.  If it really is a change,
  we must remove all non-modified points from any existing map, and then flesh
  out using the new one.

******************************************************************************/

void    CGlyphMap::UsePredefined(long lidNew) {
    if  (m_lidPredefined == lidNew)
        return; //  Didn't need to do this!

    if  (m_lidPredefined != NoPredefined)
        UnmergePredefined(lidNew != NoPredefined);

    m_lidPredefined = lidNew;

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    Changed();
}

/******************************************************************************

  CGlyphMap::SetInvocation

  This member changes the invocation string for selecting or unselecting a
  given code page.

******************************************************************************/

void    CGlyphMap::SetInvocation(unsigned u, LPCTSTR lpstrInvoke,
                                 BOOL bSelect) {
    CodePage(u).SetInvocation(lpstrInvoke, bSelect);
    Changed();
}

/******************************************************************************

  CGlyphMap::ChangeEncoding

  This member is called when the user changes the encoding string used to
  invoke a given code point.  This could be done via the glyph, but then the
  containing document won't know of the change, and thus the change could be
  inadvertently lost...

******************************************************************************/

void    CGlyphMap::ChangeEncoding(WORD wCodePoint, LPCTSTR lpstrNewInvoke) {

    union {
        CObject         *pco;
        CGlyphHandle    *pcgh;
    };

    if  (!m_csmw2oEncodings.Lookup(wCodePoint, pco) || !lpstrNewInvoke||
            !*lpstrNewInvoke)
        return;

    pcgh -> NewEncoding(lpstrNewInvoke);

    Changed();
}

/******************************************************************************

  CGlyphMap::ConvertCTT()

  This member fuction initializes the glyphmap structure from a CTT file

******************************************************************************/

int     CGlyphMap::ConvertCTT() {

    struct sCTT {
        enum {Composed, Direct, Paired};
        WORD    m_wFormat;
        BYTE    m_bFirstChar, m_bLastChar;
        union   {
            uencCTT m_uectt[1];
            BYTE    m_bDirect[1];
        };
    };

    //  If this map isn't empty, empty it now- at least of the glyph data

    m_csmw2oEncodings.RemoveAll();
    m_crr.Empty();

    CByteArray  cbaImage;

    try {

        CFile   cfCTT(m_csSource, CFile::modeRead | CFile::shareDenyWrite);

        cbaImage.SetSize(cfCTT.GetLength());

        cfCTT.Read(cbaImage.GetData(), cfCTT.GetLength());
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  IDS_FileReadError ;
    }

#if 0
    union {
        PBYTE   pbCTT;
        sCTT*   psctt;
    };

    pbCTT = cbaImage.GetData();
    BYTE    bFirst = min(0x20, psctt -> m_bFirstChar),
            bLast = 0xFF;   //  Since we use a byte this is the max!
    unsigned ucGlyphs = 1 + bLast - bFirst;


    //  Convert the code points to Unicode
    CByteArray  cbaCode;
    CWordArray  cwaCode;

    for (unsigned u = 0; u < ucGlyphs; u++)
        cbaCode.Add(u + bFirst);

    //  Convert the data to Unicode using the selected code page.  This uses
    //  data stored from MultiByteToWideChar, so it is similar, except we can
    //  do this with code pages which might not be installed on the user's
    //  system.

    if  (ucGlyphs != pccpi->Convert(cbaCode, cwaCode, CodePage(0).Page())) {
        CString csWork;
        csWork.Format(IDS_NoUnicodePoint, u + bFirst, CodePage(0).Page());
        AfxMessageBox(csWork);
        return  IDS_UnicodeConvFailed ;
    }

    //  Since we add phony glyphs to the table (why, one wonders), we must mark
    //  them so we can manufacture equally phony encodings for them.
    for (u = 0; u < ucGlyphs; u++) {

        //  Now, let's record the Encoding

        CGlyphHandle  *pcghNew = new CGlyphHandle;
        unsigned uToUse = u + bFirst - psctt -> m_bFirstChar;

        switch  (psctt -> m_wFormat) {

            case    sCTT::Direct:
                if  (u + bFirst < psctt -> m_bFirstChar)
                    pcghNew -> Init((BYTE) u + bFirst, u,cwaCode[u]);
                else
                    pcghNew -> Init(psctt -> m_bDirect[uToUse], u, cwaCode[u]);
                break;

            case    sCTT::Paired:
                if  (u + bFirst < psctt -> m_bFirstChar)
                    pcghNew -> Init((BYTE) u + bFirst, u, cwaCode[u]);
                else
                    if  (psctt -> m_uectt[uToUse].abPaired[1])
                        pcghNew -> Init(psctt -> m_uectt[uToUse].abPaired, u,
                            cwaCode[u]);
                    else
                        pcghNew -> Init(psctt -> m_uectt[uToUse].abPaired[0],
                            u, cwaCode[u]);
                break;

            case    sCTT::Composed:
                if  (u + bFirst < psctt -> m_bFirstChar) {
                    BYTE    bMe = u + bFirst;
                    pcghNew -> Init(&bMe, 1, u, cwaCode[u]);
                }
                else
                    pcghNew -> Init(pbCTT + psctt -> m_uectt[uToUse].wOffset,
                        psctt -> m_uectt[uToUse + 1].wOffset -
                        psctt -> m_uectt[uToUse].wOffset, u, cwaCode[u]);
                break;

            default:    //  Don't accept anything else!
                AfxMessageBox(IDS_InvalidCTTFormat);
                return  IDS_Invalid2CTTFormat ;
        }   //  One map entry coded

        //  Code page index inits OK, but must know the page

        pcghNew -> SetCodePage(0, DefaultCodePage());

        m_csmw2oEncodings[cwaCode[u]] = pcghNew;
        m_crr.Add(pcghNew);
    }   //  Loop of generating entries

    m_bPaired = sCTT::Paired == psctt -> m_wFormat;
#else
    {
        HANDLE   hheap;
        PBYTE   pbCTT;
        UNI_GLYPHSETDATA *pGTT;

        pbCTT = cbaImage.GetData();
        if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )))
        {
            char acMessage[256];
            wsprintf(acMessage, "HeapCreate() fails in ctt2gtt" );
            MessageBox(NULL, acMessage, NULL, MB_OK);
            return  IDS_HeapCFailed ;
        }
									
        //if (!BConvertCTT2GTT(hheap, (PTRANSTAB)pbCTT, DefaultCodePage(), 0x20,
		ASSERT(m_pcdOwner != NULL) ;
		DWORD dw = ((CProjectRecord*) m_pcdOwner)->GetDefaultCodePageNum() ;
        if (!BConvertCTT2GTT(hheap, (PTRANSTAB)pbCTT, dw, 0x20, 0xff, NULL, 
			NULL, &pGTT, 0)){
			HeapDestroy(hheap);   // raid 116619 prefix
            return IDS_ConvCTTFailed ;
		}
		try {
			CFile   cfGTT;
			if  (!cfGTT.Open(m_cfn.FullName(), CFile::modeCreate | CFile::modeWrite |
				CFile::shareExclusive))
				return  IDS_FileWriteError;
			cfGTT.Write(pGTT, pGTT->dwSize);
		}

		catch   (CException *pce) {
			pce -> ReportError();
			pce -> Delete();
			HeapDestroy(hheap);
			return  IDS_FileWriteError ;
		}

        HeapDestroy(hheap);
    }

    Load();

#endif

    return  0 ;
}

/******************************************************************************

  CGlyphMap::Load()

  This initializes the glyphmap from a GTT format file.  Since this is the
  primary means of loading, it requires no parameters.

******************************************************************************/

BOOL    CGlyphMap::Load(LPCTSTR lpstrName /*= NULL*/) {

    //  Note the correct name and path- the rename checks may fail, since the
    //  file is opened elsewhere (possibly with sharing conflicts), so disable
    //  them, for now.  This code is a little sleazy- but the only time the
    //  file name isn't null is if the file's being opened.

    if  (FileTitle().IsEmpty() && lpstrName) {
        m_cfn.EnableCreationCheck(FALSE);
        SetFileName(lpstrName);
        m_cfn.EnableCreationCheck();
    }

    if  (Glyphs()) { //  If we already have them, we're already loaded!
        m_csoaCodePage.RemoveAll(); //  Clean it all up, and reload.
        m_csmw2oEncodings.RemoveAll();
        m_crr.Empty();
    }

    CByteArray  cbaGTT;

    union   {
        PBYTE   pbGTT;
        sGTTHeader  *psgtth;
    };

    Load(cbaGTT);   //  If this fails, it will post a reason why

    if  (!cbaGTT.GetSize())
        return  FALSE;

    pbGTT = cbaGTT.GetData();

    sMapTable*  psmt = (sMapTable *) (pbGTT + psgtth -> m_dwofMapTable);
    sMapTableEntry* psmte = (sMapTableEntry *)(psmt + 1);

    //  Before we go any further, let's do some validation

    if  (psgtth -> m_dwVersion != sGTTHeader::Version1Point0)
        return  FALSE;

    m_bPaired = FALSE;

    //  First, let's snarf up the code page info

    struct sInvocation {
        DWORD   m_dwSize, m_dwOffset;
    };

    struct sCodePageInfo {
        DWORD   m_dwPage;
        sInvocation m_siSelect, m_siDeselect;
    }   *psci = (sCodePageInfo *)(pbGTT + psgtth -> m_dwofCodePages);

    m_csoaCodePage.RemoveAll();

    for (unsigned u = 0; u < psgtth -> m_dwcCodePages; u++, psci++) {
        m_csoaCodePage.Add(new CCodePageData(psci -> m_dwPage));
        if  (!psci -> m_siSelect.m_dwSize != !psci -> m_siSelect.m_dwOffset ||
             !psci -> m_siDeselect.m_dwSize !=
             !psci -> m_siDeselect.m_dwOffset)
            return  FALSE;  //  The data is bogus!

        CodePage(u).SetInvocation(((PBYTE) psci) + psci->m_siSelect.m_dwOffset,
            psci -> m_siSelect.m_dwSize, TRUE);
        CodePage(u).SetInvocation(((PBYTE) psci) + psci->m_siDeselect.m_dwOffset,
            psci -> m_siDeselect.m_dwSize, FALSE);
        //CodePage(u).SetInvocation(pbGTT + psci -> m_siSelect.m_dwOffset,
        //    psci -> m_siSelect.m_dwSize, TRUE);
        //CodePage(u).SetInvocation(pbGTT + psci -> m_siDeselect.m_dwOffset,
        //    psci -> m_siDeselect.m_dwSize, FALSE);
    }

    //  Next, we need to walk the glyph run tables to decipher and use the map
    //  table.

    struct sGlyphRun {
        WORD    m_wFirst, m_wc;
    }   *psgr = (sGlyphRun *)(pbGTT + psgtth -> m_dwofRuns);

    _ASSERTE(psgtth -> m_dwcGlyphs == psmt -> m_dwcEntries);

    WORD    wIndex = 0;

	/*** Changes have been made so that the following code is unneeded.
	 	 The MDT can load predefined GTTs now.  In addition, skipping
		 the complete loading of these GTTs causes some problems with
		 UFM width table loading.  The cumulative count of entries in
		 the glyph run tables is used to determine the maximum size of
		 the UFMs width table.  The data in the run tables is also used
		 to verify width table entries.

		// Don't do the rest if a predefined GTT is being loaded.  The code below
		// can blow on large GTTs; eg, the DBCS ones.  It may be better to find out
		// why the code blows but this seems to work for now.

		if ((short) m_wID >= CGlyphMap::Wansung
		 && (short) m_wID <= CGlyphMap::CodePage437)
			return TRUE ;
	*/

    for (unsigned uRun = 0; uRun < psgtth -> m_dwcRuns; uRun++, psgr++)
        for (u = 0; u < psgr -> m_wc; u++, psmte++, wIndex++) {
            CGlyphHandle*   pcgh = new CGlyphHandle;

            switch  (psmte -> m_bfType & sMapTableEntry::Format) {
                case    sMapTableEntry::Direct:

                    pcgh -> Init((PBYTE) &psmte -> m_uectt, 1, wIndex,
                        psgr -> m_wFirst + u);
                    break;

                case    sMapTableEntry::Paired:

                    pcgh -> Init(psmte -> m_uectt.abPaired, wIndex,
                        psgr -> m_wFirst + u);

                    if  (!(psmte -> m_bfType & sMapTableEntry::DBCS))
                        m_bPaired = TRUE;

                    break;

                case    sMapTableEntry::Composed:

                    pcgh -> Init(pbGTT + psgtth -> m_dwofMapTable +
                        psmte -> m_uectt.wOffset + sizeof wIndex,
                        *(PWORD) (pbGTT + psgtth -> m_dwofMapTable +
                        psmte -> m_uectt.wOffset), wIndex,
                        psgr -> m_wFirst + u);
                    break;

                default:    //  Bad news- bad format
                    delete  pcgh;   //  No orphans needed!
                    return  FALSE;
            }

            //  Don't forget the code page ID!

            pcgh -> SetCodePage(psmte -> m_bCodePageIndex,
                CodePage(psmte -> m_bCodePageIndex).Page());

            //  Mark this if it is to be disabled.

            if  (psmte -> m_bfType & sMapTableEntry::Disable)
                pcgh -> SetPredefined(CGlyphHandle::Removed);

            m_csmw2oEncodings[psgr -> m_wFirst + u] = pcgh;
            m_crr.Add(pcgh);
        }

    //  If we're predefined, Merge now.

    m_lidPredefined = psgtth -> m_lidPredefined;

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    return  TRUE;   //  We actually did it!
}

/******************************************************************************

  CGlyphMap::RLE

  This generates an RLE-format file image of the glyph map.

******************************************************************************/

BOOL    CGlyphMap::RLE(CFile& cfTarget) {

    sRLE    srle;

    srle.m_widRLE = 0x78FE;
    srle.m_wcFirst = m_crr.First();
    srle.m_wcLast = m_crr.Last();
    srle.m_dwFlag = 0;
    srle.m_dwcGlyphs = m_csmw2oEncodings.GetCount();
    srle.m_dwcRuns = m_crr.RunCount();
    srle.m_dwcbImage = 4 * sizeof srle.m_dwcbImage + srle.m_dwcRuns *
         m_crr.Size();
    srle.m_dwcbThis = srle.m_dwcbImage + 3 * sizeof srle.m_dwcbThis +
        srle.m_dwcGlyphs * sizeof srle.m_dwcGlyphs;

    //  Determine the correct format, and thus the RLE size

    if  (!m_crr.MustCompose())
        srle.m_wFormat = m_bPaired ? sRLE::Paired : sRLE::Direct;
    else
        if  (srle.m_dwcGlyphs < 256 &&
             srle.m_dwcbThis + m_crr.ExtraNeeded() <= 0xffff) {
            srle.m_dwcbThis += m_crr.ExtraNeeded();
            srle.m_wFormat = sRLE::LengthIndexOffset;
        }
        else {
            srle.m_dwcbThis += m_crr.ExtraNeeded(FALSE);
            srle.m_wFormat = sRLE::LengthOffset;
        }

    //  We now need to feed the offset information down to the lower level
    //  classes, so that they are prepared to render their information to
    //  the target file.

    //  The first items encoded are the runs, which immediately follow the RLE
    //  header.

    DWORD   dwOffset = sizeof srle + srle.m_dwcRuns * m_crr.Size();

    m_crr.NoteOffset(dwOffset, TRUE, m_bPaired);

    //  If this requires extra data, it will be appearing after the FD_GLYPHSET

    if  (srle.m_wFormat == sRLE::LengthOffset ||
         srle.m_wFormat == sRLE::LengthIndexOffset)
        m_crr.NoteExtraOffset(dwOffset,
            srle.m_wFormat == sRLE::LengthIndexOffset);

    _ASSERTE(dwOffset == srle.m_dwcbThis);

    //  We've got our data, we've got our file, and we've got a job to do.
    //  Hop to it!

    try {
        cfTarget.Write(&srle, sizeof srle);
        m_crr.WriteSelf(cfTarget);
        m_crr.WriteHandles(cfTarget, srle.m_wFormat);
        m_crr.WriteEncodings(cfTarget, srle.m_wFormat == sRLE::LengthOffset ?
            CGlyphHandle::RLEBig : CGlyphHandle::RLESmall);
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CGlyphMap::Glyph

  I tried to do this in the header, file but that lets it be in-line, and I
  don't want to export CRunRecord.

******************************************************************************/

CGlyphHandle*   CGlyphMap::Glyph(unsigned u) {
    return  m_crr.GetGlyph(u);
}

/******************************************************************************

  CGlyphMap::CreateEditor

  This member function overrides the CProjectNode function to create a new
  CGlyphMapContainer document embedding this Glyph Map.  It then uses the
  appropriate document template to open a view on this document.

******************************************************************************/

CMDIChildWnd    *CGlyphMap::CreateEditor() {
    CGlyphMapContainer* pcgmcMe= new CGlyphMapContainer(this, FileName());

    //  Make up a cool title

    pcgmcMe -> SetTitle(m_pcbnWorkspace -> Name() + _TEXT(": ") + Name());

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt ->
        CreateNewFrame(pcgmcMe, NULL);

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcgmcMe, TRUE);
        m_pcmdt -> AddDocument(pcgmcMe);
    }

    return  pcmcwNew;
}

/******************************************************************************

  CGlyphMap::Generate

  This member function generates the GTT format image of the current data.

  It returns a BOOL indicating success or failure.

******************************************************************************/

BOOL    CGlyphMap::Generate(CFile& cfGTT) {

    sGTTHeader  sgtth;

    //  First, take care of any predefined stuff, if we have to

    if  (m_lidPredefined != NoPredefined)
        UnmergePredefined(TRUE);

    sgtth.m_dwcGlyphs = Glyphs();
    sgtth.m_dwcRuns = m_crr.RunCount();
    sgtth.m_dwcCodePages = CodePages();
    sgtth.m_lidPredefined = m_lidPredefined;

    //  The run table is the first item after the header, so add in its size

    sgtth.m_dwofRuns = sgtth.m_dwcbImage;   //  Runs are first item
    sgtth.m_dwcbImage += sgtth.m_dwcRuns * m_crr.Size(FALSE);
    sgtth.m_dwofCodePages = sgtth.m_dwcbImage;  //  Code pages are next

    //  Code page selection strings immediately follow the Code page structures
    //  The code page information size must be padded to a DWORD multiple

    sgtth.m_dwcbImage += sgtth.m_dwcCodePages * CodePage(0).Size();
	DWORD dwPadding ;	// # of padding bytes needed to DWORD align map table
	DWORD dwSelOffset ;	// Offset from each CODEPAGEINFO to sel/desel strings
	DWORD dwSelBytes ;	// Total # of bytes used by sel/desel strings
	dwSelOffset = sgtth.m_dwcbImage - sgtth.m_dwofCodePages ;
    for (unsigned u = 0 ; u < CodePages() ; u++) {
        CodePage(u).NoteOffsets(dwSelOffset) ;
		dwSelOffset -= CodePage(0).Size() ;
	} ;

    // Save the amount of padding, as we'll write it later.  It is also needed
	// as part of the computation for the mapping table offset.

    dwPadding = dwSelOffset + sgtth.m_dwcbImage ;
    dwPadding = (sizeof(DWORD) -
        (dwPadding & (sizeof(DWORD) - 1))) & (sizeof(DWORD) - 1) ;

	// Compute the number of bytes used for the sel/desel strings and pad.  Then
	// add this count to the image count of bytes so that it can be used to set
	// the mapping table offset.

	dwSelBytes = dwSelOffset + dwPadding ;
    sgtth.m_dwcbImage += dwSelBytes;
    sgtth.m_dwofMapTable = sgtth.m_dwcbImage;

	TRACE("***CGlyphMap::Generate() -  dwPadding = %d, dwSelBytes = %d, m_dwofMapTable = 0x%x\n", dwPadding, dwSelBytes, sgtth.m_dwofMapTable) ;

    //  Map Table size determination

    sMapTable   smt(Glyphs());

    //  Fortunately for us, the following not only preps the data, it also
    //  updates the image size for us
    if  (m_crr.MustCompose())
        m_crr.NoteOffset(smt.m_dwcbImage, FALSE, m_bPaired);

    //  Final Size calculation
    sgtth.m_dwcbImage += smt.m_dwcbImage;

    //  Now, we just write it out

    try {
        cfGTT.Write(&sgtth, sizeof sgtth);  //  Header
		
		ASSERT(sgtth.m_dwofRuns == cfGTT.GetPosition()) ;
        m_crr.WriteSelf(cfGTT, FALSE);      //  Glyph Runs
		
		ASSERT(sgtth.m_dwofCodePages == cfGTT.GetPosition()) ;
        for (unsigned u = 0; u < CodePages(); u++)
            CodePage(u).WriteSelf(cfGTT);   //  Code page structures

        for (u = 0; u < CodePages(); u++)
            CodePage(u).WriteInvocation(cfGTT); //  Code page invocations

		// Pad with 0's to DWORD align the mapping table

		dwSelBytes = 0 ;
        cfGTT.Write((LPSTR) &dwSelBytes, dwPadding) ;

        //  Do the map table, and we are finished!

		ASSERT(sgtth.m_dwofMapTable == cfGTT.GetPosition()) ;
        cfGTT.Write(&smt, sizeof smt);
        m_crr.WriteMapTable(cfGTT, m_lidPredefined != NoPredefined);
        m_crr.WriteEncodings(cfGTT, CGlyphHandle::GTT);
    }
    catch   (CException * pce) {
        //  Take care of any predefined stuff, if we have to

        if  (m_lidPredefined != NoPredefined)
            MergePredefined();

        //  Feedback- something broke when it shouldn't have
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }
    //  Take care of any predefined stuff, if we have to

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    Changed(FALSE);

    return  TRUE;
}

/******************************************************************************

  CGlyphMapContainer class - this encases the glyph table UI when it is either
  embedded in the driver, or loaded directly from the GTT

******************************************************************************/

/******************************************************************************

  CGlyphMapContainer::CGlyphMapContainer()

  This default constructor is used whenever dynamic creation is used, which is
  most MFC usages of the document system.  It starts with an empty glyph map.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGlyphMapContainer, CDocument)

CGlyphMapContainer::CGlyphMapContainer()
{
    m_pcgm = new CGlyphMap;
    m_pcgm -> NoteOwner(*this);
    m_bSaveSuccessful = m_bEmbedded = FALSE;
}

/******************************************************************************

  CGlyphMapContainer:CGlyphMapContainer(CGlyphMap *pvgm, CString csPath)

  This constructor override is used when we create a CGlyphMapContainer
  document from the driver/project level editor.  In this case, a digested
  map is passed, so no additional I/O us needed.

******************************************************************************/

CGlyphMapContainer::CGlyphMapContainer(CGlyphMap *pcgm, CString csPath)
{
    m_pcgm = pcgm;
    SetPathName(csPath, FALSE);
    m_bEmbedded = TRUE;
	m_bSaveSuccessful = FALSE;
    m_pcgm -> NoteOwner(*this); //  This is the document being edited!
}

BOOL CGlyphMapContainer::OnNewDocument() {
    return  CDocument::OnNewDocument();
}

CGlyphMapContainer::~CGlyphMapContainer() {
    if  (!m_bEmbedded && m_pcgm)
        delete  m_pcgm;
}


BEGIN_MESSAGE_MAP(CGlyphMapContainer, CDocument)
    //{{AFX_MSG_MAP(CGlyphMapContainer)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer diagnostics

#ifdef _DEBUG
void CGlyphMapContainer::AssertValid() const {
    CDocument::AssertValid();
}

void CGlyphMapContainer::Dump(CDumpContext& dc) const {
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer serialization

void CGlyphMapContainer::Serialize(CArchive& ar) {
    if (ar.IsStoring()) {
        // TODO: add storing code here
    }
    else {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer commands

BOOL CGlyphMapContainer::OnSaveDocument(LPCTSTR lpszPathName) {

    //  We save via the glyph map's Generate function.

    CFile   cfGTT;
    if  (!cfGTT.Open(lpszPathName, CFile::modeCreate | CFile::modeWrite |
        CFile::shareExclusive))
        return  FALSE;

    m_bSaveSuccessful = m_pcgm -> Generate(cfGTT) ;

	// Update the save timestamp.  This is done here so that other user of the
	// Generate() function don't update the timestamp.

	m_pcgm->m_ctSaveTimeStamp = CTime::GetCurrentTime() ;
	
	// when open mutiple workspace, last of the pos is the workspace conating current GTT or UFM
	CDriverResources * pcpr =(CDriverResources *) m_pcgm->GetWorkspace() ;
	if (m_pcgm->ChngedCodePt() && pcpr ) {//  && m_pcgm->Glyphs() <= 1000 ) {
		pcpr->SyncUFMWidth() ;
	}
    return m_bSaveSuccessful ;
}


/******************************************************************************

  CGlyphMapContainer::OnOpenDocument

  This overrides the typical MFC open document action, which is to open the
  document by serialization.  Instead, we use the CGlyphMap Load override for
  the GTT format to initialize the GlyphMap.

******************************************************************************/

BOOL CGlyphMapContainer::OnOpenDocument(LPCTSTR lpstrFile)
{
    return m_pcgm->Load(lpstrFile) ;
}


/******************************************************************************

  CGlyphMapContainer::SaveModified

  The document is about to close.  If the GTT was changed by the user but the
  user does not want to save the changes, the user wants to close the GTT, and
  the GTT was loaded from a workspace, then reload the GTT so that the changes
  are removed from the in memory copy of the GTT.  This keeps those "discarded"
  changes from being displayed the next time the GTT is edited.

  Return TRUE if it is ok for the doc to close.  Otherwise, FALSE.

******************************************************************************/

BOOL CGlyphMapContainer::SaveModified()
{
	// Get a pointer to the associate view class instance and use it to make
	// sure the code page select/deselect strings are copied into the GTT.

	POSITION pos = GetFirstViewPosition() ;
	ASSERT(pos != NULL) ;
	CGlyphMapView* pcgmv = (CGlyphMapView*) GetNextView(pos) ;
	pcgmv->SaveBothSelAndDeselStrings() ;
	
	// Find out if the document was modified and if the user wants to save it.

	m_bSaveSuccessful = FALSE ;
	BOOL bmodified = IsModified() ;
	BOOL bcloseok = CDocument::SaveModified() ;

	// If the GTT was loaded from a workspace, the GTT was changed, the user
	// does NOT want to save the changes, and he does want to close the doc,
	// then reload the GTT.
	
	if (m_bEmbedded	&& bmodified && bcloseok && !m_bSaveSuccessful)
		m_pcgm->Load() ;

	// Return flag indicating if it is ok to close the doc.

	return bcloseok ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdview.cpp ===
/******************************************************************************

  Source File:  GPD Viewer.CPP

  This file implements the GPD viewing/editing class.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-24-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "MainFrm.H"
#include	<gpdparse.h>
#include    "ProjNode.H"
#include	"rcfile.h"
#include    "GPDFile.H"
#include    "GPDView.H"
#include    "Resource.H"
#include	"freeze.h"

#include "projview.h"
#include "comctrls.h"
#include    "INFWizrd.h"	//raid 0001


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/******************************************************************************

  CGPDViewer class

  This class implements the GPD viewer.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGPDViewer, CRichEditView)


BEGIN_MESSAGE_MAP(CGPDViewer, CRichEditView)
	//{{AFX_MSG_MAP(CGPDViewer)
	ON_WM_DESTROY()
	ON_COMMAND(ID_FILE_PARSE, OnFileParse)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
	ON_WM_TIMER()
	ON_CONTROL_REFLECT(EN_VSCROLL, OnVscroll)
	ON_WM_VSCROLL()
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_ERROR_LEVEL, OnFileErrorLevel)
	ON_COMMAND(ID_EDIT_GOTO, OnGotoGPDLineNumber)
	ON_COMMAND(ID_SrchNextBtn, OnSrchNextBtn)
	ON_COMMAND(ID_SrchPrevBtn, OnSrchPrevBtn)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_LBN_SELCHANGE(IDC_ErrorLst, OnSelchangeErrorLst)
	ON_WM_LBUTTONDBLCLK()
	ON_COMMAND(ID_EDIT_ENABLE_AIDS, OnEditEnableAids)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_FILE_INF, OnFileInf)
	//}}AFX_MSG_MAP
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()


/******************************************************************************

  CGPDViewer::MarkError

  This private member highlights the given line in the error display.  The
  offending line in the GPD is displayed and selected if the error message
  contains a line number.

******************************************************************************/

void    CGPDViewer::MarkError(unsigned u)
{
	// Copy the error message to the status bar.

    CString cserror = GetDocument()->ModelData()->Error(u) ;
    m_csb.SetPaneText(0, cserror) ;
    SetFocus() ;

    // If the string starts with the GPD name, scroll to the line.
	
	CString csname = GetDocument()->ModelData()->FileTitleExt() ;
    if (!cserror.Find(csname) && cserror[csname.GetLength()] == _T('(')) {
        //  Extract the line number

        cserror = cserror.Mid(1 + csname.GetLength()) ;
        int iLine = atoi(cserror) ;

		// Determine the line's first character number and its length

		int nstartchar = GetRichEditCtrl().LineIndex(-1 + iLine) ;
		int nlinelen = GetRichEditCtrl().GetLine(iLine - 1,
												 cserror.GetBuffer(1024), 1024) ;
		cserror.ReleaseBuffer(nlinelen) ;
		nlinelen -= 2 ;

		// Select the line that caused the error and scroll it into view.

        GetRichEditCtrl().SetSel(nstartchar, nstartchar + nlinelen) ;
        GetRichEditCtrl().LineScroll(iLine  - (5 +
            GetRichEditCtrl().GetFirstVisibleLine())) ;
    } ;

    CWnd *pcwnderrors = m_cdbActionBar.GetDlgItem(IDC_ErrorLst);
    pcwnderrors->SendMessage(WM_HSCROLL, SB_TOP, NULL) ;
}


/******************************************************************************

  CGPDViewer::CreateActionBar

  Create the action bar and attach it to the GPD Editor window iff the GPD has
  errors to display.

******************************************************************************/

void    CGPDViewer::CreateActionBar()
{
	// Get reference to ModelData instance for the GPD in the editor

    CModelData& cmd = *GetDocument()->ModelData() ;

	// If the GPD has errors...

    if  (cmd.HasErrors()) {

		// ...Iff the action bar has not been created yet...

		if (m_cdbActionBar.m_hWnd == NULL) {
			// ...Create the error bar, position it, and resize the REC to make
			// room for it.

			m_cdbActionBar.Create(GetParentFrame(), IDD_GPDActionBar,
								  CBRS_BOTTOM, IDD_GPDActionBar) ;
			GetParentFrame()->RecalcLayout() ;

			// Now set the focus back to the REC.

			SetFocus() ;
		} ;
	} ;
}


/******************************************************************************

  CGPDViewer::LoadErrorListBox

  This fills the error dialog bar with the current set of errors, if there are
  any...

******************************************************************************/

void    CGPDViewer::LoadErrorListBox()
{
	// Get reference to ModelData instance for the GPD in the editor

    CModelData& cmd = *GetDocument()->ModelData() ;

	// If the GPD has errors...

    if  (cmd.HasErrors()) {
		// ...Get a pointer to the list box and attach it to CListBox.  Then
		// clear the list box.

		CWnd *pcwndlst = m_cdbActionBar.GetDlgItem(IDC_ErrorLst) ;
		CListBox clberrors  ;
		clberrors.Attach(pcwndlst->m_hWnd) ;
		clberrors.ResetContent() ;

		// Load the list box with the new errors.  Detach the list box when
		// done.

        for (unsigned u = 0 ; u < cmd.Errors() ; u++)
            clberrors.AddString(cmd.Error(u)) ;
		clberrors.Detach() ;

		// Set the list box label.  It contains the number of errors.

        CString cserror ;
		cserror.Format(IDS_ErrorLabel, u) ;
		m_cdbActionBar.SetDlgItemText(IDC_ErrorLabel, cserror) ;

		// Select the first error and set the focus to the REC.

        ChangeSelectedError(1) ;
        SetFocus() ;

	// Otherwise, just display a message saying there are no errors.

	} else {
        CString csWork;
        csWork.LoadString(IDS_NoSyntaxErrors);
        m_csb.SetPaneText(0, csWork);
    }
}


/******************************************************************************

  CGPDViewer::Color

  This private member syntax colors the rich edit controls contents using the
  information gleaned from the GPD file's analysis.

******************************************************************************/

void    CGPDViewer::Color()
{
    CHARRANGE   crCurrentSel;
    CHARFORMAT  cf;
    CModelData& cmd = *(GetDocument() -> ModelData());
    CRichEditCtrl&  crec = GetRichEditCtrl();
    m_bInColor = TRUE; 

    //  Turn off change and selection notification messages
	
	FreezeREC() ;

	// Get formatting info from the current selection to use as the default
	// characteristics for ever line on the screen.
    crec.GetSel(crCurrentSel);
    crec.GetDefaultCharFormat(cf);
    cf.dwEffects &= ~CFE_AUTOCOLOR;
    cf.dwMask |= CFM_COLOR;

    //  Color each visible line as it was classsified visibility is
    //  determined by checking the character bounds against the client
    //  rectangle for the control.

    int iTop = m_iTopLineColored = crec.GetFirstVisibleLine();
    int i    = iTop;
    int iLineHeight = crec.GetCharPos(crec.LineIndex(i+1)).y -
        crec.GetCharPos(crec.LineIndex(i)).y;

	// Tweak things to improve performance.

    CRect   crEdit ;
    crec.GetClientRect(crEdit) ;
    crec.LockWindowUpdate() ;    //  Don't let this show until done!
    crec.HideSelection(TRUE, TRUE) ;

	// Use the formatting characteristics of the current selection as a
	// starting place for the characteristics of each line on the screen.
	// Then set the line's colors based on the data returned by TextColor().

	int nlinesinrec = crec.GetLineCount() ;	// Number of lines in the REC
	int nstartchar, nendchar ;	// Used to determine starting/ending chars to
								// color in current line and to say line done
    do {
		nstartchar = nendchar = 0 ;

		// Colorize each segment of the current line that needs colorizing

		while (1) {
 			cf.crTextColor = TextColor(i, nstartchar, nendchar) ;
			if (nstartchar == -1) 
				break ;			// *** Loop exits here
			crec.SetSel(crec.LineIndex(i) + nstartchar,
						crec.LineIndex(i) + nendchar) ;
			crec.SetSelectionCharFormat(cf) ;
		} ; 
    } while (++i < nlinesinrec &&
	         crec.GetCharPos(crec.LineIndex(i)).y + iLineHeight <
		     crEdit.bottom - 1) ;

    //  Restore the original position of the cursor, and then the original
    //  line (in case the cursor is no longer on this page).

	  crec.SetSel(crCurrentSel); 
	  crec.LineScroll(iTop - crec.GetFirstVisibleLine());
      crec.HideSelection(FALSE, TRUE);
      crec.UnlockWindowUpdate();    //  Let it shine!

    //  Restore the notification mask

	UnfreezeREC() ;

	// Create the action bar and load the error list box.

    if  (m_bStart) {
		CreateActionBar() ;
        LoadErrorListBox() ;
	} ;
    m_bInColor = FALSE;
	
}


/******************************************************************************

  CGPDViewer::TextColor

  This determines what colors to make a line.  It is complicated a bit by the
  fact that the Rich Edit control gives false values for line length on long
  files.  Probably some brain-dead 64K thing, but I sure can't fix it.

  This routine is/can be called multiple times on a line.  Each time it is
  called, try to find the next piece of the line that needs to be colorized.
  If no colorizable part of the line can be found, set nstartchar to -1 and
  return.

  This routine will indicate the line range and color for these types of text:
	Normal to end of line comments (green)
	Comments containing error messages (red)
	Comments containing warning messages (amber/yellow)
	GPD keywords (blue)

  If a comment contains a keyword, the appropriate comment color is used.  IE,
  comments take precedence over everything as far as colorizing is concerned.

******************************************************************************/

unsigned CGPDViewer::TextColor(int i, int& nstartchar, int& nendchar)
{
	// Get the specified line

    CByteArray  cba ;
    CRichEditCtrl&  crec = GetRichEditCtrl() ;
    cba.SetSize(max(crec.LineLength(i) + sizeof (unsigned), 100)) ;
    CString csline((LPCTSTR) cba.GetData(),
        crec.GetLine(i, (LPSTR) cba.GetData(),
            (int)(cba.GetSize() - sizeof (unsigned)))) ;

	// If the end of the line was dealt with the last time, indicate that this
	// line is done and return.

	if (nendchar + 1 >= csline.GetLength()) {
		nstartchar = -1 ;
		return RGB(0, 0, 0) ;
	} ;

	// Now get the segment of the line we need to check and see if there is a
	// comment or something that might be a keyword in it.

	CString csphrase = csline.Mid(nendchar) ;
	int ncomloc = csphrase.Find(_T("*%")) ;
	int nkeyloc = csphrase.Find(_T('*')) ;

	// Process any comment found in the string

	if (ncomloc >= 0)
		return (CommentColor(csphrase, ncomloc, csline, nstartchar, nendchar)) ;

	// If no comment was found, process anything that might be a GPD keyword.

	if (nkeyloc >= 0)
		return (KeywordColor(csphrase, nkeyloc, csline, nstartchar, nendchar)) ;

	// The rest of the line should be black

	nstartchar = nendchar + 1 ;
	nendchar = csline.GetLength() ;
	return RGB(0, 0, 0) ;
}


/******************************************************************************

  CGPDViewer::CommentColor

  Determine and save the character range for the comment.  Then determine the
  type of comment and return the color required for that type.  (See TextColor()
  for more details.)

*******************************************************************************/

unsigned CGPDViewer::CommentColor(CString csphrase, int ncomloc, CString csline,
								  int& nstartchar, int& nendchar)
{
	// Determine the range in the line that contains the comment.  This starts
	// at the comment characters and goes to the end of the line.

	nstartchar = nendchar + ncomloc ;
	nendchar = csline.GetLength() - 1 ;

    // Errors

    if  (csphrase.Find(_T("Error:")) > ncomloc)
        return  RGB(0x80, 0, 0) ;

    // Warnings

    if  (csphrase.Find(_T("Warning:")) > ncomloc)
        return  RGB(0x80, 0x80, 0) ;

	// If this comment doesn't contain an error or warning, make it green.

    return  RGB(0, 0x80, 0) ;
}


/******************************************************************************

  CGPDViewer::KeywordColor

  Determine and save the character range for the comment.  Then determine the
  type of comment and return the color required for that type.  (See TextColor()
  for more details.)

*******************************************************************************/

unsigned CGPDViewer::KeywordColor(CString csphrase, int nkeyloc, CString csline,
								  int& nstartchar, int& nendchar)
{
	// Determine the length of the token that might be a keyword.  Keywords are
	// made up of letters, '?', '_', and '0'.

	TCHAR ch ;
	int nphlen = csphrase.GetLength() ;
	for (int nidx = nkeyloc + 1 ; nidx < nphlen ; nidx++) {
		ch = csphrase[nidx] ;
		if (ch != _T('?') && ch != _T('_') && (ch < _T('A') || ch > _T('Z'))
		 && (ch < _T('a') || ch > _T('z')) && ch != _T('0'))
			break ;
	} ;

	// If there is a keyword to check, isolate it.  Otherwise, update the range
	// for the * and return black as the color.

	CString cstoken ;
	if (nidx > nkeyloc + 1)
		cstoken = csphrase.Mid(nkeyloc + 1, nidx - nkeyloc - 1) ;
	else {
		nstartchar = nendchar + 1 ;
		nendchar = nstartchar + (nidx - nkeyloc - 1) ;
		return RGB(0, 0, 0) ;
	} ;

	// Update the range for the token no matter what it is.  Include the * in
	// the range.

	nstartchar = nendchar + nkeyloc ;
	nendchar = nstartchar + (nidx - nkeyloc) ;

	// Try to find the token in the keyword array
	
	CStringArray& csakeys = ThisApp().GetGPDKeywordArray() ;
	int nelts = (int)csakeys.GetSize() ;	// Number of elements in the keyword array
	int nleft, nright, ncomp ;	// Variables needed for searching of array
	int ncheck ;
	for (nleft = 0, nright = nelts - 1 ; nleft <= nright ; ) {
		ncheck = (nleft + nright) >> 1 ;
		ncomp = csakeys[ncheck].Compare(cstoken) ;
		//TRACE("Key[%d] = '%s', Tok = '%s', Comp Res = %d\n", ncheck, csakeys[ncheck], cstoken, ncomp) ;
		if (ncomp > 0)
			nright = ncheck - 1 ;
		else if (ncomp < 0)
			nleft = ncheck + 1 ;
		else
			break ;
	} ;							

	// If the token is a keyword, return blue as the color.  Otherwise,
	// return black.

	if (ncomp == 0)		
		return RGB(0, 0, 0x80) ;
	else
		return RGB(0, 0, 0) ;
}


/******************************************************************************

  CGPDViewer::UpdateNow

  This private member updates the underlying GPD and marks the document as
  changed, and the edit control as unmodified.  It is called whenever this
  needs to be done.

*******************************************************************************/

void    CGPDViewer::UpdateNow() {

    //  Don't do this if nothing's chenged...
    if  (!GetRichEditCtrl().GetModify())
        return;

    CWaitCursor cwc;    //  Just in case

    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);
    m_uTimer = 0;

    GetDocument() -> ModelData() -> UpdateFrom(GetRichEditCtrl());
    GetDocument() -> SetModifiedFlag();
    GetRichEditCtrl().SetModify(FALSE);
}


CGPDViewer::CGPDViewer()
{
	// Initialize member variables

    m_iLine = m_uTimer = 0 ;
    m_bInColor = FALSE ;
    m_bStart = TRUE ;
    m_iTopLineColored = -1 ;
	m_nErrorLevel = 0 ;
	m_bEditingAidsEnabled = true ;
	m_punk = NULL ;					
	m_pdoc = NULL ;
	m_bVScroll = false ;

	// Initialize the GPD keyword array if this hasn't been done already.

	if (ThisApp().GetGPDKeywordArray().GetSize() == 0)
		InitGPDKeywordArray() ;
}


CGPDViewer::~CGPDViewer()
{
	if (ThisApp().m_bOSIsW2KPlus)
		ReleaseFreeze(&m_punk, &m_pdoc) ;
}


/////////////////////////////////////////////////////////////////////////////
// CGPDViewer diagnostics

#ifdef _DEBUG
void CGPDViewer::AssertValid() const {
	CRichEditView::AssertValid();
}

void CGPDViewer::Dump(CDumpContext& dc) const {
	CRichEditView::Dump(dc);
}

#endif //_DEBUG

/******************************************************************************

  CGPDViewer::OnDestroy

  Handles the required project node notification when the view is destroyed.
  A GP Fault is a terrible thing to signal.

******************************************************************************/

void CGPDViewer::OnDestroy() {
	CRichEditView::OnDestroy();
	
	if  (GetDocument() -> ModelData())
        GetDocument() -> ModelData() -> OnEditorDestroyed();
	
	if (ThisApp().m_bOSIsW2KPlus)
		ReleaseFreeze(&m_punk, &m_pdoc) ;
}


/******************************************************************************

  CGPDViewer::OnInitialUpdate

  This is the wake-up call.  We fill the view from the GPD's contents, and
  eventually color things to suit us.

******************************************************************************/

void CGPDViewer::OnInitialUpdate()
{
	// Set the frame's window style and initialize the rich edit control (REC).

    GetParentFrame() -> ModifyStyle(0, WS_OVERLAPPEDWINDOW);
	CRichEditView::OnInitialUpdate();

	// Create and configure the GPD Editor's status bar

    if  (m_csb.Create(GetParentFrame())) {
        static UINT auid[] = {ID_SEPARATOR, ID_LineIndicator};
        m_csb.SetIndicators(auid, 2);
        m_csb.SetPaneInfo(1, ID_LineIndicator, SBPS_NORMAL, 200);
        GetParentFrame() -> RecalcLayout();
    }

    // We don't want EN_CHANGE messages while we load the control

    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() &
        ~ENM_CHANGE);

    // We also do not want the control to wrap lines for us, as it messes up
    // syntax coloring, etc.

    m_nWordWrap = WrapNone;
    WrapChanged();

	// Load the GPD's contents into the REC.

	GetDocument() -> ModelData() -> Fill(GetRichEditCtrl());
    SetFocus();

    // We want EN_CHANGE messages now that the initial load is complete so
	// that we can update the cache.  To keep from overloading the machine,
	// some change notifications are just acted upon once every half second.
	// A timer is used to do this.

    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() |
        ENM_CHANGE);
    m_uTimer = (unsigned) SetTimer((UINT_PTR) this, 500, NULL);

    GetRichEditCtrl().SetSel(1, 1); //  Have to change the selection!
    GetRichEditCtrl().SetSel(0, 0);

	// Initialize the pointers needed to freeze the REC.

	if (ThisApp().m_bOSIsW2KPlus)
		InitFreeze(GetRichEditCtrl().m_hWnd, &m_punk, &m_pdoc, &m_lcount) ;
}


/******************************************************************************

  CGPDViewer::OnFileParse

  Syntax check the GPD file, and show us the results

******************************************************************************/

void CGPDViewer::OnFileParse() {
    CWaitCursor cwc;

    if  (GetDocument() -> ModelData() -> HasErrors()) {
        m_cdbActionBar.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
    }

    //  Save any changes made to the file.

	bool brestore = false ;		// True iff original file must be restored
	BOOL bdocmod = GetDocument()->IsModified() ;
    if (GetRichEditCtrl().GetModify() || bdocmod) {
        UpdateNow();    //  Pick up any new changes
        GetDocument()->ModelData()->BkupStore() ;
        GetDocument()->SetModifiedFlag(bdocmod) ;
		brestore = true ;
    }

	// Reparse the GPD

	if  (!GetDocument()->ModelData()->Parse(m_nErrorLevel))
        AfxMessageBox(IDS_UnusualError) ;

	// Restore the original GPD file (when needed) because the user wasn't
	// asked if it was ok to save the file.

	if (brestore)
        GetDocument()->ModelData()->Restore() ;

	// Display the action bar and load the error list.

	CreateActionBar() ;
    LoadErrorListBox() ;
    MessageBeep(MB_ICONASTERISK) ;

	// Mark the project containing this GPD as being dirty so that the new
	// errors (or lack there of) will be saved in the MDW file.
//RAID 17181  Here are suggestions. current fix is (3)
//   (1). Ask when workspace close if Error box has the bug in any Gpd file, which was check
//	 (2). Ask when Gpd viewer close if Error box has the bug in any Gpd file, which was check
//   (3). Do not ask at all, not saving error list

//	CModelData& cmd = *GetDocument()->ModelData(); //add 1/2
//	if(cmd.HasErrors())							// add 2/2
//		GetDocument()->ModelData()->WorkspaceChange() ;  (1)
//		OnChange(); (2) // add This prompt save ask message when close gpd viewer instead of workspace
//		(3)
	
}


/******************************************************************************

  CGPDViewer::OnChange

  This gets called whenever a change is made to the contents of the file.
  The coloring (now done only on the visible page) is updated, and the
  appropriate flags are set.  To keep performance smooth, the document is no
  longer updated as a result of this message.

******************************************************************************/

void CGPDViewer::OnChange()
{
	//  Since this is a RICHEDIT control, I override the
    //  CRichEditView::OnInitialUpdate() function to or the ENM_CHANGE flag
    //  into the control's event mask.  Otherwise this message wouldn't be
    //  sent.
	//
	//  To avoid thrashing the GPD contents unneedfully, we wait for 1 second
    //  of inactivity before bashing the changes into the GPD.

	// Scrolling data in the control generates two messages; first a scroll
	// message and then a change message.  This could cause scrolling to mark
	// the document as dirty if this flag wasn't used to keep this from
	// happening.

	if (m_bVScroll) {
		m_bVScroll = false ;
		return ;
	} ;

	// Do nothing if the change message was generated by Color().

    if (m_bInColor)
		return ;

	// Colorize whatever is on the screen and mark the document as having
	// changed.

    Color() ;
    GetDocument()->SetModifiedFlag() ;
}


/******************************************************************************

  CGPDViewer::OnTimer

  This handles the timeout of the timer used to batch changes into the
  underlying document.  If this isn't for that timer, we pass it on to the base
  class.

******************************************************************************/

void CGPDViewer::OnTimer(UINT uEvent) {

	// If this isn't our timer, let the base class do what it will with it.
	
    if  (m_uTimer == uEvent)
        if  (m_bStart) {
            if  (GetRichEditCtrl().GetLineCount() <
                GetDocument() -> ModelData() -> LineCount())
                return; //  The rich edit control isn't ready, yet...
            ::KillTimer(m_hWnd, m_uTimer);
            Color();
            m_uTimer = 0;
            m_bStart = FALSE;
        }
        else
            UpdateNow();
    else
	    CRichEditView::OnTimer(uEvent);
}

/******************************************************************************

  CGPDViewer::OnSelChange

  This handles the message sent by the control when the selection changes.  I'm
  hoping this means whenever the caret moves, since the selection, while empty,
  has changed.

******************************************************************************/

void    CGPDViewer::OnSelChange(LPNMHDR pnmh, LRESULT *plr) {
    SELCHANGE*  psc = (SELCHANGE *) pnmh;

    long    lLine = GetRichEditCtrl().LineFromChar(psc -> chrg.cpMin);

    CString csWork;
    csWork.Format(_T("Line %d, Column %d"), lLine + 1,
         1 + psc -> chrg.cpMax - GetRichEditCtrl().LineIndex(lLine));

    m_csb.SetPaneText(1, csWork);

}

/******************************************************************************

  CGPDViewer::OnUpdate

  If the first update hasn't been made, do nothing.

  Next, check to see if this routine was called by CGPDContainer::OnSaveDocument().
  If it was, make sure that the document has an up to date copy of the GPD.
  This is a hack to work around problems with CGPDContainer routines in
  modldata.dll call CGPDViewer routines in minidev.exe.  This problem should
  go away when the 3 MDT DLLs are folded back into the EXE.

  Otherwise, redo the error bar, because someone just syntax checked the
  workspace.

******************************************************************************/

void    CGPDViewer::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    if  (m_bStart) //  Have we already done the first update?
        return;

	// Update the document if this routine was called by the document class.

	if (lHint == 0x4545 && (INT_PTR) pHint == 0x4545) {
		UpdateNow() ;
		return ;
	} ;

    //  If there's a dialog bar, can it.

    if  (m_cdbActionBar.GetSafeHwnd()) {
        m_cdbActionBar.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
    }

    // Recreate the action bar and load the error list.

	CreateActionBar() ;
	LoadErrorListBox();
}

/******************************************************************************

  CGPDViewer::QueryAcceptData

  Override the Rich Edit Control default behavior, because we (a) don't have
  an associated RichEditDoc, and (b) we don't want to paste anything but text.
  Not even rich text, because we control the formatting, and don't want to
  paste it.

******************************************************************************/

HRESULT CGPDViewer::QueryAcceptData(LPDATAOBJECT lpdo, CLIPFORMAT* lpcf, DWORD,
                                    BOOL bReally, HGLOBAL hgMetaFile) {
	_ASSERTE(lpcf != NULL);

	COleDataObject codo;
	codo.Attach(lpdo, FALSE);
	// if format is 0, then force particular formats if available
	if (*lpcf == 0 && (m_nPasteType == 0)&& codo.IsDataAvailable(CF_TEXT)) {
	    *lpcf = CF_TEXT;
		return S_OK;
	}
	return E_FAIL;
}


/******************************************************************************

  CGPDViewer::OnVScroll()

  This function is called when EN_VSCROLL messages are refelected from the
  edit control.  As long as we are not coloring, we color the new page.  The
  documentation says this message comes BEFORE the scolling occurs, but it
  obviously occurs afterwards.

******************************************************************************/

void    CGPDViewer::OnVscroll()
{
    // Even though we turn scroll notifications off in the color routine,
    // we still get them, so use a flag to keep from recursive death.
	//
	// In addition, a flag is set to say that a scroll message was just
	// processed so that the OnChange routine will know when it doesn't need to
	// do anything.  This is needed because scrolling generates both a scroll
	// and a change message.

    if  (m_iTopLineColored != GetRichEditCtrl().GetFirstVisibleLine() &&
        !m_bInColor) {
        if(!(GetKeyState(VK_SHIFT) & 0x8000)) // raid 28160 : GetSel,SetSel has bug(seem sdk bug)
			Color() ;
		m_bVScroll = true ;
		
	} ;
}


/******************************************************************************

  CGPDViewer::OnVScroll(UINT uCode, UINT uPosition, CScrollBar *pcsb)

  This is called whwnever the scoll bar gets clicked.  This may seem
  redundant, but EN_VSCROLL messages don't get sent when the thumb itself is
  moved with the mouse, and WM_VSCROLL doesn't get sent when the keyboard
  interface is used.  So you get to lose either way.

  This control is buggy as can be, IMHO.  Next time I want to do text editing,
  I'll use a third party tool.  They starve if they don't get it right.

******************************************************************************/

void CGPDViewer::OnVScroll(UINT uCode, UINT uPosition, CScrollBar* pcsb)
{
	CRichEditView::OnVScroll(uCode, uPosition, pcsb);
    //(Raid 16569)
	if(uCode == SB_THUMBTRACK)
		OnVscroll();
}


/******************************************************************************

  CGPDViewer::OnFileSave
  CGPDViewer::OnFileSaveAs

  Since we don't update the document as changes are made in the editor, we have
  to intercept these, update the document, and then pass these on to the
  document.

******************************************************************************/

void CGPDViewer::OnFileSave() {
	UpdateNow();
    GetDocument() -> OnFileSave();
}

void CGPDViewer::OnFileSaveAs() {
	UpdateNow();
    GetDocument() -> OnFileSaveAs();
}

/******************************************************************************

  CGPDViewer::OnUpdateEditPaste
  CGPDViewer::OnUpdateEditUndo

  These override the default processing for these menu items.  Paste is only
  possible with a text format.

  DEAE_BUG	Fix text coloring when an Undo operation is performed.

*******************************************************************************/

void CGPDViewer::OnUpdateEditPaste(CCmdUI* pccui) {
	pccui -> Enable(IsClipboardFormatAvailable(CF_TEXT));	
}

void CGPDViewer::OnUpdateEditUndo(CCmdUI* pccui) {
	pccui -> Enable(0);
}


void CGPDViewer::OnEditPaste()
{	//raid 16573
	CMainFrame *pcmf = (CMainFrame*) GetTopLevelFrame() ;
	ASSERT(pcmf != NULL) ;
	
	CGPDToolBar *cgtb = pcmf->GetGpdToolBar() ;
	
	if(GetFocus() == FromHandle(cgtb->ceSearchBox.m_hWnd) )
		cgtb->ceSearchBox.Paste();
	else
		GetRichEditCtrl().Paste() ;
		
	OnChange() ;	
}


void CGPDViewer::OnEditCut()
{
    GetRichEditCtrl().Cut() ;
	OnChange() ;
}


/******************************************************************************

  CGPDViewer::OnSelchangeErrorLst

  Update the REC by selected the GPD line corresponding to the currently
  selected error list item.

******************************************************************************/

void CGPDViewer::OnSelchangeErrorLst()
{
	ChangeSelectedError(0) ;
}


/******************************************************************************

  CGPDViewer::ChangeSelectedError

  Whenever the error message selected in the list box and/or the GPD line that
  generated the error should change, this routine is called to manage the work.

******************************************************************************/

void CGPDViewer::ChangeSelectedError(int nchange)
{
	// Make sure that the action bar exists before doing anything.

	if (m_cdbActionBar.m_hWnd == NULL || !IsWindow(m_cdbActionBar.m_hWnd))
		return ;

	// Get a pointer to the list box and attach it to CListBox.

	CWnd *pcwndlst = m_cdbActionBar.GetDlgItem(IDC_ErrorLst) ;
	CListBox clberrors ;
	clberrors.Attach(pcwndlst->m_hWnd) ;

	// Get the selected item number and the number of items.

	int nselitem = clberrors.GetCurSel() ;
	int numitems = clberrors.GetCount() ;
	
	// If the selected item number should change, change it.  Then "wrap" the
	// number if it goes out of bounds.  Last, select the referenced item.

	if (nchange != 0) {
		nselitem += nchange ;
		if (nselitem < 0)
			nselitem = numitems - 1 ;
		else if (nselitem >= numitems)
			nselitem = 0 ;
		clberrors.SetCurSel(nselitem) ;
	} ;

	// We're done with the list box now so detach from it.

	clberrors.Detach() ;

	// Select the error line in the REC and set the focus to the REC.

    MarkError(nselitem) ;
	SetFocus() ;
}


/******************************************************************************

  CGPDViewer::PreTranslateMessage

  Take special action when certain characters are entered.  Those characters
  are:
	F4			Select next error and corresponding GPD line when possible.
	Shift+F4	Select previous error and corresponding GPD line when possible.
	Ctrl+]    	Find a matching bracket "[]", paren "()", curly brace "{}", or
	      		angle brackets "<>".

******************************************************************************/

BOOL CGPDViewer::PreTranslateMessage(MSG* pMsg)
{
	// If F4 or Shift+F4 is pressed, change the selected error message and
	// update the current selected line in the GPD.

	if (pMsg->message == WM_KEYUP && pMsg->wParam == VK_F4) {
		if (!(GetKeyState(VK_SHIFT) & 0x8000))
			ChangeSelectedError(1) ;
		else
			ChangeSelectedError(-1) ;
		return CRichEditView::PreTranslateMessage(pMsg) ;
	} ;

	// Handle help command (F1)

	/*
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		//TRACE0("Calling Help on GPD\n") ;
		//ThisApp().WinHelp(0x20000 + IDR_GPD_VIEWER) ;
		//TRACE0("Calling Help on String\n") ;
		//ThisApp().WinHelp(0x20000 + IDR_STRINGEDITOR) ;
		//TRACE0("Calling Help on UFM\n") ;
		//ThisApp().WinHelp(0x20000 + IDR_FONT_VIEWER) ;
		TRACE0("Calling Help on GTT\n") ;
		ThisApp().WinHelp(0x20000 + IDR_GLYPHMAP) ;
		return 1 ;
	} ;
	*/

	// From here on, only messages (usually keys) for the REC are interesting
	// so process the rest normally and just return.

	if (this != GetFocus() || pMsg->message != WM_KEYUP)
		return CRichEditView::PreTranslateMessage(pMsg) ;

	// Handle matching brace command

	if (GetKeyState(VK_CONTROL) & 0x8000) {
		//TRACE("KEY = %d, 0x%x\n", pMsg->wParam, pMsg->wParam) ;
		
		// Process goto matching brace commands.

		if (pMsg->wParam == 0xDD)
	 		GotoMatchingBrace() ;
	} ;

	// Process the message normally.

	return CRichEditView::PreTranslateMessage(pMsg) ;
}


/******************************************************************************

  CGPDViewer::OnSrchNextBtn

  Search forward for the next part of the GPD that matches the specified text.

******************************************************************************/

void CGPDViewer::OnSrchNextBtn()
{
	SearchTheREC(true) ;
}


/******************************************************************************

  CGPDViewer::OnSrchPrevBtn

  Search backward for the previous part of the GPD that matches the specified
  text.

******************************************************************************/

void CGPDViewer::OnSrchPrevBtn()
{
	SearchTheREC(false) ;
}


/******************************************************************************

  CGPDViewer::SearchTheREC

  Search either forward or backward for the next part of the GPD that matches
  the specified text.  Select the matching text in the GPD.

  Return true if a match is found.  Otherwise, return false.

******************************************************************************/

bool CGPDViewer::SearchTheREC(bool bforward)
{
	CMainFrame *pcmf = (CMainFrame*) GetTopLevelFrame() ;
	ASSERT(pcmf != NULL) ;
	CString cstext ;
	pcmf->GetGPDSearchString(cstext) ;
	int nstlen ;
	if ((nstlen = cstext.GetLength()) == 0) {
        AfxMessageBox(IDS_BadSearchString) ;
		return false ;
	} ;

	// Declare the find text structure and get a reference to the REC.  Then
	// get the character range for the text currently selected in the REC.
	// This info will be used to compute the search range.

	FINDTEXTEX fte ;
    CRichEditCtrl& crec = GetRichEditCtrl() ;
	crec.GetSel(fte.chrg) ;

	// Set the search range.  If searching forward, search from the current
	// selection to the end of the GPD.  If searching backwards, search from
	// the current selection to the beginning of the GPD.
	//
	// DEAD_BUG	Is the latter correct???

	int norgcpmin = fte.chrg.cpMin ;
	int norgcpmax = fte.chrg.cpMax ;
	if (bforward) {
		fte.chrg.cpMin = fte.chrg.cpMax ;
		fte.chrg.cpMax = -1 ;
	} else {
		fte.chrg.cpMin = 0 ;
		fte.chrg.cpMax = norgcpmin ;
	} ;

	// Load a pointer to the search string into the fte.

	fte.lpstrText = cstext.GetBuffer(nstlen + 1) ;

	// Perform the first attempt at finding a match.

	int nmatchpos ;
	if (bforward)
		nmatchpos = crec.FindText(0, &fte) ;
	else
		nmatchpos = ReverseSearchREC(crec, fte, norgcpmin, norgcpmax) ;

	// If the match failed, try to search the other part of the GPD.  Return
	// failure if this doesn't work either.

/*	if (nmatchpos == -1) {
		if (bforward) {
			fte.chrg.cpMin = 0 ;
			fte.chrg.cpMax = norgcpmax ;
		} else {
			fte.chrg.cpMin = norgcpmin ;
			fte.chrg.cpMax = -1 ;
		} ;
		if (bforward)
			nmatchpos = crec.FindText(0, &fte) ;
		else			
			nmatchpos = ReverseSearchREC(crec, fte, norgcpmin, norgcpmax) ;
*/	if (nmatchpos == -1) {
		cstext.ReleaseBuffer() ;
		CString csmsg ;
		csmsg.Format(IDS_GPDStringSearchFailed, cstext) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return false ;
	} ;


	// A match was found so select it.

	crec.SetSel(nmatchpos, nmatchpos + nstlen) ;

	// A match was found and selected so return true.

	cstext.ReleaseBuffer() ;
	return true ;
}


/******************************************************************************

  CGPDViewer::ReverseSearchREC

  The REC's built in searching support does not search backwards so this
  routine is used to do this.  The text in the specified range is loaded
  into a string and searched.

  The index of the match is returned if one is found.  Otherwise, return -1.

******************************************************************************/

int CGPDViewer::ReverseSearchREC(CRichEditCtrl& crec, FINDTEXTEX& fte,
								 int norgcpmin, int norgcpmax)
{
	// Hide selections to prevent flashing

	crec.HideSelection(TRUE, TRUE) ;

	// Get the index of the last character in the GPD if it is needed.

	int nresult ;
	if (fte.chrg.cpMax == -1) {
		crec.SetSel(0, -1) ;
		nresult = fte.chrg.cpMin ;
		crec.GetSel(fte.chrg) ;
		fte.chrg.cpMin = nresult ;
	} ;

	// Get the text in the part of the GPD we need to check.

	crec.SetSel(fte.chrg) ;
	CString cstext = crec.GetSelText() ;

	// Search the string backwards
									
	cstext.MakeReverse() ;
	cstext.MakeUpper() ;
	CString csrevsrch = fte.lpstrText ;
	csrevsrch.MakeReverse() ;
	csrevsrch.MakeUpper() ;
	nresult = cstext.Find(csrevsrch) ;

	// If a match is found, "reverse" the number to reverse the affects of
	// reversing the strings.
	
	if (nresult >= 0) {
		nresult = fte.chrg.cpMax - fte.chrg.cpMin - nresult
				  - csrevsrch.GetLength() ;
	
		// Adjust the offset of the matching string when necessary.  We want a
		// REC index not a string index.

		if (fte.chrg.cpMin != 0)
			nresult += fte.chrg.cpMin - 2 ;
	} ;

	// Reset the original selection, show selections again, and return the
	// result.

	crec.SetSel(norgcpmin, norgcpmax) ;
	crec.HideSelection(FALSE, TRUE) ;
	return nresult ;
}


/******************************************************************************

  CGPDViewer::OnGotoGPDLineNumber

  Goto the requested GPD line number in the REC.

******************************************************************************/

void CGPDViewer::OnGotoGPDLineNumber()
{
	// Declare the Goto Line dialog box and set the maximum line number.

	CGotoLine cgl ;
    CRichEditCtrl& crec = GetRichEditCtrl() ;
	cgl.SetMaxLine(crec.GetLineCount()) ;

	// Display the dialog box and exit if the user cancels.

	if (cgl.DoModal() == IDCANCEL)
		return ;

	// Get the line number.  Then, determine the line's first character number
	// and its length.

	int nlinenum = cgl.GetLineNum() ;
	CString csline ;
	int nstartchar = crec.LineIndex(-1 + nlinenum) ;
	int nlinelen = crec.GetLine(nlinenum - 1, csline.GetBuffer(1024), 1024) ;
	csline.ReleaseBuffer(nlinelen) ;
	nlinelen -= 2 ;

	// Select the requested line and scroll it into view.

    crec.SetSel(nstartchar, nstartchar + nlinelen) ;
    crec.LineScroll(nlinenum  - (5 + crec.GetFirstVisibleLine())) ;

	// All went well so...

	return ;
}


/******************************************************************************

  CGPDViewer::OnFileErrorLevel

  Get and save the newly selected error level.

******************************************************************************/

void CGPDViewer::OnFileErrorLevel()
{
	// Initialize and display the error level dialog box.  Just return if the
	// user cancels.

	CErrorLevel	cel ;
	cel.SetErrorLevel(m_nErrorLevel) ;
	if (cel.DoModal() == IDCANCEL)
		return ;

	// Save the new error level

	m_nErrorLevel =	cel.GetErrorLevel() ;
}


/******************************************************************************

  CGPDViewer::GotoMatchingBrace

  Find and goto the matching brace in the REC.  The following types of braces
  are matched:
	(), {}, [], <>

  If there is a brace to match and a match is found, move the cursor to the
  left of the matching brace and make sure the line containing the brace is
  visible.  Return true in this case.

  If there is no brace to match or a match cannot be found, just beep and
  return false.

  In the case where the cursor is in between two braces, the one to the right
  of the cursor is matched.	 If 1+ characters are actually selected, only
  check the last character to see if it is a brace to match.

******************************************************************************/

bool CGPDViewer::GotoMatchingBrace()
{
	// Get a reference to the REC and hide selections in it because this
	// routine might change the selection several times and I don't want the
	// screen to flash as the selection changes.

    CRichEditCtrl& crec = GetRichEditCtrl() ;
    crec.LockWindowUpdate() ;
    crec.HideSelection(TRUE, TRUE) ;

	// Get the selection range and make a copy of it.  Increase the copy by one
	// on each side if the min and max are the same.  This is done to find
	// match characters when there is no selection.  Use the copy to set and get
	// the selection.

	CHARRANGE crorg, cr ;
	crec.GetSel(crorg) ;
	cr.cpMin = crorg.cpMin ;
	cr.cpMax = crorg.cpMax ;
	bool bchecksecondchar = false ;
	if (cr.cpMin == cr.cpMax) {
		cr.cpMax++ ;
		if (cr.cpMin > 0)		// Do go passed beginning of file and maintain
			cr.cpMin-- ;		// string length.
		else
			cr.cpMax++ ;
		crec.SetSel(cr) ;
		bchecksecondchar = true ;
	} ;
	CString cssel = crec.GetSelText() ;

	// HACK ALERT - There seems to be a bug in the REC that will return the
	// wrong characters if the cursor is flush left (at the beginning of
	// the line and cpMin is reduced so the characters requested span a
	// line.  This is determined by the cssel beginning with CR+LF.  When this
	// is detected, reset bchecksecondchar because in brace will be the last
	// character in the string so things will work fine if bchecksecondchar is
	// reset.  CpMin needs to be adjusted too.

	bool bbegline = false ;
	if (bchecksecondchar && cssel.GetLength() >= 2 && cssel[0] == 0xD
	 && cssel[1] == 0xA) {
		bchecksecondchar = false ;
		cr.cpMin = cr.cpMax - 1 ;
		bbegline = true ;
	} ;

	// Try to find a brace to match in the selection (opening character) and
	// use this info to set the matching brace (closing character).  If this
	// fails, reset everything, beep, and return.

	TCHAR chopen, chclose ;		// Opening/closing characters to match
	int noffset ;				// Offset in REC for brace to match
	bool bsearchup ;			// True iff must search up in REC for match
	if (!IsBraceToMatch(cssel, chopen, chclose, bchecksecondchar, bsearchup,
	 cr, noffset)) {
		crec.SetSel(crorg) ;
		crec.HideSelection(FALSE, TRUE) ;
		crec.UnlockWindowUpdate() ;
		MessageBeep(0xFFFFFFFF) ;
		return false ;
	} ;

	// Determine the starting and ending range to search.

	if (bsearchup) {
		cr.cpMin = 0 ;
		cr.cpMax = noffset ;
		if (bbegline)			// One more tweak to get around the bug
			cr.cpMax -= 2 ;
	} else {
		cr.cpMin = noffset + 1 ;
		cr.cpMax = -1 ;
	} ;

	// Get the text we want to search.

	crec.SetSel(cr) ;
	cssel = crec.GetSelText() ;

	// Set the loop counter, loop counter increment, and loop limit that will
	// cause a search up (backwards) or down (forwards).

	int nidx, nloopinc, nlimit ;
	if (bsearchup) {
		nidx = cssel.GetLength() - 1 ;
		nloopinc = -1 ;
		nlimit = -1 ;
	} else {
		nidx = 0 ;
		nloopinc = 1 ;
		nlimit = cssel.GetLength() ;
	} ;

	// Loop through the text checking characters for a matching brace.  The
	// brace count is incremented when an opening brace if found and decremented
	// when a closing brace is found.  The matching brace has been found when
	// the brace count reaches 0.

	int nbracecount = 1 ;		// Count first opening brace
	for ( ; nidx != nlimit && nbracecount != 0 ; nidx += nloopinc) {
		if (cssel[nidx] == chclose)
			nbracecount-- ;
		else if (cssel[nidx] == chopen)
			nbracecount++ ;
	} ;

	// Reset everything, beep, and return false if no matching brace was found.

	if (nbracecount != 0) {
		crec.SetSel(crorg) ;
		crec.HideSelection(FALSE, TRUE) ;
		crec.UnlockWindowUpdate() ;
		MessageBeep(0xFFFFFFFF) ;
		return false ;
	} ;

	// Determine the REC based range needed to put the cursor to the left of
	// the matching brace.  The method used to do this depends on the search
	// direction.  Then set the selection.

	if (bsearchup)
		cr.cpMin = cr.cpMax = nidx + 1 ;
	else
		cr.cpMin = cr.cpMax = cr.cpMin + nidx - 1 ;
	crec.SetSel(cr) ;

	// Scroll the line containing the matching brace into view iff it is not
	// already visible.

	int nline = crec.LineFromChar(cr.cpMin) ;
	if (!IsRECLineVisible(nline)) {
		if (bsearchup)
			crec.LineScroll(nline - (2 + crec.GetFirstVisibleLine())) ;
		else
			crec.LineScroll(nline - (5 + crec.GetFirstVisibleLine())) ;
	} ;

	// Show the selection again and return true to indicate a match was found.

    crec.HideSelection(FALSE, TRUE) ;
    crec.UnlockWindowUpdate() ;
	return true ;				
}


/******************************************************************************

  CGPDViewer::IsBraceToMatch

  Find out if there is a brace to match.  Return true if there is and save that
  brace as the opening character and save its matching brace as the closing
  character.  In addition, determine and save the REC offset for the opening
  character.  Last, set a flag to tell if searching for the match should go
  up into the REC or down into the REC based the opening character being the
  right or left brace.  If no opening brace is found, return false.

  In the case where the cursor is in between two braces, the one to the right
  of the cursor is matched.	 If 1+ characters are actually selected, only
  check the last character to see if it is a brace to match.

******************************************************************************/

bool CGPDViewer::IsBraceToMatch(CString& cssel, TCHAR& chopen, TCHAR& chclose,
								bool bchecksecondchar, bool& bsearchup,
								CHARRANGE cr, int& noffset)
{
	int nsellen = cssel.GetLength() ;	// Length of selection string

	// Loop through the character(s) to be checked.

	chclose = 0 ;
	for (int n = 1 ; n >= 0 ; n--) {
		// Use the type of selection and the iteration to determine which - if
		// any - character to check and that character's offset.

		if (bchecksecondchar) {
			if (n >= nsellen)
				continue ;
			chopen = cssel[n] ;
			noffset = cr.cpMin + n ;
		} else if (n == 0) {
			chopen = cssel[nsellen - 1] ;
			noffset = cr.cpMin + nsellen - 1 ;
		} else
			continue ;

		// Check all of the left braces.  If an one is found, save its right
		// brace.  A left brace as an opening character means that the REC
		// must be searched down.

		bsearchup = false ;
		if (chopen == _T('('))
			chclose = _T(')') ;
		if (chopen == _T('{'))
			chclose = _T('}') ;
		if (chopen == _T('['))
			chclose = _T(']') ;
		if (chopen == _T('<'))
			chclose = _T('>') ;

		// If we have a closing character, a match was found and all the needed
		// info has been saved so return true.

		if (chclose != 0)
			return true ;

		// Check all of the right braces.  If an one is found, save its left
		// brace.  A right brace as an opening character means that the REC
		// must be searched up.

		bsearchup = true ;
		if (chopen == _T(')'))
			chclose = _T('(') ;
		if (chopen == _T('}'))
			chclose = _T('{') ;
		if (chopen == _T(']'))
			chclose = _T('[') ;
		if (chopen == _T('>'))
			chclose = _T('<') ;

		// If we have a closing character, a match was found and all the needed
		// info has been saved so return true.

		if (chclose != 0)
			return true ;
	} ;

	// If this point is reached, no brace was found so...

	return false ;
}


/******************************************************************************

  CGPDViewer::InitGPDKeywordArray

  Build a sorted array of GPD keyword strings.  This array is used to find and
  colorize keywords, etc.

******************************************************************************/

extern "C" PSTR GetGPDKeywordStr(int nkeyidx, PGLOBL pglobl) ;
extern "C" int InitGPDKeywordTable(PGLOBL pglobl) ;

void CGPDViewer::InitGPDKeywordArray()
{
	// Begin by getting a reference to the array and setting its initial size.

    GLOBL   globl;

    PGLOBL pglobl = &globl;


	CStringArray& csakeys = ThisApp().GetGPDKeywordArray() ;
	csakeys.SetSize(400) ;

	// Initialize the GPD keyword table and save its size.  Shrink the array
	// and return if this fails.

	int numtabents ;
	if ((numtabents = InitGPDKeywordTable(pglobl)) == -1) {
		csakeys.SetSize(0) ;
		return ;
	} ;

	// Declare variables needed to insert elements into the array.

	int nelts = 0 ;				// Number of elements used in the array
	int nleft, nright, ncomp ;	// Variables needed for searching of array
	int ncheck ;
	LPSTR lpstrkey ;			// Pointer to current keyword

	// Get all of the GPD keywords and use them to make a sorted array of
	// keyword strings.

	for (int nkeyidx = 0 ; nkeyidx <= numtabents ; nkeyidx++) {
		// Get the next string pointer.  Skip it if the pointer is NULL.

		if ((lpstrkey = GetGPDKeywordStr(nkeyidx, pglobl)) == NULL)
			continue ;

		// Skip the curly braces that are in the keyword list.

		if (strcmp(lpstrkey, _T("{")) == 0 || strcmp(lpstrkey, _T("}")) == 0)
			continue ;

		// Now find the location to insert this string into the list

		for (nleft = 0, nright = nelts - 1 ; nleft <= nright ; ) {
			ncheck = (nleft + nright) >> 1 ;
			ncomp = csakeys[ncheck].Compare(lpstrkey) ;
			//TRACE("Key[%d] = '%s', Tok = '%s', Comp Res = %d\n", ncheck, csakeys[ncheck], lpstrkey, ncomp) ;
			if (ncomp > 0)
				nright = ncheck - 1 ;
			else if (ncomp < 0)
				nleft = ncheck + 1 ;
			else
				break ;
		} ;

		// Insert the new string at the correct spot in the array.

		csakeys.InsertAt(nleft, lpstrkey) ;

		// Count this element and assert if the array limit has been reached.

		nelts++ ;
		ASSERT(nelts < 400) ;
	} ;

	// Now that we know the actual number of keywords, shrink the array to its
	// correct size.

	csakeys.SetSize(nelts) ;

	// Either something is wrong with my array building code above or something
	// is wrong with the CStringArray class because the array isn't sorted
	// perfectly.  There are a few problems.  The code below is meant to fix
	// those problems.  The sorting algorithm is slow but it only has to be
	// run once and few strings need to be moved so it should be ok.

	int nidx1, nidx2 ;
	CString cstmp ;
	for (nidx1 = 0 ; nidx1 < nelts - 1 ; nidx1++) {
		for (nidx2 = nidx1 + 1 ; nidx2 < nelts ; nidx2++) {
			if (csakeys[nidx1].Compare(csakeys[nidx2]) > 0) {
				cstmp = csakeys[nidx1] ;
				csakeys[nidx1] = csakeys[nidx2] ;
				csakeys[nidx2] = cstmp ;
			} ;
		} ;
	} ;

	/*
	// Testing code used to make sure the array is sorted in ascending order.

	CString cs1, cs2 ;
	int x, y, z ;
	for (x = 0 ; x < (nelts - 1) ; x++) {
		if (csakeys[x].Compare(csakeys[x+1]) > 0) {
			cs1 = csakeys[x] ;
			cs2 = csakeys[x+1] ;
		} ;
	} ;
	*/

	// Dump the contents of the sorted keyword array.
	
	//for (nleft = 0 ; nleft < nelts ; nleft++)
	//	TRACE("%4d   %s\n", nleft, csakeys[nleft]) ;
}


/******************************************************************************

  CGPDViewer::IsRECLineVisible

  Return true if the specified line is visible in the REC's window.  Otherwise,
  return false.  If the specified line is -1 (the default), check the current
  line.

  Visibility is determined by getting the rect for the REC's window and - based
  on the line number and height - determine if the line is in that rect.

******************************************************************************/

bool CGPDViewer::IsRECLineVisible(int nline /*= -1*/)
{
	// Get a reference to the REC.

    CRichEditCtrl& crec = GetRichEditCtrl() ;

    //  Determine the height of lines in the REC's window.

    int ntopline = crec.GetFirstVisibleLine() ;
    int nlineheight = crec.GetCharPos(crec.LineIndex(ntopline+1)).y -
        crec.GetCharPos(crec.LineIndex(ntopline)).y ;

	// Determine the current line number if needed

	CHARRANGE cr ;
	if (nline == -1) {
		crec.GetSel(cr) ;
		nline = crec.LineFromChar(cr.cpMin) ;
	} ;

	// Get the dimensions of the REC's window

	CRect crwindim ;
    crec.GetClientRect(crwindim) ;

	// Return true if the bottom of the line is above the bottom of the
	// REC's window.

    return (crec.GetCharPos(crec.LineIndex(nline)).y + nlineheight <
		    crwindim.bottom - 1)  ;
}


LPTSTR	CGPDViewer::alptstrStringIDKeys[] = {	// Keywords with string ID values
	_T("*rcModelNameID"),
	_T("*rcInstalledOptionNameID"),
	_T("*rcNotInstalledOptionNameID"),
	_T("*rcInstallableFeatureNameID"),
	_T("*rcNameID"),
	_T("*rcPromptMsgID"),
	_T("*rcInstallableFeatureNameID"),
	_T("*rcNameID"),
	_T("*rcCartridgeNameID"),
	_T("*rcTTFontNameID"),
	_T("*rcDevFontNameID"),
	_T("*rcPersonalityID"),
	_T("*rcHelpTextID"),
	NULL
} ;

LPTSTR	CGPDViewer::alptstrUFMIDKeys[] = {		// Keywords with UFM ID values
	_T("*DeviceFonts"),
	_T("*DefaultFont"),
	_T("*MinFontID"),
	_T("*MaxFontID"),
	_T("*Fonts"),
	_T("*PortraitFonts"),
	_T("*LandscapeFonts"),
	NULL
} ;

/******************************************************************************

  CGPDViewer::OnLButtonDblClk

  If the user clicked on the RC ID for a string or a UFM, start the String
  Editor or the UFM Editor.  In the latter case, load the specified UFM into
  the editor.

  Current restrictions:
	o This instance of the GPD Editor must have been started from the Workspace
	  view.
	o Only numeric RC IDs are supported.  Macros representing an ID are not
	  supported.

******************************************************************************/

void CGPDViewer::OnLButtonDblClk(UINT nFlags, CPoint point)
{
// Do default double click processing first so that whatever the user
	// clicked on will be selected.
	
	CRichEditView::OnLButtonDblClk(nFlags, point) ;

	// Do no further processing if GPD editing aids have been disabled.	
	if (!m_bEditingAidsEnabled)
		return ; 

	// Another editor can only be started when the GPD Editor was run from the
	// workspace view.

//	if (!GetDocument()->GetEmbedded())
//		return ;

	// Get reference for the REC and get the selected text.

    CRichEditCtrl& crec = GetRichEditCtrl() ;
	CString cssel = crec.GetSelText() ;

	// Try to turn the selected text into a number.  Return if this doesn't
	// work or the number is negative because only positive, numeric RC IDs
	// are supported at this time.

	int nrcid ;
	if ((nrcid = atoi(cssel)) <= 0)
		return ;

	// Get the line containing the current selection

	CHARRANGE cr ;
	crec.GetSel(cr) ;
	int nline = crec.LineFromChar(cr.cpMin) ;
	TCHAR achline[1024] ;
	int numchars = crec.GetLine(nline, achline, 1024) ;
	achline[numchars] = 0 ;
	CString csline = achline ;

	// Do nothing if the number selected was in a comment.

	if (csline.Find(_T("*%")) >= 0
	 && csline.Find(_T("*%")) < cr.cpMin - crec.LineIndex(nline))
		return ;

	// Now try to find a keyword in the line that has a string or UFM ID
	// associated with it.  If no keyword is found in this line and it begins
	// with a plus sign (continuation character), check the previous line.

	bool bstring = false ;		// True iff a string ID was found
	bool bufm = false ;			// True iff a UFM ID was found
	int n ;						// Loop index
	for ( ; ; ) {
		// Try to find a matching string keyword in the current line
		
		for (n = 0 ; alptstrStringIDKeys[n] != NULL ; n++)
			if (csline.Find(alptstrStringIDKeys[n]) >= 0) {
				bstring = true ;
				break ;
			} ;

		// Try to find a matching UFM keyword in the current line
		
		for (n = 0 ; alptstrUFMIDKeys[n] != NULL ; n++)
			if (csline.Find(alptstrUFMIDKeys[n]) >= 0) {
				bufm = true ;
				break ;
			} ;

		// Blow if both types of keywords were found because this case isn't
		// handled correctly.

		ASSERT(!(bstring && bufm)) ;

		// Setup to process the previous line if no match was found and this
		// line starts with a continuation character.  Otherwise, exit the
		// loop or the routine.

		if (bstring || bufm)
			break ;				// *** Loop exits here
		else if (csline[0] != _T('+') || --nline < 0)
			return ;			// *** Routine exits when there is nothing to do
		else {
			numchars = crec.GetLine(nline, achline, 1024) ;
			achline[numchars] = 0 ;
			csline = achline ;
		} ;
	} ;

	// Start the appropriate editor with the appropriate data loaded.
	// Raid 3176 all below if.
	if (!GetDocument()->GetEmbedded()){
		// find the font name in RC file
	
		//1. get rc file name   2. load rc file 3. find font name   4.make array with it's number and file path
			
		//get rc file , assuem rc file is same with DLL name.if not user have to select rc file.
		CString csPath = GetDocument()->GetPathName();
		CString csrfile = csPath.Left(csPath.ReverseFind(_T('\\')) + 1);
		csrfile = csrfile + _T("*.rc"); 
		
		CFileFind cff;
	// raid 201554
		if ( cff.FindFile(csrfile)) {   
			cff.FindNextFile() ;
			csrfile = cff.GetFilePath();
		}
		else
		{
			CString cstmp;
			cstmp.LoadString(IDS_NotFoundRC);
			if ( AfxMessageBox(cstmp,MB_YESNO) == IDYES ) {
				CFileDialog cfd(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
					_T("RC Files (*.rc)|*.rc||") );   
				if(IDCANCEL == cfd.DoModal())
					return ;
				csrfile = cfd.GetFileName();
			}
			else 
				return ;

		}
		
		CWinApp *cwa = AfxGetApp();
		if (bstring){
			// we save RC path, its rcid for the use on StringEditorDoc
		
			cwa->WriteProfileString(_T("StrEditDoc"),_T("StrEditDocS"),csrfile);
			cwa->WriteProfileInt(_T("StrEditDoc"),_T("StrEditDoc"),nrcid );
		}
		// load rc file : only interested in font name
		CString csUFMName;
		if (bufm){ // can use just "else "
			CDriverResources* pcdr = new CDriverResources();
			CStringArray csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5;
			CStringTable cstTemp1, cstFonts, cstTemp2;

			pcdr->LoadRCFile(csrfile , csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5,
						cstTemp1, cstFonts, cstTemp2,Win2000);

			// get font name
			csUFMName = cstFonts[(WORD)nrcid];
			csUFMName = csPath.Left(csPath.ReverseFind(_T('\\')) + 1) + csUFMName ;
			
			}
		// call the document 
		
		POSITION pos = cwa->GetFirstDocTemplatePosition();
		CString csExtName;
		CDocTemplate *pcdt ;
		while (pos != NULL){
			pcdt = cwa -> GetNextDocTemplate(pos);

			ASSERT (pcdt != NULL);
			ASSERT (pcdt ->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

			pcdt ->GetDocString(csExtName, CDocTemplate::filterExt);
			
			if (csExtName == _T(".UFM") & bufm){
				pcdt->OpenDocumentFile(csUFMName,TRUE);
				return;
			}
			if (csExtName == _T(".STR") & bstring){
				pcdt->OpenDocumentFile(NULL) ;
				return;
			}
		}

	
	}
	else{
		CDriverResources* pcdr = (CDriverResources*) GetDocument()->ModelData()->GetWorkspace() ;
		pcdr->RunEditor(bstring, nrcid) ;
	}
}


/******************************************************************************

  CGPDViewer::OnEditEnableAids

  Reverse the state of the "Editing Aids Enabled" flag and reverse the checked
  status of the corresponding menu command.

******************************************************************************/

void CGPDViewer::OnEditEnableAids()
{
	// Reverse the state of the flag

	m_bEditingAidsEnabled = !m_bEditingAidsEnabled ;

	// Reverse the checked status of the menu command

	CMenu* pcm = AfxGetMainWnd()->GetMenu() ;
	UINT ustate = (m_bEditingAidsEnabled) ? MF_CHECKED : MF_UNCHECKED ;
	pcm->CheckMenuItem(ID_EDIT_ENABLE_AIDS, ustate) ;
}


/******************************************************************************

  CGPDViewer::FreezeREC

  Use a COM interface to the REC to freeze its display if possible.  This is
  the most efficient but it is only possible under Win2K+.  In additon, tell the
  REC to ignore change messages.  This is needed even on Win2K+ because the
  messages are generated even when the REC's display is frozen.

******************************************************************************/

void CGPDViewer::FreezeREC()
{
	GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() &
		~(ENM_CHANGE | ENM_SELCHANGE | ENM_SCROLLEVENTS)) ;
	if(!m_pdoc)//raid 104081: click and start : not call OnInitUpdate()
		InitFreeze(GetRichEditCtrl().m_hWnd, &m_punk, &m_pdoc, &m_lcount) ;
	
	if (ThisApp().m_bOSIsW2KPlus)	
		Freeze(m_pdoc, &m_lcount) ;
}


/******************************************************************************

  CGPDViewer::UnfreezeREC

  Use a COM interface to the REC to unfreeze its display if possible.  This is
  only possible under Win2K+.  In additon, tell the REC to process change
  messages again.  This is needed even on Win2K+ because the messages are 
  always disabled by FreezeREC().

******************************************************************************/

void CGPDViewer::UnfreezeREC()
{
	if (ThisApp().m_bOSIsW2KPlus)
		Unfreeze(m_pdoc, &m_lcount) ;
    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() |
		ENM_CHANGE | ENM_SELCHANGE | ENM_SCROLLEVENTS) ;
}



// RAID 0001
void CGPDViewer::OnFileInf() 
{
	
	CINFWizard* pciw = new CINFWizard(this, 1) ;
	
	if (pciw->DoModal() == IDCANCEL) {
		delete pciw ;
		return ;
	} ;

	
	// Generate the INF file based on the information collected.

	if (!pciw->GenerateINFFile()) {
		delete pciw ;
		return ;
	} ;

	// Allocate and initialize the document.

    CINFWizDoc* pciwd = new CINFWizDoc((CGPDContainer*) GetDocument(), pciw) ;

	// Create the window.

    CMDIChildWnd* pcmcwnew ;
	CMultiDocTemplate* pcmdt = INFViewerTemplate() ;
	pcmcwnew = (CMDIChildWnd *) pcmdt->CreateNewFrame(pciwd, NULL) ;

	// If the window was created, finish the initialization.  Otherwise, just 
	// return.

    if  (pcmcwnew) {
        pcmdt->InitialUpdateFrame(pcmcwnew, pciwd, TRUE) ;
        pcmdt->AddDocument(pciwd) ;
	} ;

}

 


/*
LRESULT CGPDViewer::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	return 0 ;
}
*/




/////////////////////////////////////////////////////////////////////////////
// CGotoLine dialog


CGotoLine::CGotoLine(CWnd* pParent /*=NULL*/)
	: CDialog(CGotoLine::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGotoLine)
	m_csLineNum = _T("");
	//}}AFX_DATA_INIT

	m_nMaxLine = m_nLineNum = -1 ;
}


void CGotoLine::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGotoLine)
	DDX_Control(pDX, IDC_GotoBox, m_ceGotoBox);
	DDX_Text(pDX, IDC_GotoBox, m_csLineNum);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGotoLine, CDialog)
	//{{AFX_MSG_MAP(CGotoLine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGotoLine message handlers

void CGotoLine::OnOK()
{
	// Get the line number string.  Complain and exit if there is no line number.

	CString cserror ;
	UpdateData(TRUE) ;
	if (m_csLineNum == _T("")) {
		cserror.Format(IDS_BadGotoLineNum, m_csLineNum) ;
        AfxMessageBox(cserror) ;
		m_ceGotoBox.SetFocus() ;
		return ;
	} ;

	// Convert the line number string to a number.  Complain if the number is
	// invalid or too large.

	m_nLineNum = atoi(m_csLineNum) ;
	if (m_nLineNum < 1 || m_nLineNum > m_nMaxLine) {
		cserror.Format(IDS_BadGotoLineNum, m_csLineNum) ;
        AfxMessageBox(cserror) ;
		m_ceGotoBox.SetFocus() ;
		return ;
	} ;

	// The line number seems ok so...

	CDialog::OnOK();
}




/////////////////////////////////////////////////////////////////////////////
// CErrorLevel dialog


CErrorLevel::CErrorLevel(CWnd* pParent /*=NULL*/)
	: CDialog(CErrorLevel::IDD, pParent)
{
	//{{AFX_DATA_INIT(CErrorLevel)
	m_nErrorLevel = -1;
	//}}AFX_DATA_INIT
}


void CErrorLevel::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CErrorLevel)
	DDX_Control(pDX, IDC_ErrorLevelLst, m_ccbErrorLevel);
	DDX_CBIndex(pDX, IDC_ErrorLevelLst, m_nErrorLevel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorLevel, CDialog)
	//{{AFX_MSG_MAP(CErrorLevel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorLevel message handlers

BOOL CErrorLevel::OnInitDialog()
{
	CDialog::OnInitDialog() ;

	// Blow if the current error level was not set

	ASSERT(m_nErrorLevel != -1) ;
	
	// Set the current error level in the error level list box.

	UpdateData(FALSE) ;
	
	return TRUE ; // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CErrorLevel::OnOK()
{
	// Get the error level selected by the user

	UpdateData() ;
	
	CDialog::OnOK() ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gttview.cpp ===
/******************************************************************************

  Source File:  Glyph Map View.CPP

  This file implements the items that make up the glyph mapping editor

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "GTT.H"
#include    "ChildFrm.H"
#include    "GTTView.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "NewProj.H"
#include    <CodePage.H>
#include    "AddCdPt.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  CGlyphMapView class implementation

  This is the view class for glyph translation tables.  It presents a property
  sheet for display of all of the relevant items in the glyph map.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGlyphMapView, CView)

CGlyphMapView::CGlyphMapView() {
}

CGlyphMapView::~CGlyphMapView() {
}

BEGIN_MESSAGE_MAP(CGlyphMapView, CView)
	//{{AFX_MSG_MAP(CGlyphMapView)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CGlyphMapView::OnInitialUpdate

  This member function is an override which handles the initial call to display
  the view.  It creates the property sheet, positions it within the view, then
  sets the frame size to match.

******************************************************************************/

void CGlyphMapView::OnInitialUpdate() {

    if  (GetDocument() -> GlyphMap() -> Name().IsEmpty()) {
        GetDocument() -> GlyphMap() -> Rename(GetDocument() -> GetTitle());
        GetDocument() -> SetModifiedFlag(FALSE);    //  Rename sets it
    }

    m_cps.Construct(IDR_MAINFRAME, this);
    m_cgmp.Init(GetDocument() -> GlyphMap());
    m_ccpp.Init(GetDocument() -> GlyphMap());
    m_cpm.Init(GetDocument() -> GlyphMap());
    m_cps.AddPage(&m_cgmp);
    m_cps.AddPage(&m_ccpp);
#if defined(NOPOLLO)    //  RAID 106376
    m_cps.AddPage(&m_cpm);
#endif

    m_cps.Create(this, WS_CHILD, WS_EX_CLIENTEDGE);

    CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);
    GetParentFrame() -> CalcWindowRect(crPropertySheet);
    GetParentFrame() -> SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	CView::OnInitialUpdate();
    m_cps.ShowWindow(SW_SHOWNA);
    GetParentFrame() -> ShowWindow(SW_SHOW);
}

void CGlyphMapView::OnDraw(CDC* pDC) {
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}


/******************************************************************************

  CGlyphMapView::SaveBothSelAndDeselStrings

  Save both the codepage, Select and the Deselect strings if they have changed.
  This routine is generally called by the document class to make sure this
  data is copied into the GTT before the GTT is saved.

******************************************************************************/

void CGlyphMapView::SaveBothSelAndDeselStrings() 
{
	m_ccpp.SaveBothSelAndDeselStrings() ;
}


/////////////////////////////////////////////////////////////////////////////
// CGlyphMapView diagnostics

#ifdef _DEBUG
void CGlyphMapView::AssertValid() const {
	CView::AssertValid();
}

void CGlyphMapView::Dump(CDumpContext& dc) const {
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapView message handlers

void CGlyphMapView::OnDestroy() {
	CView::OnDestroy();
	
	if  (GetDocument() -> GlyphMap())
        GetDocument() -> GlyphMap() -> OnEditorDestroyed();
	
}

/******************************************************************************

  CGlyphMapView::OnActivateView

  For some reason, the property sheet does not get the focus when the frame is
  activated (probably the view class takes it away from us).  This member
  function guarantees keyboard afficionados aren't perturbed by this.

******************************************************************************/

void CGlyphMapView::OnActivateView(BOOL bActivate, CView* pActivateView,
                                   CView* pDeactiveView) {

	CView::OnActivateView(bActivate, pActivateView, pDeactiveView);

    if  (bActivate)
        m_cps.SetFocus();
}

/******************************************************************************

  CGlyphMappingPage class

  This class implements the property page for viewing and editing the gory code
  point-by-code point details.

******************************************************************************/

//  Even before the constructor, we have the list sorting routine
int CALLBACK    CGlyphMappingPage::MapSorter(LPARAM lp1, LPARAM lp2,
                                             LPARAM lpThis) {
    //  A negative return means the first is less...

    //  First, let's uncast those LPARAMs
    CGlyphMappingPage   *pcgmp = (CGlyphMappingPage *) lpThis;
    CGlyphHandle *pcgh1 = (CGlyphHandle*) lp1;
    CGlyphHandle *pcgh2 = (CGlyphHandle*) lp2;

    //  We'll use 3 columns to store the sort possibilities.
    int aiResult[Columns];
    aiResult[Codes] = pcgh1 -> CodePoint() - pcgh2 -> CodePoint();
    aiResult[Pages] = pcgh1 -> CodePage() - pcgh2 -> CodePage();
    CString cs1, cs2;
    pcgh1 -> GetEncoding(cs1);
    pcgh2 -> GetEncoding(cs2);
    aiResult[Strings] = lstrcmp(cs1, cs2);

    if  (aiResult[pcgmp -> m_bSortFirst])
        return  pcgmp -> m_abDirection[pcgmp -> m_bSortFirst] ?
        aiResult[pcgmp -> m_bSortFirst] : -aiResult[pcgmp -> m_bSortFirst];

    if  (aiResult[pcgmp -> m_bSortSecond])
        return  pcgmp -> m_abDirection[pcgmp -> m_bSortSecond] ?
        aiResult[pcgmp -> m_bSortSecond] : -aiResult[pcgmp -> m_bSortSecond];

    return  pcgmp -> m_abDirection[pcgmp -> m_bSortLast] ?
        aiResult[pcgmp -> m_bSortLast] : -aiResult[pcgmp -> m_bSortLast];
}

/******************************************************************************

  CGlyphMappingPage constructor

  As befits a class of this complexity, there's a bit of work to do here.

******************************************************************************/

CGlyphMappingPage::CGlyphMappingPage() :
    CPropertyPage(CGlyphMappingPage::IDD) {

    m_pcgm = NULL;
    for (unsigned u = 0; u < Columns; u++)
        m_abDirection[u] = TRUE;

    m_bSortFirst = Codes;
    m_bSortSecond = Strings;
    m_bSortLast = Pages;
    m_bJustChangedSelectString = FALSE;
    m_uTimer = m_uidGlyph = 0;

	//{{AFX_DATA_INIT(CGlyphMappingPage)
	//}}AFX_DATA_INIT
}

CGlyphMappingPage::~CGlyphMappingPage() {
}

void CGlyphMappingPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGlyphMappingPage)
	DDX_Control(pDX, IDC_Banner, m_cpcBanner);
	DDX_Control(pDX, IDC_GlyphMapping, m_clcMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGlyphMappingPage, CPropertyPage)
	//{{AFX_MSG_MAP(CGlyphMappingPage)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_GlyphMapping, OnEndlabeleditGlyphMapping)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_GlyphMapping, OnItemchangedGlyphMapping)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_GlyphMapping, OnColumnclickGlyphMapping)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_GlyphMapping, OnGetdispinfoGlyphMapping)
	ON_NOTIFY(LVN_KEYDOWN, IDC_GlyphMapping, OnKeydownGlyphMapping)
	ON_WM_TIMER()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_ChangeInvocation, OnChangeInvocation)
    ON_COMMAND(ID_ChangeCodePage, OnChangeCodePage)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_AddItem, OnAddItem)
END_MESSAGE_MAP()

/******************************************************************************

  CGlyphMappingPage::OnInitDialog

  This member intializes the controls on this page, which in this case means a
  list view with a sizeable numer of items.

******************************************************************************/

BOOL CGlyphMappingPage::OnInitDialog() {
	CPropertyPage::OnInitDialog();
	
	//  Initialize the list control
    CString csWork;

    csWork.LoadString(IDS_MapColumn0);
    m_clcMap.InsertColumn(0, csWork, LVCFMT_LEFT,
        m_clcMap.GetStringWidth(csWork) * 2, 2);

    csWork.LoadString(IDS_MapColumn1);
    m_clcMap.InsertColumn(1, csWork, LVCFMT_LEFT,
        m_clcMap.GetStringWidth(csWork) * 2, 1);

    csWork.LoadString(IDS_MapColumn2);
    m_clcMap.InsertColumn(2, csWork, LVCFMT_LEFT,
        m_clcMap.GetStringWidth(csWork) * 2, 0);

    m_lPredefinedID = m_pcgm -> PredefinedID();

    //  Put up a message about the wait, then kick off a quick timer so the
    //  message is seen...

    m_uTimer = (unsigned)SetTimer(IDD, 100, NULL);

    if  (!m_uTimer) {
        CWaitCursor cwc;
        OnTimer(m_uTimer);
    }

	//LoadCharMapList() ;

	return TRUE;
}

/******************************************************************************

  CGlyphMappingPage::OnContextMenu

  This member function is called when a right-click with the mouse is detected.
  If it is within the area of the list view, we display an appropriate context
  menu.  Otherwise, we default to the normal system handling of the message.

******************************************************************************/

void CGlyphMappingPage::OnContextMenu(CWnd* pcw, CPoint cpt) {
	CPoint  cptThis = cpt;

    m_clcMap.ScreenToClient(&cptThis);

    //  Toss it out if it isn't within the view.

    CRect   crMap;
    m_clcMap.GetClientRect(crMap);
    if  (!crMap.PtInRect(cptThis))
        return;

    cptThis.x = 5;  //  Keep it well within the first column

    int idContext = m_clcMap.HitTest(cptThis);
    if  (idContext == -1) {   //  Nothing selected, allow the "Add" item
        CMenu   cmThis;
        CString csWork;

        cmThis.CreatePopupMenu();
        csWork.LoadString(ID_AddItem);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
        cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y,
            this);

        return;
    }

    m_clcMap.SetItemState(idContext, LVIS_SELECTED | LVIS_FOCUSED,
        LVIS_SELECTED | LVIS_FOCUSED);

    CMenu   cmThis;
    CString csWork;

    cmThis.CreatePopupMenu();
    csWork.LoadString(ID_ChangeInvocation);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeInvocation,
        csWork);

    if  (m_pcgm -> CodePages() > 1) {
        csWork.LoadString(ID_ChangeCodePage);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeCodePage,
            csWork);
    }

    cmThis.AppendMenu(MF_SEPARATOR);
    csWork.LoadString(ID_AddItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
    csWork.LoadString(ID_DeleteItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_DeleteItem,
        csWork);

    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y, this);
}

/******************************************************************************

  CGlyphMappingPage::OnChangeInvocation

  Called when the user decides to change the invocation for the code point.
  Simply initiate a label edit.

******************************************************************************/

void    CGlyphMappingPage::OnChangeInvocation() {
    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;

    m_clcMap.EditLabel(idContext);
}

/******************************************************************************

  CGlyphMappingPage::OnChangeCodePage

  This handles a code page change request.

******************************************************************************/

void    CGlyphMappingPage::OnChangeCodePage() {

    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;
    //  Create a string naming the item, and invoke the CSelectCodePage
    //  dialog...

    CGlyphHandle *pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);

    CSelectCodePage cscp(this, m_pcgm -> Name() + _TEXT(" ") +
        m_clcMap.GetItemText(idContext, 1),
        m_pcgm -> PageID(pcgh -> CodePage()));

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);
    cdaPages.RemoveAt(pcgh -> CodePage());

    cscp.LimitTo(cdaPages);

    if  (cscp.DoModal() != IDOK)
        return;

    //  Change the code page.   For maximum flexibility, we'll use an array
    //  for this.  This is because if this is to correct a perceived mistake,
    //  the codes should be translated to MBCS and then back.

    //  NOTE: This was also to support multiple selection, which isn't allowed.

    CPtrArray   cpaThis;
    cpaThis.Add((void *) m_clcMap.GetItemData(idContext));
    m_pcgm -> ChangeCodePage(cpaThis, cscp.SelectedCodePage());

    m_clcMap.SetItemText(idContext, 2, cscp.GetCodePageName());
}

/******************************************************************************

  CGlyphMappingPage::OnDeleteItem

  This handles the Delete Item message from the context menu, by verifying
  this is what is wanted, and then doing it.

******************************************************************************/

void    CGlyphMappingPage::OnDeleteItem() {
    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;

    if  (IDYES != AfxMessageBox(IDS_DeleteItemQuery,
         MB_YESNO | MB_ICONQUESTION))
        return;

    //  Delete the entry from the glyph map
    CGlyphHandle*   pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);
    m_pcgm -> DeleteGlyph(pcgh -> CodePoint());

    m_clcMap.DeleteItem(idContext);
    _ASSERTE((unsigned) m_clcMap.GetItemCount() == m_pcgm -> Glyphs());
}

/******************************************************************************

  CGlyphMappingPage::OnAddItem

  This is called whenever the user wishes to add new code points to the map.  I
  ask the glyph map which points exist, and if there are any, invoke a modal
  dialog to allow the selection of new glyphs.

******************************************************************************/

void    CGlyphMappingPage::OnAddItem() {

    CMapWordToDWord cmw2dAvailable;

    m_pcgm -> UndefinedPoints(cmw2dAvailable);

    if  (!cmw2dAvailable.Count()) {
        AfxMessageBox(IDS_NoUnmappedGlyphs);
        return;
    }

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);

    CAddCodePoints  cacp(this, cmw2dAvailable, cdaPages, m_pcgm -> Name());

    if  (cacp.DoModal() != IDOK)    return;

    //  The map will now contain only the new code points...
    m_pcgm -> AddPoints(cmw2dAvailable);

    m_uTimer = (unsigned) SetTimer(IDD, 10, NULL);

    if  (!m_uTimer)
        OnTimer(m_uTimer);

    //  Reset the sort criteria so we don't have to sort the data
    for (unsigned u = 0; u < Columns; u++)
        m_abDirection[u] = TRUE;

    m_bSortFirst = Codes;
    m_bSortSecond = Strings;
    m_bSortLast = Pages;
}


/******************************************************************************

  CGlyphMappingPage::OnEndlabeleditGlyphMapping

  This is called when a user clicks outside the edit control to end editing of
  a selection string.  We pass the string down, and do some finagling to force
  the system to accept the value as we display it, which isn't as the user
  typed it, in some cases.

******************************************************************************/

void CGlyphMappingPage::OnEndlabeleditGlyphMapping(NMHDR* pnmh, LRESULT* plr) 
{
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;

	// Pass the new invocation string to the glyph map to handle
    CGlyphHandle*   pcgh = (CGlyphHandle*) plvdi -> item.lParam;
    m_pcgm -> ChangeEncoding(pcgh -> CodePoint(), plvdi -> item.pszText);

    m_bJustChangedSelectString = TRUE;
	
	*plr = TRUE;
}


/******************************************************************************

  CGlyphMappingPage::OnItemchangedGlyphMapping

  This is called whenever anything changes in the list box- we are primarily
  interested in text changes (since we have to adjust encodings once entered)
  and selection changes (so we can move the "cursor" accordingly.

******************************************************************************/

void CGlyphMappingPage::OnItemchangedGlyphMapping(NMHDR* pnmh, LRESULT* plr) 
{
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    //  We only care if this notes a text change in the selected item and we
    //  haven't fixed it, yet.

    if  (pnmlv -> iItem != idContext || !(pnmlv -> uChanged & LVIF_TEXT) ||
        !m_bJustChangedSelectString)
        return;

    CGlyphHandle*   pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);

    CString csWork;
    m_bJustChangedSelectString = FALSE;
    pcgh -> GetEncoding(csWork);
    m_clcMap.SetItemText(idContext, 0, csWork);
	
	*plr = 0;
}


/******************************************************************************

  CGlyphMappingPage::OnColumnclickGlyphMapping

  Called when the user wants to sort the list- so that's what we do!

******************************************************************************/

void CGlyphMappingPage::OnColumnclickGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;
	//  Resort the list based upon the selected column, and the current sort
    //  order

    if  (pnmlv -> iSubItem == m_bSortFirst)
        m_abDirection[m_bSortFirst] = !m_abDirection[m_bSortFirst]; //  Reverse
    else {
        if  (pnmlv -> iSubItem == m_bSortSecond)
            m_bSortSecond = m_bSortFirst;
        else {
            m_bSortLast = m_bSortSecond;
            m_bSortSecond = m_bSortFirst;
        }
        m_bSortFirst = (BYTE)pnmlv -> iSubItem;
    }

    CWaitCursor cwc;    //  On FE tables, this can take a while...

    m_clcMap.SortItems(&MapSorter, (UINT_PTR) this);
	
	*plr = 0;
}


void CGlyphMappingPage::LoadCharMapList()
{
	CWaitCursor cwc ;
    m_clcMap.EnableWindow(FALSE) ;

    CGlyphHandle* pcgh ;
    int idItem ;
    CString csWork ;

    for (unsigned u = 0 ; m_uidGlyph < m_pcgm -> Glyphs() ; u++, m_uidGlyph++) {
        pcgh = m_pcgm->Glyph(m_uidGlyph) ;

        if(pcgh != NULL)
			pcgh->GetEncoding(csWork) ;
        else
		{
			AfxMessageBox(IDS_LoadGTTError);//raid 116604 prefix : this fucntion(LoadCharMapList) are dead
			return ;
		} ;

        idItem = m_clcMap.InsertItem(m_uidGlyph, csWork) ;
        m_clcMap.SetItemData(idItem, (LPARAM) pcgh) ;

        csWork.Format(_TEXT("0x%4.4X"), pcgh->CodePoint()) ;
        m_clcMap.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u) ;

        csWork = m_pcgm->PageName(pcgh->CodePage()) ;
        m_clcMap.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u) ;
    }

    m_clcMap.EnableWindow(TRUE) ;
	m_cpcBanner.SetPos(0) ;
	m_cpcBanner.ShowWindow(SW_HIDE) ;
}


/******************************************************************************

  CGlyphMappingPage::OnGetdispinfoGlyphMapping

  This member function is an attempt to speed handling of large tables, and
  also to handle code page changes more gracefully.  All items are initially
  declared as callbacks, so the control requests names for items as they are
  displayed, via this member.

******************************************************************************/

void CGlyphMappingPage::OnGetdispinfoGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;
	
	*plr = 0;

    //  If the window is obstructed when an item is deleted, there might not
    //  be a glpyh at this point, so watch out!

    CGlyphHandle*   pcgh = (CGlyphHandle*) plvdi -> item.lParam;
    if  (!pcgh)
        return;

    CString csWork;

    switch  (plvdi -> item.iSubItem) {
        case    0:
             pcgh -> GetEncoding(csWork);
            break;

        case    1:
            csWork.Format(_TEXT("0x%4.4X"), pcgh -> CodePoint());
            plvdi -> item.mask |= LVIF_DI_SETITEM;  //  This never changes
            break;

        case    2:
            csWork = m_pcgm -> PageName(pcgh -> CodePage());
    }

    lstrcpyn(plvdi -> item.pszText, csWork, plvdi -> item.cchTextMax);
}

/******************************************************************************

  CGlyphMappingPage::OnSetActive

  Called when the page is activated, but after OnInitDialog on the first
  activation.  If the predefined code page ID has changed, we must rebuild the
  page.

******************************************************************************/
// //raid 118880
BOOL CGlyphMappingPage::OnSetActive() {

      m_lPredefinedID = m_pcgm -> PredefinedID();
      m_uTimer = (unsigned) SetTimer(IDD, 10, NULL);

	  m_clcMap.DeleteAllItems();
	  OnTimer(m_uTimer);  

	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CGlyphMappingPage::OnKeydownGlyphMapping

  This is called whenever the user presses a key.  We use it to provide an
  extended interface from the keyboard, to match the other editors.

******************************************************************************/

void    CGlyphMappingPage::OnKeydownGlyphMapping(NMHDR* pnmh, LRESULT* plr)
{
	LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;

    if (plvkd->wVKey == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_GLYPHMAP) ;
		return ;
	} ;

	*plr = 0;

    int idItem = m_clcMap.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);

    if  (idItem == -1) {
        if  (plvkd -> wVKey == VK_F10)
            OnAddItem();
        return;
    }

    switch  (plvkd -> wVKey) {

    case    VK_F2:
        OnChangeInvocation();
        break;

    case    VK_DELETE:
        OnDeleteItem();
        break;

    case    VK_F10: {
            CRect   crItem;

            m_clcMap.GetItemRect(idItem, crItem, LVIR_LABEL);
            m_clcMap.ClientToScreen(crItem);
            OnContextMenu(&m_clcMap, crItem.CenterPoint());
        }
    }
}

/******************************************************************************

  CGlhpyMappingPage::OnTimer

  The only event currently using a timer is the need to fill the list.

******************************************************************************/

void    CGlyphMappingPage::OnTimer(UINT uEvent) {
    if  (uEvent != m_uTimer) {
	    CPropertyPage::OnTimer(uEvent);
        return;
    }

    CString csWork;

    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);

    if  (!m_uidGlyph) {
        m_clcMap.DeleteAllItems();
        m_cpcBanner.SetRange(0, m_pcgm -> Glyphs() -1);
        m_cpcBanner.SetStep(1);
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_SHOW);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        if  (m_uTimer)
            m_clcMap.EnableWindow(FALSE);
        else
            m_clcMap.LockWindowUpdate();
        m_clcMap.SetItemCount(m_pcgm -> Glyphs());
    }

    for (unsigned u = 0;
         m_uidGlyph < m_pcgm -> Glyphs() && (!m_uTimer || u < 100);
         u++, m_uidGlyph++) {

        CGlyphHandle*   pcgh = m_pcgm -> Glyph(m_uidGlyph);

        int idItem = m_clcMap.InsertItem(m_uidGlyph, LPSTR_TEXTCALLBACK);
        m_clcMap.SetItemData(idItem, (LPARAM) pcgh);

        m_clcMap.SetItem(idItem, 1, LVIF_TEXT, LPSTR_TEXTCALLBACK, -1, 0, 0,
            (LPARAM) pcgh);
        m_clcMap.SetItem(idItem, 2, LVIF_TEXT, LPSTR_TEXTCALLBACK, -1, 0, 0,
            (LPARAM) pcgh);
    }

    if  (m_uidGlyph == m_pcgm -> Glyphs()) {
        if  (m_uTimer)
            m_clcMap.EnableWindow(TRUE);
        else
            m_clcMap.UnlockWindowUpdate();
        m_uTimer = 0;
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_HIDE);
        SetFocus();
        m_uidGlyph = 0;
    }

    if  (m_uTimer) {
        m_cpcBanner.SetPos(m_uidGlyph);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        m_uTimer = (unsigned) SetTimer(IDD, 10, NULL);
        if  (!m_uTimer) {
            CWaitCursor cwc;    //  Might be a while...
            m_clcMap.EnableWindow(TRUE);
            m_clcMap.LockWindowUpdate();
            OnTimer(m_uTimer);
        }
    }
}

/******************************************************************************

  CGlyphMappingPage::OnDestroy

  Since this also can be time-consuming, kill the list here, and throw up the
  wait cursor.

******************************************************************************/

void    CGlyphMappingPage::OnDestroy() {
    CWaitCursor cwc;
    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);
    m_clcMap.DeleteAllItems();
	CPropertyPage::OnDestroy();	
}


/******************************************************************************

  CCodePagePage class implementation

  This class implements the code page property page, providing an interface for
  viewing and implementing the code page assignments.

******************************************************************************/

CCodePagePage::CCodePagePage() : CToolTipPage(CCodePagePage::IDD) 
{
	//{{AFX_DATA_INIT(CCodePagePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_uHelpID = HID_BASE_RESOURCE + IDR_GLYPHMAP ;
	m_bInitialized = false ;
	m_bSelDeselChgSignificant = true ;
}


CCodePagePage::~CCodePagePage() {
}

void CCodePagePage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCodePagePage)
	DDX_Control(pDX, IDC_DeletePage, m_cbDelete);
	DDX_Control(pDX, IDC_SelectString, m_ceSelect);
	DDX_Control(pDX, IDC_DeselectString, m_ceDeselect);
	DDX_Control(pDX, IDC_RemovePage, m_cbRemove);
	DDX_Control(pDX, IDC_CodePageList, m_clbPages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCodePagePage, CToolTipPage)
	//{{AFX_MSG_MAP(CCodePagePage)
	ON_EN_KILLFOCUS(IDC_SelectString, OnKillfocusSelectString)
	ON_EN_KILLFOCUS(IDC_DeselectString, OnKillfocusDeselectString)
	ON_BN_CLICKED(IDC_AddPage, OnAddPage)
	ON_LBN_SELCHANGE(IDC_CodePageList, OnSelchangeCodePageList)
	ON_BN_CLICKED(IDC_RemovePage, OnReplacePage)
	ON_EN_CHANGE(IDC_SelectString, OnChangeSelectString)
	ON_EN_CHANGE(IDC_DeselectString, OnChangeDeselectString)
	ON_BN_CLICKED(IDC_DeletePage, OnDeletePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CCodePagePage::OnInitDialog

  This member function handles the WM_INITDIALOG message by initializing the
  various controls of the dialog.

******************************************************************************/

BOOL CCodePagePage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    for (unsigned u = 0; u < m_pcgm -> CodePages(); u++) {
        int id =
            m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
        if  (!u)
            m_clbPages.SetCurSel(id);
    }

    //  Let the list box selection change handler do the rest

    OnSelchangeCodePageList();
	
	m_bInitialized = true ;
	return TRUE;
}


/******************************************************************************

  CCodePagePage::OnChangeSelectString

  Mark the GTT dirty to make sure the new string is saved.

******************************************************************************/

void CCodePagePage::OnChangeSelectString() 
{
	// Only mark the GTT as having changed when this function is called after
	// the GTT Editor and only if this change in the selection string is 
	// significant.  Do nothing when the string change is just because a 
	// previously entered string is being loaded into the control.

	if (m_bInitialized && m_bSelDeselChgSignificant)
		m_pcgm->Changed() ;
}


/******************************************************************************

  CCodePagePage::OnChangeDeselectString

  Mark the GTT dirty to make sure the new string is saved.

******************************************************************************/

void CCodePagePage::OnChangeDeselectString() 
{
	// Only mark the GTT as having changed when this function is called after
	// the GTT Editor and only if this change in the deselection string is 
	// significant.  Do nothing when the string change is just because a 
	// previously entered string is being loaded into the control.

	if (m_bInitialized && m_bSelDeselChgSignificant)
		m_pcgm->Changed() ;
}


/******************************************************************************

  CCodePagePage::OnKillfocusSelectString

  Save the Select String if it has changed.

******************************************************************************/

void CCodePagePage::OnKillfocusSelectString() 
{
	SaveSelDeselString(m_ceSelect, TRUE) ;
}


/******************************************************************************

  CCodePagePage::OnKillfocusDeselectString

  Save the Deselect String if it has changed.

******************************************************************************/

void CCodePagePage::OnKillfocusDeselectString() 
{
	SaveSelDeselString(m_ceDeselect, FALSE) ;
}


/******************************************************************************

  CCodePagePage::SaveBothSelAndDeselStrings

  Save both the Select and the Deselect strings if they have changed.

******************************************************************************/

void CCodePagePage::SaveBothSelAndDeselStrings() 
{
	SaveSelDeselString(m_ceSelect, TRUE) ;
	SaveSelDeselString(m_ceDeselect, FALSE) ;
}


/******************************************************************************

  CCodePagePage::SaveSelDeselString

  This function is called to update the GTT when the Selection or Deselection
  string may have changed.  Check to see if the control really was modified, and
  if it is, update the structure accordingly.  Then flag the control as 
  unmodified.

******************************************************************************/

void CCodePagePage::SaveSelDeselString(CEdit &cesd, BOOL bselstr)
{
	// Do nothing if the control has not been modified.

	if  (!cesd || !cesd.GetModify())
        return ;

    // Get the new sel/desel string.

	CString csWork ;
    cesd.GetWindowText(csWork) ;

	// Save the sel/desel string as determined by bselstr.  (Note: 
	// SetInvocation() sets the GTT's changed flag, too.)

    m_pcgm -> SetInvocation(
		(unsigned)m_clbPages.GetItemData(m_clbPages.GetCurSel()), csWork, 
		bselstr) ;

	// Clear the control's modified flag.

    cesd.SetModify(FALSE) ;

	// Now make sure that the string is displayed correctly.

    m_pcgm -> Invocation(
		(unsigned)m_clbPages.GetItemData(m_clbPages.GetCurSel()), csWork,
        bselstr) ;
    cesd.SetWindowText(csWork) ;
}


/******************************************************************************

  CCodePagePage::OnAddPage

  This is an event handler for the pressing of the "Add Page" button.  We invoke
  the Select Code Page dialog, and if a new page is selected, we add it to the
  list of pages that are available.

******************************************************************************/

void CCodePagePage::OnAddPage() {
    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);
    CSelectCodePage cscp(this, m_pcgm -> Name(), 0);
    cscp.Exclude(cdaPages);
	
    if  (cscp.DoModal() != IDOK)
        return;

    m_pcgm -> AddCodePage(cscp.SelectedCodePage());
    int id =
        m_clbPages.AddString(m_pcgm -> PageName(m_pcgm -> CodePages() - 1));
    m_clbPages.SetItemData(id, m_pcgm -> CodePages() -1);
    m_clbPages.SetCurSel(id);
    //  Let OnSelchangeCodePageList do the rest (that's what happened, eh?)
    OnSelchangeCodePageList();
    m_ceSelect.SetFocus();  //  A friendly place to leave it...
}


/******************************************************************************

  CCodePagePage::OnSelchangeCodePageList

  This member function handles changes in the selected code page.  It fills
  the edit controls for the selected page's name, selection and deselection
  strings, and handles enabling of the "Remove Page" button (this message
  could mean nothing is now selected...)

  Make sure that the operations of this function do not mark the GTT dirty.

******************************************************************************/

void CCodePagePage::OnSelchangeCodePageList() 
{
	m_bSelDeselChgSignificant = false ;

    int id = m_clbPages.GetCurSel();

    if  (id < 0) {
        m_ceSelect.SetWindowText(NULL);
        m_ceDeselect.SetWindowText(NULL);
        m_cbRemove.EnableWindow(FALSE);
		m_cbDelete.EnableWindow(FALSE);
        m_ceSelect.EnableWindow(FALSE);
        m_ceDeselect.EnableWindow(FALSE);
		m_bSelDeselChgSignificant = true ;
        return;
    }
	
    unsigned u = (unsigned)m_clbPages.GetItemData(id);

    SetDlgItemText(IDC_CurrentPage, m_pcgm -> PageName(u));

    CString csWork;

    m_pcgm -> Invocation(u, csWork, TRUE);
    m_ceSelect.SetWindowText(csWork);
    m_pcgm -> Invocation(u, csWork, FALSE);
    m_ceDeselect.SetWindowText(csWork);

    m_cbRemove.EnableWindow(m_pcgm -> CodePages() > 1);
	m_cbDelete.EnableWindow(m_pcgm -> CodePages() > 1);	// r118880
    m_ceSelect.EnableWindow();
    m_ceDeselect.EnableWindow();
	m_bSelDeselChgSignificant = true ;
}


/******************************************************************************

  CCodePagePage::OnReplacePage

  This handles the Remove Page button.  Not much to it, here- we just tell the
  glyph map what we want done.

******************************************************************************/

void CCodePagePage::OnReplacePage() {
	
    int id = m_clbPages.GetCurSel();

    if  (id < 0 || m_clbPages.GetCount() < 2)
        return;

    unsigned u = (unsigned)m_clbPages.GetItemData(id);

    //  Query for code page to map this one to

    CSelectCodePage cscp(this,
        CString(_TEXT("Replacing ")) + m_pcgm -> PageName(u), 0);

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);

    cdaPages.RemoveAt(u);

    cscp.LimitTo(cdaPages);

    if  (cscp.DoModal() != IDOK)
        return;

    for (unsigned uTo = 0; uTo < m_pcgm -> CodePages(); uTo++)
        if  (m_pcgm -> PageID(uTo) == cscp.SelectedCodePage())
            break;

    _ASSERTE(uTo < (unsigned) m_pcgm -> CodePages());

    if  (!m_pcgm -> RemovePage(u, uTo))
        return;

    //  Flush the list box and then refill it.

    m_clbPages.ResetContent();

    for (u = 0; u < m_pcgm -> CodePages(); u++) {
        int id = m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
    }

    //  Select whoever moved into our position, then update the rest

    m_clbPages.SetCurSel(id < m_clbPages.GetCount() ? id : id - 1);

	OnSelchangeCodePageList();
}



/******************************************************************************
//raid 118880
   CCodePagePage::OnDeletePage

  message handler :Delete code page when user push delete button 
	
  logic : get page id of selected code  -> get codepage id from Glyphmap ->
			call pcgm-> DeleteCodePage: actual part of deleting -> reset list box

********************************************************************************/
void CCodePagePage::OnDeletePage() 
{

	int id = m_clbPages.GetCurSel();

    if  (id < 0 || m_clbPages.GetCount() < 2)
        return;

    unsigned CodePageID = (unsigned)m_clbPages.GetItemData(id);

	// Actual delete call
	
	if (!m_pcgm -> RemovePage(CodePageID,CodePageID, TRUE))
		return;

    //  Flush the list box and then refill it.

    m_clbPages.ResetContent();

    for (unsigned u = 0; u < m_pcgm -> CodePages(); u++) {
        int id = m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
    }

    //  Select whoever moved into our position, then update the rest

    m_clbPages.SetCurSel(id < m_clbPages.GetCount() ? id : id - 1);

	OnSelchangeCodePageList();

}

/******************************************************************************

  CPredefinedMaps   class

  This implements the class which handles the page for pre-defined mappings
  in a GTT file.

******************************************************************************/

CPredefinedMaps::CPredefinedMaps() : CPropertyPage(CPredefinedMaps::IDD) {
	//{{AFX_DATA_INIT(CPredefinedMaps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPredefinedMaps::~CPredefinedMaps() {
}

void CPredefinedMaps::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPredefinedMaps)
	DDX_Control(pDX, IDC_PredefinedList, m_clbIDs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPredefinedMaps, CPropertyPage)
	//{{AFX_MSG_MAP(CPredefinedMaps)
	ON_BN_CLICKED(IDC_Overstrike, OnOverstrike)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPredefinedMaps message handlers

/******************************************************************************

  CPredefinedMaps::OnInitDialog

  This override handles the WM_INITDIALOG message by initializing the various
  controls.

******************************************************************************/

BOOL CPredefinedMaps::OnInitDialog() {
	CPropertyPage::OnInitDialog();

    //  Fill the list box- first, with none, then with the defined IDs

    CString csWork;

    csWork.LoadString(IDS_NoPredefined);
    m_clbIDs.AddString(csWork);
    if  (m_pcgm -> PredefinedID()== CGlyphMap::NoPredefined)
        m_clbIDs.SetCurSel(0);
    m_clbIDs.SetItemData(0, CGlyphMap::NoPredefined);
	
    for (int i = CGlyphMap::Wansung; i < 1; i++) {
        csWork.LoadString(IDS_DefaultPage + i);
        if  (csWork.IsEmpty())
            continue;
        int id = m_clbIDs.AddString(csWork);
        m_clbIDs.SetItemData(id, i);
        if  (i == m_pcgm -> PredefinedID())
            m_clbIDs.SetCurSel(i);
    }

    m_clbIDs.SetTopIndex(m_clbIDs.GetCurSel());

    CheckDlgButton(IDC_Overstrike, m_pcgm -> OverStrike());
    	
	return TRUE;  // return TRUE unless you set the focus to a control
}

/******************************************************************************

  CPredefinedMaps::OnKillActive

  This is called when we leave the page.  Since changing pages can be very
  time-consuming, we only check when you leave, not every time the selection
  changes.  Occasionally even my aged brain works.

******************************************************************************/

BOOL    CPredefinedMaps::OnKillActive() {
	
    if  (m_clbIDs.GetCurSel() >= 0)
        m_pcgm -> UsePredefined((unsigned)m_clbIDs.GetItemData(m_clbIDs.GetCurSel()));

    return CPropertyPage::OnKillActive();
}

/******************************************************************************

  CPredefinedMaps::OnOverstrike

  Called when the user clicks the check box for enabling / disabling overstrike

******************************************************************************/

void    CPredefinedMaps::OnOverstrike() {	
    m_pcgm -> OverStrike(IsDlgButtonChecked(IDC_Overstrike));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\llist.cpp ===
// LinkedList.cpp: implementation of the CLinkedList class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "minidev.h"
#include "llist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLinkedList::CLinkedList()
{
	m_dwSize ++ ; 
}

CLinkedList::~CLinkedList()
{
	m_dwSize -- ;
}

DWORD CLinkedList::Size()
{
	return m_dwSize ;
}



void CLinkedList::InitSize()
{
	m_dwSize = 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\llist.h ===
// llist.h: interface for the CLinkedList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINKEDLIST_H__34C04A7C_A22A_4B17_B6EF_4CB32E4F9756__INCLUDED_)
#define AFX_LINKEDLIST_H__34C04A7C_A22A_4B17_B6EF_4CB32E4F9756__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLinkedList  
{
public:
	
	
	static DWORD Size();
	static void InitSize();
	CLinkedList* Next;
	
	WORD data;
	CLinkedList();
	virtual ~CLinkedList();
	
private:
	static DWORD m_dwSize;
};

#endif // !defined(AFX_LINKEDLIST_H__34C04A7C_A22A_4B17_B6EF_4CB32E4F9756__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\infwizrd.h ===
#if !defined(AFX_INFWIZRD_H__D9592262_711B_11D2_ABFD_00C04FA30E4A__INCLUDED_)
#define AFX_INFWIZRD_H__D9592262_711B_11D2_ABFD_00C04FA30E4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// INFWizrd.h : header file
//


class CINFWizard ;


#define MAX_DEVNODE_NAME_ROOT   20

/////////////////////////////////////////////////////////////////////////////
// CCompatID class used to generate pseudo PNP ID for each model

class CCompatID  
{
public:
	void GenerateID( CString &csCompID );
	CCompatID( CString csMfg, CString csModel );
	virtual ~CCompatID();

protected:
	USHORT GetCheckSum( CString csValue );
	void TransString( CString &csInput );
	CString m_csModel;
	CString m_csMfg;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizWelcome dialog

class CINFWizWelcome : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizWelcome)

// Construction
public:
	CINFWizWelcome();
	~CINFWizWelcome();

// Dialog Data
	//{{AFX_DATA(CINFWizWelcome)
	enum { IDD = IDD_INFW_Welcome };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizWelcome)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizModels dialog

class CINFWizModels : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizModels)

// Construction
public:
	CINFWizModels();
	~CINFWizModels();

// Dialog Data
	//{{AFX_DATA(CINFWizModels)
	enum { IDD = IDD_INFW_ChooseModels };
	CFullEditListCtrl	m_cfelcModels;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizModels)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizModels)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	CStringArray	m_csaModels ;		// Model names
	CStringArray	m_csaModelsLast ;	// Model names (copy of last ones sel'd)
	CStringArray	m_csaInclude ;		// Include strings for models
	unsigned		m_uNumModels ;		// Number of models in the project
	unsigned		m_uNumModelsSel ;	// Number of models selected for INF
	CString			m_csToggleStr ;		// String used in toggle column
	bool			m_bSelChanged ;		// True iff initial selections may have	// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizGetPnPIDs dialog

class CINFWizGetPnPIDs : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizGetPnPIDs)

// Construction
public:
	CINFWizGetPnPIDs();
	~CINFWizGetPnPIDs();

// Dialog Data
	//{{AFX_DATA(CINFWizGetPnPIDs)
	enum { IDD = IDD_INFW_ModelPnPIDS };
	CFullEditListCtrl	m_felcModelIDs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizGetPnPIDs)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizGetPnPIDs)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected model names
	CStringArray	m_csaModelIDs ;		// PnP IDs for the selected models.

// Operations
public:
	void InitModelsIDListCtl() ;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizBiDi dialog

class CINFWizBiDi : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizBiDi)

// Construction
public:
	CINFWizBiDi();
	~CINFWizBiDi();

// Dialog Data
	//{{AFX_DATA(CINFWizBiDi)
	enum { IDD = IDD_INFW_BiDi };
	CFullEditListCtrl	m_cfelcBiDi;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizBiDi)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Operations
public:
	void ModelChangeFixups(unsigned unummodelssel, CStringArray& csamodels,
						   CStringArray& csamodelslast) ;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizBiDi)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	CString			m_csToggleStr ;		// String used in toggle column
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	CUIntArray		m_cuaBiDiFlags ;	// Per model BIDI flags kept here
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizICMProfiles dialog

class CINFWizICMProfiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizICMProfiles)

// Construction
public:
	CINFWizICMProfiles();
	~CINFWizICMProfiles();

// Dialog Data
	//{{AFX_DATA(CINFWizICMProfiles)
	enum { IDD = IDD_INFW_ICMProfiles };
	CFullEditListCtrl	m_cfelcICMFSpecs;
	CListBox	m_clbModels;
	CButton	m_cbBrowse;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizICMProfiles)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Operations
public:
	void ModelChangeFixups(unsigned unummodelssel, CStringArray& csamodels,
						   CStringArray& csamodelslast) ;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizICMProfiles)
	afx_msg void OnBrowseBtn();
	afx_msg void OnSelchangeModelsLst();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurModelIdx ;	// Index of model selected in list box

	// Array of CStringArray pointers.  One for each selected model.  Each
	// CStringArray will contain the ICM profile filespecs for a model.

	CObArray		m_coaProfileArrays ;
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizIncludeFiles dialog

class CINFWizIncludeFiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizIncludeFiles)

// Construction
public:
	CINFWizIncludeFiles();
	~CINFWizIncludeFiles();

// Dialog Data
	//{{AFX_DATA(CINFWizIncludeFiles)
	enum { IDD = IDD_INFW_IncludeFiles };
	CListBox	m_clbModels;
	CEdit	m_ceIncludeFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizIncludeFiles)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizIncludeFiles)
	afx_msg void OnSelchangeModelsLst();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected models
	CStringArray	m_csaIncFiles ;		// Include files for each model
	int				m_nCurModelIdx ;	// Index of model selected in list box
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizInstallSections dialog

#define	NUMINSTSECFLAGS 5		// Number of per model, install section flags
#define ISF_UNI			0		// Install section flag indexes
#define ISF_UNIBIDI		1
#define ISF_PSCR		2
#define ISF_TTF			3
#define ISF_OTHER		4

class CINFWizInstallSections : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizInstallSections)

// Construction
public:
	CINFWizInstallSections();
	~CINFWizInstallSections();

// Dialog Data
	//{{AFX_DATA(CINFWizInstallSections)
	enum { IDD = IDD_INFW_InstallSections };
	CListBox	m_clbModels;
	CString	m_csOtherSections;
	BOOL	m_bOther;
	BOOL	m_bPscript;
	BOOL	m_bTtfsub;
	BOOL	m_bUnidrvBidi;
	BOOL	m_bUnidrv;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizInstallSections)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizInstallSections)
	afx_msg void OnSelchangeModelsLst();
	afx_msg void OnOtherChk();
	afx_msg void OnPscriptChk();
	afx_msg void OnTtfsubChk();
	afx_msg void OnUnidrvBidiChk();
	afx_msg void OnUnidrvChk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected models
	CObArray		m_coaStdInstSecs ;	// Standard install section info
	CStringArray	m_csaOtherInstSecs ;// Other install sections
	int				m_nCurModelIdx ;	// Index of model selected in list box

// Operations
public:
	void AddModelFlags(int nidx) ;
	int InitPageControls() ;
	void BiDiDataChanged() ;
} ;


#define	NUMDATASECFLAGS 4		// Number of per model, data section flags
#define IDF_UNI			0		// Data section flag indexes
#define IDF_UNIBIDI		1
#define IDF_PSCR		2
#define IDF_OTHER		3


/////////////////////////////////////////////////////////////////////////////
// CINFWizDataSections dialog

class CINFWizDataSections : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizDataSections)

// Construction
public:
	CINFWizDataSections();
	~CINFWizDataSections();

// Dialog Data
	//{{AFX_DATA(CINFWizDataSections)
	enum { IDD = IDD_INFW_DataSections };
	CListBox	m_clbModels;
	CString	m_csOtherSections;
	BOOL	m_bOther;
	BOOL	m_bPscript;
	BOOL	m_bUnidrvBidi;
	BOOL	m_bUnidrv;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizDataSections)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizDataSections)
	afx_msg void OnSelchangeModelsLst();
	afx_msg void OnOtherChk();
	afx_msg void OnPscriptChk();
	afx_msg void OnUnidrvBidiChk();
	afx_msg void OnUnidrvChk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected models
	CObArray		m_coaStdDataSecs ;	// Standard data section info
	CStringArray	m_csaOtherDataSecs ;// Other data sections
	int				m_nCurModelIdx ;	// Index of model selected in list box

// Operations
public:
	void AddModelFlags(int nidx) ;
	int InitPageControls() ;
	void BiDiDataChanged() ;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizExtraFiles dialog

class CINFWizExtraFiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizExtraFiles)

// Construction
public:
	CINFWizExtraFiles();
	~CINFWizExtraFiles();

// Dialog Data
	//{{AFX_DATA(CINFWizExtraFiles)
	enum { IDD = IDD_INFW_ExtraFiles };
	CFullEditListCtrl	m_cfelcFSpecsLst;
	CListBox	m_clbModels;
	CButton	m_cbBrowse;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizExtraFiles)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Operations
public:
	void ModelChangeFixups(unsigned unummodelssel, CStringArray& csamodels,
						   CStringArray& csamodelslast) ;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizExtraFiles)
	afx_msg void OnSelchangeModelLst();
	afx_msg void OnBrowsBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurModelIdx ;	// Index of model selected in list box

	// Array of CStringArray pointers.  One for each selected model.  Each
	// CStringArray will contain the extra filespecs for a model.

	CObArray		m_coaExtraFSArrays ;
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizMfgName dialog

class CINFWizMfgName : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizMfgName)

// Construction
public:
	CINFWizMfgName();
	~CINFWizMfgName();

// Dialog Data
	//{{AFX_DATA(CINFWizMfgName)
	enum { IDD = IDD_INFW_MfgName };
	CEdit	m_ceMfgAbbrev;
	CEdit	m_ceMfgName;
	CString	m_csMfgName;
	CString	m_csMfgAbbrev;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizMfgName)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizMfgName)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdElts dialog

class CINFWizNonStdElts : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizNonStdElts)

// Construction
public:
	CINFWizNonStdElts();
	~CINFWizNonStdElts();

// Dialog Data
	//{{AFX_DATA(CINFWizNonStdElts)
	enum { IDD = IDD_INFW_NonStdElements };
	CButton	m_ceNewSection;
	CFullEditListCtrl	m_felcKeyValueLst;
	CListBox	m_clbSections;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizNonStdElts)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizNonStdElts)
	afx_msg void OnSelchangeSectionLst();
	afx_msg void OnNewSectionBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurSectionIdx ;	// Index of section selected in list box
	CStringArray	m_csaSections ;		// Array of INF file sections
	CUIntArray		m_cuaSecUsed ;		// An element is true iff section used

	// Array of CStringArray pointers.  One for each section.  Each CStringArray
	// will contain the extra filespecs for a model.

	CObArray		m_coaSectionArrays ;
	bool			m_bNewSectionAdded ;// True iff a new section was added
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdModelSecs dialog

class CINFWizNonStdModelSecs : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizNonStdModelSecs)

// Construction
public:
	CINFWizNonStdModelSecs();
	~CINFWizNonStdModelSecs();

// Dialog Data
	//{{AFX_DATA(CINFWizNonStdModelSecs)
	enum { IDD = IDD_INFW_NonStdModelSecs };
	CFullEditListCtrl	m_cfelcModelsLst;
	CListBox	m_clbSectionsLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizNonStdModelSecs)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizNonStdModelSecs)
	afx_msg void OnSelchangeSectionLst();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bSelChanged ;		// True iff initial selections may have
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurSectionIdx ;	// Index of section selected in list box
	CStringArray	m_csaModels ;		// Array of selected models
	CStringArray	m_csaSections ;		// Array of INF file sections
	CObArray		m_coaModelsNeedingSecs ;// Arrays of models needing sections
	CString			m_csToggleStr ;		// String used in toggle column

// Operations
public:
	void SaveSectionModelInfo() ;
	void NonStdSecsChanged() ;
	void UpdateSectionData() ;
	void InitModelsListCtl() ;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizSummary dialog

class CINFWizSummary : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizSummary)

// Construction
public:
	CINFWizSummary();
	~CINFWizSummary();

// Dialog Data
	//{{AFX_DATA(CINFWizSummary)
	enum { IDD = IDD_INFW_Summary };
	CEdit	m_ceSummary;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizSummary)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizSummary)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
};


// The following constants are used to piece together INF file contents.

const CString csLBrack(_T("[")) ;
const CString csRBrack(_T("]")) ;
const CString csEmpty(_T("")) ;
const CString csCRLF(_T("\r\n")) ;
const CString csEq(_T(" = ")) ;
const CString csComma(_T(",")) ;
const CString csCommaSp(_T(", ")) ;
const CString csQuote(_T("\"")) ;
const CString csAtSign(_T("@")) ;
const CString csBSlash(_T("\\")) ;


/////////////////////////////////////////////////////////////////////////////
// CINFWizard

class CINFWizard : public CPropertySheet
{
	CProjectView*	m_pcpvParent ;	// Parent window

	CProjectRecord*		m_pcpr ;	// Document class ptr

	DECLARE_DYNAMIC(CINFWizard)

// Construction
public:
	CINFWizard(CWnd* pParentWnd = NULL, UINT iSelectPage = 0) ;

// Attributes
public:
	CStringArray	m_csaSrcDskFiles ;	// Used to collect SourceDiskFiles names

// Operations
public:
	void SetFixupFlags() ;
	CProjectView* GetOwner() { return m_pcpvParent ; }
	CModelData& GetModel(unsigned uidx) ;
	unsigned GetModelCount() ;
	CStringArray& GetINFModels() { return m_ciwm.m_csaModels ; }
	CStringArray& GetINFModelsLst() { return m_ciwm.m_csaModelsLast ; }
	unsigned GetINFModsSelCount() { return m_ciwm.m_uNumModelsSel ; }
	bool GenerateINFFile() ;
	void ChkForNonStdAdditions(CString& cs, LPCTSTR strsection) ;
	void BldModSpecSec(CString& csinf) ;
	CString GetModelFile(CString& csmodel, bool bfspec = false) ;
	void BuildInstallAndCopySecs(CString& csinf) ;
	void QuoteFile(CString& csf) {
		if (csf.Find(_T(" ")) != -1)
			csf = csQuote + csf + csQuote ;
	} 
	void AddFileList(CString& cssection, CStringArray* pcsa) ;
	void AddSourceDisksFilesSec(CString& csinf) ;
	void AddNonStandardSecs(CString& csinf) ;
	void PrepareToRestart() ;
	void BiDiDataChanged() ;
	void AddDataSectionStmt(CString& csinst, int nmod) ;
	void AddIncludeNeedsStmts(CString& csinst, int nmod) ;
	void NonStdSecsChanged() ;
	void AddNonStdSectionsForModel(CString& csinst, int nmod, CString& csmodel);
	bool ReadGPDAndGetDLLName(CString& csdrvdll, CString& csmodel, 
							  CStringArray& csagpdfile, CString& csmodelfile) ;
	void AddICMFilesToDestDirs(CString& cssection) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CINFWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFWizard)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// Allocate class instances for each page

	CINFWizWelcome			m_ciww ;
	CINFWizModels			m_ciwm ;
	CINFWizGetPnPIDs		m_ciwgpi ;
	CINFWizBiDi				m_ciwbd ;
	CINFWizICMProfiles		m_ciwip ;
	CINFWizIncludeFiles		m_ciwif ;
	CINFWizInstallSections	m_ciwis ;
	CINFWizDataSections		m_ciwds ;
	CINFWizExtraFiles		m_ciwef ;
	CINFWizMfgName			m_ciwmn ;
	CINFWizNonStdElts		m_ciwnse ;
	CINFWizNonStdModelSecs	m_ciwnsms ;
	CINFWizSummary			m_ciws ;

	CString					m_csINFContents ;	// INF contents built here
	CUIntArray				m_cuiaNonStdSecsFlags ;	// Flags set when sec used
	CGPDContainer*			m_pcgc ; // RAID 0001
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CNewINFSection dialog

class CNewINFSection : public CDialog
{
// Construction
public:
	CNewINFSection(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewINFSection)
	enum { IDD = IDD_INFW_Sub_NewSection };
	CString	m_csNewSection;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewINFSection)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewINFSection)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CINFCheckView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CINFCheckView : public CFormView
{
protected:
	CINFCheckView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFCheckView)

// Form Data
public:
	//{{AFX_DATA(CINFCheckView)
	enum { IDD = IDD_INFCheck };
	CListBox	m_clbMissingFiles;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:
	void PostINFChkMsg(CString& csmsg) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFCheckView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CINFCheckView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CINFCheckView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc document

class CINFCheckDoc : public CDocument
{
protected:
	//CINFCheckDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFCheckDoc)

// Attributes
public:

// Operations
public:
	CINFCheckDoc();           // protected constructor used by dynamic creation
	void PostINFChkMsg(CString& csmsg) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFCheckDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CINFCheckDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFCheckDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizView view

class CINFWizView : public CEditView
{
protected:
	CINFWizView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFWizView)

// Attributes
public:
	bool	m_bChkingErrsFound ;	// True iff file checking error(s) found
	CINFCheckDoc*	m_pcicdCheckDoc ;	// Checking windows document
	CMDIChildWnd*	m_pcmcwCheckFrame ;	// Checking window frame

// Operations
public:
	bool PostINFCheckingMessage(CString& csmsg) ;
	void CheckArrayOfFiles(CStringArray* pcsa, CString& csfspec, 
						   CString& cspath, CString& csprojpath, 
						   CString& csmodel, int nerrid) ;
	void CheckIncludeFiles(CString& csfspec, CString& cspath, CString& csmodel);
	void ResetINFErrorWindow() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFWizView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CINFWizView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFWizView)
	afx_msg void OnFILEChangeINF();
	afx_msg void OnFILECheckINF();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc document

class CINFWizDoc : public CDocument
{
protected:
	CINFWizDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFWizDoc)

// Attributes
public:
	CProjectRecord*	m_pcpr ;		// Pointer to parent project (workspace)
	CINFWizard*		m_pciw ;		// Pointer to the INF's wizard
	bool			m_bGoodInit ;	// True iff the doc was correctly opened /
									// created / initialized.
	CGPDContainer*  m_pcgc ;		// RAID 0001. 
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFWizDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual void OnCloseDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
    CINFWizDoc(CGPDContainer* pcgc, CINFWizard* pciw);
	CINFWizDoc(CProjectRecord* cpr, CINFWizard* pciw);
	virtual ~CINFWizDoc();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFWizDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INFWIZRD_H__D9592262_711B_11D2_ABFD_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gtt.h ===
/******************************************************************************

  Header File:  Glyph Translation.H

  These classes define the mapping used from a Unicode or ANSI character to a
  character sequence to render said character on a printer.  They are content
  equivalent to the CTT, RLE and GTT formats used in the various flavors of the
  mini-driver architecture.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-13-97  Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(GLYPH_TRANSLATION)

#define GLYPH_TRANSLATION

#if defined(LONG_NAMES)
#include    "Project Node.H"
#else
#include    "ProjNode.H"
#endif

//  Win16 CTT formats- since these can't change, I've recoded them to suit.
//  Good thing, too- the mapping of direct was bogus- the union implies a word
//  aligned structure, but the fact is that direct data is byte-aligned.
class CInvocation : public CObject {
    CByteArray  m_cbaEncoding;
    DWORD       m_dwOffset;
    DECLARE_SERIAL(CInvocation)

    void        Encode(BYTE c, CString& cs) const;

public:

    CInvocation() {}
    void        Init(PBYTE pb, unsigned ucb);

    unsigned    Length() const { return (int)m_cbaEncoding.GetSize(); }
    const unsigned  Size() const { return 2 * sizeof m_dwOffset; }

    void    GetInvocation(CString& csReturn) const;

    BYTE    operator[](unsigned u) const {
        return u < Length() ? m_cbaEncoding[u] : 0;
    }

    CInvocation&    operator =(CInvocation& ciRef) {
        m_cbaEncoding.Copy(ciRef.m_cbaEncoding);
        return  *this;
    }

    void    SetInvocation(LPCTSTR lpstrNew);
    void    NoteOffset(DWORD& dwOffset);
    void    WriteSelf(CFile& cfTarget) const;
    void    WriteEncoding(CFile& cfTarget, BOOL bWriteLength = FALSE) const;
    virtual void    Serialize(CArchive& car);
};

//  The following class handles glyph handles and all associated details

class   CGlyphHandle : public CObject {

    CInvocation m_ciEncoding;
    DWORD       m_dwCodePage, m_dwidCodePage, m_dwOffset;
    WORD        m_wIndex;
    WORD        m_wCodePoint;   //  Unicode Representation of the glyph
    WORD        m_wPredefined;

public:
	CGlyphHandle() ;
	
    //  Atributes

    const unsigned  RLESize() const { return sizeof m_dwCodePage; }
    unsigned    CodePage() const { return m_dwidCodePage; } //  Only ID matters
    WORD        CodePoint() const { return m_wCodePoint; }

    unsigned    CompactSize() const;

    unsigned    MaximumSize() const {
        return  CompactSize() ?
            sizeof m_wIndex + ((CompactSize() + 1) & ~1) : 0;
    }

    void        GetEncoding(CString& csWhere) {
        m_ciEncoding.GetInvocation(csWhere);
    }

    enum {Modified, Added, Removed};
    WORD    Predefined() const { return m_wPredefined; }
    BOOL    operator ==(CGlyphHandle& cghRef);
    BOOL    PairedRelevant() const { return m_ciEncoding.Length() == 2; }

    //  Operations

    void    Init(BYTE b, WORD wIndex, WORD wCode);
    void    Init(BYTE ab[2], WORD wIndex, WORD wCode);
    void    Init(PBYTE pb, unsigned ucb, WORD wIndex, WORD wCode);

    CGlyphHandle&   operator =(CGlyphHandle& cghTemplate);

    void    RLEOffset(DWORD& dwOffset, const BOOL bCompact);
    void    GTTOffset(DWORD& dwOffset, BOOL bPaired);

    void    SetCodePage(DWORD dwidPage, DWORD dwNewPage) {
        m_dwCodePage = dwNewPage;
        m_dwidCodePage = dwidPage;
    }

    void    NewEncoding(LPCTSTR lpstrNew) {
        m_ciEncoding.SetInvocation(lpstrNew);
    }

    void    SetPredefined(WORD wNew) { m_wPredefined = wNew; }

    //  These write our contents for mini-driver files- they will throw
    //  exceptions on failure, so use an exception handler to handle errors

    void    WriteRLE(CFile& cfTarget, WORD wFormat) const;
    void    WriteGTT(CFile& cfTarget, BOOL bPredefined) const;

    enum    {GTT, RLEBig, RLESmall};    //  Desired encoding format
    void    WriteEncoding(CFile& cfTarget, WORD wfHow) const;
};

//  The next class maintains a record of the runs in the glyph set. It
//  generates and merges instances of itself as glyphs are added to the map.

class CRunRecord {
    WORD        m_wFirst, m_wcGlyphs;
    DWORD       m_dwOffset;    //  These are the image...
    CRunRecord  *m_pcrrNext, *m_pcrrPrevious;

    CPtrArray   m_cpaGlyphs;

    CRunRecord(CGlyphHandle *pcgh, CRunRecord* pcrrPrevious);
    CRunRecord(CRunRecord* crrPrevious, WORD wWhere);
    CRunRecord(CRunRecord* pcrrPrevious);

    CGlyphHandle&   Glyph(unsigned u) {
        return *(CGlyphHandle *) m_cpaGlyphs[u];
    }

    const CGlyphHandle& GlyphData(unsigned u) const {
        return *(CGlyphHandle *) m_cpaGlyphs[u];
    }

public:

    CRunRecord();
    ~CRunRecord();

    unsigned        Glyphs() const { return m_wcGlyphs; }
    unsigned        TotalGlyphs() const;
    BOOL            MustCompose() const;
    unsigned        RunCount() const {
        return 1 + (m_pcrrNext ? m_pcrrNext -> RunCount() : 0);
    }

    WORD            First() const { return m_wFirst; }
    WORD            Last() const {
        return m_pcrrNext ? m_pcrrNext ->Last() : -1 + m_wFirst + m_wcGlyphs;
    }

    unsigned        ExtraNeeded(BOOL bCompact = TRUE);

    const unsigned  Size(BOOL bRLE = TRUE) const {
        return  sizeof m_dwOffset << (unsigned) (!!bRLE);
    }

    void    Collect(CPtrArray& cpaGlyphs) const {
        cpaGlyphs.Append(m_cpaGlyphs);
        if  (m_pcrrNext)    m_pcrrNext -> Collect(cpaGlyphs);
    }

    CGlyphHandle*   GetGlyph(unsigned u ) const;

#if defined(_DEBUG) //  While the linkage code seems to check out, keep this
                    //  around in case of later problems
    BOOL    ChainIntact() {
        _ASSERTE(m_wcGlyphs == m_cpaGlyphs.GetSize());
        for (unsigned u = 0; u < Glyphs(); u++) {
            _ASSERTE(Glyph(u).CodePoint() == m_wFirst + u);
        }
        return  !m_pcrrNext || m_pcrrNext -> m_pcrrPrevious == this &&
            m_pcrrNext -> ChainIntact();
    }
#endif

    //  Operations

    void    Add(CGlyphHandle *pcgh);
    void    Delete(WORD wCodePoint);
    void    Empty();

    void    NoteOffset(DWORD& dwOffset, BOOL bRLE, BOOL bPaired);
    void    NoteExtraOffset(DWORD& dwOffset, const BOOL bCompact);

    //  File output operations

    void    WriteSelf(CFile& cfTarget, BOOL bRLE = TRUE) const;
    void    WriteHandles(CFile& cfTarget, WORD wFormat) const;
    void    WriteMapTable(CFile& cfTarget, BOOL bPredefined) const;
    void    WriteEncodings(CFile& cfTarget, WORD wfHow) const;
};

class CCodePageData : public CObject {
    DWORD   m_dwid;
    CInvocation  m_ciSelect, m_ciDeselect;

public:

    CCodePageData() { m_dwid = 0; }
    CCodePageData(DWORD dwid) { m_dwid = dwid; }

    //  Attributes

    DWORD   Page() const { return m_dwid; }
    void    Invocation(CString& csReturn, BOOL bSelect) const;
    const unsigned  Size() const {
        return sizeof m_dwid + 2 * m_ciSelect.Size();
    }

    BOOL    NoInvocation() const {
        return !m_ciSelect.Length() && !m_ciDeselect.Length();
    }

    //  Operations
    void    SetPage(DWORD dwNewPage) { m_dwid = dwNewPage; }
    void    SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect);
    void    SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect);
    void    NoteOffsets(DWORD& dwOffset);
    void    WriteSelf(CFile& cfTarget);
    void    WriteInvocation(CFile& cfTarget);
};

//  This class is the generic class encompassing all glyph translation
//  information.  We can use it to output any of the other forms.

class CGlyphMap : public CProjectNode {
    CSafeMapWordToOb    m_csmw2oEncodings;  //  All of the defined encodings
    CRunRecord          m_crr;
    long                m_lidPredefined;
    BOOL                m_bPaired;          //  Use paired encoding...
    CSafeObArray        m_csoaCodePage;     //  Code page(s) in this map

    //  Framework support (workspace)

    CString             m_csSource;         //  Source CTT File name

    //  Predefined GTT support- must be in this DLL

    static CSafeMapWordToOb m_csmw2oPredefined; //  Cache loaded PDTs here

    void            MergePredefined();  //  Use definitions to build "true" GTT
    void            UnmergePredefined(BOOL bTrackRemovals);

    void            GenerateRuns();

    CCodePageData&  CodePage(unsigned u) const {
        return *(CCodePageData *) m_csoaCodePage[u];
    }

    DECLARE_SERIAL(CGlyphMap)
public:
	bool ChngedCodePt() { return m_bChngCodePt ; } ;
	void SetCodePt( bool b) { m_bChngCodePt = b ; }
	// These variables hold parameters for PGetDefaultGlyphset().

	WORD	m_wFirstChar, m_wLastChar ;

	// True iff GTT data should be loaded from resources or built.
	
	bool	m_bResBldGTT ;		

	CTime	m_ctSaveTimeStamp ;	// The last time this GTT was saved

    //  Predefined IDs, and a static function for retrieving predefined maps

    enum {Wansung = -18, ShiftJIS, GB2312, Big5ToTCA, Big5ToNSA86, JISNoANK,
            JIS, KoreanISC, Big5, CodePage863 = -3, CodePage850, CodePage437,
            DefaultPage, NoPredefined = 0xFFFF};

    static CGlyphMap*	Public(WORD wID, WORD wCP = 0, DWORD dwDefCP = 0,
							   WORD wFirst = 0, WORD wLast = 255) ;

    CGlyphMap();

    //  Attributes

    unsigned    CodePages() const { return m_csoaCodePage.GetSize(); }
    DWORD       DefaultCodePage() const { return CodePage(0).Page(); }

    unsigned    Glyphs() const {
        return m_csmw2oEncodings.GetCount();
    }

    void        CodePages(CDWordArray& cdaReturn) const;
    unsigned    PageID(unsigned u) const { return CodePage(u).Page(); }
    long        PredefinedID() const { return m_lidPredefined; }

    CString     PageName(unsigned u) const;
    void        Invocation(unsigned u, CString& csReturn, BOOL bSelect) const;
    void        UndefinedPoints(CMapWordToDWord& cmw2dCollector) const;
    BOOL        OverStrike() const { return m_bPaired; }
    const CString&  SourceName() { return m_csSource; }

    //  Operations- Framework support
    void    SetSourceName(LPCTSTR lpstrNew);
    void    Load(CByteArray&    cbaMap) ;  //  Load GTT image
    //void    Load(CByteArray&    cbaMap) const;  //  Load GTT image

    //  Operations- editor support

    void    AddPoints(CMapWordToDWord& cmw2dNew);   //  Add points and pages
    void    DeleteGlyph(WORD wGlyph);
	BOOL    RemovePage(unsigned uPage, unsigned uMapTo, bool bDelete = FALSE); // 118880

    void    SetDefaultCodePage(unsigned u) { CodePage(0).SetPage(u); }
    void    ChangeCodePage(CPtrArray& cpaGlyphs, DWORD dwidNewPage);
    void    AddCodePage(DWORD dwidNewPage);

    void    UsePredefined(long lidPredefined);

    void    SetInvocation(unsigned u, LPCTSTR lpstrInvoke, BOOL bSelect);
    void    ChangeEncoding(WORD wCodePoint, LPCTSTR lpstrInvoke);
    void    OverStrike(BOOL bOn) { m_bPaired = bOn; Changed();}

    int     ConvertCTT();
    BOOL    Load(LPCTSTR lpstrName = NULL);
    BOOL    RLE(CFile& cfTarget);

    CGlyphHandle*   Glyph(unsigned u);

    //  Font editor support operations

    void    Collect(CPtrArray& cpaGlyphs) { //  Collect all glyph handles
        cpaGlyphs.RemoveAll();
        m_crr.Collect(cpaGlyphs);
    }

    virtual CMDIChildWnd*   CreateEditor();
    virtual BOOL            Generate(CFile& cfGTT);

    BOOL    SetFileName(LPCTSTR lpstrNew) ;

    virtual void    Serialize(CArchive& car);
private:
	bool m_bChngCodePt;
};

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer document

class CGlyphMapContainer : public CDocument {
    CGlyphMap   *m_pcgm;
    BOOL        m_bEmbedded;		// From driver, or not?
	BOOL		m_bSaveSuccessful;	// TRUE iff a successful save was performed

protected:
	CGlyphMapContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGlyphMapContainer)

// Attributes
public:

    CGlyphMap*  GlyphMap() { return m_pcgm; }

// Operations
public:
    //  Constructor- used to create from driver info editor
    CGlyphMapContainer(CGlyphMap *pcgm, CString csPath);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMapContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGlyphMapContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGlyphMapContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gttview.h ===
/******************************************************************************

  Header File:  Glyph Map View.H

  This defines the classes used to edit and view the glyph mappings.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard@Prodigy.Net   Began work on it.

******************************************************************************/

/******************************************************************************

  CGlyphMappingPage class

  This class handles the property sheet page which displays a list of the
  individual code points in the glyph translatin table.

******************************************************************************/

class CGlyphMappingPage : public CPropertyPage {

    //  Sorting members and methods
    enum {Strings, Codes, Pages, Columns};
    BOOL    m_abDirection[Columns];   //  Sort directions;
    BYTE    m_bSortFirst, m_bSortSecond, m_bSortLast;

    static int CALLBACK MapSorter(LPARAM lp1, LPARAM lp2, LPARAM lp3);

    CGlyphMap*  m_pcgm;
    BOOL        m_bJustChangedSelectString; //  Semi-flaky work-around
    long        m_lPredefinedID;    //  So we know if we need to change this.
    unsigned    m_uTimer;           //  Using a timer for long fills
    unsigned    m_uidGlyph;         //  Used to track where we are on fills

// Construction
public:
	CGlyphMappingPage();
	~CGlyphMappingPage();

    void    Init(CGlyphMap* pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CGlyphMappingPage)
	enum { IDD = IDD_GlyphMappings };
	CProgressCtrl	m_cpcBanner;
	CListCtrl	m_clcMap;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMappingPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    //  Stuff Class Wizard doesn't know about, because we generate it from
    //  our on-the-fly context menus...
    afx_msg void    OnChangeInvocation();
    afx_msg void    OnChangeCodePage();
    afx_msg void    OnDeleteItem();
    afx_msg void    OnAddItem();
	// Generated message map functions
	//{{AFX_MSG(CGlyphMappingPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnEndlabeleditGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetdispinfoGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void LoadCharMapList() ;
};

/*****************************************************************************

  CCodePagePage class

  This class handles the property page which describes the code pages used
  along with their selection and deselection strings.

******************************************************************************/

class CCodePagePage : public CToolTipPage {
    CGlyphMap   *m_pcgm;
	bool		m_bInitialized ;	// True iff page has been initialized.
	bool		m_bSelDeselChgSignificant ;	// True iff a change to a sel/desel
											// editbox means contents should be
// Construction								// saved.
public:
	CCodePagePage();						   
	~CCodePagePage();

    void    Init(CGlyphMap * pcgm) { m_pcgm = pcgm; }
	void	SaveBothSelAndDeselStrings() ;
	void	SaveSelDeselString(CEdit &cesd, BOOL bselstr) ;

// Dialog Data
	//{{AFX_DATA(CCodePagePage)
	enum { IDD = IDD_CodePageView };
	CButton	m_cbDelete;
	CEdit	m_ceSelect;
	CEdit	m_ceDeselect;
	CButton	m_cbRemove;
	CListBox	m_clbPages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCodePagePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCodePagePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusSelectString();
	afx_msg void OnKillfocusDeselectString();
	afx_msg void OnAddPage();
	afx_msg void OnSelchangeCodePageList();
	afx_msg void OnReplacePage();
	afx_msg void OnChangeSelectString();
	afx_msg void OnChangeDeselectString();
	afx_msg void OnDeletePage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CPredefinedMaps class

  This class allows the user to specify a predefined mapping (if desired) and
  the way the code points in the table are ro be considered in relation to the
  same.

******************************************************************************/

class CPredefinedMaps : public CPropertyPage {
    CGlyphMap   *m_pcgm;

// Construction
public:
	CPredefinedMaps();
	~CPredefinedMaps();

    void    Init(CGlyphMap *pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CPredefinedMaps)
	enum { IDD = IDD_PredefinedPage };
	CListBox	m_clbIDs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPredefinedMaps)
	public:
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPredefinedMaps)
	virtual BOOL OnInitDialog();
	afx_msg void OnOverstrike();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CGlyphMapView class

  This class is the view class for glyph maps.  It creates a property sheet
  using the above pages.

******************************************************************************/

class CGlyphMapView : public CView {
    CPropertySheet      m_cps;
    CGlyphMappingPage   m_cgmp;
    CCodePagePage       m_ccpp;
    CPredefinedMaps     m_cpm;

protected:
	CGlyphMapView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGlyphMapView)

// Attributes
public:

    CGlyphMapContainer* GetDocument() { 
        return (CGlyphMapContainer *) m_pDocument; 
    }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMapView)
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnInitialUpdate();     // first time after construct
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

public:
	void SaveBothSelAndDeselStrings() ;

// Implementation
protected:
	virtual ~CGlyphMapView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CGlyphMapView)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\mainfrm.cpp ===
/******************************************************************************

  Source File:  Main Frame.CPP

  This implements the main frame class for the application.  Since MFC does
  so much for us, this file's going to be pretty empty, for a while, at least.

  Copyright (c) 1997 by Microsoft Corporaiton.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"

#include    "Main Frame.h"
#else
#include    "MiniDev.H"
#include    "MainFrm.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	ON_WM_INITMENU()
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CMDIFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	//ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	//ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] = {
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() {
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame() {
}

static TCHAR    sacToolBarSettings[] = _TEXT("Tool Bar Settings");

/******************************************************************************

  CMainFrame::OnCreate

  This is a standard App-Wizard supplied skeleton for the code to be called
  when the main window frame is created.  Primary modification made to date is
  the addition of an additional toolbar, and toolbar state restoration.

******************************************************************************/

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) {
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_ctbMain.Create(this) || !m_ctbBuild.Create(this, WS_CHILD |
        WS_VISIBLE | CBRS_TOP, AFX_IDW_TOOLBAR + 1) ||
		!m_ctbMain.LoadToolBar(IDR_MAINFRAME) || 
        !m_ctbBuild.LoadToolBar(IDR_GPD_VIEWER)) {
		TRACE0("Failed to create toolbars\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT))) {
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_ctbMain.SetBarStyle(m_ctbMain.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
    m_ctbBuild.SetBarStyle(m_ctbBuild.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// Dock the tool bars
	m_ctbMain.EnableDocking(CBRS_ALIGN_ANY);
    m_ctbBuild.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_ctbMain);
    DockControlBar(&m_ctbBuild);
    LoadBarState(sacToolBarSettings);

	// Replace a bogus, GPD tool bar button with the Search edit box.  

	CRect cr ;		 
	int nidx = m_ctbBuild.CommandToIndex(ID_BOGUS_SBOX) ;
	m_ctbBuild.SetButtonInfo(nidx, ID_BOGUS_SBOX, TBBS_SEPARATOR, GPD_SBOX_WIDTH) ;
	m_ctbBuild.GetItemRect(nidx, &cr) ;
	if (!m_ctbBuild.ceSearchBox.Create(ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE
	 | WS_BORDER, cr, &m_ctbBuild, IDC_SearchBox)) {
		TRACE0("Failed to create search edit box.\n");
		return -1;      // fail to create
	} ;

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const {
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const {
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnInitMenu(CMenu* pMenu)
{
   CMDIFrameWnd::OnInitMenu(pMenu);

//#if defined(NOPOLLO)   //  CSRUS
  
	// CG: This block added by 'Tip of the Day' component.
	{
		// TODO: This code adds the "Tip of the Day" menu item
		// on the fly.  It may be removed after adding the menu
		// item to all applicable menu items using the resource
		// editor.

		// Add Tip of the Day menu item on the fly!
		static CMenu* pSubMenu = NULL;

		CString strHelp; strHelp.LoadString(CG_IDS_TIPOFTHEDAYHELP);
		CString strMenu;
		int nMenuCount = pMenu->GetMenuItemCount();
		BOOL bFound = FALSE;
		for (int i=0; i < nMenuCount; i++) 
		{
			pMenu->GetMenuString(i, strMenu, MF_BYPOSITION);
			if (strMenu == strHelp)
			{ 
				pSubMenu = pMenu->GetSubMenu(i);
				bFound = TRUE;
				ASSERT(pSubMenu != NULL);
			}
		}

		CString strTipMenu;
		strTipMenu.LoadString(CG_IDS_TIPOFTHEDAYMENU);
		if (!bFound)
		{
			// Help menu is not available. Please add it!
			if (pSubMenu == NULL) 
			{
				// The same pop-up menu is shared between mainfrm and frame 
				// with the doc.
				static CMenu popUpMenu;
				pSubMenu = &popUpMenu;
				pSubMenu->CreatePopupMenu();
				pSubMenu->InsertMenu(0, MF_STRING|MF_BYPOSITION, 
					CG_IDS_TIPOFTHEDAY, strTipMenu);
			} 
			pMenu->AppendMenu(MF_STRING|MF_BYPOSITION|MF_ENABLED|MF_POPUP, 
				(UINT_PTR)pSubMenu->m_hMenu, strHelp);
			DrawMenuBar();
		} 
		else
		{      
			// Check to see if the Tip of the Day menu has already been added.
			pSubMenu->GetMenuString(0, strMenu, MF_BYPOSITION);

			if (strMenu != strTipMenu) 
			{
				// Tip of the Day submenu has not been added to the 
				// first position, so add it.
				pSubMenu->InsertMenu(0, MF_BYPOSITION);  // Separator
				pSubMenu->InsertMenu(0, MF_STRING|MF_BYPOSITION, 
					CG_IDS_TIPOFTHEDAY, strTipMenu);
			}
		}
	}
//#endif
}

/******************************************************************************

  CMainFrame::OnDestroy

  This member function. called when the frame is to be destroyed, saves the
  toolbar states, before proceeding to do the normal kinds of stuff...

******************************************************************************/

void CMainFrame::OnDestroy() {

    //  Save the tool bar states.
    SaveBarState(sacToolBarSettings);

    CMDIFrameWnd::OnDestroy();
}


/******************************************************************************

  CMainFrame::GetGPDSearchString

  Load the specified string with the search string in the GPD Search string edit 
  box on the GPD tool bar.

******************************************************************************/

void CMainFrame::GetGPDSearchString(CString& cstext)
{
	m_ctbBuild.ceSearchBox.GetWindowText(cstext) ;
}


/******************************************************************************

  CMainFrame::OnViewStatusBar

  Show the status bar if the command is not checked.  Otherwise, hide the status
  bar.  Then update the window and the menu command.

******************************************************************************/

/*

  This routine does not check and uncheck the menu command for some reason
  and turning off the status bar turns off the GPD tool bar, too.  There
  are problems because of the ID used for the GPD tool bar.  Maybe, I should
  try to just add the tool bar when a GPD is displayed...

void CMainFrame::OnViewStatusBar() 
{
	CMenu* pcm = GetMenu() ;
	unsigned ustate = pcm->GetMenuState(ID_VIEW_STATUS_BAR, MF_BYCOMMAND) ;
	if (ustate & MF_CHECKED) {
		m_wndStatusBar.ShowWindow(SW_HIDE) ;
		pcm->CheckMenuItem(ID_VIEW_STATUS_BAR, MF_UNCHECKED) ;
	} else {
		m_wndStatusBar.ShowWindow(SW_SHOW) ;
		pcm->CheckMenuItem(ID_VIEW_STATUS_BAR, MF_CHECKED) ;
	} ;
	RecalcLayout() ;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\infwizrd.cpp ===
// INFWizrd.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"
#include <gpdparse.h>
#include "rcfile.h"
#include "projrec.h"
#include "projview.h"
#include "comctrls.h"
#include "Gpdview.h" //RAID 0001
#include "INFWizrd.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CINFWizard

IMPLEMENT_DYNAMIC(CINFWizard, CPropertySheet)

CINFWizard::CINFWizard(CWnd* pParentWnd, UINT iSelectPage)
	: CPropertySheet(IDS_INFWizTitle, pParentWnd )  //iSelectPage ) RAID 0001//Welcome page should be top even iselectpage=1
{
	// Save parent pointer

	m_pcpvParent = (CProjectView*) pParentWnd ;

	// Give the pages a pointer to the sheet.

	m_ciww.m_pciwParent = this ;
	m_ciwm.m_pciwParent = this ;
	m_ciwgpi.m_pciwParent = this ;
	m_ciwbd.m_pciwParent = this ;
	m_ciwip.m_pciwParent = this ;
	m_ciwif.m_pciwParent = this ;
	m_ciwis.m_pciwParent = this ;
	m_ciwds.m_pciwParent = this ;
	m_ciwef.m_pciwParent = this ;
	m_ciwmn.m_pciwParent = this ;
	m_ciwnse.m_pciwParent = this ;
	m_ciwnsms.m_pciwParent = this ;
	m_ciws.m_pciwParent = this ;

	// Add the wizard's pages and set wizard moede.
					
    AddPage(&m_ciww) ;
    AddPage(&m_ciwm) ;
    AddPage(&m_ciwgpi) ;
    AddPage(&m_ciwbd) ;
    AddPage(&m_ciwip) ;
    AddPage(&m_ciwif) ;
    AddPage(&m_ciwis) ;
    AddPage(&m_ciwds) ;
    AddPage(&m_ciwef) ;
    AddPage(&m_ciwmn) ;
    AddPage(&m_ciwnse) ;
    AddPage(&m_ciwnsms) ;
    AddPage(&m_ciws) ;
    SetWizardMode() ;

	// Get and save a pointer to the project record (document) class associated
	// with this class' parent.

	if(NULL != iSelectPage ){ //RAID 0001
		CGPDViewer*  pcgv = (CGPDViewer*) m_pcpvParent;
		m_pcgc = pcgv ->GetDocument();
	}
	else{					// END RAID
		m_pcpr = (CProjectRecord*) m_pcpvParent->GetDocument() ;
		m_pcgc = NULL;
	}
}


CINFWizard::~CINFWizard()
{
}


unsigned CINFWizard::GetModelCount()
{
	if(m_pcgc) //RAID 0001
		return 1;    // only one gpdviewer
	else		//END RAID
		return m_pcpr->ModelCount() ;
}


CModelData& CINFWizard::GetModel(unsigned uidx)
{
	return m_pcpr->Model(uidx) ;
}


void CINFWizard::SetFixupFlags()
{
	// Set flags in each of the pages that need to update their data and UI when
	// the selected models change.

	m_ciwgpi.m_bSelChanged = true ;
	m_ciwbd.m_bSelChanged = true ;
	m_ciwip.m_bSelChanged = true ;
	m_ciwif.m_bSelChanged = true ;
	m_ciwis.m_bSelChanged = true ;
	m_ciwds.m_bSelChanged = true ;
	m_ciwef.m_bSelChanged = true ;
	m_ciwnsms.m_bSelChanged = true ;
}


void CINFWizard::BiDiDataChanged()
{
	// If the selected models' BiDi data may have changed, call the pages that
	// maintain related data so that they can update their data when/if needed.

	m_ciwis.BiDiDataChanged() ;
	m_ciwds.BiDiDataChanged() ;
}


void CINFWizard::NonStdSecsChanged()
{
	// If the nonstandard sections may have changed, call the pages that
	// maintain related data so that they can update their data when/if needed.

	m_ciwnsms.NonStdSecsChanged() ;
}


bool CINFWizard::GenerateINFFile()
{
    //  This might take a while, so...

    CWaitCursor cwc ;

	// Mark all of the sections in the "section used in INF file flags" array
	// as NOT having been used.

	unsigned unumelts = (unsigned)m_ciwnse.m_cuaSecUsed.GetSize() ;
	for (unsigned u = 0 ; u < unumelts ; u++)
		m_ciwnse.m_cuaSecUsed[u] = false ;

	// Initialize the source disk files array.

	m_csaSrcDskFiles.RemoveAll() ;

	// Start by loading the string with the INF's opening comment header.

	m_csINFContents.LoadString(IDS_INFText_HeaderCmt) ;

	// Add the version section with the appropriate value for the provider.

	CString cs ;
	cs.Format(IDS_INFText_Version, m_ciwmn.m_csMfgAbbrev) ;
	ChkForNonStdAdditions(cs, _T("Version")) ;
	m_csINFContents += cs ;

	// Add the ClassInstall32.NT and printer_class_addreg sections plus the
	// comments for the manufacturer's section.

	cs.LoadString(IDS_INFText_ClInst32) ;
	ChkForNonStdAdditions(cs, _T("ClassInstall32.NT")) ;
	m_csINFContents += cs ;
	cs.LoadString(IDS_INFText_PCAddr) ;
	ChkForNonStdAdditions(cs, _T("printer_class_addreg")) ;
	m_csINFContents += cs ;
	cs.LoadString(IDS_INFText_MfgCmt) ;
	m_csINFContents += cs ;

    // Add the manufacturer's name to the manufacturer's section and add the
	// section.

	cs.Format(IDS_INFText_Manufacturer, m_ciwmn.m_csMfgName) ;
	ChkForNonStdAdditions(cs, _T("Manufacturer")) ;
	m_csINFContents += cs ;

	// Build the model specifications section and add the section.

	BldModSpecSec(m_csINFContents) ;

	// Build the copy file sections and add them to the INF contents.

	BuildInstallAndCopySecs(m_csINFContents) ;

	// Add the DestinationDirs section to the INF contents.	

	cs.LoadString(IDS_INFText_DestDirs) ;
	AddICMFilesToDestDirs(cs) ;
	ChkForNonStdAdditions(cs, _T("DestinationDirs")) ;
	m_csINFContents += cs ;

	// Add the SourceDisksNames sections to the INF contents.  Each section will
	// include the Provider string.	

	cs.LoadString(IDS_INFText_SrcDiskNamesI) ;
	ChkForNonStdAdditions(cs, _T("SourceDisksNames.x86")) ;
	m_csINFContents += cs ;

	// Add the SourceDisksFiles sections to the INF contents.

	AddSourceDisksFilesSec(m_csINFContents) ;

	// Add the nonstandard sections to the INF contents.

	AddNonStandardSecs(m_csINFContents) ;

	// Finish up by adding the Strings section to the INF contents.

	cs.LoadString(IDS_INFText_Strings) ;
	cs.Format(IDS_INFText_Strings, m_ciwmn.m_csMfgAbbrev, m_ciwmn.m_csMfgName,
			  m_ciwmn.m_csMfgName) ;
	ChkForNonStdAdditions(cs, _T("Strings")) ;
	m_csINFContents += cs ;

	m_csaSrcDskFiles.RemoveAll() ;		// Array not needed anymore

	// All went well so...

	return true ;
}


void CINFWizard::AddSourceDisksFilesSec(CString& csinf)
{
	// Begin the section with the section header.

	CString cs, cs2, csentry ;
	cs.LoadString(IDS_INFTextSrcDiskFilesHdr) ;

	// Remove any duplicate entries from source disk files array.

	int n, n2 ;
	for (n = 0 ; n < m_csaSrcDskFiles.GetSize() ; n++)
		for (n2 = n + 1 ; n2 < m_csaSrcDskFiles.GetSize() ; )
			if (m_csaSrcDskFiles[n] == m_csaSrcDskFiles[n2])
				m_csaSrcDskFiles.RemoveAt(n2) ;
			else
				n2++ ;

	// Get a count of the number of files in the source disk files array.

	unsigned unumelts = (unsigned)m_csaSrcDskFiles.GetSize() ;

	// Add an entry for each file in the array.

	for (unsigned u = 0 ; u < unumelts ; u++) {
		// Quote the file name if needed.

		cs2 = m_csaSrcDskFiles[u] ;
		//if (cs2[0] != _T('\"'))
		//	QuoteFile(cs2) ;

		// Use the model's file name to build the entry for this model.  Then
		// add this entry to the section.

		csentry.Format(IDS_INFText_SrcDiskFilesEntry, cs2) ;
		cs += csentry ;
	} ;

	// Add any extra entries there might be for this section and then add the
	// section to the INF contents.
			
	ChkForNonStdAdditions(cs, _T("SourceDisksFiles")) ;
	csinf += cs ;
}


void CINFWizard::ChkForNonStdAdditions(CString& cs, LPCTSTR strsection)
{
	// Try to find the section amongst the list of sections with nonstandard
	// additions.

	CStringArray& csasections = m_ciwnse.m_csaSections ;
	CString cssechdr ;
	cssechdr = csLBrack + strsection + csRBrack ;
	unsigned unumelts = (unsigned)csasections.GetSize() ;
	for (unsigned u = 0 ; u < unumelts ; u++) {
		if (csasections[u].CompareNoCase(cssechdr) == 0)
			break ;
	} ;

	// If the section was found, mark the section as used and add the entries
	// for the section to the string.
	//
	// DEAD_BUG - Sometimes, the user may have entered replacement entries for
	//			standard ones.  This isn't handled correctly. : 
	// S.G : check the same keyword between cs and m_ciwnse exist, and replace cs keywod 
	//        with that of m_ciwnse  // raid 71332
	unsigned unSize = 0 ;
	if (u < unumelts ) {
		CStringArray* pcsa ;
		pcsa = (CStringArray*) m_ciwnse.m_coaSectionArrays[u] ;
		
		unSize = (unsigned)pcsa->GetSize() ;
	} ;

	if ( unSize )  {
		m_ciwnse.m_cuaSecUsed[u] = true ;
		
		CStringArray* pcsa ;
		pcsa = (CStringArray*) m_ciwnse.m_coaSectionArrays[u] ;
		unumelts = (unsigned)pcsa->GetSize() ;
		
		CUIntArray cuia ;
		cuia.SetSize(10) ;
		CStringArray csaNewcs;
		int ulen = csCRLF.GetLength() ;  // just in case, unicode : what is the length of "\r\n".
		unsigned i , k ,utelen ;
		i = k = utelen = 0 ; 
		while (-1 != (i = cs.Find(csCRLF, i + 1) ) ) {
			utelen = i - k ;
			csaNewcs.Add(cs.Mid(k,utelen + ulen) ); // we have to cut the string between csCR and csCR
			k = i + ulen;  
		} ;

		for (i = 0 ; i < unSize ; i++ ) 
			cuia[i] = true;

		for (i = 1; i < (unsigned)csaNewcs.GetSize() ; i++ ) {
			CString cstmp = csaNewcs.GetAt(i);
			cstmp = cstmp.Left(cstmp.Find(_T("=")) + 1) ;
			if (! cstmp.CompareNoCase(_T("")) ) 
				break;
			for (u = 0 ; u < unSize ; u++) {
				CString csKeyw = pcsa->GetAt(u) ;
				CString csComp = csKeyw.Left(csKeyw.Find(_T("=")) + 1) ;
				if(! cstmp.CompareNoCase (csComp) ) {
					csKeyw += csCRLF ; 
					csaNewcs.SetAt(i,csKeyw) ;
					cuia[u] = false;
				} ;
					
			} ;
		} ;
		for ( u = 0 ; u < unSize ; u ++ ) 
			if (cuia[u] ) {
				CString csAdd = pcsa->GetAt(u) ;
				csAdd += csCRLF ;
				csaNewcs.Add(csAdd) ;
			} ;
		CString csnew ;
		for ( u = 0 ; u < (unsigned)csaNewcs.GetSize(); u ++ ) 
			csnew += csaNewcs.GetAt(u);
		
		cs = csnew ;

	} ;

	// Add an extra line to this section's strings to separate it from the
	// next one.


	cs += csCRLF ;
}


void CINFWizard::AddNonStandardSecs(CString& csinf)
{
	CString cs ;

	// Loop through each nonstandard section.

	CStringArray& csasections = m_ciwnse.m_csaSections ;
	unsigned unumelts = (unsigned)csasections.GetSize() ;
	CStringArray* pcsa ;
	unsigned u2, unumstrs ;
	for (unsigned u = 0 ; u < unumelts ; u++) {
		// Skip this section if it is not a nonstandard section.  IE, its
		// entries have already been added to one of the standard sections.

		if (m_ciwnse.m_cuaSecUsed[u])
			continue ;

		// Skip this section if it is the Strings section.  It will be added
		// later.

		if (csasections[u].CompareNoCase(_T("[Strings]")) == 0)
			continue ;

		// Get info about the section's entries.  Skip the section if it has
		// no entries.

		pcsa = (CStringArray*) m_ciwnse.m_coaSectionArrays[u] ;
		unumstrs = (unsigned)pcsa->GetSize() ;
		if (unumstrs == 0)
			continue ;

		// Start the section with its header.

		cs = csasections[u] + csCRLF ;

		// Add each of the entries to the section.

		for (u2 = 0 ; u2 < unumstrs ; u2++)
			cs += pcsa->GetAt(u2) + csCRLF ;
		cs += csCRLF ;

		// Add the section to the INF contents

		csinf += cs ;
	} ;
}


void CINFWizard::BldModSpecSec(CString& csinf)
{
	// Add the comment for this section to the INF file

	CString cs, csl, csr, csfn, csmodel, cspnpid ;
	cs.LoadString(IDS_INFText_ModCmt) ;
	csinf += cs ;

	// Build the section header

	cs = csLBrack + m_ciwmn.m_csMfgName + csRBrack + csCRLF ;

	// Build the entry for each model and add them to the section.  The format
	// is:
	//	"model name" = filename,PnP ID,model_name

	CStringArray& csamodels = GetINFModels() ;
	int nummodels = (int)csamodels.GetSize() ;
	int n, npos, nlen ;
	for (n = 0 ; n < nummodels ; n++) {
		csmodel = csamodels[n] ;
		csmodel.TrimLeft() ;
		csmodel.TrimRight() ;

		// If the user supplied a real PnP ID, it is used.  If not, a pseudo
		// PnP ID is generated.

		if (!m_ciwgpi.m_csaModelIDs[n].IsEmpty())
			cspnpid = m_ciwgpi.m_csaModelIDs[n] ;
		else {
			CCompatID ccid(m_ciwmn.m_csMfgName, csmodel) ;
			ccid.GenerateID(cspnpid) ;
		} ;

		nlen = csmodel.GetLength() ;
		while ((npos = csmodel.Find(_T(" "))) != -1) {
			csl = (npos > 0) ? csmodel.Left(npos) : csEmpty ;
			csr = (npos + 1 < nlen) ? csmodel.Right(nlen - npos - 1) : csEmpty ;
			csmodel = csl + _T("_") + csr ;
		} ;
		csfn = GetModelFile(csamodels[n]) ;
		//QuoteFile(csfn) ;
		cs += csQuote + csamodels[n] + csQuote + csEq + csfn + csComma
			+ cspnpid + csComma + csmodel + csCRLF ;
	} ;
	
	// Add non standard additions and then add the section to the INF file contents

	ChkForNonStdAdditions(cs, m_ciwmn.m_csMfgName) ;
	csinf += cs ;
}


void CINFWizard::BuildInstallAndCopySecs(CString& csinf)
{
	// Add the comment for the Install sections to the INF contents

	CString cs ;
	cs.LoadString(IDS_INFText_InstallCmt) ;
	csinf += cs ;

	// Load the section components that will be needed repeatedly

	CString cskey, csdrvdll ;
	cskey.LoadString(IDS_INFText_CopyKey) ;
	bool bbidiadded = false ;	// True iff BiDi DLL in [SourceDiskFiles] array

	// Create an install section for each model and add it the INF contents

	CStringArray& csamodels = GetINFModels() ;
	CStringArray csagpdfile ;
	CString csmodelfile, cshdr, csinc(_T("*Include:")), cstmp ;
	int numstrs, nloc ;
	unsigned unummodels = (unsigned)csamodels.GetSize() ;
	for (unsigned u = 0 ; u < unummodels ; u++) {
		// Build the section header

		cshdr = csmodelfile = GetModelFile(csamodels[u]) ;
		cs = csLBrack + csmodelfile + csRBrack + csCRLF ;

		// Read the GPD to get the DLL name & add it to	SourceDiskFiles array.

		if (!ReadGPDAndGetDLLName(csdrvdll,csamodels[u],csagpdfile,csmodelfile))
			continue ;

		// Build the copy files statement.  Begin by adding the copy files
		// entry, the DLL, and the GPD to the statement.

		//QuoteFile(csmodelfile) ;
		cs += cskey + csdrvdll + csComma + csAtSign + csmodelfile ;
		m_csaSrcDskFiles.Add(csmodelfile) ;	// Add to [SourceDiskFiles] array

		// Add ICM files to the copy files entry when needed.
		
		AddFileList(cs,	(CStringArray*) m_ciwip.m_coaProfileArrays[u]) ;
		
		// Add the nonstandard files for this model to the copy files entry
		// when needed.

		AddFileList(cs,	(CStringArray*) m_ciwef.m_coaExtraFSArrays[u]) ;

		// Scan the current model's GPD file for include statements.
		// If any are found, add them to the copy files entry.

		numstrs = (int) csagpdfile.GetSize() ;
		for (int n = 0 ; n < numstrs ; n++) {
			if ((nloc = csagpdfile[n].Find(csinc)) == -1)
				continue ;
			cstmp = csagpdfile[n].Mid(nloc + csinc.GetLength()) ;
			cstmp.TrimLeft() ;
			cstmp.TrimRight() ;
			if (cstmp[0] == csQuote[0])						// Remove quotes
				cstmp = cstmp.Mid(1, cstmp.GetLength() - 2) ;
			if ((nloc = cstmp.ReverseFind(_T('\\'))) > -1)	// Remove path
				cstmp = cstmp.Right(cstmp.GetLength() - nloc - 1) ;
			if (cstmp.CompareNoCase(_T("stdnames.gpd")) == 0)
				continue ;							// File include below
			//QuoteFile(cstmp) ;
			m_csaSrcDskFiles.Add(cstmp) ; // Add to [SourceDiskFiles] array
			cs += csComma + csAtSign + cstmp ;
		} ;

		// Add any required nonstandard sections to the model's CopyFiles stmt.

		AddNonStdSectionsForModel(cs, (int) u, csamodels[u]) ;

		// Add the data sections statement to the Installs section

		AddDataSectionStmt(cs, (int) u) ;

		// Add the data file statement to the Install section

		cstmp.Format(IDS_INFText_DataFileKey, csmodelfile) ;
		cs += cstmp ;

		// Add the Include and Needs statements to the Install section

		AddIncludeNeedsStmts(cs, (int) u) ;

		// Add the section to the INF contents.

		//cs += csCRLF ;
		ChkForNonStdAdditions(cs, cshdr) ;
		csinf += cs ;
	} ;
}


bool CINFWizard::ReadGPDAndGetDLLName(CString& csdrvdll, CString& csmodel,
									  CStringArray& csagpdfile,
									  CString& csmodelfile)
{
	// Load the GPD file.  Complain and return false if this fails.

	CString cserr ;

	if (!LoadFile(GetModelFile(csmodel, true), csagpdfile)) {
		cserr.Format(IDS_INFGPDReadError, csmodelfile) ;
		AfxMessageBox(cserr, MB_ICONEXCLAMATION) ;
		return false ;
	} ;

	// Get the number of lines in the file and the DLL keyword.

	int nloc ;
	int numstrs = (int) csagpdfile.GetSize() ;
	CString csdllkey(_T("*ResourceDLL:")) ;

	// Look for the DLL name in the GPD file.

	for (int n = 0 ; n < numstrs ; n++) {
		// Continue if current line doesn't contain DLL file name.

		if ((nloc = csagpdfile[n].Find(csdllkey)) == -1)
			continue ;

		// Isolate the DLL file name in the current statement.

		csdrvdll = csagpdfile[n].Mid(nloc + csdllkey.GetLength()) ;
		csdrvdll.TrimLeft() ;
		csdrvdll.TrimRight() ;
		if (csdrvdll[0] == csQuote[0])						// Remove quotes
			csdrvdll = csdrvdll.Mid(1, csdrvdll.GetLength() - 2) ;
		if ((nloc = csdrvdll.ReverseFind(_T('\\'))) > -1)	// Remove path
			csdrvdll = csdrvdll.Right(csdrvdll.GetLength() - nloc - 1) ;
		
		// Add the DLL file name to the SourceDiskFiles array and then add an
		// atsign to it so that it will be ready for future use.

		m_csaSrcDskFiles.Add(csdrvdll) ;
		csdrvdll = csAtSign + csdrvdll ;
		return true ;
	} ;

	// If this point is reached, the DLL file name could not be found so
	// complain and return false.
	
	cserr.Format(IDS_INFNoDLLError, csmodelfile) ;
	AfxMessageBox(cserr, MB_ICONEXCLAMATION) ;
	return false ;
}


void CINFWizard::AddFileList(CString& cssection, CStringArray* pcsa)
{	
	int n, numstrs, npos ;

	// If there is a list of files to add to the section...

	if ((numstrs = (int)pcsa->GetSize()) > 0) {
		// ... Add each file to the section

		CString cstmp ;
		for (n = 0 ; n < numstrs ; n++) {
			cstmp = pcsa->GetAt(n) ;

			// If the filespec contains a path, remove it.

			if ((npos = cstmp.ReverseFind(_T('\\'))) > -1)
				cstmp = cstmp.Right(cstmp.GetLength() - npos - 1) ;

			// Quote the file name if it contains space(s).

			//QuoteFile(cstmp) ;

			m_csaSrcDskFiles.Add(cstmp) ;	// Add to [SourceDiskFiles] array

			// Add this file to the section.

			cssection += csComma + csAtSign + cstmp ;
		} ;
	} ;
}


void CINFWizard::AddICMFilesToDestDirs(CString& cssection)
{
	int				n, n2, numstrs, npos, numarrays ;
	CStringArray*	pcsa ;
	CString			cstmp, cstmp2 ;

	// Find out how many ICM file, string arrays there are.

	numarrays = (int) m_ciwip.m_coaProfileArrays.GetSize() ;

	// Check each array for ICM filespecs...

	for (n = 0 ; n < numarrays ; n++) {
		// Find out how many strings are in the current array

		pcsa = (CStringArray*) m_ciwip.m_coaProfileArrays[n] ;
		numstrs = (int) pcsa->GetSize() ;

		// Add each string in the current array to the DestinationDirs section.

		for (n2 = 0 ; n2 < numstrs ; n2++) {
			cstmp = pcsa->GetAt(n2) ;

			// If the filespec contains a path, remove it.

			if ((npos = cstmp.ReverseFind(_T('\\'))) > -1)
				cstmp = cstmp.Right(cstmp.GetLength() - npos - 1) ;

			// Format the statement for this file and add it to the section.

			cstmp2.Format(IDS_INFText_ICMDest,cstmp) ;
			cssection += cstmp2 ;
		} ;
	} ;
}


CString CINFWizard::GetModelFile(CString& csmodel, bool bfspec/*=false*/)
{
	// Find the class instance associated with the specified model.

//RAID 0001
	if(m_pcgc){
		CString csFileName = m_pcgc->ModelData()->GetKeywordValue(m_pcgc->
			GetPathName(),_T("GPDFileName"));

	if (bfspec)
		return m_pcgc->GetPathName() ;
	else
		return csFileName;
	}

	else
	{
//END 0001
	unsigned unummodels = GetModelCount() ;
	for (unsigned u = 0 ; u < unummodels ; u++) {
		if (csmodel == GetModel(u).Name())
			break ;
	} ;
	ASSERT(u < unummodels) ;

	// Either return a full filespec or just a file name.

	if (bfspec)
		return (GetModel(u).FileName()) ;
	else
		return (GetModel(u).FileTitleExt()) ;
	}  // else{	 END RAID 0001
}


void CINFWizard::AddDataSectionStmt(CString& csinst, int nmod)
{
	// Prepare to determine the contents of the data section statement.

	CString cs, cs2 ;
	cs2 = csEmpty ;
	int nid = IDS_DataSecUni ;
	CUIntArray* pcuia = (CUIntArray*) m_ciwds.m_coaStdDataSecs[nmod] ;

	// Find the only one - if any - of the first three data section names that
	// can be added to the statement.

	for (int n = 0 ; n < NUMDATASECFLAGS - 1 ; n++, nid++)
		if ((*pcuia)[n]) {
			cs2.LoadString(nid) ;
			break ;
		} ;

	// If there is a nonstandard data section, add it too.

	if ((*pcuia)[IDF_OTHER]) {
		if (!cs2.IsEmpty())
			cs2 += csComma ;
		cs2 += m_ciwds.m_csaOtherDataSecs[nmod] ;
	} ;

	// Finish formating the data section statement and add it to the rest of
	// the install section.

	cs.Format(IDS_INFText_DataSecKey, cs2) ;
	csinst += cs ;
}


void CINFWizard::AddIncludeNeedsStmts(CString& csinst, int nmod)
{
	CString cs, cs2 ;

	// Build the Include statement and add it to the section..

	cs.Format(IDS_INFText_IncludeKey, m_ciwif.m_csaIncFiles[nmod]) ;
	csinst += cs ;

	// Prepare to determine the contents of the needs section statement.

	cs2 = csEmpty ;
	CUIntArray* pcuia = (CUIntArray*) m_ciwis.m_coaStdInstSecs[nmod] ;

	// The TrueType section, if needed, is the first section to list in the
	// Includes statement.

	if ((*pcuia)[ISF_TTF])
		cs2.LoadString(IDS_InstSecTtf) ;

	// Find the only one - if any - of the first three install section names
	// that can be added to the statement.

	int nid = IDS_InstSecUni ;
	for (int n = 0 ; n < NUMINSTSECFLAGS - 2 ; n++, nid++)
		if ((*pcuia)[n]) {
			if (!cs2.IsEmpty())
				cs2 += csComma ;
			cs.LoadString(nid) ;
			cs2 += cs ;
			break ;
		} ;

	// If there is a nonstandard install section, add it too.

	if ((*pcuia)[ISF_OTHER]) {
		if (!cs2.IsEmpty())
			cs2 += csComma ;
		cs2 += m_ciwis.m_csaOtherInstSecs[nmod] ;
	} ;

	// Finish formating the install section statement and add it to the rest of
	// the install section.

	cs.Format(IDS_INFText_NeedsKey, cs2) ;
	csinst += cs ;
}


void CINFWizard::AddNonStdSectionsForModel(CString& csinst, int nmod,
										   CString& csmodel)
{
	// Declare looping variables and find out how many nonstd sections there are

	int	n, n2, n3 ;
	int numelts = (int) m_ciwnsms.m_csaSections.GetSize() ;

	// If this is the first time this function is called, size and initialize
	// the "this section has already been added to the SourceDiskFiles" flags.

	if (nmod == 0) {
		m_cuiaNonStdSecsFlags.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)
			m_cuiaNonStdSecsFlags[n] = 0 ;
	} ;

	// Loop through all of the nonstandard sections looking for one that
	// references the current model.

	CStringArray* pcsa ;
	CStringArray* pcsa2 ;
	CString		  cssec ;
	for (n = 0 ; n < numelts ; n++) {
		// Get a pointer to the names of models that need the current section.

		pcsa = (CStringArray*) m_ciwnsms.m_coaModelsNeedingSecs[n] ;
		
		// Check each model in the above list to see if it matches the model
		// passed in as an argument to this function.

		for (n2 = 0 ; n2 < pcsa->GetSize() ; n2++)
			// If a match is found...

			if ((*pcsa)[n2] == csmodel) {
				// ...add the section name to the model's CopyFiles statement
				// (Strip the brackets off first.)...

				cssec = m_ciwnsms.m_csaSections[n] ;
				cssec = cssec.Mid(1, cssec.GetLength() - 2) ;
				csinst += csComma + cssec ;

				// ...and make sure that the sections files are listed in the
				// SourceDiskFiles section.

				if (!m_cuiaNonStdSecsFlags[n]) {
					pcsa2 = (CStringArray*) m_ciwnse.m_coaSectionArrays[n] ;
					for (n3 = 0 ; n3 < pcsa2->GetSize() ; n3++)
						m_csaSrcDskFiles.Add((*pcsa2)[n3]) ; // Add to [SourceDiskFiles] array
					m_cuiaNonStdSecsFlags[n] = 1 ;
				} ;
				break ;
			} ;
	} ;
}	


void CINFWizard::PrepareToRestart()
{
	// Set the flags needed to get the pages to reinitialize themselves but
	// keep all existing data.

	m_ciwm.m_bReInitWData = m_ciwbd.m_bReInitWData = true ;
	m_ciwip.m_bReInitWData = m_ciwef.m_bReInitWData = true ;
	m_ciwmn.m_bReInitWData = m_ciwnse.m_bReInitWData = true ;
	m_ciws.m_bReInitWData = m_ciwif.m_bReInitWData = true ;
	m_ciwis.m_bReInitWData = m_ciwds.m_bReInitWData = true ;
	m_ciwnsms.m_bReInitWData = m_ciwgpi.m_bReInitWData = true ;
}


BEGIN_MESSAGE_MAP(CINFWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CINFWizard)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizard message handlers


/////////////////////////////////////////////////////////////////////////////
// CINFWizWelcome property page

IMPLEMENT_DYNCREATE(CINFWizWelcome, CPropertyPage)

CINFWizWelcome::CINFWizWelcome() : CPropertyPage(CINFWizWelcome::IDD)
{
	//{{AFX_DATA_INIT(CINFWizWelcome)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = false ;
}

CINFWizWelcome::~CINFWizWelcome()
{
}

void CINFWizWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizWelcome)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizWelcome, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizWelcome)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizWelcome message handlers

BOOL CINFWizWelcome::OnSetActive()
{
	//  We wish to disable the "Back" button here.

	m_pciwParent->SetWizardButtons(PSWIZB_NEXT) ;
	m_pciwParent->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	m_bInitialized = true ;		// Page is initialized now

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizModels property page

IMPLEMENT_DYNCREATE(CINFWizModels, CPropertyPage)

CINFWizModels::CINFWizModels() : CPropertyPage(CINFWizModels::IDD)
{
	//{{AFX_DATA_INIT(CINFWizModels)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Initialize member variables

	m_bInitialized = m_bSelChanged = m_bReInitWData = false ;
	m_uNumModels = m_uNumModelsSel = 0 ;
}

CINFWizModels::~CINFWizModels()
{
}

void CINFWizModels::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizModels)
	DDX_Control(pDX, IDC_ModelsList, m_cfelcModels);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizModels, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizModels)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizModels message handlers

BOOL CINFWizModels::OnSetActive()
{
	// Reenable the "Back" button.
	CString cstmp ;   // RAID 0001  move to head from body
	m_pciwParent->SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK) ;

	m_cfelcModels.SetFocus() ;		// The list control gets the focus

	// If this page has been initialized already, make a copy of the current
	// selections and set the flag that indicates that the selection may be
	// changing.  See below for more info.
// RAID 0001
	if(NULL != m_pciwParent->m_pcgc ){
		CString csFilePath = m_pciwParent->m_pcgc->GetPathName();
		CString csModelName = m_pciwParent->m_pcgc->ModelData()->
	   		GetKeywordValue(csFilePath,_T("ModelName"));
		
		m_uNumModels = 1;
		m_csaModels.RemoveAll( );
		m_csaModels.Add(csModelName);

		if (m_bInitialized && !m_bReInitWData)
			return CPropertyPage::OnSetActive() ;

		m_csToggleStr.LoadString(IDS_INFModelsToggleStr) ;
		m_csaInclude.RemoveAll();
		m_csaInclude.Add(m_csToggleStr); 

	}

	else {
//END RAID 0001

		unsigned u ;
		if (m_bInitialized)	{		
			m_csaModelsLast.SetSize(m_uNumModelsSel) ;
			for (u = 0 ; u < m_uNumModelsSel ; u++)
				m_csaModelsLast[u] = m_csaModels[u] ;
			m_bSelChanged = true ;

			// Nothing more need be done if the page is not being reinitialized.

			if (!m_bReInitWData)
				return CPropertyPage::OnSetActive() ;
		} ;

		// The following info is needed when reinitializing and is used/described
		// later.
		
		unsigned unumselected, u2, ureinitidx ;
		if (m_bReInitWData)
			unumselected = ureinitidx = (unsigned)m_csaModels.GetSize() ;

		// Save the number of models in the project and use this number to set the
		// length of the models string array.

		m_uNumModels = m_pciwParent->GetModelCount() ;
		m_csaModels.SetSize(m_uNumModels) ;
		if (!m_bReInitWData)
			m_csaInclude.RemoveAll() ;

		// Load the model names into the models string array.  This is straight
		// forward if we are NOT reinitializing but more complicated when we are
		// reinitializing.  In the latter case, the user's previous selections
		// must be maintained at the beginning of the array.  The rest of the
		// models should be added to array after the selections.

	//	CString cstmp ;		RAID 0001
		for (u = 0 ; u < m_uNumModels ; u++) {
			cstmp = m_pciwParent->GetModel(u).Name() ;

			// If not reinitializing, just add the model name to the array.

			if (!m_bReInitWData)
				m_csaModels[u] = cstmp ;

			// Otherwise only add the model name to the array if it is not one of
			// the selected models that are already in the array.

			else {
				for (u2 = 0 ; u2 < unumselected ; u2++)
					if (m_csaModels[u2] == cstmp)
						break ;
				if (u2 >= unumselected)
					m_csaModels[ureinitidx++] = cstmp ;
			} ;
		} ;
		
		// Initialize the list control
	} // RAID 0001. else {
	m_cfelcModels.InitControl(LVS_EX_FULLROWSELECT, m_uNumModels, 2,
							  TF_HASTOGGLECOLUMNS+TF_CLICKONROW, 0,
							  MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_cfelcModels.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 20, false, true,
								 COLDATTYPE_STRING, (CObArray*) &m_csaModels) ;
	
	// Initialize the includes column in the list control.

	cstmp.LoadString(IDS_INFIncludesColLab) ;
	m_csToggleStr.LoadString(IDS_INFModelsToggleStr) ;
	m_cfelcModels.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -20, false,
								 true, COLDATTYPE_TOGGLE,
								 (CObArray*) &m_csaInclude, m_csToggleStr) ;
	
	m_bInitialized = true ;		// Page is initialized now
	m_bReInitWData = false ;	// Reinit is done now on this page
	return CPropertyPage::OnSetActive() ;
}


LRESULT CINFWizModels::OnWizardNext()
{
	// Make sure the list's contents are sorted in descending order by included
	// status.

	m_cfelcModels.SortControl(1) ;
	if (m_cfelcModels.GetColSortOrder(1))
		m_cfelcModels.SortControl(1) ;

	// Get the data in the included status column.

	m_cfelcModels.GetColumnData((CObArray*) &m_csaInclude, 1) ;

	// Complain and don't let the user continue if no models were selected.

	if (m_csaInclude.GetSize() == 0 || m_csaInclude[0].IsEmpty()) {
		CString csmsg ;
		csmsg.LoadString(IDS_INFNoModelsSel) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return -1 ;
	} ;

	// Get the data in the models column.

	m_cfelcModels.GetColumnData((CObArray*) &m_csaModels, 0) ;

	// Determine the number of included models and use this count to resize the
	// models array.

	m_uNumModelsSel = 0 ;
	for (unsigned u = 0 ; u < m_uNumModels ; u++) {
		if (m_csaInclude[u].IsEmpty())
			break ;
		m_uNumModelsSel++ ;
	} ;
	m_csaModels.SetSize(m_uNumModelsSel) ;

	// Call the sheet class to set the the other pages' fixup flags if the
	// selection changed.

	if (m_bSelChanged) {
		m_pciwParent->SetFixupFlags() ;
		m_bSelChanged = false ;
	} ;

	// All went well so move on to the next wizard page.
	
	return CPropertyPage::OnWizardNext() ;
}


int IdentifyOldAndNewModels(CStringArray& csanewmodels, CUIntArray& cuiaoldmodelsfound,
							CUIntArray& cuianewmodelsfound, int& newnumelts,
							CStringArray& csamodels)
{
	int		n, n2 ;				// Looping variables

	// Get the number of models in the new and old lists.

	int numelts = (int) csamodels.GetSize() ;
	newnumelts = (int) csanewmodels.GetSize() ;

	// Declare and initialize flag arrays used to determine which models are
	// in use.

	cuiaoldmodelsfound.SetSize(numelts) ;
	for (n = 0 ; n < numelts ; n++)
		cuiaoldmodelsfound[n] = 0 ;
	cuianewmodelsfound.SetSize(newnumelts) ;
	for (n = 0 ; n < newnumelts ; n++)
		cuianewmodelsfound[n] = 0 ;

	// Loop through the old & new models to see which of them are still in use.

	for (n = 0 ; n < numelts ; n++)
		for (n2 = 0 ; n2 < newnumelts ; n2++)
			if (csamodels[n] == csanewmodels[n2]) {
				cuiaoldmodelsfound[n] =	cuianewmodelsfound[n2] = 1 ;
				break ;
			} ;

	// Return the number models previously selected

	return numelts ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizGetPnPIDs property page

IMPLEMENT_DYNCREATE(CINFWizGetPnPIDs, CPropertyPage)

CINFWizGetPnPIDs::CINFWizGetPnPIDs() : CPropertyPage(CINFWizGetPnPIDs::IDD)
{
	//{{AFX_DATA_INIT(CINFWizGetPnPIDs)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
}

CINFWizGetPnPIDs::~CINFWizGetPnPIDs()
{
}


void CINFWizGetPnPIDs::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizGetPnPIDs)
	DDX_Control(pDX, IDC_ModelsPnPIDList, m_felcModelIDs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizGetPnPIDs, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizGetPnPIDs)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CINFWizGetPnPIDs message handlers

BOOL CINFWizGetPnPIDs::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;
								
	int		n, n2 ;				// Looping and indexing variables

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the selected model names.  Then make the PnP ID array
		// the same size and initialize each entry to empty.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		m_csaModelIDs.SetSize(m_csaModels.GetSize()) ;
		for (n = 0 ; n < m_csaModelIDs.GetSize() ; n++)
			m_csaModelIDs[n] = csEmpty ;

		// Initialize and load the list control

		InitModelsIDListCtl() ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  They are handled in similar
	// ways.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	int numelts, newnumelts ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			m_csaModelIDs.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize all related data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_csaModelIDs.InsertAt(n2, csEmpty) ;
	} ;

	// Reinitialize the list control if the wizard has been reinitialized.
	// Otherwise, just reload the columns in the list control.

	if (m_bReInitWData)
		InitModelsIDListCtl() ;
	else {
		// If necessary, zap extra old data that could be left in the control
		// after the new data is loaded.

		if (numelts > newnumelts) {
			CStringArray csa ;
			csa.SetSize(numelts) ;
			for (n = 0 ; n < numelts ; n++)
				csa[n] = csEmpty ;
			m_felcModelIDs.SetColumnData((CObArray*) &csa, 0) ;
			m_felcModelIDs.SetColumnData((CObArray*) &csa, 1) ;
		} ;

		m_felcModelIDs.SetColumnData((CObArray*) &m_csaModels, 0) ;
		m_felcModelIDs.SetColumnData((CObArray*) &m_csaModelIDs, 1) ;
	} ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


LRESULT CINFWizGetPnPIDs::OnWizardNext()
{
	// Get the data in the PnP ID column.

	m_felcModelIDs.GetColumnData((CObArray*) &m_csaModelIDs, 1) ;

	// Complain and exit without allowing the wizard page to change if a PnP ID
	// is found that contains spaces.

	int numelts = (int) m_csaModelIDs.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		if (m_csaModelIDs[n].Find(_T(' ')) >= 0) {
			AfxMessageBox(IDS_PnPSpacesError, MB_ICONEXCLAMATION) ;
			return -1 ;
		} ;
	} ;
	
	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizGetPnPIDs::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizGetPnPIDs::InitModelsIDListCtl()
{
	int				numelts ;	// Number of elements in an array
	CString			cstmp ;

	// Initialize the list control

	numelts = (int) m_csaModels.GetSize() ;
	m_felcModelIDs.InitControl(LVS_EX_FULLROWSELECT, numelts, 2, 0, 0,
							   MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_felcModelIDs.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 25, false,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &m_csaModels) ;

	// Initialize the PnP ID column in the list control.

	cstmp.LoadString(IDS_INFPnPIDColLab) ;
	m_felcModelIDs.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -25,
								  true, false, COLDATTYPE_STRING,
								  (CObArray*) &m_csaModelIDs) ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizBiDi property page

IMPLEMENT_DYNCREATE(CINFWizBiDi, CPropertyPage)

CINFWizBiDi::CINFWizBiDi() : CPropertyPage(CINFWizBiDi::IDD)
{
	//{{AFX_DATA_INIT(CINFWizBiDi)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
}


CINFWizBiDi::~CINFWizBiDi()
{
}


void CINFWizBiDi::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizBiDi)
	DDX_Control(pDX, IDC_ModelsList, m_cfelcBiDi);
	//}}AFX_DATA_MAP
}


void CINFWizBiDi::ModelChangeFixups(unsigned unummodelssel,
								    CStringArray& csamodels,
								    CStringArray& csamodelslast)
{	
	// Declare looping vars, get the size of the old selection array, and
	// declare and size a new flags array.

	unsigned u, u2, unumlst ;
	unumlst = (unsigned)csamodelslast.GetSize() ;
	CUIntArray cuaflags ;
	cuaflags.SetSize(unummodelssel) ;

	// Try to find each new model in the list of old models.  If found, copy the
	// models flag.  If not found, initialize the models flag to false.

	for (u = 0 ; u < unummodelssel ; u++) {
		for (u2 = 0 ; u2 < unumlst ; u2++) {
			if (csamodels[u] == csamodelslast[u2])
				break ;
		} ;
		cuaflags[u] = (u2 < unumlst) ? m_cuaBiDiFlags[u2] : false ;
	} ;

	// Copy the new flags array back into the member variable flags array.

	m_cuaBiDiFlags.SetSize(unummodelssel) ;
	for (u = 0 ; u < unummodelssel ; u++)
		m_cuaBiDiFlags[u] = cuaflags[u] ;

	// Now that the data structures are up to date, load the list control with
	// the new information.  (This part only needed if NOT reinitializing.)

	if (!m_bReInitWData) {
		m_cfelcBiDi.SetColumnData((CObArray*) &csamodels, 0) ;
		CString cs ;
		for (u = 0 ; u < unummodelssel ; u++) {
			cs = (m_cuaBiDiFlags[u]) ? m_csToggleStr : csEmpty ;
			VERIFY(m_cfelcBiDi.SetItemText(u, 1, cs)) ;
		} ;
	} ;
}


BEGIN_MESSAGE_MAP(CINFWizBiDi, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizBiDi)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizBiDi message handlers

BOOL CINFWizBiDi::OnSetActive()
{
	m_cfelcBiDi.SetFocus() ;	// The list control gets the focus

	// Nothing else need be done if this page has been initialized already
	// and it is not being asked to reinitialize the page...  That is,
	// except for possibly needing to pick up any selected model changes
	// that were made.

	if (m_bInitialized && !m_bReInitWData) {
		if (m_bSelChanged) {
			ModelChangeFixups(m_pciwParent->GetINFModsSelCount(),
							  m_pciwParent->GetINFModels(),
							  m_pciwParent->GetINFModelsLst()) ;
			m_bSelChanged = false ;
		} ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Get the array of selected models and declare an array for BiDi info.

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;
	CStringArray csabidi ;
	unsigned unumelts = (unsigned)csamodels.GetSize() ;
	m_csToggleStr.LoadString(IDS_INFBiDiToggleStr) ;

	// If not reinitializing, make sure the BiDi array is empty.  Otherwise,
	// initialize the BiDi strings array based on the settings in the BiDi
	// flags array.

	if (!m_bReInitWData)
		csabidi.RemoveAll() ;
	else {
		ModelChangeFixups(m_pciwParent->GetINFModsSelCount(),
						  m_pciwParent->GetINFModels(),
						  m_pciwParent->GetINFModelsLst()) ;
		csabidi.SetSize(unumelts) ;
		for (unsigned u = 0 ; u < unumelts ; u++)
			if (m_cuaBiDiFlags[u])
				csabidi[u] = m_csToggleStr ;
	} ;

	// Initialize the list control

	m_cfelcBiDi.InitControl(LVS_EX_FULLROWSELECT, unumelts, 2,
							TF_HASTOGGLECOLUMNS+TF_CLICKONROW, 0,
							MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	CString cstmp ;
	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_cfelcBiDi.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 40, false, true,
							   COLDATTYPE_STRING, (CObArray*) &csamodels) ;

	// Initialize the bidi column in the list control.

	cstmp.LoadString(IDS_INFBiDiColLab) ;
	m_cfelcBiDi.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -20, false, true,
							   COLDATTYPE_TOGGLE, (CObArray*) &csabidi,
							   m_csToggleStr) ;

	m_bInitialized = true ;		// Page is initialized now
	m_bReInitWData = false ;	// Reinit (if needed) is done now on this page
	return CPropertyPage::OnSetActive() ;
}


LRESULT CINFWizBiDi::OnWizardNext()
{
	// Make sure the list's contents are sorted in descending order by BI-DI
	// status.

	m_cfelcBiDi.SortControl(1) ;
	if (m_cfelcBiDi.GetColSortOrder(1))
		m_cfelcBiDi.SortControl(1) ;

	// Get the data in the models and BI-DI status columns.	 Then get the
	// original list of selected models.

	CStringArray csamodels, csabidi ;
	m_cfelcBiDi.GetColumnData((CObArray*) &csamodels, 0) ;
	m_cfelcBiDi.GetColumnData((CObArray*) &csabidi, 1) ;
	CStringArray& csaselmodels = m_pciwParent->GetINFModels() ;

	// Get the length of the arrays and use it to size the array that is used
	// to hold the BI-DI flags.

	unsigned unummodels = (unsigned)csaselmodels.GetSize() ;
	m_cuaBiDiFlags.SetSize(unummodels) ;

	// Now we need to set the BIDI flags correctly.  This is complicated a bit
	// because the models array from the Bi-Di list may not be in the same
	// order as the selected models array.  The flags array should map to the
	// selected models array.  There is extra code below to deal with this.

	for (unsigned u = 0 ; u < unummodels ; u++) {
		for (unsigned u2 = 0 ; u2 < unummodels ; u2++) {
			if (csaselmodels[u] == csamodels[u2]) {
				m_cuaBiDiFlags[u] = !csabidi[u2].IsEmpty() ;
				break ;
			} ;
		} ;
	} ;

	// If this is not the first time this page has been used, any changes made
	// could affect the data managed by some of the other pages.  Make a call
	// to fixup that data when needed.

	m_pciwParent->BiDiDataChanged() ;
		
	// All went well so move on to the next wizard page.
	
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizBiDi::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void InitListListPage(CListBox& clbmainlst, bool& binit, CINFWizard* pciwparent,
					  CObArray& coapermaindata,
					  CFullEditListCtrl& cfelcsecondlst, int ncollabid,
					  CStringArray& csamain, bool& breinitwdata,
					  int& ncurmodelidx, int neditlen, DWORD dwmiscflags)
{
	clbmainlst.SetFocus() ;	// The main list box gets the focus

	// Nothing else need be done if this page has been initialized already and
	// it has not be requested to reinitialize itself while keeping existing
	// data.

	if (binit && !breinitwdata)
		return ;

	// Count the array of items to load into the main list box.

	unsigned unummodels = (unsigned)csamain.GetSize() ;

	// Load the main items into the main list box.

	clbmainlst.ResetContent() ;
	for (unsigned u = 0 ; u < unummodels ; u++)
		clbmainlst.AddString(csamain[u]) ;

	CStringArray* pcsa ;
	
	// Initialize the array of string array pointers used to manage the data
	// in the second list for each item in the main list. (Only if not
	// reinitializing because the existing data must be maintained in this
	// case.)

	if (!breinitwdata) {
		coapermaindata.SetSize(unummodels) ;
		for (u = 0 ; u < unummodels ; u++) {	
			pcsa = new CStringArray ;
			pcsa->RemoveAll() ;
			coapermaindata[u] = (CObArray*) pcsa ;
		} ;
	} ;
	
	// Initialize the list control

	cfelcsecondlst.InitControl(LVS_EX_FULLROWSELECT+LVS_EX_GRIDLINES, 8, 1, 0,
							   neditlen, dwmiscflags) ;

	// Put some bogus entries into a string array that is used to "activate"
	// the list control.

	pcsa = new CStringArray ;
	pcsa->SetSize(8) ;
	for (u = 0 ; u < 8 ; u++)				
		pcsa->SetAt(u, csEmpty) ;

	// Initialize the only column in the list control.

	CString cstmp ;
	cstmp.LoadString(ncollabid) ;
	cfelcsecondlst.InitLoadColumn(0, cstmp, SETWIDTHTOREMAINDER, -16, true,
									true, COLDATTYPE_STRING, (CObArray*) pcsa) ;
	delete pcsa ;

	// Now that the list control has been initialized, disable it until a main
	// list item is selected.

	cfelcsecondlst.EnableWindow(false) ;

	ncurmodelidx = -1 ;			// Reset the current model index
	binit = true ;				// Page is initialized now
	breinitwdata = false ;		// Reinit (if needed) is done now on this page
	return ;
}


void SelChangedListListPage(CListBox& clbmainlst, bool binit,
							CObArray& coapermaindata,
						    CFullEditListCtrl& cfelcsecondlst,
							CButton* pcbbrowse, int& ncurmainidx)
{
	// Do nothing if the page has not been initialized yet.

	if (!binit)
		return ;

	// Make sure the Profiles list and Browse button are enabled.

	if (pcbbrowse != NULL)
		pcbbrowse->EnableWindow() ;
	cfelcsecondlst.EnableWindow() ;

	// If there was a previous selection in the list box, save that model's
	// filespecs before loading the current model's filespecs.

	CStringArray* pcsa ;
	if (ncurmainidx != -1) {
		cfelcsecondlst.SaveValue() ;
		pcsa = (CStringArray*) coapermaindata[ncurmainidx] ;
		cfelcsecondlst.GetColumnData((CObArray*) pcsa, 0) ;
	} ;

	// Update the current model index and load its filespecs into the list
	// control.  Before loading, make sure that the current model's file array
	// is long enough to overwrite all of the last model's file strings that
	// are currently in the list.

	if ((ncurmainidx = clbmainlst.GetCurSel()) != -1) {
		pcsa = (CStringArray*) coapermaindata[ncurmainidx] ;
		int nelts = (int)pcsa->GetSize() ;
		int nrows = cfelcsecondlst.GetItemCount() ;
		if (nelts < nrows) {
			pcsa->SetSize(nrows) ;
			for (int n = nrows ; n < nelts ; n++)
				pcsa->SetAt(n, csEmpty) ;
		} ;
		cfelcsecondlst.SetColumnData((CObArray*) pcsa, 0) ;
	} ;
}
						

void OnBrowseListListPage(CFullEditListCtrl& cfelcsecondlst, int nfiletypeid)
{	
	// Prepare for and prompt the user for a filespec to add to the list
	// control.  Return if the user cancels.

	CString cstmp ;
	cstmp.LoadString(nfiletypeid) ;
	CFileDialog cfd(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, cstmp) ;
	if (cfd.DoModal() != IDOK)
		return ;

	// Get the user selected filespec.

	cstmp = cfd.GetPathName() ;

	// Determine the row to place the filespec in

	int nrow ;
	if ((nrow = cfelcsecondlst.GetNextItem(-1, LVNI_SELECTED)) == -1)
		nrow = 0 ;

	// Save the filespec in the profiles list

	VERIFY(cfelcsecondlst.SetItemText(nrow, 0, cstmp)) ;
}


void OnWizNextListListPage(int& ncurmainidx, CFullEditListCtrl& cfelcsecondlst,
						   CObArray& coapermaindata)
{
	// If there was a previous selection in the list box, save that item's
	// data.

	CStringArray* pcsa ;
	if (ncurmainidx != -1) {
		cfelcsecondlst.SaveValue() ;
		pcsa = (CStringArray*) coapermaindata[ncurmainidx] ;
		cfelcsecondlst.GetColumnData((CObArray*) pcsa, 0) ;
	} ;

	// Users may not fill every string in the string arrays so get rid of the
	// ones that are empty.

	int nnummodels = (int)coapermaindata.GetSize() ;
	int nnumfiles, n, n2, n3 ;
	for (n = 0 ; n < nnummodels ; n++) {
		pcsa = (CStringArray*) coapermaindata[n] ;
		nnumfiles = (int)pcsa->GetSize() ;
		for (n2 = n3 = 0 ; n2 < nnumfiles ; n2++) {
			(pcsa->GetAt(n3)).TrimLeft() ;
			(pcsa->GetAt(n3)).TrimRight() ;
			if ((pcsa->GetAt(n3)).IsEmpty())
				pcsa->RemoveAt(n3) ;
			else
				n3++ ;
		} ;
	} ;
}


void ModelChangeFixupsListListPage(unsigned unummodelssel,
								   CStringArray& csamodels,	
								   CStringArray& csamodelslast,
								   CFullEditListCtrl& cfelcsecondlst,
								   CObArray& coapermaindata, int& ncurmainidx,
								   CButton* pcbbrowse, CListBox& clbmainlst,
								   bool& breinitwdata)
{
	// Declare looping vars, get the size of the old selection array, and
	// declare / size / initialize a new profiles array.

	unsigned u, u2, unumlst, unumrows, unumold ;
	unumlst = (unsigned) csamodelslast.GetSize() ;
	if ((unumrows = cfelcsecondlst.GetItemCount()) == 0)
		unumrows = 8 ;
	CObArray coaprofarrays ;
	CStringArray *pcsa, *pcsaold ;
	coaprofarrays.SetSize(unummodelssel) ;
	for (u = 0 ; u < unummodelssel ; u++) {
		pcsa = new CStringArray ;
		pcsa->SetSize(unumrows) ;
		for (u2 = 0 ; u2 < unumrows ; u2++)
			pcsa->SetAt(u2, csEmpty) ;
		coaprofarrays[u] = (CObArray*) pcsa ;
	} ;

	// Clear the list control if not reinitializing.

	if (!breinitwdata)
		cfelcsecondlst.SetColumnData((CObArray*) coaprofarrays[0], 0) ;

	// Try to find each new model in the list of old models.  If found, copy the
	// old model's data to the new profiles array.

	for (u = 0 ; u < unummodelssel ; u++) {
		for (u2 = 0 ; u2 < unumlst ; u2++) {
			if (csamodels[u] == csamodelslast[u2])
				break ;
		} ;
		if (u2 < unumlst) {
			pcsa = (CStringArray*) coaprofarrays[u] ;
			pcsaold = (CStringArray*) coapermaindata[u2] ;
			unumold	= (unsigned)pcsaold->GetSize() ;
			for (u2 = 0 ; u2 < unumold ; u2++)
				pcsa->SetAt(u2, pcsaold->GetAt(u2)) ;
		} ;
	} ;

	// Delete all of the old data

	for (u = 0 ; u < (unsigned) coapermaindata.GetSize() ; u++) {
		pcsaold = (CStringArray*) coapermaindata[u] ;
		delete pcsaold ;
	} ;

	// Copy the new data into the member variable

	coapermaindata.SetSize(unummodelssel) ;
	for (u = 0 ; u < unummodelssel ; u++)
		coapermaindata[u] = coaprofarrays[u] ;

	// Now that the data structures are up to date, finish updating the page's
	// controls.

	ncurmainidx = -1 ;
	cfelcsecondlst.EnableWindow(false) ;
	pcbbrowse->EnableWindow(false) ;
	clbmainlst.ResetContent() ;
	for (u = 0 ; u < unummodelssel ; u++)
		clbmainlst.AddString(csamodels[u]) ;
	clbmainlst.SetCurSel(-1) ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizICMProfiles property page

IMPLEMENT_DYNCREATE(CINFWizICMProfiles, CPropertyPage)

CINFWizICMProfiles::CINFWizICMProfiles() : CPropertyPage(CINFWizICMProfiles::IDD)
{
	//{{AFX_DATA_INIT(CINFWizICMProfiles)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}

CINFWizICMProfiles::~CINFWizICMProfiles()
{
	// Delete the string arrays referenced in m_coaProfileArrays.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaProfileArrays.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaProfileArrays[n] ;
		delete pcsa ;
	} ;
}

void CINFWizICMProfiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizICMProfiles)
	DDX_Control(pDX, IDC_ICMFSpecsLst, m_cfelcICMFSpecs);
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Control(pDX, IDC_BrowseBtn, m_cbBrowse);
	//}}AFX_DATA_MAP
}


void CINFWizICMProfiles::ModelChangeFixups(unsigned unummodelssel,
										   CStringArray& csamodels,
										   CStringArray& csamodelslast)
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return ;

	// See ModelChangeFixupsListListPage() for more information.

	ModelChangeFixupsListListPage(unummodelssel, csamodels, csamodelslast,
								  m_cfelcICMFSpecs, m_coaProfileArrays,
								  m_nCurModelIdx, &m_cbBrowse, m_clbModels,
								  m_bReInitWData) ;
}


BEGIN_MESSAGE_MAP(CINFWizICMProfiles, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizICMProfiles)
	ON_BN_CLICKED(IDC_BrowseBtn, OnBrowseBtn)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizICMProfiles message handlers

BOOL CINFWizICMProfiles::OnSetActive()
{
	// Get the list of models to load into the main list box.

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;

	// Nothing else need be done if this page has been initialized already
	// and it is not being asked to reinitialize the page...  That is,
	// except for possibly needing to pick up any selected model changes
	// that were made.

	if (m_bInitialized && !m_bReInitWData) {
		if (m_bSelChanged) {
			ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
							  m_pciwParent->GetINFModelsLst()) ;
			m_bSelChanged = false ;
		} ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Pick up selected model changes when reinitializing

	if (m_bReInitWData)	{
		ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
						  m_pciwParent->GetINFModelsLst()) ;
		m_bSelChanged = false ;
	} ;

	// See InitListListPage() for more details.

	InitListListPage(m_clbModels, m_bInitialized, m_pciwParent,
					 m_coaProfileArrays, m_cfelcICMFSpecs, IDS_INFICMColLab,
					 csamodels, m_bReInitWData, m_nCurModelIdx, 256, 0) ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizICMProfiles::OnSelchangeModelsLst()
{
	SelChangedListListPage(m_clbModels, m_bInitialized, m_coaProfileArrays,
						   m_cfelcICMFSpecs, &m_cbBrowse, m_nCurModelIdx) ;
}


void CINFWizICMProfiles::OnBrowseBtn()
{
	// See OnBrowseListListPage() for more information.

	OnBrowseListListPage(m_cfelcICMFSpecs, IDS_CommonICMFile) ;
}


LRESULT CINFWizICMProfiles::OnWizardNext()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return -1 ;

	// See OnWizNextListListPage() for more information.
	
	OnWizNextListListPage(m_nCurModelIdx, m_cfelcICMFSpecs, m_coaProfileArrays);
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizICMProfiles::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizIncludeFiles property page

IMPLEMENT_DYNCREATE(CINFWizIncludeFiles, CPropertyPage)

CINFWizIncludeFiles::CINFWizIncludeFiles() : CPropertyPage(CINFWizIncludeFiles::IDD)
{
	//{{AFX_DATA_INIT(CINFWizIncludeFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}

CINFWizIncludeFiles::~CINFWizIncludeFiles()
{
}

void CINFWizIncludeFiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizIncludeFiles)
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Control(pDX, IDC_IncludeFileBox, m_ceIncludeFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizIncludeFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizIncludeFiles)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizIncludeFiles message handlers

BOOL CINFWizIncludeFiles::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;

	int		n, n2 ;					// Looping variable
	int		numelts, newnumelts ;	// Number of elements in an array
	CString	cstmp ;					// Temp string

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the currently selected model names and then load them
		// into the list box. Set the focus to the list box.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
			m_clbModels.AddString(m_csaModels[n]) ;
		m_clbModels.SetFocus() ;

		// Size and initialize the include files array.  Initialize each
		// include file to the default.

		cstmp.LoadString(IDS_DefINFIncFile) ;
		m_csaIncFiles.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)
			m_csaIncFiles[n] = cstmp ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  Both are handled the same way.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			m_csaIncFiles.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize an Include File string for it.

	cstmp.LoadString(IDS_DefINFIncFile) ;
	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_csaIncFiles.InsertAt(n2, cstmp) ;
	} ;

	// Clear the Include Files edit box

	m_ceIncludeFile.SetWindowText(csEmpty) ;

	// Reinitialize the models array and the current model index.

	m_clbModels.ResetContent() ;
	for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
		m_clbModels.AddString(m_csaModels[n]) ;
	m_clbModels.SetCurSel(-1) ;
	m_clbModels.SetFocus() ;
	m_nCurModelIdx = -1 ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizIncludeFiles::OnSelchangeModelsLst()
{
	// If there was a previous model selection, save its include file string.
	// Otherwise, enable the include file edit box.

	if (m_nCurModelIdx != -1)
		m_ceIncludeFile.GetWindowText(m_csaIncFiles[m_nCurModelIdx]) ;
	else
		m_ceIncludeFile.EnableWindow() ;

	// Save the index for the currently selected model.  Then load the edit box
	// with the include file string for that model.

	m_nCurModelIdx = m_clbModels.GetCurSel() ;
	m_ceIncludeFile.SetWindowText(m_csaIncFiles[m_nCurModelIdx]) ;
}

	
LRESULT CINFWizIncludeFiles::OnWizardNext()
{
	// Save the index for the currently selected model.  If the value is valid,
	// save the include file string for this model.

	if ((m_nCurModelIdx = m_clbModels.GetCurSel()) != -1)
		m_ceIncludeFile.GetWindowText(m_csaIncFiles[m_nCurModelIdx]) ;

	// Make sure each model has an include file string.  Complain and exit
	// without allowing the page to change if an empty string is found.

	int numelts = (int) m_csaIncFiles.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		if (m_csaIncFiles[n].IsEmpty()) {
			CString cserrmsg ;
			cserrmsg.Format(IDS_INFMissingIncError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			m_ceIncludeFile.SetFocus() ;
			return -1 ;
		} ;
	} ;

	// All went well so...
	
	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizIncludeFiles::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizInstallSections property page

IMPLEMENT_DYNCREATE(CINFWizInstallSections, CPropertyPage)

CINFWizInstallSections::CINFWizInstallSections() : CPropertyPage(CINFWizInstallSections::IDD)
{
	//{{AFX_DATA_INIT(CINFWizInstallSections)
	m_csOtherSections = _T("");
	m_bOther = FALSE;
	m_bPscript = FALSE;
	m_bTtfsub = FALSE;
	m_bUnidrvBidi = FALSE;
	m_bUnidrv = FALSE;
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}


CINFWizInstallSections::~CINFWizInstallSections()
{
	// Delete the flag arrays referenced in m_coaStdInstSecs.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdInstSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;
		delete pcuia ;
	} ;
}


void CINFWizInstallSections::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizInstallSections)
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Text(pDX, IDC_OtherBox, m_csOtherSections);
	DDX_Check(pDX, IDC_OtherChk, m_bOther);
	DDX_Check(pDX, IDC_PscriptChk, m_bPscript);
	DDX_Check(pDX, IDC_TtfsubChk, m_bTtfsub);
	DDX_Check(pDX, IDC_UnidrvBidiChk, m_bUnidrvBidi);
	DDX_Check(pDX, IDC_UnidrvChk, m_bUnidrv);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizInstallSections, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizInstallSections)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	ON_BN_CLICKED(IDC_OtherChk, OnOtherChk)
	ON_BN_CLICKED(IDC_PscriptChk, OnPscriptChk)
	ON_BN_CLICKED(IDC_TtfsubChk, OnTtfsubChk)
	ON_BN_CLICKED(IDC_UnidrvBidiChk, OnUnidrvBidiChk)
	ON_BN_CLICKED(IDC_UnidrvChk, OnUnidrvChk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizInstallSections message handlers

BOOL CINFWizInstallSections::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;

	int		n, n2 ;					// Looping variable
	int		numelts, newnumelts ;	// Number of elements in an array
	CUIntArray* pcuia ;				// Used to reference a model's flags array

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the currently selected model names and initialize the
		// controls on this page.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		numelts = InitPageControls() ;

		// Size and initialize the standard install sections array.  There is
		// one entry in the array per model.  Each entry references an array
		// of flags that specify the install sections for each model.  See
		// below to see how the flags are initialized.
		//
		// The other install sections string array is sized and initialized too.
		
		m_coaStdInstSecs.SetSize(numelts) ;
		m_csaOtherInstSecs.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)	
			AddModelFlags(n) ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  Both are handled the same way.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;
			delete pcuia ;
			m_coaStdInstSecs.RemoveAt(n) ;
			m_csaOtherInstSecs.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize all related Install Section data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_coaStdInstSecs.InsertAt(n2, (CObject*) NULL) ;
		m_csaOtherInstSecs.InsertAt(n2, csEmpty) ;
		AddModelFlags(n2) ;
	} ;

	// Initialize the controls on the page

	InitPageControls() ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizInstallSections::AddModelFlags(int nidx)
{
	int			n ;				// Looping variable
	CUIntArray* pcuia ;			// Used to reference a model's flags array
	CString		csfname ;		// Model's file name

	// Allocate the flags array and save it in the array of flags arrays.
	// Next, initialize the other sections string for this model.

	pcuia = new CUIntArray ;
	m_coaStdInstSecs[nidx] = (CObArray*) pcuia ;
	m_csaOtherInstSecs[nidx].Empty() ;

	// Size the current flags array and initialize each one to 0 (off).

	pcuia->SetSize(NUMINSTSECFLAGS) ;
	for (n = 0 ; n < NUMINSTSECFLAGS ; n++)
		(*pcuia)[n] = 0 ;

	// Get the model's file name and check its extension to see if
	// one of its Unidrv or its PostScript flag should be set.  (The
	// other flags are only user settable so they aren't changed.)
	//RAID 0001
	csfname = m_pciwParent->GetModelFile(m_csaModels[nidx]) ;
	if (csfname.Find(_T(".GPD")) != -1) {
		// The UNIDRVBIDI section is used (flagged) if the user marked
		// this model BIDI.  Otherwise, the UNIDRV section is used.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[nidx])
			(*pcuia)[ISF_UNIBIDI] = 1 ;
		else
			(*pcuia)[ISF_UNI] = 1 ;
	
	// Postcript file.

	} else
		(*pcuia)[ISF_PSCR] = 1 ;
}


int CINFWizInstallSections::InitPageControls()
{
	int		n ;					// Looping variable
	int		numelts ;			// Number of elements in an array

	// Load the current set of models into the list box

	m_clbModels.ResetContent() ;
	for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
		m_clbModels.AddString(m_csaModels[n]) ;
	
	// Make sure there is no model selected in the list box and that the box
	// has the focus.

	m_clbModels.SetCurSel(-1) ;
	m_clbModels.SetFocus() ;
	m_nCurModelIdx = -1 ;

	// Clear and disable all of the check boxes and the Other edit box.

	for (n = IDC_UnidrvChk ; n <= IDC_TtfsubChk ; n++)
		GetDlgItem(n)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(FALSE) ;
	m_bUnidrv = m_bUnidrvBidi = m_bPscript = m_bTtfsub = m_bOther = FALSE ;
	m_csOtherSections = csEmpty ;
	UpdateData(FALSE) ;

	// Return the number of elements in the list box.  Ie, the number of
	// selected models.

	return numelts ;
}

	
LRESULT CINFWizInstallSections::OnWizardNext()
{
	// Save the index for the currently selected model.  If the value is valid,
	// save the install section data for this model.

	if ((m_nCurModelIdx = m_clbModels.GetCurSel()) != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdInstSecs[m_nCurModelIdx] ;
		(*pcuia)[ISF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[ISF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[ISF_PSCR] = (unsigned) m_bPscript ;
		(*pcuia)[ISF_TTF] =	(unsigned) m_bTtfsub ;
		if ((*pcuia)[ISF_OTHER] = (unsigned) m_bOther)
			m_csaOtherInstSecs[m_nCurModelIdx] = m_csOtherSections ;
	} ;
	
	// Make sure that each model has one of the main sections selected and, if
	// the Other section was selected, it has an Other string.

	CString cserrmsg ;
	CUIntArray* pcuia ;
	int numelts = (int) m_csaModels.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;
		TRACE("*** %s: ISF_UNI=%d  ISF_UNIBIDI=%d  ISF_PSCR=%d  ISF_OTHER=%d\n", m_csaModels[n], (*pcuia)[ISF_UNI], (*pcuia)[ISF_UNIBIDI], (*pcuia)[ISF_PSCR], (*pcuia)[ISF_OTHER]) ;
		if ((*pcuia)[ISF_UNI] == 0 && (*pcuia)[ISF_UNIBIDI] == 0
		 && (*pcuia)[ISF_PSCR] == 0 && (*pcuia)[ISF_OTHER] == 0) {
			cserrmsg.Format(IDS_INFMissingInstSecError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
		if ((*pcuia)[ISF_OTHER] && m_csaOtherInstSecs[n].IsEmpty()) {
			cserrmsg.Format(IDS_INFNoOtherStrError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
	} ;

	// All went well so...

	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizInstallSections::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizInstallSections::OnSelchangeModelsLst()
{
	// If there was a previous model selection, save its install section flags.
	// Otherwise, enable the install section check boxes.

	if (m_nCurModelIdx != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdInstSecs[m_nCurModelIdx] ;
		(*pcuia)[ISF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[ISF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[ISF_PSCR] = (unsigned) m_bPscript ;
		(*pcuia)[ISF_TTF] =	(unsigned) m_bTtfsub ;
		if ((*pcuia)[ISF_OTHER] = (unsigned) m_bOther)
			m_csaOtherInstSecs[m_nCurModelIdx] = m_csOtherSections ;
	} else {
		for (int n = IDC_UnidrvChk ; n <= IDC_TtfsubChk ; n++)
			GetDlgItem(n)->EnableWindow(TRUE) ;
	} ;

	// Save the index for the currently selected model.  Then set the check
	// boxes based on the flags for the specified model.

	m_nCurModelIdx = m_clbModels.GetCurSel() ;
	CUIntArray* pcuia = (CUIntArray*) m_coaStdInstSecs[m_nCurModelIdx] ;
	m_bUnidrv = (BOOL) ((*pcuia)[ISF_UNI]) ;
	m_bUnidrvBidi = (BOOL) ((*pcuia)[ISF_UNIBIDI]) ;
	m_bPscript = (BOOL) ((*pcuia)[ISF_PSCR]) ;
	m_bTtfsub = (BOOL) ((*pcuia)[ISF_TTF]) ;
	if (m_bOther = (BOOL) ((*pcuia)[ISF_OTHER]))
		m_csOtherSections = m_csaOtherInstSecs[m_nCurModelIdx] ;
	else
		m_csOtherSections = csEmpty ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;
	UpdateData(FALSE) ;
}


void CINFWizInstallSections::OnPscriptChk()
{
	// If the PostScript checkbox is checked, the Unidrv and TrueType check
	// boxes must be unchecked.

	UpdateData(TRUE) ;
	if (m_bPscript) {
		m_bTtfsub = m_bUnidrvBidi = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnTtfsubChk()
{
	// If the TrueType box is checked, clear the PostScript checkbox.

	UpdateData(TRUE) ;
	if (m_bTtfsub) {
		m_bPscript = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnUnidrvBidiChk()
{
	// If the UNIDRV_BIDI box is checked, the UNIDRV and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrvBidi) {
		m_bPscript = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnUnidrvChk()
{
	// If the UNIDRV box is checked, the UNIDRV_BIDI and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrv) {
		m_bPscript = m_bUnidrvBidi = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnOtherChk()
{
	// Enable or disable the Other sections edit box based on the new state of
	// the Other check box.

	UpdateData(TRUE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;

	// If the Other check box was just checked, move the focus to the Other box.

	if (m_bOther)
		GetDlgItem(IDC_OtherBox)->SetFocus() ;
}


void CINFWizInstallSections::BiDiDataChanged()
{
	// Do nothing if this page has not be initialized yet.  In addition, do
	// nothing if the selected models may have changed or a reinit has been
	// request.  These cases are taken care of in OnSetActive().  In additon,
	// it allows this routine to know that the model data in this page are in
	// the same order as the data in the BiDi page().

	if (!m_bInitialized || m_bReInitWData || m_bSelChanged)
		return ;

	// Loop through the data for each selected model and make sure it agrees
	// as much as possible with the current BiDi settings.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdInstSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;

		// If the model's BiDi flag is set, make sure it is set here and that
		// its Unidriv and PScript flags are clear.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[n]) {
			(*pcuia)[ISF_UNIBIDI] = 1 ;
			(*pcuia)[ISF_UNI] = (*pcuia)[ISF_PSCR] = 0 ;

		// Otherwise, clear the BiDi flag.  Then set the Unidrv flag if the
		// PScript flag is clear.

		} else {
			(*pcuia)[ISF_UNIBIDI] = 0 ;
			if ((*pcuia)[ISF_PSCR] == 0)
				(*pcuia)[ISF_UNI] = 1 ;
		} ;
	} ;

	// Reinitialize the controls on the page.

	InitPageControls() ;
}


//////////////////////////////////////////////////////////////////////////
// CINFWizDataSections property page

IMPLEMENT_DYNCREATE(CINFWizDataSections, CPropertyPage)

CINFWizDataSections::CINFWizDataSections() : CPropertyPage(CINFWizDataSections::IDD)
{
	//{{AFX_DATA_INIT(CINFWizDataSections)
	m_csOtherSections = _T("");
	m_bOther = FALSE;
	m_bPscript = FALSE;
	m_bUnidrvBidi = FALSE;
	m_bUnidrv = FALSE;
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}


CINFWizDataSections::~CINFWizDataSections()
{
	// Delete the flag arrays referenced in m_coaStdDataSecs.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdDataSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;
		delete pcuia ;
	} ;
}


void CINFWizDataSections::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizDataSections)
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Text(pDX, IDC_OtherBox, m_csOtherSections);
	DDX_Check(pDX, IDC_OtherChk, m_bOther);
	DDX_Check(pDX, IDC_PscriptChk, m_bPscript);
	DDX_Check(pDX, IDC_UnidrvBidiChk, m_bUnidrvBidi);
	DDX_Check(pDX, IDC_UnidrvChk, m_bUnidrv);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizDataSections, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizDataSections)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	ON_BN_CLICKED(IDC_OtherChk, OnOtherChk)
	ON_BN_CLICKED(IDC_PscriptChk, OnPscriptChk)
	ON_BN_CLICKED(IDC_UnidrvBidiChk, OnUnidrvBidiChk)
	ON_BN_CLICKED(IDC_UnidrvChk, OnUnidrvChk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizDataSections message handlers

BOOL CINFWizDataSections::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;

	int		n, n2 ;					// Looping variable
	int		numelts, newnumelts ;	// Number of elements in an array
	CUIntArray* pcuia ;				// Used to reference a model's flags array

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the currently selected model names and initialize the
		// controls on this page.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		numelts = InitPageControls() ;

		// Size and initialize the standard data sections array.  There is
		// one entry in the array per model.  Each entry references an array
		// of flags that specify the data sections for each model.  See
		// below to see how the flags are initialized.
		//
		// The other data sections string array is sized and initialized too.
		
		m_coaStdDataSecs.SetSize(numelts) ;
		m_csaOtherDataSecs.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)	
			AddModelFlags(n) ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  Both are handled the same way.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;
			delete pcuia ;
			m_coaStdDataSecs.RemoveAt(n) ;
			m_csaOtherDataSecs.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize all related Data Section data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_coaStdDataSecs.InsertAt(n2, (CObject*) NULL) ;
		m_csaOtherDataSecs.InsertAt(n2, csEmpty) ;
		AddModelFlags(n2) ;
	} ;

	// Initialize the controls on the page

	InitPageControls() ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizDataSections::AddModelFlags(int nidx)
{
	int			n ;				// Looping variable
	CUIntArray* pcuia ;			// Used to reference a model's flags array
	CString		csfname ;		// Model's file name

	// Allocate the flags array and save it in the array of flags arrays.
	// Next, initialize the other sections string for this model.

	pcuia = new CUIntArray ;
	m_coaStdDataSecs[nidx] = (CObArray*) pcuia ;
	m_csaOtherDataSecs[nidx].Empty() ;

	// Size the current flags array and initialize each one to 0 (off).

	pcuia->SetSize(NUMDATASECFLAGS) ;
	for (n = 0 ; n < NUMDATASECFLAGS ; n++)
		(*pcuia)[n] = 0 ;

	// Get the model's file name and check its extension to see if
	// one of its Unidrv or its PostScript flag should be set.  (The
	// other flags are only user settable so they aren't changed.)

	csfname = m_pciwParent->GetModelFile(m_csaModels[nidx]) ;
	if (csfname.Find(_T(".GPD")) != -1) {
		// The UNIDRVBIDI section is used (flagged) if the user marked
		// this model BIDI.  Otherwise, the UNIDRV section is used.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[nidx])
			(*pcuia)[IDF_UNIBIDI] = 1 ;
		else
			(*pcuia)[IDF_UNI] = 1 ;
	
	// Postcript file.

	} else
		(*pcuia)[IDF_PSCR] = 1 ;
}


int CINFWizDataSections::InitPageControls()
{
	int		n ;					// Looping variable
	int		numelts ;			// Number of elements in an array

	// Load the current set of models into the list box

	m_clbModels.ResetContent() ;
	for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
		m_clbModels.AddString(m_csaModels[n]) ;
	
	// Make sure there is no model selected in the list box and that the box
	// has the focus.

	m_clbModels.SetCurSel(-1) ;
	m_clbModels.SetFocus() ;
	m_nCurModelIdx = -1 ;

	// Clear and disable all of the check boxes and the Other edit box.

	for (n = IDC_UnidrvChk ; n <= IDC_OtherChk ; n++)
		GetDlgItem(n)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(FALSE) ;
	m_bUnidrv = m_bUnidrvBidi = m_bPscript = m_bOther = FALSE ;
	m_csOtherSections = csEmpty ;
	UpdateData(FALSE) ;

	// Return the number of elements in the list box.  Ie, the number of
	// selected models.

	return numelts ;
}

	
LRESULT CINFWizDataSections::OnWizardNext()
{
	// Save the index for the currently selected model.  If the value is valid,
	// save the install section data for this model.

	if ((m_nCurModelIdx = m_clbModels.GetCurSel()) != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdDataSecs[m_nCurModelIdx] ;
		(*pcuia)[IDF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[IDF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[IDF_PSCR] = (unsigned) m_bPscript ;
		if ((*pcuia)[IDF_OTHER] = (unsigned) m_bOther)
			m_csaOtherDataSecs[m_nCurModelIdx] = m_csOtherSections ;
	} ;
	
	// Make sure that each model has one of the main sections selected and, if
	// the Other section was selected, it has an Other string.

	CString cserrmsg ;
	CUIntArray* pcuia ;
	int numelts = (int) m_csaModels.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;
		TRACE("*** %s: IDF_UNI=%d  IDF_UNIBIDI=%d  IDF_PSCR=%d  IDF_OTHER=%d\n", m_csaModels[n], (*pcuia)[IDF_UNI], (*pcuia)[IDF_UNIBIDI], (*pcuia)[IDF_PSCR], (*pcuia)[IDF_OTHER]) ;
		if ((*pcuia)[IDF_UNI] == 0 && (*pcuia)[IDF_UNIBIDI] == 0
		 && (*pcuia)[IDF_PSCR] == 0 && (*pcuia)[IDF_OTHER] == 0) {
			cserrmsg.Format(IDS_INFMissingDataSecError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
		if ((*pcuia)[IDF_OTHER] && m_csaOtherDataSecs[n].IsEmpty()) {
			cserrmsg.Format(IDS_INFNoOtherStrError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
	} ;

	// All went well so...

	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizDataSections::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizDataSections::OnSelchangeModelsLst()
{
	// If there was a previous model selection, save its data section flags.
	// Otherwise, enable the install section check boxes.

	if (m_nCurModelIdx != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdDataSecs[m_nCurModelIdx] ;
		(*pcuia)[IDF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[IDF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[IDF_PSCR] = (unsigned) m_bPscript ;
		if ((*pcuia)[IDF_OTHER] = (unsigned) m_bOther)
			m_csaOtherDataSecs[m_nCurModelIdx] = m_csOtherSections ;
	} else {
		for (int n = IDC_UnidrvChk ; n <= IDC_OtherChk ; n++)
			GetDlgItem(n)->EnableWindow(TRUE) ;
	} ;

	// Save the index for the currently selected model.  Then set the check
	// boxes based on the flags for the specified model.

	m_nCurModelIdx = m_clbModels.GetCurSel() ;
	CUIntArray* pcuia = (CUIntArray*) m_coaStdDataSecs[m_nCurModelIdx] ;
	m_bUnidrv = (BOOL) ((*pcuia)[IDF_UNI]) ;
	m_bUnidrvBidi = (BOOL) ((*pcuia)[IDF_UNIBIDI]) ;
	m_bPscript = (BOOL) ((*pcuia)[IDF_PSCR]) ;
	if (m_bOther = (BOOL) ((*pcuia)[IDF_OTHER]))
		m_csOtherSections = m_csaOtherDataSecs[m_nCurModelIdx] ;
	else
		m_csOtherSections = csEmpty ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;
	UpdateData(FALSE) ;
}


void CINFWizDataSections::OnOtherChk()
{
	// Enable or disable the Other sections edit box based on the new state of
	// the Other check box.

	UpdateData(TRUE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;

	// If the Other check box was just checked, move the focus to the Other box.

	if (m_bOther)
		GetDlgItem(IDC_OtherBox)->SetFocus() ;
}


void CINFWizDataSections::OnPscriptChk()
{
	// If the PostScript checkbox is checked, the Unidrv boxes must be
	// unchecked.

	UpdateData(TRUE) ;
	if (m_bPscript) {
		m_bUnidrvBidi = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizDataSections::OnUnidrvBidiChk()
{
	// If the UNIDRV_BIDI box is checked, the UNIDRV and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrvBidi) {
		m_bPscript = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizDataSections::OnUnidrvChk()
{
	// If the UNIDRV box is checked, the UNIDRV_BIDI and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrv) {
		m_bPscript = m_bUnidrvBidi = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizDataSections::BiDiDataChanged()
{
	// Do nothing if this page has not be initialized yet.  In addition, do
	// nothing if the selected models may have changed or a reinit has been
	// request.  These cases are taken care of in OnSetActive().  In additon,
	// it allows this routine to know that the model data in this page are in
	// the same order as the data in the BiDi page().

	if (!m_bInitialized || m_bReInitWData || m_bSelChanged)
		return ;

	// Loop through the data for each selected model and make sure it agrees
	// as much as possible with the current BiDi settings.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdDataSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;

		// If the model's BiDi flag is set, make sure it is set here and that
		// its Unidriv and PScript flags are clear.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[n]) {
			(*pcuia)[IDF_UNIBIDI] = 1 ;
			(*pcuia)[IDF_UNI] = (*pcuia)[IDF_PSCR] = 0 ;

		// Otherwise, clear the BiDi flag.  Then set the Unidrv flag if the
		// PScript flag is clear.

		} else {
			(*pcuia)[IDF_UNIBIDI] = 0 ;
			if ((*pcuia)[IDF_PSCR] == 0)
				(*pcuia)[IDF_UNI] = 1 ;
		} ;
	} ;

	// Reinitialize the controls on the page.

	InitPageControls() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizExtraFiles property page

IMPLEMENT_DYNCREATE(CINFWizExtraFiles, CPropertyPage)

CINFWizExtraFiles::CINFWizExtraFiles() : CPropertyPage(CINFWizExtraFiles::IDD)
{
	//{{AFX_DATA_INIT(CINFWizExtraFiles)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}

CINFWizExtraFiles::~CINFWizExtraFiles()
{
	// Delete the string arrays referenced in m_coaExtraFSArrays.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaExtraFSArrays.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaExtraFSArrays[n] ;
		delete pcsa ;
	} ;
}

void CINFWizExtraFiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizExtraFiles)
	DDX_Control(pDX, IDC_ExtraFSpecsLst, m_cfelcFSpecsLst);
	DDX_Control(pDX, IDC_ModelLst, m_clbModels);
	DDX_Control(pDX, IDC_BrowsBtn, m_cbBrowse);
	//}}AFX_DATA_MAP
}


void CINFWizExtraFiles::ModelChangeFixups(unsigned unummodelssel,
										  CStringArray& csamodels,
										  CStringArray& csamodelslast)
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return ;

	// See ModelChangeFixupsListListPage() for more information.

	ModelChangeFixupsListListPage(unummodelssel, csamodels, csamodelslast,
								  m_cfelcFSpecsLst, m_coaExtraFSArrays,
								  m_nCurModelIdx, &m_cbBrowse, m_clbModels,
								  m_bReInitWData) ;
}


BEGIN_MESSAGE_MAP(CINFWizExtraFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizExtraFiles)
	ON_LBN_SELCHANGE(IDC_ModelLst, OnSelchangeModelLst)
	ON_BN_CLICKED(IDC_BrowsBtn, OnBrowsBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizExtraFiles message handlers

BOOL CINFWizExtraFiles::OnSetActive()
{
	// Get the list of models to load into the main list box.

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;

	// Nothing else need be done if this page has been initialized already
	// and it is not being asked to reinitialize the page...  That is,
	// except for possibly needing to pick up any selected model changes
	// that were made.

	if (m_bInitialized && !m_bReInitWData) {
		if (m_bSelChanged) {
			ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
							  m_pciwParent->GetINFModelsLst()) ;
			m_bSelChanged = false ;
		} ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Pick up selected model changes when reinitializing

	if (m_bReInitWData) {
		ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
						  m_pciwParent->GetINFModelsLst()) ;
		m_bSelChanged = false ;
	} ;

	// See InitListListPage() for more details.

	InitListListPage(m_clbModels, m_bInitialized, m_pciwParent,
					 m_coaExtraFSArrays, m_cfelcFSpecsLst,
					 IDS_INFExFilesColLab, csamodels, m_bReInitWData,
					 m_nCurModelIdx, 256, 0) ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizExtraFiles::OnSelchangeModelLst()
{
	SelChangedListListPage(m_clbModels, m_bInitialized, m_coaExtraFSArrays,
						   m_cfelcFSpecsLst, &m_cbBrowse, m_nCurModelIdx) ;
}


void CINFWizExtraFiles::OnBrowsBtn()
{
	// See OnBrowseListListPage() for more information.

	OnBrowseListListPage(m_cfelcFSpecsLst, IDS_CommonExtraFile) ;
}


LRESULT CINFWizExtraFiles::OnWizardNext()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return -1 ;

	// See OnWizNextListListPage() for more information.
	
	OnWizNextListListPage(m_nCurModelIdx, m_cfelcFSpecsLst, m_coaExtraFSArrays);
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizExtraFiles::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizMfgName property page

IMPLEMENT_DYNCREATE(CINFWizMfgName, CPropertyPage)

CINFWizMfgName::CINFWizMfgName() : CPropertyPage(CINFWizMfgName::IDD)
{
	//{{AFX_DATA_INIT(CINFWizMfgName)
	m_csMfgName = csEmpty;
	m_csMfgAbbrev = csEmpty;
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = false ;
}


CINFWizMfgName::~CINFWizMfgName()
{
}


void CINFWizMfgName::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizMfgName)
	DDX_Control(pDX, IDC_ProviderBox, m_ceMfgAbbrev);
	DDX_Control(pDX, IDC_ManufacturerBox, m_ceMfgName);
	DDX_Text(pDX, IDC_ManufacturerBox, m_csMfgName);
	DDV_MaxChars(pDX, m_csMfgName, 64);
	DDX_Text(pDX, IDC_ProviderBox, m_csMfgAbbrev);
	DDV_MaxChars(pDX, m_csMfgAbbrev, 2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizMfgName, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizMfgName)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizMfgName message handlers

BOOL CINFWizMfgName::OnSetActive()
{
	// Do nothing if the page has been initialized already and it is not being
	// asked to reinitialize itself.
	CStringArray csagpd ;		 // RAID 0001 ; move to head from body
	if (m_bInitialized && !m_bReInitWData)
		return CPropertyPage::OnSetActive() ;

	// Most of the work needed to initialize this page is only needed when it
	// is NOT being asked to REinitialized itself.

	if (!m_bReInitWData) {
		// Find the class instance associated with the first selected model.

		CStringArray& csamodels = m_pciwParent->GetINFModels() ;
		unsigned unummodels = m_pciwParent->GetModelCount() ;
		if(!m_pciwParent->m_pcgc){	//RAID 0001
			for (unsigned u = 0 ; u < unummodels ; u++) {
				if (csamodels[0] == m_pciwParent->GetModel(u).Name())
					break ;
			} ;
			ASSERT(u < unummodels) ;
			LoadFile(m_pciwParent->GetModel(u).FileName(), csagpd) ;
		}							
		else
			LoadFile(m_pciwParent->m_pcgc->GetPathName(), csagpd) ;
			//END RAID 0001
		// Open/Read/Close the model's GPD file.

		
			

		// Scan the file for and isolate the ModelName entry.

		int numlines = (int)csagpd.GetSize() ;
		CString csmodelname(_T("ModelName")) ;
		CString cscurline ;
		int nloc ;
		for (int n = 0 ; n < numlines ; n++) {
			if ((nloc = csagpd[n].Find(csmodelname)) >= 0) {
				csmodelname = csagpd[n].Mid(csmodelname.GetLength() + nloc) ;
				if ((nloc = csmodelname.Find(_T('"'))) >= 0) {
					csmodelname = csmodelname.Mid(nloc + 1) ;
					if ((nloc = csmodelname.Find(_T('"'))) >= 0)
						csmodelname = csmodelname.Left(nloc) ;
				} else {
					if (csmodelname[0] == _T(':'))
						csmodelname = csmodelname.Mid(1) ;
				} ;
				csmodelname.TrimLeft() ;
				csmodelname.TrimRight() ;
				break ;
			} ;
		} ;

		// If the ModelName entry was found...

		if (n < numlines && !csmodelname.IsEmpty()) {
			// Use the first space terminated value in the ModelName entry for
			// the manufacturer's name.

			if ((nloc = csmodelname.Find(_T(' '))) >= 0)
				m_csMfgName = csmodelname.Left(nloc) ;
			else
				m_csMfgName = csmodelname ;

			// Use the first two letters of the ModelName entry for the
			// provider's "name".

			m_csMfgAbbrev = csmodelname.Left(2) ;
			m_csMfgAbbrev.MakeUpper() ;

			// Load the manufacturer and provider names into the edit boxes on
			// this	page.

			UpdateData(false) ;
		} ;
	
	// When reinitializing, the member variables associated with the controls
	// are already set so just use them.

	} else
		UpdateData(false) ;
	
	// Set focus to first control, set initialization flag, and return.

	m_ceMfgName.SetFocus() ;
	m_bInitialized = true ;	
	m_bReInitWData = false ;	// Reinit (if needed) is done now on this page
	return CPropertyPage::OnSetActive();
}


LRESULT CINFWizMfgName::OnWizardNext()
{
	// Get the values for the manufacturer and provider.

	UpdateData(true) ;

	// Complain if either field is blank and do not move on to the next page.
	// Make sure the abbreviation is 2 characters long, too.
	
	m_csMfgName.TrimLeft() ;
	m_csMfgName.TrimRight() ;
	m_csMfgAbbrev.TrimLeft() ;
	m_csMfgAbbrev.TrimRight() ;
	CString csmsg ;
	if (m_csMfgName.IsEmpty()) {
		m_ceMfgName.SetFocus() ;
		csmsg.LoadString(IDS_NoMfgError) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return -1 ;
	}  ;
	if (m_csMfgAbbrev.IsEmpty() || m_csMfgAbbrev.GetLength() != 2) {
		m_ceMfgAbbrev.SetFocus() ;
		csmsg.LoadString(IDS_NoMfgAbbrevError) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return -1 ;
	}  ;

	// All appears to be well so...

	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizMfgName::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdElts property page

IMPLEMENT_DYNCREATE(CINFWizNonStdElts, CPropertyPage)

CINFWizNonStdElts::CINFWizNonStdElts() : CPropertyPage(CINFWizNonStdElts::IDD)
{
	//{{AFX_DATA_INIT(CINFWizNonStdElts)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bNewSectionAdded = false ;
	m_nCurSectionIdx = -1 ;
}

CINFWizNonStdElts::~CINFWizNonStdElts()
{
	// Delete the string arrays referenced in m_coaSectionArrays.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaSectionArrays.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaSectionArrays[n] ;
		delete pcsa ;
	} ;
}

void CINFWizNonStdElts::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizNonStdElts)
	DDX_Control(pDX, IDC_NewSectionBtn, m_ceNewSection);
	DDX_Control(pDX, IDC_KeyValueLst, m_felcKeyValueLst);
	DDX_Control(pDX, IDC_SectionLst, m_clbSections);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizNonStdElts, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizNonStdElts)
	ON_LBN_SELCHANGE(IDC_SectionLst, OnSelchangeSectionLst)
	ON_BN_CLICKED(IDC_NewSectionBtn, OnNewSectionBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdElts message handlers

BOOL CINFWizNonStdElts::OnSetActive()
{
	// Build an array of valid section names.

	if (!m_bInitialized) {
		m_csaSections.Add(_T("[ControlFlags]")) ;
		m_csaSections.Add(_T("[DestinationDirs]")) ;
		m_csaSections.Add(_T("[Device]")) ;
		m_csaSections.Add(_T("[Install]")) ;
		m_csaSections.Add(_T("[Manufacturer]")) ;
		m_csaSections.Add(_T("[SourceDisksFiles]")) ;
		m_csaSections.Add(_T("[SourceDisksNames]")) ;
		m_csaSections.Add(_T("[Strings]")) ;
	} ;
	
	// See InitListListPage() for more details.

	InitListListPage(m_clbSections, m_bInitialized, m_pciwParent,
					 m_coaSectionArrays, m_felcKeyValueLst, IDS_NonStdColLab,
					 m_csaSections, m_bReInitWData, m_nCurSectionIdx, 256, 0) ;

	m_bNewSectionAdded = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizNonStdElts::OnSelchangeSectionLst()
{
	SelChangedListListPage(m_clbSections, m_bInitialized, m_coaSectionArrays,
						   m_felcKeyValueLst, NULL, m_nCurSectionIdx) ;
}


void CINFWizNonStdElts::OnNewSectionBtn()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return ;

	// Prompt the user for a new section name.  Return if the user cancels.

	CNewINFSection cnis ;
	if (cnis.DoModal() == IDCANCEL)
		return ;

	// Get the new section name and add brackets if necessary.

	CString csnewsec = cnis.m_csNewSection ;
	csnewsec.TrimLeft() ;
	csnewsec.TrimRight() ;
	if (csnewsec[0] != _T('['))
		csnewsec = csLBrack + csnewsec ;
	if (csnewsec.Right(1) != csRBrack)
		csnewsec += csRBrack ;

	// Add a new string array to hold the data for the new section.
	
	CStringArray* pcsa = new CStringArray ;
	int nelts = m_felcKeyValueLst.GetItemCount() ;
	pcsa->SetSize(nelts) ;
	for (int n = 0 ; n < nelts ; n++)
		pcsa->SetAt(n, csEmpty) ;
	m_coaSectionArrays.Add((CObject*) pcsa) ;

	// Add the new section to the sections array.  Then, add the new section to
	// the sections list box and try to select this item and make it visible.

	m_csaSections.Add(csnewsec) ;
	int nidx = m_clbSections.AddString(csnewsec) ;
	m_clbSections.SetCurSel(nidx) ;
	OnSelchangeSectionLst() ;

	// Note that a new section was added during this activation of the page.

	m_bNewSectionAdded = true ;
}


LRESULT CINFWizNonStdElts::OnWizardNext()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return -1 ;

	// See OnWizNextListListPage() for more information.
	
	OnWizNextListListPage(m_nCurSectionIdx, m_felcKeyValueLst,
						  m_coaSectionArrays) ;

	// Make sure the "section used in INF file flags" array is correctly sized.

	m_cuaSecUsed.SetSize(m_csaSections.GetSize()) ;

	// If this is not the first time this page has been used, any changes made
	// could affect the data managed by some of the other pages.  Make a call
	// to fixup that data when needed.

	if (m_bNewSectionAdded)
		m_pciwParent->NonStdSecsChanged() ;
		
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizNonStdElts::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdModelSecs property page

IMPLEMENT_DYNCREATE(CINFWizNonStdModelSecs, CPropertyPage)

CINFWizNonStdModelSecs::CINFWizNonStdModelSecs() : CPropertyPage(CINFWizNonStdModelSecs::IDD)
{
	//{{AFX_DATA_INIT(CINFWizNonStdModelSecs)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = false ;
	m_nCurSectionIdx = -1 ;
}


CINFWizNonStdModelSecs::~CINFWizNonStdModelSecs()
{
	// Delete the string arrays referenced in m_coaModelsNeedingSecs.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaModelsNeedingSecs.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaModelsNeedingSecs[n] ;
		delete pcsa ;
	} ;
}


void CINFWizNonStdModelSecs::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizNonStdModelSecs)
	DDX_Control(pDX, IDC_ModelSectionLst, m_cfelcModelsLst);
	DDX_Control(pDX, IDC_SectionLst, m_clbSectionsLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizNonStdModelSecs, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizNonStdModelSecs)
	ON_LBN_SELCHANGE(IDC_SectionLst, OnSelchangeSectionLst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdModelSecs message handlers

BOOL CINFWizNonStdModelSecs::OnSetActive()
{
	// Turn off the finish button.

	m_pciwParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT) ;

	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;
								
	int				n, n2, n3 ;	// Looping variable
	int				numelts ;	// Number of elements in an array
	CStringArray*	pcsa ;		// Used to reference a sections models array

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the nonstandard section names and the selected model
		// names.

		m_csaSections.Copy(m_pciwParent->m_ciwnse.m_csaSections) ;
		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;

		// The following array is used to manage the models that need each
		// section.  Set its size to the same as the number of sections and
		// load its elements with pointers to string arrays.  Load the sections
		// list box in the same loop.

		numelts = (int) m_csaSections.GetSize() ;
		m_coaModelsNeedingSecs.SetSize(numelts) ;
		m_clbSectionsLst.ResetContent() ;
		for (n = 0 ; n < numelts ; n++) {
			pcsa = new CStringArray ;
			pcsa->RemoveAll() ;
			m_coaModelsNeedingSecs[n] = (CObArray*) pcsa ;
			m_clbSectionsLst.AddString(m_csaSections[n]) ;
		} ;
		m_clbSectionsLst.SetFocus() ;
	
		// Initialize and load the list control

		InitModelsListCtl() ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  They are handled in similar
	// ways.
	//
	// Begin by removing references to models that are no longer selected.

	m_csaModels.RemoveAll() ;
	m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
	int nummodels = (int) m_csaModels.GetSize() ;
	numelts = (int) m_coaModelsNeedingSecs.GetSize() ;
	for (n = 0 ; n < numelts ; n++) {
		pcsa = (CStringArray*) m_coaModelsNeedingSecs[n] ;
		for (n2 = (int) pcsa->GetSize() - 1 ; n2 >= 0 ; n2--) {
			for (n3 = 0 ; n3 < nummodels ; n3++)
				if ((*pcsa)[n2] == m_csaModels[n3])
					break ;
			if (n3 >= nummodels)
				pcsa->RemoveAt(n2) ;
		} ;
	} ;

	// Reinitialize the list control if the wizard has been reinitialized.
	// Otherwise, the models may have changed so update that column of the
	// list control.

	if (m_bReInitWData)
		InitModelsListCtl() ;
	else
		m_cfelcModelsLst.SetColumnData((CObArray*) &m_csaModels, 0) ;

	// Update the sections information.

	UpdateSectionData() ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizNonStdModelSecs::OnSelchangeSectionLst()
{
	// If there was a previous section selection, save the list of models that
	// need it.  Otherwise, enable the models list control.

	if (m_nCurSectionIdx != -1)
		SaveSectionModelInfo() ;
	else
		m_cfelcModelsLst.EnableWindow(TRUE) ;

	// Save the index of the newly selected section and then use that index to
	// get the array of selected models for the section.

	m_nCurSectionIdx = m_clbSectionsLst.GetCurSel() ;
	CStringArray* pcsa ;
	pcsa = (CStringArray*) m_coaModelsNeedingSecs[m_nCurSectionIdx] ;

	// Declare and size a new array that will be loaded with info on the
	// selected models for the current section.  Then load the string displayed
	// in the list control for selected models.

	CStringArray csaselmods ;
	int numelts = (int) m_csaModels.GetSize() ;
	csaselmods.SetSize(numelts) ;
	CString csselstr ;
	csselstr.LoadString(IDS_INF_NSMS_ToggleStr) ;

	// Use the list of all models and the current selection's list of models to
	// build an array with the selected string in the right spots so that this
	// array can be loaded into the list control.

	for (int n2 = 0 ; n2 < pcsa->GetSize() ; n2++)
		for (int n = 0 ; n < numelts ; n++)
			if ((*pcsa)[n2] == m_csaModels[n])
				csaselmods[n] = csselstr ;

	// Load array built above into the list control so that the user can see
	// which models have been selected for the current section.

	m_cfelcModelsLst.SetColumnData((CObArray*) &csaselmods, 1) ;
}


LRESULT CINFWizNonStdModelSecs::OnWizardNext()
{
	// If there was a previous section selection, save the list of models that
	// need it.

	if (m_nCurSectionIdx != -1)
		SaveSectionModelInfo() ;
	
	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizNonStdModelSecs::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizNonStdModelSecs::SaveSectionModelInfo()
{
	// Get the selection data out of the list control.

	CStringArray csaselmods ;
	m_cfelcModelsLst.GetColumnData((CObArray*) &csaselmods, 1) ;

	// Use the index of the selected section to get a list of its currently
	// selected models.  Remove the models in it because it will be refilled
	// with new data later.

	CStringArray* pcsa ;
	pcsa = (CStringArray*) m_coaModelsNeedingSecs[m_nCurSectionIdx] ;
	pcsa->RemoveAll() ;

	// Add every selected model to the section's selected models array.

	for (int n = 0 ; n < m_csaModels.GetSize() ; n++)
		if (!csaselmods[n].IsEmpty())
			pcsa->Add(m_csaModels[n]) ;
}


void CINFWizNonStdModelSecs::NonStdSecsChanged()
{
	// Do nothing if this page has not be initialized yet.  In addition, do
	// nothing if the selected models may have changed or a reinit has been
	// request.  These cases are taken care of in OnSetActive().

	if (!m_bInitialized || m_bReInitWData || m_bSelChanged)
		return ;

	// Update the section data to agree with any changes that may have been
	// made.

	UpdateSectionData() ;
}


void CINFWizNonStdModelSecs::UpdateSectionData()
{
	// Get a copy of the latest nonstandard section.

	int		n, n2 ;				// Looping variables
	CStringArray csanewsections ;
	csanewsections.Copy(m_pciwParent->m_ciwnse.m_csaSections) ;

	// Allocate and size the flags arrays used to determine which sections are
	// still in use.

	int numelts = (int) m_csaSections.GetSize() ;
	int newnumelts = (int) csanewsections.GetSize() ;
	CUIntArray cuiaoldflags, cuianewflags ;
	cuiaoldflags.SetSize(numelts) ;
	for (n = 0 ; n < numelts ; n++)
		cuiaoldflags[n] = 0 ;
	cuianewflags.SetSize(newnumelts) ;
	for (n = 0 ; n < newnumelts ; n++)
		cuianewflags[n] = 0 ;

	// Loop through the old & new models to see which of them are still in use.

	for (n = 0 ; n < numelts ; n++)
		for (n2 = 0 ; n2 < newnumelts ; n2++)
			if (m_csaSections[n] == csanewsections[n2]) {
				cuiaoldflags[n] =	cuianewflags[n2] = 1 ;
				break ;
			} ;

	// Remove the old sections and related data that are no longer needed.

	CStringArray* pcsa ;
	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldflags[n] == 0) {
			m_csaSections.RemoveAt(n) ;
			pcsa = (CStringArray*) m_coaModelsNeedingSecs[n] ;
			delete pcsa ;
			m_coaModelsNeedingSecs.RemoveAt(n) ;
		} ;

	// Add the truly new sections to this page's array of section names and
	// initialize all related section data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewflags[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaSections.InsertAt(n2, csanewsections[n]) ;
		pcsa = new CStringArray ;
		m_coaModelsNeedingSecs.InsertAt(n2, (CObject*) pcsa) ;
	} ;

	// Clear the sections list box and reload it with the new sections data.
	// Make sure that nothing is selected in the listbox and give it the focus.

	m_clbSectionsLst.ResetContent() ;
	for (n = 0, numelts = (int) m_csaSections.GetSize() ; n < numelts ; n++)
		m_clbSectionsLst.AddString(m_csaSections[n]) ;
	m_clbSectionsLst.SetCurSel(-1) ;
	m_nCurSectionIdx = -1 ;
	m_clbSectionsLst.SetFocus() ;

	// Clear the selected models column in the list control and disable it.

	CStringArray csa ;
	csa.SetSize(m_csaModels.GetSize()) ;
	m_cfelcModelsLst.SetColumnData((CObArray*) &csa, 1) ;
	m_cfelcModelsLst.EnableWindow(FALSE) ;
}


void CINFWizNonStdModelSecs::InitModelsListCtl()
{
	int				numelts ;	// Number of elements in an array
	CString			cstmp ;

	// Initialize the list control

	numelts = (int) m_csaModels.GetSize() ;
	m_cfelcModelsLst.InitControl(LVS_EX_FULLROWSELECT, numelts, 2,
								 TF_HASTOGGLECOLUMNS+TF_CLICKONROW, 0,
								 MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_cfelcModelsLst.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 25, false,
									false, COLDATTYPE_STRING,
									(CObArray*) &m_csaModels) ;

	// Initialize the bidi column in the list control.

	cstmp.LoadString(IDS_INFSecNeededColLab) ;
	CStringArray csaempty ;
	m_csToggleStr.LoadString(IDS_INF_NSMS_ToggleStr) ;
	m_cfelcModelsLst.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -25,
									false, false, COLDATTYPE_TOGGLE,
									(CObArray*) &csaempty, m_csToggleStr) ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizSummary property page

IMPLEMENT_DYNCREATE(CINFWizSummary, CPropertyPage)

CINFWizSummary::CINFWizSummary() : CPropertyPage(CINFWizSummary::IDD)
{
	//{{AFX_DATA_INIT(CINFWizSummary)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = false ;
}


CINFWizSummary::~CINFWizSummary()
{
}


void CINFWizSummary::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizSummary)
	DDX_Control(pDX, IDC_SummaryBox, m_ceSummary);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizSummary, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizSummary)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizSummary message handlers

BOOL CINFWizSummary::OnSetActive()
{
	// Turn on the finish button.

	m_pciwParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;

	// Initialize the summary to empty.

	CString cs, cs2, cs3, cs4, cssummary ;
	cssummary = csEmpty ;

	// Add the selected models to the summary

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;
	cssummary.LoadString(IDS_ModelsSumTxt) ;
	int nummodels = (int)csamodels.GetSize() ;
	for (int n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n", csamodels[n]) ;	
		cssummary += cs ;
	} ;

	// Add PnP ID info to the summary

	cs.LoadString(IDS_PnPIDSumTxt) ;
	cssummary += cs ;
	bool bfoundone = false ;
	for (n = 0 ; n < nummodels ; n++) {
		if (!m_pciwParent->m_ciwgpi.m_csaModelIDs[n].IsEmpty()) {
			cs.Format("\t%s: %s\r\n", csamodels[n],
					  m_pciwParent->m_ciwgpi.m_csaModelIDs[n]) ;
			cssummary += cs ;
			bfoundone = true ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add BIDI info to the summary

	cs.LoadString(IDS_BIDISumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	for (n = 0 ; n < nummodels ; n++) {
		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[n]) {
			cs.Format("\t%s\r\n", csamodels[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add the ICM profiles info to the summary.

	cs.LoadString(IDS_ICMSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	CStringArray* pcsa ;
	int n2, numstrs ;
	for (n = 0 ; n < nummodels ; n++) {
		pcsa = (CStringArray*) m_pciwParent->m_ciwip.m_coaProfileArrays[n] ;
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", csamodels[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add the include files info to the summary

	cs.LoadString(IDS_IncFilesSumTxt) ;
	cssummary += cs ;
	for (n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n\t\t%s\r\n", csamodels[n],
				  m_pciwParent->m_ciwif.m_csaIncFiles[n]) ;
		cssummary += cs ;
	} ;

	// Add the install sections info to the summary

	cs.LoadString(IDS_InstSecsSumTxt) ;
	cssummary += cs ;
	CUIntArray* pcuia ;
	int nid ;
	for (n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n", csamodels[n]) ;
		cssummary += cs ;
		pcuia = (CUIntArray*) m_pciwParent->m_ciwis.m_coaStdInstSecs[n] ;
		cs = cs3 = cs4 = csEmpty ;
		cs = "\t\t" ;
		nid = IDS_InstSecUni ;
		for (n2 = 0 ; n2 < NUMINSTSECFLAGS - 1 ; n2++, nid++)
			if ((*pcuia)[n2]) {
				cs2.LoadString(nid) ;
				cs4.Format("%s%s", cs3, cs2) ;
				cs += cs4 ;
				cs3 = _T(", ") ;
			} ;
		if ((*pcuia)[ISF_OTHER]) {
			cs4.Format("%s%s", cs3,
					   m_pciwParent->m_ciwis.m_csaOtherInstSecs[n]) ;
			cs += cs4 ;
		} ;
		cssummary += cs + csCRLF ;
	} ;

	// Add the data sections info to the summary

	cs.LoadString(IDS_DataSecsSumTxt) ;
	cssummary += cs ;
	for (n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n", csamodels[n]) ;
		cssummary += cs ;
		pcuia = (CUIntArray*) m_pciwParent->m_ciwds.m_coaStdDataSecs[n] ;
		cs = cs3 = cs4 = csEmpty ;
		cs = "\t\t" ;
		nid = IDS_DataSecUni ;
		for (n2 = 0 ; n2 < NUMDATASECFLAGS - 1 ; n2++, nid++)
			if ((*pcuia)[n2]) {
				cs2.LoadString(nid) ;
				cs4.Format("%s%s", cs3, cs2) ;
				cs += cs4 ;
				cs3 = _T(", ") ;
			} ;
		if ((*pcuia)[IDF_OTHER]) {
			cs4.Format("%s%s", cs3,
					   m_pciwParent->m_ciwds.m_csaOtherDataSecs[n]) ;
			cs += cs4 ;
		} ;
		cssummary += cs + csCRLF ;
	} ;

	// Add the nonstandard files info to the summary

	cs.LoadString(IDS_NonStdFilesSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	for (n = 0 ; n < nummodels ; n++) {
		pcsa = (CStringArray*) m_pciwParent->m_ciwef.m_coaExtraFSArrays[n] ;
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", csamodels[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add the manufacturer and provider info to the summary

	cs.Format(IDS_MfgSumTxt, m_pciwParent->m_ciwmn.m_csMfgName) ;
	cssummary += cs ;
	cs.Format(IDS_ProvSumTxt, m_pciwParent->m_ciwmn.m_csMfgAbbrev) ;
	cssummary += cs ;

	// Add the nonstandard sections info to the summary

	cs.LoadString(IDS_NonStdSecSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	CStringArray& csasections = m_pciwParent->m_ciwnse.m_csaSections ;
	nummodels = (int)csasections.GetSize() ;
	for (n = 0 ; n < nummodels ; n++) {
		pcsa = (CStringArray*) m_pciwParent->m_ciwnse.m_coaSectionArrays[n] ;
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", csasections[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;

	// Add the nonstandard sections needed by models info to the summary

	cs.LoadString(IDS_NonStdModelsSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	int numsections = (int) m_pciwParent->m_ciwnsms.m_csaSections.GetSize() ;
	for (n = 0 ; n < numsections ; n++) {
		pcsa = (CStringArray*)m_pciwParent->m_ciwnsms.m_coaModelsNeedingSecs[n];
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", m_pciwParent->m_ciwnsms.m_csaSections[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Load the edit box, set the initialized flag, and return.

	m_ceSummary.SetSel(0, -1) ;
	m_ceSummary.ReplaceSel(cssummary) ;
	m_ceSummary.SetSel(0, 0) ;
	m_ceSummary.SetSel(-1, 0) ;
	m_ceSummary.SetReadOnly() ;
	m_bInitialized = true ;		// Page is initialized now
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CNewINFSection dialog

CNewINFSection::CNewINFSection(CWnd* pParent /*=NULL*/)
	: CDialog(CNewINFSection::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewINFSection)
	m_csNewSection = csEmpty;
	//}}AFX_DATA_INIT
}


void CNewINFSection::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewINFSection)
	DDX_Text(pDX, IDC_NewSectionBox, m_csNewSection);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewINFSection, CDialog)
	//{{AFX_MSG_MAP(CNewINFSection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CNewINFSection message handlers

void CNewINFSection::OnOK()
{
	UpdateData() ;
	
	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CINFWizView

IMPLEMENT_DYNCREATE(CINFWizView, CEditView)

CINFWizView::CINFWizView()
{
	m_pcicdCheckDoc = NULL ;
	m_pcmcwCheckFrame = NULL ;
}


CINFWizView::~CINFWizView()
{
}


BEGIN_MESSAGE_MAP(CINFWizView, CEditView)
	//{{AFX_MSG_MAP(CINFWizView)
	ON_COMMAND(ID_FILE_Change_INF, OnFILEChangeINF)
	ON_COMMAND(ID_FILE_Check_INF, OnFILECheckINF)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizView drawing

void CINFWizView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CINFWizView diagnostics

#ifdef _DEBUG
void CINFWizView::AssertValid() const
{
	CEditView::AssertValid();
}

void CINFWizView::Dump(CDumpContext& dc) const
{
	CEditView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CINFWizView message handlers

void CINFWizView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
	// TODO: Add your specialized code here and/or call the base class
	
	CEditView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}


void CINFWizView::OnInitialUpdate()
{
	// Set the frame's window style and initialize the edit box.

    GetParentFrame()->ModifyStyle(0, WS_OVERLAPPEDWINDOW) ;
	CEditView::OnInitialUpdate();
	
	// Set a default title for the window.

	CString cs ;
	cs.LoadString(IDS_INFFile) ;
	GetDocument()->SetTitle(cs) ;

	// Load the edit box with the contents of the INF file.

	GetEditCtrl().SetSel(0, -1) ;
	GetEditCtrl().ReplaceSel( ((CINFWizDoc*) GetDocument())->m_pciw->m_csINFContents ) ;
	GetEditCtrl().SetSel(0, 0) ;
	GetEditCtrl().SetSel(-1, 0) ;
//	GetEditCtrl().SetReadOnly() ;
}


void CINFWizView::OnFILEChangeINF()
{
	// Restart the wizard so that the users changes can be collected.

	CINFWizDoc* pciwd = (CINFWizDoc*) GetDocument() ;
	CINFWizard* pciw = pciwd->m_pciw ;
	pciw->PrepareToRestart() ;
    if (pciw->DoModal() == IDCANCEL)
		return ;

	// Regenerate the INF contents

	if (!pciw->GenerateINFFile())
		return ;

	// Load the edit box with the contents of the new INF.

	GetEditCtrl().SetSel(0, -1) ;
	GetEditCtrl().ReplaceSel(pciw->m_csINFContents) ;
	GetEditCtrl().SetSel(0, 0) ;
	GetEditCtrl().SetSel(-1, 0) ;
	GetEditCtrl().SetReadOnly() ;
}


void CINFWizView::OnFILECheckINF()
{
    //  This might take a while, so...

    CWaitCursor cwc ;

	// Remove the contents of any existing INF checking window and reset the
	// checking flag.

	ResetINFErrorWindow() ;

	// Get a pointer to the wizard class because it contains some functions
	// that will be useful to file checking process.

	CINFWizDoc* pciwd = (CINFWizDoc*) GetDocument() ;
	CINFWizard* pciw = pciwd->m_pciw ;

	// Get a reference to the array of selected models and a count of them.  Use
	// them to loop through each model.  Allocate all of the variables needed
	// for processing including the string to hold the various paths that will
	// be needed.

	CStringArray& csamodels = pciw->GetINFModels() ;
	int nummodels = (int)csamodels.GetSize() ;
	CString csfspec, cspath, csmodel, cs, cstmp,csprojpath ;
	//RAID 0001

if(pciw ->m_pcgc){
    cstmp      = pciwd->m_pcgc->GetPathName();
    cstmp      = cstmp.Left(cstmp.ReverseFind(csBSlash[0]));	//cstmp are used instead GetW2000()
	csprojpath = cstmp.Left(cstmp.ReverseFind(csBSlash[0])+1) ;
}	//END RAID 0001
else {
	csprojpath = pciwd->m_pcpr->GetProjFSpec() ;
	csprojpath = csprojpath.Left(csprojpath.ReverseFind(csBSlash[0]) + 1) ;
}
	CFileStatus cfs ;
	int n ;
	BOOL bexists ;

	// Do all of the checking for each model before moving on to the next one.

	for (n = 0 ; n < nummodels ; n++) {
		csmodel = csamodels[n] ;

		// Make sure that the GPD file for the model exists.

		csfspec = pciw->GetModelFile(csmodel, true) ;
		if (!(bexists = CFile::GetStatus(csfspec, cfs))) {
			cs.Format(IDS_INFChk_NoModErr, csmodel, csfspec) ;
			PostINFCheckingMessage(cs) ;
		} ;
		cspath = csfspec.Left(csfspec.ReverseFind(csBSlash[0]) + 1) ;

		// Verify the existence of the files referenced in include statements
		// in the current GPD file iff the GPD file exists.

		if (bexists)
			CheckIncludeFiles(csfspec, cspath, csmodel) ;

		// Check for the existence of the ICM files (if any) for this GPD.
		
		CheckArrayOfFiles((CStringArray*) pciw->m_ciwip.m_coaProfileArrays[n],
						  csfspec, cspath, csprojpath, csmodel,
						  IDS_INFChk_NoICMFileErr) ;

		// Check for the existence of the nonstd files (if any) for this GPD.

		CheckArrayOfFiles((CStringArray*) pciw->m_ciwef.m_coaExtraFSArrays[n],
						  csfspec, cspath, csprojpath, csmodel,
						  IDS_INFChk_NoNonStdFileErr) ;
	} ;

	// Check for the existence of the resource DLL.  First look for it in the
	// project directory.  If it isn't there, try the W2K directory.

	// RAID 0001
	if(pciw->m_pcgc)
		cs = pciw->m_pcgc->ModelData()->GetKeywordValue(pciw->m_pcgc->GetPathName(),_T("ResourceDLL"));
	else{	//END RAID 0001
		cs = pciwd->m_pcpr->DriverName() ;
		cs = cs.Left(8) + _T(".dll") ;		// Resource DLL name.
	} 
	if (!CFile::GetStatus(csprojpath + cs, cfs)) {
		cstmp = (pciw->m_pcgc) ? cstmp + csBSlash : pciwd->m_pcpr->GetW2000Path() + csBSlash ; //RAID 0001
		if (!CFile::GetStatus(cstmp + cs, cfs)) {
			cstmp.Format(IDS_INFChk_NoResDLLErr, (pciw->m_pcgc)? cs :
							pciwd->m_pcpr->DriverName(), cs) ;		//RAID 0001
		 PostINFCheckingMessage(cstmp) ;
		} ;
	} ;

	// Tell the user if no problems were found.

	if (!m_bChkingErrsFound)
		AfxMessageBox(IDS_INFChecksOK, MB_ICONINFORMATION) ;
}


void CINFWizView::CheckArrayOfFiles(CStringArray* pcsa, CString& csfspec,
									CString& cspath, CString& csprojpath,
									CString& csmodel, int nerrid)
{
	// There is nothing to do if there are no filespecs in the array.

	int numfiles ;
	if ((numfiles = (int)pcsa->GetSize()) == 0)
		return ;

	// Variables needed for file existence checking

	int n ;
	BOOL bexists ;
	CString csfile, csmsg ;
	CFileStatus cfs ;

	// Check for the existence of each file.

	for (n = 0 ; n < numfiles ; n++) {
		csfile = pcsa->GetAt(n) ;

		// If the file string contains a full filespec, just check it.

		if (csfile[1] == _T(':'))
			bexists = CFile::GetStatus(csfile, cfs) ;

		// Otherwise, add the GPD path and, if needed, the project path to the
		// file string and check to see if the file is there.

		else {
			if (!(bexists = CFile::GetStatus(cspath + csfile, cfs)))
				bexists = CFile::GetStatus(csprojpath + csfile, cfs) ;
		} ;

		// Post a message if the file was not found.

		if (!bexists) {
			csmsg.Format(nerrid, csmodel, csfile) ;
			PostINFCheckingMessage(csmsg) ;
		} ;
	} ;
}


void CINFWizView::CheckIncludeFiles(CString& csfspec, CString& cspath,
									CString& csmodel)
{
	// Variables needed to read the GPD and check include files.

	CStringArray csagpdfile ;
	CString csinc(_T("*Include:")), cs, cstmp ;
	int n, numstrs, nloc ;
	CFileStatus cfs ;

	// Include files can only be checked if the GPD file can be read.

	if (LoadFile(csfspec, csagpdfile))	{
		numstrs = (int)csagpdfile.GetSize() ;

		// Check each line in the GPD file to see if it contains an include
		// statement.

		for (n = 0 ; n < numstrs ; n++) {
			// Skip statement if not include statement

			if ((nloc = csagpdfile[n].Find(csinc)) == -1)
				continue ;

			// Isolate the filespec in the include statement

			cs = csagpdfile[n].Mid(nloc + csinc.GetLength()) ;
			cs.TrimLeft() ;
			cs.TrimRight() ;
			if (cs[0] == csQuote[0])					// Remove quotes
				cs = cs.Mid(1, cs.GetLength() - 2) ;

			// If the include file's filespec is relative, add the GPD's
			// path to it.  Then test for the file's existence.  Post a
			// message if the file does not exist.

			if (cs[1] != _T(':'))
				cs = cspath + cs ;
			if (!CFile::GetStatus(cs, cfs)) {
				cstmp.Format(IDS_INFChk_NoIncFileErr, csmodel, cs,
							 csfspec) ;
				PostINFCheckingMessage(cstmp) ;
			} ;
		} ;

	// Complain if the GPD file could not be read.

	} else {
		cstmp.Format(IDS_INFChk_GPDReadErr, csfspec) ;
		AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
	} ;
}


/******************************************************************************

  CINFWizView::PostINFCheckingMessage

  Create the checking results window if needed and then post a message to it.

******************************************************************************/

bool CINFWizView::PostINFCheckingMessage(CString& csmsg)
{
	// Clean up before continuing if the user closed the checking window.

	if (m_pcicdCheckDoc && m_pcmcwCheckFrame
	 && !IsWindow(m_pcmcwCheckFrame->m_hWnd)) {
		m_pcicdCheckDoc = NULL ;
		m_pcmcwCheckFrame = NULL ;
	} ;

	// Create the INF checking, error display window if one does not exist.

	if (m_pcicdCheckDoc == NULL) {
		m_pcicdCheckDoc = new CINFCheckDoc ;
		if (m_pcicdCheckDoc == NULL)
			return false ;
		CString cstitle ;		// Set the new window's title
		cstitle.Format(IDS_INFCheckTitle, GetDocument()->GetTitle()) ;
		m_pcicdCheckDoc->SetTitle(cstitle) ;
		CMultiDocTemplate*  pcmdt = WSCheckTemplate() ;	
		m_pcmcwCheckFrame = (CMDIChildWnd *) pcmdt->CreateNewFrame(m_pcicdCheckDoc, NULL) ;
		if  (m_pcmcwCheckFrame) {
			pcmdt->InitialUpdateFrame(m_pcmcwCheckFrame, m_pcicdCheckDoc, TRUE) ;
			pcmdt->AddDocument(m_pcicdCheckDoc) ;
		} else {
			delete m_pcicdCheckDoc ;
			m_pcicdCheckDoc = NULL ;
			return false ;
		} ;
	} ;

	// Post the message and return

	m_pcicdCheckDoc->PostINFChkMsg(csmsg) ;
	m_bChkingErrsFound = true ;
	return true ;
}


/******************************************************************************

  CINFWizView::ResetINFErrorWindow

  If there is an existing checking results window for this INF file, clear
  out its contents.  Next, initialize a flag that has to be set before the
  checking begins.

******************************************************************************/

void CINFWizView::ResetINFErrorWindow()
{
	// Clear the checking window if there is one.
  
 	if (m_pcicdCheckDoc && m_pcmcwCheckFrame && IsWindow(m_pcmcwCheckFrame->m_hWnd))
	 	m_pcicdCheckDoc->DeleteAllMessages() ;
	else {
		m_pcicdCheckDoc = NULL ;
		m_pcmcwCheckFrame = NULL ;
		// DEAD_BUG - Do I need to delete these classes first??? // No you can't.
	} ;

	// Initialize checking flag

	m_bChkingErrsFound = false ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc

IMPLEMENT_DYNCREATE(CINFWizDoc, CDocument)

CINFWizDoc::CINFWizDoc()
{
	// This constructor is called when the File Open command is used.  That is
	// not supported at this point.

	m_bGoodInit = false ;
}


CINFWizDoc::CINFWizDoc(CProjectRecord* pcpr, CINFWizard* pciw)
{
	// Save the input parameters.

	m_pcpr = pcpr ;
	m_pciw = pciw ;
	ASSERT(m_pciw != NULL) ;

	// Class is correctly constructed.

	m_bGoodInit = true ;
}
//RAID 0001
CINFWizDoc::CINFWizDoc(CGPDContainer * pcgc, CINFWizard * pciw)
{
	m_pcgc = pcgc ;
	m_pciw = pciw ;
	ASSERT(m_pciw != NULL) ;

	// Class is correctly constructed.

	m_bGoodInit = true ;

}
// RAID 0001

BOOL CINFWizDoc::OnNewDocument()
{
	// Creating a new INF doc in this way is not supported.

	return FALSE ;

	//if (!CDocument::OnNewDocument())
	//	return FALSE;
	//return TRUE;
}


CINFWizDoc::~CINFWizDoc()
{
	// Do nothing if this class was not correctly constructed.

	if (!m_bGoodInit)
		return ;

	// Free the wizard classes if they exist.

	if (m_pciw != NULL)
		delete m_pciw ;
}


BEGIN_MESSAGE_MAP(CINFWizDoc, CDocument)
	//{{AFX_MSG_MAP(CINFWizDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc diagnostics

#ifdef _DEBUG
void CINFWizDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CINFWizDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc serialization

void CINFWizDoc::Serialize(CArchive& ar)
{
	unsigned unumbytes ;
	CString& csinfcontents = m_pciw->m_csINFContents ;

	if (ar.IsStoring())
	{
		unumbytes = csinfcontents.GetLength() ;
		ar.Write(csinfcontents.GetBuffer(unumbytes + 10), unumbytes) ;
		csinfcontents.ReleaseBuffer() ;
	}
	else
	{
		// TODO: add loading code here
	}
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc commands

void CINFWizDoc::OnCloseDocument()
{
	// Clean up the wizard if the class was correctly constructed.

	if (m_bGoodInit) {
		delete m_pciw ;
		m_pciw = NULL ;
	} ;

	CDocument::OnCloseDocument();
}


BOOL CINFWizDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
	// Opening an INF doc in this way is not supported so complain and exit.

	CString csmsg ;
	csmsg.LoadString(IDS_INFOpenError) ;
	AfxMessageBox(csmsg, MB_ICONINFORMATION) ;
	return FALSE ;

	//if (!CDocument::OnOpenDocument(lpszPathName))
	//	return FALSE;
	
	// TODO: Add your specialized creation code here
	
	//return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CINFCheckView

IMPLEMENT_DYNCREATE(CINFCheckView, CFormView)

CINFCheckView::CINFCheckView()
	: CFormView(CINFCheckView::IDD)
{
	//{{AFX_DATA_INIT(CINFCheckView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CINFCheckView::~CINFCheckView()
{
}

void CINFCheckView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFCheckView)
	DDX_Control(pDX, IDC_ErrWrnLstBox, m_clbMissingFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFCheckView, CFormView)
	//{{AFX_MSG_MAP(CINFCheckView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFCheckView diagnostics

#ifdef _DEBUG
void CINFCheckView::AssertValid() const
{
	CFormView::AssertValid();
}

void CINFCheckView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CINFCheckView message handlers

/******************************************************************************

  CINFCheckView::OnInitialUpdate

  Resize the frame to better fit the visible controls in it.

******************************************************************************/

void CINFCheckView::OnInitialUpdate()
{
    CRect	crtxt ;				// Coordinates of list box label
	CRect	crlbfrm ;			// Coordinates of list box and frame

	CFormView::OnInitialUpdate() ;

	// Get the dimensions of the list box label

	HWND	hlblhandle ;		
	GetDlgItem(IDC_INFCLabel, &hlblhandle) ;
	::GetWindowRect(hlblhandle, crtxt) ;
	crtxt.NormalizeRect() ;

	// Get the dimensions of the list box and then add the height of the label
	// to those dimensions.

	m_clbMissingFiles.GetWindowRect(crlbfrm) ;
	crlbfrm.bottom += crtxt.Height() ;

	// Make sure the frame is big enough for these 2 controls plus a little bit
	// more.

	crlbfrm.right += 40 ;
	crlbfrm.bottom += 40 ;
    GetParentFrame()->CalcWindowRect(crlbfrm) ;
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crlbfrm.Width(), crlbfrm.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE) ;
}


/******************************************************************************

  CINFCheckView::PostINFChkMsg

  Add an error or warning message to the list box.

******************************************************************************/

void CINFCheckView::PostINFChkMsg(CString& csmsg)
{	
	int n = m_clbMissingFiles.AddString(csmsg) ;
}


/******************************************************************************

  CINFCheckView::DeleteAllMessages

  Delete all of the messages in the list box.

******************************************************************************/

void CINFCheckView::DeleteAllMessages(void)
{
	m_clbMissingFiles.ResetContent() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc

IMPLEMENT_DYNCREATE(CINFCheckDoc, CDocument)

CINFCheckDoc::CINFCheckDoc()
{
}

BOOL CINFCheckDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}

CINFCheckDoc::~CINFCheckDoc()
{
}


/******************************************************************************

  CINFCheckDoc::PostINFChkMsg

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CINFCheckDoc::PostINFChkMsg(CString& csmsg)
{	
	POSITION pos = GetFirstViewPosition() ;
	if (pos != NULL) {
		CINFCheckView* pcicv = (CINFCheckView *) GetNextView(pos) ;
		pcicv->PostINFChkMsg(csmsg) ;
		pcicv->UpdateWindow() ;
	} ;
}


/******************************************************************************

  CINFCheckDoc::DeleteAllMessages

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CINFCheckDoc::DeleteAllMessages(void)
{
	POSITION pos = GetFirstViewPosition() ;
	if (pos != NULL) {
		CINFCheckView* pcicv = (CINFCheckView *) GetNextView(pos) ;
		pcicv->DeleteAllMessages() ;
		pcicv->UpdateWindow() ;
	} ;
}


BEGIN_MESSAGE_MAP(CINFCheckDoc, CDocument)
	//{{AFX_MSG_MAP(CINFCheckDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc diagnostics

#ifdef _DEBUG
void CINFCheckDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CINFCheckDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc serialization

void CINFCheckDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCompatID::CCompatID( CString csMfg, CString csModel )
{
   // Save the Parameters
   m_csMfg = csMfg;
   m_csModel = csModel;
}


CCompatID::~CCompatID()
{

}


void CCompatID::TransString(CString &csInput)
{
   // Walk Through the String changing Spaces to Underscores
   DWORD i;
   TCHAR cszSpace[] = TEXT(" ");
   TCHAR cszUS[] = TEXT("_");
   DWORD dwLength = csInput.GetLength();

   for ( i = 0; i < dwLength; i++ )
   {
      if (csInput.GetAt(i) == cszSpace[0])
         csInput.SetAt(i, cszUS[0]);
   }
}


USHORT CCompatID::GetCheckSum(CString csValue)
{
    WORD    wCRC16a[16]={
        0000000,    0140301,    0140601,    0000500,
        0141401,    0001700,    0001200,    0141101,
        0143001,    0003300,    0003600,    0143501,
        0002400,    0142701,    0142201,    0002100,
    };

    WORD    wCRC16b[16]={
        0000000,    0146001,    0154001,    0012000,
        0170001,    0036000,    0024000,    0162001,
        0120001,    0066000,    0074000,    0132001,
        0050000,    0116001,    0104001,    0043000,
    };

    BYTE    byte;
    USHORT  CS=0;
    DWORD   dwSize = csValue.GetLength();
    PBYTE   ptr = (PBYTE) csValue.GetBuffer(dwSize);

    dwSize *= sizeof(TCHAR);

    for ( ; dwSize ; --dwSize, ++ptr) {

        byte = (BYTE)(((WORD)*ptr)^((WORD)CS));  // Xor CRC with new char
        CS      = ((CS)>>8) ^ wCRC16a[byte&0x0F] ^ wCRC16b[byte>>4];
    }
    csValue.ReleaseBuffer();

    return CS;
}


void CCompatID::GenerateID(CString &csCompID)
{
   CString csTransModel, csMfgModel;

   // Build the Mfg Model string
   csMfgModel = m_csMfg;
   csMfgModel += m_csModel;

   // Convert the spaces to underscores
   TransString( csMfgModel );

   csTransModel = m_csModel;
   TransString( csTransModel );

   csCompID = csMfgModel;

   // Get the CheckSum
   USHORT usCheckSum = GetCheckSum( csCompID );


   // Now chop off the Mfg/Model string if too Long.
   if ( csCompID.GetLength() > MAX_DEVNODE_NAME_ROOT )
   {
      csCompID.GetBufferSetLength(MAX_DEVNODE_NAME_ROOT);
      csCompID.ReleaseBuffer();
   }

   TCHAR szCheckSum[6] = { 0x00 };
   // _itot( usCheckSum, szCheckSum, 16 );
   _stprintf( szCheckSum, _T("%04X"), usCheckSum );
   csCompID +=szCheckSum;

   //csCompID += TEXT(",");
   //csCompID += csTransModel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\minidev.h ===
/******************************************************************************

  Source File:  MiniDriver Developer Studio.H

  This defines the main application class, and other relatively global data.

  Copyright (c) 1997 By Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/******************************************************************************

  CMiniDriverStudio class

  This is the application class for this application. 'Nuff said?

******************************************************************************/

class CMiniDriverStudio : public CWinApp {
    //  Document templates for the various editors and error display windows
    CMultiDocTemplate   *m_pcmdtGlyphMap, *m_pcmdtFont, *m_pcmdtModel,
                        *m_pcmdtWorkspace, *m_pcmdtWSCheck, *m_pcmdtStringEditor,
						*m_pcmdtINFViewer, *m_pcmdtINFCheck ;
	CString				m_strAppPath ;	// Application path

	CStringArray		m_csaGPDKeywordArray ;	// Array of GPD keyword strings

public:
	CMiniDriverStudio();

    bool	m_bOSIsW2KPlus ;			// True iff OS ver >= 5.0
	bool	m_bExcludeBadCodePages ;	// See CDefaultCodePageSel:OnSetActive()
	
	CMultiDocTemplate*  GlyphMapTemplate() const { return m_pcmdtGlyphMap; }
    CMultiDocTemplate*  FontTemplate() const { return m_pcmdtFont; }
    CMultiDocTemplate*  GPDTemplate() const { return m_pcmdtModel; }
    CMultiDocTemplate*  WSCheckTemplate() const { return m_pcmdtWSCheck; }
    CMultiDocTemplate*  StringEditorTemplate() const { return m_pcmdtStringEditor; }
    CMultiDocTemplate*  INFViewerTemplate() const { return m_pcmdtINFViewer; }
    CMultiDocTemplate*  INFCheckTemplate() const { return m_pcmdtINFCheck; }
	CMultiDocTemplate*  WorkspaceTemplate() const { return m_pcmdtWorkspace; } 
    
	void SaveAppPath() ;
	CString GetAppPath() const { return m_strAppPath ; } 

	CStringArray& GetGPDKeywordArray() { return m_csaGPDKeywordArray ; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMiniDriverStudio)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMiniDriverStudio)
	afx_msg void OnAppAbout();
	afx_msg void OnUpdateFileGeneratemaps(CCmdUI* pCmdUI);
	afx_msg void OnFileGeneratemaps();
	//}}AFX_MSG
#if !defined(NOPOLLO)
	afx_msg void OnFileNew();
#endif
	DECLARE_MESSAGE_MAP()
private:
	void ShowTipAtStartup(void);
private:
	void ShowTipOfTheDay(void);
};

//  App access function(s)

CMiniDriverStudio&  ThisApp();

CMultiDocTemplate*  GlyphMapDocTemplate();
CMultiDocTemplate*  FontTemplate();
CMultiDocTemplate*  GPDTemplate();
CMultiDocTemplate*  WSCheckTemplate();
CMultiDocTemplate*  StringEditorTemplate();
CMultiDocTemplate*  INFViewerTemplate();
CMultiDocTemplate*  INFCheckTemplate();

//  Text File Loading (into a CStringArray) function

BOOL    LoadFile(LPCTSTR lpstrFile, CStringArray& csaContents);


class CMDTCommandLineInfo : public CCommandLineInfo
{
// Construction
public:
	CMDTCommandLineInfo() ;
	~CMDTCommandLineInfo() ;

// Implementation
public:
	virtual void ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast) ;

// Data
public:
    bool	m_bCheckOS ;				// Check OS version >= 5 iff true
	bool	m_bExcludeBadCodePages ;	// See CDefaultCodePageSel:OnSetActive()
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\modldata.cpp ===
/******************************************************************************

  Source File: Model Data Knowledge Base.CPP
  
  This implements the DLL initialization routines for the DLL, for starters.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-19-1997    Bob_Kjelgaard@Prodigy.Net   Created it

*******************************************************************************/

#include    "StdAfx.H"
//#include    <AfxDllX.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  DllMain

  DLL initialization routine.  This has the responsibility of adding this DLL
  to the recognized sets of extensions, so the MFC methods for resource sharing
  will work properly.

******************************************************************************/

/*** Commented out because this is no longer part of a DLL.

static AFX_EXTENSION_MODULE ModelDataKnowledgeBaseDLL = {NULL, NULL};

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH) {
		TRACE0("Model Data Knowledge Base.Dll Initializing!\n");
		
		if (!AfxInitExtensionModule(ModelDataKnowledgeBaseDLL, hInstance))
			return 0;

		new CDynLinkLibrary(ModelDataKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Model Data Knowledge Base.Dll Terminating!\n");
		AfxTermExtensionModule(ModelDataKnowledgeBaseDLL);
	}
	return 1;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newcomp.cpp ===
// NewComponent.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"

#include "NewFile.h"

#include "utility.h"
#include "projnode.h"
#include "gpdfile.h"
#include "nproject.h"

#include "nconvert.h"

#include "newcomp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewComponent

IMPLEMENT_DYNAMIC(CNewComponent, CPropertySheet)


CNewComponent::CNewComponent(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	AddPage(&m_cnf) ;
	AddPage(&m_cnp) ;
	AddPage(&m_cnc) ;
}


CNewComponent::CNewComponent(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{

}


CNewComponent::~CNewComponent()
{
}


BEGIN_MESSAGE_MAP(CNewComponent, CPropertySheet)
	//{{AFX_MSG_MAP(CNewComponent)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewComponent message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\minidev.cpp ===
/******************************************************************************

  Source File:  MiniDriver Developer Studio.CPP

  This implements the MFC application object and closely related classes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Renamed it when the project was
                reorganized into an EXE with multiple DLLs

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include	"resource.h"
#include	"WSCheck.H"
#include    "MiniDev.H"
#include    "MainFrm.H"
#include    "ChildFrm.H"
#include    "ProjView.H"
#include    "GTTView.H"
#include    "comctrls.h"
#include    "FontView.H"
#include    "GPDView.H"
#include    <CodePage.H>
#include	"tips.h"
#include	"StrEdit.h"
#include	"INFWizrd.h"
#include	<string.h>

// for new project and new file

#include    "newcomp.h"

#include    <Dos.H>
#include    <Direct.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio

BEGIN_MESSAGE_MAP(CMiniDriverStudio, CWinApp)
	ON_COMMAND(CG_IDS_TIPOFTHEDAY, ShowTipOfTheDay)
	//{{AFX_MSG_MAP(CMiniDriverStudio)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_UPDATE_COMMAND_UI(ID_FILE_GENERATEMAPS, OnUpdateFileGeneratemaps)
	ON_COMMAND(ID_FILE_GENERATEMAPS, OnFileGeneratemaps)
	//}}AFX_MSG_MAP
	// Standard file based document commands
#if defined(NOPOLLO)
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
#else
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
#endif
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio construction

CMiniDriverStudio::CMiniDriverStudio() 
{
	m_bOSIsW2KPlus = false ;
	m_bExcludeBadCodePages = true ;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMiniDriverStudio object

static CMiniDriverStudio theApp;

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio initialization

BOOL CMiniDriverStudio::InitInstance() {

    // Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    SetRegistryKey(_TEXT("Microsoft"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	m_pcmdtWorkspace = new CMultiDocTemplate(
		IDR_MINIWSTYPE,
		RUNTIME_CLASS(CProjectRecord),
		RUNTIME_CLASS(CMDIChildWnd), 
		RUNTIME_CLASS(CProjectView));
	AddDocTemplate(m_pcmdtWorkspace);
    m_pcmdtGlyphMap = new CMultiDocTemplate(IDR_GLYPHMAP, 
        RUNTIME_CLASS(CGlyphMapContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CGlyphMapView));
    AddDocTemplate(m_pcmdtGlyphMap);
    m_pcmdtFont = new CMultiDocTemplate(IDR_FONT_VIEWER, 
        RUNTIME_CLASS(CFontInfoContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CFontViewer));
    AddDocTemplate(m_pcmdtFont);
    m_pcmdtModel = new CMultiDocTemplate(IDR_GPD_VIEWER,
        RUNTIME_CLASS(CGPDContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CGPDViewer));
    AddDocTemplate(m_pcmdtModel);
    m_pcmdtWSCheck = new CMultiDocTemplate(IDR_WSCHECK,
        RUNTIME_CLASS(CWSCheckDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CWSCheckView));
    AddDocTemplate(m_pcmdtWSCheck);
    m_pcmdtStringEditor = new CMultiDocTemplate(IDR_STRINGEDITOR,
        RUNTIME_CLASS(CStringEditorDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CStringEditorView));
    AddDocTemplate(m_pcmdtStringEditor);
    m_pcmdtINFViewer = new CMultiDocTemplate(IDR_INF_FILE_VIEWER,
        RUNTIME_CLASS(CINFWizDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CINFWizView));
    AddDocTemplate(m_pcmdtINFViewer);
    m_pcmdtINFCheck = new CMultiDocTemplate(IDR_INFCHECK,
        RUNTIME_CLASS(CINFCheckDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CINFCheckView));
    AddDocTemplate(m_pcmdtINFCheck);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes();	//raid 104081 ..Types(TRUE) ->..Types()

	// Parse command line for standard shell commands, DDE, file open

	CMDTCommandLineInfo cmdInfo ;
	ParseCommandLine(cmdInfo) ;

	//  Turn off New on startup

    if  (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew)
        cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing ;
															    
	// Check to see if the OS check should be skipped.  Clean up command line
	// related info if the OS check will be skipped.

	if (!cmdInfo.m_bCheckOS || !cmdInfo.m_bExcludeBadCodePages) 
		if  (cmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen)
			cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing ;
	
	m_bExcludeBadCodePages = cmdInfo.m_bExcludeBadCodePages ;

	// Dispatch commands specified on the command line

	if (!ProcessShellCommand(cmdInfo))
		return FALSE ;

	// The MDT can only run on Win 98 or NT 4.0+.

	if (cmdInfo.m_bCheckOS) {
		OSVERSIONINFO	osinfo ;	// Filled by GetVersionEx()
		osinfo.dwOSVersionInfoSize = sizeof(osinfo) ;
		GetVersionEx(&osinfo) ;
		if (osinfo.dwPlatformId != VER_PLATFORM_WIN32_NT 
		 || osinfo.dwMajorVersion < 5) {
			AfxMessageBox(IDS_ReqOSError) ;
			return FALSE ;
		} ;
		m_bOSIsW2KPlus = true ;
	} ;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	// Get and save the application path

	SaveAppPath() ;

	// CG: This line inserted by 'Tip of the Day' component.
	ShowTipAtStartup();

	return TRUE;
}


void CMiniDriverStudio::SaveAppPath() 
{
	// Get the program's filespec

	GetModuleFileName(m_hInstance, m_strAppPath.GetBufferSetLength(256), 256) ;
	m_strAppPath.ReleaseBuffer() ;

	// Take the file name off the string so that only the path is left.

	int npos = npos = m_strAppPath.ReverseFind(_T('\\')) ;
	m_strAppPath = m_strAppPath.Left(npos + 1) ;
}


/////////////////////////////////////////////////////////////////////////////
// CMDTCommandLineInfo used to process command line info

CMDTCommandLineInfo::CMDTCommandLineInfo()
{
	m_bCheckOS = true ;
	m_bExcludeBadCodePages = true ;
}


CMDTCommandLineInfo::~CMDTCommandLineInfo()
{
}


void CMDTCommandLineInfo::ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast)
{
	if (strcmp(lpszParam, _T("4")) == 0)
		m_bCheckOS = false ;
	else if (_stricmp(lpszParam, _T("CP")) == 0)
		m_bExcludeBadCodePages = false ;
	else
		CCommandLineInfo::ParseParam(lpszParam, bFlag, bLast)	;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog {
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual BOOL OnInitDialog();
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) {
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMiniDriverStudio::OnAppAbout() {
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio commands


//  Handle the File GenerateMaps menu item.  We only enable it if there's
//  something new to see.

void CMiniDriverStudio::OnUpdateFileGeneratemaps(CCmdUI* pccui) {
	
    CCodePageInformation    ccpi;

    for (unsigned u = 0; u < ccpi.InstalledCount(); u++)
        if  (!ccpi.HaveMap(ccpi.Installed(u)))
            break;

    pccui -> Enable(u < ccpi.InstalledCount());
}

void CMiniDriverStudio::OnFileGeneratemaps() {
	CCodePageInformation    ccpi;

    AfxMessageBox(ccpi.GenerateAllMaps() ? IDS_MapsGenerated : IDS_MapsFailed);
}

void CMiniDriverStudio::ShowTipAtStartup(void) {
	// CG: This function added by 'Tip of the Day' component.

	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);
	if (cmdInfo.m_bShowSplash) 	{
		CTipOfTheDay dlg;
		if (dlg.m_bStartup)
			dlg.DoModal();
	}
}

void CMiniDriverStudio::ShowTipOfTheDay(void) {
	// CG: This function added by 'Tip of the Day' component.

	CTipOfTheDay dlg;
	dlg.DoModal();
}

#if !defined(NOPOLLO)

/******************************************************************************

  CMiniDriverStudio::OnFileNew

  This allows you to create a workspace by conversion.  Perhaps when the Co.
  Jones arrive, this will be invoked as a separate menu item, rather than the
  File New item...

******************************************************************************/

void CMiniDriverStudio::OnFileNew() {
//	LPBYTE pfoo = (LPBYTE) 0x2cffe7 ;

	CNewComponent cnc(_T("New") ) ;
 
	cnc.DoModal() ;
/*    CDocument*  pcdWS = m_pcmdtWorkspace -> CreateNewDocument();
    if  (!pcdWS || !pcdWS -> OnNewDocument()) {
        if  (pcdWS)
            delete  pcdWS;
        return;
    }
    m_pcmdtWorkspace -> SetDefaultTitle(pcdWS);
    CFrameWnd*  pcfw = m_pcmdtWorkspace -> CreateNewFrame(pcdWS, NULL);
    if  (!pcfw) return;
    m_pcmdtWorkspace -> InitialUpdateFrame(pcfw, pcdWS);
*/

}




#endif  //!defined(NOPOLLO)

//  Global Functions go here, saith the Bob...

CMiniDriverStudio&  ThisApp() { return theApp; }

CMultiDocTemplate*  GlyphMapDocTemplate() {
    return  theApp.GlyphMapTemplate();
}

CMultiDocTemplate* FontTemplate() { return theApp.FontTemplate(); }

CMultiDocTemplate*  GPDTemplate() { return theApp.GPDTemplate(); }

CMultiDocTemplate*  WSCheckTemplate() { return theApp.WSCheckTemplate(); }

CMultiDocTemplate*  StringEditorTemplate() { return theApp.StringEditorTemplate(); }

CMultiDocTemplate*  INFViewerTemplate() { return theApp.INFViewerTemplate(); }

CMultiDocTemplate*  INFCheckTemplate() { return theApp.INFCheckTemplate(); }

BOOL    LoadFile(LPCTSTR lpstrFile, CStringArray& csaContents) {

    CStdioFile  csiof;

    if  (!csiof.Open(lpstrFile, 
        CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))

        return  FALSE;

    csaContents.RemoveAll();
    try {
        CString csContents;
        while   (csiof.ReadString(csContents))
            csaContents.Add(csContents);
    }
    catch(...) {
        return  FALSE;
    }

    return  TRUE;
}

//  CAboutDlg command handlers.

BOOL CAboutDlg::OnInitDialog() {

	CDialog::OnInitDialog();

    CString csWork, csFormat;

	// Fill available memory
    MEMORYSTATUS ms = {sizeof(MEMORYSTATUS)};
	GlobalMemoryStatus(&ms);
	csFormat.LoadString(CG_IDS_PHYSICAL_MEM);
	csWork.Format(csFormat, ms.dwAvailPhys / 1024L, ms.dwTotalPhys / 1024L);

	SetDlgItemText(IDC_PhysicalMemory, csWork);

	// Fill disk free information
	struct _diskfree_t diskfree;
	int nDrive = _getdrive(); // use current default drive
	if (_getdiskfree(nDrive, &diskfree) == 0) {
		csFormat.LoadString(CG_IDS_DISK_SPACE);
		csWork.Format(csFormat, (DWORD)diskfree.avail_clusters *
			(DWORD)diskfree.sectors_per_cluster *
			(DWORD)diskfree.bytes_per_sector / (DWORD)1024L,
			nDrive - 1 + _T('A'));
	}
 	else
 		csWork.LoadString(CG_IDS_DISK_SPACE_UNAVAIL);

	SetDlgItemText(IDC_FreeDiskSpace, csWork);

    csWork.Format(_TEXT("Code Pages:  ANSI %u OEM %u"), GetACP(), GetOEMCP());

    SetDlgItemText(IDC_CodePages, csWork);

    return TRUE;
}


// This code is needed because of the references to the following functions
// and variable in DEBUG.H.

#ifdef DBG

ULONG _cdecl DbgPrint(PCSTR, ...)
{
	return 0 ;
}

VOID DbgBreakPoint(VOID)
{
}

PCSTR StripDirPrefixA(PCSTR pstrFilename)
{
	return "" ;
}

int  giDebugLevel ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\mainfrm.h ===
/******************************************************************************

  Header File:  Main Frame.H

  This defines the class which handles the application's main window's frame.
  It will begin life, at the least, as a standaard MFC App Wizard creation.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-04-2997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/


// CGPDToolBar is used to add control(s) to the GPD tool bar.

class CGPDToolBar : public CToolBar
{
public:
	CEdit	ceSearchBox ;		// Search text edit box
	//CButton	cbNext ;			// Search next button
	//CButton cbPrevious ;		// Search previous button
} ;


// Widths of control(s) in CGPDToolBar.

#define	GPD_SBOX_WIDTH		170


class CMainFrame : public CMDIFrameWnd {
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

	void GetGPDSearchString(CString& cstext) ;
	CGPDToolBar* GetGpdToolBar() { return &m_ctbBuild; }	// raid 16573
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	afx_msg void OnInitMenu(CMenu* pMenu);
	CStatusBar  m_wndStatusBar;
	CToolBar    m_ctbMain;
	CGPDToolBar	m_ctbBuild;		  

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newcomp.h ===
#if !defined(AFX_NEWCOMPONENT_H__BF7CE06F_A5C1_4985_BA38_C80D4178B0AF__INCLUDED_)
#define AFX_NEWCOMPONENT_H__BF7CE06F_A5C1_4985_BA38_C80D4178B0AF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// newcompo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewComponent
#include "NewFile.h"
#include "nproject.h"
#include "nconvert.h"

class CNewComponent : public CPropertySheet
{
	DECLARE_DYNAMIC(CNewComponent)

// Construction
public:

	CNewComponent(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CNewComponent(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	

// Attributes
public:

// Operations
public:
	CNewFile     m_cnf ; // rename CNewPrjWResource // del
	CNewProject  m_cnp ; // rename CNewPrjWTemplate
	CNewConvert  m_cnc ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewComponent)
	//}}AFX_VIRTUAL

// Implementation
public:
	CNewProject* GetProjectPage() { return &m_cnp ; } ;
	virtual ~CNewComponent();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewComponent)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWCOMPONENT_H__BF7CE06F_A5C1_4985_BA38_C80D4178B0AF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nconvert.h ===
#if !defined(AFX_NEWPROJECT_H__CC553456_AD1E_4816_8A20_5DF52F336FA6__INCLUDED_)
#define AFX_NEWPROJECT_H__CC553456_AD1E_4816_8A20_5DF52F336FA6__INCLUDED_

//#include "minidev.h"	// Added by ClassView
#include "utility.h"	// Added by ClassView
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewProject.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConvPfmDlg dialog

class CConvPfmDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CConvPfmDlg)

// Construction
public:
	CConvPfmDlg();
	~CConvPfmDlg();

// Dialog Data
	//{{AFX_DATA(CConvPfmDlg)
	enum { IDD = IDD_ConvertPFM };
	CComboBox	m_ccbCodepages;
	CString	m_csGttPath;
	CString	m_csPfmPath;
	CString	m_csUfmDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvPfmDlg)
	public:
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvPfmDlg)
	afx_msg void OnGTTBrowser();
	afx_msg void OnPFMBrowsers();
	afx_msg void OnSelchangeComboCodePage();
	afx_msg void OnUfmDirBrowser();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool ConvPFMToUFM();
	CStringArray m_csaPfmFiles;
};

/////////////////////////////////////////////////////////////////////////////
// CConverPFM

class CConvertPFM : public CPropertySheet
{
	DECLARE_DYNAMIC(CConvertPFM)

// Construction
public:
	CConvertPFM(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CConvertPFM(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

private:
	CConvPfmDlg m_ccpd ;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConverPFM)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CConvertPFM();

	// Generated message map functions
protected:
	//{{AFX_MSG(CConverPFM)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CConvCttDlg dialog

class CConvCttDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CConvCttDlg)

// Construction
public:
	CConvCttDlg();
	~CConvCttDlg();

// Dialog Data
	//{{AFX_DATA(CConvCttDlg)
	enum { IDD = IDD_ConvertCTT };
	CComboBox	m_ccbCodepages;
	CString	m_csCttPath;
	CStringArray m_csaCttFiles ;
	CString	m_csGttDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvCttDlg)
	public:
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvCttDlg)
	afx_msg void OnCTTBrowser();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool ConvCTTToGTT();
};

/////////////////////////////////////////////////////////////////////////////
// CConvertCTT

class CConvertCTT : public CPropertySheet
{
	DECLARE_DYNAMIC(CConvertCTT)

// Construction
public:
	CConvertCTT(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CConvertCTT(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
private:
	CConvCttDlg m_cccd ;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConvertCTT)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CConvertCTT();

	// Generated message map functions
protected:
	//{{AFX_MSG(CConvertCTT)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CNewConvert dialog

class CNewConvert : public CPropertyPage
{
	DECLARE_DYNCREATE(CNewConvert)

// Construction
public:
	

	CNewConvert();
	~CNewConvert();

// Dialog Data
	//{{AFX_DATA(CNewConvert)
	enum { IDD = IDD_NewConvert };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewConvert)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNewConvert)
	afx_msg void OnPrjConvert();
	afx_msg void OnPFMConvert();
	afx_msg void OnCTTConvert(); 
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
//	CSafeObArray m_csoaModels,m_csoaFonts,m_csoaAtlas;

	CPropertySheet * m_pcps;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROJECT_H__CC553456_AD1E_4816_8A20_5DF52F336FA6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nconvert.cpp ===
// NewProject.cpp : implementation file
//


#include "stdafx.h"
#include "minidev.h"

#include "codepage.h"

#include    <wingdi.h>
#include    <winddi.h>
#include    <prntfont.h>
#include    <uni16res.h>

#include  "gtt.h"
#include  "nconvert.h" 

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConvPfmDlg property page

IMPLEMENT_DYNCREATE(CConvPfmDlg, CPropertyPage)

CConvPfmDlg::CConvPfmDlg() : CPropertyPage(CConvPfmDlg::IDD)
{

	//{{AFX_DATA_INIT(CConvPfmDlg)
	m_csGttPath = _T("");
	m_csPfmPath = _T("");
	m_csUfmDir = _T("");
	//}}AFX_DATA_INIT
}

CConvPfmDlg::~CConvPfmDlg()
{
}

void CConvPfmDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvPfmDlg)
	DDX_Control(pDX, IDC_ComboCodePage, m_ccbCodepages);
	DDX_Text(pDX, IDC_GttPath, m_csGttPath);
	DDX_Text(pDX, IDC_PfmFiles, m_csPfmPath);
	DDX_Text(pDX, IDC_UfmDir, m_csUfmDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvPfmDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CConvPfmDlg)
	ON_BN_CLICKED(IDC_GTTBrowser, OnGTTBrowser)
	ON_BN_CLICKED(IDC_PFMBrowser, OnPFMBrowsers)
	ON_CBN_SELCHANGE(IDC_ComboCodePage, OnSelchangeComboCodePage)
	ON_BN_CLICKED(IDC_UfmDirBrowser, OnUfmDirBrowser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvPfmDlg message handlers

BOOL CConvPfmDlg::OnWizardFinish() 
{
	CString csErr ; 


	if( ConvPFMToUFM() ) {
		csErr.Format(IDS_NewUFM,m_csUfmDir) ;
		AfxMessageBox(csErr,MB_ICONINFORMATION) ;
	}
	else
	{
		csErr.LoadString(IDS_NewUFMError);
		AfxMessageBox(csErr,MB_ICONEXCLAMATION) ;
	}
	return CPropertyPage::OnWizardFinish();
}

LRESULT CConvPfmDlg::OnWizardBack() 
{
	
	// restore the parent propertysheet dialog.
	EndDialog(IDD_ConvertPFM) ;
	return CPropertyPage::OnWizardBack();
}


BOOL CConvPfmDlg::OnSetActive() 
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_DISABLEDFINISH) ;	
	((CPropertySheet*)GetParent())->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		// There are 3 code pages that seem to make MultiByteToWideChar() to 
		// fail.  Don't let the user choose one of those code pages unless
		// he knows the secret password (ie, undocument command line switch
		// 'CP').

		if (ThisApp().m_bExcludeBadCodePages)
			if (dwcp == 1361 || dwcp == 28595 || dwcp == 28597) 
				continue ;

		wsprintf(accp, "%5d", dwcp) ;
		n = m_ccbCodepages.AddString(accp) ;
		if (dwcp == 1252) // change dwdefcp to 1252 due to not support DBCS.
			m_ccbCodepages.SetCurSel(n) ;
	} ;
	return CPropertyPage::OnSetActive();
}

void CConvPfmDlg::OnGTTBrowser() 
{
	UpdateData() ;
	CString csFilter = _T("GTT File(*.gtt)|*.gtt||") ;
	CString csExtension = _T(".GTT") ;
	CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST ,csFilter);
	
	if  (cfd.DoModal() == IDOK) {
        m_csGttPath = cfd.GetPathName() ;
		UpdateData(FALSE) ;	
	} ;
	
	
}

void CConvPfmDlg::OnPFMBrowsers() 
{
	UpdateData() ;
	CString csFilter( _T("PFM Files (*.pfm)|*.pfm||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".ctt"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {

		m_csaPfmFiles.Add(cfd.GetNextPathName(pos)) ;
	}
	
	m_csPfmPath = m_csaPfmFiles[0] ;
	// GTT directory is same with the CTT directory as default.
	m_csUfmDir = m_csPfmPath.Left(m_csPfmPath.ReverseFind(_T('\\') ) );
	SetCurrentDirectory(m_csUfmDir) ;
	UpdateData(FALSE) ;

	if(m_csPfmPath.GetLength() )
		((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;		
	
}


/**************************************************************************************
bool CConvPfmDlg::OnUfmDirBrowser()
Do ; just directory browser
Args 
Ret.

***************************************************************************************/

void CConvPfmDlg::OnUfmDirBrowser() 
{
	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
//    char    acidir[_MAX_PATH] ; // Initial directory is built here
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    strcpy(acpath, _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	ofn.lpstrInitialDir = m_csUfmDir ; //  in parent dialog box
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY /*| OFN_ENABLEHOOK */| OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook = NULL ;// BrowseDlgProc ;

    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    
	m_csUfmDir = (LPCTSTR) acpath ;


	UpdateData(FALSE) ;
	
}


/**************************************************************************************
bool CConvPfmDlg::OnSelchangeComboCodePage()
Do ;DBCS code page convert does not supported in this version. so we have to show exclamtion
messag to the user when they select DBCS code page; the reason of showing DBCS in the list
although they are not supported is that it cann't less confusing to the user.

Args 
Ret.

***************************************************************************************/


// 
void CConvPfmDlg::OnSelchangeComboCodePage() 
{
	CString csCodepage ;
	DWORD   dwCodepage ;
	m_ccbCodepages.GetLBText(m_ccbCodepages.GetCurSel(),csCodepage) ;

	dwCodepage = atoi(csCodepage) ;


	if (dwCodepage == 932 || dwCodepage == 936 || dwCodepage == 949 || dwCodepage == 950 ) {
		AfxMessageBox(_T("DBCS conversion is not supported in this version"),MB_ICONINFORMATION) ;
		DWORD dwacp = GetACP() ;
		TCHAR acp[16] ;
		wsprintf(acp, "%5d",dwacp) ;
		int nI = m_ccbCodepages.FindString(-1,acp ) ;
		m_ccbCodepages.SetCurSel(nI ) ;
	} ;
		

} ;

struct sGTTHeader {
    DWORD   m_dwcbImage;
    enum    {Version1Point0 = 0x10000};
    DWORD   m_dwVersion;
    DWORD   m_dwfControl;   //  Any flags defined?
    long    m_lidPredefined;
    DWORD   m_dwcGlyphs;
    DWORD   m_dwcRuns;
    DWORD   m_dwofRuns;
    DWORD   m_dwcCodePages;
    DWORD   m_dwofCodePages;
    DWORD   m_dwofMapTable;
    DWORD   m_dwReserved[2];
    sGTTHeader() {
        memset(this, 0, sizeof *this);
        m_dwVersion = Version1Point0;
        m_lidPredefined = CGlyphMap::NoPredefined;
        m_dwcbImage = sizeof *this;
    }
};

extern "C" {

    BOOL    BConvertPFM(LPBYTE lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT,
                        PWSTR pwstrUnique, LPCTSTR lpstrUFM, int iGTTID);

	PUNI_GLYPHSETDATA PGetDefaultGlyphset(
	IN		HANDLE		hHeap,
	IN		WORD		wFirstChar,
	IN		WORD		wLastChar,
	IN		DWORD		dwCodePage) ;


}

/**************************************************************************************
bool CConvPfmDlg::ConvPFMToUFM()
Do ; this is workhorse. untimately, all routine exist for BConvertPFM; correct codepage
inside gtt file, ufm directory, gtt files or resource gtt or default. new UFM files 
are created inside BConvertPFM function. just set correct UFM path.

Args .
Ret.

***************************************************************************************/
bool CConvPfmDlg::ConvPFMToUFM()
{
	// Call BConvertPFM for each PFM data with codepage, gtt data if exist,
	// ufm file path and name, 
	CByteArray cbaGTT ;
	// loading the GTT
	// change the codepage value of GTT(
	CString csCodePage ;
	DWORD   dwCodePage ;
	m_ccbCodepages.GetLBText(m_ccbCodepages.GetCurSel(),csCodePage) ;
	dwCodePage = atoi(csCodePage) ;

	// loading the GTT file when there is gtt file or we have to use resource file or 
	// default GTT file instead of real GTT file
	if (m_csGttPath.GetLength() ) {

		try {
			CFile   cfLoad(m_csGttPath, CFile::modeRead | CFile::shareDenyWrite);
			cbaGTT.SetSize(cfLoad.GetLength());
			cfLoad.Read(cbaGTT.GetData(), cfLoad.GetLength());
		}

		catch   (CException   *pce) {
			pce -> ReportError();
			pce -> Delete();
			cbaGTT.RemoveAll();
			return false;
		}
	
	} 
	else
	{
		short sid = (short)dwCodePage ;
		if(MAKEINTRESOURCE((sid < 0) ? -sid : sid) == NULL)
			return false ;

        HRSRC hrsrc = FindResource(AfxGetResourceHandle(),
            MAKEINTRESOURCE((sid < 0) ? -sid : sid),
            MAKEINTRESOURCE(IDR_GLYPHMAP));
        if  (hrsrc) {
			HGLOBAL hg = LoadResource(AfxGetResourceHandle(), hrsrc) ;
			if  (!hg)
				return false;
			LPVOID  lpv = LockResource(hg) ;
			if  (!lpv)
				return false ;
			cbaGTT.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc)) ;
			memcpy(cbaGTT.GetData(), lpv, (size_t)cbaGTT.GetSize()) ;
			return false ;
		} ;

		//AfxMessageBox("GTT building code reached.") ;

		// If all else fails, try to generate a GTT based on the code page ID
		// that should be in m_wID if this point is reached.

        HANDLE   hheap ;
        UNI_GLYPHSETDATA *pGTT ;
        if (!(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024))) {
			AfxMessageBox(IDS_HeapInGLoad) ;
			return false ;
		} ;
		pGTT = PGetDefaultGlyphset(hheap, 0x20, 0xff,
								   (DWORD) sid) ;
		if (pGTT == NULL) {
			HeapDestroy(hheap) ;		//raid 116600 Prefix
			AfxMessageBox(IDS_PGetFailedInGLoad) ;
			return false ;
		} ;
		cbaGTT.SetSize(pGTT->dwSize) ;
		memcpy(cbaGTT.GetData(), pGTT, (size_t)cbaGTT.GetSize()) ;
		HeapDestroy(hheap) ;
    }

	// Creating the UFM Path
	UpdateData() ;
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	WIN32_FIND_DATA wfd32 ;
	HANDLE hDir = FindFirstFile(m_csUfmDir,&wfd32) ;
	if (hDir == INVALID_HANDLE_VALUE) {
		if (!CreateDirectory(m_csUfmDir,&st) ) {
			CString csmsg ;
			csmsg = _T("Fail to create the template directory") ;
			AfxMessageBox(csmsg) ;
			return false ;
		} 
	} ;

	//Set the GTT codepage with selected code page by user
	union {
		BYTE* pbGTT ;
		sGTTHeader* psGTTH ;
	} ;

	pbGTT = cbaGTT.GetData() ;
	if (!pbGTT)
		return false ;
	PUNI_CODEPAGEINFO pCodepage = (PUNI_CODEPAGEINFO)(pbGTT + psGTTH->m_dwofCodePages );
	CopyMemory(&pCodepage->dwCodePage,&dwCodePage,sizeof(DWORD) ) ;
	
	// Convert the PFM to UFM: calling the BConvertPFM for every selected PFM files
	CCodePageInformation ccpi ;
	
	for ( int i = 0 ; i < m_csaPfmFiles.GetSize() ; i++ ) {
		// loading the PFM
		CString csPFMPath = m_csaPfmFiles[i] ;
		
		CByteArray cbaPFM ;
		try {
			CFile   cfLoad(csPFMPath, CFile::modeRead | CFile::shareDenyWrite);
			cbaPFM.SetSize(cfLoad.GetLength());
			cfLoad.Read(cbaPFM.GetData(), cfLoad.GetLength());
			cfLoad.Close() ;
		}
		
		catch   (CException   *pce) {
			pce -> ReportError();
			pce -> Delete();
			cbaPFM.RemoveAll();
			return  false ;
		}

		CString csUFMName = csPFMPath.Mid(csPFMPath.ReverseFind(_T('\\') )+1 ) ;
		
		csUFMName = csUFMName.Left(csUFMName.ReverseFind(('.')) ) ;
		csUFMName.MakeUpper() ;
		CString csUFMPath = m_csUfmDir + _T("\\") + csUFMName + _T(".UFM") ;
		
		// convert ansi unique name to unicode.
		CByteArray  cbaIn;
        CWordArray  cwaOut;

        cbaIn.SetSize(1 + csUFMName.GetLength());
        lstrcpy((LPSTR) cbaIn.GetData(), (LPCTSTR) csUFMName);
        ccpi.Convert(cbaIn, cwaOut, GetACP());
		
		// Call the global function BConvertPFM, BConvertPFM creat the UFM file under the
		// specified path.
		if(!BConvertPFM(cbaPFM.GetData(), dwCodePage, cbaGTT.GetData(),
				cwaOut.GetData(), csUFMPath, (short) 0 ) )
			return false;
		// clear the data field

//		cbaPFM.RemoveAll() ;
//		cwaOut.RemoveAll() ;
		

	}

	return true ;
}

/////////////////////////////////////////////////////////////////////////////
// CConverPFM

IMPLEMENT_DYNAMIC(CConvertPFM, CPropertySheet)

CConvertPFM::CConvertPFM(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CConvertPFM::CConvertPFM(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{

	AddPage(&m_ccpd) ;

	SetWizardMode() ;


}

CConvertPFM::~CConvertPFM()
{
}


BEGIN_MESSAGE_MAP(CConvertPFM, CPropertySheet)
	//{{AFX_MSG_MAP(CConverPFM)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConverPFM message handlers

/////////////////////////////////////////////////////////////////////////////
// CConvCttDlg property page

IMPLEMENT_DYNCREATE(CConvCttDlg, CPropertyPage)

CConvCttDlg::CConvCttDlg() : CPropertyPage(CConvCttDlg::IDD)
{
	//{{AFX_DATA_INIT(CConvCttDlg)
	m_csCttPath = _T("");
	m_csGttDir = _T("");
	//}}AFX_DATA_INIT
}

CConvCttDlg::~CConvCttDlg()
{
}

void CConvCttDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvCttDlg)
	DDX_Control(pDX, IDC_COMBO_Codepage, m_ccbCodepages);
	DDX_Text(pDX, IDC_EDIT_CTTFile, m_csCttPath);
	DDX_Text(pDX, IDC_GttDirectory, m_csGttDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvCttDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CConvCttDlg)
	ON_BN_CLICKED(IDC_CTTBrowser, OnCTTBrowser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvCttDlg message handlers

BOOL CConvCttDlg::OnWizardFinish() 
{
	CString csErr ;
	if(ConvCTTToGTT() ) {
		csErr.Format(IDS_NewGTT,m_csGttDir) ;
		AfxMessageBox(csErr,MB_ICONINFORMATION) ;
	}
	else
	{
		csErr.LoadString(IDS_NewGTTError);
		AfxMessageBox(csErr,MB_ICONEXCLAMATION) ;
	}
	
	return CPropertyPage::OnWizardFinish();
}

LRESULT CConvCttDlg::OnWizardBack() 
{
	EndDialog(IDD_ConvertCTT) ;
	return CPropertyPage::OnWizardBack();
}

void CConvCttDlg::OnCTTBrowser() 
{
	UpdateData() ;
	CString csFilter( _T("CTT Files (*.ctt)|*.ctt||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".ctt"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {
		m_csaCttFiles.Add(cfd.GetNextPathName(pos)) ;
	}
	
	
	m_csCttPath = m_csaCttFiles[0] ;
	// GTT directory is same with the CTT directory as default.
	m_csGttDir = m_csCttPath.Left(m_csCttPath.ReverseFind(_T('\\') ) );
	SetCurrentDirectory(m_csGttDir) ;

	UpdateData(FALSE) ;

	if(m_csCttPath.GetLength() )
		((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;		
	
}

//DEL BOOL CConvCttDlg::OnInitDialog() 
//DEL {
//DEL 	CPropertyPage::OnInitDialog();
//DEL 	
//DEL 	//Fill the list with installed codepage rather than supported code page.
//DEL 	
//DEL 	CCodePageInformation ccpi ; 
//DEL 
//DEL //	ccpi.
//DEL 
//DEL 	return TRUE;  // return TRUE unless you set the focus to a control
//DEL 	              // EXCEPTION: OCX Property Pages should return FALSE
//DEL }

BOOL CConvCttDlg::OnSetActive() 
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_DISABLEDFINISH) ;	
	((CPropertySheet*)GetParent())->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;
	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		// There are 3 code pages that seem to make MultiByteToWideChar() to 
		// fail.  Don't let the user choose one of those code pages unless
		// he knows the secret password (ie, undocument command line switch
		// 'CP').

		
		if (dwcp == 1361 || dwcp == 28595 || dwcp == 28597) 
			continue ;

		wsprintf(accp, "%5d", dwcp) ;
		n = m_ccbCodepages.AddString(accp) ;
		if (dwcp == 1252) // change dwdefcp to 1252 due to not support DBCS.
			m_ccbCodepages.SetCurSel(n) ;
	} ;	

	return CPropertyPage::OnSetActive();
}

extern "C"
BOOL
BConvertCTT2GTT(
    IN     HANDLE             hHeap,
    IN     PTRANSTAB          pCTTData,
    IN     DWORD              dwCodePage,
    IN     WCHAR              wchFirst,
    IN     WCHAR              wchLast,
    IN     PBYTE              pCPSel,
    IN     PBYTE              pCPUnSel,
    IN OUT PUNI_GLYPHSETDATA *ppGlyphSetData,
    IN     DWORD              dwGlySize);

extern "C"
PUNI_GLYPHSETDATA
PGetDefaultGlyphset(
	IN		HANDLE		hHeap,
	IN		WORD		wFirstChar,
	IN		WORD		wLastChar,
	IN		DWORD		dwCodePage) ;


bool CConvCttDlg::ConvCTTToGTT()
{

	CString csCodePage ;
	DWORD   dwCodePage ;
	m_ccbCodepages.GetLBText(m_ccbCodepages.GetCurSel(),csCodePage) ;
	dwCodePage = atoi(csCodePage) ;

	// Creating the UFM Path
	UpdateData() ;
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	WIN32_FIND_DATA wfd32 ;
	HANDLE hDir = FindFirstFile(m_csGttDir,&wfd32) ;
	if (hDir == INVALID_HANDLE_VALUE) {
		if (!CreateDirectory(m_csGttDir,&st) ) {
			CString csmsg ;
			csmsg = _T("Fail to create the template directory") ;
			AfxMessageBox(csmsg) ;
			return false ;
		} 
	} ;

	for (int i = 0 ; i < m_csaCttFiles.GetSize() ; i ++ ) {
		
	// load the cTT files
		CString csCTTPath = m_csaCttFiles[i] ;
		CByteArray cbaCTT ;
		try {
			CFile   cfLoad(csCTTPath, CFile::modeRead | CFile::shareDenyWrite);
			cbaCTT.SetSize(cfLoad.GetLength());
			cfLoad.Read(cbaCTT.GetData(), cfLoad.GetLength());
		}
		catch   (CException   *pce) {
        pce -> ReportError();
        pce -> Delete();
        cbaCTT.RemoveAll();
        return  false ;
		}

		PBYTE  pbCTT = cbaCTT.GetData() ;
		HANDLE hheap ;
		  if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )))
		{
			CString csErr ;
			csErr.Format(IDS_HeapCFailed,csCTTPath) ;
			AfxMessageBox(csErr ,MB_ICONEXCLAMATION);
			return  false ;
		}
									
		// call the convert extern function
		UNI_GLYPHSETDATA *pGTT = new UNI_GLYPHSETDATA ;
		
		if (!BConvertCTT2GTT(hheap, (PTRANSTAB)pbCTT, dwCodePage, 0x20, 0xff, NULL, 
			NULL, &pGTT, 0)){
			HeapDestroy(hheap);   // raid 116619 prefix
			return false ;
		}

		

		// store the GTT files
		CString csGTTName = csCTTPath.Mid(csCTTPath.ReverseFind(_T('\\') )+1 ) ;
		csGTTName = csGTTName.Left(csGTTName.ReverseFind(('.')) ) ;
		CString csGTTPath = m_csGttDir + _T("\\") + csGTTName + _T(".GTT") ;
		csGTTName.MakeUpper() ;	
		try {
			CFile   cfGTT;
			if  (!cfGTT.Open(csGTTPath, CFile::modeCreate | CFile::modeWrite |
				CFile::shareExclusive))
				return  false;
			cfGTT.Write(pGTT, pGTT->dwSize);
			cfGTT.Close() ;
		}

		catch   (CException *pce) {
			pce -> ReportError();
			pce -> Delete();
			HeapDestroy(hheap);
			return  false ;
		}
		
//		if (pGTT )
//			delete pGTT ;
		HeapDestroy(hheap);
	}
	return true ;
}
/////////////////////////////////////////////////////////////////////////////
// CConvertCTT

IMPLEMENT_DYNAMIC(CConvertCTT, CPropertySheet)

CConvertCTT::CConvertCTT(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CConvertCTT::CConvertCTT(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	AddPage(&m_cccd) ;

	SetWizardMode() ;

}

CConvertCTT::~CConvertCTT()
{
}


BEGIN_MESSAGE_MAP(CConvertCTT, CPropertySheet)
	//{{AFX_MSG_MAP(CConvertCTT)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertCTT message handlers
/////////////////////////////////////////////////////////////////////////////
// CNewConvert property page

IMPLEMENT_DYNCREATE(CNewConvert, CPropertyPage)

CNewConvert::CNewConvert() : CPropertyPage(CNewConvert::IDD)
{
	//{{AFX_DATA_INIT(CNewConvert)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}



CNewConvert::~CNewConvert()
{
}

void CNewConvert::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewConvert)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewConvert, CPropertyPage)
	//{{AFX_MSG_MAP(CNewConvert)
	ON_BN_CLICKED(IDC_CONVERT, OnPrjConvert)
	ON_BN_CLICKED(IDC_CONV_PFM, OnPFMConvert)
	ON_BN_CLICKED(IDC_CONV_CTT, OnCTTConvert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewConvert message handlers


/*************************************************************************************
void CNewConvert::OnPrjConvert() 
Creat Doc-> call Convert Wizard -> Creat frame -> Create View by updatefram

**************************************************************************************/
void CNewConvert::OnPrjConvert() 
{
	 //  Invoke the wizard.
	m_pcps->ShowWindow(SW_HIDE) ;
	CMultiDocTemplate* pcmdt = ThisApp().WorkspaceTemplate() ;

	CDocument* pcdWS = pcmdt->CreateNewDocument() ;

	if  (!pcdWS || !pcdWS -> OnNewDocument()) {
        if  (pcdWS) {
            delete  pcdWS;
			m_pcps->EndDialog(1) ;
		}
        return;
    }
	pcmdt->SetDefaultTitle(pcdWS) ;
	
	CFrameWnd* pcfw = pcmdt->CreateNewFrame(pcdWS,NULL) ;

	if (pcfw) 
		pcmdt->InitialUpdateFrame(pcfw,pcdWS) ;

	m_pcps->EndDialog(1) ;
	

	
}

/*************************************************************************************
void CNewConvert::OnPFMConvert() 


**************************************************************************************/

void CNewConvert::OnPFMConvert() 
{
	CConvertPFM cnp ( _T("PFM Convert To UFM ") ) ;

	m_pcps->ShowWindow(SW_HIDE) ;

	INT_PTR ret = cnp.DoModal() ;
	if (ret == (INT_PTR)IDD_ConvertPFM )
		m_pcps->ShowWindow(SW_RESTORE) ;
	else
		m_pcps->EndDialog(1) ;
}


/*************************************************************************************
void CNewConvert::OnCTTConvert() 

**************************************************************************************/

void CNewConvert::OnCTTConvert() 
{
	CConvertCTT ccc ( _T("GTT Converter ") ) ;

	m_pcps->ShowWindow(SW_HIDE) ;

    INT_PTR ret = ccc.DoModal() ;
	if (ret == (INT_PTR)IDD_ConvertCTT )
		m_pcps->ShowWindow(SW_RESTORE) ;
	else
		m_pcps->EndDialog(1) ;
}


/***************************************************************************************
	BOOL CNewConvert::OnSetActive() 
Do.
****************************************************************************************/
BOOL CNewConvert::OnSetActive() 
{
	
	return CPropertyPage::OnSetActive();
}

/***************************************************************************************
	BOOL CNewConvert::OnInitDialog()  
Do; Getting perent pointer

****************************************************************************************/
BOOL CNewConvert::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	m_pcps = DYNAMIC_DOWNCAST(CPropertySheet,GetOwner() ) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newfile.h ===
#if !defined(AFX_NEWFILE_H__97287CE6_9DCB_47D4_920D_23575A63D0B5__INCLUDED_)
#define AFX_NEWFILE_H__97287CE6_9DCB_47D4_920D_23575A63D0B5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewFile.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewFile dialog

/*
class CNewFile : public CPropertyPage

This version doesn't support insert to project file creation. Actually this is intially 
desigend support, but time isn't enough to implement that, so just delete relevant edit,
button in the Dlg box. I don't delete the 


*/
class CNewFile : public CPropertyPage
{
	DECLARE_DYNCREATE(CNewFile)

// Construction
	const int FILES_NUM;

public:
	CNewFile();
	CNewFile(CPropertySheet *pcps) ;
	~CNewFile();

// Dialog Data
	//{{AFX_DATA(CNewFile)
	enum { IDD = IDD_NewFile };
//	CButton	m_cbEnPrj;
	CListCtrl	m_clcFileName;
	CString	m_csFileLoc;
//	CString	m_csPrjName;
	CString	m_csNewFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewFile)
	public:
	virtual BOOL OnSetActive();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNewFile)
	afx_msg void OnBrowser();
	afx_msg void OnDblclkNewfilesList(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewFilename();
	afx_msg void OnClickNewfilesList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void SetOkButton();
//	BOOL m_bproj;
	BOOL CallNewDoc();
	CPropertySheet *m_pcps ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWFILE_H__97287CE6_9DCB_47D4_920D_23575A63D0B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\parser.c ===
/******************************************************************************

  Source File:	Parser.C

  This is an NT Build hack.  It includes all of the "C" files used for the
  GPD parser, because Build can't handle directories beyond ..

  This file also contains some of the code used to access parts of the parser.
  It is put here so that there will be no need to grovel around to find the 
  appropriate include files needed to call the parser.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved

  A Pretty Penny Enterprises Production

  Change History:

  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Did the dirty deed
  07-18-1998	ekevans@acsgroup.com		Added first parser access routines

******************************************************************************/

#define	UNICODE
#define	_UNICODE

#undef	WINVER	//	Undo the MFC weirdness
#define	WINVER	0x0500
#define	_DEBUG_H_
#include "lib.h"

extern void _cdecl DebugPrint(PCSTR, ...);

#define	ERR(x)	DebugPrint x
#define	WARNING(x) DebugPrint x
#define	VERBOSE(x)
#define	ASSERT(x)
#define RIP(x)

//	Parser files
#if defined(WIN32)
#include	"..\..\..\parsers\gpd\preproc1.c"
#include	"..\..\..\parsers\gpd\command.c"
#include	"..\..\..\parsers\gpd\constrnt.c"
#include	"..\..\..\parsers\gpd\helper1.c"
#include	"..\..\..\parsers\gpd\installb.c"
#include	"..\..\..\parsers\gpd\macros1.c"
#include	"..\..\..\parsers\gpd\postproc.c"
#include	"..\..\..\parsers\gpd\semanchk.c"
#include	"..\..\..\parsers\gpd\shortcut.c"
#include	"..\..\..\parsers\gpd\snapshot.c"
#include	"..\..\..\parsers\gpd\snaptbl.c"
#include	"..\..\..\parsers\gpd\state1.c"
#include	"..\..\..\parsers\gpd\state2.c"
#include	"..\..\..\parsers\gpd\token1.c"
#include	"..\..\..\parsers\gpd\value1.c"
#include	"..\..\..\parsers\gpd\treewalk.c"
#include	"..\..\..\parsers\gpd\framwrk1.c"
#else
#include	"..\..\parsers\gpd\preproc1.c"
#include	"..\..\parsers\gpd\command.c"
#include	"..\..\parsers\gpd\constrnt.c"
#include	"..\..\parsers\gpd\helper1.c"
#include	"..\..\parsers\gpd\installb.c"
#include	"..\..\parsers\gpd\macros1.c"
#include	"..\..\parsers\gpd\postproc.c"
#include	"..\..\parsers\gpd\semanchk.c"
#include	"..\..\parsers\gpd\shortcut.c"
#include	"..\..\parsers\gpd\snapshot.c"
#include	"..\..\parsers\gpd\snaptbl.c"
#include	"..\..\parsers\gpd\state1.c"
#include	"..\..\parsers\gpd\state2.c"
#include	"..\..\parsers\gpd\token1.c"
#include	"..\..\parsers\gpd\value1.c"
#include	"..\..\parsers\gpd\treewalk.c"
#include	"..\..\parsers\gpd\framwrk1.c"
#endif


BOOL bKeywordInitDone = FALSE ;		// TRUE iff the keyword table has been initialized
int  nKeywordTableSize = -1 ;		// The number of valid entries in the keyword table


/******************************************************************************

  InitGPDKeywordTable()

  Call the part of the GPD parser that is needed to initialize the GPD keyword
  table.  This must be done before GPD keyword string pointers can be returned
  by GetGPDKeywordStr().

  If all goes well, a flag is set, the size of the table is saved, and the size
  of the table is returned.  If something fails, return -1.

******************************************************************************/

int InitGPDKeywordTable(PGLOBL pglobl)
{			
    PRANGE  prng ;				// Used to reference the table section ranges

	// Initialize the GPD parser

	VinitGlobals(0, pglobl) ;
	if (!BpreAllocateObjects(pglobl) || !BinitPreAllocatedObjects(pglobl)) 
		return -1 ;
	bKeywordInitDone = TRUE ;

	// Save the size of the table

    prng  = (PRANGE)(gMasterTable[MTI_RNGDICTIONARY].pubStruct) ;
    nKeywordTableSize = (int) (prng[END_ATTR - 1].dwEnd) ;

	// Return the size of the table

	return nKeywordTableSize ;
}


/******************************************************************************

  GetGPDKeywordStr()

  Return a pointer to the specified (numbered) GPD keyword string.  The pointer
  might be NULL.  Always return a NULL pointer if the GPD keyword table has not
  been initialized or a request for a string passed the end of the table is
  requested.

******************************************************************************/

PSTR GetGPDKeywordStr(int nkeyidx, PGLOBL pglobl)
{
	// Nothing can be done if the GPD parser could not be initialized or the
	// key index is too big.

	if (!bKeywordInitDone || nkeyidx > nKeywordTableSize)
		return NULL ;

	// Return the requested keyword string pointer.

	return (mMainKeywordTable[nkeyidx].pstrKeyword) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newproj.h ===
/******************************************************************************

  Header File:  New Project Wizard.H

  This file defines the various classes which make up the new project/ new
  mini-driver wizard.  This is a key component of the studio, as it is the tool
  that kicks all the important conversions off for us.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_kjelgaard@Prodigy.Net   Created the initial version.

******************************************************************************/

#if !defined(NEW_PROJECT_WIZARD)
#define NEW_PROJECT_WIZARD

#if defined(LONG_NAMES)
#include    "Project Record.H"
#else
#include    "ProjRec.H"
#endif

//  An initial definition of the wizard class

class CNewConvertWizard;

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage dialog

class CFirstNewWizardPage : public CPropertyPage {

    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CFirstNewWizardPage(CNewConvertWizard &cnpwOwner);
	~CFirstNewWizardPage();

// Dialog Data
	//{{AFX_DATA(CFirstNewWizardPage)
	enum { IDD = IDD_FirstPageNewWizard };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFirstNewWizardPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFirstNewWizardPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	bool IsWrongNT4File(CString& cswrcfspec) ;
};

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets dialog

class CSelectTargets : public CPropertyPage {

    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CSelectTargets(CNewConvertWizard& cnpwOwner);
	~CSelectTargets();

// Dialog Data
	//{{AFX_DATA(CSelectTargets)
	enum { IDD = IDD_NPWSelectTargets };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectTargets)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectTargets)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations dialog

class CSelectDestinations : public CPropertyPage {

    CNewConvertWizard&  m_cnpwOwner;

    void    DoDirectoryBrowser(CString& csinitdir);
    BOOL    BuildStructure();

// Construction
public:
	CSelectDestinations(CNewConvertWizard& cnpwOwner);
	~CSelectDestinations();

// Dialog Data
	//{{AFX_DATA(CSelectDestinations)
	enum { IDD = IDD_NPWSelectDest };
	CButton	m_cbBrowseNT3x;
	CButton	m_cbBrowseNT40;
	CButton	m_cbBrowseW2000;
	CString	m_csW2KDest;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectDestinations)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectDestinations)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowseNT40();
	afx_msg void OnBrowseW2000();
	afx_msg void OnBrowseNT3x();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CGPDSelection dialog

class CGPDSelection : public CPropertyPage
{
    CNewConvertWizard&  m_cnpwOwner ;
	bool				m_bBtnStateIsSelect ;

// Construction
public:
	CGPDSelection(CNewConvertWizard& cnpwOwner) ;
	~CGPDSelection();

// Dialog Data
	//{{AFX_DATA(CGPDSelection)
	enum { IDD = IDD_NPWGPDSelection };
	CButton	m_cbGPDSelBtn;
	CEditControlEditBox	m_cecebFileName;
	CEdit	m_ceModelName;
	CEditControlListBox	m_ceclbGPDInfo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGPDSelection)
	public:
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGPDSelection)
	afx_msg void OnGPDSelBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	bool GPDInfoSaveAndVerify(bool bverifydata) ;
};


/////////////////////////////////////////////////////////////////////////////
// CRunUniTool dialog

class CRunUniTool : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CRunUniTool(CNewConvertWizard& cnpwOwner);
	~CRunUniTool();

// Dialog Data
	//{{AFX_DATA(CRunUniTool)
	enum { IDD = IDD_RunUniTool };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRunUniTool)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRunUniTool)
	afx_msg void OnRunUniTool();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles dialog

class CConvertFiles : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CConvertFiles(CNewConvertWizard& cnpwOwner);
	~CConvertFiles();

// Dialog Data
	//{{AFX_DATA(CConvertFiles)
	enum { IDD = IDD_ConvertFiles };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvertFiles)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvertFiles)
	afx_msg void OnConvertFiles();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC dialog

class CRunNTGPC : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CRunNTGPC(CNewConvertWizard& cnpwOwner);
	~CRunNTGPC();

// Dialog Data
	//{{AFX_DATA(CRunNTGPC)
	enum { IDD = IDD_GPCEditor };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRunNTGPC)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRunNTGPC)
	afx_msg void OnRunNtGpcEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages dialog

class CMapCodePages : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CMapCodePages(CNewConvertWizard& cnpwOwner);
	~CMapCodePages();

// Dialog Data
	//{{AFX_DATA(CMapCodePages)
	enum { IDD = IDD_NPWCodePageSelection };
	CListBox	m_clbMapping;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMapCodePages)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMapCodePages)
	afx_msg void OnChangeCodePage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CDefaultCodePageSel dialog

class CDefaultCodePageSel : public CPropertyPage
{
    CNewConvertWizard&  m_cnpwOwner ;
	bool				bInitialized ;

// Construction
public:
	CDefaultCodePageSel(CNewConvertWizard& cnpwOwner) ;
	~CDefaultCodePageSel();

// Dialog Data
	//{{AFX_DATA(CDefaultCodePageSel)
	enum { IDD = IDD_NPWDefaultCodePageSel };
	CListBox	m_clbCodePages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDefaultCodePageSel)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDefaultCodePageSel)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CNewConvertWizard

class CNewConvertWizard : public CPropertySheet {

    CProjectRecord& m_cprThis;  //  The project being set up
    BOOL                m_bFastConvert; //  Normal/Custom conversion flag
    WORD                m_eGPDConvert; //  Flag for GPD conversion

    //  Property pages contained in this wizard.
    CFirstNewWizardPage m_cfnwp;
    CSelectTargets      m_cst;
    CSelectDestinations m_csd;
    CRunUniTool         m_crut;
    CMapCodePages       m_cmcp;
    CRunNTGPC           m_crng;
    CConvertFiles       m_ccf;
	CGPDSelection		m_cgpds;
	CDefaultCodePageSel m_cdcps ;

// Construction
public:
	CNewConvertWizard(CProjectRecord& cprFor, CWnd* pParentWnd = NULL);
	
// Attributes
public:

    CProjectRecord& Project() { return m_cprThis; }
    BOOL            FastConvert() const { return m_bFastConvert; }

    enum    {Direct, Macro, CommonRC, CommonRCWithSpoolerNames};
    WORD            GPDConvertFlag() const { return m_eGPDConvert; }

// Operations
public:

    void            FastConvert(BOOL bFastConvert) { 
        m_bFastConvert = bFastConvert;
    }

    void            GPDConvertFlag(WORD wf) { m_eGPDConvert = wf; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewConvertWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNewConvertWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewConvertWizard)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CSelectCodePage dialog

class CSelectCodePage : public CDialog {
    CString     m_csName;
    unsigned    m_uidCurrent;
    CDWordArray m_cdaPages;
// Construction
public:
	CSelectCodePage(CWnd* pParent, CString csName, unsigned uidPage);

    unsigned    SelectedCodePage() const { return m_uidCurrent; }
    CString     GetCodePageName() const;

    void        Exclude(CDWordArray& cdaExclude);
    void        LimitTo(CDWordArray& cdaExclusive);

// Dialog Data
	//{{AFX_DATA(CSelectCodePage)
	enum { IDD = IDD_SelectPage };
	CListBox	m_clbPages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectCodePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectCodePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeSupportedPages();
	afx_msg void OnDblclkSupportedPages();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nproject.h ===
#if !defined(AFX_NEWTPROJECT_H__BB1A03B5_5555_4DE7_988D_D6F5117D0D77__INCLUDED_)
#define AFX_NEWTPROJECT_H__BB1A03B5_5555_4DE7_988D_D6F5117D0D77__INCLUDED_

#include "utility.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPrjWTem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewProject dialog

class CNewProject : public CPropertyPage
{
//	DECLARE_DYNCREATE(CNewProject) 
	DECLARE_SERIAL(CNewProject) 

	
// Construction
public:
	CString GetGPDpath() {return m_csGPDpath ; } ;

	CGPDContainer* GPDContainer () { return m_pcgc ; } 
	CNewProject();   // standard constructor


// Dialog Data
	//{{AFX_DATA(CNewProject)
	enum { IDD = IDD_NEW_PROJECT };
	CButton	m_cbLocprj;
	CButton	m_cbAddT;
	CListCtrl m_clcTemplate ;
	CString	m_csPrjname;
	CString	m_csPrjpath;
	CString	m_cstname;
	CString	m_cstpath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewProject)
	public:
	virtual BOOL OnSetActive();
	virtual void Serialize(CArchive& car);
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewProject)
	afx_msg void OnGpdBrowser();
	afx_msg void OnDirBrowser() ;
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckAdd();
	afx_msg void OnAddTemplate();
	afx_msg void OnChangeEditPrjName();
	afx_msg void OnChangeEditPrjLoc();
	afx_msg void OnClickListTemplate(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListTemplate(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	bool AddGpds(CString& csTemplate);
	void SetButton();
	CString m_csGPDpath;
	CGPDContainer* m_pcgc;
	CString m_csoldPrjpath;
	CPropertySheet* m_pcps;
	CStringArray m_csaTlst;
	CMapStringToString m_cmstsTemplate;

};


/////////////////////////////////////////////////////////////////////////////
// CNewPrjWResource dialog

class CNewPrjWResource : public CPropertyPage
{

	DECLARE_DYNCREATE(CNewPrjWResource) 
// Construction
public:
	CNewPrjWResource();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewPrjWResource)
	enum { IDD = IDD_NewResource };
	CButton	m_cbCheckFonts;
	CString	m_csUFMpath;
	CString	m_csGTTpath;
	CString	m_csGpdFileName;
	CString	m_csModelName;
	CString	m_csRCName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPrjWResource)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPrjWResource)
	afx_msg void OnSerchUFM();
	afx_msg void OnSearchGTT();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckFonts();
	afx_msg void OnChangeEditGpd();
	afx_msg void OnChangeEditModel();
	afx_msg void OnChangeEditResourec();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CStringArray m_csaUFMFiles, m_csaGTTFiles ;

private:
	CStringArray m_csaRcid;
	void CreateRCID(CString csgpd );
	CNewProject*   m_pcnp;
	
};



class CNewProjectWizard : public CPropertySheet
{
	DECLARE_DYNAMIC(CNewProjectWizard)

	
// Construction
public:
	CNewProjectWizard(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CNewProjectWizard(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
	
	CWnd* m_pParent;

public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewProjectWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	CPropertyPage* GetProjectPage();
//	CPropertyPage * GetTemplatePage( ) { return (CPropertyPage*)&m_cpwt ; } 
	
	virtual ~CNewProjectWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewProjectWizard)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CNewPrjWResource m_cpwr ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWTPROJECT_H__BB1A03B5_5555_4DE7_988D_D6F5117D0D77__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\pfm2ifi.cpp ===
/*************************** Module Header **********************************
 * pfm2ifi
 *      Program to read Windows 3.1 PFM format data and convert to NT's
 *      IFIMETRICS data.  Note that since IFIMETRICS is somewhat more
 *      elaborate than PFM data,  some of the values are best guesses.
 *      These are made on the basis of educated guesses.
 *
 * Copyright (C) 1992,  Microsoft Corporation
 *
 ****************************************************************************/

#include        "StdAfx.h"
#if (_WIN32_WINNT < 0x0500)
typedef unsigned long DESIGNVECTOR;
#endif
#include        <winddi.h>

#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        "raslib.h"
#include        "fontinst.h"
#undef DBG
#define	ALIAS_EXT    "._al"             /* The extension on an alias file */


/*   Function prototypes  */
char  **ppcGetAlias( HANDLE, const char * );


PBYTE MapFileA( LPCSTR, DWORD * );
BOOL  bValidatePFM( BYTE *, DWORD );

CD  *GetFontSel(HANDLE hHeap, FONTDAT *pFDat, int bSelect) {
    LOCD	    locd;		/* From originating data */
    CD		   *pCD;
    CD		   *pCDOut;		/* Copy data to here */


    locd = bSelect ? pFDat->DI.locdSelect : pFDat->DI.locdUnSelect;

    if( locd != -1 ) // (NOOCD extended to a long)
    {
	int   size;

	CD    cdTmp;			/* For alignment problems */


	pCD = (CD *)(pFDat->pBase + locd);

        /*
         *   The data pointed at by pCD may not be aligned,  so we copy
         * it into a local structure.  This local structure then allows
         * us to determine how big the CD really is (using it's length field),
         * so then we can allocate storage and copy as required.
         */

        memcpy( &cdTmp, (LPSTR)pCD, sizeof(CD) );

	/* Allocate storage area in the heap */

	size = cdTmp.wLength + sizeof(CD);

	pCDOut = (CD *)HeapAlloc( hHeap, 0, (size + 1) & ~0x1 );
//raid 43535
	if (pCDOut == NULL){
		return 0;
	}

	memcpy( pCDOut, (BYTE *)pCD, size );

	return  pCDOut;
    }

    return   0;
}

short   *GetWidthVector(HANDLE hHeap, FONTDAT *pFDat) {

    /*
     *    For debugging code,  verify that we have a width table!  Then,
     *  allocate memory and copy into it.
     */

    short  *pus;                /* Destination address */

    int     cb;                 /* Number of bytes required */

    /*
     *   There are LastChar - FirstChar width entries,  plus the default
     *  char.  And the widths are shorts.
     */
    cb = (pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 2) * sizeof( short );

    pus = (short *)HeapAlloc( hHeap, 0, cb );

    /*
     *   If this is a bitmap font,  then use the width table, but use
     *  the extent table (in PFMEXTENSION area) as these are ready to
     *  to scale.
     */


    if( pus )
    {
        BYTE   *pb;

        if( pFDat->pETM &&
            pFDat->pETM->emMinScale != pFDat->pETM->emMaxScale &&
            pFDat->PFMExt.dfExtentTable )
        {
            /*   Scalable,  so use the extent table */
            pb = pFDat->pBase + pFDat->PFMExt.dfExtentTable;
        }
        else
        {
            /*   Not scalable.  */
            pb = pFDat->pBase + sizeof( res_PFMHEADER );
        }

        memcpy( pus, pb, cb );
    }

    return  pus;
}

static void ConvFontRes(register FONTDAT *pFDat) {

    BYTE    *pb;		/* Miscellaneous operations */

    res_PFMHEADER    *pPFM;	/* The resource data format */
    res_PFMEXTENSION *pR_PFME;	/* Resource data PFMEXT format */


    /*
     *   Align the PFMHEADER structure.
     */

    pPFM = (res_PFMHEADER *)pFDat->pBase;

    pFDat->PFMH.dfType = pPFM->dfType;
    pFDat->PFMH.dfPoints = pPFM->dfPoints;
    pFDat->PFMH.dfVertRes = pPFM->dfVertRes;
    pFDat->PFMH.dfHorizRes = pPFM->dfHorizRes;
    pFDat->PFMH.dfAscent = pPFM->dfAscent;
    pFDat->PFMH.dfInternalLeading = pPFM->dfInternalLeading;
    pFDat->PFMH.dfExternalLeading = pPFM->dfExternalLeading;
    pFDat->PFMH.dfItalic = pPFM->dfItalic;
    pFDat->PFMH.dfUnderline = pPFM->dfUnderline;
    pFDat->PFMH.dfStrikeOut = pPFM->dfStrikeOut;

    pFDat->PFMH.dfWeight = DwAlign2( pPFM->b_dfWeight );

    pFDat->PFMH.dfCharSet = pPFM->dfCharSet;
    pFDat->PFMH.dfPixWidth = pPFM->dfPixWidth;
    pFDat->PFMH.dfPixHeight = pPFM->dfPixHeight;
    pFDat->PFMH.dfPitchAndFamily = pPFM->dfPitchAndFamily;

    pFDat->PFMH.dfAvgWidth = DwAlign2( pPFM->b_dfAvgWidth );
    pFDat->PFMH.dfMaxWidth = DwAlign2( pPFM->b_dfMaxWidth );

    pFDat->PFMH.dfFirstChar = pPFM->dfFirstChar;
    pFDat->PFMH.dfLastChar = pPFM->dfLastChar;
    pFDat->PFMH.dfDefaultChar = pPFM->dfDefaultChar;
    pFDat->PFMH.dfBreakChar = pPFM->dfBreakChar;

    pFDat->PFMH.dfWidthBytes = DwAlign2( pPFM->b_dfWidthBytes );

    pFDat->PFMH.dfDevice = DwAlign4( pPFM->b_dfDevice );
    pFDat->PFMH.dfFace = DwAlign4( pPFM->b_dfFace );
    pFDat->PFMH.dfBitsPointer = DwAlign4( pPFM->b_dfBitsPointer );
    pFDat->PFMH.dfBitsOffset = DwAlign4( pPFM->b_dfBitsOffset );


    /*
     *   The PFMEXTENSION follows the PFMHEADER structure plus any width
     *  table info.  The width table will be present if the PFMHEADER has
     *  a zero width dfPixWidth.  If present,  adjust the extension address.
     */

    pb = pFDat->pBase + sizeof( res_PFMHEADER );  /* Size in resource data */

    if( pFDat->PFMH.dfPixWidth == 0 )
	pb += (pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 2) * sizeof( short );

    pR_PFME = (res_PFMEXTENSION *)pb;

    /*
     *   Now convert the extended PFM data.
     */

    pFDat->PFMExt.dfSizeFields = pR_PFME->dfSizeFields;

    pFDat->PFMExt.dfExtMetricsOffset = DwAlign4( pR_PFME->b_dfExtMetricsOffset );
    pFDat->PFMExt.dfExtentTable = DwAlign4( pR_PFME->b_dfExtentTable );

    pFDat->PFMExt.dfOriginTable = DwAlign4( pR_PFME->b_dfOriginTable );
    pFDat->PFMExt.dfPairKernTable = DwAlign4( pR_PFME->b_dfPairKernTable );
    pFDat->PFMExt.dfTrackKernTable = DwAlign4( pR_PFME->b_dfTrackKernTable );
    pFDat->PFMExt.dfDriverInfo = DwAlign4( pR_PFME->b_dfDriverInfo );
    pFDat->PFMExt.dfReserved = DwAlign4( pR_PFME->b_dfReserved );

    memcpy( &pFDat->DI, pFDat->pBase + pFDat->PFMExt.dfDriverInfo,
						 sizeof( DRIVERINFO ) );

    /*
     *    Also need to fill in the address of the EXTTEXTMETRIC. This
     *  is obtained from the extended PFM data that we just converted!
     */

    if( pFDat->PFMExt.dfExtMetricsOffset )
    {
        /*
         *    This structure is only an array of shorts, so there is
         *  no alignment problem.  However,  the data itself is not
         *  necessarily aligned in the resource!
         */

        int    cbSize;
        BYTE  *pbIn;             /* Source of data to shift */

        pbIn = pFDat->pBase + pFDat->PFMExt.dfExtMetricsOffset;
        cbSize = DwAlign2( pbIn );

        if( cbSize == sizeof( EXTTEXTMETRIC ) )
        {
            /*   Simply copy it!  */
            memcpy( pFDat->pETM, pbIn, cbSize );
        }
        else
            pFDat->pETM = NULL;         /* Not our size, so best not use it */

    }
    else
        pFDat->pETM = NULL;             /* Is non-zero when passed in */

    return;
}

BOOL    ConvertPFMToIFI(LPCTSTR lpstrPFM, LPCTSTR lpstrIFI, 
                        LPCTSTR lpstrUniq) {
    int       cWidth;           /* Number of entries in width table */
    HANDLE    hheap;            /* Handle to heap for storage */
    HANDLE    hOut;             /* The output file */

    DWORD     dwSize;           /* Size of input file */

    char    **ppcAliasList;     /* The alias list of names,  if present */

    PWSTR     pwstrUniqNm;      /* Unique name */

    IFIMETRICS   *pIFI;

    CD       *pCDSel;           /* Font selection command descriptor */
    CD       *pCDDesel;         /* Deselection - typically not required */

    FI_DATA   fid;              /* Keep track of stuff in the file */

    FONTDAT   FDat;             /* Converted form of data */

    EXTTEXTMETRIC  etm;         /* Additional data on this font */
    INT     bPrint = 0;

    char    acMessage[100];

    /*
     *    Create us a heap,  since all the functions we steal from rasdd
     *  require that we pass a heap handle!
     */

    if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 ))) {
        /*   Not too good!  */
        wsprintf(acMessage, _T("HeapCreate() fails in pfm2ifi") ) ;
        MessageBox(NULL, acMessage, NULL, MB_OK);

        return  FALSE;
    }

    cWidth = strlen(lpstrUniq);

    if ( !(pwstrUniqNm = (PWSTR)HeapAlloc( hheap, 0, (cWidth + 1) * sizeof( WCHAR ) ) ) ){
		wsprintf(acMessage, "HeapAlloc() fails in pfm2ifi" );
        MessageBox(NULL, acMessage, NULL, MB_OK);
        return  FALSE;
    }

    MultiByteToWideChar( CP_ACP, 0, lpstrUniq, cWidth, pwstrUniqNm, cWidth );
    *(pwstrUniqNm + cWidth) = 0;

    /*
     *   Zero out the header structure.  This means we can ignore any
     * irrelevant fields, which will then have the value 0, which is
     * the value for not used.
     */

    memset( &fid, 0, sizeof( fid ) );
    memset( &FDat, 0, sizeof( FONTDAT ) );

    /*
     *   First step is to open the input file - this is done via MapFileA.
     *  We then pass the returned address around to various functions
     *  which do the conversion to something we understand.
     */

    if( !(FDat.pBase = MapFileA( lpstrPFM, &dwSize))) {
        wsprintf(acMessage, "Cannot open input file: %s", lpstrPFM);
        MessageBox(NULL, acMessage, NULL, MB_OK);

        return  FALSE;
    }

    /*
     *    Do some validation on the input file.
     */

    if  (!bValidatePFM( FDat.pBase, dwSize)) {
        wsprintf(acMessage, "%s is not a valid PFM file", lpstrPFM);

        return FALSE;
    }

    /*
     *    If there is a file with the same name as the input file, BUT with
     *  an extension of ._al, this is presumed to be an alias file.  An
     *  alias file consists of a set of alias names for this font.  The
     *  reason is that font names have not been very consistent,  so we
     *  provide aliases to the font mapper,  thus maintaining the format
     *  information for old documents.
     *    The file format is one alias per input line.  Names which
     *  are duplicates of the name in the PFM file will be ignored.
     */

    ppcAliasList = ppcGetAlias(hheap, lpstrPFM);

    FDat.pETM = &etm;               /* Important for scalable fonts */

    /*
     *   Create the output file.
     */

    hOut = CreateFile( lpstrIFI, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                                 FILE_ATTRIBUTE_NORMAL, 0);
    if( hOut == (HANDLE)-1) {
        wsprintf(acMessage, "Could not create output file '%s'", lpstrIFI);
        MessageBox(NULL, acMessage, NULL, MB_OK);
        return  FALSE;
    }

    /*
     *    Now have the data,  so civilise it: alignment etc.
     */

    ConvFontRes( &FDat );

    fid.fCaps = FDat.DI.fCaps;
    fid.wFontType = FDat.DI.wFontType; /* Device  FOnt Type */
    fid.wPrivateData = FDat.DI.wPrivateData;
    fid.sYAdjust = FDat.DI.sYAdjust;
    fid.sYMoved = FDat.DI.sYMoved;
    fid.wXRes = FDat.PFMH.dfHorizRes;
    fid.wYRes = FDat.PFMH.dfVertRes;

    /*
     *    Convert the font metrics.   Note that the last two parameters are
     * chosen with the understanding of how this function does its scaling.
     * Any changes to that method will require changes here too!!!
     */

    pIFI = FontInfoToIFIMetric( &FDat, hheap, pwstrUniqNm, ppcAliasList );
    fid.dsIFIMet.pvData = pIFI;

    if  (fid.dsIFIMet.pvData == 0) {
        /*   Should not happen!  */
        MessageBox(NULL, "Could not create IFIMETRICS", NULL, MB_OK);
        return  FALSE;
    }

    fid.dsIFIMet.cBytes = pIFI->cjThis;

    /*
     *    Also need to record which CTT is used for this font.  When the
     * resource is loaded,  this is turned into the address of the
     * corresponding CTT,  which is a resource somewhere else in the
     * mini-driver,  or in rasdd.
     */
    fid.dsCTT.cBytes = FDat.DI.sTransTab;

    /*
     *   Note that IFIMETRICS is only WORD aligned.  However,  since the
     *  following data only requires WORD alignment, we can ignore any
     *  lack of DWORD alignment.
     */

    /*
     *    If there is a width vector,  now is the time to extract it.
     *  There is one if dfPixWidth field in the PFM data is zero.
     */

    if( FDat.PFMH.dfPixWidth == 0 &&
        (fid.dsWidthTab.pvData = GetWidthVector( hheap, &FDat )) )
    {
        cWidth = pIFI->chLastChar - pIFI->chFirstChar + 1;
        fid.dsWidthTab.cBytes = cWidth * sizeof( short );
    }
    else
        fid.dsWidthTab.cBytes = 0;

    /*
     *    Finally,  the font selection/deselection strings.  These are
     *  byte strings,  sent directly to the printer.   Typically there
     *  is no deselection string.  These require WORD alignment,  and
     *  the GetFontSel function will round the size to that requirement.
     *  Since we follow the width tables,  WORD alignment is guaranteed.
     */

    if( pCDSel = GetFontSel( hheap, &FDat, 1 ) )
    {
        /*   Have a selection string,  so update the red tape etc.  */
        fid.dsSel.cBytes = (int)HeapSize( hheap, 0, (LPSTR)pCDSel );
        fid.dsSel.pvData = pCDSel;
    }

    if( pCDDesel = GetFontSel( hheap, &FDat, 0 ) )
    {
        /*   Also have a deselection string,  so record its presence */
        fid.dsDesel.cBytes = (int)HeapSize( hheap, 0, (LPSTR)pCDDesel );
        fid.dsDesel.pvData = pCDDesel;
    }

    if( FDat.pETM == NULL )
    {
        fid.dsETM.pvData = NULL;
        fid.dsETM.cBytes = 0;
    }
    else
    {
        fid.dsETM.pvData = (VOID*) &etm;
        fid.dsETM.cBytes = sizeof(etm);
    }

    /*
     *   Time to write the output file.
     */

    if( iWriteFDH( hOut, &fid ) < 0 )
        MessageBox(NULL, "CANNOT WRITE OUTPUT FILE", NULL, MB_OK);

    /*   All done,  so clean up and away  */
    UnmapViewOfFile( FDat.pBase );              /* Input no longer needed */

    HeapDestroy(hheap);               /* Probably not needed */
    CloseHandle(hOut);               //  Really, this would be a good idea!  

    return  TRUE;
}

/*
 *   An ASCII based copy of KentSe's mapfile function.
 */


/************************** Function Header *********************************
 * PVOID MapFileA( psz, pdwSize )
 *
 * Returns a pointer to the mapped file defined by psz.
 *
 * Parameters:
 *   psz   ASCII string containing fully qualified pathname of the
 *          file to map.
 *
 * Returns:
 *   Pointer to mapped memory if success, NULL if error.
 *
 * NOTE:  UnmapViewOfFile will have to be called by the user at some
 *        point to free up this allocation.
 *
 * History:
 *  11:32 on Tue 29 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *        Return the size of the file too.
 *
 *   05-Nov-1991    -by-    Kent Settle     [kentse]
 * Wrote it.
 ***************************************************************************/

PBYTE
MapFileA(LPCSTR psz, PDWORD pdwSize) {
    void   *pv;

    HANDLE  hFile, hFileMap;

    BY_HANDLE_FILE_INFORMATION  x;


    /*
     *    First open the file.  This is required to do the mapping, but
     *  it also allows us to find the size,  which is used for validating
     *  that we have something resembling a PFM file.
     */

    hFile = CreateFileA(psz, GENERIC_READ, FILE_SHARE_READ,
                             NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        printf( "MapFileA: CreateFileA( %s ) failed.\n", psz );

        return  NULL;
    }

    /*
     *   Find the size of the file now,  and set it in the caller's area.
     */

    if( GetFileInformationByHandle( hFile, &x ) )
        *pdwSize = x.nFileSizeLow;
    else
        *pdwSize = 0;

    // create the mapping object.

    if( !(hFileMap = CreateFileMappingA( hFile, NULL, PAGE_READONLY,
                                         0, 0, NULL )) )
    {
        printf( "MapFileA: CreateFileMapping failed.\n" );

        return  NULL;
    }

    // get the pointer mapped to the desired file.

    if( !(pv = MapViewOfFile( hFileMap, FILE_MAP_READ, 0, 0, 0 )) )
    {
        printf( "MapFileA: MapViewOfFile failed.\n" );

        return  NULL;
    }

    // now that we have our pointer, we can close the file and the
    // mapping object.

    if( !CloseHandle( hFileMap ) )
        printf( "MapFileA: CloseHandle( hFileMap ) failed.\n" );

    if( !CloseHandle( hFile ) )
        printf( "MapFileA: CloseHandle( hFile ) failed.\n" );

    return  (PBYTE) pv;
}



/************************** Function Header *******************************
 * bValidatePFM
 *      Look at a memory mapped PFM file,  and see if it seems reasonable.
 *
 * RETURNS:
 *      TRUE if OK,  else FALSE
 *
 * HISTORY:
 *  12:22 on Tue 29 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *      First version to improve usability of pfm2ifi.
 *
 **************************************************************************/

BOOL
bValidatePFM( PBYTE pBase, DWORD dwSize ) {

    DWORD    dwOffset;             /* Calculate offset of interest as we go */

    res_PFMHEADER     *rpfm;       /* In Win 3.1 format, UNALIGNED!! */
    res_PFMEXTENSION  *rpfme;      /* Final access to offset to DRIVERINFO */

    DRIVERINFO      di;            /* The actual DRIVERINFO data! */


    /*
     *    First piece of sanity checking is the size!  It must be at least
     *  as large as a PFMHEADER structure plus a DRIVERINFO structure.
     */

    if( dwSize < (sizeof( res_PFMHEADER ) + (sizeof( DRIVERINFO ) ) +
                  sizeof( res_PFMEXTENSION )) )
    {
        return  FALSE;
    }

    /*
     *    Step along to find the DRIVERINFO structure, as this contains
     *  some identifying information that we match to look for legitimacy.
     */
    rpfm = (res_PFMHEADER *)pBase;           /* Looking for fixed pitch */

    dwOffset = sizeof( res_PFMHEADER );

    if( rpfm->dfPixWidth == 0 )
    {
        /*   Proportionally spaced, so allow for the width table too! */
        dwOffset += (rpfm->dfLastChar - rpfm->dfFirstChar + 2) * sizeof( short );

    }

    rpfme = (res_PFMEXTENSION *)(pBase + dwOffset);

    /*   Next is the PFMEXTENSION data  */
    dwOffset += sizeof( res_PFMEXTENSION );

    if( dwOffset >= dwSize )
    {
        return  FALSE;
    }

    dwOffset = DwAlign4( rpfme->b_dfDriverInfo );

    if( (dwOffset + sizeof( DRIVERINFO )) > dwSize )
    {
        return   FALSE;
    }

    /*
     *    A memcpy is used because this data is typically not aigned. Ugh!
     */

    memcpy( &di, pBase + dwOffset, sizeof( di ) );


    if( di.sVersion > DRIVERINFO_VERSION )
    {
        return   FALSE;
    }

    return  TRUE;
}



/************************** Function Header *******************************
 * ppcGetAlias
 *      Return a pointer to an array of pointers to aliases for the given
 *      font name.
 *
 * RETURNS:
 *      Pointer to pointer to aliases;  0 on error.
 *
 * HISTORY:
 *  10:02 on Fri 28 May 1993    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 ***************************************************************************/


char   **
ppcGetAlias( HANDLE hheap, LPCSTR pcFile ) {


    char     *pcAlias;          /* The name of the alias file */
    char     *pcTmp;            /* Temporary stuffing around */
    char     *pcTmp2;           /* Yet more temporary stuffing around */

    char    **ppcRet;           /* The return value */

    FILE     *fAlias;           /* The alias file,  if there */



    ppcRet = (char  **)0;

    /*  The 5 is for the terminating NUL plus the characters "._al"  */
    pcAlias = (char *)HeapAlloc( hheap, 0, strlen( pcFile ) + 5 );

    if( pcAlias )
    {
        /*   Generate the file name, try to open it  */
        strcpy( pcAlias, pcFile );

        if( !(pcTmp = strrchr( pcAlias, '\\' )) )
        {
            /*   No \ in name - is there a /? */
            if( !(pcTmp = strrchr( pcAlias, '/' )) )
            {
                /*  Must be a simple name,  so point at the start of it */
                pcTmp = pcAlias;
            }
        }

        /*
         *    Now pcTmp points at the start of the last component of the
         *  file name.  IF this contains a '.',  then overwrite whatever
         *  follows by our extension,  otherwise add our extension to the end.
         */

        if( !(pcTmp2 = strrchr( pcTmp, '.' )) )
            pcTmp2 = pcTmp + strlen( pcTmp );


        strcpy( pcTmp2, ALIAS_EXT );

        fAlias = fopen( pcAlias, "r" );

        HeapFree( hheap, 0, (LPSTR)pcAlias );            /* No longer used */

        if( fAlias )
        {
            /*
             *    First,  read the file to count how many lines there are.
             *  Thus we can allocate the storage for the array of pointers.
             */

            char  acLine[ 256 ];              /* For reading the input line */
            int   iNum;                       /* Count the number of lines! */
            int   iIndex;                     /* Stepping through input */

            iNum = 0;
            while( fgets( acLine, sizeof( acLine ), fAlias ) )
                ++iNum;


            if( iNum )
            {
                /*  Some data available,  so allocate pointer and off we go */

                ++iNum;
                ppcRet = (char  **)HeapAlloc( hheap, 0, iNum * sizeof( char * ) );

                if( ppcRet )
                {

                    iIndex = 0;

                    rewind( fAlias );             /* Back to the start */

                    while( iIndex < iNum &&
                           fgets( acLine, sizeof( acLine ), fAlias ) )
                    {
                        /*
                         *   Do a little editing - delete leading space,
                         * trailing space + control characters.
                         */


                        pcTmp = acLine;

                        while( *pcTmp &&
                               (!isprint( *pcTmp ) || isspace( *pcTmp )) )
                                       ++pcTmp;


                        /*  Filter out the ending stuff too! */
                        pcTmp2 = pcTmp + strlen( pcTmp );

                        while( pcTmp2 > pcTmp &&
                               (!isprint( *pcTmp2 ) || isspace( *pcTmp2 )) )
                        {
                            /*
                             *   Zap it,  then onto the previous char. NOTE
                             * that this is not the best solution, but it
                             * is convenient.
                             */

                            *pcTmp2-- = '\0';            /* Zap the end */
                        }


                        ppcRet[ iIndex ] = (PSTR) HeapAlloc( hheap, 0,
                                                        strlen( pcTmp ) + 1 );

                        if( ppcRet[ iIndex ] )
                        {
                            /*  Copy input to new buffer */

                            strcpy( ppcRet[ iIndex ], pcTmp );
                            ++iIndex;              /* Next output slot */
                        }

                    }
                    ppcRet[ iIndex ] = NULL;
                }
            }
        }
    }

    return  ppcRet;
}

/************************* Function Header ********************************
 * strcpy2WChar
 *      Convert a char * string to a WCHAR string.  Basically this means
 *      converting each input character to 16 bits by zero extending it.
 *
 * RETURNS:
 *      Value of first parameter.
 *
 * HISTORY:
 *  12:35 on Thu 18 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Use the correct conversion method to Unicode.
 *
 *  09:36 on Thu 07 Mar 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 **************************************************************************/

 static PWSTR   strcpy2WChar(PWSTR pWCHOut, LPSTR lpstr) {

    /*
     *   Put buffering around the NLS function that does all this stuff.
     */

    int     cchIn;             /* Number of input chars */


    cchIn = strlen( lpstr ) + 1;

    MultiByteToWideChar( CP_ACP, 0, lpstr, cchIn, pWCHOut, cchIn );


    return  pWCHOut;
}

/*************************** Function Header *****************************
 * FontInfoToIFIMetric
 *      Convert the Win 3.1 format PFM data to NT's IFIMETRICS.  This is
 *      typically done before the minidrivers are built,  so that they
 *      can include IFIMETRICS, and thus have less work to do at run time.
 *
 * RETURNS:
 *      IFIMETRICS structure,  allocated from heap;  NULL on error
 *
 * HISTORY:
 *  13:58 on Fri 28 May 1993    -by-    Lindsay Harris   [lindsayh]
 *      Goes back a long way,  I am now adding the aliasing code.
 *
 **************************************************************************/

IFIMETRICS  * 
FontInfoToIFIMetric(FONTDAT *pFDat, HANDLE hheap, PWSTR pwstrUniqNm, 
                    char **ppcAliasList) {

    register  IFIMETRICS   *pIFI;

    FWORD  fwdExternalLeading;

    int    cWC;                 /* Number of WCHARS to add */
    int    cbAlloc;             /* Number of bytes to allocate */
    int    iI;                  /* Loop index */
    int    iCount;              /* Number of characters in Win 3.1 font */
    int    cAlias;              /* Number of aliases we have found */

    WCHAR *pwch;                /* For string manipulations */

    WCHAR   awcAttrib[ 256 ];   /* Generate attributes + BYTE -> WCHAR */
    BYTE    abyte[ 256 ];       /* Used (with above) to get wcLastChar etc */



    /*
     *    First step is to determine the length of the WCHAR strings
     *  that are placed at the end of the IFIMETRICS,  since we need
     *  to include these in our storage allocation.
     *
     *    There may also be an alias list.  If so, we need to include
     *  that in our calculation.   We have a NULL terminated array
     *  of pointers to the aliases,  one of which is most likely the
     *  name in the Win 3.1 format data.
     */


    cWC = 0;
    cAlias = 0;                /* No aliases is the default */

    if( ppcAliasList )
    {
        /*  There are aliases - count them and determine their size  */

        char   *pc;

        iI = 0;
        while( pc = ppcAliasList[ iI ] )
        {
            if( strcmp( pc, (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace ) )
            {
                /*   Not a match,  so add this one in too!  */

                cWC += strlen( pc ) + 1;            /* Terminating NUL */
                ++cAlias;
            }
            ++iI;
        }

        ++cWC;             /* There is an extra NUL to terminate the list */

    }


    cWC +=  3 * strlen( (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */

    /*
     *   Produce the desired attributes: Italic, Bold, Light etc.
     * This is largely guesswork,  and there should be a better method.
     */


    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';               /* Write out an empty string */

    if( pFDat->PFMH.dfItalic )
        wcscat( awcAttrib, L" Italic" );

    if( pFDat->PFMH.dfWeight >= 700 )
        wcscat( awcAttrib, L" Bold" );
    else
    {
        if( pFDat->PFMH.dfWeight < 200 )
            wcscat( awcAttrib, L" Light" );
    }

    /*
     *   The attribute string appears in 3 entries of IFIMETRICS,  so
     * calculate how much storage this will take.  NOTE THAT THE LEADING
     * CHAR IN awcAttrib is NOT placed in the style name field,  so we
     * subtract one in the following formula to account for this.
     */

    if( awcAttrib[ 0 ] )
        cWC += 3 * wcslen( awcAttrib ) - 1;

    cWC += wcslen( pwstrUniqNm ) + 1;   /* SHOULD BE PRINTER NAME */
    cWC += 4;                           /* Terminating nulls */

    cbAlloc = sizeof( IFIMETRICS ) + sizeof( WCHAR ) * cWC;

    pIFI = (IFIMETRICS *)HeapAlloc( hheap, 0, cbAlloc );
// raid 43536 prefix
	if (pIFI == NULL){
		return FALSE;
	}

    ZeroMemory( pIFI, cbAlloc );               /* In case we miss something */

    pIFI->cjThis = cbAlloc;                    /* Everything */

    pIFI->cjIfiExtra = 0;   //  Correct for all pre 4.0

    /*   The family name:  straight from the FaceName - no choice?? */

    pwch = (WCHAR *)(pIFI + 1);         /* At the end of the structure */
    pIFI->dpwszFamilyName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);

    strcpy2WChar( pwch, (LPSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */
    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */

    /*
     *   Append the alias list to the end of this,  if there is an alias list.
     */

    if( cAlias )
    {
        /*  Found some aliases - add them on.   */

        char   *pc;

        cAlias = 0;
        while( pc = ppcAliasList[ cAlias ] )
        {
            if( strcmp( pc, (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace ) )
            {
                /*   Not a match,  so add this one in too!  */

                strcpy2WChar( pwch, pc );
                pwch += wcslen( pwch ) + 1;         /* Next slot to fill */
            }
            ++cAlias;
        }

        /*
         *   The list is terminated with a double NUL.
         */

        *pwch++ = L'\0';
    }

    /*   Now the face name:  we add bold, italic etc to family name */

    pIFI->dpwszFaceName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);

    strcpy2WChar( pwch, (LPSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */
    wcscat( pwch, awcAttrib );


    /*   Now the unique name - well, sort of, anyway */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszUniqueName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);

    wcscpy( pwch, pwstrUniqNm );        /* Append printer name for uniqueness */
    wcscat( pwch, L" " );
    wcscat( pwch, (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName) );

    /*  Onto the attributes only component */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszStyleName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);
    wcscat( pwch, &awcAttrib[ 1 ] );


#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "Rasdd!pfm2ifi: STACK CORRUPTED BY awcAttrib" );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;
    }


    if( ((BYTE *)(pwch + wcslen( pwch ) + 1)) > ((BYTE *)pIFI + cbAlloc) )
    {
        DbgPrint( "Rasdd!pfm2ifi: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwch + wcslen( pwch ) + 1)),
                ((BYTE *)pIFI + cbAlloc) );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;

    }
#endif

    pIFI->dpFontSim   = 0;
    {
        //int i;

        pIFI->lEmbedId     = 0;
        pIFI->lItalicAngle = 0;
        pIFI->lCharBias    = 0;
        /*for (i=0;i<IFI_RESERVED;i++)
            pIFI->alReserved[i] = 0;*/
        pIFI->dpCharSets=0;
    }
    pIFI->jWinCharSet = (BYTE)pFDat->PFMH.dfCharSet;


    if( pFDat->PFMH.dfPixWidth )
    {
        pIFI->jWinPitchAndFamily |= FIXED_PITCH;
        pIFI->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);
    }
    else
        pIFI->jWinPitchAndFamily |= VARIABLE_PITCH;


    pIFI->jWinPitchAndFamily |= (((BYTE) pFDat->PFMH.dfPitchAndFamily) & 0xf0);

    pIFI->usWinWeight = (USHORT)pFDat->PFMH.dfWeight;

//
// IFIMETRICS::flInfo
//
    pIFI->flInfo |=
        FM_INFO_TECH_BITMAP    |
        FM_INFO_1BPP           |
        FM_INFO_INTEGER_WIDTH  |
        FM_INFO_NOT_CONTIGUOUS |
        FM_INFO_RIGHT_HANDED;

    /*  Set the alias bit,  if we have added an alias!  */

    if( cAlias )
        pIFI->flInfo |= FM_INFO_FAMILY_EQUIV;


    /*
     *    A scalable font?  This happens when there is EXTTEXTMETRIC data,
     *  and that data has a min size different to the max size.
     */

    if( pFDat->pETM && (pFDat->pETM->emMinScale != pFDat->pETM->emMaxScale) )
    {
       pIFI->flInfo        |= FM_INFO_ISOTROPIC_SCALING_ONLY;
       pIFI->fwdUnitsPerEm  = pFDat->pETM->emMasterUnits;
    }
    else
    {
        pIFI->fwdUnitsPerEm =
            (FWORD) (pFDat->PFMH.dfPixHeight - pFDat->PFMH.dfInternalLeading);
    }

    pIFI->fsSelection =
        ((pFDat->PFMH.dfItalic            ) ? FM_SEL_ITALIC     : 0)    |
        ((pFDat->PFMH.dfUnderline         ) ? FM_SEL_UNDERSCORE : 0)    |
        ((pFDat->PFMH.dfStrikeOut         ) ? FM_SEL_STRIKEOUT  : 0)    |
        ((pFDat->PFMH.dfWeight >= FW_BOLD ) ? FM_SEL_BOLD       : 0) ;

    pIFI->fsType        = FM_NO_EMBEDDING;
    pIFI->fwdLowestPPEm = 1;


    /*
     * Calculate fwdWinAscender, fwdWinDescender, fwdAveCharWidth, and
     * fwdMaxCharInc assuming a bitmap where 1 font unit equals one
     * pixel unit
     */

    pIFI->fwdWinAscender = (FWORD)pFDat->PFMH.dfAscent;

    pIFI->fwdWinDescender =
        (FWORD)pFDat->PFMH.dfPixHeight - pIFI->fwdWinAscender;

    pIFI->fwdMaxCharInc   = (FWORD)pFDat->PFMH.dfMaxWidth;
    pIFI->fwdAveCharWidth = (FWORD)pFDat->PFMH.dfAvgWidth;

    fwdExternalLeading = (FWORD)pFDat->PFMH.dfExternalLeading;

//
// If the font was scalable, then the answers must be scaled up
// !!! HELP HELP HELP - if a font is scalable in this sense, then
//     does it support arbitrary transforms? [kirko]
//

    if( pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
    {
        /*
         *    This is a scalable font:  because there is Extended Text Metric
         *  information available,  and this says that the min and max
         *  scale sizes are different:  thus it is scalable! This test is
         *  lifted directly from the Win 3.1 driver.
         */

        int iMU,  iRel;            /* Adjustment factors */

        iMU  = pFDat->pETM->emMasterUnits;
        iRel = pFDat->PFMH.dfPixHeight;

        pIFI->fwdWinAscender = (pIFI->fwdWinAscender * iMU) / iRel;

        pIFI->fwdWinDescender = (pIFI->fwdWinDescender * iMU) / iRel;

        pIFI->fwdMaxCharInc = (pIFI->fwdMaxCharInc * iMU) / iRel;

        pIFI->fwdAveCharWidth = (pIFI->fwdAveCharWidth * iMU) / iRel;

        fwdExternalLeading = (fwdExternalLeading * iMU) / iRel;
    }

    pIFI->fwdMacAscender =    pIFI->fwdWinAscender;
    pIFI->fwdMacDescender = - pIFI->fwdWinDescender;

    pIFI->fwdMacLineGap   =  fwdExternalLeading;

    pIFI->fwdTypoAscender  = pIFI->fwdMacAscender;
    pIFI->fwdTypoDescender = pIFI->fwdMacDescender;
    pIFI->fwdTypoLineGap   = pIFI->fwdMacLineGap;

    if( pFDat->pETM )
    {
        /*
         *    Zero is a legitimate default for these.  If 0, gdisrv
         *  chooses some default values.
         */
        pIFI->fwdCapHeight = pFDat->pETM->emCapHeight;
        pIFI->fwdXHeight = pFDat->pETM->emXHeight;

        pIFI->fwdSubscriptYSize = pFDat->pETM->emSubScriptSize;
        pIFI->fwdSubscriptYOffset = pFDat->pETM->emSubScript;

        pIFI->fwdSuperscriptYSize = pFDat->pETM->emSuperScriptSize;
        pIFI->fwdSuperscriptYOffset = pFDat->pETM->emSuperScript;

        pIFI->fwdUnderscoreSize = pFDat->pETM->emUnderlineWidth;
        pIFI->fwdUnderscorePosition = pFDat->pETM->emUnderlineOffset;

        pIFI->fwdStrikeoutSize = pFDat->pETM->emStrikeOutWidth;
        pIFI->fwdStrikeoutPosition = pFDat->pETM->emStrikeOutOffset;

    }
    else
    {
        /*  No additional information, so do some calculations  */
        pIFI->fwdSubscriptYSize = pIFI->fwdWinAscender/4;
        pIFI->fwdSubscriptYOffset = -(pIFI->fwdWinAscender/4);

        pIFI->fwdSuperscriptYSize = pIFI->fwdWinAscender/4;
        pIFI->fwdSuperscriptYOffset = (3 * pIFI->fwdWinAscender)/4;

        pIFI->fwdUnderscoreSize = pIFI->fwdWinAscender / 12;
        if( pIFI->fwdUnderscoreSize < 1 )
            pIFI->fwdUnderscoreSize = 1;

        pIFI->fwdUnderscorePosition = -pFDat->DI.sUnderLinePos;

        pIFI->fwdStrikeoutSize     = pIFI->fwdUnderscoreSize;

        pIFI->fwdStrikeoutPosition = (FWORD)pFDat->DI.sStrikeThruPos;
        if( pIFI->fwdStrikeoutPosition  < 1 )
            pIFI->fwdStrikeoutPosition = (pIFI->fwdWinAscender + 2) / 3;
    }

    pIFI->fwdSubscriptXSize = pIFI->fwdAveCharWidth/4;
    pIFI->fwdSubscriptXOffset =  (3 * pIFI->fwdAveCharWidth)/4;

    pIFI->fwdSuperscriptXSize = pIFI->fwdAveCharWidth/4;
    pIFI->fwdSuperscriptXOffset = (3 * pIFI->fwdAveCharWidth)/4;



    pIFI->chFirstChar = pFDat->PFMH.dfFirstChar;
    pIFI->chLastChar  = pFDat->PFMH.dfLastChar;

    /*
     *   We now do the conversion of these to Unicode.  We presume the
     * input is in the ANSI code page,  and call the NLS converion
     * functions to generate proper Unicode values.
     */

    iCount = pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 1;

    for( iI = 0; iI < iCount; ++iI )
        abyte[ iI ] = iI + pFDat->PFMH.dfFirstChar;

    MultiByteToWideChar( CP_ACP, 0, (LPCSTR) abyte, iCount, awcAttrib, iCount );

    /*
     *   Now fill in the IFIMETRICS WCHAR fields.
     */

    pIFI->wcFirstChar = 0xffff;
    pIFI->wcLastChar = 0;

    /*   Look for the first and last  */
    for( iI = 0; iI < iCount; ++iI )
    {
        if( pIFI->wcFirstChar > awcAttrib[ iI ] )
            pIFI->wcFirstChar = awcAttrib[ iI ];

        if( pIFI->wcLastChar < awcAttrib[ iI ] )
            pIFI->wcLastChar = awcAttrib[ iI ];

    }

    pIFI->wcDefaultChar = awcAttrib[ pFDat->PFMH.dfDefaultChar ];
    pIFI->wcBreakChar = awcAttrib[ pFDat->PFMH.dfBreakChar ];

    pIFI->chDefaultChar = pFDat->PFMH.dfDefaultChar + pFDat->PFMH.dfFirstChar;
    pIFI->chBreakChar   = pFDat->PFMH.dfBreakChar   + pFDat->PFMH.dfFirstChar;


    if( pFDat->PFMH.dfItalic )
    {
    //
    // tan (17.5 degrees) = .3153
    //
        pIFI->ptlCaret.x      = 3153;
        pIFI->ptlCaret.y      = 10000;
    }
    else
    {
        pIFI->ptlCaret.x      = 0;
        pIFI->ptlCaret.y      = 1;
    }

    pIFI->ptlBaseline.x = 1;
    pIFI->ptlBaseline.y = 0;

    pIFI->ptlAspect.x =  pFDat->PFMH.dfHorizRes;
    pIFI->ptlAspect.y =  pFDat->PFMH.dfVertRes;

    pIFI->rclFontBox.left   = 0;
    pIFI->rclFontBox.top    =   (LONG) pIFI->fwdWinAscender;
    pIFI->rclFontBox.right  =   (LONG) pIFI->fwdMaxCharInc;
    pIFI->rclFontBox.bottom = - (LONG) pIFI->fwdWinDescender;

    pIFI->achVendId[0] = 'U';
    pIFI->achVendId[1] = 'n';
    pIFI->achVendId[2] = 'k';
    pIFI->achVendId[3] = 'n';

    pIFI->cKerningPairs = 0;

    pIFI->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    pIFI->panose.bFamilyType      = PAN_ANY;
    pIFI->panose.bSerifStyle      = PAN_ANY;
    if(pFDat->PFMH.dfWeight >= FW_BOLD)
    {
        pIFI->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else if (pFDat->PFMH.dfWeight > FW_EXTRALIGHT)
    {
        pIFI->panose.bWeight = PAN_WEIGHT_MEDIUM;
    }
    else
    {
        pIFI->panose.bWeight = PAN_WEIGHT_LIGHT;
    }
    pIFI->panose.bProportion      = PAN_ANY;
    pIFI->panose.bContrast        = PAN_ANY;
    pIFI->panose.bStrokeVariation = PAN_ANY;
    pIFI->panose.bArmStyle        = PAN_ANY;
    pIFI->panose.bLetterform      = PAN_ANY;
    pIFI->panose.bMidline         = PAN_ANY;
    pIFI->panose.bXHeight         = PAN_ANY;

    return   pIFI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nproject.cpp ===
// NewTProject.cpp : implementation file
//

#include "stdafx.h"
#include "Minidev.h"

#include "utility.h"
#include "projnode.h"
#include "gpdfile.h"

#include <gpdparse.h>
#include "comctrls.h"
#include "newproj.h"

#include "newcomp.h"
#include "nconvert.h"
#include "nproject.h"

//#include "nprjwiz.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewProject dialog

TCHAR *TName[] =  {_T("PCL 3"),_T("PCL 5e"),_T("HPGL 2"),_T("PCL 6"),_T("ESC / 2") } ;
DWORD TID[] = {100,101,102,103,104 } ;
TCHAR *TFileName[] = {_T("pcl3.gpd"),_T("pcl5e.gpd"),_T("hpgl2.gpd"),_T("pcl6.gpd"),_T("escp2.gpd")} ;

TCHAR *AddedGpd[] = { _T("pjl.gpd"),_T("p6disp.gpd"),_T("pclxl.gpd"),_T("p6font.gpd") } ;
DWORD AddID [] = {110,111,112,113} ;

//IMPLEMENT_DYNCREATE(CNewProject, CPropertyPage)

IMPLEMENT_SERIAL(CNewProject, CPropertyPage, 0) 


CNewProject::CNewProject()
	: CPropertyPage(CNewProject::IDD)
{
	//{{AFX_DATA_INIT(CNewProject)
	m_csPrjname = _T("");
	m_csPrjpath = _T("");
	m_cstname = _T("");
	m_cstpath = _T("");
	//}}AFX_DATA_INIT
	unsigned uTemplate = sizeof(TName)/sizeof(TName[0]) ;

	// this routine run when this called for the first time in MDT program
	// project wizard are serialized. 
	if (!m_csaTlst.GetSize() ){  
		for(unsigned i = 0 ; i < uTemplate ; i ++  )
			m_csaTlst.Add(TName[i]) ; 

		CWinApp* pApp = AfxGetApp();
		CString cshelppath = pApp->m_pszHelpFilePath;
		CString csAdded = cshelppath.Left(cshelppath.ReverseFind('\\') ) ;
		csAdded += _T("\\Template\\*.gpd") ;

		CFileFind cff; // BUG_BUG :: code clean below.
		WIN32_FIND_DATA fd;

		HANDLE hFile = FindFirstFile(csAdded,&fd ) ;
		if (INVALID_HANDLE_VALUE != hFile  ) {
			csAdded = csAdded.Left(csAdded.ReverseFind('\\') + 1) ;
			CString cstname = fd.cFileName ;
			cstname = cstname.Left(cstname.ReverseFind(_T('.') )  ) ;
			m_csaTlst.Add(cstname ) ;
			m_cmstsTemplate[m_csaTlst[i++]] = csAdded + fd.cFileName ;
	

			while (FindNextFile(hFile,&fd) ) {
				CString cstname = fd.cFileName ;
				cstname = cstname.Left(cstname.ReverseFind(_T('.') )  ) ;
				m_csaTlst.Add(cstname ) ;
				m_cmstsTemplate[m_csaTlst[i++]] = csAdded + fd.cFileName ;
			}
			
		} ;
	} ;
} ;


void CNewProject::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewProject)
	DDX_Control(pDX, IDC_DirBrowser, m_cbLocprj);
	DDX_Control(pDX, IDC_CHECK_ADD, m_cbAddT);
	DDX_Control(pDX,IDC_LIST_ProjectTemplate,m_clcTemplate) ;
	DDX_Text(pDX, IDC_EDIT_NPRJNAME, m_csPrjname);
	DDX_Text(pDX, IDC_EDIT_NPRJLOC, m_csPrjpath);
	DDX_Text(pDX, IDC_EDIT_AddTName, m_cstname);
	DDX_Text(pDX, IDC_EDIT_AddTPath, m_cstpath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewProject, CPropertyPage)
	//{{AFX_MSG_MAP(CNewProject)
	ON_BN_CLICKED(IDC_Search_PRJ, OnGpdBrowser)
	ON_BN_CLICKED(IDC_DirBrowser, OnDirBrowser)
	ON_BN_CLICKED(IDC_CHECK_ADD, OnCheckAdd)
	ON_BN_CLICKED(IDC_AddTemplate, OnAddTemplate)
	ON_EN_CHANGE(IDC_EDIT_NPRJNAME, OnChangeEditPrjName)
	ON_EN_CHANGE(IDC_EDIT_NPRJLOC, OnChangeEditPrjLoc)
	ON_NOTIFY(NM_CLICK, IDC_LIST_ProjectTemplate, OnClickListTemplate)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_ProjectTemplate, OnDblclkListTemplate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProject message handlers

/********************************************************************************
void CNewProject::OnGpdBrowser() 
Look for template file browser (*.gpd)
*********************************************************************************/

void CNewProject::OnGpdBrowser() 
{
	UpdateData() ;
	CString csFilter = _T("Template file(*.gpd)|*.gpd||") ;
	CString csExtension = _T(".GPD") ;
	CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST ,csFilter);
	
	if  (cfd.DoModal() == IDOK) {
        m_cstpath = cfd.GetPathName() ;
		UpdateData(FALSE) ;	
	} ;
	
	
}


/********************************************************************************
void CNewProject::OnDirBrowser()
1. locate the directory of project : under this \ufm, \gtt will be created .
2.

*********************************************************************************/

void CNewProject::OnDirBrowser()
{

/*
	BROWSEINFO  brif = {0} ;

    LPITEMIDLIST pidlRoot = NULL;
	LPITEMIDLIST pidlSelected = NULL;
	LPMALLOC pMalloc = NULL ;
	char * pszPath = new char[256] ;

	SHGetMalloc(&pMalloc) ;

//	SHGetSpecialFolderLocation(m_hWnd,CSIDL_RECENT,&pidlRoot) ;

	brif.hwndOwner = m_hWnd ;
	brif.pidlRoot = pidlRoot ;
	brif.pszDisplayName  = new char[256] ;
	brif.lpszTitle = _T("Set Directory") ;
	brif.ulFlags = 0 ;
	brif.lpfn = NULL ;
	

	pidlSelected = SHBrowseForFolder(&brif) ;

	SHGetPathFromIDList(pidlSelected,pszPath) ;
*/
	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
//    char    acidir[_MAX_PATH] ; // Initial directory is built here
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    strcpy(acpath, _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	ofn.lpstrInitialDir = NULL ; //  in parent dialog box
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY /*| OFN_ENABLEHOOK */| OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook = NULL ;// BrowseDlgProc ;

    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    
	m_csPrjpath = (LPCTSTR) acpath ;
	m_csoldPrjpath = m_csPrjpath ;
	if ( m_csPrjname.GetLength() != 0)
		m_csPrjpath += _T("\\") + m_csPrjname ;

	UpdateData(FALSE) ;
/*	if (pidlSelected)
		pMalloc->Free(pidlSelected) ;

	pMalloc->Release() ;
*/


}

/********************************************************************************
BOOL CNewProject::OnInitDialog()
ToDo : load the template gpd file and show them to list control box, also disable
add template relevant control
*********************************************************************************/

BOOL CNewProject::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// get PropertySheet pointer
	m_pcps = DYNAMIC_DOWNCAST(CPropertySheet,GetOwner() ) ;

	// uncheck the check box,
	m_cbAddT.SetCheck(false) ;
	
	// disable Add Template Edit box
	TCHAR cBuf[256];

	GetCurrentDirectory(256,cBuf) ;
	m_csPrjpath = cBuf ;
	m_csoldPrjpath = m_csPrjpath ;
	UpdateData(FALSE);

	// initialize the tempalte list with its icon
	CImageList* pcil = new CImageList ;

	pcil->Create(16,16,ILC_COLOR4,4,1 );

	CBitmap cb;
	   
	cb.LoadBitmap(IDB_SMALLGLYPH);
	for (unsigned j =0; j< (unsigned)m_csaTlst.GetSize(); j++)	{
		pcil->Add(&cb,RGB(0,0,0) );
	}
    cb.DeleteObject() ;
	
	m_clcTemplate.SetImageList(pcil,LVSIL_SMALL);

	LV_ITEM lvi ;
	for(unsigned i = 0 ; i < (unsigned)m_csaTlst.GetSize() ; i ++  ) {
		 
		lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM ;
		lvi.iItem = i ;
		lvi.iSubItem = 0 ;
		lvi.pszText = m_csaTlst[i].GetBuffer(m_csaTlst[i].GetLength() ) ;
		lvi.iImage = i ;
		lvi.lParam = (UINT_PTR)i ;

		m_clcTemplate.InsertItem(&lvi) ;
	
	}
	
	// disable unused button
	GetDlgItem(IDC_EDIT_AddTName)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_EDIT_AddTPath)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_AddTemplate)->EnableWindow(FALSE) ;
		
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/********************************************************************************
BOOL CNewProject::OnSetActive() 

*********************************************************************************/

BOOL CNewProject::OnSetActive() 
{
	SetButton() ;
	
//	UpdateData(FALSE) ;
	
	return CPropertyPage::OnSetActive();
}

/********************************************************************************
CNewProject::OnCheckAdd() 
when user check the add template box, it will enable other control


**********************************************************************************/
void CNewProject::OnCheckAdd() 
{
	CEdit ceTName, ceTPath ;

	if ( m_cbAddT.GetCheck() )  {// check the button
		GetDlgItem(IDC_EDIT_AddTName)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_EDIT_AddTPath)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_AddTemplate)->EnableWindow(TRUE) ;
			
	} 
	else {
		GetDlgItem(IDC_EDIT_AddTName)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_EDIT_AddTPath)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_AddTemplate)->EnableWindow(FALSE) ;
	} ;


} ; 



/********************************************************************************
	void CNewProject::OnAddTemplate() 
1. Add template name to Template list box.
2. Save template file and its file to mapping variable



********************************************************************************/
void CNewProject::OnAddTemplate() 
{
	UpdateData() ;
	// check the added template nane is right ?
	BOOL bname = FALSE ;
	for ( unsigned i = 0 ; i < (unsigned) m_csaTlst.GetSize() ; i++ ) {
		CString cstmp = m_csaTlst[i] ;
		if (!cstmp.CompareNoCase(m_cstname) ){
			bname = TRUE ;
			break;	
		}
	} ;

	if (m_cstname.GetLength() == 0 || m_cstpath.GetLength() == 0 || bname) {
		CString csErr ;
		csErr.LoadString(IDS_FailCreateTemplate) ;
	
	    AfxMessageBox(csErr,MB_ICONEXCLAMATION) ;
		return ;
	} ;
	
	// add the template name to its CStrinArray name list and list control.
	m_csaTlst.Add(m_cstname) ;
	i = PtrToInt(PVOID(m_csaTlst.GetSize()) ) ; 
	m_clcTemplate.InsertItem(i-1, m_csaTlst[i-1] ) ;
	
	
	// copy the template file into the template directory, which is under MDT file
	// directory\template
	// Get the mdt dir.
	CWinApp* pApp = AfxGetApp();
	CString csRoot = pApp->m_pszHelpFilePath;
	csRoot = csRoot.Left(csRoot.ReverseFind('\\') ) ;
	csRoot += _T("\\Template") ;

	// Create the directory under MDT help file directory if it does not exist
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	WIN32_FIND_DATA wfd32 ;
	HANDLE hDir = FindFirstFile(csRoot,&wfd32) ;
	if (hDir == INVALID_HANDLE_VALUE) {
		if (!CreateDirectory(csRoot,&st) ) {
			CString csErr ;
			csErr.LoadString(IDS_FailCreateTempDir) ;
			AfxMessageBox(csErr) ;
			return ;
		} 
	} ;
	// copy the file, target file name should be template file name for convernience 
	// when loading the template file.
	CString csdst = csRoot + _T('\\') +  m_cstname + _T(".GPD") ;
	if (!CopyFile(m_cstpath,csdst , TRUE)) {
			CString csmsg ;
			csmsg.Format(IDS_AddCopyFailed, m_cstpath,
						 csdst.Left(csdst.GetLength() - 1)) ;
			csmsg += csdst ;
			AfxMessageBox(csmsg) ;
			return ;
	};

	// add to the collection as its template name and its path
	m_cmstsTemplate[m_cstname] = (LPCTSTR)csdst.GetBuffer(256) ;

	
	CString csmsg ;
	csmsg.Format(IDS_TemplateCreated, csRoot ) ;
	AfxMessageBox(csmsg) ;

}



/***************************************************************************************
	void CNewProject::OnChangeEditPrjName() 

1.  As user write project name, same name will be written to prject path simultaneously.


****************************************************************************************/
void CNewProject::OnChangeEditPrjName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	

	
	UpdateData() ;
	
	SetButton() ;

	m_csPrjpath = m_csoldPrjpath + _T("\\") + m_csPrjname ;
	
	UpdateData(FALSE) ;

}

/***************************************************************************************
void CNewProject::OnChangeEditPrjLoc() 


****************************************************************************************/
void CNewProject::OnChangeEditPrjLoc() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	m_csoldPrjpath = m_csPrjpath ;

	
}



/***************************************************************************************
void CNewProject::OnClickListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 


****************************************************************************************/
void CNewProject::OnClickListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 
{
	
	SetButton() ;
	*pResult = 0;
}


/***************************************************************************************
void CNewProject::OnDblclkListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 
ToDo ; Do nothing when no project name exist

****************************************************************************************/
void CNewProject::OnDblclkListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 
{
	POSITION pos = m_clcTemplate.GetFirstSelectedItemPosition();
	
	// template and project name has to be selected or exist
	if ( m_csPrjname.GetLength() != 0 && pos )
		m_pcps->PressButton(PSBTN_OK) ;
    else
		AfxMessageBox (_T("No Project name exist or template is not selected"), MB_ICONINFORMATION) ;
	*pResult = 0;
}


/***************************************************************************************
void CNewProject::SetButton()


****************************************************************************************/
void CNewProject::SetButton()
{
	POSITION pos = m_clcTemplate.GetFirstSelectedItemPosition();
	
	// template and project name has to be selected or exist
	if ( m_csPrjname.GetLength() == 0 || !pos )
		m_pcps->GetDlgItem(IDOK)->EnableWindow(FALSE) ;
	else
		m_pcps->GetDlgItem(IDOK)->EnableWindow() ;

}


/***************************************************************************************
void CNewProject::Serialize(CArchive& car) 

****************************************************************************************/
void CNewProject::Serialize(CArchive& car) 
{
	CPropertyPage::Serialize(car) ;
	if (car.IsStoring())
	{	
		
	}
	else
	{	
		
	}
}

/*****************************************************************************************
void CNewProject::OnOK() 
ToDo : Creat poject directory as well as creat temp file for resource gpd file / get path 
of custom gpd file


******************************************************************************************/
void CNewProject::OnOK() 
{
		// TODO: Add your specialized code here and/or call the base class
	UpdateData() ;		// copy all edit value to its member data.

	POSITION pos = m_clcTemplate.GetFirstSelectedItemPosition();
	
	int iSelected = m_clcTemplate.GetNextSelectedItem(pos );
	
	if (iSelected < sizeof(TName)/sizeof(TName[0]) ) { // for using template from the resource
	
		CString cstmp = AfxGetApp()->m_pszHelpFilePath ;
		cstmp = cstmp.Left(cstmp.ReverseFind(_T('\\')) + 1 )  ;
		cstmp += _T("tmp.gpd")   ;
		CFile cf(cstmp,CFile::modeCreate | CFile::modeWrite ) ;
		
		HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(TID[iSelected]),
			MAKEINTRESOURCE(IDR_NEWPROJECT));
			

		if (!hrsrc) {
			CString csError ; 
			csError.LoadString(IDS_ResourceError) ;
			AfxMessageBox(csError,MB_ICONEXCLAMATION) ;		
			return ;
		} ;

		HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
		if  (!hgMap)
			return ;  //  This should never happen!
	
		int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
		LPVOID lpv = LockResource(hgMap);
		
		cf.Write(lpv,nsize) ;
		m_csGPDpath = cf.GetFilePath() ;

		cf.Close() ;
			
	}
	else {
		m_csGPDpath = (LPCTSTR)m_cmstsTemplate[m_csaTlst[iSelected]] ;
	}

	// create directory
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	if (!CreateDirectory(m_csPrjpath.GetBuffer(256),&st) ) {
		DWORD dwError = GetLastError() ;
		CString csmsg ;
		if ( dwError == ERROR_ALREADY_EXISTS)
			csmsg.LoadString(IDS_FileAlreadExist) ;
		else
			csmsg.LoadString(IDS_FileCreateDirectory) ;
		AfxMessageBox(csmsg) ;
		return ;
	}
	
	CString csTmp = m_clcTemplate.GetItemText(iSelected,0);
	
	//Check selected template if it required added file (PCL 6 need e more resource files)
	// if so, Call AddGpds() for creating these files
	if(!csTmp.Compare(_T("PCL 6") )&& !AddGpds(csTmp) ){
		CString csError ; 
		csError.LoadString(IDS_ResourceError) ;
		AfxMessageBox(csError,MB_ICONEXCLAMATION) ;		
		return ;
	}

	m_pcps->ShowWindow(SW_HIDE) ;

	CNewProjectWizard cntp (_T("New Project Wizard"), this ) ;
 
	if (cntp.DoModal() == IDCANCEL)
		m_pcps->ShowWindow(SW_RESTORE) ;		
	else CPropertyPage::OnOK();
}


/***************************************************************************************
bool CNewProject::AddGpds() 

Do : copy required gpd filss according to a selected template. for instance, PCL6 need pjl.gpd,
p6disp.gpd, pclxl.gpd files.

****************************************************************************************/


bool CNewProject::AddGpds(CString& csTemplate)
{

	for (int i = 0 ; i < sizeof(AddID) / sizeof(AddID[0]) ; i ++ ) {
		CString cstmp = m_csPrjpath + _T('\\') + AddedGpd[i] ;
		
		CFile cf(cstmp,CFile::modeCreate | CFile::modeWrite ) ;
			
		HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(AddID[i]),
			MAKEINTRESOURCE(IDR_NEWPROJECT));
			

		if (!hrsrc) {
			CString csError ; 
			csError.LoadString(IDS_ResourceError) ;
			AfxMessageBox(csError,MB_ICONEXCLAMATION) ;		
			return false;
		} ;

		HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
		if  (!hgMap) 
			return false ;  //  This should never happen!

		int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
		LPVOID lpv = LockResource(hgMap);
		
		cf.Write(lpv,nsize) ;
		cf.Close() ;
	}
	return true ;
}






/////////////////////////////////////////////////////////////////////////////
// CNewPrjWResource dialog

IMPLEMENT_DYNCREATE(CNewPrjWResource, CPropertyPage)

CNewPrjWResource::CNewPrjWResource()
	: CPropertyPage(CNewPrjWResource::IDD)
{
	//{{AFX_DATA_INIT(CNewPrjWResource)
	m_csUFMpath = _T("");
	m_csGTTpath = _T("");
	m_csGpdFileName = _T("");
	m_csModelName = _T("");
	m_csRCName = _T("");
	//}}AFX_DATA_INIT
//	m_csaUFMFiles.SetSize(10) ;
//	m_csaGTTFiles.SetSize(10) ; 
}


void CNewPrjWResource::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPrjWResource)
	DDX_Control(pDX, IDC_CHECK_FONTS, m_cbCheckFonts);
	DDX_Text(pDX, IDC_UFM_PATH, m_csUFMpath);
	DDX_Text(pDX, IDC_GTT_PATH, m_csGTTpath);
	DDX_Text(pDX, IDC_EDIT_GPD, m_csGpdFileName);
	DDX_Text(pDX, IDC_EDIT_MODEL, m_csModelName);
	DDX_Text(pDX, IDC_EDIT_RESOUREC, m_csRCName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewPrjWResource, CPropertyPage)
	//{{AFX_MSG_MAP(CNewPrjWResource)
	ON_BN_CLICKED(IDC_SerchUFM, OnSerchUFM)
	ON_BN_CLICKED(IDC_SearchGTT, OnSearchGTT)
	ON_BN_CLICKED(IDC_CHECK_FONTS, OnCheckFonts)
	ON_EN_CHANGE(IDC_EDIT_GPD, OnChangeEditGpd)
	ON_EN_CHANGE(IDC_EDIT_MODEL, OnChangeEditModel)
	ON_EN_CHANGE(IDC_EDIT_RESOUREC, OnChangeEditResourec)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************************************************************
void CNewPrjWResource::OnSerchUFM() 
Search the ufm 

*****************************************************************************************/

void CNewPrjWResource::OnSerchUFM() 
{
	UpdateData() ;
	CString csFilter( _T("*.ufm|*.ufm||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".ufm"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[8192];
	memset(cfd.m_ofn.lpstrFile,0,8192);
	cfd.m_ofn.nMaxFile = 8192;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {
		CString cspath = cfd.GetNextPathName(pos) ;
		m_csaUFMFiles.Add(cspath) ;
	}
	m_csUFMpath = m_csaUFMFiles[0] ;

	SetCurrentDirectory(m_csUFMpath.Left(m_csUFMpath.ReverseFind(_T('\\') ) ) ) ;
	
	UpdateData(FALSE) ;
}

/****************************************************************************************
void CNewPrjWResource::OnSearchGTT() 
Search the gtt files
*****************************************************************************************/

void CNewPrjWResource::OnSearchGTT() 
{
	UpdateData() ;  // in order to upgraded edit string value ;

	CString csFilter( _T("*.gtt|*.gtt||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".gtt"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {

		m_csaGTTFiles.Add(cfd.GetNextPathName(pos)) ;
	}
	
	m_csGTTpath = m_csaGTTFiles[0] ;
	SetCurrentDirectory(m_csGTTpath.Left(m_csGTTpath.ReverseFind(_T('\\') ) ) ) ;

	UpdateData(FALSE) ;
}

/////////////////////////////////////////////////////////////////////////////
// CNewPrjWResource message handlers

/***************************************************************************************
BOOL CNewPrjWResource::OnInitDialog() 

mainly disable controls 
*****************************************************************************************/

BOOL CNewPrjWResource::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    // uncheck the check box,
	m_cbCheckFonts.SetCheck(false) ;
	
	// disable Add Template Edit box
	
	GetDlgItem(IDC_UFM_PATH)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_GTT_PATH)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_SerchUFM)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_SearchGTT)->EnableWindow(FALSE) ;
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/****************************************************************************************
void CNewPrjWResource::OnCheckFonts() 

user want to include fonts inside new project, this routin does not mapping the RCID in 
a UFM to specifc GTT. user has to change these rcid value after project creation.
*****************************************************************************************/

void CNewPrjWResource::OnCheckFonts() 
{
	CEdit ceTName, ceTPath ;

	if ( m_cbCheckFonts.GetCheck() )  {// check the button
		GetDlgItem(IDC_UFM_PATH)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_GTT_PATH)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_SerchUFM)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_SearchGTT)->EnableWindow(TRUE) ;
			
	} 
	else {
		GetDlgItem(IDC_UFM_PATH)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_GTT_PATH)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_SerchUFM)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_SearchGTT)->EnableWindow(FALSE) ;
	} ;
	
}


/****************************************************************************************
BOOL CNewPrjWResource::OnSetActive() 

*****************************************************************************************/

BOOL CNewPrjWResource::OnSetActive() 
{
	// change the NEXT to FINISH.
	((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
	((CPropertySheet*)GetOwner())->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	return CPropertyPage::OnSetActive();
}

/****************************************************************************************
BOOL CNewPrjWResource::OnWizardFinish() 
this is workhouse. Creating directory and fils for project & build environment, and copies 
these files.

*****************************************************************************************/

BOOL CNewPrjWResource::OnWizardFinish() 
{
	UpdateData() ;
	m_pcnp = (CNewProject* )(( CNewProjectWizard* )GetParent() )->GetProjectPage() ;
	

	//// copied the resource file to project directory.////
	
	CString csPrjPath, csNewGPDPat, csUFMDir, csGTTDir,csGPDPath ;
	CStringArray csaNewUFMPath,csaNewGTTPath ;
	
	csPrjPath = m_pcnp->m_csPrjpath ;
	csGPDPath = m_pcnp->GetGPDpath() ;

	csUFMDir = csPrjPath + _T("\\UFM") ;
	csGTTDir = csPrjPath + _T("\\GTT") ;
	
	// create ufm, gtt directory
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	
	if (!CreateDirectory(csUFMDir.GetBuffer(256),&st) || 
			!CreateDirectory(csGTTDir.GetBuffer(256),&st) ) {
		
		CString csmsg ;
		csmsg = _T("Fail to creat the resources (ufm, gtt) directory") ;
		AfxMessageBox(csmsg) ;
		return FALSE ;
	}
	
	
	// Copy Resource files to project class 
	// UFM files
	for ( int i = 0 ; i< m_csaUFMFiles.GetSize() ; i++ ) {
		CString csname, cssrc, csdest;

		cssrc = m_csaUFMFiles[i] ;
		csname = cssrc.Mid(cssrc.ReverseFind(_T('\\')) + 1) ;
		csdest=	csUFMDir + _T('\\') + csname ;
		
		if (!CopyFile(cssrc, csdest, TRUE)) {
			CString csmsg ;
			csmsg.Format(IDS_AddCopyFailed, cssrc,
						 csdest.Left(csdest.GetLength() - 1)) ;
			csmsg += csdest ;
			AfxMessageBox(csmsg) ;
			return FALSE ;
		}
		m_csaUFMFiles.SetAt(i,csdest) ;

	}

	// GTT files
	for ( i = 0 ; i< m_csaGTTFiles.GetSize() ; i++ ) {
		CString csname, cssrc, csdest;

		cssrc = m_csaGTTFiles[i] ;
		csname = cssrc.Mid(cssrc.ReverseFind(_T('\\')) + 1) ;
		csdest=	csGTTDir + _T('\\') + csname ;
				
		if (!CopyFile(cssrc, csdest, TRUE)) {
			CString csmsg ;
			csmsg.Format(IDS_AddCopyFailed, cssrc,
						 csdest.Left(csdest.GetLength() - 1)) ;
			csmsg += csdest ;
			AfxMessageBox(csmsg) ;
			return FALSE ;
		}
		m_csaGTTFiles.SetAt(i,csdest) ;
	}

	// GPD files
	CString cssrc, csdest;
	cssrc = csGPDPath;
	if(!m_csGpdFileName.GetLength() )
		m_csGpdFileName = csPrjPath.Mid(csPrjPath.ReverseFind('\\') + 1 );
	csdest = csPrjPath + _T('\\') + m_csGpdFileName + _T(".gpd" ) ;
	if (!CopyFile(cssrc, csdest, TRUE)) {
		CString csmsg ;
		csmsg.Format(IDS_AddCopyFailed, cssrc,
					 csdest.Left(csdest.GetLength() - 1)) ;
		csmsg += csdest ;
		AfxMessageBox(csmsg) ;
		return FALSE ;
	}
	csGPDPath.Delete(0,csGPDPath.GetLength());
	csGPDPath = csdest ;
	
	// Create RCID mapping from pcl5eres.txt and target GPD.
	CreateRCID(csdest) ;

	// Copy Stdnames.gpd ; use established module 
	try {
		CString cssrc, csdest ;
		cssrc = ThisApp().GetAppPath() + _T("stdnames.gpd") ;
		csdest = csPrjPath + _T("\\") + _T("stdnames.gpd") ;
		CopyFile(cssrc, csdest, FALSE) ;
		
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
//      return  FALSE ;
    }



	// Create the RC 
	 
	CString csRC,csSources, csMakefile ;
	if(!m_csRCName.GetLength() )
		m_csRCName = csPrjPath.Mid(csPrjPath.ReverseFind('\\') + 1 );
	csRC = csPrjPath + _T('\\') + m_csRCName + _T(".rc" ) ;
	CFile cfRC(csRC,CFile::modeCreate | CFile::modeWrite ) ;
	cfRC.Close() ;

	// Create the SOURCES files
	csSources = csPrjPath + _T("\\sources") ;
	CFile cf(csSources,CFile::modeCreate | CFile::modeWrite ) ;

	HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(150),
		MAKEINTRESOURCE(IDR_NEWSOURCES));
		

	if (!hrsrc) {
		AfxMessageBox(_T("Fail to create new sources due to insufficient resource, you have to \
			make sources file for the build "), MB_ICONEXCLAMATION ) ;
		
	} ;

	HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
	if  (!hgMap)
		return  FALSE;  //  This should never happen!

	int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
	LPVOID lpv = LockResource(hgMap);
	
	cf.Write(lpv,nsize) ;
	CString cssource = cf.GetFilePath() ;
	cf.Close() ;
	
	
	//We need to copy more gpd file if user select PCL6 template mmm..
	//Get file from the resource 3 files ( pjl.gpd, p6disp.gpd, pclxl.gpd )
	


	//Update the SOURCES file
	CModelData cmd;
	cmd.SetKeywordValue(cssource,_T("TARGETNAME"),m_csRCName,true) ;
	cmd.SetKeywordValue(cssource,_T("SOURCES"),m_csRCName + _T(".rc"),true );
	cmd.SetKeywordValue(cssource,_T("MISCFILES"), m_csGpdFileName + _T(".GPD"),true ) ;
	
	
	// Create the MAKEFILE.
	csMakefile = csPrjPath + _T("\\makefile") ;
	CFile cfMakefile(csMakefile,CFile::modeCreate | CFile::modeWrite ) ;
//  should fill the contents of the makefile
	CString cstemp(_T("!INCLUDE $(NTMAKEENV)\\makefile.def") );
	cfMakefile.Write(cstemp,cstemp.GetLength() ) ;
	cfMakefile.Close() ;


	// Create the DEF file
	CString csDeffile = csPrjPath + _T("\\") + m_csRCName + _T(".def") ;
	CFile cfDeffile(csDeffile,CFile::modeCreate | CFile::modeWrite ) ;
	cstemp.Empty() ;
	cstemp = _T("LIBRARY ") + m_csRCName ;
	cfDeffile.Write(cstemp,cstemp.GetLength() ) ;
	cfDeffile.Close() ;

	


//  Call the Frame of the project workspace
	CMultiDocTemplate* pcmdtWorkspace = ThisApp().WorkspaceTemplate() ;

	CDocument*  pcdWS = pcmdtWorkspace->CreateNewDocument();
    
	CProjectRecord *ppr = DYNAMIC_DOWNCAST(CProjectRecord,pcdWS ) ;
	
	ppr->CreateFromNew(m_csaUFMFiles, m_csaGTTFiles,csGPDPath,m_csModelName,m_csRCName,m_csaRcid) ;

	pcmdtWorkspace-> SetDefaultTitle(pcdWS);
    CFrameWnd*  pcfw = pcmdtWorkspace -> CreateNewFrame(pcdWS, NULL);
    
	if  (!pcfw) 
		return FALSE;
    
	pcmdtWorkspace -> InitialUpdateFrame(pcfw, pcdWS);
	
//	SetCurrentDirectory(csPrjPath ) ;
	return CPropertyPage::OnWizardFinish();
}

/****************************************************************************************
LRESULT CNewPrjWResource::OnWizardBack() 
this lead close all windows inlcuding parent window, because this dialog box created under
OnOK of parent dialog box. need to be updated.

*****************************************************************************************/

LRESULT CNewPrjWResource::OnWizardBack() 
{
	
	return ((CPropertySheet*)GetParent())->PressButton(PSBTN_CANCEL ) ;
//	return CPropertyPage::OnWizardBack();
}

/****************************************************************************************
void CNewPrjWResource::OnChangeEditGpd() 

*****************************************************************************************/

void CNewPrjWResource::OnChangeEditGpd() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	UpdateData() ;
	if(m_csGpdFileName.GetLength() && m_csModelName.GetLength() && m_csRCName.GetLength() )
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_FINISH);
	else
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
}		

/****************************************************************************************
void CNewPrjWResource::OnChangeEditModel() 
all these three value(model name, rc name, gdp file name ) should exist for creating project

*****************************************************************************************/

void CNewPrjWResource::OnChangeEditModel() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	UpdateData() ;
	if(m_csGpdFileName.GetLength() && m_csModelName.GetLength() && m_csRCName.GetLength() )
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_FINISH);
	else
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
}


/****************************************************************************************
void CNewPrjWResource::OnChangeEditResourec() 

*****************************************************************************************/
void CNewPrjWResource::OnChangeEditResourec() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	UpdateData() ;
	if(m_csGpdFileName.GetLength() && m_csModelName.GetLength() && m_csRCName.GetLength() )
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_FINISH);
	else
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
}
/*****************************************************************************************
void CNewPrjWResource::CreateRCID(CString csGPD)
	if (pcl.txt)
		read the pcl.txt
	else
		read from the resource and create pcl.txt under root
	compare (pcl.txt value and rc value in the gpd)
	creating list of existing string and value
******************************************************************************************/

void CNewPrjWResource::CreateRCID(CString csGPD)
{
	// check pcl.txt: 1st, mdt help directory  2nd. load resource file
	
	CString cstable = AfxGetApp()->m_pszHelpFilePath ;
	cstable = cstable.Left(cstable.ReverseFind(_T('\\')) + 1 )  ;

	cstable += _T("pcl.txt") ;

	CFileFind cff ;
	if (! cff.FindFile(cstable) ) {
		// load from the resource files			
		CFile cf(cstable,CFile::modeCreate | CFile::modeWrite ) ;
		
		HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(200),
			MAKEINTRESOURCE(IDR_STRINGTABLE));
			

		if (!hrsrc) {
			AfxMessageBox(_T("Fail to create new project due to insufficient resource"), MB_ICONEXCLAMATION ) ;
			return ;
		} ;

		HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
		if  (!hgMap)
			return ;  //  This should never happen!
	
		int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
		LPVOID lpv = LockResource(hgMap);
		
		cf.Write(lpv,nsize) ;
		cf.Close() ;
	}

	// Get Every rcNameID value from the GPD
	CStringArray csaData;
	
	if(!LoadFile(csGPD,csaData)){	// call global function in minidev.h(which is include for this fucntion)
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csGPD);
		AfxMessageBox(csErr,MB_OK);
		return ;
	}
	
	CDWordArray cdwRcid ;
	CString csline;
	CString csKeyword = _T("rcNameID:") ;
	int offset ;
	for (int i = 0 ; i < csaData.GetSize() ; i ++ ) { 
		csline = csaData[i];
		if(-1 ==(offset=csline.Find(csKeyword)) )
			continue;
		else
		{
			csline = csline.Mid(offset+csKeyword.GetLength());
			int ircid = atoi(csline) ;
			if (ircid)
				cdwRcid.Add(ircid) ;
			
		}
	}

	// Search the pcl.txt for the rcNameID
	csaData.RemoveAll() ;
	if(!LoadFile(cstable,csaData)){
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csGPD);
		AfxMessageBox(csErr,MB_OK);
		return ;
	}

	// save rcid and string to string table array
	CStringTable cstrcid ;
	
	for (i = 0 ; i < csaData.GetSize() ;i ++ ) {
		csline = csaData[i] ;
			
		WORD    wKey = (WORD) atoi(csline);

		if  (!wKey)
			continue  ;  //  0 is not a valid resource number...

		csline = csline.Mid(csline.Find("\""));
		csline = csline.Mid(1, -2 + csline.GetLength());

		cstrcid.Map(wKey, csline);
	}
	
	// save slelected line from pcl.txt after matching pcl.txt data and seleted gpd rcid
	CString cstmp ;
	for ( i = 0 ; i < cdwRcid.GetSize() ; i ++ ) {
		WORD wKey = (WORD) cdwRcid[i] ;

		csline = cstrcid[wKey] ;
		cstmp.Format("%d",wKey) ;
		csline = cstmp + _T("\"") + csline ;
		m_csaRcid.Add(csline ) ;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard


IMPLEMENT_DYNAMIC(CNewProjectWizard, CPropertySheet)

CNewProjectWizard::CNewProjectWizard(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	
}

CNewProjectWizard::CNewProjectWizard(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{

	AddPage(&m_cpwr) ;

	m_pParent = pParentWnd ;
	SetWizardMode() ;
	
}

CNewProjectWizard::~CNewProjectWizard()
{
}


BEGIN_MESSAGE_MAP(CNewProjectWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CNewProjectWizard)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard message handlers


/*************************************************************************************
CPropertyPage* CNewProjectWizard::GetProjectPage()

this is just propertysheet for project wizard, Currently project wizard contain only one
propertypage, but it can be expand to more propertypage so medium properysheet is required
for the future use rather that just us one dialog box

**************************************************************************************/
CPropertyPage* CNewProjectWizard::GetProjectPage()
{
	
	CNewComponent* pcnc = (CNewComponent* ) GetParent();
	return (CPropertyPage*)pcnc->GetProjectPage() ; ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newfile.cpp ===
// NewFile.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "NewFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewFile property page

TCHAR* pszFileNames[] = {_T("GPD"), _T("UFM"), _T("GTT")};
TCHAR* pszExt[] = {_T(".GPD"), _T(".UFM"), _T(".GTT") };
int  iBitmap[] = {IDB_GPD_VIEWER,IDB_FONT_VIEWER,IDB_GLYPHMAP};
WORD  wID[] = {120,122,124 } ;



IMPLEMENT_DYNCREATE(CNewFile, CPropertyPage)



CNewFile::CNewFile() : CPropertyPage(CNewFile::IDD),FILES_NUM(3)
{
	//{{AFX_DATA_INIT(CNewFile)
	m_csFileLoc = _T("");
	m_csNewFile = _T("");
	//}}AFX_DATA_INIT
//	m_bproj = FALSE ;
}

CNewFile::CNewFile(CPropertySheet *pcps): CPropertyPage(CNewFile::IDD),FILES_NUM(3)
{
//	m_pcps = pcps ;
}


CNewFile::~CNewFile()
{

}

void CNewFile::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewFile)
	DDX_Control(pDX, IDC_NEWFILES_LIST, m_clcFileName);
	DDX_Text(pDX, IDC_FILE_LOC, m_csFileLoc);
	DDX_Text(pDX, IDC_NEWFILENAME, m_csNewFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewFile, CPropertyPage)
	//{{AFX_MSG_MAP(CNewFile)
	ON_BN_CLICKED(IDC_Browser, OnBrowser)
	ON_NOTIFY(NM_DBLCLK, IDC_NEWFILES_LIST, OnDblclkNewfilesList)
	ON_EN_CHANGE(IDC_NEWFILENAME, OnChangeNewFilename)
	ON_NOTIFY(NM_CLICK, IDC_NEWFILES_LIST, OnClickNewfilesList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewFile message handlers


/********************************************************************************
	BOOL CNewFile::OnSetActive() 
Do: Enumerate the file list to the list control box
Args:
Ret.


*********************************************************************************/
BOOL CNewFile::OnSetActive() 
{
	m_clcFileName.DeleteAllItems();
	// create object for imagelist, it didn't work when use this as reference.
	CImageList* pcil = new CImageList ;

	pcil->Create(32,32,ILC_COLOR4,3,1);
 	CBitmap cb;
	 
    for (int j =0; j< FILES_NUM; j++)	{
		cb.LoadBitmap(iBitmap[j]);
		pcil->Add(&cb,RGB(0,0,0) );
		cb.DeleteObject();
	}
 
	m_clcFileName.SetImageList(pcil,LVSIL_NORMAL);
// set the items with image and text
	LV_ITEM lvi;
	for (int i = 0; i< FILES_NUM; i++)
	{
		lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM ;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.pszText = pszFileNames[i]; 
		lvi.iImage = i;
	    lvi.lParam = (ULONG_PTR)pszExt[i];
 
		m_clcFileName.InsertItem(&lvi);
	}


	
	return CPropertyPage::OnSetActive();
}


/********************************************************************************
	BOOL CNewFile::CallNewDoc()
Do:  this is workhourse. it load the resource file for gpd, gtt, ufm, creat gtt, ufm 
directory, and then creat file.

*********************************************************************************/

BOOL CNewFile::CallNewDoc()
{

	UpdateData();

/* Tell what is selected

  if (ufm, gtt)
	make new file based on selected files base.

  if( project file)
  { 
    run Wizard :
		: user chose GPD template -> 
		    1.Do this template make rc file(?)
		    2.what UFM, GTT are included in template
			3.how can take care of ufm, gtt mentioned GPD 
			4.what user chose when make GPD template.
	
	Make sub directory W2K, UFM, GTT.
	
	  	  

  }
	*/	
	
	// get selected file text name (ex. .UFM, .GTT
	int idContext = m_clcFileName.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

	if (idContext == -1 )
		return FALSE ;

	union {ULONG_PTR lParam; LPCTSTR lpstrExt;};
	// get extention for file
	lParam = m_clcFileName.GetItemData(idContext);


	// compare the selected file name and parsing
	// Call new Document 

	CWinApp *cwa = AfxGetApp();
	POSITION pos = cwa->GetFirstDocTemplatePosition();
	CString csExtName;
	CDocTemplate *pcdt ;
	while (pos != NULL){
		pcdt = cwa -> GetNextDocTemplate(pos);

		ASSERT (pcdt != NULL);
		ASSERT (pcdt ->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

		pcdt ->GetDocString(csExtName, CDocTemplate::filterExt);

		if (csExtName == lpstrExt){
			// 1. create the file when a.created with project file  b. created with file name
//			if (m_bproj || m_csNewFile.GetLength() != 0) { 
			if (! m_csNewFile.GetLength())
				m_csNewFile = _T("Untitled") ;
			if (m_csNewFile.GetLength() != 0) { 
				// check the file name if user put or not
				if (m_csNewFile.GetLength() == 0 ) {
					CString csErr ;
					csErr.LoadString(IDS_NoFileName) ;
					AfxMessageBox(csErr, MB_ICONEXCLAMATION);
					return FALSE ;
				} ;
				// make UFM, GTT directory if user create these file
				CString csDir = m_csFileLoc.Right(m_csFileLoc.ReverseFind(_T('\\'))) ;
					// create directory
				SECURITY_ATTRIBUTES st;
				st.nLength = sizeof(SECURITY_ATTRIBUTES);
				st.lpSecurityDescriptor = NULL;
				st.bInheritHandle = FALSE ;
				try {
					if (!csExtName.CompareNoCase(_T(".UFM")) ){
						if (!!csDir.CompareNoCase(_T("UFM")) ) {
							m_csFileLoc += _T("\\UFM") ;
							CreateDirectory(m_csFileLoc,&st) ;
						}
					}
					else if (!csExtName.CompareNoCase(_T(".GTT")) ){
						if (!!csDir.CompareNoCase(_T("GTT") ) ) {
							m_csFileLoc += _T("\\GTT") ;
							CreateDirectory(m_csFileLoc,&st) ;
						}
					} 
				}
				catch (CException* pce) {
					pce->ReportError() ;
					pce->Delete() ;
					return FALSE ;
				} ;
				// check if specified named file is exist or not in the directory
				CString csFileName = m_csFileLoc +_T("\\") + m_csNewFile + csExtName;
				CFileFind cff ;
				if ( cff.FindFile(csFileName) ) {
					
					CString csMsg ;
					csMsg.LoadString(IDS_FileNewExist) ;
					if (AfxMessageBox (csMsg, MB_YESNO ) == IDNO)
						return FALSE ;

				}
				
				CFile cf(csFileName,CFile::modeCreate | CFile::modeWrite ) ;
				
				// load the UFM, GTT, GPD from the resources.
				for (unsigned i = 0 ; i < sizeof (*pszExt) ; i ++ ) {
					if (!csExtName.CompareNoCase(pszExt[i] ) )
						break;
				} ;

				WORD wi = wID [i] ;
				HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(wID[i]),
					MAKEINTRESOURCE(IDR_NEWFILE));
					
 
				if (!hrsrc) {
					CString csErr ;
					csErr.LoadString(IDS_ResourceError) ;
					AfxMessageBox(csErr, MB_ICONEXCLAMATION ) ;
					return FALSE;
				} ;

			    HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
			    if  (!hgMap)
					return  FALSE;  //  This should never happen!
			
				int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
				LPVOID lpv = LockResource(hgMap);
				
				cf.Write(lpv,nsize) ;
				cf.Close() ;

				pcdt->OpenDocumentFile(csFileName) ;

				// add the new file into the project tree.
			}
			else // 2.created the file with no file name, project 
				pcdt->OpenDocumentFile(NULL);
			return TRUE;
		}
	}

	return FALSE;
}

/********************************************************************************
	void CNewFile::OnBrowser() 
Do:  Using the old version browser rather than SHELL. code reuse in the MDT and 
faster than SHELL to be loaded
Args:
Ret.

*********************************************************************************/


void CNewFile::OnBrowser() 
{

	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    strcpy(acpath, _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	ofn.lpstrInitialDir = NULL ; //  in parent dialog box
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY /*| OFN_ENABLEHOOK */| OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook = NULL ;
    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    
	m_csFileLoc = (LPCTSTR) acpath ;
	
	UpdateData(FALSE) ;
/*	if (pidlSelected)
		pMalloc->Free(pidlSelected) ;

	pMalloc->Release() ;
*/
}

/********************************************************************************
	void CNewFile::OnOK() 
Do: 
Args:
Ret.

*********************************************************************************/
void CNewFile::OnOK() 
{
	//to do
	/*
	Read what item is selected and open the file

  */
	if(CallNewDoc())
		CPropertyPage::OnOK();
	
}



/********************************************************************************
	void CNewFile::OnDblclkNewfilesList(NMHDR* pNMHDR, LRESULT* pResult) 
Do: Call the CallNewDoc() like OK () button, we need to check the filename is set or not
Args:
Ret.


*********************************************************************************/
void CNewFile::OnDblclkNewfilesList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	
	if (CallNewDoc() )
		EndDialog(IDD_NewFile) ;
	// bug; need to close the dialog ?? OnOK() call directly does not works.

	*pResult = 0 ;
	

	

}


/********************************************************************************
	void CNewFile::OnCheckProject() 
Do:  Enable and disable by checking the Project file name checkec status
Args:
Ret.

*********************************************************************************/
/*
void CNewFile::OnCheckProject() 
{
	CEdit cePrjName;
	CWnd *pcw ;
	if ( m_cbEnPrj.GetCheck() )  {// check the button
		pcw = GetDlgItem(IDC_EDIT_PRJ_NAME) ;
		cePrjName.Attach(pcw->m_hWnd ) ;
		cePrjName.EnableWindow(TRUE) ;
		cePrjName.Detach() ;	
	}
	else {
		pcw = GetDlgItem(IDC_EDIT_PRJ_NAME) ;
		cePrjName.Attach(pcw->m_hWnd ) ;
		cePrjName.EnableWindow(FALSE) ;
		cePrjName.Detach() ;
	} ;
} ;


*/
/********************************************************************************
	BOOL CNewFile::OnInitDialog() 
Do: Enumberate File name list
Args:
Ret.


*********************************************************************************/
BOOL CNewFile::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	m_pcps = DYNAMIC_DOWNCAST(CPropertySheet,GetOwner() ) ;
	
	m_pcps->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	
//	CMDIFrameWnd *pFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, AfxGetApp()->m_pMainWnd) ;
// Get the active MDI child window.
//	CMDIChildWnd *pChild = DYNAMIC_DOWNCAST(CMDIChildWnd, pFrame->GetActiveFrame() );

	CString cstmp ;
	
//	CDocument *pDoc ;
	cstmp.LoadString(IDS_MDWExtension) ;
/*	
	for ( ; pChild ; pChild = (CMDIChildWnd* ) pChild->GetNextWindow() ) {
		pDoc = (CDocument *) pChild->GetActiveDocument();
		if(pDoc) {
			CString cs = pDoc->GetTitle() ;
			if(cs.Find(cstmp) != -1 ) {
			m_bproj = TRUE;
			break;
			} 
		}
		else
			break;

	} 

	if(m_bproj) {
		CheckDlgButton(IDC_CHECK_PROJECT,1);
		m_csPrjName = ((CProjectRecord*)pDoc)->DriverName();

		m_csFileLoc = ((CProjectRecord*)pDoc)->GetW2000Path();
		
		m_pcps->GetDlgItem(IDOK)->EnableWindow(FALSE) ;

		UpdateData(FALSE);

		
	}
	else{
*/	
//		GetDlgItem(IDC_CHECK_PROJECT)->EnableWindow(FALSE);
//	    GetDlgItem(IDC_STATIC_ADDTOPRJ)->EnableWindow(FALSE);
	CWinApp* pApp = AfxGetApp();
	CString csPath = pApp->m_pszHelpFilePath;
	m_csFileLoc = csPath.Left(csPath.ReverseFind(_T('\\') ) ) ;
	
	UpdateData(FALSE);
		
//	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/********************************************************************************
void CNewFile::OnChangeNewFilename() 
Do: Called whenever File Name edit box clicked. just call SetOkButton()
Args:
Ret.

*********************************************************************************/
void CNewFile::OnChangeNewFilename() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetOkButton() ;
}

void CNewFile::OnClickNewfilesList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetOkButton() ;
	*pResult = 0;
}

/********************************************************************************
void CNewFile::SetOkButton()

Do; Enable and disable OK button by checking the filename and 
selection of file on the list


*********************************************************************************/
void CNewFile::SetOkButton()
{
	UpdateData() ;
	POSITION pos = m_clcFileName.GetFirstSelectedItemPosition();

	if (m_csNewFile.GetLength() != 0 && pos )
		m_pcps->GetDlgItem(IDOK)->EnableWindow()  ;
	else
		m_pcps->GetDlgItem(IDOK)->EnableWindow(FALSE)  ;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newproj.cpp ===
/******************************************************************************

  Source File:  New Project Wizard.CPP

  This contains the implementation of the classes that make u the new project
  wizard- a key component of this tool.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it
  02-28-1998	Ekevans@acsgroup.com		The UI for the wizard was changed
				to only support conversion to Win2K minidrivers.  Be this as
				it may, most - if not all - of the support in this file for
				other conversions is still in this file but is unused.
******************************************************************************/

#include    "StdAfx.h"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "NewProj.H"
#include    <CodePage.H>
#include	<dlgs.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewConvertWizard

//  We use "this" to allow the pages to hook back to us- disable the
//  warnings this causes, as none will use the pointer until after
//  we have been initialized.

#pragma warning(disable : 4355)
CNewConvertWizard::CNewConvertWizard(CProjectRecord& cprFor, CWnd* pParentWnd) :
	CPropertySheet(NewProjectWizardTitle, pParentWnd), m_cfnwp(*this),
    m_cprThis(cprFor), m_cst(*this), m_csd(*this), m_crut(*this),
    m_crng(*this), m_ccf(*this), m_cmcp(*this), m_cgpds(*this), m_cdcps(*this) {

    m_bFastConvert = TRUE;
    m_eGPDConvert = CommonRCWithSpoolerNames;

    AddPage(&m_cfnwp);	//CFirstNewWizardPage
    AddPage(&m_cst);	//CSelectTargets
    AddPage(&m_csd);	//CSelectDestinations
	AddPage(&m_cdcps);	//CDefaultCodePageSel
	AddPage(&m_cgpds);	//CGPDSelection
    AddPage(&m_crut);	//CRunUniTool
    AddPage(&m_cmcp);	//CMapCodePages
    AddPage(&m_ccf);	//CConvertFiles
    AddPage(&m_crng);	//CRunNTGPC
    SetWizardMode();
}

#pragma warning(default : 4355)

CNewConvertWizard::~CNewConvertWizard() {
}

BEGIN_MESSAGE_MAP(CNewConvertWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CNewConvertWizard)
	ON_WM_NCCREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewConvertWizard message handlers

//  restore the system menu to the wizard, and allow it to be minimized

BOOL CNewConvertWizard::OnNcCreate(LPCREATESTRUCT lpCreateStruct) {
	ModifyStyle(WS_CHILD, WS_MINIMIZEBOX | WS_SYSMENU);
	
	if (!CPropertySheet::OnNcCreate(lpCreateStruct))
		return FALSE;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage property page

CFirstNewWizardPage::CFirstNewWizardPage(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CFirstNewWizardPage::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CFirstNewWizardPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFirstNewWizardPage::~CFirstNewWizardPage() {
}

void CFirstNewWizardPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFirstNewWizardPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFirstNewWizardPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFirstNewWizardPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage message handlers

BOOL CFirstNewWizardPage::OnSetActive() {
	//  We wish to disable the "Back" button here.
	
    m_cnpwOwner.SetWizardButtons(PSWIZB_NEXT);
	m_cnpwOwner.GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	return  CPropertyPage::OnSetActive();
}

/******************************************************************************

  CFirstNewWizardPage::OnWizardNext

  When Next is pressed, we invoke a file open dialog to allow us to collect the
  source RC file information.

******************************************************************************/

LRESULT CFirstNewWizardPage::OnWizardNext()
{
	CString		cswrcfspec ;	// Filespec for RC/RC3/W31 file

	//  When the "Next" button is pushed, we need to find the driver we are
    //  going to work with.  Keep prompting the user until a valid filespec
	//	is returned.
		
	do {
		CFileDialog cfd(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
			"Driver Resource Scripts (*.w31,*.rc)|*.w31;*.rc||",
			&m_cnpwOwner);

		CString csTitle;
		csTitle.LoadString(OpenRCDialogTitle);

		cfd.m_ofn.lpstrTitle = csTitle;

		if  (cfd.DoModal() != IDOK)
			return  -1;

		// Save the filespec and then exit the loop if the file is ok.
		// Otherwise, reprompt.

		cswrcfspec = cfd.GetPathName() ;
	} while (IsWrongNT4File(cswrcfspec)) ;

    //  Collect the RC file name

    m_cnpwOwner.Project().SetSourceRCFile(cswrcfspec) ;

	// The only conversion supported now is the so called "Fast Conversion" so
	// set that flag and skip some of the other wizard pages and go straight to
	// the destinations page.

    m_cnpwOwner.FastConvert(TRUE) ;
    return CSelectDestinations::IDD ;
}


/******************************************************************************

 CFirstNewWizardPage::IsWrongNT4File

 NT 4.0 minidrivers are made up of (among other things) both an RC file and a
 W31 file.  NT 4.0 minidriver conversions must be driven from the W31 file.
 So, if the filespec references an RC file, check the file to see if it is an
 NT 4 file.  If it is, look for a W31 file and ask the user if it should be
 used.  If yes, change the filespec and return false.  If no or there is no
 W31 file, return true so that the user will be reprompted.

******************************************************************************/

bool CFirstNewWizardPage::IsWrongNT4File(CString& cswrcfspec)
{
	CString		cstmp1 ;		// Temp string
	CString		cstmp2 ;		// Temp string
	CString		cstmp3 ;		// Temp string

	// If the file does not end with .RC, return false (ok).

	cstmp1.LoadString(IDS_RCExt) ;
	int nlen = cstmp1.GetLength() ;
	cstmp2 = cswrcfspec.Right(nlen) ;
	if (cstmp1.CompareNoCase(cstmp2) != 0)
		return false ;

	// The filespec references an RC file so it must be read and scanned to
	// see if this is an NT 4.0 RC file.  Start by reading the file...

    CStringArray    csacontents ;
    if  (!LoadFile(cswrcfspec, csacontents))
        return  FALSE ;

	// Now scan the file looking for a "2 RC_TABLES ... nt.gpc" line that will
	// indicate that this is an NT 4.0 file.

	cstmp1.LoadString(IDS_RCTables) ;
	cstmp2.LoadString(IDS_RCTabID) ;
	cstmp3.LoadString(IDS_RCTabFile) ;
	int n ;
	for (n = 0 ; n < csacontents.GetSize() ; n++) {

		// Skip this line if "RC_TABLES" is not in the line.

		if (csacontents[n].Find(cstmp1) < 0)
			continue ;

		// Skip this line if it doesn't start with "2"

		csacontents[n].TrimLeft() ;
		if (csacontents[n].Find(cstmp2) != 0)
			continue ;

		// If this line contains "nt.gpc", this is the one we want so exit the
		// loop.

		csacontents[n].MakeLower() ;
		if (csacontents[n].Find(cstmp3) >= 0)
			break ;
	} ;

	// If this is NOT an NT 4.0 RC file, return false (ok).

	if (n >= csacontents.GetSize())
		return false ;

	// We have an NT 4.0 RC file, check to see if there is a W31 file in the
	// same dir.  If there is, ask the user if he wants to use it and do so
	// if he says yes.

	cstmp1 = cswrcfspec.Left(cswrcfspec.GetLength() - nlen) ;
	cstmp2.LoadString(IDS_W31Ext) ;
	cstmp1 += cstmp2 ;
	CFileFind cff ;
	if (cff.FindFile(cstmp1)) {
		cstmp3.Format(IDS_SwitchToW31, cswrcfspec, cstmp1) ;
		if (AfxMessageBox(cstmp3, MB_YESNO) == IDYES) {
			cswrcfspec = cstmp1 ;
			return false ;
		} ;
	} ;

	// Either there is no W31 file or the user chose not to use it so return
	// true to indicate that the user should be reprompted to select another
	// file.

	cstmp1.Format(IDS_BadNT4File, cswrcfspec) ;
	AfxMessageBox(cstmp1) ;
	return true ;
}


/////////////////////////////////////////////////////////////////////////////
// CSelectTargets property page

CSelectTargets::CSelectTargets(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CSelectTargets::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CSelectTargets)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSelectTargets::~CSelectTargets() {
}

void CSelectTargets::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectTargets)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectTargets, CPropertyPage)
	//{{AFX_MSG_MAP(CSelectTargets)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets message handlers

BOOL CSelectTargets::OnSetActive() {
	//  We need to enable the "Back" button...

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    SetDlgItemText(IDC_DriverName, m_cnpwOwner.Project().DriverName());
	
	return CPropertyPage::OnSetActive();
}

//  Initialize the controls

BOOL CSelectTargets::OnInitDialog() {

	CPropertyPage::OnInitDialog();
	
	CheckDlgButton(IDC_TargetNT40,
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));
	CheckDlgButton(IDC_TargetNT3x,
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));
	CheckDlgButton(IDC_TargetWin95,
        m_cnpwOwner.Project().IsTargetEnabled(Win95));
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSelectTargets::OnWizardNext() {

	//  Set the flags according to the controls...

    m_cnpwOwner.Project().EnableTarget(WinNT40,
        IsDlgButtonChecked(IDC_TargetNT40));
	m_cnpwOwner.Project().EnableTarget(WinNT3x,
        IsDlgButtonChecked(IDC_TargetNT3x));
	m_cnpwOwner.Project().EnableTarget(Win95,
        IsDlgButtonChecked(IDC_TargetWin95));

	CString csName;
	GetDlgItemText(IDC_DriverName, csName);
    m_cnpwOwner.Project().Rename(csName);
	
	return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations property page

/**********************************************************************
 * Function:    BrowseDlgProc
 *
 * Purpose:     This dialog procedure is used to correctly initialize
 *				a browse dialog box based on the type of browsing to be
 *				performed.
 *
 *				If just a path (folder) is required, hide the file
 *				related controls that are on the dialog box.
 *
 *				If drive filtering is required, install a custom message
 *				handler for the drives combo box that will perform the
 *				filtering.
 *
 * In:          Standard dialog procedure parameters
 *
 * Out:         TRUE if message handle.  FALSE if standard processing
 *              should occur.
 **********************************************************************/

UINT_PTR APIENTRY BrowseDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    // Don't do anything if this is NOT the init message

    if (msg != WM_INITDIALOG)
        return (FALSE) ;

    // Hide the unneeded file related controls

	ShowWindow(GetDlgItem(hdlg, stc2), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, stc3), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, edt1), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, lst1), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, cmb1), SW_HIDE) ;

    // Do the default initialization too.

    return (FALSE) ;
}


//  This routine browses for a directory, beginning with the one named in the
//  given control.  If a directory is selected, the control is appropriately
//  updated.
//
//	An old style common dialog box is used to do this.  There is a function,
//	::SHBrowseForFolder(), that can do this with the new style dialog box but
//	I don't think this function is available on all platforms supported by
//	the MDT.

void    CSelectDestinations::DoDirectoryBrowser(CString& csinitdir)
{
	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
    char    acidir[_MAX_PATH] ; // Initial directory is built here
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    strcpy(acpath, _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	//n = GetWindowText(hParentDrives, acidir, _MAX_PATH) ;
	//GetWindowText(hfolder, &acidir, _MAX_PATH) ;
	strcpy(acidir, csinitdir.GetBufferSetLength(256)) ;
	csinitdir.ReleaseBuffer() ;
	ofn.lpstrInitialDir = acidir ;	// Path in parent dialog box
	//LoadString(ofn.hInstance, IDS_SELFOLDTITLE, actitle, 64) ;
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK | OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook =  BrowseDlgProc ;

    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    csinitdir = acpath ;
	UpdateData(FALSE) ;

	return ;
}

/******************************************************************************

  CSelectDestinations::BuildStructure

  This private member function establishes the selected directory structure,
  if it can, and reports its success or failure as need be.

******************************************************************************/

BOOL    CSelectDestinations::BuildStructure() {
    //  Verify the directory exists (or can be created) for each of the
    //  target directories that is enabled.

    CProjectRecord& cpr = m_cnpwOwner.Project();

    CString csPath;

    if  (cpr.IsTargetEnabled(Win2000)) {
        GetDlgItemText(IDC_W2000Destination, csPath);

		// First, make sure that the path the user selected ends with the
		// directory "W2K".
			// raid 123448
/*	CString cspdir, csw2kdir ;
		csw2kdir.LoadString(IDS_NewDriverRootDir) ;		// R 123448
		cspdir = csPath.Right(csw2kdir.GetLength() + 1) ;
		csw2kdir = _T("\\") + csw2kdir ;
		
		if (cspdir.CompareNoCase(csw2kdir) != 0) {
			csw2kdir = csw2kdir.Right(csw2kdir.GetLength() - 1) ;
			cspdir.Format(IDS_BadDestPath, csw2kdir) ;
			AfxMessageBox(cspdir, MB_ICONEXCLAMATION) ;
			return FALSE ;
		} ;
*/	// raid 123448
		CString csSourcePath;
		csSourcePath = cpr.SourceFile().Left(cpr.SourceFile().ReverseFind('\\') ); 
		if (!csPath.CompareNoCase(csSourcePath) || !csPath.CompareNoCase(csSourcePath + "\\") ) {
			AfxMessageBox("You have to have different Destination from RC source file",MB_ICONEXCLAMATION );
			return FALSE;
		} ;

		// Continue with rest of directory verifications...

        if  (!cpr.SetPath(Win2000, csPath) || !cpr.BuildStructure(Win2000)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_W2000Destination) -> SetFocus();
            return  FALSE;
        }
    }

    if  (cpr.IsTargetEnabled(WinNT40)) {
        GetDlgItemText(IDC_NT40Destination, csPath);
        if  (!cpr.SetPath(WinNT40, csPath) || !cpr.BuildStructure(WinNT40)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT40Destination) -> SetFocus();
            return  FALSE;
        }
    }

    if  (cpr.IsTargetEnabled(WinNT3x)) {
        GetDlgItemText(IDC_NT3xDestination, csPath);
        if  (!cpr.SetPath(WinNT3x, csPath) || !cpr.BuildStructure(WinNT3x)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT3xDestination) -> SetFocus();
            return  FALSE;
        }
    }

    return  TRUE;
}

/******************************************************************************

  CSelectDestinations constructor, destructor, DDX routine and message map.

******************************************************************************/

CSelectDestinations::CSelectDestinations(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CSelectDestinations::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CSelectDestinations)
	m_csW2KDest = _T("");
	//}}AFX_DATA_INIT
}

CSelectDestinations::~CSelectDestinations() {
}

void CSelectDestinations::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectDestinations)
	DDX_Control(pDX, IDC_BrowseNT3x, m_cbBrowseNT3x);
	DDX_Control(pDX, IDC_BrowseNT40, m_cbBrowseNT40);
	DDX_Control(pDX, IDC_BrowseW2000, m_cbBrowseW2000);
	DDX_Text(pDX, IDC_W2000Destination, m_csW2KDest);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSelectDestinations, CPropertyPage)
	//{{AFX_MSG_MAP(CSelectDestinations)
	ON_BN_CLICKED(IDC_BrowseNT40, OnBrowseNT40)
	ON_BN_CLICKED(IDC_BrowseW2000, OnBrowseW2000)
	ON_BN_CLICKED(IDC_BrowseNT3x, OnBrowseNT3x)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations message handlers

BOOL CSelectDestinations::OnInitDialog() {

	CPropertyPage::OnInitDialog();

    //  Place the browser Icon in the Win2K button

    HICON   hiArrow = LoadIcon(AfxGetResourceHandle(),
        MAKEINTRESOURCE(IDI_BrowseArrow));
	m_cbBrowseW2000.SetIcon(hiArrow);

#if 0
	m_cbBrowseNT40.SetIcon(hiArrow);
	m_cbBrowseNT3x.SetIcon(hiArrow);
#else
    m_cbBrowseNT40.ShowWindow(SW_HIDE);
    m_cbBrowseNT3x.ShowWindow(SW_HIDE);
#endif
	
    return TRUE;
}


//  When we are made active, fill in the correct path names.  Note that these
//  might change as a result of activity on other pages, so we do not just do
//  this at init time.

BOOL CSelectDestinations::OnSetActive() {

    //  Fill in the correct path names

    //SetDlgItemText(IDC_W2000Destination,
    //    m_cnpwOwner.Project().TargetPath(Win2000));
    m_csW2KDest = m_cnpwOwner.Project().TargetPath(Win2000) ;
    SetDlgItemText(IDC_NT40Destination,
        m_cnpwOwner.Project().TargetPath(WinNT40));
    SetDlgItemText(IDC_NT3xDestination,
        m_cnpwOwner.Project().TargetPath(WinNT3x));
    SetDlgItemText(IDC_Win95Destination,
        m_cnpwOwner.Project().TargetPath(Win95));

    //  Disable all controls related to non-operative targets

    GetDlgItem(IDC_W2000Destination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(Win2000));

    m_cbBrowseW2000.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(Win2000));
	
    GetDlgItem(IDC_NT40Destination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));

    m_cbBrowseNT40.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));

    GetDlgItem(IDC_NT3xDestination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));

    m_cbBrowseNT3x.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));

    //  Turn on the back and next buttons.

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT) ;

	// Initialize controls

	UpdateData(FALSE) ;

	return CPropertyPage::OnSetActive();
}

void CSelectDestinations::OnBrowseNT3x() {
	//DoDirectoryBrowser(IDC_NT3xDestination);
}

void CSelectDestinations::OnBrowseNT40() {
	//DoDirectoryBrowser(IDC_NT40Destination);
}

void CSelectDestinations::OnBrowseW2000() {
	DoDirectoryBrowser(m_csW2KDest);
}


/******************************************************************************

  CSelectDestinations::OnWizardNext

  Create the project record, build the destination directories, and begin the
  conversion.  The conversion is started here because the work that is done
  will generate the model information that is displayed on the GPD Selection
  page.

  Note: The original layout of this function is commented out below.  It may
  be need if some of the unimplemented/incomplete function in this program is
  ever finished.

******************************************************************************/

LRESULT CSelectDestinations::OnWizardNext() 
{
    //  This might take a while, so...

    CWaitCursor cwc;

	// Build the directory structure

    if  (!BuildStructure())
        return  -1;

    CProjectRecord& cpr = m_cnpwOwner.Project();

	// Open the conversion logging file.

	cpr.OpenConvLogFile() ;

    // Loading the original resources is done here because some of this
	// info is needed for the GPD selection page.

	if  (!cpr.LoadResources()) {
		// Display error message(s) if the resources could not be loaded.

		cpr.CloseConvLogFile() ;
        AfxMessageBox(IDP_RCLoadFailed) ;
		if (cpr.ThereAreConvErrors()) {
			CString csmsg ;
			csmsg.Format(IDS_FatalConvErrors, cpr.GetConvLogFileName()) ;
			AfxMessageBox(csmsg) ;
		} ;

		m_cnpwOwner.EndDialog(IDCANCEL) ;
        return  -1 ;
    }

    return CPropertyPage::OnWizardNext();
}

/******************************************************************************

  CSelectDestinations::OnWizardBack

  This handles the response to the back button.  We must override the default
  handler in the case of a normal conversion, as the default will go back to
  the target selection page, and we will go back to the initial page in the
  fast-path case.

******************************************************************************/

LRESULT CSelectDestinations::OnWizardBack() {
    return m_cnpwOwner.FastConvert() ?
        CFirstNewWizardPage::IDD : CPropertyPage::OnWizardBack();
}


/////////////////////////////////////////////////////////////////////////////
// CRunUniTool property page

CRunUniTool::CRunUniTool(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CRunUniTool::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CRunUniTool)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRunUniTool::~CRunUniTool() {
}

void CRunUniTool::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRunUniTool)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRunUniTool, CPropertyPage)
	//{{AFX_MSG_MAP(CRunUniTool)
	ON_BN_CLICKED(IDC_RunUniTool, OnRunUniTool)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRunUniTool message handlers

void CRunUniTool::OnRunUniTool() {
	//  Not too terribly difficult, really.  Invoke UniTool, which resides
    //  in the same directory we came from.  Then wait for the user to close it.

    STARTUPINFO         si = {sizeof si, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0,
                        STARTF_FORCEONFEEDBACK, 0, 0, NULL, NULL, NULL, NULL};
    PROCESS_INFORMATION pi;

    CString csCommand("Unitool ");

    csCommand += m_cnpwOwner.Project().SourceFile();

    if  (!CreateProcess(NULL, const_cast <LPTSTR> ((LPCTSTR) csCommand), NULL,
        NULL, FALSE, CREATE_SEPARATE_WOW_VDM, NULL,
        m_cnpwOwner.Project().TargetPath(Win95), &si, &pi)) {
        TRACE("Failed to run Unitool, reason %d <%X>\r\n", GetLastError(),
            GetLastError());
        AfxMessageBox(IDS_UnitoolNotRun);
        return;
    }

    CloseHandle(pi.hThread);    //  We'll wait on the process.
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
}

/******************************************************************************

  CRunUniTool::OnSetActive

  We never force this to be run, anymore, so just enable both buttons.

******************************************************************************/

BOOL CRunUniTool::OnSetActive() {
	//  We need to deactivate the Next button if Unitool has not yet been run
    //  on this driver.

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CRunUniTool::OnWizardNext

  Go right on ahead, unless the RC file isn't translatable...

******************************************************************************/

LRESULT CRunUniTool::OnWizardNext() {
	//  One last check- we must be able to load and understand the RC file
    //  before we proceed.

    if  (!m_cnpwOwner.Project().LoadResources()) {
        AfxMessageBox(IDP_RCLoadFailed);
        return  -1;
    }

    return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles property page

CConvertFiles::CConvertFiles(CNewConvertWizard& cnpwOwner) :
CPropertyPage(CConvertFiles::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CConvertFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CConvertFiles::~CConvertFiles() {
}

void CConvertFiles::DoDataExchange(CDataExchange* pDX) {

    CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvertFiles)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvertFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CConvertFiles)
	ON_BN_CLICKED(IDC_ConvertFiles, OnConvertFiles)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles message handlers

/******************************************************************************

  CConvertFiles::OnSetActive

  This handler is called whenever the user navigates to where this sheet is
  active.

******************************************************************************/

BOOL CConvertFiles::OnSetActive() {

    //  If there is no NT GPC work to be done, we can be done with it.
	m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
        (m_cnpwOwner.Project().IsTargetEnabled(WinNT3x | WinNT40) ?
            0 : PSWIZB_DISABLEDFINISH));

    //  Set the radio buttons according to the selected GPD conversions

    CheckRadioButton(IDC_Direct, IDC_SpoolerNames,
        IDC_Direct + m_cnpwOwner.GPDConvertFlag());
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CConvertFiles::OnConvertFiles

  Message handler for the user pressing the Convert Files button.

******************************************************************************/

void CConvertFiles::OnConvertFiles() {

    //  This might take a while, so...
    CWaitCursor cwc;

    //  We now need to generate ALL of the necessary files
    m_cnpwOwner.GPDConvertFlag(
        GetCheckedRadioButton(IDC_Direct, IDC_SpoolerNames) - IDC_Direct);
    m_cnpwOwner.Project().GenerateTargets(m_cnpwOwner.GPDConvertFlag());
    if  (m_cnpwOwner.Project().ConversionsComplete())
        m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
            (m_cnpwOwner.Project().IsTargetEnabled(WinNT3x | WinNT40) ?
                PSWIZB_NEXT : PSWIZB_FINISH));
}

/******************************************************************************

  CConvertFiles::OnKillActive

  This is called whenever the page is dismissed.  We save the GPD conversion
  flag, in case we come back to this page later.

******************************************************************************/

BOOL CConvertFiles::OnKillActive() {
	m_cnpwOwner.GPDConvertFlag(
        GetCheckedRadioButton(IDC_Direct, IDC_SpoolerNames) - IDC_Direct);

    return CPropertyPage::OnKillActive();
}

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC property page

CRunNTGPC::CRunNTGPC(CNewConvertWizard &cnpwOwner) :
    CPropertyPage(CRunNTGPC::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CRunNTGPC)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRunNTGPC::~CRunNTGPC() {
}

void CRunNTGPC::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRunNTGPC)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRunNTGPC, CPropertyPage)
	//{{AFX_MSG_MAP(CRunNTGPC)
	ON_BN_CLICKED(IDC_RunNtGpcEdit, OnRunNtGpcEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC message handlers

void CRunNTGPC::OnRunNtGpcEdit() {
	//  We only hit this step if we are building for NT 3.x or 4.0, so see
    //  which it is.

    CProjectRecord& cprThis = m_cnpwOwner.Project();

    UINT    ufEdit = cprThis.IsTargetEnabled(WinNT3x) ? WinNT3x : WinNT40;

    //  Not too terribly difficult, really.  Invoke the editor, which resides
    //  in the same directory we came from.  Wait for the user to close it.

    STARTUPINFO         si = {sizeof si, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0,
                        STARTF_FORCEONFEEDBACK, 0, 0, NULL, NULL, NULL, NULL};
    PROCESS_INFORMATION pi;

    CString csCommand("NTGPCEdt ");

    csCommand += cprThis.RCName(ufEdit);

    if  (!CreateProcess(NULL, const_cast <LPTSTR> ((LPCTSTR) csCommand), NULL,
        NULL, FALSE, CREATE_SEPARATE_WOW_VDM, NULL,
        m_cnpwOwner.Project().TargetPath(ufEdit), &si, &pi)) {
        TRACE("Failed to run NTGPCEdt, reason %d <%X>\r\n", GetLastError(),
            GetLastError());
        AfxMessageBox(IDS_UnitoolNotRun);
        return;
    }

    CloseHandle(pi.hThread);    //  We'll wait on the process.
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);

    //  Copy the NT GPC file, if necessary}

    if  (ufEdit == WinNT3x && cprThis.IsTargetEnabled(WinNT40))
        CopyFile(cprThis.TargetPath(WinNT3x) + _TEXT("\\NT.GPC"),
            cprThis.TargetPath(WinNT40) + _TEXT("\\NT.GPC"), FALSE);

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
    m_cnpwOwner.Project().OldStuffDone();
}

BOOL CRunNTGPC::OnSetActive() {
    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
        (m_cnpwOwner.Project().NTGPCCompleted() ?
            PSWIZB_FINISH : PSWIZB_DISABLEDFINISH));
	
	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages property page

CMapCodePages::CMapCodePages(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CMapCodePages::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CMapCodePages)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMapCodePages::~CMapCodePages() {
}

void CMapCodePages::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMapCodePages)
	DDX_Control(pDX, IDC_TableToPage, m_clbMapping);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMapCodePages, CPropertyPage)
	//{{AFX_MSG_MAP(CMapCodePages)
	ON_BN_CLICKED(IDC_ChangeCodePage, OnChangeCodePage)
	ON_LBN_DBLCLK(IDC_TableToPage, OnChangeCodePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages message handlers

BOOL CMapCodePages::OnSetActive() {

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    m_clbMapping.ResetContent();

    for (unsigned u = 0; u < m_cnpwOwner.Project().MapCount(); u++) {
        CGlyphMap& cgm = m_cnpwOwner.Project().GlyphMap(u);
        int id = m_clbMapping.AddString(cgm.Name() + _TEXT("->") +
            cgm.PageName(0));
        m_clbMapping.SetItemData(id, u);
    }

    m_clbMapping.SetCurSel(0);
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CMapCodePages::OnChangeCodePaage

  Response to the Change Code Page button.  Invoke the change code page dialog,
  and pass the new selection to the underlying glyph map.  Update the info in
  list, too...

******************************************************************************/

void CMapCodePages::OnChangeCodePage() {
    int idSel = m_clbMapping.GetCurSel();
    if  (idSel < 0)
        return;

    unsigned uidTable = (unsigned) m_clbMapping.GetItemData(idSel) ;

    CGlyphMap&  cgm =  m_cnpwOwner.Project().GlyphMap(uidTable);
	CSelectCodePage cscp(this, cgm.Name(), cgm.PageID(0));

    if  (cscp.DoModal() == IDOK) {
        cgm.SetDefaultCodePage(cscp.SelectedCodePage());

        //  Update the control- alas, this means filling it all in.

        m_clbMapping.ResetContent();

        for (unsigned u = 0; u < m_cnpwOwner.Project().MapCount(); u++) {
            CGlyphMap& cgm = m_cnpwOwner.Project().GlyphMap(u);
            int id = m_clbMapping.AddString(cgm.Name() + _TEXT("->") +
                cgm.PageName(0));
            m_clbMapping.SetItemData(id, u);
            if  (u == uidTable)
                m_clbMapping.SetCurSel(id);
        }
    }
}

LRESULT CMapCodePages::OnWizardNext() {

	// If this fails, it will report why via a message box.

    CWaitCursor cwc;    //  Just in case this takes a while!
	
    return  m_cnpwOwner.Project().LoadFontData() ? 0 : -1;
}

/******************************************************************************

  CSelectCodePage class

  This class implements a dialog which is used in several places where
  selection of a code page is desired.

******************************************************************************/

/******************************************************************************

  CSelectCodePage::CSelectCodePage

  The constructor for this class builds an array of the mapped code page names
  from the CCodePageInformation class.

******************************************************************************/

CSelectCodePage::CSelectCodePage(CWnd* pParent, CString csName,
                                 unsigned uidCurrent)
	: CDialog(CSelectCodePage::IDD, pParent) {
	//{{AFX_DATA_INIT(CSelectCodePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_csName = csName;
    m_uidCurrent = uidCurrent;

    CCodePageInformation    ccpi;

    ccpi.Mapped(m_cdaPages);
}

void CSelectCodePage::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectCodePage)
	DDX_Control(pDX, IDC_SupportedPages, m_clbPages);
	//}}AFX_DATA_MAP
}

/******************************************************************************

  CSelectCodePage::GetCodePageName

  This returns the name of the selected code page.

******************************************************************************/

CString CSelectCodePage::GetCodePageName() const {
    CCodePageInformation    ccpi;

    return  ccpi.Name(m_uidCurrent);
}

/******************************************************************************

  CSelectCodePage::Exclude

  This member function receives a list of code pages which are not to be
  displayed in the selection list.

******************************************************************************/

void    CSelectCodePage::Exclude(CDWordArray& cdaPariah) {

    for (int i = 0; i < cdaPariah.GetSize(); i++)
        for (int j = 0; j < m_cdaPages.GetSize(); j++)
            if  (cdaPariah[i] == m_cdaPages[j]) {
                m_cdaPages.RemoveAt(j);
                break;
            }
}

/******************************************************************************

  CSelectCodePage::LimitTo

  This member receives a list of the pages to select- this list supersedes the
  list of mapped tables we began with.

******************************************************************************/

void    CSelectCodePage::LimitTo(CDWordArray& cdaPages) {
    if  (!cdaPages.GetSize())
        return;

    m_cdaPages.Copy(cdaPages);
}

BEGIN_MESSAGE_MAP(CSelectCodePage, CDialog)
	//{{AFX_MSG_MAP(CSelectCodePage)
	ON_LBN_SELCHANGE(IDC_SupportedPages, OnSelchangeSupportedPages)
	ON_LBN_DBLCLK(IDC_SupportedPages, OnDblclkSupportedPages)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectCodePage message handlers

BOOL CSelectCodePage::OnInitDialog() {
	CDialog::OnInitDialog();
	
	CString csTemp;

    GetWindowText(csTemp);
    csTemp += _TEXT(" ") + m_csName;
    SetWindowText(csTemp);

    CCodePageInformation    ccpi;

    for (int i = 0; i < m_cdaPages.GetSize(); i++) {
        int id = m_clbPages.AddString(ccpi.Name(m_cdaPages[i]));
        m_clbPages.SetItemData(id, m_cdaPages[i]);
    }

    //  The one to select is the current one

    for (i = 0; i < m_cdaPages.GetSize(); i++)
        if  (m_uidCurrent == m_clbPages.GetItemData(i))
        break;

    if  (i < m_cdaPages.GetSize())
        m_clbPages.SetCurSel(i);
    else {
        m_uidCurrent = (unsigned) m_clbPages.GetItemData(0);
        m_clbPages.SetCurSel(0);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
}

//  When a new code page is selected, record its identity.

void CSelectCodePage::OnSelchangeSupportedPages() {
	//  Determine what the newly selected page is.

    int idCurrent = m_clbPages.GetCurSel();

    if  (idCurrent < 0)
        return;

    m_uidCurrent = (unsigned) m_clbPages.GetItemData(idCurrent);
}

void CSelectCodePage::OnDblclkSupportedPages() {
    CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CGPDSelection property page

CGPDSelection::CGPDSelection(CNewConvertWizard& cnpwOwner) :
	CPropertyPage(CGPDSelection::IDD), m_cnpwOwner(cnpwOwner),
	m_ceclbGPDInfo(&m_ceModelName, &m_cecebFileName),
	m_cecebFileName(&m_ceclbGPDInfo)
{
	//{{AFX_DATA_INIT(CGPDSelection)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Initially, the Select All / Deselect All button is set to Select All.

	m_bBtnStateIsSelect = true ;
}


CGPDSelection::~CGPDSelection()
{
}


void CGPDSelection::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGPDSelection)
	DDX_Control(pDX, IDC_GPDSelBtn, m_cbGPDSelBtn);
	DDX_Control(pDX, IDC_ECValue, m_cecebFileName);
	DDX_Control(pDX, IDC_ECName, m_ceModelName);
	DDX_Control(pDX, IDC_ECList, m_ceclbGPDInfo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGPDSelection, CPropertyPage)
	//{{AFX_MSG_MAP(CGPDSelection)
	ON_BN_CLICKED(IDC_GPDSelBtn, OnGPDSelBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGPDSelection message handlers

BOOL CGPDSelection::OnSetActive()
{
    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;
	
	// Get the current GPD model names and file names.

	CProjectRecord& cpr = m_cnpwOwner.Project() ;
	CStringArray csamodels, csafiles ;
	if (!cpr.GetGPDModelInfo(&csamodels, &csafiles)) {
        AfxMessageBox(IDS_GPDSelInitFailed) ;
		return FALSE ;
	} ;

	// Load the Edit Control with the data collected above and do the rest of
	// the initialization that is needed.

	//if (!m_ceclbGPDInfo.Init(csamodels, csafiles, 110)) {
	if (!m_ceclbGPDInfo.Init(csamodels, csafiles, 120)) {
        AfxMessageBox(IDS_GPDSelInitFailed) ;
		return FALSE ;
	} ;

	return CPropertyPage::OnSetActive() ;
}


BOOL CGPDSelection::OnWizardFinish()
{
	// Save and verify the GPD info.  Return 0 if this fails so that the
	// wizard won't close.

	if (!GPDInfoSaveAndVerify(true))
		return 0 ;

    //  This might take a while, so...

    CWaitCursor cwc ;

	CProjectRecord& cpr = m_cnpwOwner.Project() ;

	// Continue with the conversion process.  Start by loading the PFMs and
	// CTTs.

	if  (!cpr.LoadFontData()) {
		// Display error message(s) if the fonts could not be loaded.

		cpr.CloseConvLogFile() ;
		if (cpr.ThereAreConvErrors()) {
			CString csmsg ;
			csmsg.Format(IDS_FatalConvErrors, cpr.GetConvLogFileName()) ;
			AfxMessageBox(csmsg) ;
		} ;

		m_cnpwOwner.EndDialog(IDCANCEL) ;
        return  TRUE ;
    }

    //  We now need to generate ALL of the necessary files

    BOOL brc = cpr.GenerateTargets(m_cnpwOwner.GPDConvertFlag()) ;

	// Close the conversion logging file.

	cpr.CloseConvLogFile() ;

	// Tell the user if some conversion errors were logged.

	if (cpr.ThereAreConvErrors()) {
		CString csmsg ;
		csmsg.Format(IDS_ConvErrors, cpr.GetConvLogFileName()) ;
		AfxMessageBox(csmsg) ;
	} ;

	// Handle the failure of the GenerateTargets step

	if (!brc) {
		m_cnpwOwner.EndDialog(IDCANCEL) ;
        return  TRUE ;
	} ;

	// Copy standard file to the new driver's directory

	try {
		CString cssrc, csdest ;
		cssrc = ThisApp().GetAppPath() + _T("stdnames.gpd") ;
		csdest = cpr.GetW2000Path() + _T("\\") + _T("stdnames.gpd") ;
		CopyFile(cssrc, csdest, FALSE) ;
		//cssrc = ThisApp().GetAppPath() + _T("common.rc") ;
		//csdest = cpr.GetW2000Path() + _T("\\") + _T("common.rc") ;
		//CopyFile(cssrc, csdest, FALSE) ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return  FALSE ;
    }

    return  cpr.ConversionsComplete() ;
}


LRESULT CGPDSelection::OnWizardBack()
{
	// Save the GPD info.  Return -1 if this fails so that the wizard page
	// won't change.  (Probably won't fail.)

	if (!GPDInfoSaveAndVerify(false))
		return -1 ;

	return CPropertyPage::OnWizardBack() ;
}


bool CGPDSelection::GPDInfoSaveAndVerify(bool bverifydata)
{
	// Get the file names from the Edit Control.

	CStringArray csafiles ;
	m_ceclbGPDInfo.GetGPDInfo(csafiles) ;

	// If verification is requested and there are no selected files, ask the
	// user if that is what he wants.  If no, return false to indicate that
	// GPD selection should continue.

	if (bverifydata) {
		int numelts = (int)csafiles.GetSize() ;
		for (int n = 0 ; n < numelts ; n++) {
			if (!csafiles[n].IsEmpty())
				break ;
		} ;
		if (n >= numelts) {
			n = AfxMessageBox(IDS_NoGPDsPrompt, MB_YESNO | MB_ICONQUESTION) ;
			if (n == IDYES)
				return 0 ;
		} ;
	} ;
	
	// Send the GPD file names back to the driver conversion code and verify
	// them if requested.  If the verification fails, select the offending
	// list box entry and return false to indicate that verification failed.

	CProjectRecord& cpr = m_cnpwOwner.Project() ;
	int nidx = cpr.SaveVerGPDFNames(csafiles, bverifydata) ;
	if (nidx >= 0) {
		m_ceclbGPDInfo.SelectLBEntry(nidx) ;
		return false ;
	} ;

	// All went well so...

	return true ;
}


void CGPDSelection::OnGPDSelBtn()
{
	// Get the file names and model names from the Edit Control.

	CStringArray csafiles, csamodels ;
	m_ceclbGPDInfo.GetGPDInfo(csafiles, &csamodels) ;

	// Models are selected by generating a file name for them.  Select all
	// unselected models when appropriate...
	
	if (m_bBtnStateIsSelect) {
		CProjectRecord& cpr = m_cnpwOwner.Project() ;
		cpr.GenerateGPDFileNames(csamodels, csafiles) ;

	// ...Otherwise, deselect all models by deleting their file names

	} else {
		int numelts = (int)csafiles.GetSize() ;
		for (int n = 0 ; n < numelts ; n++)
			csafiles[n] = _T("") ;
	} ;

	// Reinitialize the edit control with the modified data.

	m_ceclbGPDInfo.Init(csamodels, csafiles, 120) ;

	// Change the button caption and the button state flag

	CString cscaption ;
	cscaption.LoadString((m_bBtnStateIsSelect) ? IDS_DeselectAll : IDS_SelectAll) ;
	m_cbGPDSelBtn.SetWindowText(cscaption) ;
	m_bBtnStateIsSelect = !m_bBtnStateIsSelect ;
}


/////////////////////////////////////////////////////////////////////////////
// CDefaultCodePageSel property page

CDefaultCodePageSel::CDefaultCodePageSel(CNewConvertWizard& cnpwOwner) :
	CPropertyPage(CDefaultCodePageSel::IDD), m_cnpwOwner(cnpwOwner),
	bInitialized(false)
{
	//{{AFX_DATA_INIT(CDefaultCodePageSel)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


CDefaultCodePageSel::~CDefaultCodePageSel()
{
}


void CDefaultCodePageSel::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDefaultCodePageSel)
	DDX_Control(pDX, IDC_CodePageList, m_clbCodePages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDefaultCodePageSel, CPropertyPage)
	//{{AFX_MSG_MAP(CDefaultCodePageSel)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDefaultCodePageSel message handlers

BOOL CDefaultCodePageSel::OnSetActive()
{
	// Do nothing if the page has been activated already.
	// raid 118881
	m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	if (bInitialized)  // if back from the next property
		return CPropertyPage::OnSetActive() ;

	// Find out how many code pages are installed on the machine.

	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		// There are 3 code pages that seem to make MultiByteToWideChar() to 
		// fail.  Don't let the user choose one of those code pages unless
		// he knows the secret password (ie, undocument command line switch
		// 'CP').

		if (ThisApp().m_bExcludeBadCodePages)
			if (dwcp == 1361 || dwcp == 28595 || dwcp == 28597) 
				continue ;

		wsprintf(accp, "%5d", dwcp) ;
		n = m_clbCodePages.AddString(accp) ;
		if (dwcp == dwdefcp)
			m_clbCodePages.SetCurSel(n) ;
	} ;

	// Everything is set up now so call the base routine.
	
	bInitialized = true ;
	return CPropertyPage::OnSetActive() ;
}


LRESULT CDefaultCodePageSel::OnWizardNext()
{
	// Get the index of the currently selected list box item.

	int nsel ;
	if ((nsel = m_clbCodePages.GetCurSel()) == LB_ERR) {
		AfxMessageBox(IDS_MustSelCP, MB_ICONINFORMATION) ;
		return -1 ;
	} ;

	// Get the selected list box string.

	CString cs ;
	m_clbCodePages.GetText(nsel, cs) ;

	// Turn the string into a number and convert the number into the 
	// corresponding predefined GTT code for Far East code pages when
	// applicable.

	short scp = (short) atoi(cs) ;
	DWORD dwcp = (DWORD) scp ;				// Keep copy of real CP
	switch (scp) {
		case 932:
			scp = -17 ;
			break ;
		case 936:
			scp = -16 ;
			break ;
		case 949:
			scp = -18 ;
			break ;
		case 950:
			scp = -10 ;
			break ;
	} ;

	// Save the default "code page" number in the project class instance.

	CProjectRecord& cpr = m_cnpwOwner.Project() ;
	cpr.SetDefaultCodePageNum(dwcp) ;		// Save real CP number first
	dwcp = (DWORD) scp ;
	cpr.SetDefaultCodePage(dwcp) ;

	// All went well so...
	
	return CPropertyPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projnode.cpp ===
/******************************************************************************

  Source File:  Project Node.CPP

  This implements the CProjectNode class which alows individual nodes in the
  tree view to control their behavior without the control itself having to know
  what all that behavior is.

  The original header file (from the prototype) said this class didn't need an
  implementation file, but this no longer makes sense, so it's bite the bullet
  time here at Pretty Penny Enterprises...

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard#Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "Resource.H"
#include    "ProjNode.H"
#include	"gtt.h"
#include	"fontinfo.h"
#include	"rcfile.h"
#include	"projrec.h"
#include	"comctrls.h"
#include	"StrEdit.h"


IMPLEMENT_SERIAL(CBasicNode, CObject, 0)

CBasicNode::CBasicNode() { 
    m_pcmcwEdit = NULL; 
    m_pcdOwner = NULL;
    m_pctcOwner = NULL;
    m_hti = NULL;
    m_pcbnWorkspace = NULL;
	m_bUniqueNameChange = false ;
}

CBasicNode::~CBasicNode() {
    if (m_pcmcwEdit)
		if (IsWindow(m_pcmcwEdit->m_hWnd))
			m_pcmcwEdit -> DestroyWindow();
}


// Changed() - If the node contains a document pointer, use it to indicate
// that the document does or does not need to be saved.  If the RC file
// needs to be rewritten, call the routine in the document class to save
// this info.

void CBasicNode::Changed(BOOL bModified, BOOL bWriteRC) 
{ 
    if (m_pcdOwner) {
		m_pcdOwner->SetModifiedFlag(bModified) ; 
		if (bWriteRC) 
			((CProjectRecord *) m_pcdOwner)->SetRCModifiedFlag(TRUE) ;
	} ;
}


//  Name ourselves and children- default to just our name, no children

void    CBasicNode::Fill(CTreeCtrl *pctcWhere, HTREEITEM htiParent) {
    m_pctcOwner = pctcWhere;
    m_hti = pctcWhere -> InsertItem(m_csName, htiParent);
    pctcWhere -> SetItemData(m_hti, PtrToUlong(this));
}

//  Display a context menu using the ID array, if it has any members

void    CBasicNode::ContextMenu(CWnd *pcw, CPoint cp) {

    if  (!m_cwaMenuID.GetSize())
        return;

    CMenu   cmThis;

    if  (!cmThis.CreatePopupMenu())
        return;

    for (int i = 0; i < m_cwaMenuID.GetSize(); i++) {

        if  (m_cwaMenuID[i]) {
            CString csWork;

            csWork.LoadString(m_cwaMenuID[i]);
            cmThis.AppendMenu(MF_STRING | MF_ENABLED, m_cwaMenuID[i], csWork);
        }
        else
            cmThis.AppendMenu(MF_SEPARATOR);
    }

    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cp.x, cp.y, pcw);
}



//  This override is called if our label is edited, or we are otherwise
//  renamed...
BOOL    CBasicNode::Rename(LPCTSTR lpstrNewName) {
    if  (!lpstrNewName)
        return  FALSE;

    if  (lpstrNewName == m_csName)
        return  TRUE;

    //  We'll return TRUE, unless the rename produces an exception
    try {
        m_csName = lpstrNewName;
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    WorkspaceChange();
    return  TRUE;
}

void    CBasicNode::Edit() {
    if  (!m_pcmcwEdit)
        m_pcmcwEdit = CreateEditor();
    else {
        if  (IsWindow(m_pcmcwEdit -> m_hWnd))
            m_pcmcwEdit -> ActivateFrame();
		else
			m_pcmcwEdit = CreateEditor();
	} ;
}


/******************************************************************************\

  CBasicNode::GetEditor

  Get the node's editor frame pointer and check to see if it is valid.  Return
  it if it is valid.  If it isn't valid, clear the pointer and return NULL.

******************************************************************************/

CMDIChildWnd* CBasicNode::GetEditor()
{ 
    if (m_pcmcwEdit != NULL && !IsWindow(m_pcmcwEdit->m_hWnd))
		m_pcmcwEdit = NULL ;

	return m_pcmcwEdit ;
}


/******************************************************************************\

  CBasicNode::UniqueName

  Add a character or replace a character in the node's name to try to make it
  unique.  The new character will be in one of the following ranges a-z or 
  0-9.

******************************************************************************/

void CBasicNode::UniqueName(bool bsizematters, bool bfile, LPCTSTR lpstrpath)
{
	CString	csnew(m_csName) ;
	TCHAR	tch ;				// Unique character
	int		nposlen ;			// Name's change position/length

	// Determine the 0-based length of the name

	nposlen = csnew.GetLength() - 1 ;

	// If the name has been changed before, use the last "unique" character to
	// determine the new unique character.  Then replace the old unique 
	// character with the new unique character.

	if (m_bUniqueNameChange) {
		tch = csnew.GetAt(nposlen) + 1 ;
		if (tch == _T('{'))
			tch = _T('0') ;
		else if (tch == _T(':'))
			tch = _T('a') ;
		csnew.SetAt(nposlen, tch) ;

	// If the name has not been changed before, add a unique character to the
	// end of the name if this won't make the name longer than 8 characters
	// or we don't care how long the name is.  Otherwise, replace the last
	// character with the new unique character.

	} else {
		if (nposlen < 7 || !bsizematters)
			csnew += _T("a") ;
		else
			csnew.SetAt(nposlen, _T('a')) ;
	} ;

	// Rename the node/file by calling the appropriate Rename() routine.  If
	// CFileNode::Rename() m_csName must be zapped to force it to take the
	// correct code path.  In addition, the file's path must be prepended to
	// its name.

	if (bfile) {
		m_csName.Empty() ;
		csnew = lpstrpath + csnew ;
		Rename(csnew) ;
	} else
		CBasicNode::Rename(csnew) ;
	
	// Indicate that the name has been changed.

	m_bUniqueNameChange = true ;
}


/******************************************************************************\

  CBasicNode::Serialize

  Pretty simple- the names the only field we will be keeping...

******************************************************************************/

void    CBasicNode::Serialize(CArchive& car) {
    CObject::Serialize(car);
    if  (car.IsLoading())
        car >> m_csName;
    else
        car << m_csName;
}

/******************************************************************************

  CFixedNode implementation

******************************************************************************/

IMPLEMENT_DYNAMIC(CFixedNode, CBasicNode)

CFixedNode::CFixedNode(unsigned uidName, CSafeObArray& csoa, FIXEDNODETYPE fnt, 
                       CMultiDocTemplate *pcmdt, CRuntimeClass *pcrc) :
    m_csoaDescendants(csoa) {
    m_uidName = uidName;
	m_fntType = fnt;
    m_pcmdt = pcmdt;
    m_pcrc = pcrc;
}


/******************************************************************************

  CFixedNode::Zap

  This method is called when an underlying object is to be destroyed.  It finds
  a matching pointer in the array, and then deletes that entry.

******************************************************************************/

void CFixedNode::Zap(CProjectNode *pcpn, BOOL bdelfile)
{
	// Try to find the node we want to delete in the array of descendants for
	// this node.  Just return if it can't be found.

    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
        if  (pcpn == m_csoaDescendants[u]) 
			break ;
	} ;
	if (u >= m_csoaDescendants.GetSize())
		return ;

	// If the user wants to remove the file too, do it.

    if  (bdelfile)
        DeleteFile(pcpn->FileName()) ;

	// Save a copy of the node's tree handle
		
    HTREEITEM htiGone = pcpn->Handle() ;

	// Remove the project node from the array of descendants and delete it from
	// the tree.

    m_csoaDescendants.RemoveAt(u);
    m_pctcOwner -> DeleteItem(htiGone);
    
	// Update this (fixed) node's entry in the tree so that it will accurately
	// reflect the new number of descendants.

	CString csWork;
    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);

	// Mark the workspace and RC file as needing to be saved.

    WorkspaceChange(TRUE, TRUE);
}


/******************************************************************************

  CFixedNode::Import

  This member function will import one or more files of the given type if there
  is a document template and dynamic constructor available.  It uses the 
  template to customize the File Open dialog, and the constructor to build the
  elements.
  
  NOTE:  There is a fair amount of common code between this routine and
  Copy().  If a bug/change is made in this routine, check to see if the 
  same change needs to be made to Copy().

******************************************************************************/

void    CFixedNode::Import() {
    if  (!m_pcmdt || !m_pcrc || !m_pcrc -> m_pfnCreateObject)
        return;

    CString csExtension, csFilter;

    m_pcmdt -> GetDocString(csExtension, CDocTemplate::filterExt); 
    m_pcmdt -> GetDocString(csFilter, CDocTemplate::filterName);
    csFilter += _T("|*") + csExtension + _T("||");

    CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        m_pctcOwner);
	// raid 104822
    cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}

	// Get the first, new RC ID to use if this is a resource node.

	int nnewrcid = GetNextRCID() ;

	// Build a path to the directory for the added files.  The path is node
	// type specific.

	CString csnodepath = ((CDriverResources *) m_pcbnWorkspace)->GetW2000Path() ;
	if (csnodepath.Right(1) != _T("\\"))
		csnodepath += _T("\\") ;
	CString cstmp ;
	if (m_fntType == FNT_UFMS)
		cstmp.LoadString(IDS_FontDir) ;
	else if (m_fntType == FNT_GTTS)
		cstmp.LoadString(IDS_GTTDir) ;
	csnodepath += cstmp ;

    //  Import all of the named files...

	CString cssrc ;				// Source fspec
    for (POSITION pos = cfd.GetStartPosition(); pos; ) {

        //  Create the underlying object using dynamic creation.  Only a 
        //  CProjectNode has the required function, here.

        CProjectNode*   pcpn = (CProjectNode *) m_pcrc -> CreateObject();
        if  (!pcpn || !pcpn -> IsKindOf(RUNTIME_CLASS(CProjectNode))) {
            TRACE("Imported object not derived from CProjectNode");
            delete  pcpn;
            continue;
        }

		// If the file is already in the right directory, make sure that it is
		// not already a part of the workspace.

		cssrc = cfd.GetNextPathName(pos) ;
		if (csnodepath.CompareNoCase(cssrc.Left(csnodepath.GetLength())) == 0) {
			if (IsFileInWorkspace(cssrc)) {
				// Build and display error message.  Then skip this file.
				CString csmsg ;
				csmsg.Format(IDS_AddDupError, cssrc) ;
				AfxMessageBox(csmsg) ;
			    delete  pcpn ;
		        continue ;
	        } ;
			cstmp = cssrc ;

		// If the file is not in the right directory, try to copy it there.

		} else {
			cstmp = cssrc.Mid(cssrc.ReverseFind(_T('\\')) + 1) ;
			cstmp =	csnodepath + cstmp ;
			if (!CopyFile(cssrc, cstmp, TRUE)) {
				// Build and display error message.  Then skip this file.
				CString csmsg ;
				csmsg.Format(IDS_AddCopyFailed, cssrc,
							 csnodepath.Left(csnodepath.GetLength() - 1)) ;
				csmsg += cstmp ;
				AfxMessageBox(csmsg) ;
			    delete  pcpn ;
		        continue ;
			} ;
		} ;

		// Initialize the new node
		// RAID: 17897 : 
		// Add CModelData::GetKeywordValue
		// CBN::Rename(ModelName) after SetFileName() by pcpn->Rename(ModelName)
       CModelData cmd;

		pcpn -> SetFileName(cstmp); //goes to CBN::Rename(FileName)
        if (m_fntType == FNT_GPDS)   //add 1/3
			pcpn ->Rename(cmd.GetKeywordValue(cstmp,_T("ModelName")));		 //add 2/3
		else						 //add 3/3
			pcpn -> Rename(pcpn -> FileTitle());
        
		pcpn -> NoteOwner(*m_pcdOwner);
        pcpn -> SetWorkspace(m_pcbnWorkspace);
		m_csoaDescendants.Add(pcpn);
        WorkspaceChange(TRUE, TRUE);
        pcpn -> EditorInfo(m_pcmdt);

		
		// load actual UFM, GTT data.	// raid 128653
		if (m_fntType == FNT_UFMS ) {
			
			CFontInfo *pfi = (CFontInfo* )pcpn;
			
			CDriverResources* pcdr = (CDriverResources*) pfi->GetWorkspace() ;

			pcdr -> LinkAndLoadFont(*pfi,TRUE);
				
		} 

		else if (m_fntType == FNT_GTTS) {

			CGlyphMap *pcgm = (CGlyphMap* ) pcpn;

			pcgm ->Load();
		
		} ;
			
		// Add the new node to the workspace view

        pcpn -> Fill(m_pctcOwner, m_hti, nnewrcid++, m_fntType);
    } ;

	delete cfd.m_ofn.lpstrFile;
    //  Now, update our own appearance (get the count right)

    CString csWork;
    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);
}


/******************************************************************************

  CFixedNode::Copy

  This member function will make a copy of one the this node's children.  The
  UI needed to determine the source child and the destination file name was
  done in CProjectView and the information is passed into this routine.
  
  NOTE:  There is a fair amount of common code between this routine and
  Import().  If a bug/change is made in this routine, check to see if the 
  same change needs to be made to Import().

******************************************************************************/

void CFixedNode::Copy(CProjectNode *pcpnsrc, CString csorgdest)
{
	// Can't do anything if the following pointers are set.

    if  (!m_pcmdt || !m_pcrc || !m_pcrc -> m_pfnCreateObject)
        return;

    // Build the destination filespec by isolating the name in the destination
	// string and adding on this source's path and extension.  

	CString csdest(csorgdest) ;
	int npos ;
	if ((npos = csdest.ReverseFind(_T('\\'))) != -1)
		csdest = csdest.Mid(npos + 1) ;
	if ((npos = csdest.ReverseFind(_T('.'))) != -1)
		csdest = csdest.Left(npos) ;
	if (csdest.GetLength() <= 0) {
		csdest.Format(IDS_CopyNameError, csorgdest) ;
		AfxMessageBox(csdest) ;
		return ;
	} ;
	csdest = csdest + pcpnsrc->FileExt() ;
	CString csdesttitleext(csdest) ;
	csdest = pcpnsrc->FilePath() + csdest ;

    // Copy the source file to the destination

	if (!CopyFile(pcpnsrc->FileName(), csdest, TRUE)) {
		// Build and display error message.  Then return.
		CString csmsg, cspath(pcpnsrc->FilePath()) ;
		cspath.Left(cspath.GetLength() - 1) ;
		csmsg.Format(IDS_CopyCopyFailed, pcpnsrc->FileTitleExt(),
					 csdesttitleext, cspath) ;
		AfxMessageBox(csmsg) ;
		return ;
	} ;

    //  Create the underlying object using dynamic creation.  Only a 
    //  CProjectNode has the required function, here.

	int nnewrcid = GetNextRCID() ;
    CProjectNode*   pcpn = (CProjectNode *) m_pcrc -> CreateObject();
    if  (!pcpn || !pcpn -> IsKindOf(RUNTIME_CLASS(CProjectNode))) {
        TRACE("Imported object not derived from CProjectNode");
        delete  pcpn;
        return;
    } ;

	// Initialize the new node

    pcpn->SetFileName(csdest);
    pcpn->Rename(pcpn->FileTitle());
    pcpn->NoteOwner(*m_pcdOwner);
    pcpn->SetWorkspace(m_pcbnWorkspace);
	m_csoaDescendants.Add(pcpn);
    WorkspaceChange(TRUE, TRUE);
    pcpn->EditorInfo(m_pcmdt);

	// Add the new node to the workspace view

    pcpn->Fill(m_pctcOwner, m_hti, nnewrcid, m_fntType);

    //  Now, update our own appearance (get the count right)

    CString csWork;
    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);

	// Last but not least...  If a new GPD was just added, tell the user to
	// change the name in the GPD to make sure it is unique.

	if (m_fntType == FNT_GPDS) {
		csdest.Format(IDS_GPDReminder, pcpn->Name()) ;
		AfxMessageBox(csdest) ;
	} ;
}


/******************************************************************************

  CFixedNode::GetNextRCID

  If this is a resource (UFM or GTT) node, all of its descendants have RC IDs.
  Find the largest one and return one greater than that for use in a new
  descendant.  If this is not a resource node, just return -1.

******************************************************************************/

int CFixedNode::GetNextRCID()
{
	// Return -1 if this is not a resource node that requires RC IDs

	if (m_fntType != FNT_UFMS && m_fntType != FNT_GTTS)
		return -1 ;

	// Find the largest used RC ID.  Use the descendant's index if it does not
	// have an RC ID.

	int nlargestusedid = 0 ;
	int nrcid ;
    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
		nrcid = ((CProjectNode *) m_csoaDescendants[u])->nGetRCID() ;
		if (nrcid == -1)
			nrcid = (int) u + 1 ;
		if (nrcid > nlargestusedid)
			nlargestusedid = nrcid ;
	} ;

	// Return the next RC ID to use

	return (nlargestusedid + 1) ;
}


/******************************************************************************

  CFixedNode::IsFileInWorkspace

  Check the node's descendants to see if one of them matches the given filespec.
  Return true if a match is found.  Otherwise, return false.

******************************************************************************/

bool CFixedNode::IsFileInWorkspace(LPCTSTR strfspec)
{
	CString		csdescfspec ;	// Filespec for current descendant

    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
		csdescfspec = ((CProjectNode *) m_csoaDescendants[u])->FileName() ;
		if (csdescfspec.CompareNoCase(strfspec) == 0)
			return true ;
	} ;

	return false ;
}


/******************************************************************************

  CFixedNode::IsRCIDUnique

  Check the node's descendants to see if one of them has the same RC ID as the
  one passed in.  Return true if a no match is found.  Otherwise, return false.

******************************************************************************/

bool CFixedNode::IsRCIDUnique(int nid) 
{
    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
		if (((CProjectNode *) m_csoaDescendants[u])->nGetRCID() == nid)
			return false ;
	}

	return true ;
}


/******************************************************************************

  CFixedNode::Fill

  This is a generic fill- the node names itself, then fills its node using the
  array of nodes given to it at init time.

******************************************************************************/

void    CFixedNode::Fill(CTreeCtrl *pctc, HTREEITEM hti) {
    CString csWork;

	// Add the number of descendants to the node's name IFF this is the UFMs,
	// GTTs, or GPDs nodes.  Then add the node to the tree.

    m_csName.LoadString(m_uidName);
    if (m_fntType == FNT_UFMS || m_fntType == FNT_GTTS || m_fntType == FNT_GPDS) {
		csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
	    m_csName += csWork;
	} ;
    CBasicNode::Fill(pctc, hti);

	// Add this node's descendants to the tree.

    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++)
		((CProjectNode *) m_csoaDescendants[u]) -> Fill(pctc, m_hti, u + 1, m_fntType) ;
}


/******************************************************************************

  CStringsNode implementation

******************************************************************************/

IMPLEMENT_DYNAMIC(CStringsNode, CBasicNode)

CStringsNode::CStringsNode(unsigned uidName, CSafeObArray& csoa, 
						   FIXEDNODETYPE fnt, CMultiDocTemplate *pcmdt, 
						   CRuntimeClass *pcrc) : m_csoaDescendants(csoa) {
    m_uidName = uidName;
	m_fntType = fnt;
    m_pcmdt = pcmdt;
    m_pcrc = pcrc;
	m_nFirstSelRCID = -1 ;	
}


/******************************************************************************

  CStringsNode::Fill

  This is a generic fill- the node names itself, then fills its node using the
  array of nodes given to it at init time.

******************************************************************************/

void    CStringsNode::Fill(CTreeCtrl *pctc, HTREEITEM hti) {
    CString csWork;

	// Add this node to the tree

    m_csName.LoadString(m_uidName);
    CBasicNode::Fill(pctc, hti);
}


/*****************************************************************************

  CStringsNode::CreateEditor

  This member function launches an editing view for the strings.

******************************************************************************/

CMDIChildWnd* CStringsNode::CreateEditor()
{
	// Allocate and initialize the document.

	CProjectRecord* cpr = (CProjectRecord*) m_pcdOwner ;
    CStringEditorDoc* pcsed = new CStringEditorDoc(this, cpr, cpr->GetStrTable()) ;

	// Set the editor's title

	CString cstitle ;
	cstitle.Format(IDS_StringEditorTitle, cpr->DriverName()) ;
    pcsed->SetTitle(cstitle) ;	

	// Create the window.

    CMDIChildWnd* pcmcwnew ;
	pcmcwnew = (CMDIChildWnd *) m_pcmdt->CreateNewFrame(pcsed, NULL) ;

	// If the window was created, finish the initialization and return the 
	// frame pointer.  Otherwise, clean up and return NULL.

    if  (pcmcwnew) {
        m_pcmdt->InitialUpdateFrame(pcmcwnew, pcsed, TRUE) ;
        m_pcmdt->AddDocument(pcsed) ;
		return pcmcwnew ;
	} else {
		delete pcsed ;
		return NULL ;
	} ;
}


/******************************************************************************

  CFileNode implementation

******************************************************************************/

IMPLEMENT_SERIAL(CFileNode, CBasicNode, 0);

CFileNode::CFileNode() {
    m_cwaMenuID.Add(ID_RenameItem);
    m_bEditPath = FALSE;
    m_bCheckForValidity = TRUE;
}

/******************************************************************************

  CFileNode::Rename

  If there is no name currently, then see if the named file can be created.
  The other case, means the file should already be on the disk, so it is a bit 
  trickier.

  First, check to see if the name violates the current naming conventions.  If
  so, reject it.  Then attempt to move the file.  IF the name is OK and the
  file is moved, set the new name in the item label.  Always returns FALSE.

******************************************************************************/

BOOL    CFileNode::Rename(LPCTSTR lpstrNew) {
    CString csNew = lpstrNew;

    if  (!lpstrNew) {   //  This only happens if the label edit was canceled.
        csNew.LoadString(IDS_FileName);
        if  (m_pctcOwner)
            m_pctcOwner -> SetItemText(m_hti, csNew + ViewName());
        WorkspaceChange(TRUE, TRUE);	// ** Parameters might be wrong
        return  FALSE;
    }

	// Add an extension to the file name if it is needed.

    if  (m_csExtension.CompareNoCase(csNew.Right(m_csExtension.GetLength())))
        csNew += m_csExtension;

	// This path is taken when a driver is being converted.  
	
    if  (m_csName.IsEmpty()) {
        CFile   cfTemp;

        //  This check needs to be optional since in some instances, we know
        //  the name is valid because the file is open, and we're just trying
        //  to collect the name.

        if  (!cfTemp.Open(csNew, CFile::modeCreate | CFile::modeNoTruncate |
            CFile::modeWrite | CFile::shareDenyNone) && m_bCheckForValidity) {
            CString csWork, csDisplay;

            csWork.LoadString(IDS_InvalidFilename);
            csDisplay.Format(csWork, (LPCTSTR) csNew);
            AfxMessageBox(csDisplay);
            return  FALSE;
        }

        try {
            m_csPath = cfTemp.GetFilePath();
            m_csPath = m_csPath.Left(1 + m_csPath.ReverseFind(_T('\\')));
        }
        catch   (CException *pce) {
            pce -> ReportError();
            pce -> Delete();
            return  FALSE;
        }

        //  If the file type isn't registered, then GetFileTitle returns the
        //  extension, so strip it!

        csNew = cfTemp.GetFileTitle();
        if  (!m_csExtension.CompareNoCase(csNew.Right(
             m_csExtension.GetLength())))
            csNew = csNew.Left(csNew.GetLength() - m_csExtension.GetLength());

        return  CBasicNode::Rename(csNew);  //  OK from this path
    }

    //  Strip any path if it cannot be changed, and substitute the real one

    if  (!m_bEditPath)
        csNew = m_csPath + csNew.Mid(1 + csNew.ReverseFind(_T('\\')));

    try {
        LPSTR   lpstr;

        CFile::Rename(FullName(), csNew);

        GetFullPathName(csNew, MAX_PATH, csNew.GetBuffer(MAX_PATH), &lpstr);
        csNew.ReleaseBuffer();
        m_csPath = csNew.Left(1 + csNew.ReverseFind(_T('\\')));
        csNew = csNew.Mid(m_csPath.GetLength());
        m_csName = csNew.Left(csNew.GetLength() - 
            m_csExtension.GetLength());
        csNew.LoadString(IDS_FileName);
        if  (m_pctcOwner)
            m_pctcOwner -> SetItemText(m_hti, csNew + m_csName);
        WorkspaceChange(TRUE, TRUE);
        return  FALSE;  //  Force the change (above) to be kept.
    }
    catch   (CFileException *pcfe) {    //  Don't get a file name with statics
        if  (pcfe -> m_cause == ERROR_FILE_NOT_FOUND)
            csNew = FullName();
        pcfe -> m_strFileName = csNew;
        pcfe -> ReportError();
        pcfe -> Delete();
        return  FALSE;
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }
}


/******************************************************************************

  CFileNode::SetPathAndName

  Set the node's path and file name in a way that works when someone has
  directly editted the UFM table in the RC file.  This is the only time that
  this routine should be called.  It doesn't perform any checks.  We rely on the
  person who editted the RC file to have done it correctly.

******************************************************************************/

void CFileNode::SetPathAndName(LPCTSTR lpstrpath, LPCTSTR lpstrname)
{
	m_csPath = lpstrpath ;
	m_csName = lpstrname ;
}


/******************************************************************************

  CFileNode::CanEdit

  This will return TRUE, but it will first have to remove the File Name: stuff
  from the label, so we can get a cleaner edit.

******************************************************************************/

BOOL    CFileNode::CanEdit() const {

    CEdit*   pce = m_pctcOwner -> GetEditControl();
    if  (pce)
        pce -> SetWindowText(m_bEditPath ? m_csPath + m_csName : m_csName);
    return  !!pce;
}

/******************************************************************************

  CFileNode::Fill

  We play a bit of a game here, changing our name temporarily to use the base 
  class implementation.

******************************************************************************/

void    CFileNode::Fill(CTreeCtrl* pctc, HTREEITEM htiParent) {
    CString csTemp = Name();

    m_csName.LoadString(IDS_FileName);
    m_csName += csTemp;
    CBasicNode::Fill(pctc, htiParent);
    m_csName = csTemp;
}


/******************************************************************************

  CFileNode::Serialize

  Since the name is covered by the base class, we only need to serialize the 
  boolean controlling long/short file names.  The file paths are only handled
  in down level versions of the MDW. 

******************************************************************************/

void    CFileNode::Serialize(CArchive& car) 
{
    CBasicNode::Serialize(car) ;

	// The file path is only kept in the MDW file when the MDW version is less
	// than MDW_VER_NO_FILE_PATHS.  Process it in this case.

	unsigned uver = ((CProjectRecord*) car.m_pDocument)->GetMDWVersion() ;
	if (uver >= MDW_VER_YES_FILE_PATHS) {  // raid 123448
		if  (car.IsLoading())
			car >> m_csPath ;
		else
			car << m_csPath ;
	} ;
}


/******************************************************************************

  CProjectNode implementation

******************************************************************************/

IMPLEMENT_SERIAL(CProjectNode, CBasicNode, 1)

CProjectNode::CProjectNode() 
{
    m_pcmdt = NULL ;

	m_bRefFlag = false ;		// Clear the referenced flag
}

void    CProjectNode::Fill(CTreeCtrl *pctc, HTREEITEM hti, unsigned urcid,
						   FIXEDNODETYPE fnt)
{
	// Add this node to the tree

    CBasicNode::Fill(pctc, hti);

	// Add this node's file node to the tree

    m_cfn.SetWorkspace(m_pcbnWorkspace);
    m_cfn.Fill(pctc, m_hti);
	
	// Add this node's RC ID node to the tree IFF it needs to use it

	if (fnt == FNT_UFMS || fnt == FNT_GTTS) {
		m_crinRCID.SetWorkspace(m_pcbnWorkspace) ;
		m_crinRCID.Fill(pctc, m_hti, urcid, fnt) ; 
	} ;
}


void CProjectNode::Serialize(CArchive& car) 
{
    CBasicNode::Serialize(car);
    m_cfn.Serialize(car);
    m_crinRCID.Serialize(car);
}


void CProjectNode::ChangeID(CRCIDNode* prcidn, int nnewid, CString csrestype)
{
    //  Walk back up the hierarchy to find this project node's owning Fixed node.

    CFixedNode&  cfn = * (CFixedNode *) m_pctcOwner->GetItemData(
        m_pctcOwner->GetParentItem(m_hti)) ;
    ASSERT(cfn.IsKindOf(RUNTIME_CLASS(CFixedNode))) ;

	// Make sure that the new ID is unique for this resource type

	if (!cfn.IsRCIDUnique(nnewid)) {
		CString csmsg ;
		csmsg.Format(IDS_IDNotUnique, nnewid, csrestype) ;
		AfxMessageBox(csmsg) ;
		return ;
	} ;

	// Change this node's ID, update the display, and mark the workspace and
	// RC file as needing to be saved.

	nSetRCID(nnewid) ;
	m_crinRCID.BuildDisplayName() ;
	m_pctcOwner->SetItemText(m_crinRCID.Handle(), m_crinRCID.Name()) ; 
    WorkspaceChange(TRUE, TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
//	CRCIDNode Implementation
//
//	Note: This class must be enhanced to support extra functionality.
//
    
IMPLEMENT_SERIAL(CRCIDNode, CBasicNode, 0) ;

CRCIDNode::CRCIDNode() 
{
	// Initialze as unset or unknown.

	m_nRCID = -9999 ;				
	m_fntType = FNT_UNKNOWN ;

	// Build the context sensitive menu for this node type

    m_cwaMenuID.Add(ID_ChangeID);
}


/******************************************************************************

  CRCIDNode::Fill

  Add the RC ID node for the current resource to the workspace view.

******************************************************************************/

void CRCIDNode::Fill(CTreeCtrl *pctc, HTREEITEM hti, int nid, FIXEDNODETYPE fnt) 
{
	// Set the RC ID and the node type.  The info passed in should only be used
	// if these member variables are "unset".  (This class has other functions
	// that can be used to change these variables once they've been set.)
	
	if (m_nRCID == -9999)	// raid 167257
		m_nRCID = nid ;
	if (m_fntType == FNT_UNKNOWN)
		m_fntType = fnt ;

	// Build the string to display for this node based on the RC ID & node type

	BuildDisplayName() ;

	// Add the node to the view

    CBasicNode::Fill(pctc, hti);
}


void CRCIDNode::BuildDisplayName()
{
	CString csid ;				// Holds ID string
	
	// Build the string to display for this node based on the RC ID & node type

	if (m_nRCID != -9999)
		csid.Format(_T("%d"), m_nRCID) ;
	else
		csid.LoadString(IDS_Unknown) ;
	switch (m_fntType) {
		case FNT_UFMS:
			m_csName.Format(IDS_RCUFM, csid) ;
			break ;
		case FNT_GTTS:
			m_csName.Format(IDS_RCGTT, csid) ;
			break ;
		default :
			m_csName.Format(IDS_RCUNK, csid) ;
			break ;
	} ;
}


void    CRCIDNode::Serialize(CArchive& car)
{
	int		nfnt = (int) m_fntType ;	// CArchive doesn't handle enumerations

    CBasicNode::Serialize(car);
    if  (car.IsLoading()) 
		car >> m_nRCID >> nfnt ;
    else
		car << m_nRCID << nfnt ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projrec.cpp ===
/******************************************************************************

  Source File:  Project Record.CPP

  This implements the project record class, which tracks the details for
  multiple mini-drivers.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@prodigy.net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "NewProj.H"
#include	"projnode.h"
#include	"StrEdit.h"
#include	"codepage.h"
#include	<io.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord

IMPLEMENT_DYNCREATE(CProjectRecord, CDocument)

BEGIN_MESSAGE_MAP(CProjectRecord, CDocument)
	//{{AFX_MSG_MAP(CProjectRecord)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord construction/destruction

CProjectRecord::CProjectRecord() {
	m_ufTargets = Win2000;
    m_ufStatus = 0;
	m_bRCModifiedFlag = FALSE ;
	m_ctRCFileTimeStamp = (time_t) 0 ;
	m_dwDefaultCodePage = 1252 ;	// Not always correct but better than nothing
	m_dwDefaultCodePageNum = 1252 ;	// Not always correct but better than nothing
}

CProjectRecord::~CProjectRecord() {
}


/******************************************************************************

  CProjectRecord::OnOpenDocument

  First, open the file directly and try to read version information from it.
  Complain and fail the open if the file's version is greater than the MDT's
  current version number.  IE, fail if someone is trying to open a workspace
  on a down level (older) version of the MDT.

  Second, open a workspace in the normal way.  Then check the workspace's
  version to see if it is out of date.  If it is and the user agrees, do what is
  necessary to bring it up to date and then save the updated workspace file.

  All version related upgrade work should be managed from this routine.
  Depending on the age of the workspace file, there may be multiple upgrade
  steps required.  Be that as it may, the user should only be prompted once.
  NEW UPGRADE CHECKS AND STEPS SHOULD FOLLOW THE FORMAT LAYED OUT BELOW.

  There are various other workspace related checks that need to be done.  For
  example, the timestamp of the RC file needs to be checked to see if it has
  been changed by something other than the the MDT.  That work should be done
  and/or managed by code in this routine, too.  If possible (and I'm not sure
  it is), prompt the user no more than once per file (eg, RC or INF) for these
  things, too.  AGAIN, FOLLOW THE FORMAT LAYED OUT BELOW.

  The last thing done in this routine is to try to verify and - if necessary -
  update the location of files in the workspace.  If this fails and the user
  doesn't want to continue anyway, the Open is failed.  See VerUpdateFilePaths()
  for more information.

******************************************************************************/

BOOL CProjectRecord::OnOpenDocument(LPCTSTR lpszPathName)
{
	// Complain and fail if the user is trying to open a bogus file.

	CString cstmp(lpszPathName), cstmp2 ;
	cstmp.MakeUpper() ;
	cstmp2.LoadString(IDS_MDWExtension) ;
	if (cstmp.Find(cstmp2) == -1) {
		cstmp.LoadString(IDS_UnExpFilTypError) ;
		AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
		return FALSE ;
	} ;

	// Start by reading the MDW file's version stamp.
	
	try {
		CFile cfmdw(lpszPathName, CFile::modeRead | CFile::shareDenyNone) ;
		cfmdw.Read(&m_mvMDWVersion, MDWVERSIONSIZE) ;
		cfmdw.Close() ;
	}
	catch (CException* pce) {
		pce->ReportError() ;
		pce->Delete() ;
		return FALSE ;
	} ;

	// If the version tag is invalid, set the version number to the
	// default version number; IE, 0.

	if (strncmp(m_mvMDWVersion.acvertag, VERTAGSTR, MDWVERSIONSIZE) != 0)
		m_mvMDWVersion.uvernum = MDW_DEFAULT_VERSION ;

	// Now. make sure that the MDW's version isn't newer than the MDT's version.

	if (m_mvMDWVersion.uvernum > MDW_CURRENT_VERSION) {
		CString csmsg, cstmp ;
		cstmp = lpszPathName ;
		int nloc = cstmp.ReverseFind(_T('\\')) ;
		if (nloc >= 0)
			cstmp = cstmp.Right(cstmp.GetLength() - nloc - 1) ;
		csmsg.Format(IDS_MDWTooNewError, cstmp, m_mvMDWVersion.uvernum,
					 MDW_CURRENT_VERSION) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return FALSE ;
	} ;

	if (!CDocument::OnOpenDocument(lpszPathName))
		return FALSE ;

	// Save the project file's filespec.

	m_csProjFSpec = lpszPathName ;

	// If the workspace version is too old to upgrade, just return TRUE to
	// indicate that the file was successfully opened and that nothing else
	// can be done.

	if (m_mvMDWVersion.uvernum < MDW_FIRST_UPGRADABLE_VER)
		return TRUE ;

	// ***  Beginning of workspace upgrade management code.
	//
	//	o	Declare flags for each of the required upgrade steps.  These
	//		flags will be set in the following switch statement.
	//	o	There is also a flag that is set when any workspace upgrading is
	//		required.
	//	o	Make sure that all flags are initialized to false.
	//
	// NOTE: That the cases in the switch statement do not end with break
	// statements.  This is so that all of the upgrade flags for a workspace
	// currently at a particular version will be set when needed.  The
	// switch statement is set up so that if the workspace is version X, then
	// all of the upgrade flags for versions > X are set.
	//
	// Whenever a new workspace version is added:
	//	o	Declare a new flag for it.
	//	o	Add a new case statement to the switch statement for it.  (See note
	//		above.  You are actually adding a case statement for the previous
	//		version that will set the new version's flag.)
	//	o	Bupgradeneeded should always be set by the last case statement.
	//		Move the bupgradeneeded setting statement to the last case statement
	//		whenever a new case statement is added.

	bool bupgradeneeded, brctimestamp, bdefaultcodepage, bresdllnamechanged ;
	bool bnodrpathsinmdw, bfilesinw2ktree ;
	bupgradeneeded = brctimestamp = bdefaultcodepage = false ;
	bresdllnamechanged = bnodrpathsinmdw = bfilesinw2ktree = false ;
	switch (m_mvMDWVersion.uvernum) {
		case MDW_VER_STRING_RCIDS:	
			bdefaultcodepage = true ;
		case MDW_VER_DEFAULT_CPAGE:
			brctimestamp = true ;
		case MDW_VER_RC_TIMESTAMP:
			bresdllnamechanged = true ;
		case MDW_VER_NEW_DLLNAME:
			bnodrpathsinmdw = true ;
		case MDW_VER_NO_FILE_PATHS:
			bfilesinw2ktree = true ;
			bupgradeneeded = true ;
	} ;

	// If upgrade(s) are needed, declare a flag that indicates if any upgrading,
	// checking, or updating error has occurred.  If this flag is set, all
	// processing should stop.  Then...

	bool bprocerror = false ;
	bool buserwantstoupgrade = false ;
	CString csprompt ;
	if (bupgradeneeded) {

		// ...  Build a customized prompt for the user.
		//	o	Statements about upgrade tasks relevant to the user should also
		//		be added to the prompt.  For example, it should be noted when
		//		the RC file will be rewritten.  In this case (and below when
		//		other RC related checks are made), it is only necessary to
		//		test the "newest" RC related flag.  IE, the one associated with
		//		the latest MDW version.  This works because if any of the older
		//		RC flags are set, the newest one must be set too.
		//	o	Be concise so the message doesn't get too long.

		csprompt.Format(IDS_MDWUpgradeMsg1, DriverName()) ;
		if (bresdllnamechanged) {
			cstmp.LoadString(IDS_RCFileChanging) ;
			csprompt += cstmp ;
		} ;
		cstmp.LoadString(IDS_MDWUpgradeMsg2) ;
		csprompt += cstmp ;

		// ...	Do the work if the user wants to upgrade.
		//	o	Each upgrade step should be enclosed in an if statement that
		//		checks its individual flag and the processing error flag.

		if (AfxMessageBox(csprompt, MB_ICONQUESTION + MB_YESNO) == IDYES) {
			buserwantstoupgrade = true ;

			// If required, prompt the user for a default code page for the
			// driver and save it.
			
			if (!bprocerror && bdefaultcodepage)
				bprocerror = !UpdateDfltCodePage() ;

			// Reparse the RC file, rewrite it, and update its timestamp when
			// required.

			if (!bprocerror && bresdllnamechanged)
				bprocerror = !UpdateRCFile() ;

			// If required, rename the driver's subtree root directory from
			// "NT5" to "W2K".

			if (!bprocerror && bfilesinw2ktree)
				bprocerror = !UpdateDrvSubtreeRootName() ;

			// If everything is ok, update the MDW's version number.  (The MDW
			// file is saved later so that this only has to be done once.)

			if (!bprocerror)
				m_mvMDWVersion.uvernum = MDW_CURRENT_VERSION ;
		} ;
	} ;

	// ***	End of workspace upgrade management code except for possible MDW
	// ***	file reload.  (See below for details.)
	
	// ***	Begin workspace related checks and updates
	//		
	//	o	All of the checks for a specific file should be grouped together in
	//		one if statement so that only one prompt is required when the file
	//		needs to be updated.
	//	o	The if statement must contain the specific checks and, optionally,
	//		test if a related MDW upgrade step has already been performed or
	//		if a processing error has already occurred.
	//	o	If all of the checks/tests are "passed", perform whatever processing
	//		is required.
	//	o	If any updates are performed that require the MDW file to be
	//		rewritten, set bupgradeneeded.
	//	o	Always set bprocerror if an error occurs and tell the user what
	//		happened.

	// Reread the RC file if it has been changed and user oks it.

	if (!bprocerror && !bresdllnamechanged && RCFileChanged()) {
		cstmp = m_csRCName ;
		cstmp.MakeUpper() ;
		csprompt.Format(IDS_UpdateRCFile, cstmp) ;
		if (AfxMessageBox(csprompt, MB_ICONQUESTION + MB_YESNO) == IDYES) {
			if (!(bprocerror = !UpdateRCFile()))
				bupgradeneeded = true ;
		} ;
	} ;

	// ***	End of workspace related checks and updates
	
	// Save any MDW file changes that were made by any of the code above.

	if (bupgradeneeded && !bprocerror)
		bprocerror = (bool) !CDocument::OnSaveDocument(lpszPathName) ;

	// Occassionally, one of the changes done above requires the reloading of
	// the driver's MDW file.  That is done here.  The reasons are listed below.
	//	o When the driver's subtree root has been renamed from "NT5" to "W2K",
	//	  there are still copies of "NT5" in paths and filespecs in class
	//	  instances all over the place.  The easiest way to correct those paths,
	//	  etc is by reloading the MDW file.

	if (buserwantstoupgrade && bfilesinw2ktree && !bprocerror)
		if (!CDocument::OnOpenDocument(lpszPathName))
			return FALSE ;

    // Try to detect if driver files were moved and if they can be found.
	// Continue processing if the files were found or the user wants to
	// continue anyway.  Otherwise, cancel the loading of the workspace.
	
	if (!VerUpdateFilePaths())
		return FALSE ;

	// Workspace was loaded so return TRUE.
	// DEAD_BUG: Should I return TRUE even if there was a processing error???

	return TRUE ;
}


/******************************************************************************

  CProjectRecord::RCFileChanged

  If the MDW version is NOT large enough for this info to be relevant, return
  false.  If the version is large enough but m_ctRCFileTimeStamp is
  uninitialized, assert.

  If the everything is ok, get the timestamp for the RC file and compare it
  with m_ctRCFileTimeStamp.  If the RC file has changed, return true.
  Otherwise, return false.

******************************************************************************/

bool CProjectRecord::RCFileChanged()
{
	// Return no change if the MDW version is too low.

	if (m_mvMDWVersion.uvernum < MDW_VER_RC_TIMESTAMP)
		return false ;

	// Blow if the saved time is uninitialized.

	ASSERT(m_ctRCFileTimeStamp.GetTime() > 0) ;

	// Get the timestamp for the RC file, compare it with the time the MDT last
	// modified the file, and return the result.

	CTime ct ;
	if (!GetRCFileTimeStamp(ct))
		return false ;
	//TRACE("RC timestamp = %s     Saved timestamp = %s\n", ct.Format("%c"), m_ctRCFileTimeStamp.Format("%c")) ;
	if (ct > m_ctRCFileTimeStamp)
		return true ;
	else
		return false ;
}


/******************************************************************************

  CProjectRecord::GetRCFileTimeStamp

  Get the last modified time stamp for this project's RC file and load it into
  the specified parameter.  Return true if this succeeds.  Otherwise, return
  false.

******************************************************************************/

bool CProjectRecord::GetRCFileTimeStamp(CTime& ct)
{
	try {
		// Open the RC file

		CString csrcfspec(TargetPath(Win2000) + '\\' + m_csRCName) ;
		CFile cfrc(csrcfspec, CFile::modeRead + CFile::shareDenyNone) ;
		
		// Get RC file status information
		
		CFileStatus cfs ;
		cfrc.GetStatus(cfs) ;

		// Copy the last modified time stamp into the caller's variable

		ct = cfs.m_mtime ;

		// All went well so...

		return true ;
	}
	catch (CException* pce) {
		pce->ReportError() ;
		pce->Delete() ;
		return false ;
	} ;

	return false ;
}


/******************************************************************************

  CProjectRecord::UpdateRCFile

  This routine is called when it has been determined that the RC file was
  modified outside of the MDT.  This routine will reparse the RC file to
  update the internal data structures, merge the new data with the old data,
  and write a new RC file based on the combined information.  Then the
  timestamp for the last time the MDT modified the RC file is updated.

  Return true if all goes well.  Otherwise, return false.

******************************************************************************/

bool CProjectRecord::UpdateRCFile()
{
	// Build a filespec for the RC file.

	CString csrcfspec(TargetPath(Win2000) + '\\' + m_csRCName) ;

	// Reparse the RC file and update internal data structures.

	if (!m_cdr.ReparseRCFile(csrcfspec))
		return false ;

	// Write a new RC file base on the updated information.

	if  (!m_cdr.Generate(Win2000, csrcfspec))	{
		AfxMessageBox(IDS_RCWriteError) ;
		return  false ;  //  TODO:   Cleanup and backtracking
	} ;

	// Update the last time the RC file was written by the MDT timestamp.

	GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CProjectRecord::UpdateDfltCodePage

  Prompt the user for a default code page and save it.  Fail (return) false if
  the user cancels.  Return true if all goes well.

******************************************************************************/

bool CProjectRecord::UpdateDfltCodePage()
{
	// Display the dialog box to prompt for the code page.

	CGetDefCodePage dlg ;
	if (dlg.DoModal() == IDCANCEL)
		return false ;

	// A code page was selected, get it out of the dialog class and save it in
	// this class.  Both the cp/translated Far East resource ID and the real
	// CP are saved.

	SetDefaultCodePage(dlg.GetDefaultCodePage()) ;
	SetDefaultCodePageNum(dlg.GetDefaultCodePageNum()) ;


	// All went well so...

	return true ;
}


/******************************************************************************

  CProjectRecord::UpdateDrvSubtreeRootName

  This routine is called when the root of the driver's subtree needs to be
  renamed.  Older versions of the MDT would create a directory named "NT5" in
  which to put the driver's files and subdirectories.  Now that NT 5.0 has
  been renamed to Windows 2000 the new driver root directory should be called
  "W2K".  This routine will rename the driver's "NT5" directory to "W2K".
  Return true if the directory rename is successful.  Otherwise, return false.

******************************************************************************/

bool CProjectRecord::UpdateDrvSubtreeRootName()
{
	// Isolate the path for the MDW file.

	int npos = m_csProjFSpec.ReverseFind(_T('\\')) ;
	CString cspath = m_csProjFSpec.Left(npos + 1) ;

	// Now use the MDW file's path to build the old and new root directory
	// paths.

	CString csoldpath, csnewpath ;
	csoldpath.LoadString(IDS_OldDriverRootDir) ;
	csoldpath = cspath + csoldpath ;
	csnewpath.LoadString(IDS_NewDriverRootDir) ;
	csnewpath = cspath + csnewpath ;

	// Rename the directory.  Complain and return false if this fails.

	try {
		if (rename(csoldpath, csnewpath) != 0)
			return false ;
	}
	catch (CException *pce) {
		pce->ReportError() ;
		pce->Delete() ;
		return FALSE ;
	} ;

	// Update this path so that the RC file checks will work later in the
	// code.

	m_csW2000Path = csnewpath ;
	// All went well so...

	return true ;
}


/******************************************************************************

  CProjectRecord::OnSaveDocument

  Before saving the document, rebuild the RC file when needed and check the
  workspace for consistency.

******************************************************************************/

BOOL CProjectRecord::OnSaveDocument(LPCTSTR lpszPathName)
{
	// Check to see if the RC file needs to be rewritten first.  If the RC file
	// needs to be rewritten but this operation fails, return false (FAILURE).

	if (m_bRCModifiedFlag) {

		// If the workspace has no version information, rewriting the RC file
		// will erase the string table from the file.  The user probably
		// won't want to do this.  Only continue if he says so.

		int nqr = IDYES ;		// Query result
		if (m_mvMDWVersion.uvernum == MDW_DEFAULT_VERSION) {
			CString csmsg ;
			csmsg.Format(IDS_RCRewriteQuestion, m_cdr.Name(), m_csRCName) ;
			nqr = AfxMessageBox(csmsg, MB_YESNO+MB_ICONQUESTION+MB_DEFBUTTON2) ;
		} ;

		if (nqr == IDYES) {
			if  (!m_cdr.Generate(Win2000, TargetPath(Win2000) + '\\' + m_csRCName))	{
				AfxMessageBox(IDS_RCWriteError) ;
				return  FALSE ;  //  TODO:   Cleanup and backtracking
			} ;

			// Update the last time the RC file was written by the MDT timestamp.

			GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;
		} ;
		m_bRCModifiedFlag = FALSE ;
	} ;

	// Check the workspace for consistency before continuing.  Save, set, and
	// restore the directory around this call.

	CString cscurdir ;
	::GetCurrentDirectory(512, cscurdir.GetBuffer(512)) ;
	cscurdir.ReleaseBuffer() ;
	SetCurrentDirectory(m_csW2000Path) ;
	BOOL brc = m_cdr.WorkspaceChecker(true) ;
	SetCurrentDirectory(cscurdir) ;

	// Save the project file's filespec.

	m_csProjFSpec = lpszPathName ;

	// Now save the document (workspace) file.
	//
	// NOTE:	The value returned is virtually assured to be TRUE.  This is
	//			done to make sure the document is saved when the user requests
	//			it.  This has some unwanted side effects that I don't know
	//			how to avoid.  First, if the save is happening because the
	//			document is closing, it will still close even if there are
	//			workspace errors that the user wants to see.  Second, if the
	//			save is happening because the app is closing, the app will
	//			still close even if there are workspace errors that the user
	//			wants to see.
	// raid 123448
	if (m_mvMDWVersion.uvernum == MDW_VER_FILES_IN_W2K_TREE )
		m_mvMDWVersion.uvernum = MDW_VER_YES_FILE_PATHS ;

	return CDocument::OnSaveDocument(lpszPathName) ;
}


CString CProjectRecord::TargetPath(UINT ufFlags) const {

    switch(ufFlags) {
        case    Win95:
            return  m_csWin95Path;

        case    WinNT3x:
            return  m_csNT3xPath;

        case    WinNT40:
            return  m_csNT40Path;

        case    Win2000:
            return  m_csW2000Path;
    }

    AfxThrowNotSupportedException();

    return  m_csWin95Path;
}

//  This routine establishes the source RC file's name, and the initial paths
//  for all of the potential targets.

void    CProjectRecord::SetSourceRCFile(LPCTSTR lpstrSource) {
    m_csSourceRCFile = lpstrSource;

    m_csW2000Path = m_csNT40Path = m_csNT3xPath = m_csWin95Path =
        m_csSourceRCFile.Left(m_csSourceRCFile.ReverseFind(_T('\\')));
		
	// The last path component of the Windows 2000 files' directory, depends on
	// the version of the MDW file.

	CString cs ;
	if (m_mvMDWVersion.uvernum >= MDW_VER_FILES_IN_W2K_TREE)
		cs.LoadString(IDS_NewDriverRootDir) ;
	else
		cs.LoadString(IDS_OldDriverRootDir) ;
	m_csW2000Path += _T("\\") ;
	m_csW2000Path += cs ;

    m_csNT40Path += _T("\\NT4");
    m_csNT3xPath += _T("\\NT3");

    //  Trim the path name (including trailing \) to get driver name and RC
    m_csRCName = m_csSourceRCFile.Mid(1 + m_csWin95Path.GetLength());
    if  (m_csRCName.Find('.') != -1)
        m_csRCName = m_csRCName.Left(m_csRCName.Find('.'));
    m_cdr.Rename(m_csRCName);
    m_csRCName += _T(".RC");
    m_ufStatus = 0;
}

//  This is a helper function- it validates a new path name, and if it is
//  valid, returns TRUE, and stores it in the given CString;

static BOOL ValidatePath(CString& csTarget, LPCTSTR lpstrPath) {

    if  (!csTarget.CompareNoCase(lpstrPath)) {
        //  Trivial- no change = success!
        return  TRUE;
    }

    //  Determine the current directory, so we don't lose it.

    CString csCurrentDirectory, csNewOne;

    GetCurrentDirectory(MAX_PATH, csCurrentDirectory.GetBuffer(MAX_PATH));

    csCurrentDirectory.ReleaseBuffer();

    //  Attempt to switch to the new directory.  If we succeed, we're done.

    if  (SetCurrentDirectory(lpstrPath)) {
        GetCurrentDirectory(MAX_PATH, csTarget.GetBuffer(MAX_PATH));
        csTarget.ReleaseBuffer();

        SetCurrentDirectory(csCurrentDirectory);
        return  TRUE;
    }

    //  Attempt to create the new directory.  If this succeeds, delete the
    //  directory, and note our success our failure, either way.

    if  (CreateDirectory(lpstrPath, NULL)) {
        SetCurrentDirectory(lpstrPath);
        GetCurrentDirectory(MAX_PATH, csTarget.GetBuffer(MAX_PATH));
        csTarget.ReleaseBuffer();

        SetCurrentDirectory(csCurrentDirectory);
        RemoveDirectory(csTarget);
        return  TRUE;
    }
    return  FALSE;  //  Nothing worked, give it up...
}

//  The following loads all of the driver resources.

BOOL    CProjectRecord::LoadResources() {

    if  (!m_cdr.Load(*this))
        return  FALSE;

    m_ufStatus |= UniToolRun;
    m_ufStatus &= ~(ConversionsDone | NTGPCDone);
    SetModifiedFlag();

    return  TRUE;
}

//  The following member validates a new target path name.

BOOL    CProjectRecord::SetPath(UINT ufTarget, LPCTSTR lpstrPath) {

    switch  (ufTarget) {
        case    Win2000:
            m_ufStatus&= ~ConversionsDone;
            return  ValidatePath(m_csW2000Path, lpstrPath);

        case    WinNT40:
            m_ufStatus&= ~(ConversionsDone | NTGPCDone);
            return  ValidatePath(m_csNT40Path, lpstrPath);

        case    WinNT3x:
            m_ufStatus&= ~(ConversionsDone | NTGPCDone);
            return  ValidatePath(m_csNT3xPath, lpstrPath);
    }

    _ASSERTE(FALSE); //  This should never happen!
    return  FALSE;
}

//  When we create a new document (aka project, aka driver), we invoke the
//  new project wizard

BOOL CProjectRecord::OnNewDocument() {
	if  (!CDocument::OnNewDocument())
        return  FALSE;
		// raid 104822 : add real new document : kill below
    //  Invoke the wizard.
    CNewConvertWizard cnpw(*this);

	// Initialize the workspace's version number.
	
	m_mvMDWVersion.uvernum = MDW_CURRENT_VERSION ;

    return  cnpw.DoModal() == ID_WIZFINISH;

	return TRUE;
  }


/////////////////////////////////////////////////////////////////////////////
// CProjectRecord serialization
//
// See "MDT Workspace Versioning" in projrec.h for more information.
//

void CProjectRecord::Serialize(CArchive& car)
{
	// The first thing to do when storing is to build and write out the MDW
	// version information.  Only do this when the workspace's version number
	// is not MDW_DEFAULT_VERSION; IE, the WS has a version number.
	
	if (car.IsStoring()) {
		if (m_mvMDWVersion.uvernum > MDW_DEFAULT_VERSION) {
			strcpy(m_mvMDWVersion.acvertag, VERTAGSTR) ;
			car.Write(&m_mvMDWVersion, MDWVERSIONSIZE) ;
		} ;

	// When loading, CProjectRecord::OnOpenDocument() initializes and uses
	// m_mvMDWVersion.  Then the file is closed.  The file is reopened at the
	// beginning by CDocument::OnOpenDocument().  This means that when the file
	// contains version info, we must skip passed it so that the rest of the
	// serialization process can continue as expected.

	} else if (m_mvMDWVersion.uvernum >= MDW_FIRST_UPGRADABLE_VER)
		car.Read(&m_mvMDWVersion, MDWVERSIONSIZE) ;

	// m_csW2000Path needs to be loaded before m_cdr.Serialize() is called
	// so that the string can be used in the function and/or the routines it
	// calls.
//   raid 123448
	if (m_mvMDWVersion.uvernum < MDW_VER_YES_FILE_PATHS) {
		m_csW2000Path = car.GetFile()->GetFilePath() ;
		m_csW2000Path = m_csW2000Path.Left(m_csW2000Path.ReverseFind(_T('\\'))) ;
		
		// The last path component depends on the version of the MDW file.

		CString cs ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_FILES_IN_W2K_TREE)
			cs.LoadString(IDS_NewDriverRootDir) ;
		else
			cs.LoadString(IDS_OldDriverRootDir) ;
		m_csW2000Path += _T("\\") ;	// b. 2 lines : Raid 123448 !;; can cancel W2K dir.
		m_csW2000Path += cs ;
	} ; 

	// Now that versioning is done, get on with saving or restoring the
	// workspace's state.

    m_cdr.Serialize(car) ;
	if (car.IsStoring()) {
		if (m_mvMDWVersion.uvernum >= MDW_VER_YES_FILE_PATHS)   // Raid 123448
			car << m_csW2000Path ;
		car << m_csNT40Path << m_csNT3xPath << m_csWin95Path <<
            m_csSourceRCFile << m_ufTargets << m_ufStatus << m_csRCName ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_DEFAULT_CPAGE)
			car << m_dwDefaultCodePage ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_RC_TIMESTAMP)
			car << m_ctRCFileTimeStamp ;
	} else {
		if (m_mvMDWVersion.uvernum >= MDW_VER_YES_FILE_PATHS)
			car >> m_csW2000Path ;
		car >> m_csNT40Path >> m_csNT3xPath >> m_csWin95Path >>
            m_csSourceRCFile >> m_ufTargets >> m_ufStatus >> m_csRCName ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_DEFAULT_CPAGE) {
			car >> m_dwDefaultCodePage ;

			// Use m_dwDefaultCodePage to compute m_dwDefaultCodePageNum so
			// that a new MDW version is NOT needed to support
			// m_dwDefaultCodePageNum.  (See the declaration of these variables
			// for more info.)

			short scp = (short) ((WORD) m_dwDefaultCodePage) ;
			switch (scp) {
				case -10:
					m_dwDefaultCodePageNum = 950 ;
					break ;
				case -16:
					m_dwDefaultCodePageNum = 936 ;
					break ;
				case -17:
					m_dwDefaultCodePageNum = 932 ;
					break ;
				case -18:
					m_dwDefaultCodePageNum = 949 ;
					break ;
				default:
					m_dwDefaultCodePageNum = m_dwDefaultCodePage ;
					break ;
			} ;
		} ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_RC_TIMESTAMP)
			car >> m_ctRCFileTimeStamp ;
	}

	
	// Last, tell the user that the driver in this workspace should be
	// reconverted when there is no version information in the MDW file.
	// Only do this when loading.

	if (!car.IsStoring() && m_mvMDWVersion.uvernum == MDW_DEFAULT_VERSION) {
		CString csmsg ;
		csmsg.Format(IDS_NoVersionError, m_cdr.Name()) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
	} ;
}


//  Private Worker Routine- this establishes a directory, by first attempting
//  to go to it, then creating it if that failes.  The current directory is
//  preserved.

static BOOL Establish(CString   csNew) {
    CString csCurrent;

    GetCurrentDirectory(MAX_PATH, csCurrent.GetBuffer(MAX_PATH));
    csCurrent.ReleaseBuffer();

    if  (SetCurrentDirectory(csNew)) {
        SetCurrentDirectory(csCurrent);
        return  TRUE;
    }

    return  CreateDirectory(csNew, NULL);
}

//  Private worker routine.  This establishes the directory structure given it,
//  consisting of a named route, and two branches.

static BOOL CreateStructure(const CString& csRoot, LPCTSTR lpstrFont,
                            LPCTSTR lpstrMap) {
    return  Establish(csRoot) && Establish(csRoot + '\\' + lpstrFont) &&
        Establish(csRoot + '\\' + lpstrMap);
}

/******************************************************************************

  CProjectRecord::BuildStructure

  This builds the directory structure needed for all conversion targets.  This
  is done before files are generated so that the renaming calls in many of the
  project nodes do not fail.

******************************************************************************/

BOOL    CProjectRecord::BuildStructure(unsigned uVersion) {

    switch  (uVersion) {

        case    Win2000:

            return  CreateStructure(TargetPath(Win2000), _T("UFM"), _T("GTT"));

        case    WinNT40:

            return  CreateStructure(TargetPath(WinNT40), _T("IFI"), _T("RLE"));

        case    WinNT3x:

            return  CreateStructure(TargetPath(WinNT3x), _T("IFI"), _T("RLE"));
    }

    _ASSERTE(FALSE);

    return  FALSE;
}


/******************************************************************************

  CProjectRecord::GenerateTargets

  This one is a workhorse- it generates all of the files needed for all of the
  enabled targets, using the Win 3.x files as a base, with the exception of the
  NT GPC extensions, which require an interactive step.

******************************************************************************/

BOOL    CProjectRecord::GenerateTargets(WORD wfGPDConvert)
{
	int			nerrorid ;		// Error message ID returned by some routines

    //  Generate the files needed for Win2K

    if  (!CreateStructure(TargetPath(Win2000), _TEXT("UFM"), _TEXT("GTT")))
        return  FALSE;  //  TODO:   Feedback

    m_cdr.ForceCommonRC(FALSE);	// Don't use common.rc at all

	// Find and remove the standard include files from the array of include
	// files.  This will keep them from being added to the RC file twice.

	CString cs ;
	cs.LoadString(IDS_StdIncludeFile1) ;
	m_cdr.RemUnneededRCInclude(cs) ;
    if  (wfGPDConvert > 1) {
		cs.LoadString(IDS_StdIncludeFile2) ;
		m_cdr.RemUnneededRCInclude(cs) ;
	} ;
	cs.LoadString(IDS_StdIncludeFile3) ;
	m_cdr.RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile4) ;
	m_cdr.RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile5) ;
	m_cdr.RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_OldIncludeFile1) ;
	m_cdr.RemUnneededRCInclude(cs) ;

    //  Generate the RC file

	if  (!m_cdr.Generate(Win2000, TargetPath(Win2000) + '\\' + m_csRCName))
        return  FALSE;  //  TODO:   Cleanup and feedback

	// Update the last time the RC file was written by the MDT timestamp.

	GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

	//  Generate the GTT files

#if 0
    for (unsigned u = 0; u < m_cdr.MapCount(); u++) {

		CString	csfspec ;
        try {
			csfspec = m_cdr.GlyphTable(u).FileName() ;
            CFile   cfGTT(csfspec,
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

            if  (!m_cdr.GlyphTable(u).Generate(cfGTT)) {
				m_cdr.LogConvInfo(IDS_FileWriteError, 1, &csfspec) ;
				return  FALSE ;
			} ;
        }
        catch   (CException *pce) {
            pce -> ReportError();
            pce -> Delete();
			m_cdr.LogConvInfo(IDS_FileWriteError, 1, &csfspec) ;
            return  FALSE;
        }
    }
#else
	unsigned u ;
#endif

    //  Generate the UFM files

	CGlyphMap* pcgm ;
    for (u = 0; u < m_cdr.FontCount(); u++) {
		CFontInfo& cfi = m_cdr.Font(u) ;

		// Load the UFM's PFM if it hasn't been loaded already.  This is done
		// here to get possible GTT mapping info that is used if a GTT must be
		// built for this UFM.  This shouldn't fail.  If it does fail, the
		// conversion cannot continue.

		if (!cfi.MapPFM()) {
			CString	csfspec ;
			csfspec = cfi.FileName() ;
			m_cdr.LogConvInfo(IDS_UFMGenError, 1, &csfspec) ;
            return  FALSE;
		} ;

        // Map the UFM -> GTT, so we can convert the UFM
		//
		// DEAD_BUG:	The code page field in the font class instances has not
		//			been set yet so send 0 instead.  This might be fixable.

		/*		res_PFMHEADER  *pPFM = (res_PFMHEADER *) cfi.m_cbaPFM.GetData();
	
		BYTE dfCharSet = pPFM ->dfCharSet;
		WORD  CharSetCodePage = 0;
		switch (dfCharSet) {
		case  SHIFTJIS_CHARSET:
				CharSetCodePage = 932;
				break;
		case GB2312_CHARSET:
				CharSetCodePage = 936;
				break;
		case HANGEUL_CHARSET:
		case JOHAB_CHARSET:
				CharSetCodePage = 936;
				break;
		case CHINESEBIG5_CHARSET:
				CharSetCodePage = 950;
				break;
		}
*/		
		//TRACE("***  GetFirstPFM() = %d\t\tGetLastPFM() = %d\n", cfi.GetFirstPFM(), cfi.GetLastPFM()) ;
        pcgm = CGlyphMap::Public(cfi.Translation(), 0, GetDefaultCodePage(),
								 cfi.GetFirstPFM(), cfi.GetLastPFM()) ;
        if (pcgm)
            cfi.SetTranslation(pcgm) ;
        else
            for (unsigned uGTT = 0; uGTT < m_cdr.MapCount(); uGTT++)
                if (cfi.Translation() ==
                 ((WORD) m_cdr.GlyphTable(uGTT).nGetRCID())) {
                    cfi.SetTranslation(&m_cdr.GlyphTable(uGTT));
                    break;
                }

		// Log an error if the UFM could not be generated and stop.  Continuing
		// could cause things like the RC file and Workspace View to be wrong.
		// In addition, delete any partially generated UFM file.

		if  ((nerrorid = cfi.Generate(cfi.FileName())) != 0) {
			CString	csfspec ;
			csfspec =
				(nerrorid == IDS_BadCTTID) ? cfi.SourceName() : cfi.FileName() ;
			m_cdr.LogConvInfo(nerrorid, 1, &csfspec) ;
			try {
				CFile::Remove(cfi.FileName()) ;
			}
			catch(CFileException* pce) {
				pce = pce ;
			}
            return  FALSE;
		} ;
    }

    //  Generate the GPD files

    if  (!m_cdr.ConvertGPCData(*this, wfGPDConvert))
        return  FALSE;  //  Error will already have been reported to user.

    //  Simplest case is no NT versions selected.  By definition, we are done.

    if  (!IsTargetEnabled(WinNT40 | WinNT3x)) {
        m_ufStatus |= ConversionsDone;
        return  TRUE;
    }

    //  Generate the files needed for NT 4.0

    if  (IsTargetEnabled(WinNT40)) {
        if  (!CreateStructure(TargetPath(WinNT40), _TEXT("IFI"), _TEXT("RLE")))
            return  FALSE;  //  TODO:   Feedback

        //  Generate the RC file
        if  (!m_cdr.Generate(WinNT40, TargetPath(WinNT40) + '\\' + m_csRCName))
            return  FALSE;  //  TODO:   Cleanup and feedback

		// Update the last time the RC file was written by the MDT timestamp.

		GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

		//  Copy the GPC file
        if  (!CopyFile(TargetPath(Win95) + m_cdr.GPCName(0),
             TargetPath(WinNT40) + m_cdr.GPCName(0), FALSE))
             return FALSE;  //  TODO:   Cleanup and feedback

        //  Generate the RLE files

        for (u = 0; u < m_cdr.MapCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\RLE\\") +
                m_cdr.GlyphTable(u).Name() + _TEXT(".RLE");

            CFile   cfRLE;

            if  (!cfRLE.Open(csName,
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
                return  FALSE;  //  As usal, TODO:  Feedback...

            if  (!m_cdr.GlyphTable(u).RLE(cfRLE))
                return  FALSE;  //  TODO:   Ditto
        }

        //  Generate the IFI files
        for (u = 0; u < m_cdr.OriginalFontCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\IFI\\") +
                m_cdr.Font(u).Name() + _TEXT(".IFI");
            if  (!m_cdr.Font(u).Generate(csName))
                return  FALSE;  //  TODO:   Ditto
        }
    }

    //  Generate the files needed for NT 3.x

    if  (IsTargetEnabled(WinNT3x)) {
        if  (!CreateStructure(TargetPath(WinNT3x), _TEXT("IFI"), _TEXT("RLE")))
            return  FALSE;  //  TODO:   Feedback

        //  Generate the RC file
        if  (!m_cdr.Generate(WinNT3x, TargetPath(WinNT3x) + '\\' + m_csRCName))
            return  FALSE;  //  TODO:   Cleanup and feedback

		// Update the last time the RC file was written by the MDT timestamp.

		GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

        //  Copy the GPC file
        if  (!CopyFile(TargetPath(Win95) + m_cdr.GPCName(0),
             TargetPath(WinNT3x) + m_cdr.GPCName(0), FALSE))
             return FALSE;  //  TODO:   Cleanup and feedback

        //  Generate the RLE files

        for (u = 0; u < m_cdr.MapCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\RLE\\") +
                m_cdr.GlyphTable(u).Name() + _TEXT(".RLE");

            CFile   cfRLE;

            if  (!cfRLE.Open(csName,
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
                return  FALSE;  //  As usal, TODO:  Feedback...

            if  (!m_cdr.GlyphTable(u).RLE(cfRLE))
                return  FALSE;  //  TODO:   Ditto
        }

        //  Generate the IFI files
        for (u = 0; u < m_cdr.OriginalFontCount(); u++) {
            CString csName = TargetPath(WinNT3x) + _TEXT("\\IFI\\") +
                m_cdr.Font(u).Name() + _TEXT(".IFI");
            if  (!m_cdr.Font(u).Generate(csName))
                return  FALSE;  //  TODO:   Ditto
        }
    }

    m_ufStatus |= ConversionsDone;

    return  TRUE;
}

/******************************************************************************

  CProjectRecord::GPDConversionCheck

  If any of the GPD files have unresolved errors from the conversion process,
  it will open all of them, if the user asks, so they can fix the problem(s)
  forthwith- or leave them for the next time the workspace is edited.

******************************************************************************/

void    CProjectRecord::GPDConversionCheck(BOOL bReportSuccess) {
    CUIntArray  cuaSuspects;

    for (unsigned u = 0; u < m_cdr.Models(); u ++)
        if  (m_cdr.Model(u).HasErrors())
            cuaSuspects.Add(u);

    if  (!cuaSuspects.GetSize()) {
        if (bReportSuccess)
            AfxMessageBox(IDS_NoErrorsAnywhere);
        return;
    }

    if  (AfxMessageBox(IDS_ConversionErrors, MB_YESNO) == IDNO)
        return;

    while   (cuaSuspects.GetSize()) {
        m_cdr.Model(cuaSuspects[0]).Edit();
        cuaSuspects.RemoveAt(0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord diagnostics

#ifdef _DEBUG
void CProjectRecord::AssertValid() const {
	CDocument::AssertValid();
}

void CProjectRecord::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG




/////////////////////////////////////////////////////////////////////////////
// CProjectRecord commands

/////////////////////////////////////////////////////////////////////////////
//	VerUpdateFilePaths - Verify and update paths/filespecs in workspace file
//
//	Use the information read from the workspace file to see if the Win2K RC
//	file is where it is supposed to be.  If it is, assume that all is ok.  If
//	not, assume that either the workspace (.MDW) file or the files reference by
//	the workspace file have moved.
//
//	Tell the user and ask if he wants to locate the RC file for us.  If yes,
//	prompt for and verify the new RC file path.  Reprompt if it is wrong.  If
//	the user cancels, exit.
//
//	Once a path to the RC file is verified, use the file's grandparent
//	directory to update the paths used for all UFMs, GTTs, GPDs, and the rest
//	of the paths read from the MDW file and managed by this document.  The
//	grandparent directory is used because it is needed to correct some of
//	the filespecs saved in the workspace.  All of the Win2K files are
//  expected to be in directory(s) beneath the grandparent directory.  Lastly,
//	set the document's modified flag so that the updated paths can be saved
//	later.
//
//	void CProjectRecord::VerUpdateFilePaths()
//
//	Args:
//		None
//
//	Returns
//		Nothing
//
//	Notes
//		First, the Workspace View Add/Insert/Clone/Copy context menu commands
//		must make sure that the destination files for these commands always
//		end up in the appropriate workspace directories for this scheme to
//		work.
//
//		Second, if it is decided that more than one root directory is needed
//		for a workspace, this function will have to prompt for multiple
//		directories and then use the appropriate directory to update the paths
//		for UFMs, GTTs, GPDs, and the rest of the paths referenced by the
//		workspace file.
//
//		Third, if this tool is ever enhanced to handle conversions to anything
//		other than Win2K drivers, this routine will need to be enhanced to
//		handle those cases too.
//
	
bool CProjectRecord::VerUpdateFilePaths()
{
    CFileFind	cff ;			// Used to find the RC file
	bool		borig = true ;	// True iff the original RC file was found
	BOOL		bfound ;		// True iff an RC file was found
	CString		csprompt ;		// Used to prompt the user
	int			nresponse = 0 ;	// User's response to prompt

	// Make a copy of the file path and build a filespec for the Win2000 RC file

	CString	csrcpath(m_csW2000Path) ;
	CString	csrcfspec(csrcpath) ;
	if (csrcfspec.Right(1) != _T('\\'))
		csrcfspec += _T("\\") ;
	csrcfspec += m_csRCName ;

	// Keep checking for the existence of the RC file and prompting the user
	// until the file is found or the user doesn't want to continue any more.

	while (true) {
		// If the Win2000 RC file exists, we're done so exit.

		if (bfound = cff.FindFile(csrcfspec))
			break ;

		// Explain the situation to the user and ask if they want to tell us where
		// the file is.	 (Only do this the first time.)

		if (borig) {
			csprompt.Format(IDS_RCFindPrompt, DriverName(), csrcpath) ;
			nresponse = AfxMessageBox(csprompt, MB_YESNOCANCEL+MB_ICONQUESTION);
			if (nresponse != IDYES)
				break ;
		} ;

		// Prompt the user for a new RC file

		CFileDialog cfd(TRUE, _T(".RC"), m_csRCName,
						OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
						_T("RC File (*.rc)|*.rc||")) ;
		cfd.m_ofn.lpstrInitialDir = csrcpath ;
		if  (cfd.DoModal() != IDOK)
			break ;

		// Prepare to check the new filespec

		csrcfspec = cfd.GetPathName() ;
		csrcpath = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\'))) ;
		borig = false ;
	} ;

	// If the original RC file was found or the user did not provide a new
	// filespec or the user cancels, just return without changing anything.
	// Return false if the user cancelled.

	if (borig || !bfound)
		return (nresponse != IDCANCEL) ;

	// When the MDT performs a conversion, the resulting files are put into
	// a directory tree with a root directory like NT4 or Win2K by default.  The
	// directory layout and files from that root directory on down are expected
	// to be maintained.  The RC file is expected to be in that root directory,
	// too.  Therefore, the paths in this workspace up to BUT NOT INCLUDING that
	// root directory must be updated; ie, the path for the RC file's
	// grandparent directory.  So, get the new path for the grandparent
	// directory.

	CString csrcnewgrand(csrcpath) ;
	csrcnewgrand = csrcnewgrand.Left(csrcnewgrand.ReverseFind(_T('\\')) + 1) ;

	// As a safety measure, existing paths are only updated if they begin with
	// the RC file's OLD grandparent directory.

	CString csrcoldgrand(m_csW2000Path) ;
	csrcoldgrand = csrcoldgrand.Left(csrcoldgrand.ReverseFind(_T('\\')) + 1) ;
	int noldlen = csrcoldgrand.GetLength() ;

	// Variables used to process arrays of objects and their paths

	unsigned u ;
	unsigned unumobjs ;
	CString  cspath ;

	// Update UFM filespecs

    for (unumobjs = m_cdr.FontCount(), u = 0 ; u < unumobjs ; u++) {
        cspath = m_cdr.Font(u).GetPath() ;
		if (cspath.Find(csrcoldgrand) == 0)	{
			cspath = csrcnewgrand + cspath.Right(cspath.GetLength() - noldlen) ;
			m_cdr.Font(u).SetPath(cspath) ;
		} ;
	} ;

	// Update GTT filespecs

    for (unumobjs = m_cdr.MapCount(), u = 0 ; u < unumobjs ; u++) {
        cspath = m_cdr.GlyphTable(u).GetPath() ;
		if (cspath.Find(csrcoldgrand) == 0)	{
			cspath = csrcnewgrand + cspath.Right(cspath.GetLength() - noldlen) ;
			m_cdr.GlyphTable(u).SetPath(cspath) ;
		} ;
	} ;

	// Update GPD filespecs

    for (unumobjs = m_cdr.Models(), u = 0 ; u < unumobjs ; u++) {
        cspath = m_cdr.Model(u).GetPath() ;
		if (cspath.Find(csrcoldgrand) == 0)	{
			cspath = csrcnewgrand + cspath.Right(cspath.GetLength() - noldlen) ;
			m_cdr.Model(u).SetPath(cspath) ;
		} ;
	} ;

	// Now, update the paths that are in the workspace.

	if (m_csSourceRCFile.Find(csrcoldgrand) == 0)
		m_csSourceRCFile = csrcnewgrand + m_csSourceRCFile.Right(m_csSourceRCFile.GetLength() - noldlen) ;
	if (m_csW2000Path.Find(csrcoldgrand) == 0)
		m_csW2000Path = csrcnewgrand + m_csW2000Path.Right(m_csW2000Path.GetLength() - noldlen) ;
	if (m_csNT40Path.Find(csrcoldgrand) == 0)
		m_csNT40Path = csrcnewgrand + m_csNT40Path.Right(m_csNT40Path.GetLength() - noldlen) ;
	if (m_csNT3xPath.Find(csrcoldgrand) == 0)
		m_csNT3xPath = csrcnewgrand + m_csNT3xPath.Right(m_csNT3xPath.GetLength() - noldlen) ;
	if (m_csWin95Path.Find(csrcoldgrand) == 0)
		m_csWin95Path = csrcnewgrand + m_csWin95Path.Right(m_csWin95Path.GetLength() - noldlen) ;

	// Lastly, mark the workspace file as being dirty so that it can be saved
	// later.

	SetModifiedFlag() ;
    return TRUE;
}


/******************************************************************************

  CProjectRecord::SaveModified

  This overridable function is used to make sure that the "subdocuments"
  associated with this document that are NOT file based are saved before this
  document closes.  The normal saving mechanisms employed by the MFC document
  view architectured don't always work in these cases.  The work required to
  save each subdocument is subdocument dependent.  The current list of
  subdocuments that fall into this category are:
	
  o	String Table Editor - The editor just modifies the string table portion of
	the RC file that is associated with the documented managed by this
	instance of CProjectRecord.  If the editor exists, tell it to save the
	string table.  If this succeeds, the document's save flags will be updated
	when needed.  If this fails, return FALSE so that the calling function
	will know that this document should not be closed.

******************************************************************************/

BOOL CProjectRecord::SaveModified()
{
	// Save the string table if it was modified.
	//
	// Begin by getting a pointer to the string editor for this project.

	CMDIChildWnd* pcmcw = m_cdr.GetStringsNode()->GetEditor() ;

	// If there is a string editor, call it to save the string table.

	if (pcmcw != NULL) {
		CStringEditorDoc* pcsed = (CStringEditorDoc*) pcmcw->GetActiveDocument() ;

		// Return FALSE (do not close this document) if the string table needed
		// to be saved but it couldn't be saved because it is invalid.

		if (!pcsed->SaveStringTable()) {
			pcmcw->SetFocus() ;
			return FALSE ;
		} ;
	} ;
	
	return CDocument::SaveModified();
}


/////////////////////////////////////////////////////////////////////////////
// CGetDefCodePage dialog


CGetDefCodePage::CGetDefCodePage(CWnd* pParent /*=NULL*/)
	: CDialog(CGetDefCodePage::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetDefCodePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CGetDefCodePage::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetDefCodePage)
	DDX_Control(pDX, IDC_CodePageList, m_clbCodePages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetDefCodePage, CDialog)
	//{{AFX_MSG_MAP(CGetDefCodePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetDefCodePage message handlers

BOOL CGetDefCodePage::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Find out how many code pages are installed on the machine.

	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n2 ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;
		wsprintf(accp, "%5d", dwcp) ;
		n2 = m_clbCodePages.AddString(accp) ;
		if (dwcp == dwdefcp)
			m_clbCodePages.SetCurSel(n2) ;
	} ;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CGetDefCodePage::OnOK()
{
	// Get the index of the currently selected list box item.

	int nsel ;
	if ((nsel = m_clbCodePages.GetCurSel()) == LB_ERR) {
		AfxMessageBox(IDS_MustSelCP, MB_ICONINFORMATION) ;
		return ;
	} ;

	// Get the selected list box string, turn it into a number, and save it.

	CString cs ;
	m_clbCodePages.GetText(nsel, cs) ;

	// Turn the string into a number and convert the number into the
	// corresponding predefined GTT code for Far East code pages when
	// applicable.

	short scp = (short) atoi(cs) ;
	m_dwDefaultCodePageNum = (DWORD) scp ;	// Save real CP number first
	switch (scp) {
		case 932:
			scp = -17 ;
			break ;
		case 936:
			scp = -16 ;
			break ;
		case 949:
			scp = -18 ;
			break ;
		case 950:
			scp = -10 ;
			break ;
	} ;
	DWORD dwcp = (DWORD) scp ;

	m_dwDefaultCodePage = dwcp ;

	// All went well so...

	CDialog::OnOK();
}

BOOL CProjectRecord::CreateFromNew(CStringArray &csaUFMFiles, CStringArray &csaGTTFiles, CString &csGpdPath, CString &csModelName, CString &csRC,CStringArray& csaRcid)
{
	
	
	// customize GPD keyword value
	CModelData cmd ;
	CString cspath, csmodel, csdll ; 
	cspath = csGpdPath.Mid(csGpdPath.ReverseFind('\\') + 1 ) ;

	cmd.SetKeywordValue(csGpdPath,_T("*GPDFileName"),cspath);
	cmd.SetKeywordValue(csGpdPath,_T("*ModelName"),csModelName) ;
	cmd.SetKeywordValue(csGpdPath,_T("*ResourceDLL"),csRC + _T(".dll") ) ;
	
	
	// Fill RC member data : m_csRCName, m_csW2000Path ;
	m_csW2000Path = csGpdPath.Left(csGpdPath.ReverseFind('\\') ) ;
	m_csRCName = csRC + _T(".rc") ; 
	GetRCFileTimeStamp(m_ctRCFileTimeStamp) ; // set the last time stamp
	SetRCModifiedFlag(TRUE ) ;

	// Set project version 
	m_mvMDWVersion.uvernum = MDW_VER_FILES_IN_W2K_TREE ;
	m_dwDefaultCodePage = 
	m_dwDefaultCodePageNum = 1252 ;  
	 
	// Set project name; top name in the tree
	CString csPrjname;
	csPrjname = m_csW2000Path.Mid(m_csW2000Path.ReverseFind('\\') + 1 ) ;
	Rename(csPrjname ) ;
	
	
	// copy the resource data to project member data 
	m_cdr.CopyResources(csaUFMFiles,csaGTTFiles, csGpdPath, csaRcid) ;
	

	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projview.cpp ===
/******************************************************************************

  Source File:  Project View.CPP

  This implements the view class for project level information.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:

  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "ProjView.H"
#include	"INFWizrd.H"
#include    "Gpdfile.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectView

IMPLEMENT_DYNCREATE(CProjectView, CFormView)

BEGIN_MESSAGE_MAP(CProjectView, CFormView)
	//{{AFX_MSG_MAP(CProjectView)
	ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_DriverView, OnBeginlabeleditDriverView)
	ON_NOTIFY(TVN_ENDLABELEDIT, IDC_DriverView, OnEndLabelEdit)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_DBLCLK, IDC_DriverView, OnDblclkDriverView)
	ON_COMMAND(ID_FILE_PARSE, OnFileParse)
	ON_NOTIFY(TVN_KEYDOWN, IDC_DriverView, OnKeydownDriverView)
	ON_WM_SIZE()
    ON_COMMAND(ID_FILE_CheckWS, OnCheckWorkspace)
	ON_COMMAND(ID_FILE_INF, OnFileInf)
	//}}AFX_MSG_MAP
	// Standard printing commands
//	ON_COMMAND(ID_FILE_PRINT, CFormView::OnFilePrint)	//RAID 135232 no printing in project view
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CFormView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CFormView::OnFilePrintPreview)
    //  Commands we pop up from context menus
    ON_COMMAND(ID_ExpandBranch, OnExpandBranch)
    ON_COMMAND(ID_CollapseBranch, OnCollapseBranch)
    ON_COMMAND(ID_RenameItem, OnRenameItem)
    ON_COMMAND(ID_OpenItem, OnOpenItem)
    //ON_COMMAND(ID_GenerateOne, OnGenerateItem)
    ON_COMMAND(IDOK, OnOpenItem)    //  We'll open an item if ENTER is hit
    ON_COMMAND(ID_Import, OnImport)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_CopyItem, OnCopyItem)
    ON_COMMAND(ID_ChangeID, OnChangeID)
    ON_COMMAND(ID_CheckWS, OnCheckWorkspace)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjectView construction/destruction

CProjectView::CProjectView() : CFormView(CProjectView::IDD) {
	//{{AFX_DATA_INIT(CProjectView)
	//}}AFX_DATA_INIT
	
	// Resizing is not ok, yet

	bResizingOK = false ;
}


CProjectView::~CProjectView()
{
}


void CProjectView::DoDataExchange(CDataExchange* pDX) {
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjectView)
	DDX_Control(pDX, IDC_DriverView, m_ctcDriver);
	//}}AFX_DATA_MAP
}

BOOL CProjectView::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.lpszClass = _T("Workspace") ;	 // raid 104822	
	return CScrollView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView drawing

void CProjectView::OnInitialUpdate() {
	CFormView::OnInitialUpdate();

    ResizeParentToFit(FALSE);

    //GetDocument() -> VerUpdateFilePaths();
    GetDocument() -> InitUI(&m_ctcDriver);
    GetParentFrame() -> ShowWindow(SW_SHOW);
    GetDocument() -> GPDConversionCheck();
	
	// Get the current dimensions of the workspace view window and the other
	// control(s) that can be resized.  Then set the flag that says that
	// resizing is ok now.

	WINDOWPLACEMENT wp ;
	wp.length = sizeof(WINDOWPLACEMENT) ;
	GetWindowPlacement(&wp) ;
	crWSVOrgDims = wp.rcNormalPosition ;
	crWSVCurDims = crWSVOrgDims ;
	m_ctcDriver.GetWindowPlacement(&wp) ;
	crTreeOrgDims = wp.rcNormalPosition ;
	crTreeCurDims = crTreeOrgDims ;
	HWND	hlblhandle ;		
	GetDlgItem(IDC_ProjectLabel, &hlblhandle) ;
	::GetWindowPlacement(hlblhandle, &wp) ;
	crLblOrgDims = wp.rcNormalPosition ;
	crLblCurDims = crLblOrgDims ;
	bResizingOK = true ;
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView printing

BOOL CProjectView::OnPreparePrinting(CPrintInfo* pInfo) {
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CProjectView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/) {
	// TODO: add extra initialization before printing
}

void CProjectView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/) {
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView diagnostics

#ifdef _DEBUG
void CProjectView::AssertValid() const {
	CScrollView::AssertValid();
}

void CProjectView::Dump(CDumpContext& dc) const {
	CScrollView::Dump(dc);
}

CProjectRecord* CProjectView::GetDocument() {// non-debug version is inline
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CProjectRecord)));
	return (CProjectRecord*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CProjectView message handlers

void CProjectView::OnBeginlabeleditDriverView(NMHDR* pnmh, LRESULT* plr) {
	TV_DISPINFO* ptvdi = (TV_DISPINFO*) pnmh;

    *plr = !((CBasicNode *) ptvdi -> item.lParam) -> CanEdit();
}

/******************************************************************************

  CProjectView::OnEndLabelEdit

  Called when a label in the view has been edited- the user has either
  canceled (new text in item will be empty), or changed the text.  We pass the
  whole information on to the CBasicNode which handles this object.

******************************************************************************/

void CProjectView::OnEndLabelEdit(NMHDR* pnmh, LRESULT* plr) {
	TV_DISPINFO* ptvdi = (TV_DISPINFO*) pnmh;

    *plr = ((CBasicNode *) ptvdi -> item.lParam) -> Rename(ptvdi -> 
        item.pszText);
	//raid 19658
	CString csfile = ptvdi->item.pszText;
	int offset;
	if(-1 != (offset=csfile.ReverseFind(_T('\\')) ) ) {
		CModelData cmd;
		CString csValue = csfile.Mid(offset+1);
//		csValue.MakeUpper();
		csValue +=  _T(".GPD");
		csfile += _T(".gpd");
		cmd.SetKeywordValue(csfile,_T("*GPDFileName"),csValue);
	}


}

/******************************************************************************

  CProjectView::OnContextMenu

  This is called when the user right-clicks the mouse.  We determine if the
  mouse is within an item in the tree view.  If it is, then we pass it on to
  the CBasicNode-derived object which handles that item.  That object is then
  responsible for displaying the proper context menu.

******************************************************************************/

void CProjectView::OnContextMenu(CWnd* pcw, CPoint cp) {
	if  (pcw != &m_ctcDriver)
        return;

    CPoint  cpThis(cp);

    m_ctcDriver.ScreenToClient(&cpThis);

    //  If the mouse is inside the area of any item, display its context menu

    UINT    ufItem;

    HTREEITEM hti = m_ctcDriver.HitTest(cpThis, &ufItem);

    if  (!hti || !(ufItem & (TVHT_ONITEM | TVHT_ONITEMBUTTON)))
        return;
        
    //  Some operations require we know which item, so we're going to
    //  select the given item.  If this is really a problem, we can change
    //  it later (cache it in a member).

    m_ctcDriver.SelectItem(hti);

    ((CBasicNode *) m_ctcDriver.GetItemData(hti)) -> ContextMenu(this, cp);
}

/******************************************************************************

  CProjectView::OnExpandBranch

  This is called when the user selects an expand item from a context menu.  In
  this case, we don't need to pass this through the CBasicNode- we just expand
  it using the normal common control methods (actually using an MFC method, 
  since this promises greater future portability).

******************************************************************************/

void    CProjectView::OnExpandBranch() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.Expand(htiSelected, TVE_EXPAND);
}

/******************************************************************************

  CProjectView::OnCollapseBranch

  In this case, the user has selected the Collapse item from a context menu.
  We collapse the branch at the selected tree view item.

******************************************************************************/

void    CProjectView::OnCollapseBranch() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.Expand(htiSelected, TVE_COLLAPSE);
}

/******************************************************************************

  CProjectView::OnRenameItem

  This handles a user selecting a Rename item.  This results in us ordering the
  view to begin label editing of the selected item.  The interactions regarding
  label editing are routed to the underlying CBasicNode object via 
  OnBeginLabelEdit and OnEndLabelEdit.

******************************************************************************/

void    CProjectView::OnRenameItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.EditLabel(htiSelected);
}

/******************************************************************************

  CProjectView::OnOpenItem

  This method is invoked when the user wishes to edit an item in the tree.
  This is always routed through the underlying CBasicNode-derived item.  Some
  items can't be edited, and will ignore this (in fact, this is the base class
  behavior).

******************************************************************************/

void    CProjectView::OnOpenItem() { 
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();
	

    if  (!htiSelected) 
        return;
	// raid 8350
	CWnd *cwd = FromHandle(m_hWnd); 
	(cwd->GetParent()) -> ShowWindow(SW_SHOWNORMAL );


  ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Edit();
}

//  Generate an image of the selected item (usable for building)
/*		No longer supported
void    CProjectView::OnGenerateItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    //((CProjectNode *) m_ctcDriver.GetItemData(htiSelected)) -> Generate();
}
*/

/******************************************************************************

  CProjectView::OnDblClkDriverView

  This is called when the user double-clicks anywhere in the tree view.  We
  route it through the Open message handler, as this will always be the desired
  action.

******************************************************************************/

void CProjectView::OnDblclkDriverView(NMHDR* pNMHDR, LRESULT* pResult) {
	OnOpenItem();
}

/******************************************************************************

  CProjectView::OnFileParse

  This method invokes the parser on each of the GPD files in the project.

******************************************************************************/

void CProjectView::OnFileParse() {
    {
        CWaitCursor cwc;    //  This could take a while...

        for (unsigned u = 0; u < GetDocument() -> ModelCount(); u++) {
            GetDocument() -> Model(u).Parse(0);
            GetDocument() -> Model(u).UpdateEditor();
        }
    }

    GetDocument() -> GPDConversionCheck(TRUE);

}

/******************************************************************************

  CProjectView::OnKeydownDriverView

  This handles various keystrokes we want handled over and above what the
  default handling by the control supplies.

******************************************************************************/

void CProjectView::OnKeydownDriverView(NMHDR* pnmh, LRESULT* plr) {
	TV_KEYDOWN* ptvkd = (TV_KEYDOWN*)pnmh;

    HTREEITEM htiSelected = m_ctcDriver.GetSelectedItem();

	*plr = 0;

    if  (!htiSelected)
        return;

    CRect   crThis;
    
    m_ctcDriver.GetItemRect(htiSelected, crThis, FALSE);

    CBasicNode& cbn = *(CBasicNode *) m_ctcDriver.GetItemData(htiSelected);
	
    switch  (ptvkd -> wVKey) {
        case    VK_F10:
            //  Create a context menu for this item.
            m_ctcDriver.ClientToScreen(crThis);
            cbn.ContextMenu(this, crThis.CenterPoint());
            return;

        case    VK_DELETE:
            //  If the item is successfully deleted, remove it from the
            //  view
            OnDeleteItem();  //add (raid 7227)
//			cbn.Delete();   //delete(raid 7227)
            return;
//RAID 7227 add hot key
		//Open F2, Copy F3, Rename, Delete DELETE Key,
		case     VK_F2:
			OnOpenItem();
			return;
		case     VK_F3:
			OnCopyItem();
			return;
		case     VK_F4:
			OnRenameItem();
			return;
    }
}

/******************************************************************************

  CProjectView::OnImport

  This method is invoked when the user selects an "Import" item on a context
  menu.  How this is handled is entirely the responsibility of the underlying
  CBasicNode-derived item, so the request gets routed there by this code.

******************************************************************************/

void    CProjectView::OnImport() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Import();
}

/******************************************************************************

  CProjectView::OnDeleteItem

  For item deletion via context menu.  The delete key is handled in 
  OnKeydownDriverView.  Once again, the underlying object handles what happens.
  BUT, before that happens, this routine handles the common UI because of
  oddities with working with the DLLs.

******************************************************************************/

void    CProjectView::OnDeleteItem() 
{
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

	// The selected item should be a pointer to a project node+.  Get a pointer
	// to the node and verify its type.  Return if the type is incorrect.

	CProjectNode* pcpn = (CProjectNode*) m_ctcDriver.GetItemData(htiSelected) ;
    if (!pcpn->IsKindOf(RUNTIME_CLASS(CProjectNode)))
		return ;

	// Init and prompt for the new RC ID.  Return if the user cancels.

    CDeleteQuery cdq;
	CString cstmp(pcpn->FileExt()) ;
	cstmp = cstmp.Mid(1) ;
	cdq.Init(cstmp, pcpn->Name()) ;
    if  (cdq.DoModal() != IDYES)
        return ;

    //  Walk back up the hierarchy to find the owning Fixed node, and
    //  remove us from the array for that node- since that member is a
    //  reference to the array, all will work as it should.

    CFixedNode&  cfn = * (CFixedNode *) m_ctcDriver.GetItemData(
        m_ctcDriver.GetParentItem(pcpn->Handle())) ;
    ASSERT(cfn.IsKindOf(RUNTIME_CLASS(CFixedNode))) ;
    cfn.Zap(pcpn, cdq.KillFile());

    //  WARNING:  the object pointed to by this has been deleted do NOTHING
    //  from this point on that could cause the pointer to be dereferenced!
}


/******************************************************************************

  CProjectView::OnCopyItem

  For item copy via context menu.  Once again, the underlying object handles 
  what happens. BUT, before that happens, this routine handles the common UI
  because of oddities with working with the DLLs.

******************************************************************************/

void    CProjectView::OnCopyItem()
{
	// Just return if nothing is selected.

    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();
    if  (!htiSelected)
        return ;

	// The selected item should be a pointer to a project node+.  Get a pointer
	// to the node and verify its type.  Return if the type is incorrect.

	CProjectNode* pcpn = (CProjectNode*) m_ctcDriver.GetItemData(htiSelected) ;
    if (!pcpn->IsKindOf(RUNTIME_CLASS(CProjectNode)))
		return ;

	// Prompt for the new file name.  Return if the user cancels.

	CCopyItem cci ;
	cci.Init(pcpn->FileTitleExt()) ;
	if (cci.DoModal() == IDCANCEL)
		return ;

    //  Walk back up the hierarchy to find this project node's owning Fixed node.

    CFixedNode&  cfn = * (CFixedNode *) m_ctcDriver.GetItemData(
        m_ctcDriver.GetParentItem(pcpn->Handle())) ;
    ASSERT(cfn.IsKindOf(RUNTIME_CLASS(CFixedNode)));

	// Call the fixed node to make the copy of its child.

	cfn.Copy(pcpn, cci.m_csCopyName) ;
}


/******************************************************************************

  CProjectView::OnChangeID

  Called to change a resource ID via context menu.  Once again, the underlying
  object handles what happens.  BUT, before that happens, this routine handles
  the common UI because of oddities with working with the DLLs.

******************************************************************************/

void    CProjectView::OnChangeID()
{
	// Just return if nothing is selected.

    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();
    if  (!htiSelected)
        return ;

	// The selected item should be a pointer to a RCID node.  Get a pointer
	// to the node and verify its type.  Return if the type is incorrect.

	CRCIDNode* prcidn = (CRCIDNode*) m_ctcDriver.GetItemData(htiSelected) ;
    if (!prcidn->IsKindOf(RUNTIME_CLASS(CRCIDNode)))
		return ;

    //  Walk back up the hierarchy to find this RCID node's owning project node.

    CProjectNode&  cpn = * (CProjectNode *) m_ctcDriver.GetItemData(
        m_ctcDriver.GetParentItem(prcidn->Handle())) ;
    ASSERT(cpn.IsKindOf(RUNTIME_CLASS(CProjectNode)));

	// Init and prompt for the new RC ID.  Return if the user cancels.

	CChangeID ccid ;
	CString cstmp(cpn.FileExt()) ;
	cstmp = cstmp.Mid(1) ;
	ccid.Init(cstmp, cpn.Name(), prcidn->nGetRCID()) ;
	if (ccid.DoModal() == IDCANCEL)
		return ;

	// Call a project node function to finish the work.

	cpn.ChangeID(prcidn, ccid.m_nNewResID, cstmp) ;
}


/******************************************************************************

  CProjectView::OnCheckWorkspace

  Called to check a workspace for completeness and tidiness.

******************************************************************************/

void    CProjectView::OnCheckWorkspace()
{
	// Save the current directory

	CString cscurdir ;
	::GetCurrentDirectory(512, cscurdir.GetBuffer(512)) ;
	cscurdir.ReleaseBuffer() ;

	// Change the current directory to the directory containing the GPDs and
	// then check the workspace.

	SetCurrentDirectory(((CProjectRecord*) GetDocument())->GetW2000Path()) ;
	GetDocument()->WorkspaceChecker(false) ;

	// Reset the original directory

	SetCurrentDirectory(cscurdir) ;
}


/******************************************************************************

  CProjectView::OnSize

  Resize the label and tree control in the workspace view when the view is
  resized.

******************************************************************************/

void CProjectView::OnSize(UINT ntype, int cx, int cy)
{
	// First, call this routine for the base class

	CFormView::OnSize(ntype, cx, cy) ;

	// Do nothing else if the other data needed for resizing is uninitialized.
	// Also ignore all WM_SIZE messages except those with types of either
	// SIZE_MAXIMIZED or SIZE_RESTORED.

	if (!bResizingOK || (ntype != SIZE_MAXIMIZED && ntype != SIZE_RESTORED))
		return ;

	// Determine how much the window's dimensions have changed

	int ndx = cx - crWSVCurDims.Width() ;
	int ndy = cy - crWSVCurDims.Height() ;
	crWSVCurDims.right += ndx ;
	crWSVCurDims.bottom += ndy ;

	// Update the tree control's dimensions based on how much the window has
	// changed, make sure the control's minimums have not been exceeded, and
	// then change the size of the tree control.
				   
	crTreeCurDims.right += ndx ;
	crTreeCurDims.bottom += ndy ;
	if (crTreeOrgDims.Width() > crTreeCurDims.Width() 
	 || crWSVOrgDims.Width() >= crWSVCurDims.Width())
		crTreeCurDims.right = crTreeOrgDims.right ;
	if (crTreeOrgDims.Height() > crTreeCurDims.Height() 
	 || crWSVOrgDims.Height() >= crWSVCurDims.Height())
		crTreeCurDims.bottom = crTreeOrgDims.bottom ;
	m_ctcDriver.MoveWindow(crTreeCurDims, TRUE) ;

	// Now, do the same thing for the label.  The one difference is that only
	// label's width is allowed to change.

	crLblCurDims.right += ndx ;
	if (crLblOrgDims.Width() > crLblCurDims.Width() 
	 || crWSVOrgDims.Width() >= crWSVCurDims.Width())
		crLblCurDims.right = crLblOrgDims.right ;
	HWND	hlblhandle ;		
	GetDlgItem(IDC_ProjectLabel, &hlblhandle) ;
	::MoveWindow(hlblhandle, crLblCurDims.left, crLblCurDims.top, 
	 crLblCurDims.Width(), crLblCurDims.Height(), TRUE) ;

}


/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog


CCopyItem::CCopyItem(CWnd* pParent /*=NULL*/)
	: CDialog(CCopyItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCopyItem)
	m_csCopyName = _T("");
	m_csCopyPrompt = _T("");
	//}}AFX_DATA_INIT
}


void CCopyItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyItem)
	DDX_Text(pDX, IDC_CopyName, m_csCopyName);
	DDX_Text(pDX, IDC_CopyPrompt, m_csCopyPrompt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCopyItem, CDialog)
	//{{AFX_MSG_MAP(CCopyItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyItem message handlers

void CCopyItem::Init(CString cssrcfile)
{
	// Build the copy prompt string.

	m_csCopyPrompt.Format(IDS_CopyPrompt, cssrcfile) ;
}
/////////////////////////////////////////////////////////////////////////////
// CChangeID dialog


CChangeID::CChangeID(CWnd* pParent /*=NULL*/)
	: CDialog(CChangeID::IDD, pParent)
{
	//{{AFX_DATA_INIT(CChangeID)
	m_csResourceLabel = _T("");
	m_csResourceName = _T("");
	m_nCurResID = 0;
	m_nNewResID = 0;
	//}}AFX_DATA_INIT
}


void CChangeID::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChangeID)
	DDX_Text(pDX, IDC_ResourceLabel, m_csResourceLabel);
	DDX_Text(pDX, IDC_ResourceName, m_csResourceName);
	DDX_Text(pDX, IDC_CurResID, m_nCurResID);
	DDX_Text(pDX, IDC_NewResID, m_nNewResID);
	DDV_MinMaxInt(pDX, m_nNewResID, 1, 999999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangeID, CDialog)
	//{{AFX_MSG_MAP(CChangeID)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangeID message handlers

void CChangeID::Init(CString csrestype, CString csname, int ncurid)
{
	m_csResourceLabel.Format(IDS_ResourceLabel,	csrestype) ;
	m_csResourceName = csname ;
	m_nCurResID	= ncurid ;
}


/******************************************************************************
 
  CDeleteQuery dialog

  This implements the dialog that validates and verifies the removal of a 
  file from the workspace.

******************************************************************************/

CDeleteQuery::CDeleteQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteQuery::IDD, pParent) {
	//{{AFX_DATA_INIT(CDeleteQuery)
	m_csTarget = _T("");
	m_bRemoveFile = FALSE;
	//}}AFX_DATA_INIT
}


void CDeleteQuery::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteQuery)
	DDX_Text(pDX, IDC_DeletePrompt, m_csTarget);
	DDX_Check(pDX, IDC_Remove, m_bRemoveFile);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDeleteQuery, CDialog)
	//{{AFX_MSG_MAP(CDeleteQuery)
	ON_BN_CLICKED(IDNO, OnNo)
	ON_BN_CLICKED(IDYES, OnYes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteQuery message handlers

void CDeleteQuery::Init(CString csrestype, CString csname) 
{
	m_csTarget.Format(IDS_DeletePrompt, csrestype, csname) ;
}


void CDeleteQuery::OnYes() {
	if  (UpdateData())
        EndDialog(IDYES);
	
}


void CDeleteQuery::OnNo() {
	EndDialog(IDNO);
}


/******************************************************************************

  CProjectView::OnFileInf

  Called when the Generate INF command is selected on the File menu.  This
  routine invokes the INF file generation wizard to collect input and generate
  the INF file.  Then create and initialize a window to display the INF file.

******************************************************************************/

void CProjectView::OnFileInf() 
{
	// INF files can only be generated for projects that contain models (GPDs).

	if (GetDocument()->ModelCount() == 0) {
		CString csmsg ;
		csmsg.LoadString(IDS_INFNoModelsError) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return ;
	} ;

    // Initialize the INF generation wizard.

    CINFWizard* pciw = new CINFWizard(this) ;

    // Invoke the INF generation wizard. Clean up and return if the user 
	// cancels.

    if (pciw->DoModal() == IDCANCEL) {
		delete pciw ;
		return ;
	} ;

	// Generate the INF file based on the information collected.

	if (!pciw->GenerateINFFile()) {
		delete pciw ;
		return ;
	} ;

	// Allocate and initialize the document.

    CINFWizDoc* pciwd = new CINFWizDoc((CProjectRecord*) GetDocument(), pciw) ;

	// Create the window.

    CMDIChildWnd* pcmcwnew ;
	CMultiDocTemplate* pcmdt = INFViewerTemplate() ;
	pcmcwnew = (CMDIChildWnd *) pcmdt->CreateNewFrame(pciwd, NULL) ;

	// If the window was created, finish the initialization.  Otherwise, just 
	// return.

    if  (pcmcwnew) {
        pcmdt->InitialUpdateFrame(pcmcwnew, pciwd, TRUE) ;
        pcmdt->AddDocument(pciwd) ;
	} ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\pfmconv.c ===
/******************************************************************************

  Source File:  PFMConv.C

  This file is a hack- NT Build can't traverse directories on a SOURCES= line,
  so this file #includes all of the files I need for PFM conversion from 
  elsewhere in the tree.

  Copyright c) 1997 by Microsoft Corporation

  Change History:
  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Created it, hope I never touch it
  again...

******************************************************************************/

#ifdef  DBG
#undef	DBG
#endif


// This definition causes additional code to be compiled in 
// ..\pfm2ufm\pfmconv.c!PGetDefaultGlyphset().

#define	BUILD_FULL_GTT


#include    "..\pfm2ufm\pfm2ufm.c"
#include    "..\pfm2ufm\pfmconv.c"
#include    "..\ctt2gtt\cttconv.c"
#include	"..\..\..\lib\uni\fontutil.c"
#include	"..\..\..\lib\uni\globals.c"
#include	"..\..\..\lib\uni\unilib.c"
#include	"..\..\..\lib\uni\um\umlib.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\prtdlg.cpp ===
// PrtDlg.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"

#include "PrtDlg.h"
#include "Windows.h"
#include "commdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrtDlg dialog


CPrtDlg::CPrtDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPrtDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPrtDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPrtDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPrtDlg)
	DDX_Control(pDX, IDC_PRINT_COMBO, m_ccbPrtList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrtDlg, CDialog)
	//{{AFX_MSG_MAP(CPrtDlg)
	ON_BN_CLICKED(IDC_PRINT_SETUP, OnPrintSetup)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrtDlg message handlers
/*
  	show print standard sheet dialog box and set up
  
*/
void CPrtDlg::OnPrintSetup() 
{
/*
	HRESULT hResult;
	LPPRINTDLGEX pPDX = NULL;
LPPRINTPAGERANGE pPageRanges = NULL;

// Allocate the PRINTDLGEX structure.

pPDX = (LPPRINTDLGEX)GlobalAlloc(GPTR, sizeof(PRINTDLGEX));
if (!pPDX)
    return E_OUTOFMEMORY;

// Allocate an array of PRINTPAGERANGE structures.

pPageRanges = (LPPRINTPAGERANGE) GlobalAlloc(GPTR, 
                   10 * sizeof(PRINTPAGERANGE));
if (!pPageRanges)
    return E_OUTOFMEMORY;

//  Initialize the PRINTDLGEX structure.

pPDX->lStructSize = sizeof(PRINTDLGEX);
pPDX->hwndOwner = hWnd;
pPDX->hDevMode = NULL;
pPDX->hDevNames = NULL;
pPDX->hDC = NULL;
pPDX->Flags = PD_RETURNDC | PD_COLLATE;
pPDX->Flags2 = 0;
pPDX->ExclusionFlags = 0;
pPDX->nPageRanges = 0;
pPDX->nMaxPageRanges = 10;
pPDX->lpPageRanges = pPageRanges;
pPDX->nMinPage = 1;
pPDX->nMaxPage = 1000;
pPDX->nCopies = 1;
pPDX->hInstance = 0;
pPDX->lpPrintTemplateName = NULL;
pPDX->lpCallback = NULL;
pPDX->nPropertyPages = 0;
pPDX->lphPropertyPages = NULL;
pPDX->nStartPage = START_PAGE_GENERAL;
pPDX->dwResultAction = 0;

//  Invoke the Print property sheet.

hResult = PrintDlgEx(pPDX);

if ( (hResult == S_OK) &&
           pPDX->dwResultAction == PD_RESULT_PRINT) {

    // User clicked the Print button, so
    // use the DC and other information returned in the 
    // PRINTDLGEX structure to print the document
	
*/	
}	
	
	
/*void CPrtDlg::OnOK()
Print out Gpd view
	
  Get DOCINFO
  Get PrintDC, 
  1. StartDoc(), StartPage(), EndPage(),  
	
	
  2. Things to consider
	
     2.1  line number of printable area
	 2.2  character height for 2.1
	 2.3  Clipping area  --> 
	       2.3.1  selection part -> capture string(avoid disrupting its format)
           2.3.2  All -> GPDDOC();
     
	   
*/	

void CPrtDlg::OnOK() 
{   
//	CGPDViewer* pcgv = (CGPDViewer *)GetParent();
// get View, Doc class 
	CWnd *pcw = GetParent();

//	CDocument *pcd = pcw ->GetDocument();

// Get PrintDC
        

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\raslib.h ===
/************************** Module Header ***********************************
 * raslib.h
 *      Include file to provide prototypes and data types for the rasdd
 *      private library.
 *
 * Copyright (C) 1992 - 1993    Microsoft Corporation.
 *
 *****************************************************************************/

/*
 *   The simple way to turn ANSI to UNICODE>
 */


/*
 *   A convenient grouping for passing around information about the
 * Win 3.1 font information.
 */

typedef  struct
{
    BYTE           *pBase;      /* The base address of data area */
    DRIVERINFO      DI;         /* DRIVERINFO for this font */
    PFMHEADER       PFMH;       /* Properly aligned, not resource format */
    PFMEXTENSION    PFMExt;     /* Extended PFM data,  properly aligned! */
    EXTTEXTMETRIC  *pETM;       /* Extended text metric */
} FONTDAT;

/*
 *   Function prototypes for functions that convert Win 3.1 PFM style
 *  font info to the IFIMETRICS etc required by NT.
 */

/*   Convert PFM style metrics to IFIMETRICS  */
IFIMETRICS *FontInfoToIFIMetric( FONTDAT  *, HANDLE, PWSTR, char ** );

/*   Extract the Command Descriptors for (de)selecting a font */
CD *GetFontSel( HANDLE, FONTDAT *, int );


/*   Convert from non-aligned x86 format Win 3.1 data to aligned versions */
void ConvFontRes( FONTDAT * );

/*   Obtain the width vector - proportionally spaced fonts only */
short  *GetWidthVector( HANDLE, FONTDAT * );

/*
 *     Functions to return the integer value in a WORD or DWORD.  Functions
 *  do two operations:   first is to align the data,  second is to
 *  adjuest the byte order to the current machine.  The input is
 *  assumed to be little endian,  like the x86.
 */

extern "C" WORD   DwAlign2( BYTE * );
extern "C" DWORD  DwAlign4( BYTE * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MiniDev.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projnode.h ===
/******************************************************************************

  Header File:  Project Node.H

  This describes the Project Node.  This keeps the Project Control Window code
  simple, by having a project node which can create new intances of itself, 
  import itself from another source, edit itself, etc.  Most Menu and tree view
  notification messages wind up being handled by being passed to the currently
  selected node on the tree, which will be an instance of a class derived from
  this one.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:
  12-16-96  KjelgaardR@acm.org  Created it

******************************************************************************/

#if !defined(PROJECT_NODES)

#define PROJECT_NODES

#if defined(LONG_NAMES)
#include    "Utility Classes.H"
#else
#include    "Utility.H"
#endif

//  CBasicNode - base class for stuff we can manipulate

class CBasicNode : public CObject {
    DECLARE_SERIAL(CBasicNode)
    CBasicNode*     m_pcbnWorkspace;//  Basic Node for the workspace

protected:
    CString         m_csName;       //  These should always have a name...
    HTREEITEM       m_hti;          //  Handle in the owning tree view
    CTreeCtrl       *m_pctcOwner;   //  The window that owns us
    CMDIChildWnd    *m_pcmcwEdit;   //  The window we're being edited in.
    CDocument       *m_pcdOwner;    //  Document we are part of
    CWordArray      m_cwaMenuID;    //  Menu auto-fill
	bool			m_bUniqueNameChange ;	// True iff name change to make it
											// uniqe.  (See UniqueName().)

public:
    CBasicNode();
    ~CBasicNode();

    CString         Name() const { return m_csName; }

    HTREEITEM   Handle() const { return m_hti; }

    void		NoteOwner(CDocument& cdOwner) { m_pcdOwner = &cdOwner; }
    CDocument*	GetOwner() { return m_pcdOwner ; }

    void    SetWorkspace(CBasicNode* pcbnWS) { m_pcbnWorkspace = pcbnWS; }
    CBasicNode* GetWorkspace() { return m_pcbnWorkspace ; }

	void    Changed(BOOL bModified = TRUE, BOOL bWriteRC = FALSE) ;

	void	UniqueName(bool bsizematters, bool bfile, LPCTSTR lpstrpath = _T("")) ;

	//  Name ourselves and children- default to just our name, no children
    virtual void    Fill(CTreeCtrl *pctcWhere, 
                         HTREEITEM htiParent = TVI_ROOT);
    
    //  Overridable functions to allow polymorphic tree node handling
    virtual void            ContextMenu(CWnd *pcw, CPoint cp);
    virtual CMDIChildWnd    *CreateEditor() { return NULL; }
    virtual BOOL            CanEdit() const { return  TRUE; }
    virtual void            Delete() { }  //  Default is don't honor it!
    virtual void            Import() { }    //  Never at this level!
    //  This override is called if our label is edited, or we are otherwise
    //  renamed...
    virtual BOOL            Rename(LPCTSTR lpstrNewName);

    void			Edit() ;
    void			OnEditorDestroyed() { m_pcmcwEdit = NULL ; }
	CMDIChildWnd*	GetEditor() ;

    virtual void    Serialize(CArchive& car);
    
    void    WorkspaceChange(BOOL bModified = TRUE, BOOL bWriteRC = FALSE) { 
        if  (m_pcbnWorkspace)
            m_pcbnWorkspace -> Changed(bModified, bWriteRC);
    }
};


// Sometimes, it is useful to know something about the type of data managed by
// a fixed node or a strings node.  The following enumeration one way to do 
// this.

typedef enum {
	FNT_RESOURCES = 0,
	FNT_UFMS,
	FNT_GTTS,
	FNT_GPDS,
	FNT_STRINGS,
	FNT_OTHER,
	FNT_UNKNOWN
} FIXEDNODETYPE ;


// CStringsNode is a hybrid between CFixedNode and CProjectNode.  It is a fixed
// node that can be opened and edited.

class CStringsNode : public CBasicNode {
	unsigned        m_uidName;
    CSafeObArray    &m_csoaDescendants;
    CMultiDocTemplate*  m_pcmdt;    // Used for importing data
    CRuntimeClass*      m_pcrc;     // The second half of the import
    FIXEDNODETYPE	m_fntType ;		// Node type
	int m_nFirstSelRCID ;			// RC ID of first entry to select in editor
    DECLARE_DYNAMIC(CStringsNode)

public:
    CStringsNode(unsigned uidName, CSafeObArray& csoa, 
				 FIXEDNODETYPE fnt = FNT_OTHER, CMultiDocTemplate *pcmdt = NULL, 
				 CRuntimeClass *pcrc = NULL);
                 
	void    SetMenu(CWordArray& cwaSpec) { m_cwaMenuID.Copy(cwaSpec); }

    virtual BOOL			CanEdit() const { return TRUE; }
    virtual void			Fill(CTreeCtrl *pctc, HTREEITEM hti);
    virtual CMDIChildWnd*   CreateEditor();
	int  GetFirstSelRCID() { return m_nFirstSelRCID ; }
	void SetFirstSelRCID(int nrcid) { m_nFirstSelRCID = nrcid ; }
};

class CFileNode : public CBasicNode {
    
    BOOL    m_bEditPath, m_bCheckForValidity;
    CString m_csExtension, m_csPath;

    DECLARE_SERIAL(CFileNode)

    const CString ViewName() { 
        return m_bEditPath ? m_csPath + m_csName : m_csName;
    }

public:
    CFileNode();

    //  Attributes
    CString NameExt() const { return Name() + m_csExtension; }
    CString FullName() const { return m_csPath + Name() + m_csExtension; }
    const CString   Path() const { return m_csPath; }
    const CString   Extension() const { return m_csExtension; }
    virtual BOOL    CanEdit() const;
    //  Operations
    void    SetExtension(LPCTSTR lpstrExt) { m_csExtension = lpstrExt; }
    void    AllowPathEdit(BOOL bOK = TRUE) { m_bEditPath = bOK; }
    void    EnableCreationCheck(BOOL bOn = TRUE) { m_bCheckForValidity = bOn; }
	void	SetPath(LPCTSTR lpstrNew) { m_csPath = lpstrNew ; }
	void	SetPathAndName(LPCTSTR lpstrpath, LPCTSTR lpstrname) ;

    //  Overriden CBasicNode operations

    virtual BOOL    Rename(LPCTSTR lpstrNewName);
    virtual void    Fill(CTreeCtrl* pctc, HTREEITEM htiParent);
    virtual void    Serialize(CArchive& car);
};


// This class is used to manage the RC ID nodes in the Workspace view.  
// Currently, there is one of these for each UFM and GTT node.
//
// Note: This class must be enhanced to support extra functionality.
    
class CRCIDNode : public CBasicNode {
    int				m_nRCID;		// RC ID
    FIXEDNODETYPE	m_fntType ;		//  Node type
    DECLARE_SERIAL(CRCIDNode)

public:
    CRCIDNode() ;
	~CRCIDNode() {} ;

    virtual void Fill(CTreeCtrl *pctc, HTREEITEM hti, int nid, FIXEDNODETYPE fnt) ;
	int				nGetRCID() { return m_nRCID ; }
	void			nSetRCID(int nrcid) { m_nRCID = nrcid ; }
	FIXEDNODETYPE	fntGetType() { return m_fntType ; }
	void			fntSetType(FIXEDNODETYPE fnt) { m_fntType = fnt ; }

    virtual void    Serialize(CArchive& car);

	void			BuildDisplayName() ;
};


//  We bring it all together in a limited fashion at least, for the project
//  level node- it always contains a file name node.

class CProjectNode : public CBasicNode {
    DECLARE_SERIAL(CProjectNode)

	bool				m_bRefFlag ;	// Referenced flag used in WS checking

protected:
    CMultiDocTemplate*  m_pcmdt;

public:
    CProjectNode();

    CFileNode           m_cfn;
	CRCIDNode			m_crinRCID;		//  Workspace view, RC ID node

    const CString   FileName() const { return m_cfn.FullName(); }
    const CString   FilePath() const { return m_cfn.Path(); }
    const CString   FileTitle() const { return m_cfn.Name(); }
    const CString   FileExt() const { return m_cfn.Extension(); }
    const CString   FileTitleExt() const { return m_cfn.NameExt(); }
	
	const CString	GetPath() const { return m_cfn.Path() ; }
	void  SetPath(LPCTSTR lpstrNew) { m_cfn.SetPath(lpstrNew) ; }

    BOOL    SetFileName(LPCTSTR lpstrNew) { return m_cfn.Rename(lpstrNew); }
    void    EditorInfo(CMultiDocTemplate* pcmdt) { m_pcmdt = pcmdt; }
    BOOL    ReTitle(LPCTSTR lpstrNewName) {
        return m_cfn.CBasicNode::Rename(lpstrNewName);
    }

    virtual void    Fill(CTreeCtrl *pctcWhere, HTREEITEM htiParent = TVI_ROOT,
                         unsigned urcid = -1, FIXEDNODETYPE fnt = FNT_UNKNOWN);

    virtual void    Serialize(CArchive& car);

    // RC ID management routines

	int		nGetRCID() { return m_crinRCID.nGetRCID() ; }
	void	nSetRCID(int nrcid) { m_crinRCID.nSetRCID(nrcid) ; }
	void	ChangeID(CRCIDNode* prcidn, int nnewid, CString csrestype) ;

	// Reference flag management routines

	bool GetRefFlag() { return m_bRefFlag ; } 
	void SetRefFlag() { m_bRefFlag = true ; } 
	void ClearRefFlag() { m_bRefFlag = false ; } 
};


// This is a special class for nodes with constant names.  IE, labels for 
// groups of UFMs, GTTs, etc most of the time.	

class CFixedNode : public CBasicNode {
	unsigned        m_uidName;
    CSafeObArray    &m_csoaDescendants;
    CMultiDocTemplate*  m_pcmdt;    //  Used for importing data
    CRuntimeClass*      m_pcrc;     //  The second half of the import
    FIXEDNODETYPE	m_fntType ;		//  Node type
    DECLARE_DYNAMIC(CFixedNode)

public:
    CFixedNode(unsigned uidName, CSafeObArray& csoa, FIXEDNODETYPE fnt = FNT_OTHER,  
               CMultiDocTemplate *pcmdt = NULL, CRuntimeClass *pcrc = NULL);

	void    SetMenu(CWordArray& cwaSpec) { m_cwaMenuID.Copy(cwaSpec); }

    //  GPD Deletion support

    void    Zap(CProjectNode * pcpn, BOOL bdelfile) ;

    virtual BOOL    CanEdit() const { return FALSE; }
    virtual void    Import();
	void			Copy(CProjectNode *pcpnsrc, CString csorgdest) ;
	int				GetNextRCID() ;
    virtual void    Fill(CTreeCtrl *pctc, HTREEITEM hti);

	bool			IsFileInWorkspace(LPCTSTR strfspec)	;
	bool			IsRCIDUnique(int nid) ;

    FIXEDNODETYPE	GetType() { return m_fntType ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projrec.h ===
/******************************************************************************

  Header File:  Project Record.H

  This defines the CProjectRecord class, which tracks and controls the progress
  and content of a single project workspace in the studio.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(AFX_PROJREC_H__50303D0C_EKE1_11D2_AB62_00C04FA30E4A__INCLUDED_)
#define AFX_PROJREC_H__50303D0C_EKE1_11D2_AB62_00C04FA30E4A__INCLUDED_

#if defined(LONG_NAMES)
#include    "Driver Resources.H"
#else
#include    "RCFile.H"
#endif

///////////////////////////////////////////////////////////////////////////////
//
// MDT Workspace Versioning
//
// The MDT uses MFC's Serialization support to save and restore the state of a
// driver's workspace.  This data is saved in an MDW file.  The Serialization
// support is supposed to include versioning but it doesn't seem to be working
// so I have implemented my own versioning support for workspace files.
//
// A version stamp in the form of the following structure 
// (plus related definitions) will be added to the beginning of each MDW file.
// The CProjectRecord::Serialize() will read and write the version stamp.  The
// version info is saved in a member variable (m_mvMDWVersion) and the number 
// is accessible via GetMDWVersion().  A version number of 0 is put into 
// m_nMDWVersion if the an old MDW with no version is read.  In this case, the
// workspace is marked as being dirty so that it can be updated later.
//
// The current version number is set by the value for MDW_CURRENT_VERSION.  
// Version numbers are unsigned integers.  Each time the version number is
// changed, an entry should be made in the following table describing the 
// reason for the change.
//
//
// MDW VERSION HISTORY
//
// Version		Date		Description
// ----------------------------------------------------------------------------
//	  0			02/01/98	Contains no version info.  Should be the MDW 
//							version that has UFM and GTT RC IDs in it.
//	  1			04/21/98	String table RC IDs were added to the MDW files.
//	  2			10/08/98	Default code page number added to the MDW files.
//	  3			09/15/98	RC file timestamp was added to the MDW file.
//	  4			12/14/98	Resource DLL name changed from xxxxxRES.DLL to 
//							xxxxxxxx.DLL.
//	  5			03/02/99	Driver file paths removed from the MDW file.
//	  6			08/16/99	Changed the root of the driver files' subtree from
//							NT5 to W2K so that the directory name matches the
//							OS name.
//
//
// The version information below is used to determine what is in an MDW file 
// and when to upgrade that file and other parts of a driver's workspace; most
// notably the RC file.  Upgrade determination and work (or at least the code 
// that manages the upgrading) are in CProjectRecord::OnOpenDocument().  See
// that member function for more information.
//

// Definitions for the current MDW version, each MDW version that has been
// used, the first upgradable version, and the default MDW version.
										
#define MDW_CURRENT_VERSION			7	// See table above for more info
#define MDW_VER_YES_FILE_PATHS      7	// Give .mdw file saving place flexibility. //raid 123448
#define MDW_VER_FILES_IN_W2K_TREE	6	// Driver files in W2K tree
#define MDW_VER_NO_FILE_PATHS		5	// Removed file paths from MDW file
#define MDW_VER_NEW_DLLNAME			4	// Ver # when resource DLL name changed
#define MDW_VER_RC_TIMESTAMP		3	// Ver # when RC file timestamp added
#define MDW_VER_DEFAULT_CPAGE		2	// Ver # when default code page added
#define MDW_VER_STRING_RCIDS		1	// Ver # when string IDs added
#define MDW_FIRST_UPGRADABLE_VER	1	// All vers >= to this can be upgraded
#define MDW_DEFAULT_VERSION			0	// Ver # when no ver info in MDW file

#define VERTAGLEN				12				// Length of the version tag
#define	VERTAGSTR				"EKE MDW VER"	// Version tag string

typedef struct mdwversioninfo {
	char		acvertag[VERTAGLEN] ;	// Used to identify version stamp
	unsigned	uvernum ;				// Version number
} MDWVERSION, *PMDWVERSION ;

#define	MDWVERSIONSIZE	sizeof(MDWVERSION) 


enum {Win95 = 1, WinNT3x, WinNT40 = 4, Win2000 = 8, NotW2000 = 16};

class CProjectRecord : public CDocument {
    CString m_csSourceRCFile, m_csRCName;
    CString m_csW2000Path, m_csNT40Path, m_csNT3xPath, m_csWin95Path;
	
	CString m_csProjFSpec ;		// Location of project file.

	// True iff the RC file should be rewritten whenever the project workspace
	// file is saved.

	BOOL	m_bRCModifiedFlag ;	
    
	UINT    m_ufTargets;

    CDriverResources    m_cdr;  //  A record of the RC file contents
    
    //  Enumerated flags for the project's status

    enum {UniToolRun = 1, ConversionsDone = 2, NTGPCDone = 4};
    UINT    m_ufStatus;

	MDWVERSION	m_mvMDWVersion ;	// MDW version information

	virtual BOOL OnSaveDocument( LPCTSTR lpszPathName ) ;

	// Last time RC file was changed by MDT.

	CTime	m_ctRCFileTimeStamp ;
	
	// The next two variables are used to save the default code page number.
	// Two variables are used because the Far East code pages are built into
	// the MDT as resources so - in these cases - the Far East code pages'
	// resource number (actually negative resource number) is needed too.

	DWORD	m_dwDefaultCodePage ;	// Code page number / neg resource ID
	DWORD	m_dwDefaultCodePageNum ;// Code page number 

protected: // create from serialization only
	CProjectRecord();
	DECLARE_DYNCREATE(CProjectRecord)

// Attributes
public:

	void	SetRCModifiedFlag(BOOL bsetting) {m_bRCModifiedFlag = bsetting ; }

    BOOL    IsTargetEnabled(UINT ufTarget) const { 
        return m_ufTargets & ufTarget;
    }

    BOOL    UniToolHasBeenRun() const { return m_ufStatus & UniToolRun; }
    BOOL    ConversionsComplete() const {
        return m_ufStatus & ConversionsDone; 
    }
    BOOL    NTGPCCompleted() const { return m_ufStatus & NTGPCDone; }

    CString SourceFile() const { return m_csSourceRCFile; }

    CString     DriverName() { return m_cdr.Name(); }

    CString TargetPath(UINT ufTarget) const;

    CString     RCName(UINT ufTarget) const {
        return  TargetPath(ufTarget) + _TEXT("\\") + m_csRCName;
    }

    unsigned    MapCount() const { return m_cdr.MapCount(); }
    CGlyphMap&  GlyphMap(unsigned u) { return m_cdr.GlyphTable(u); }

    unsigned    ModelCount() const { return m_cdr.Models(); }
    CModelData& Model(unsigned u) { return m_cdr.Model(u); }

	CString		GetW2000Path() { return m_csW2000Path ; }

	unsigned	GetMDWVersion() { return m_mvMDWVersion.uvernum ; }

	void		SetMDWVersion(unsigned nver) { m_mvMDWVersion.uvernum = nver ; } 
	
	CStringTable* GetStrTable() { return m_cdr.GetStrTable() ; }

	bool		RCFileChanged() ;

	bool		GetRCFileTimeStamp(CTime& ct) ;

	// See variable declarations for more info about these functions.

	DWORD GetDefaultCodePage() { return m_dwDefaultCodePage ; }
	DWORD GetDefaultCodePageNum() { return m_dwDefaultCodePageNum ; }
	void SetDefaultCodePage(DWORD dwcp) { m_dwDefaultCodePage = dwcp ; }
	void SetDefaultCodePageNum(DWORD dwcp) { m_dwDefaultCodePageNum = dwcp ; }

	CString		GetProjFSpec() { return m_csProjFSpec ; }

// Operations
public:

    void    EnableTarget(UINT ufTarget, BOOL bOn = TRUE) {
        UINT    ufCurrent = m_ufTargets;
        if  (bOn)
            m_ufTargets |= ufTarget;
        else
            m_ufTargets &= ~ufTarget;
        if  (ufCurrent == m_ufTargets)
            return;
        if  (ufTarget & (WinNT3x | WinNT40 | Win2000) ) { //raid 105917
            m_ufStatus &=~(ConversionsDone | NTGPCDone);
            return;
        }
    }

    void    SetSourceRCFile(LPCTSTR lpstrSource);

    BOOL    LoadResources();

    BOOL    LoadFontData() { return m_cdr.LoadFontData(*this); }
    
	// The next 3 functions support the GPD Selection feature in the Conversion
	// Wizard.

	BOOL    GetGPDModelInfo(CStringArray* pcsamodels, CStringArray* pcsafiles) {
		return m_cdr.GetGPDModelInfo(pcsamodels, pcsafiles) ; 
	}

	int		SaveVerGPDFNames(CStringArray& csafiles, bool bverifydata) {
		return m_cdr.SaveVerGPDFNames(csafiles, bverifydata) ;
	} ;
    
	void   GenerateGPDFileNames(CStringArray& csamodels, CStringArray& csafiles) {
		m_cdr.GenerateGPDFileNames(csamodels, csafiles) ; 
	}

	BOOL    SetPath(UINT ufTarget, LPCTSTR lpstrNewPath);

    BOOL    BuildStructure(unsigned uVersion);

    BOOL    GenerateTargets(WORD wfGPDConvert);

    void    OldStuffDone() { m_ufStatus |= NTGPCDone; }
    void    Rename(LPCTSTR lpstrNewName) { m_cdr.Rename(lpstrNewName); }
    void    InitUI(CTreeCtrl *pctc) { m_cdr.Fill(pctc, *this); }
    void    GPDConversionCheck(BOOL bReportSuccess = FALSE);

	// Conversion log file management routines

	bool	OpenConvLogFile(void) { 
		return m_cdr.OpenConvLogFile(m_csSourceRCFile) ; 
	}
	void	CloseConvLogFile(void) { m_cdr.CloseConvLogFile() ; }
	CString	GetConvLogFileName() const {return m_cdr.GetConvLogFileName() ; }
	bool	ThereAreConvErrors() {return m_cdr.ThereAreConvErrors() ; }

	bool	WorkspaceChecker(bool bclosing) {
		return m_cdr.WorkspaceChecker(bclosing) ;
	}

	// Upgrade management routines.

	bool	UpdateRCFile() ;
	bool	UpdateDfltCodePage() ;
	bool	UpdateDrvSubtreeRootName() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectRecord)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	CGlyphMap& GlyphTable(unsigned u) { return m_cdr.GlyphTable(u) ; } ;
	BOOL CreateFromNew(CStringArray& csaUFMFiles,CStringArray& csaGTTFiles,CString& csGpdPath,CString& csModelName,CString& csResourceDll,CStringArray& csaRcid );
	bool    VerUpdateFilePaths(void);
	virtual ~CProjectRecord();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CProjectRecord)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CGetDefCodePage dialog

class CGetDefCodePage : public CDialog
{
	// The next two variables are used to save the default code page number.
	// Two variables are used because the Far East code pages are built into
	// the MDT as resources so - in these cases - the Far East code pages'
	// resource number (actually negative resource number) is needed too.

	DWORD	m_dwDefaultCodePage ;	// Code page number / neg resource ID
	DWORD	m_dwDefaultCodePageNum ;// Code page number 

// Construction
public:
	CGetDefCodePage(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGetDefCodePage)
	enum { IDD = IDD_UpgDefCPage };
	CListBox	m_clbCodePages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetDefCodePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	// See variable declarations for more info about these functions.

	DWORD GetDefaultCodePage() { return m_dwDefaultCodePage ; }
	DWORD GetDefaultCodePageNum() { return m_dwDefaultCodePageNum ; }

protected:

	// Generated message map functions
	//{{AFX_MSG(CGetDefCodePage)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // !defined(AFX_PROJREC_H__50303D0C_EKE1_11D2_AB62_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projview.h ===
/******************************************************************************

  Header File:  Project View.H

  This defines the class which provides the UI for viewing and manipulating
  project level information for the studio.

  Copyright (c) 1997 by Microsoft Corporaiton.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/
#if defined(LONG_NAMES)
#include    "Project Record.H"
#else
#include    "ProjRec.H"
#endif

class CProjectView : public CFormView {
protected: // create from serialization only
	CProjectView();
	CRect	crWSVOrgDims ;		// Window's original dimensions
	CRect	crWSVCurDims ;		// Window's current dimensions
	CRect	crTreeCurDims ;		// Current tree (m_ctcDriver) control dimensions
	CRect	crTreeOrgDims ;		// Original tree (m_ctcDriver) control dimensions
	CRect	crLblCurDims ;		// Current label dimensions
	CRect	crLblOrgDims ;		// Current label dimensions
	bool	bResizingOK ;		// True iff it is OK to resize the control(s)
	DECLARE_DYNCREATE(CProjectView)

// Attributes
public:
	//{{AFX_DATA(CProjectView)
	enum { IDD = IDD_ProjectForm };
	CTreeCtrl	m_ctcDriver;
	//}}AFX_DATA
	CProjectRecord* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CProjectView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

    //  Messages generated by tree view nodes derived from CProjectNode
    afx_msg void    OnExpandBranch();
    afx_msg void    OnCollapseBranch();
    afx_msg void    OnRenameItem();
    afx_msg void    OnOpenItem();
    //afx_msg void    OnGenerateItem();
    afx_msg void    OnImport();
    afx_msg void    OnDeleteItem();
    afx_msg void    OnCopyItem();
    afx_msg void    OnChangeID();
    afx_msg void    OnCheckWorkspace();

// Generated message map functions
protected:
	//{{AFX_MSG(CProjectView)
	afx_msg void OnBeginlabeleditDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblclkDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFileParse();
	afx_msg void OnKeydownDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSize(UINT ntype, int cx, int cy) ;
	afx_msg void OnFileInf();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in Project View.cpp
inline CProjectRecord* CProjectView::GetDocument()
   { return (CProjectRecord*)m_pDocument; }
#endif
/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog

class CCopyItem : public CDialog
{
// Construction
public:
	CCopyItem(CWnd* pParent = NULL);   // standard constructor
	void Init(CString cssrcfile);

// Dialog Data
	//{{AFX_DATA(CCopyItem)
	enum { IDD = IDD_CopyItem };
	CString	m_csCopyName;
	CString	m_csCopyPrompt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCopyItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCopyItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CChangeID dialog

class CChangeID : public CDialog
{
// Construction
public:
	void Init(CString csrestype, CString csname, int ncurid);
	CChangeID(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CChangeID)
	enum { IDD = IDD_ChangeID };
	CString	m_csResourceLabel;
	CString	m_csResourceName;
	int		m_nCurResID;
	int		m_nNewResID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangeID)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CChangeID)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDeleteQuery dialog

class CDeleteQuery : public CDialog {
// Construction
public:
	CDeleteQuery(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteQuery)
	enum { IDD = IDD_DeleteQuery };
	CString	m_csTarget;
	BOOL	m_bRemoveFile;
	//}}AFX_DATA

    void    Init(CString csrestype, CString csname) ;
    BOOL    KillFile() const { return m_bRemoveFile; }
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteQuery)
	afx_msg void OnNo();
	afx_msg void OnYes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MiniDev.rc
//
#define NewProjectWizardTitle           1
#define OpenRCDialogTitle               2
#define IDOK2                           2
#define IDS_UnitoolNotRun               3
#define IDP_UnitoolNotRun               3
#define IDS_RCLoadFailed                4
#define IDP_RCLoadFailed                4
#define IDS_Unimplemented               5
#define IDS_CannotMakeDirectory         6
#define IDP_CannotMakeDirectory         6
#define IDS_Atlas                       7
#define IDS_FontList                    8
#define ID_RenameItem                   9
#define ID_ExpandBranch                 10
#define ID_CollapseBranch               11
#define ID_OpenItem                     12
#define IDS_MapColumn0                  13
#define IDS_MapColumn1                  14
#define IDS_MapColumn2                  15
#define IDS_MapsGenerated               16
#define IDS_NoPredefined                16
#define IDS_MapsFailed                  17
#define IDS_NoErrorsAnywhere            17
#define ID_ChangeInvocation             18
#define ID_ChangeCodePage               19
#define ID_DeleteItem                   20
#define IDS_DeleteItemQuery             21
#define ID_GenerateOne                  22
#define IDS_DefaultPage                 41
#define ID_AddItem                      42
#define IDS_NoUnmappedGlyphs            43
#define IDP_NoUnmappedGlyphs            43
#define IDS_LengthMismatch              44
#define IDS_LoadFailure                 45
#define IDS_Models                      46
#define IDS_ConversionErrors            47
#define IDP_ConversionErrors            47
#define IDS_FileName                    48
#define IDS_InvalidFilename             49
#define IDS_OverwritePrompt             50
#define ID_Import                       51
#define IDS_FileOpenError               52
#define IDS_GPCConversionError          53
#define IDS_RemovedInvalid              54
#define IDS_BadFileChars                54
#define IDS_UnusedFont                  55
#define IDS_ResourceID                  56
#define IDS_WidthColumn0                57
#define IDS_WidthColumn1                58
#define IDS_KernColumn0                 59
#define IDS_KernColumn1                 60
#define IDS_KernColumn2                 61
#define IDS_InvalidNumberFormat         62
#define ID_ChangeAmount                 63
#define IDS_CapH                        64
#define IDS_LowerX                      65
#define IDS_SuperSizeX                  66
#define IDS_SuperSizeY                  67
#define IDS_SubSizeX                    68
#define IDS_SubSizeY                    69
#define IDS_SuperMoveX                  70
#define IDS_SuperMoveY                  71
#define IDS_SubMoveX                    72
#define IDS_SubMoveY                    73
#define IDS_ItalicAngle                 74
#define IDS_UnderSize                   75
#define IDS_UnderOffset                 76
#define IDS_StrikeSize                  77
#define IDS_StrikeOffset                78
#define IDS_Baseline                    79
#define IDS_InterlineGap                80
#define IDS_Lowerp                      81
#define IDS_Lowerd                      82
#define IDS_InternalLeading             83
#define IDS_Overweight                  84
#define IDS_InvalidCharSet              85
#define IDS_InvalidCharacter            86
#define IDS_NoDBCS                      87
#define IDS_LimitsSwapped               88
#define IDS_NotWindowed                 89
#define IDS_ScaleReversed               90
#define IDS_WidthReversed               91
#define IDS_AngleTooBig                 92
#define IDS_BadCTTID                    93
#define IDS_NoSyntaxErrors              94
#define IDS_NoUnicodePoint              95
#define IDS_InvalidCTTFormat            96
#define IDS_WaitToFill                  97
#define IDS_NoGPCData                   98
#define IDS_RCFindPrompt                99
#define IDD_ABOUTBOX                    100
#define IDS_Resources                   100
#define IDS_Strings                     101
#define IDD_FORMVIEW                    101
#define CG_IDS_PHYSICAL_MEM             102
#define CG_IDS_DISK_SPACE               103
#define CG_IDS_DISK_SPACE_UNAVAIL       104
#define IDB_LIGHTBULB                   105
#define IDS_GPDSelInitFailed            105
#define IDD_TIP                         106
#define IDS_DupGPDFName                 106
#define CG_IDS_TIPOFTHEDAY              107
#define CG_IDS_TIPOFTHEDAYMENU          108
#define CG_IDS_DIDYOUKNOW               109
#define CG_IDS_FILE_ABSENT              110
#define CG_IDP_FILE_CORRUPT             111
#define CG_IDS_TIPOFTHEDAYHELP          112
#define ID_LineIndicator                113
#define IDS_SelectAll                   113
#define IDR_CP1252                      114
#define IDS_DeselectAll                 114
#define IDR_MAINFRAME                   128
#define IDR_MINIWSTYPE                  129
#define IDD_FirstPageNewWizard          130
#define IDD_NPWSelectDest               131
#define IDD_NPWSelectTargets            132
#define IDD_NPWDefaultCodePageSel       133
#define IDD_RunUniTool                  136
#define IDD_ConvertFiles                137
#define IDD_GPCEditor                   138
#define IDD_ProjectForm                 139
#define IDR_GLYPHMAP                    140
#define IDD_GlyphMappings               142
#define IDD_NPWCodePageSelection        143
#define IDD_SelectPage                  144
#define IDD_CodePageView                145
#define IDD_PredefinedPage              146
#define IDD_AddCodePoints               147
#define IDR_FONT_VIEWER                 148
#define IDD_UFM1_Dlg                    150
#define IDB_PlusButton                  152
#define IDB_DeleteButton                153
#define IDR_GPD_VIEWER                  155
#define IDB_Wizard                      156
#define IDD_GPDErrors                   157
#define IDD_GPDActionBar                157
#define IDD_KerningPairs                166
#define IDD_FontSimulations             168
#define IDI_BrowseArrow                 173
#define IDD_AddKernPair                 175
#define IDD_FILE_NEW_DIALOG             176
#define IDD_UFM2_dpCharSet_Dlg          178
#define IDD_UFM2_dpCharSets_Dlg         178
#define IDD_WSCheck                     179
#define IDD_DIALOG1                     181
#define IDD_StringEditor                182
#define IDD_UFM3_Dlg                    183
#define IDD_UFM2_flINFO_DIALOG          185
#define IDD_DIALOG2                     186
#define IDD_UFM2_PANOSE_DLG             188
#define IDD_RECT_DLG                    189
#define IDD_POINT_DLG                   190
#define IDD_BASE_DIALOG                 191
#define IDD_GotoLine                    192
#define IDD_ErrorLevel                  193
#define IDD_UFM2_fsSelection_Dlg        195
#define IDD_UFM2_jWinPitchAndFamily_Dlg 197
#define IDD_UFM2_jWinCharSet_Dlg        198
#define IDD_UpgDefCPage                 199
#define IDD_UFM2_Dlg                    200
#define IDD_UFM1_fCaps_Dlg              201
#define IDD_UFM1_wType_Dlg              202
#define IDD_CharWidths                  203
#define IDD_UFM1_flGenFlags_Dlg         204
#define IDD_INFW_Sub_NewSection         205
#define IDD_UFM2_Family_Dlg             206
#define IDD_INFCheck                    207
#define IDD_UFM3_ExtMetrics             208
#define IDD_UFM2_IFIMetrics             209
#define IDD_UFM1_Header                 210
#define IDD_UFM1S_GenFlags              211
#define IDD_UFM1S_Caps                  212
#define IDD_UFM1S_Types                 213
#define IDD_UFM2S_Rect                  214
#define IDD_UFM2S_CharSets              215
#define IDD_UFM2S_Family                216
#define IDD_UFM2S_FontSims              217
#define IDD_UFM2S_Info                  218
#define IDD_UFM2S_Panose                219
#define IDD_UFM2S_Point                 220
#define IDD_UFM2S_Selection             221
#define IDD_UFM2S_WinCharSet            222
#define IDD_UFM2S_WinPitchFamily        223
#define IDD_WidthKernCheckResults       224
#define IDD_INFW_IncludeFiles           225
#define IDD_INFW_InstallSections        226
#define IDD_INFW_DataSections           227
#define IDD_INFW_NonStdModelSecs        228
#define IDD_INFW_ModelPnPIDS            229
#define IDD_NewFiles                    230
#define IDD_NewFile                     230
#define IDB_MULTI_ICONS                 231
#define IDB_BITMAP1                     232
#define IDB_MAINFRAME                   233
#define IDB_GPD_VIEWER                  234
#define IDB_GLYPHMAP                    235
#define IDB_FONT_VIEWER                 236
#define IDB_MINIWSTYPE                  237
#define IDD_ProjNew                     238
#define IDD_NewConvert                  239
#define IDD_FILE_PRINT                  240
#define IDD_DIALOG3                     241
#define IDD_DIALOG4                     243
#define IDD_NEW_PROJECT                 244
#define IDD_DIALOG6                     245
#define IDD_NewResource                 246
#define IDB_BITMAP2                     249
#define IDB_SMALLGLYPH                  254
#define IDD_ConvertPFM                  255
#define IDD_ConvertCTT                  256
#define IDC_TargetW2000                 1000
#define IDC_BULB                        1000
#define IDC_TargetNT40                  1001
#define IDC_W2000Destination            1001
#define IDC_STARTUP                     1001
#define IDC_BrowseW2000                 1002
#define IDC_TargetNT3x                  1002
#define IDC_NEXTTIP                     1002
#define IDC_NT40Destination             1003
#define IDC_RunUniTool                  1003
#define IDC_TargetWin95                 1004
#define IDC_BrowseNT40                  1004
#define IDC_PhysicalMemory              1004
#define IDC_TIPSTRING                   1004
#define IDC_FreeDiskSpace               1005
#define IDC_NT3xDestination             1005
#define IDC_RunNtGpcEdit                1005
#define IDC_BrowseNT3x                  1006
#define IDC_ConvertFiles                1006
#define IDC_CodePages                   1006
#define IDC_DriverName                  1007
#define IDC_DriverView                  1008
#define IDC_Win95Destination            1009
#define IDC_GlyphMapping                1009
#define IDC_InstalledPages              1010
#define IDC_SupportedPages              1011
#define IDC_TableToPage                 1011
#define IDC_ChangeCodePage              1012
#define IDC_CodePageList                1014
#define IDC_CurrentPage                 1015
#define IDC_SelectString                1016
#define IDC_DeselectString              1017
#define IDC_AddPage                     1018
#define IDC_RemovePage                  1019
#define IDC_NoPredefined                1020
#define IDC_PredefinedAddTo             1021
#define IDC_RemovePredefined            1022
#define IDC_ReplacePredefined           1023
#define IDC_PredefinedList              1024
#define IDC_GlyphList                   1025
#define IDC_FamilyNames                 1026
#define IDC_FaceName                    1027
#define IDC_UniqueName                  1028
#define IDC_FixedPitch                  1029
#define IDC_VariablePitch               1030
#define IDC_Italic                      1031
#define IDC_Underline                   1032
#define IDC_StrikeOut                   1033
#define IDC_AddFamily                   1034
#define IDC_RemoveFamily                1035
#define IDC_StyleName                   1036
#define IDC_Errors                      1037
#define IDC_RemoveError                 1038
#define IDC_Previous                    1039
#define IDC_Next                        1040
#define NormalConversion                1041
#define CustomConversion                1042
#define IDC_Direct                      1043
#define IDC_Macros                      1044
#define IDC_Common                      1045
#define IDC_SpoolerNames                1046
#define IDC_FamilyBits                  1047
#define IDC_CharSet                     1048
#define IDC_FontWeight                  1049
#define IDC_FontHeight                  1051
#define IDC_FontWidth                   1052
#define IDC_SpecialMetric               1053
#define IDC_FontSpecialValue            1054
#define IDC_SpinFontSpecial             1055
#define IDC_Scalable                    1057
#define IDC_MasterDevice                1059
#define IDC_MasterFont                  1060
#define IDC_PortraitFont                1061
#define IDC_LandscapeFont               1062
#define IDC_MinimumScale                1063
#define IDC_MaximumScale                1064
#define IDC_ScalePoints                 1065
#define IDC_ScaleDevice                 1066
#define IDC_KerningTree                 1067
#define IDC_CharacterWidths             1068
#define IDC_FirstCharacter              1069
#define IDC_LastCharacter               1070
#define IDC_DefaultCharacter            1071
#define IDC_BreakCharacter              1072
#define IDC_ShowANSI                    1073
#define IDC_UnicodeShown                1074
#define IDC_EnableItalicSim             1076
#define IDC_EnableBoldSim               1077
#define IDC_EnableBISim                 1078
#define IDC_ItalicWeight                1079
#define IDC_IMaxWidth                   1080
#define IDC_IAverage                    1081
#define IDC_ItalicSlant                 1082
#define IDC_BoldWeight                  1083
#define IDC_BMaxWidth                   1084
#define IDC_BAverage                    1085
#define IDC_BIWeight                    1086
#define IDC_BIMaxWidth                  1087
#define IDC_BIAverage                   1088
#define IDC_BoldItalicSlant             1089
#define IDC_FontSelector                1090
#define IDC_FontUnselector              1091
#define IDC_FontLocation                1092
#define IDC_FontTechnology              1093
#define IDC_VerticalResolution          1094
#define IDC_HorizontalResolution        1095
#define IDC_PreAdjustY                  1096
#define IDC_PostAdjustY                 1097
#define IDC_CenteringAdjustment         1098
#define IDC_PrivateData                 1099
#define IDC_GTTDescription              1100
#define IDC_ItalicSim                   1101
#define IDC_CanUnderline                1102
#define IDC_CROK                        1103
#define IDC_BoldSim                     1104
#define IDC_DoubleUnderline             1105
#define IDC_StrikeThru                  1106
#define IDC_Backspace                   1107
#define IDC_KernFirst                   1112
#define IDC_KernSecond                  1113
#define IDC_KernAmount                  1114
#define IDC_Overstrike                  1115
#define IDC_Banner                      1116
#define IDC_CopyPrompt                  1119
#define IDC_CopyName                    1120
#define IDC_ResourceLabel               1121
#define IDC_ResourceName                1122
#define IDC_ResIDLabel                  1123
#define IDC_CurResID                    1124
#define IDC_NewResID                    1125
#define IDC_ProjectLabel                1127
#define IDC_CHECK1                      1128
#define IDC_ECName                      1128
#define IDC_ECValue                     1129
#define IDC_ECList                      1130
#define IDC_rbConvertOrGeneric          1131
#define IDC_GPDSelBtn                   1131
#define IDC_rbConvertOrGeneric2         1132
#define IDC_ErrWrnLstBox                1132
#define IDC_rbColorLaser                1133
#define IDC_RecheckBtn                  1133
#define IDC_rbMonochromeLaser           1134
#define IDC_WSCLabel                    1134
#define IDC_rbColorSerial               1135
#define IDC_rbMonochromeSerial          1136
#define IDC_RADIO1                      1137
#define IDC_LIST1                       1137
#define IDC_ErrorLst                    1137
#define IDC_SELabel1                    1138
#define IDC_SELabel2                    1139
#define IDC_SELabel3                    1140
#define IDC_SELstCtrl                   1141
#define IDC_SEGotoBtn                   1142
#define IDC_SEGotoBox                   1143
#define IDC_SESearchBox                 1144
#define IDC_SESearchBtn                 1145
#define IDC_SrchNextBtn                 1146
#define IDC_SrchPrevBtn                 1147
#define IDC_SearchBox                   1148
#define IDC_GotoBox                     1149
#define IDC_UndoBtn                     1150
#define IDC_GotoBtn                     1151
#define IDC_SyntaxBtn                   1152
#define IDC_EWLevelBox                  1153
#define IDC_EWLst                       1153
#define IDC_EditAidsCBox                1154
#define IDC_ErrorLabel                  1155
#define IDC_LIST2                       1156
#define IDC_BUTTON1                     1157
#define IDC_ebUFM1_DefaultCodepage      1158
#define IDC_BUTTON2                     1158
#define IDC_ebUFM1_GlyphSetDataRCID     1159
#define IDC_EDIT1                       1159
#define IDC_CTTBrowser                  1159
#define IDC_EDIT2                       1160
#define IDC_cb_FamilyNames              1162
#define IDC_COMBO1                      1166
#define IDC_ErrorLevelLst               1166
#define IDC_NEWFILES_PROJECT            1166
#define IDC_PRINT_COMBO                 1166
#define IDC_ComboCodePage               1166
#define IDC_ModelsList                  1167
#define IDC_BrowseBtn                   1168
#define IDC_ModelsLst                   1169
#define IDC_ProfileFSpecsBox            1170
#define IDC_ManufacturerBox             1171
#define IDC_eb_Fields                   1172
#define IDC_ProviderBox                 1172
#define IDC_eb_Values                   1173
#define IDC_SectionLst                  1173
#define IDC_lb_Strings                  1174
#define IDC_KeyValueBox                 1174
#define IDC_ModelLst                    1175
#define IDC_BrowsBtn                    1176
#define IDC_SummaryBox                  1177
#define IDC_ICMFSpecsLst                1178
#define IDC_ExtraFSpecsLst              1179
#define IDC_KeyValueLst                 1180
#define IDC_NewSectionBtn               1181
#define IDOK_Subclassed                 1182
#define IDC_NewSectionBox               1182
#define IDC_INFCLabel                   1183
#define IDC_cb_UFM2_Family              1184
#define IDC_UniDrvLst                   1184
#define IDC_pb_UFM2_Family_Add          1185
#define IDC_DefaultCodepageBox          1185
#define IDC_pb_UFM2_Family_Remove       1186
#define IDC_GlyphSetDataRCIDBox         1186
#define IDC_IFIMetricsLst               1187
#define IDC_ExtMetricsLst               1188
#define IDC_SaveCloseChk                1189
#define IDC_FlagsLst                    1190
#define IDC_PointsLst                   1192
#define IDC_PanoseLst                   1193
#define IDC_NamesLst                    1194
#define IDC_RectLst                     1195
#define IDC_BadKerningPairs             1196
#define IDC_WidthTblResults             1197
#define IDC_KernTblResults              1198
#define IDC_IncludeFileBox              1199
#define IDC_UnidrvChk                   1200
#define IDC_UnidrvBidiChk               1201
#define IDC_PscriptChk                  1202
#define IDC_OtherChk                    1203
#define IDC_TtfsubChk                   1204
#define IDC_OtherBox                    1205
#define IDC_ModelSectionLst             1207
#define IDC_ModelsPnPIDList             1208
#define IDC_ReplacePage                 1209
#define IDC_NEWFILES_LIST               1210
#define IDC_NEWFILES_FILENAME           1211
#define IDC_NEWFILENAME                 1211
#define IDC_NEWFILES_LOCATION           1212
#define IDC_FILE_LOC                    1212
#define IDC_CHECK_PROJECT               1213
#define IDC_EDIT_PRJ_NAME               1214
#define IDC_STATIC_ADDTOPRJ             1215
#define IDC_DeletePage                  1216
#define IDC_Browser                     1217
#define IDC_PRINT_ALL                   1220
#define IDC_PRINT_SELECTED              1221
#define IDC_PRINT_SETUP                 1222
#define IDC_CHECK2                      1224
#define IDC_CHECK3                      1225
#define IDC_CHECK4                      1226
#define IDC_CHECK5                      1227
#define IDC_CHECK6                      1228
#define IDC_TREE1                       1232
#define IDC_CHECK7                      1233
#define IDC_CHECK8                      1234
#define IDC_CHECK9                      1235
#define IDC_CHECK10                     1236
#define IDC_EDIT3                       1237
#define IDC_EDIT_RESOUREC               1237
#define IDC_PfmFiles                    1237
#define IDC_UFM_PATH                    1238
#define IDC_GttPath                     1238
#define IDC_NEW_PROJECT                 1239
#define IDC_GTT_PATH                    1239
#define IDC_CONVERT                     1240
#define IDC_CONV_PRJ                    1240
#define IDC_CHECK_FONTS                 1241
#define IDC_SerchUFM                    1242
#define IDC_SearchGTT                   1243
#define IDC_EDIT_NPRJNAME               1244
#define IDC_EDIT_NPRJLOC                1245
#define IDC_Search_PRJ                  1246
#define IDC_DirBrowser                  1247
#define IDC_EDIT_AddTName               1249
#define IDC_EDIT_AddTPath               1250
#define IDC_CHECK_ADD                   1251
#define IDC_LIST_ProjectTemplate        1252
#define IDC_AddTemplate                 1253
#define IDC_EDIT_MODEL                  1254
#define IDC_EDIT_GPD                    1255
#define IDC_CONV_UFM                    1256
#define IDC_CONV_PFM                    1256
#define IDC_CONV_GTT                    1257
#define IDC_CONV_CTT                    1257
#define IDC_PFMBrowser                  1258
#define IDC_EDIT_CTTFile                1259
#define IDC_GTTBrowser                  1259
#define IDC_COMBO_Codepage              1260
#define IDC_UfmDirBrowser               1260
#define IDC_GttDirectory                1261
#define IDC_UfmDir                      1262
#define IDS_Unknown                     2000
#define IDS_RCUFM                       2001
#define IDS_RCGTT                       2002
#define IDS_RCUNK                       2003
#define ID_CopyItem                     2004
#define ID_ChangeID                     2005
#define IDS_FontDir                     2006
#define IDS_GTTDir                      2007
#define IDS_AddCopyFailed               2008
#define IDS_AddDupError                 2009
#define IDS_RCWriteError                2010
#define IDS_CopyCopyFailed              2011
#define IDS_CopyNameError               2012
#define IDS_CopyPrompt                  2013
#define IDS_GPDReminder                 2014
#define IDS_ResourceLabel               2015
#define IDS_IDNotUnique                 2016
#define IDD_DeleteQuery                 2017
#define IDS_DeletePrompt                2017
#define IDC_DeletePrompt                2018
#define ID_CheckWS                      2018
#define IDC_Remove                      2019
#define IDS_FILE_CheckWS                2019
#define IDD_CopyItem                    2020
#define IDS_RCExt                       2020
#define IDD_ChangeID                    2021
#define IDS_W31Ext                      2021
#define IDD_FILEOPENORD                 2022
#define IDS_RCTables                    2022
#define IDS_RCTabID                     2023
#define IDD_NPWGPDSelection             2023
#define IDD_INFW_Welcome                2024
#define IDS_RCTabFile                   2024
#define IDD_INFW_ChooseModels           2025
#define IDS_SwitchToW31                 2025
#define IDD_INFW_MfgName                2026
#define IDS_BadNT4File                  2026
#define IDD_INFW_FileName               2027
#define IDS_NoGPDsPrompt                2027
#define IDD_INFW_BiDi                   2028
#define IDS_DupInvRCID                  2028
#define IDD_INFW_ICMProfiles            2029
#define IDS_NoFSpecInRCLine             2029
#define IDD_INFW_ExtraFiles             2030
#define IDS_ORangeRCID                  2030
#define IDD_INFW_NonStdElements         2031
#define IDS_GTTSetName                  2031
#define IDD_INFW_Summary                2032
#define IDS_UFMSetName                  2032
#define IDS_ConvErrors                  2033
#define IDS_FileReadError               2034
#define IDS_UnicodeConvFailed           2035
#define IDS_Invalid2CTTFormat           2036
#define IDS_PFMTooSmall                 2037
#define IDS_PFMCharError                2038
#define IDS_BadPFMInfoOffset            2039
#define IDS_BadPFMInfoVersion           2040
#define IDS_FileWriteError              2041
#define IDS_UFMGenError                 2042
#define IDS_FatalConvErrors             2043
#define IDS_UFMCompError                2044
#define IDS_GTTTidyWarning              2045
#define IDS_BadGPDError                 2046
#define IDS_GPDUFMCompError             2047
#define IDS_UFMTidyWarning              2048
#define IDS_GPDStrCompError             2049
#define IDS_StrTidyWarning              2050
#define IDS_GPDModNameCompError         2051
#define IDS_GPDFileNameCompError        2052
#define IDR_WSCHECK                     2053
#define IDS_WSCloseCheckPrmt            2054
#define IDS_WSCheckTitle                2055
#define IDS_NoWSProblems                2056
#define IDS_NoVersionError              2057
#define IDS_RCRewriteQuestion           2058
#define IDS_UFMSetGTTID                 2059
#define IDS_UnexpectedCPError           2060
#define IDR_STRINGEDITOR                2060
#define IDS_StringEditorTitle           2061
#define IDS_StrEditRCIDColLab           2062
#define IDS_StrEditStringColLab         2063
#define IDS_BadGotoRCID                 2064
#define IDS_NoGotoRCID                  2065
#define IDS_BadSearchString             2066
#define IDS_NoSearchString              2067
#define IDS_SaveStrTabPrompt            2068
#define IDS_InvalidRCID                 2069
#define IDS_DuplicateRCID               2070
#define IDS_EmptyStringInStrTab         2071
#define IDS_UnusualError                2072
#define IDS_ErrorLabel                  2073
#define IDS_BadGotoLineNum              2074
#define IDS_GPDBackupFailed             2075
#define IDS_HeapCFailed                 2076
#define IDS_ConvCTTFailed               2077
#define IDS_RCForUFMPrompt              2078
#define IDS_UFMCompWarning              2079
#define MAPPING_TABLE                   2622
#define IDS_XXXUnexpectedCPError        2623
#define IDS_ReqOSError                  2624
#define IDS_Delete2ItemQuery            2625
#define IDS_StandAloneFontLoad          2626
#define IDS_CantStoreStandAlone         2627
#define IDS_GPDStringSearchFailed       2628
#define IDS_MDWUpgradeMsg1              2629
#define IDS_MDWUpgradeMsg2              2630
#define IDS_RCFileChanging              2631
#define IDS_RCRepFailed1                2632
#define IDS_RCCommentHdr1               2633
#define IDS_RCCommentHdr2               2634
#define IDS_RCCommentHdr3               2635
#define IDS_StdIncludeFile1             2636
#define IDS_StdIncludeFile2             2637
#define IDS_StdIncludeFile3             2638
#define IDS_StdIncludeFile4             2639
#define IDS_StdIncludeFile5             2640
#define IDS_IncStmt                     2641
#define IDS_OldIncludeFile1             2642
#define IDS_MDWTooNewError              2643
#define IDS_UpdateRCFile                2644
#define IDS_MustSelCP                   2645
#define IDS_HeapInGLoad                 2646
#define IDS_PGetFailedInGLoad           2647
#define IDS_INFWizTitle                 2648
#define IDS_INFModelsColLab             2649
#define IDS_INFIncludesColLab           2650
#define IDS_INFModelsToggleStr          2651
#define IDS_INFNoModelsSel              2652
#define IDS_INFBiDiColLab               2653
#define IDS_INFBiDiToggleStr            2654
#define IDS_INFICMColLab                2655
#define IDS_CommonRCFile                2656
#define IDS_CommonICMFile               2657
#define IDS_INFExFilesColLab            2658
#define IDS_CommonExtraFile             2659
#define IDS_NoMfgError                  2660
#define IDS_NoMfgAbbrevError            2661
#define IDS_NonStdColLab                2662
#define IDS_ModelsSumTxt                2663
#define IDS_BIDISumTxt                  2664
#define IDS_NoneSumTxt                  2665
#define IDS_ICMSumTxt                   2666
#define IDS_NonStdFilesSumTxt           2667
#define IDS_MfgSumTxt                   2668
#define IDS_ProvSumTxt                  2669
#define IDS_NonStdSecSumTxt             2670
#define IDR_INF_FILE_VIEWER             2671
#define ID_FILE_Check_INF               2672
#define ID_FILE_Change_INF              2673
#define IDS_INFText_HeaderCmt           2674
#define IDS_INFText_Version             2675
#define IDS_INFText_PCAddr              2676
#define IDS_INFText_MfgCmt              2677
#define IDS_INFText_Manufacturer        2678
#define IDS_INFText_ClInst32            2679
#define IDS_INFText_ModCmt              2680
#define IDS_INFText_CopySecCmt          2681
#define IDS_INFText_CopyKey             2682
#define IDS_INFText_CopyDataEntry       2683
#define IDS_INFText_UNIDRV              2684
#define IDS_INFText_UnidrvSec           2685
#define IDS_INFText_UnidrvDataSec       2686
#define IDS_INFText_InstallCmt          2687
#define IDS_INFText_DestDirs            2688
#define IDS_INFText_SrcDiskNamesI       2689
#define IDS_INFTextSrcDiskFilesHdr      2690
#define IDS_INFText_CtrlFlags           2691
#define IDS_INFText_Strings             2692
#define IDS_INFText_SrcDiskNamesA       2693
#define IDS_INFTextSrcDiskFilesEntry    2694
#define IDS_INFText_SrcDiskFilesEntry   2694
#define IDS_INFText_UnidrvSrcDskFiles   2695
#define IDS_INFFile                     2720
#define IDS_INFGPDReadError             2721
#define IDS_INFNoModelsError            2722
#define IDS_INFOpenError                2723
#define IDR_INFCHECK                    2724
#define IDS_INFChk_NoModErr             2725
#define IDS_INFChk_NoIncFileErr         2726
#define IDS_INFChk_GPDReadErr           2727
#define IDS_INFChk_NoICMFileErr         2728
#define IDS_INFChk_NoNonStdFileErr      2729
#define IDS_INFChk_NoResDLLErr          2730
#define IDS_INFChecksOK                 2731
#define IDS_INFCheckTitle               2732
#define IDS_UFMTooSmallError            2733
#define IDS_ReservedRCIDUsed            2734
#define IDS_BadKernPairError            2735
#define IDS_NoFamilyNamesError          2736
#define IDS_MissingFieldError           2737
#define IDS_LessEqZeroError             2738
#define IDS_EmptyStrError               2739
#define IDS_LessZeroError               2740
#define IDS_GrterEqZeroError            2741
#define IDS_EqualsZeroError             2742
#define IDS_EqFieldsError               2743
#define IDS_BadWidth                    2744
#define IDS_NoGTTForUFMError            2745
#define IDS_NoGTTForUFMFatalError       2746
#define IDS_GTTCPChangedMsg             2747
#define IDS_CPID                        2748
#define IDS_GTTID                       2749
#define IDS_WidthsTableOK               2750
#define IDS_WidthsTableTooBig           2751
#define IDS_KerningTableBadEnts         2752
#define IDS_KerningTableOK              2753
#define IDS_DefINFIncFile               2754
#define IDS_INFMissingIncError          2755
#define IDS_INFMissingInstSecError      2756
#define IDS_INFNoOtherStrError          2757
#define IDS_IncFilesSumTxt              2758
#define IDS_InstSecsSumTxt              2759
#define IDS_DataSecsSumTxt              2760
#define IDS_InstSecUni                  2761
#define IDS_InstSecUniBiDi              2762
#define IDS_InstSecPScript              2763
#define IDS_InstSecTtf                  2764
#define IDS_DataSecUni                  2765
#define IDS_DataSecUniBiDi              2766
#define IDS_DataSecPScript              2767
#define IDS_INFText_IncludeKey          2768
#define IDS_INFText_NeedsKey            2769
#define IDS_INFText_DataSecKey          2770
#define IDS_INFMissingDataSecError      2771
#define IDS_INFText_DataFileKey         2772
#define IDS_INFSecNeededColLab          2773
#define IDS_INF_NSMS_ToggleStr          2774
#define IDS_NonStdModelsSumTxt          2775
#define IDS_INFNoDLLError               2776
#define IDS_INFPnPIDColLab              2777
#define IDS_PnPIDSumTxt                 2778
#define IDS_INFText_ICMDest             2779
#define IDS_PnPSpacesError              2780
#define IDS_GTTCPOnlySaved              2781
#define IDS_UFMOKNow                    2782
#define IDS_UnExpFilTypError            2783
#define IDS_MDWExtension                2784
#define IDS_CTTFarEastCPError           2785
#define IDS_OldDriverRootDir            2786
#define IDS_NewDriverRootDir            2787
#define IDS_BadDestPath                 2788
#define IDS_ResourceError               2789
#define IDS_LoadGTTError                2790
#define IDS_StrEditNoSave               2791
#define IDS_NotFoundRC                  2792
#define IDS_StrEditNoEdit               2793
#define IDS_NewUFM                      2794
#define IDS_NewUFMError                 2795
#define IDS_NewGTT                      2796
#define IDS_NewGTTError                 2797
#define IDS_FileNewExist                2798
#define IDS_FileAlreadExist             2799
#define IDS_FileCreateDirectory         2800
#define IDS_NoFileName                  2801
#define IDS_TemplateCreated             2802
#define IDS_FailCreateTemplate          2803
#define IDS_FailCreateTempDir           2804
#define ID_FILE_GENERATEMAPS            32771
#define ID_FILE_PARSE                   32772
#define ID_FILE_INF                     32773
#define ID_FILE_CheckWS                 -32759
#define ID_EDIT_GOTO                    32778
#define ID_EDIT_ENABLE_AIDS             32779
#define ID_FILE_ERROR_LEVEL             32780
#define ID_BOGUS_SBOX                   32783
#define ID_BOGUS_NBTN                   32784
#define ID_BOGUS_PBTN                   32785
#define ID_SrchNextBtn                  32786
#define ID_SrchPrevBtn                  32787
#define ID_BUTTON32788                  32788
#define ID_PROJECT_NEW                  32790
#define ID_PROJECT_INSERT               32791
#define IDM_FILE_PRINT                  32793
#define ID_PROJECT_INSERT_UFM           32794
#define ID_PROJECT_INSERT_GTT           32795
#define ID_PROJECT_INSERT_GPD           32796
#define IDR_NEWFILE                     32797
#define IDR_NEWPROJECT                  32798
#define IDR_NEWSOURCES                  32799
#define IDR_STRINGTABLE                 32800

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        258
#define _APS_NEXT_COMMAND_VALUE         32797
#define _APS_NEXT_CONTROL_VALUE         1264
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\rcfile.h ===
/******************************************************************************

  Header File:  Driver Resources.H

  This defines the CDriverResource class, which contains all of the information
  required to build the RC file for the mini-driver.

  It contains a list of all of the #include files, any #define'd constants
  (which will now go to a separate header file), the GPC tables, of all of the
  fonts (in all three formats) and glyph translation tables (again, in all 3
  formats).  It is designed to be initializaed by reading the Win 3.1 RC file,
  and a member function can then generate the RC file for any desired version.

  We allow UFM and GTT files to be added to the list without having an 
  associated PFM, as one purpose of this tool is to wean people away from
  UniTool.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-08-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(DRIVER_RESOURCES)

#define DRIVER_RESOURCES

#include    "GTT.H"				//  Glyph Mapping classes
#include    "FontInfo.H"		//  Font information classes
#include    "GPDFile.H"
#include    "utility.H"


class CWSCheckDoc ;				// Forward declaration


// Definitions used during string ID verification to skip string IDs that are
// in COMMON.RC.

#define	FIRSTCOMMONRCSTRID	1000
#define	LASTCOMMONRCSTRID	2400


class CDriverResources : public CBasicNode {

    DECLARE_SERIAL(CDriverResources)

    BOOL                m_bUseCommonRC;

    CStringArray        m_csaIncludes, m_csaTables;

    CStringArray        m_csaDefineNames, m_csaDefineValues;

    //  The String table is a separate class, defined above
    
    CStringTable        m_cst;

	// Manages selected GPDs file names
	
	CStringArray		m_csaModelFileNames ;	

    //  TODO:   Handle the version resource so it is under project control

    //  For now, simply let it and any other untranslated lines sit in another
    //  array.

    CStringArray        m_csaRemnants;

    //  Collections of Various items of interest

    CFixedNode          m_cfnAtlas, m_cfnFonts, m_cfnModels;
    CSafeObArray        m_csoaAtlas, m_csoaFonts, m_csoaModels;
    CFixedNode          m_cfnResources ;	// "Resources" node in workspace view
    CSafeObArray        m_csoaResources ;	// An empty place holder
    CStringsNode        m_csnStrings ;		// "Strings" node in workspace view
    CSafeObArray        m_csoaStrings ;		// An empty place holder
    COldMiniDriverData  m_comdd;
    unsigned            m_ucSynthesized;    //  "Artificial" UFM count

    enum    {ItWorked, ItFailed, ItWasIrrelevant};

    UINT    CheckTable(int iWhere, CString csLine, CStringArray& csaTarget,
                       BOOL bSansExtension = TRUE);
    UINT    CheckTable(int iWhere, CString csLine, CStringTable& cstTarget);

    BOOL    AddStringEntry(CString  csDefinition, CStringTable& cstrcstrings);

    CString m_csW2000Path ;		// Path to Win2K files

	CStdioFile*	m_pcsfLogFile ;	// Used to write log file
	bool		m_bErrorsLogged ;	// True iff errors have been written to the log file
	CString		m_csConvLogFile ;	// Conversion log file name

	// Workspace consistency checking related variables

	CWSCheckDoc*	m_pwscdCheckDoc ;		// Checking window document
	bool			m_bFirstCheckMsg ;	// True iff next check msg will be first one
	bool			m_bIgnoreChecks ;	// True iff WS check problems should be ignored
	CMDIChildWnd*	m_pcmcwCheckFrame ;	// Checking window frame

public:
	CDriverResources() ;
	~CDriverResources() ;
	
	BOOL SyncUFMWidth();
	void CopyResources(CStringArray& pcsaUFMFiles,CStringArray& pcsaGTTFiles, CString& pcsModel,CStringArray& cstrcid);

    //  Attributes
    CString     GPCName(unsigned u);
    unsigned    MapCount() const { return m_csoaAtlas.GetSize(); }
    CGlyphMap&  GlyphTable(unsigned u) { 
        return *(CGlyphMap *) m_csoaAtlas[u]; 
    }
    unsigned    FontCount() const { return m_csoaFonts.GetSize(); }
    unsigned    OriginalFontCount() const { 
        return FontCount() - m_ucSynthesized; 
    }
    CFontInfo&  Font(unsigned u) const { 
        return *(CFontInfo *) m_csoaFonts[u]; 
    }

    unsigned    Models() const { return m_csoaModels.GetSize(); }
    CModelData&  Model(unsigned u) const { 
        return *(CModelData *) m_csoaModels[u];
    }

	CString		GetW2000Path() { return m_csW2000Path ; }

	CStringTable* GetStrTable() { return &m_cst ; }
    
	//  Operations
    BOOL    Load(class CProjectRecord& cpr);
	bool	LoadRCFile(CString& csrcfpec, CStringArray& csadefinenames, 
				CStringArray& csadefinevalues, CStringArray& csaincludes, 
				CStringArray& csaremnants, CStringArray& csatables, 
				CStringTable& cstrcstrings, CStringTable& cstfonts, 
				CStringTable& cstmaps, UINT ufrctype) ;
    BOOL    LoadFontData(CProjectRecord& cpr);
    BOOL    ConvertGPCData(CProjectRecord& cpr, WORD wfGPDConvert);
    BOOL    Generate(UINT ufTarget, LPCTSTR lpstrPath);
	void	RemUnneededRCDefine(LPCTSTR strdefname) ;
	void	RemUnneededRCInclude(LPCTSTR strincname) ;

	// The next 3 functions support the GPD Selection feature in the Conversion
	// Wizard.

	BOOL    GetGPDModelInfo(CStringArray* pcsamodels, CStringArray* pcsafiles) ;
	int		SaveVerGPDFNames(CStringArray& csafiles, bool bverifydata) ;
	void   GenerateGPDFileNames(CStringArray& csamodels, CStringArray& csafiles) ;

    void    ForceCommonRC(BOOL bOn) { m_bUseCommonRC = bOn; }

	// The next group of functions handle conversion log file management.

	bool	OpenConvLogFile(CString cssourcefile) ;
	void	CloseConvLogFile(void) ;
	void	LogConvInfo(int nmsgid, int numargs, CString* pcsarg1 = NULL, 
	    				int narg2 = 0) ;
	CString	GetConvLogFileName() const {return m_csConvLogFile ; }
	bool	ThereAreConvErrors() {return m_bErrorsLogged ; }
	BOOL	ReportFileFailure(int idMessage, LPCTSTR lpstrFile) ;

	// The next group of functions handle checking a workspace for completeness
	// and tidiness.

	bool	WorkspaceChecker(bool bclosing) ;
	void	DoGTTWorkspaceChecks(bool bclosing, bool& bwsproblem) ;
	void	DoUFMWorkspaceChecks(bool bclosing, bool& bwsproblem) ;
	void	DoStringWorkspaceChecks(bool bclosing, bool& bwsproblem)	;
	void	DoGPDWorkspaceChecks(bool bclosing, bool& bwsproblem) ;
	void	ResetWorkspaceErrorWindow(bool bclosing) ;
	bool	PostWSCheckingMessage(CString csmsg, CProjectNode* ppn) ;
	bool	IgnoreChecksWhenClosing(bool bclosing) ;

    void    Fill(CTreeCtrl *pctcWhere, CProjectRecord& cpr);
    virtual void    Serialize(CArchive& car);

    CStringsNode*	GetStringsNode() { return &m_csnStrings ; }

	bool	RunEditor(bool bstring, int nrcid) ;
	
	bool	ReparseRCFile(CString& csrcfspec) ;
	void	UpdateResourceList(CStringTable& cst, CSafeObArray& csoa,
							   CUIntArray& cuaboldfound, 
							   CUIntArray& cuabnewfound, CString& csrcpath, 
							   int& nc) ;
	void	UpdateResourceItem(CProjectNode* pcpn, CString& csrcpath, 
							   WORD wkey, CString& cs, FIXEDNODETYPE fnt) ;
	void	LinkAndLoadFont(CFontInfo& cfi, bool bworkspaceload, bool bonlyglyph = false) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\prtdlg.h ===
#if !defined(AFX_PRTDLG_H__E2A3A53B_A5AE_46A8_8822_E5B8D9B2FD97__INCLUDED_)
#define AFX_PRTDLG_H__E2A3A53B_A5AE_46A8_8822_E5B8D9B2FD97__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PrtDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPrtDlg dialog


class CPrtDlg : public CDialog
{
// Construction
public:
	CPrtDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPrtDlg)
	enum { IDD = IDD_FILE_PRINT };
	CComboBox	m_ccbPrtList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrtDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPrtDlg)
	afx_msg void OnPrintSetup();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRTDLG_H__E2A3A53B_A5AE_46A8_8822_E5B8D9B2FD97__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\tips.h ===
/******************************************************************************

  Header File:  Tip of the Day.H

  This defines the Tip of the Day dialog class.  It was originally created by
  the Component Gallery, but I expect I will et around to tweaking it here and 
  there pretty soon.

  Copyright (c) 1997 by Microsoft Corporation.  All rights reserved.
  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

class CTipOfTheDay : public CDialog {
// Construction
public:
	CTipOfTheDay(CWnd* pParent = NULL);	 // standard constructor

// Dialog Data
	//{{AFX_DATA(CTipOfTheDay)
	// enum { IDD = IDD_TIP };
	BOOL	m_bStartup;
	CString	m_strTip;
	//}}AFX_DATA

	FILE* m_pStream;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTipOfTheDay)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTipOfTheDay();

protected:
	// Generated message map functions
	//{{AFX_MSG(CTipOfTheDay)
	afx_msg void OnNextTip();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void GetNextTipString(CString& strNext);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stdafx.h ===
/******************************************************************************

  Source File:  StdAfx.H

  This is a standard MFC file.  It includes everything we want to have 
  pre-compiled through StdAfx.CPP.  Hence items being worked on never belong 
  here.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.
  
  A Pretty Penny Enterprises Production

  Change History:
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it when I re-orged the
                project.

******************************************************************************/

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include    <AfxWin.H>      // MFC core and standard components
#include    <AfxExt.H>      // MFC extensions
#include    <AfxCmn.H>		// MFC support for Windows Common Controls
#include    <AfxRich.H>     // MFC Support for rich edit controls and views

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxpriv.h>


// Identifies this program in other include files.  First use is in DEBUG.H.

#define __MDT__		1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\rcfile.cpp ===
/******************************************************************************

  Source File:  Driver Resources.CPP

  This implements the driver resource class, which tracks the resources in the
  driver.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-08-1997    Bob_Kjelgaard@Prodigy.Net   Created it
													
******************************************************************************/

#include    "StdAfx.h"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"WSCheck.h"
#include    "ProjRec.H"


//  First, we're going to implement the CStringTable class

IMPLEMENT_SERIAL(CStringTable, CObject, 0)

CString CStringTable::operator[](WORD wKey) const {

    for (unsigned u = 0; u < Count(); u++)
        if  (wKey == m_cuaKeys[u])
            break;

    return  u < Count() ? m_csaValues[u] : m_csEmpty;
}

void    CStringTable::Map(WORD wKey, CString csValue) {
    if  (!wKey || csValue.IsEmpty()) return;

    if  (!Count() || wKey > m_cuaKeys[-1 + Count()]) {
        m_cuaKeys.Add(wKey);
        m_csaValues.Add(csValue);
        return;
    }

    for (unsigned u = 0; u < Count(); u++)
        if  (m_cuaKeys[u] >= wKey)
            break;

    if  (m_cuaKeys[u] != wKey){
        m_cuaKeys.InsertAt(u, wKey);
        m_csaValues.InsertAt(u, csValue);
    }
    else
        m_csaValues.SetAt(u, csValue);
}



void    CStringTable::Remove(WORD wKey) {

    for (unsigned u = 0; u < Count(); u++)
        if  (wKey >= m_cuaKeys[u])
            break;

    if  (u == Count() || wKey != m_cuaKeys[u])
        return;
    m_csaValues.RemoveAt(u);
    m_cuaKeys.RemoveAt(u);
}

void    CStringTable::Details(unsigned u, WORD &wKey, CString &csValue) {
    if  (u > Count()) u = 0;
    wKey = (WORD)m_cuaKeys[u];

    csValue = operator[](wKey);
}

void    CStringTable::Serialize(CArchive& car)
{
	// First, call the base class' serialization routine.
	
    CObject::Serialize(car);

	// CUIntArray is not serializable so the keys array's size and values have
	// to be saved/restored manually.  This is only done when the MDW should
	// contain (save) or does contain (restore) this information.

	int n = 0 ;
	int ncnt = (int)m_cuaKeys.GetSize() ;
	CProjectRecord* cpr = (CProjectRecord *) car.m_pDocument ;
	if (cpr->GetMDWVersion() > MDW_DEFAULT_VERSION) {
		if (car.IsStoring()) {
			car << ncnt ;
			for (n ; n < ncnt ; n++)
				car << m_cuaKeys[n] ;
		} else {
			car >> ncnt ;
			m_cuaKeys.SetSize(ncnt) ;
			int nvalue ;
			for (n ; n < ncnt ; n++) {
				car >> nvalue ;
				m_cuaKeys[n] = nvalue ;
			} ;
		} ;
	} ;

    // Now save/restore the values array.

    m_csaValues.Serialize(car);
}


void CStringTable::InitRefFlags()
{
	// Initialize the number of elements in the array to the number of strings
	// in the table.

	unsigned ucount = Count() ;
	m_cuaRefFlags.SetSize(ucount) ;

	// Clear all of the flags

	for (unsigned u = 0 ; u < ucount ; u++)
		ClearRefFlag(u) ;
}


IMPLEMENT_SERIAL(CDriverResources, CBasicNode, 0)

void    CDriverResources::Serialize(CArchive& car)
{
	CBasicNode::Serialize(car);

    m_csaIncludes.Serialize(car);
    m_csoaFonts.Serialize(car);
    m_csaTables.Serialize(car);
    m_csoaAtlas.Serialize(car);
    m_csaDefineNames.Serialize(car);
    m_csaDefineValues.Serialize(car);
    m_cst.Serialize(car);
    m_csaRemnants.Serialize(car);
    m_csoaModels.Serialize(car);

	// There are no paths for driver files in the MDW file when the MDW version
	// is at least MDW_VER_NO_FILE_PATHS.  Build and set the paths in this case.

	unsigned uver = ((CProjectRecord*) car.m_pDocument)->GetMDWVersion() ;
	if (uver < MDW_VER_YES_FILE_PATHS) {	// raid 123448
		CString csw2kpath = ((CProjectRecord*) car.m_pDocument)->GetW2000Path() ;
		unsigned unumobjs, u ;
		CString  cspath ;

		// Set the GPD file paths.

		cspath = csw2kpath + _T('\\') ;
		for (unumobjs = Models(), u = 0 ; u < unumobjs ; u++)
			Model(u).SetPath(cspath) ;

		// Set the UFM file paths.

		cspath.LoadString(IDS_FontDir) ;
		cspath = csw2kpath + _T('\\') + cspath ;
		for (unumobjs = FontCount(), u = 0 ; u < unumobjs ; u++)
			Font(u).SetPath(cspath) ;

		// Set the GTT file paths.

		cspath.LoadString(IDS_GTTDir) ;
		cspath = csw2kpath + _T('\\') + cspath ;
		for (unumobjs = MapCount(), u = 0 ; u < unumobjs ; u++)
			GlyphTable(u).SetPath(cspath) ;
	} ;
}


/******************************************************************************

  CDriverResources::CheckTable(int iWhere, CString csLine,
    CStringTable& cstTarget)

  Internal work routine- this looks at a line, and some parameters, decides
  whether to work on it or not, and if it does, validates the resource number
  and adds the file name and resource number to its list.

  This override is needed because the resource IDs for translation tables have
  not heretofore been a compact set.

******************************************************************************/

UINT    CDriverResources::CheckTable(int iWhere, CString csLine,
                                     CStringTable& cstTarget) {
    if  (iWhere == -1)
        return  ItWasIrrelevant;

    //  See if the ID is valid or not.  It must be an integer > 0

    int iKey = atoi(csLine);

    if  (iKey < 0 || iKey > 0x7FFF) //  Valid range for resource IDs in Win16
        LogConvInfo(IDS_ORangeRCID, 1, &csLine) ;
        //return  ItFailed;

	// Find the filespec at the end of the line.  Fail if there is no filespec.

    for (int i = -1 + csLine.GetLength(); i; i--) {
        if  (csLine[i] == _TEXT(' ') || csLine[i] == _TEXT('\t'))
            break;
    }
    if  (!i)  {
        LogConvInfo(IDS_NoFSpecInRCLine, 1, &csLine) ;
        return  ItWorked;		// Cause the line to be skipped.
        //return  ItFailed;
	} ;

    cstTarget.Map((WORD) iKey, csLine.Mid(++i));

    return  ItWorked;
}

/******************************************************************************

  CDriverResources::CheckTable(int iWhere, CString csLine,
    CStringArray& csaTarget)

  Internal work routine- this looks at a line, and some parameters, decides
  whether to work on it or not, and if it does, validates the resource number
  and adds the file name to its list.

******************************************************************************/

UINT    CDriverResources::CheckTable(int iWhere, CString csLine,
                                     CStringArray& csaTarget,
                                     BOOL bSansExtension) {
    if  (iWhere == -1)
        return  ItWasIrrelevant;

    //  See if the name is valid or not

    if  (atoi(csLine) != 1 +csaTarget.GetSize())
        LogConvInfo(IDS_DupInvRCID, 1, &csLine) ;
        //return  ItFailed;

	// Find the filespec at the end of the line.  Fail if there is no filespec.

    for (int i = -1 + csLine.GetLength(); i; i--) {
        if  (csLine[i] == _TEXT(' ') || csLine[i] == _TEXT('\t'))
            break;
    }
    if  (!i)  {
        LogConvInfo(IDS_NoFSpecInRCLine, 1, &csLine) ;
        return  ItWorked;		// Cause the line to be skipped.
        //return  ItFailed;
	} ;

    if  (!bSansExtension) {
        //  Don't bother to strip the extension
        csaTarget.Add(csLine.Mid(++i));
        return  ItWorked;
    }

    //  Strip everything after the last period.

    CString csName = csLine.Mid(++i);

    if  (csName.ReverseFind(_T('.')) > csName.ReverseFind(_T('\\')))
        csName = csName.Left(csName.ReverseFind(_T('.')));

    csaTarget.Add(csName);

    return  ItWorked;
}

//  Private work member.  This parses a line from a string table to extract
//  the value and the string itself.

BOOL    CDriverResources::AddStringEntry(CString csLine,
										 CStringTable& cstrcstrings)
{
    WORD    wKey = (WORD) atoi(csLine);

    if  (!wKey)
        return  FALSE;  //  0 is not a valid resource number...

    csLine = csLine.Mid(csLine.Find("\""));
    csLine = csLine.Mid(1, -2 + csLine.GetLength());

    cstrcstrings.Map(wKey, csLine);

    return  TRUE;
}

//  Constructor- would be trivial, except we need to initialize some of the
//  fancier UI objects

CDriverResources::CDriverResources() :
	m_cfnAtlas(IDS_Atlas, m_csoaAtlas, FNT_GTTS, GlyphMapDocTemplate(),
        RUNTIME_CLASS(CGlyphMap)),
    m_cfnFonts(IDS_FontList, m_csoaFonts, FNT_UFMS, FontTemplate(),
        RUNTIME_CLASS(CFontInfo)),
    m_cfnModels(IDS_Models, m_csoaModels, FNT_GPDS, GPDTemplate(),
        RUNTIME_CLASS(CModelData)),
	m_cfnResources(IDS_Resources, m_csoaResources, FNT_RESOURCES),
	m_csnStrings(IDS_Strings, m_csoaStrings, FNT_STRINGS, StringEditorTemplate(),
		RUNTIME_CLASS(CStringsNode))
{
	// Set the context sensitive menus for the workspace, resources, UFMs, GTTs,
	// GPDs, and Strings nodes.

	m_cwaMenuID.Add(ID_OpenItem);
    m_csnStrings.SetMenu(m_cwaMenuID);
	m_cwaMenuID.SetAt(0, ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    m_cfnResources.SetMenu(m_cwaMenuID);
    m_cwaMenuID.InsertAt(0, 0, 1);
    m_cwaMenuID.InsertAt(0, ID_Import);
	m_cfnAtlas.SetMenu(m_cwaMenuID);
    m_cfnFonts.SetMenu(m_cwaMenuID);
    m_cfnModels.SetMenu(m_cwaMenuID);
    m_cwaMenuID.SetAt(0, ID_RenameItem);
    m_cwaMenuID.InsertAt(0, ID_CheckWS);

	m_ucSynthesized = 0;

	m_pcsfLogFile = NULL;
	m_bErrorsLogged = false;

	m_pwscdCheckDoc = NULL ;
	m_pcmcwCheckFrame = NULL ;
	m_bFirstCheckMsg = true ;
}


CDriverResources::~CDriverResources()
{
	// Make sure that if there is a log file, it gets closed.

	CloseConvLogFile() ;
}


//  Member function for returning a GPC file name.  These come ready for
//  concatenation, so they are preceded by '\'

CString CDriverResources::GPCName(unsigned u) {
    CString csReturn('\\');

    csReturn += m_csaTables[u] + _TEXT(".GPC");

    return  csReturn;
}


/******************************************************************************

  CDriverResources::ReportFileFailure

  This is a private routine- it loads a string table resource with an error
  message, formats it using the given file name, displays a message box,
  then returns FALSE.

******************************************************************************/

BOOL CDriverResources::ReportFileFailure(int idMessage,
												LPCTSTR lpstrFile)
{
    CString csfile(lpstrFile) ;
	LogConvInfo(idMessage, 1, &csfile) ;
    return FALSE ;
}


/******************************************************************************

  CDriverResources::OpenConvLogFile

  This function allocates an instance of CFile to manage the conversion log
  file and opens the log file.

******************************************************************************/

bool CDriverResources::OpenConvLogFile(CString cssourcefile)
{
	// Return "failure" if CFile instance cannot be allocated.

	if ((m_pcsfLogFile = new CStdioFile) == NULL)
		return false ;

	// Build the log file name from the input source file name.

	m_csConvLogFile = cssourcefile ;
	int npos ;
	if ((npos = m_csConvLogFile.Find(_T('.'))) >= 0)
		m_csConvLogFile = m_csConvLogFile.Left(npos) ;
	m_csConvLogFile += _T(".LOG") ;

	// Open the log file

    if (!m_pcsfLogFile->Open(m_csConvLogFile, CFile::modeCreate | CFile::modeWrite |
        CFile::shareExclusive)) {
		CloseConvLogFile() ;
		return  false ;
	} ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CDriverResources::CloseConvLogFile

  This function closes the conversion log file and deletes the instance of
  CFile used to manage the log file.

******************************************************************************/

void CDriverResources::CloseConvLogFile(void)
{
	// Do nothing if the pointer is null.

	if (m_pcsfLogFile == NULL)
		return ;

	// Close the file if it is open

	if (m_pcsfLogFile->m_pStream != NULL)
		m_pcsfLogFile->Close() ;

	delete m_pcsfLogFile ;
	m_pcsfLogFile = NULL ;
}


/******************************************************************************

  CDriverResources::LogConvInfo

  Assuming the log file is ready to use, build and write a message to the
  conversion log file.

******************************************************************************/

void CDriverResources::LogConvInfo(int nmsgid, int numargs, CString* pcsarg1,
								   int narg2)
{
	CString		csmsg ;			// Log message is loaded/built here

	// Do nothing if the log file pointer is null or the file handle is
	// uninitialized.

	if (m_pcsfLogFile == NULL || m_pcsfLogFile->m_pStream == NULL)
		return ;

	// Load and/or build the message based on the number of arguments

	switch (numargs) {
		case 0:
			csmsg.LoadString(nmsgid) ;
			break ;
		case 1:
			csmsg.Format(nmsgid, *pcsarg1) ;
			break ;
		case 2:
			csmsg.Format(nmsgid, *pcsarg1, narg2) ;
			break ;
		default:
			return ;
	} ;

	// Write the message and indicate that a message has been written

	try {
		m_pcsfLogFile->WriteString(csmsg) ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return ;
    }
	m_bErrorsLogged = true ;
}


/******************************************************************************

  CDriverResources::Load

  This function loads and reads the RC file for the driver, and determines all
  of the needed resources.  It initializes the structures used to fetermine the
  glyph map file set, font file set, etc.

******************************************************************************/

BOOL    CDriverResources::Load(class CProjectRecord& cprOwner)
{
    CWaitCursor     cwc;    //  Just in case this takes a while...
    NoteOwner(cprOwner);

	// Load the RC file and save its data into data specific arrays.

    CStringTable    cstFonts;    //  Names First!
    CStringTable    cstMaps;
    if  (!LoadRCFile(cprOwner.SourceFile(), m_csaDefineNames, m_csaDefineValues,
					 m_csaIncludes, m_csaRemnants, m_csaTables, m_cst, cstFonts,
					 cstMaps, NotW2000))
        return  FALSE ;

	// The string table with font info in it needs to be copied into a string
	// array for further processing.

	CStringArray csaFonts ;
	int numelts = cstFonts.Count() ;
    WORD wKey ;
	csaFonts.SetSize(numelts) ;
	for (int n = 0 ; n < numelts ; n++)
		cstFonts.Details(n, wKey, csaFonts[n]) ;

    //  RAID 103242- people can load totally bogus files.  Die now if there is
    //  no GPC data as a result of this.

    if  (!m_csaTables.GetSize()) {
        AfxMessageBox(IDS_NoGPCData);
        return  FALSE;
    }

    //  End 103242

    if  (m_csaTables.GetSize() == 1)
        m_csaTables.Add(_TEXT("NT"));   //  Usually necessary.

    //  Now, let's name the translation tables- we wil load them later...
	//  Note: Different rules are used for naming the node and the file.

	CString cstmp ;
	int		npos ;
    for (unsigned u = 0; u < cstMaps.Count(); u++) {
        CString csName;
        m_csoaAtlas.Add(new CGlyphMap);
        cstMaps.Details(u, wKey, csName);
		if (csName[0] == _T('\\'))
			GlyphTable(u).SetSourceName(cprOwner.TargetPath(Win95) + csName) ;
		else
			GlyphTable(u).SetSourceName(cprOwner.TargetPath(Win95) + _T('\\') +
				csName) ;
        //if  (!GlyphTable(u).SetFileName(cprOwner.TargetPath(Win2000) +
        //    _T("\\GTT\\") + GlyphTable(u).Name()))
		if ((npos = csName.ReverseFind(_T('\\'))) >= 0)
			cstmp = csName.Mid(npos + 1) ;
		else
			cstmp = csName ;
		cstmp = cprOwner.TargetPath(Win2000) + _T("\\GTT\\") + cstmp ;
        if  (!GlyphTable(u).SetFileName(cstmp))	{
			LogConvInfo(IDS_GTTSetName, 1, &cstmp) ;
            return  FALSE;
		};
        GlyphTable(u).nSetRCID((int) wKey);
    }

    //  Now, cycle it again, but this time, make sure all of the root file
    //  names and display names are unique.

    for (u = 1; u < MapCount(); u++) {
        for (unsigned uCompare = 0; uCompare < u; uCompare++) {

			// If a matching file title is found, make it unique.

            if  (!GlyphTable(uCompare).FileTitle().CompareNoCase(
             GlyphTable(u).FileTitle())) {
				GlyphTable(u).m_cfn.UniqueName(true, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
				continue ;
            } ;

			// If a matching display name is found, make it unique.

            if  (!GlyphTable(uCompare).Name().CompareNoCase(
             GlyphTable(u).Name())) {
				GlyphTable(u).UniqueName(false, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
            } ;
		} ;
	} ;

    //  Now, let's name the fonts - we wil load them later...
	//  Note: Different rules are used for naming the node and the file.

    for (u = 0; u < (unsigned) csaFonts.GetSize(); u++) {
        m_csoaFonts.Add(new CFontInfo);
		cstmp = csaFonts[u] ;
		if (cstmp.GetAt(0) == _T('\\'))
			Font(u).SetSourceName(cprOwner.TargetPath(Win95) + cstmp) ;
		else
			Font(u).SetSourceName(cprOwner.TargetPath(Win95) + _T('\\') +
				cstmp) ;
        Font(u).SetUniqueName(m_csName);
		if ((npos = cstmp.ReverseFind(_T('\\'))) >= 0)
			cstmp = cstmp.Mid(npos + 1) ;
		cstmp = cprOwner.TargetPath(Win2000) + _T("\\UFM\\") + cstmp ;
        if  (!Font(u).SetFileName(cstmp)) {
			LogConvInfo(IDS_UFMSetName, 1, &cstmp) ;
            return  FALSE;
		};
    }

    //  Now, cycle it again, but this time, make sure all of the root file
    //  names and display names are unique.

    for (u = 1; u < FontCount(); u++) {
        for (unsigned uCompare = 0; uCompare < u; uCompare++) {

			// If a matching file title is found, make it unique.

            if  (!Font(uCompare).FileTitle().CompareNoCase(
             Font(u).FileTitle())) {
				Font(u).m_cfn.UniqueName(true, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
				continue ;
            } ;

			// If a matching display name is found, make it unique.

            if  (!Font(uCompare).Name().CompareNoCase(
             Font(u).Name())) {
				Font(u).UniqueName(false, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
            } ;
		} ;
	} ;

    //  Attempt to load the GPC data if there is any.  Then begin the
	//  process of splitting GPCs that manage multiple models into multiple
	//  GPDs.

    CFile               cfGPC;

    if  (!cfGPC.Open(cprOwner.TargetPath(Win95) + GPCName(0),
        CFile::modeRead | CFile::shareDenyWrite) || !m_comdd.Load(cfGPC))
        return  ReportFileFailure(IDS_FileOpenError,
            cprOwner.TargetPath(Win95) + GPCName(0));
	if (!m_comdd.SplitMultiGPCs(m_cst))
        return  ReportFileFailure(IDS_FileOpenError,
            cprOwner.TargetPath(Win95) + GPCName(0));

	n = m_cst.Count() ;

    return  TRUE;
}


/******************************************************************************

  CDriverResources::LoadRCFile

  This function loads and reads the RC file for the driver, and determines all
  of the needed resources.  The data is loaded into the arguments.

  Args:
	csrcfpec				The RC filespec for the file to load
	csadefinenames     Definition names
	csadefinevalues		Definition values
	csaincludes				Include statement filespecs
	csaremnants         RC statements that don't fall into other categories
	csatables           GPC info
	cstrcstrings        String table strings
	cstfonts            Font (UFM/PFM) info
	cstmaps				Map (CTT/GTT) info
	ufrctype			Win2000 iff parsing Win2K RC file.  Otherwise, NotW2000.

  Returns true if the file is successfully loaded.  Otherwise, false.

******************************************************************************/

bool CDriverResources::LoadRCFile(CString& csrcfpec,
								  CStringArray& csadefinenames,
								  CStringArray& csadefinevalues,
								  CStringArray& csaincludes,
								  CStringArray& csaremnants,
								  CStringArray& csatables,
								  CStringTable& cstrcstrings,
								  CStringTable& cstfonts,
								  CStringTable& cstmaps,
								  UINT ufrctype)
{
	// Read the RC file

    CStringArray    csacontents ;
    while (!LoadFile(csrcfpec, csacontents)){		// Raid 3176
		CString cstmp;int iRet;	
		cstmp.LoadString(IDS_NotFoundRC);
		if ( (iRet = AfxMessageBox(cstmp,MB_YESNO) ) == IDYES) {
			CFileDialog cfd(TRUE);   
			if(IDCANCEL == cfd.DoModal())
				return false;
			csrcfpec = cfd.GetPathName();
			continue;
		}
		else 
			return false ;
	}
    //  Clean everything up, in case we were previously loaded...

    csadefinenames.RemoveAll();
    csadefinevalues.RemoveAll();
    csaincludes.RemoveAll();
    csaremnants.RemoveAll();
    csatables.RemoveAll();
    cstrcstrings.Reset();
    cstfonts.Reset();
    cstmaps.Reset();

	// Declare and load the Map and Font table keyword variables

	CString	csfontlabel, cstranslabel ;
    if  (ufrctype == Win2000) {
        csfontlabel = _T("RC_UFM");
        cstranslabel = _T("RC_GTT");
    } else {
        csfontlabel = _T("RC_FONT");
        cstranslabel = _T("RC_TRANSTAB");
    } ;

    //  Let the parsing begin
    //  03-14-1997  We can't assume sequential numbering of the table resources

    BOOL    bLookingForBegin=false, bLookingForEnd=false, bInComment=false ;
	CString cscurline, cshold ;
	int nloc, nloc2 ;
	bool blastlinewasremnant = false ;
    while (csacontents.GetSize()) {

		// Get the next line to process.  Usually this is the next line in the
		// contents array.  Occassionally, a line held for later processing
		// should be used.

		if (cshold.IsEmpty()) {
			cscurline = csacontents[0] ;
			csacontents.RemoveAt(0) ;		// *** csacontents updated here
		} else {
			cscurline = cshold ;
			cshold.Empty() ;
		} ;


        // Add multiline comments to the remnants array.  If the comment is
		// continuing, just add the line and continue.  If this is the last line
		// of the comment, check to see if there is anything after the ending
		// comment characters.  If there is, save everything up to and including
		// the comment chars and then set up to process the rest of the line.

        if  (bInComment) {
			blastlinewasremnant = true ;
            if ((nloc = cscurline.Find(_TEXT("*/"))) >= 0) {
				bInComment = false ;
		        cscurline.TrimRight();
				if (nloc + 2 < cscurline.GetLength()) {
					csaremnants.Add(cscurline.Left(nloc + 2)) ;
					cscurline = cscurline.Mid(nloc + 2) ;
				} else {
					csaremnants.Add(cscurline) ;
		            continue ;
				} ;

			// Add the comment line to the remnants array.
				
			} else {
				csaremnants.Add(cscurline) ;
				continue ;
			} ;
		} ;

        // Remove partial line comments

        if  ((nloc = cscurline.Find(_TEXT("//"))) != -1)
            cscurline = cscurline.Left(nloc) ;

        // Handle the other style of comments.
		
        while   (-1 != (nloc = cscurline.Find(_TEXT("/*")))) {

			// Remove all partial line comments.

            if  ((nloc2 = cscurline.Find(_TEXT("*/"))) > nloc)
                cscurline = cscurline.Left(nloc) + cscurline.Mid(nloc2 + 2) ;

			// If this is the beginning of a multiline comment that starts at
			// the beginning of the line, set the comments flag and continue
			// processing.  It will be saved later.

			else if (nloc == 0) {
                bInComment = true ;
				break ;

			// If this is the beginning of a multiline comment that does NOT
			// start at the beginning of the line, save the comment for latter
			// processing and set up to continue processing the beginning of
			// the line.

			} else {
                cshold = cscurline.Mid(nloc + 1) ;
                cscurline = cscurline.Left(nloc) ;
            } ;
        } ;

        //  Now for the leading blanks and trailing blanks

        cscurline.TrimLeft();
        cscurline.TrimRight();

		// Handle blank lines.  If the previous line was a nonblank, remnant
		// line, add the blank line to the remnants array.  Always contine;
		// ie go get the next line.

        if  (cscurline.IsEmpty()) {
			if (blastlinewasremnant) {
				csaremnants.Add(cscurline) ;
				blastlinewasremnant = false ;
			} ;
            continue ;
		} ;
		blastlinewasremnant = false ;

        //  If we are processing a string table, press onward...

        if  (bLookingForBegin) {
            if  (cscurline.CompareNoCase(_TEXT("BEGIN")))
                return  false;  //  Parsing failure
            bLookingForBegin = false;
            bLookingForEnd = true;
            continue;
        }

        if  (bLookingForEnd) {
            if  (!cscurline.CompareNoCase(_TEXT("END"))) {
                bLookingForEnd = false;
                continue;
            }

            if  (!AddStringEntry(cscurline, cstrcstrings))
                return  false;  //  Parsing error

            continue;
        }

        //  If it is an include, add it to the list

        if  (cscurline.Find(_TEXT("#include")) != -1) {
            cscurline =
                cscurline.Mid(cscurline.Find(_TEXT("#include")) + 8);
            cscurline.TrimLeft();
            csaincludes.Add(cscurline);
            continue;
        }

        //  If it is a #define, do the same

        if  (cscurline.Find(_TEXT("#define")) != -1) {
            cscurline =
                cscurline.Mid(cscurline.Find(_TEXT("#define")) + 7);
            cscurline.TrimLeft();
            //  TODO:   Handle macros with parameters
            csadefinenames.Add(cscurline.SpanExcluding(_TEXT(" \t")));
            cscurline =
                cscurline.Mid(
                    csadefinenames[-1 + csadefinenames.GetSize()].
                    GetLength());
            cscurline.TrimLeft();
            csadefinevalues.Add(cscurline);
            continue;
        }

        //  GPC Tables, fonts, Glyph Tables
        switch  (CheckTable(cscurline.Find(_TEXT("RC_TABLES")),
                    cscurline, csatables)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  false;  //  Parsing error
        }

        switch  (CheckTable(cscurline.Find(csfontlabel),
                    cscurline, cstfonts)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  false;  //  Parsing error
        }

        switch  (CheckTable(cscurline.Find(cstranslabel),
                    cscurline, cstmaps)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  false;  //  Parsing error
        }

        //  String table...

        if  (cscurline.CompareNoCase(_TEXT("STRINGTABLE"))) {
            csaremnants.Add(cscurline) ;
			blastlinewasremnant = true ;
        } else
            bLookingForBegin = true ;
    }

	//unsigned u, unuments ;
	//for (u = 0, unuments = csaremnants.GetSize() ; u < unuments ; u++)
	//	TRACE("Remnants[%d] = '%s' (%d)\n", u, csaremnants[u], unuments) ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CDriverResource::LoadFontData

  This member function loads the CTT files from the Win 3.1 mini-driver to
  initialize the glyph table array.  It is a separate function because the
  Wizard must first verify the code page selection for each of the tables
  with the user.

******************************************************************************/

BOOL    CDriverResources::LoadFontData(CProjectRecord& cprOwner) {

    CWaitCursor cwc;
	int			nerrorid ;

	// Conversion of drivers that have CTTs **>AND<** are using a Far East 
	// default code page are not support.  Complain and stop the conversion
	// when this situation is detected.

	if (MapCount() > 0 && ((int) cprOwner.GetDefaultCodePage()) < 0) {
		LogConvInfo(IDS_CTTFarEastCPError, 0) ;
		return FALSE ;
	} ;

    //  Now, let's load the translation tables.

    for (unsigned u = 0; u < MapCount(); u++) {
		GlyphTable(u).NoteOwner(cprOwner) ;

        //  Load the file..
        if  ((nerrorid = GlyphTable(u).ConvertCTT()) != 0) {
			CString cstmp ;
			cstmp = GlyphTable(u).SourceName() ;
            return  ReportFileFailure(IDS_LoadFailure, cstmp) ;
		} ;
	} ;

    //  Now, let's load the Font Data.

    for (u = 0; u < FontCount() - m_ucSynthesized; u++) {

        //  Load the file..  (side effect of GetTranslation)

        //if  ((nerrorid = Font(u).GetTranslation(this)) != 0) {
        if  ((nerrorid = Font(u).GetTranslation(m_csoaAtlas)) != 0) {
			CString cstmp ;
			cstmp = Font(u).SourceName() ;
			LogConvInfo(abs(nerrorid), 1, &cstmp) ;
			if (nerrorid < 0)
				return  ReportFileFailure(IDS_LoadFailure, cstmp);
		} ;

        //  Generate the CTT/PFM mapping so we generate UFMs correctly

        if  (!Font(u).Translation()) {
            /*
                For each model, check and see if this font is in its map.
                If it is, then add the CTT to the list used, and the model,
                as well.

            */

            CMapWordToDWord cmw2dCTT;   //  Used to count models per ID
            CWordArray      cwaModel;   //  Models which used this font
            DWORD           dwIgnore;

            for (unsigned uModel = 0; uModel < m_comdd.ModelCount(); uModel++)
                if  (m_comdd.FontMap(uModel).Lookup(u + 1, dwIgnore)) {
                    //  This model needs to be remembered, along with the CTT
                    cmw2dCTT[m_comdd.DefaultCTT(uModel)]++;
                    cwaModel.Add((WORD)uModel);
                }

            if  (!cmw2dCTT.Count()) {
				CString cstmp ;
				cstmp = Font(u).SourceName() ;
				LogConvInfo(IDS_UnusedFont, 1, &cstmp) ;
                continue;
            }

            if  (cmw2dCTT.Count() == 1) {
                //  Only one CTT ID was actually used.
                Font(u).SetTranslation(m_comdd.DefaultCTT(cwaModel[0]));	
                continue;   //  We're done with this one
            }

            /*

                OK, this font has multiple CTTs in different models.  Each
                will require a new UFM to be created.  The IDs of the new UFMs
                need to be added to the set, the new defaults established, and
                a list of the font ID remapping needed for each model all need
                maintenance.

            */

            unsigned uGreatest = 0;

            for (POSITION pos = cmw2dCTT.GetStartPosition(); pos; ) {
                WORD    widCTT;
                DWORD   dwcUses;

                cmw2dCTT.GetNextAssoc(pos, widCTT, dwcUses);
                if  (dwcUses > uGreatest) {
                    uGreatest = dwcUses;
                    Font(u).SetTranslation(widCTT);
                }
            }

            //  The models that used the most common CTT will be dropped from
            //  the list

            for (uModel = (unsigned) cwaModel.GetSize(); uModel--; )
                if  (m_comdd.DefaultCTT(cwaModel[uModel]) == Font(u).Translation())
                    cwaModel.RemoveAt(uModel);

            //  Now, we create a new UFM for each CTT ID, and add the new index to
            //  the mapping required for the each affected model.

            m_ucSynthesized += cmw2dCTT.Count() - 1;

            for (pos = cmw2dCTT.GetStartPosition(); pos; ) {

                WORD    widCTT;	
                DWORD   dwcUses;

                cmw2dCTT.GetNextAssoc(pos, widCTT, dwcUses);

                if  (widCTT == Font(u).Translation())
                    continue;   //  This one has already been done.

				// Add a new font and make sure its file name is unique

                int nnewpos = m_csoaFonts.Add(new CFontInfo(Font(u), widCTT));
				for (unsigned ucomp = 0 ; ucomp < FontCount() ; ucomp++) {
					if ((unsigned) nnewpos == ucomp)
						continue ;

					// If a matching file title is found, try to make it unique
					// and restart the checking.

					if  (!Font(nnewpos).FileTitle().CompareNoCase(Font(ucomp).FileTitle())) {
						Font(nnewpos).m_cfn.UniqueName(true, true, Font(nnewpos).m_cfn.Path()) ;
						ucomp = (unsigned) -1 ;
					} ;
				} ;

                for (uModel = (unsigned) cwaModel.GetSize(); uModel--; )
                    if  (m_comdd.DefaultCTT(cwaModel[uModel]) == widCTT) {
                        m_comdd.NoteTranslation(cwaModel[uModel], u + 1,
                            FontCount());
                        cwaModel.RemoveAt(uModel);
                    }
            }

        }
    }

	// Change the GTT ID in each CGlyphMap instance.  Currently, these IDs are
	// set to whatever was used in the old RC file.  The new RC file may
	// renumber the GTTs so the IDs in CGlyphMap instances should match what
	// will be in the RC file.  When the RC file is written, the GTTs are
	// number consecutively starting at 1.  (Don't change IDs that are <= 0.)

    for (u = 0 ; u < MapCount(); u++)
		if  (GlyphTable(u).nGetRCID() > 0)	
			GlyphTable(u).nSetRCID((int) (u + 1)) ;

    // Point each font at its associated GTT file, if there is one.

    for (u = 0 ; u < FontCount(); u++)
        for (unsigned uGTT = 0; uGTT < MapCount(); uGTT++)
            if  (Font(u).Translation() == ((WORD) GlyphTable(uGTT).nGetRCID()))
                Font(u).SetTranslation(&GlyphTable(uGTT));

    Changed();

    return  TRUE;
}

/******************************************************************************

  CDriverResources::ConvertGPCData

  This will handle the conversion of the GPC data to GPD format.  It has to be
  done after the framework (especially the target directory) is created.

******************************************************************************/

BOOL    CDriverResources::ConvertGPCData(CProjectRecord& cprOwner,
                                         WORD wfGPDConvert)
{
    //  We've already loaded the GPC data, so now we just generate the files.

	unsigned umidx = -1 ;		// Used to index Model
	unsigned ugpcidx = 0 ;		// Used to indext GPC info
	int nsc ;					// Each entries split code

    for (unsigned u = 0 ; u < m_comdd.ModelCount(); u++) {
        CString csModel = m_csaModelFileNames[u] ;

		// Skip this GPD if it was not selected by the user; ie, it does not
		// have a file name.
		//
		// Before the GPD can be skipped, the GPC info index may need to be
		// incremented.  See below for a description of when this is done.

		if (csModel.IsEmpty()) {
			nsc = m_comdd.GetSplitCode(u) ;
			if (nsc == COldMiniDriverData::NoSplit)
				ugpcidx++ ;
			else if ((u + 1) < m_comdd.ModelCount()
			 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::NoSplit)
				ugpcidx++ ;
			else if	((u + 1) < m_comdd.ModelCount()
			 && nsc == COldMiniDriverData::OtherSplit
			 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::FirstSplit)
				ugpcidx++ ;

			continue ;
		} ;

		// Add a new model node and increment the index used to reference them.

        m_csoaModels.Add(new CModelData) ;
		umidx++ ;

		// Set the node's file name and display name.  Then load the other
		// pointers, etc needed for this node to perform correctly.

        if  (!Model(umidx).SetFileName(cprOwner.TargetPath(Win2000) + _T("\\") +
             csModel))
            return  FALSE;
        Model(umidx).NoteOwner(cprOwner);
        Model(umidx).EditorInfo(GPDTemplate());

		// Set the node's display name.  Normally, a node's display name is
		// pulled from the string table.  A separate array of names is used
		// to get the names of nodes that are based on GPC entries that
		// reference multiple models.

		if ((nsc = m_comdd.GetSplitCode(u)) == COldMiniDriverData::NoSplit)
			Model(umidx).Rename(m_cst[m_comdd.ModelName(u)]) ;
		else
			Model(umidx).Rename(m_comdd.SplitModelName(u)) ;
																			
		// Convert and save the GPD.

        //if  (!Model(umidx).Load(m_comdd.Image(), Name(), u + 1,
        if  (!Model(umidx).Load(m_comdd.Image(), Name(), ugpcidx + 1,
             m_comdd.FontMap(u), wfGPDConvert) || !Model(umidx).Store())
            return  ReportFileFailure(IDS_GPCConversionError, Model(umidx).Name());

		// Only increment the GPC index when
		//	1. The current entry does not reference multiple models
		//  2. The next entry does not reference multiple models
		//  3. The last model in the current entry is being processed
		// This is done to make sure that every model in an entry use the same
		// GPC index and that the index is kept in sync with each entry that
		// is processed.

		if (nsc == COldMiniDriverData::NoSplit)
			ugpcidx++ ;
		else if ((u + 1) < m_comdd.ModelCount()
		 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::NoSplit)
			ugpcidx++ ;
		else if	((u + 1) < m_comdd.ModelCount()
		 && nsc == COldMiniDriverData::OtherSplit
		 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::FirstSplit)
			ugpcidx++ ;
    }

    Changed();
    return  TRUE;
}


/******************************************************************************

  CDriverResources::GetGPDModelInfo

  Load the string arrays with with the GPD model names and file names.

******************************************************************************/

BOOL    CDriverResources::GetGPDModelInfo(CStringArray* pcsamodels,
										  CStringArray* pcsafiles)
{
	// If this is the first time this routine is called, initialize
	// m_csaModelFileNames.

	unsigned unummodels = m_comdd.ModelCount() ;
	if (unummodels != (unsigned) m_csaModelFileNames.GetSize()) {
		try {
			m_csaModelFileNames.SetSize(unummodels) ;
		}
		catch(CException* pce) {	// Caller processes error
			pce -> Delete() ;
			return  FALSE ;
		} ;
	} ;

	// Size the destination arrays

	try {
		pcsamodels->SetSize(unummodels) ;
		pcsafiles->SetSize(unummodels) ;
	}
	catch(CException* pce) {		// Caller processes error
		pce -> Delete() ;
		return  FALSE ;
	} ;

	// Loop through all of the GPDs and copy the information

    for (unsigned u = 0 ; u < m_comdd.ModelCount() ; u++) {
		if (m_comdd.GetSplitCode(u) == COldMiniDriverData::NoSplit)
			pcsamodels->SetAt(u, m_cst[m_comdd.ModelName(u)]) ;
		else
			pcsamodels->SetAt(u, m_comdd.SplitModelName(u)) ;
		pcsafiles->SetAt(u, m_csaModelFileNames[u]) ;
	} ;

	// All went well so...

	return TRUE ;
}


/******************************************************************************

  CDriverResources::SaveVerGPDFNames

  Save the GPD file names that entered into the GPD Selection page of the
  Conversion Wizard.  If requested, the names will be verified, too.  Two tests
  are made.  First, the file names are checked to make sure they only contain
  valid file name characters.  Second, the file names are checked to make sure
  they are all unique.

  Return -1 if all is ok.  If an error was found, return the index of the first
  offending entry so that that entry can be highlighted on the GPD Selection
  page.

******************************************************************************/

int	CDriverResources::SaveVerGPDFNames(CStringArray& csafiles, bool bverifydata)
{
	int numelts = (int)csafiles.GetSize() ;

	// Save the GPD file names

    for (int n = 0 ; n < numelts ; n++)
		m_csaModelFileNames[n] = csafiles[n] ;
	
	// Return "all is ok" if no verification is needed.

	if (!bverifydata)
		return -1 ;

	// Complain if any of the file names contains an illegal character and
	// return the index for that file.

    for (n = 0 ; n < numelts ; n++) {
		if (m_csaModelFileNames[n].FindOneOf(_T(":<>/\\\"|")) < 0)
			continue ;
		CString csmsg ;
        csmsg.Format(IDS_BadFileChars, m_csaModelFileNames[n]) ;
        AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return n ;
	} ;

	// Complain if any of the file names are dups and return the index for that
	// file.

    for (n = 1 ; n < numelts ; n++) {

		// Skip this entry if it is empty.

		if (m_csaModelFileNames[n].IsEmpty())
			continue ;

		for (int m = 0 ; m < n ; m++) {

			// If these files don't match, continue checking.

			if (m_csaModelFileNames[n] != m_csaModelFileNames[m])
				continue ;

			// A duplicate was found so display an error message and return
			// its index.

			CString csmsg ;
			csmsg.Format(IDS_DupGPDFName, m, n, m_csaModelFileNames[n]) ;
			AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
			return n ;
		} ;
	} ;

	// The file names passed the tests so...

	return -1 ;
}


/******************************************************************************

  CDriverResources::GenerateGPDFileNames

  Generate a file name (sans extension) for each GPD that doesn't already have
  a file name.  This is done by taking the first two characters of the model
  name + the last 6 characters of the model name.  Then make sure that each
  name is unique.  (Note: This last phase might change one of the user's
  names.)

******************************************************************************/

void CDriverResources::GenerateGPDFileNames(CStringArray& csamodels,
											CStringArray& csafiles)
{
	CString		csfname ;		// New file name
	CString		csmodel ;		// Used to build file names
	int			npos ;			// Positions of specific chars in a string
	TCHAR	tch ;				// Unique character

	// Loop through all of the file names looking for onces that are empty

	int numelts = (int)csafiles.GetSize() ;
    for (int n = 0 ; n < numelts ; n++) {
		
		// Continue if the current file name is already set

		if (!csafiles[n].IsEmpty())
			continue ;

		// The current model has no file name so generate one from the model
		// name.  Start by making a copy of the model name and remove all bad
		// characters from it.

		csmodel = csamodels[n] ;
		while ((npos = csmodel.FindOneOf(_T(":<>/\\\"|"))) >= 0)
			csmodel = csmodel.Left(npos) + csmodel.Mid(npos + 1) ;

		// Add the first 2 characters of the model name (usually the first 2
		// letters of the manufacturer's name) to the file name.

		csfname = csmodel.Left(2) ;

		// Remove the first space delimited word (usually manufacturer's name)
		// from the model name.

		if ((npos = csmodel.Find(_T(' '))) >= 0)
			csmodel = csmodel.Mid(npos + 1) ;

		// Use up to 6 characters from the right of the remaining model name
		// characters to finish the file name.  Then save the file name.

		csfname += csmodel.Right(6) ;
		csafiles[n] = csfname ;
	} ;

	// Now we need to make sure that the file names are unique.  The algorithm
	// used is much like the one in CBasicNode::UniqueName().  That function
	// is not used because we aren't dealing with Workspace View nodes here.

    bool bchanged = false ;
	for (n = 1 ; n < numelts ; n++, bchanged = false) {
		for (int m = 0 ; m < n ; m++) {
			if (csafiles[n] != csafiles[m])
				continue ;

			// The current file name is not unique so it has to be changed.
			// Begin by determine the 0-based length of the name.

			npos = csafiles[n].GetLength() - 1 ;

			// If the name has been changed before, use the last "unique"
			// character to determine the new unique character.  Then replace
			// the old unique character with the new unique character.

			if (bchanged) {
				tch = csafiles[n].GetAt(npos) + 1 ;
				if (tch == _T('{'))
					tch = _T('0') ;
				else if (tch == _T(':'))
					tch = _T('a') ;
				csafiles[n].SetAt(npos, tch) ;

			// If the name has not been changed before, add a unique character
			// to the end of the name if this won't make the name longer than
			// 8 characters.  Otherwise, replace the last character with the
			// new unique character.

			} else {
				if (npos < 7)
					csafiles[n] += _T("a") ;
				else
					csafiles[n].SetAt(npos, _T('a')) ;
			} ;

			// Note that this name has been changed and reset the inner loop
			// counter so that the changed name will be rechecked against all
			// of the file names it needs to be checked against.

			bchanged = true ;
			m = -1 ;
		} ;
	} ;
}


/******************************************************************************

  CDriverResources::Generate

  This member function generates the RC file for one of the target environments

******************************************************************************/

BOOL    CDriverResources::Generate(UINT ufTarget, LPCTSTR lpstrPath)
{
	int		nrcid ;				// Holds a resource's ID
    CString csFontPrefix, csTransPrefix, csFontLabel, csTransLabel;
    unsigned    ucTables = 0, ucFonts =
                    (ufTarget == Win2000) ? FontCount() : OriginalFontCount();

    if  (ufTarget == Win2000) {
        csFontLabel = _T("RC_UFM");
        csTransLabel = _T("RC_GTT");
    }
    else {
        csFontLabel = _T("RC_FONT");
        csTransLabel = _T("RC_TRANSTAB");
    }

    switch  (ufTarget) {
        case    Win2000:
            csFontPrefix = _TEXT("UFM");
            csTransPrefix = _TEXT("GTT");
            break;

        case    WinNT40:
        case    WinNT3x:
            csFontPrefix = _TEXT("IFI");
            csTransPrefix = _TEXT("RLE");
            ucTables = 2;
            break;

        case    Win95:
            csFontPrefix = _TEXT("PFM");
            csTransPrefix = _TEXT("CTT");
            ucTables = 1;
            break;

        default:
            _ASSERTE(FALSE);    //  This shouldn't happen
            return  FALSE;
    }

    //  Create the RC file first.

    CStdioFile  csiof;

    if  (!csiof.Open(lpstrPath, CFile::modeCreate | CFile::modeWrite |
            CFile::shareExclusive | CFile::typeText)) {
        _ASSERTE(FALSE);    //  This shouldn't be possible
        return  FALSE;
    }

    //  Write out our header- it identifies this tool as the source, and it
    //  will (eventually) include the Copyright and other strings used to
    //  customize the environment.
    try {
		CString cs, cs2 ;
		cs.LoadString(IDS_RCCommentHdr1) ;
		csiof.WriteString(cs) ;
		cs.LoadString(IDS_RCCommentHdr2) ;
		csiof.WriteString(cs) ;
		cs.LoadString(IDS_RCCommentHdr3) ;
		csiof.WriteString(cs) ;

        //csiof.WriteString(_TEXT("/********************************************")
        //    _TEXT("**********************************\n\n"));
        //csiof.WriteString(_T("  RC file generated by the Minidriver ")
        //    _T("Development Tool\n\n"));
        //csiof.WriteString(_TEXT("*********************************************")
        //    _TEXT("*********************************/\n\n"));

        // Write out the standard definition and include statements for Win2K
		// style RC files.
		ForceCommonRC(FALSE);	// Don't use common.rc at all	// raid 141064
        if  (ufTarget == Win2000) { //  NT knows best.  What do developers know?
			cs.LoadString(IDS_StdIncludeFile1) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;
            if  (m_bUseCommonRC) {
				cs.LoadString(IDS_StdIncludeFile2) ;
				cs2.Format(IDS_IncStmt, cs) ;
				csiof.WriteString(cs2) ;
			} ;
			cs.LoadString(IDS_StdIncludeFile3) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;
			cs.LoadString(IDS_StdIncludeFile4) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;

            //csiof.WriteString(_T("#include <Minidrv.H>\n"));
            //if  (m_bUseCommonRC)
            //    csiof.WriteString(_T("#include <Common.RC>\n"));
            //csiof.WriteString(_T("#include <Windows.H>\n"));
            //csiof.WriteString(_T("#include <NTVerP.H>\n"));

			// Add the version definitions to the RC file.

			csiof.WriteString(_T("#define VER_FILETYPE VFT_DRV\n"));
            csiof.WriteString(_T("#define VER_FILESUBTYPE VFT2_DRV_PRINTER\n"));
            csiof.WriteString(_T("#define VER_FILEDESCRIPTION_STR \""));

			csiof.WriteString(Name());
            csiof.WriteString(_T(" Printer Driver\"\n"));
            csiof.WriteString(_T("#define VER_INTERNALNAME_STR \""));
            csiof.WriteString(Name().Left(8));
            csiof.WriteString(_T(".dll\"\n"));
            csiof.WriteString(_T("#define VER_ORIGINALFILENAME_STR \""));
            csiof.WriteString(Name().Left(8));
            csiof.WriteString(_T(".dll\"\n"));

			// Source RC files often contain the same version definitions as
			// those added above.  Make sure they aren't added to the Win2K RC
			// file twice by removing them from the definitions from the source
			// file.
			//
			// If any new definitions are added in the section above, add a
			// statement for that definition below.

			RemUnneededRCDefine(_T("VER_FILETYPE")) ;
			RemUnneededRCDefine(_T("VER_FILESUBTYPE")) ;
			RemUnneededRCDefine(_T("VER_FILEDESCRIPTION_STR")) ;
			RemUnneededRCDefine(_T("VER_INTERNALNAME_STR")) ;
			RemUnneededRCDefine(_T("VER_ORIGINALFILENAME_STR")) ;
			
			// Add include statement for common version info.

			cs.LoadString(IDS_StdIncludeFile5) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;

            //csiof.WriteString(_T("#include \"common.ver\"\n"));
        } ;

		// Write out the rest (all if < NT 4) of the include statements.
/*	raid 141064
        for (unsigned u = 0; u < (unsigned) m_csaIncludes.GetSize(); u++) {
            CString csTest = m_csaIncludes[u];
            csTest.MakeLower();
            if  (m_csaIncludes[u].Find(_TEXT(".ver")) != -1)
                continue;
            csTest = _TEXT("#include ");
            csTest += m_csaIncludes[u] + _TEXT('\n');
            csiof.WriteString(csTest);
        }
*/
        csiof.WriteString(_TEXT("\n"));

        //  Now, write out all of the #defines

        for (unsigned u = 0; u < (unsigned) m_csaDefineNames.GetSize(); u++) {
            CString csDefine;
            csDefine.Format(_TEXT("#define %-32s %s\n"),
                (LPCTSTR) m_csaDefineNames[u], (LPCTSTR) m_csaDefineValues[u]);
            csiof.WriteString(csDefine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  GPC tables

        if  (ufTarget != Win2000)
            for (u = 0; u < ucTables; u++) {
                CString csLine;
                csLine.Format(_T("%-5u RC_TABLES PRELOAD MOVEABLE "), u + 1);
                if  (m_csaTables[u] != _T("NT"))
                    csLine += _T("\"");
                csLine += m_csaTables[u] + _T(".GPC");
                if  (m_csaTables[u] != _T("NT"))
                    csLine += _T("\"");
                csiof.WriteString(csLine + _T("\n"));
            }

        csiof.WriteString(_TEXT("\n"));

        //  Font tables

        for (u = 0; u < ucFonts; u++) {
            CString csLine;

			// Get the RC ID from the font node.  If the ID == -1, use the
			// font's index as its ID.

			if ((nrcid = Font(u).nGetRCID()) == -9999)
				nrcid = u + 1 ;

#if defined(NOPOLLO)
            csLine.Format(_TEXT("%-5u %s LOADONCALL DISCARDABLE \""),
                nrcid, (LPCTSTR) csFontLabel);
            csLine += csFontPrefix + _TEXT('\\') + Font(u).FileTitle() +
                _TEXT('.') + csFontPrefix + _TEXT("\"\n");
#else
            csLine.Format(_TEXT("%-5u %s LOADONCALL DISCARDABLE "),
                nrcid, (LPCTSTR) csFontLabel);
            csLine += csFontPrefix + _TEXT('\\') + Font(u).FileTitle() +
                _TEXT('.') + csFontPrefix + _TEXT("\n");
#endif
            csiof.WriteString(csLine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  Mapping tables

        for (u = 0; u < MapCount(); u++) {
            CString csLine;

			// Get the RC ID from the GTT node.  If the ID == -1, use the
			// GTT's index as its ID.

			if ((nrcid = GlyphTable(u).nGetRCID()) == -1)
				nrcid = u + 1 ;

#if defined(NOPOLLO)
            csLine.Format(_TEXT("%-5u %s LOADONCALL MOVEABLE \""),
                nrcid, (LPCTSTR) csTransLabel);
            csLine += csTransPrefix + _TEXT('\\') + GlyphTable(u).FileTitle() +
                _TEXT('.') + csTransPrefix + _TEXT("\"\n");
#else
            csLine.Format(_TEXT("%-5u %s LOADONCALL MOVEABLE "),
                nrcid, (LPCTSTR) csTransLabel);
            csLine += csTransPrefix + _TEXT('\\') + GlyphTable(u).FileTitle() +
                _TEXT('.') + csTransPrefix + _TEXT("\n");
#endif
            csiof.WriteString(csLine);
        }

        csiof.WriteString(_TEXT("\n"));

		int n ;
		n = m_cst.Count() ;

        //  Time to do the String Table
        if  (m_cst.Count()) {
            csiof.WriteString(_TEXT("STRINGTABLE\n  BEGIN\n"));
            for (u = 0; u < m_cst.Count(); u++) {
                WORD    wKey;
                CString csValue, csLine;

                m_cst.Details(u, wKey, csValue);

                csLine.Format(_TEXT("    %-5u  \""), wKey);
                csLine += csValue + _TEXT("\"\n");
                csiof.WriteString(csLine);
            }
            csiof.WriteString(_TEXT("  END\n\n"));
        }

        //  Now, write out any .ver includes

        if  (ufTarget != Win2000)   //  Already hardcoded them here
            for (u = 0; u < (unsigned) m_csaIncludes.GetSize(); u++) {
                CString csTest = m_csaIncludes[u];
                csTest.MakeLower();
                if  (m_csaIncludes[u].Find(_TEXT(".ver")) == -1)
                    continue;
                csTest = _TEXT("#include ");
                csTest += m_csaIncludes[u] + _TEXT('\n');
                csiof.WriteString(csTest);
            }

        csiof.WriteString(_TEXT("\n"));

        //  Now, any of the remnants
// RAID 3449 kill below 2 line
//        for (u = 0; u < (unsigned) m_csaRemnants.GetSize(); u++)
//            csiof.WriteString(m_csaRemnants[u] + TEXT('\n'));
    }
    catch (CException* pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}


/******************************************************************************

  CDriverResources::RemUnneededRCDefine

  Remove the specified definition from the array of definitions that will be
  added to the definitions in the output RC file.

******************************************************************************/

void CDriverResources::RemUnneededRCDefine(LPCTSTR strdefname)
{
    for (unsigned u = 0 ; u < (unsigned) m_csaDefineNames.GetSize() ; u++) {
        if (m_csaDefineNames[u].CompareNoCase(strdefname) != 0)
			continue ;
		m_csaDefineNames.RemoveAt(u) ;
		m_csaDefineValues.RemoveAt(u) ;
		return ;
    } ;
}


/******************************************************************************

  CDriverResources::RemUnneededRCInclude

  Remove the specified include file from the array of include files that will
  be added to the include statements in the output RC file.

******************************************************************************/

void CDriverResources::RemUnneededRCInclude(LPCTSTR strincname)
{
    for (unsigned u = 0 ; u < (unsigned) m_csaIncludes.GetSize() ; u++) {
		//TRACE("Inc[%d] = '%s'   incname = '%s'\n", u, m_csaIncludes[u], strincname) ;
        if (m_csaIncludes[u].CompareNoCase(strincname) != 0)
			continue ;
		m_csaIncludes.RemoveAt(u) ;
		return ;
    } ;
}


/******************************************************************************

  CDriverResources::ReparseRCFile

  Read in the new RC file, parse its statements, and update all of the internal
  data structures with the information from the new RC file.

******************************************************************************/

bool CDriverResources::ReparseRCFile(CString& csrcfspec)
{
    CWaitCursor     cwc ;		//  Just in case this takes a while...
	CString			cs, cs2 ;

	// Load the RC file and save its data into data specific arrays.

    CStringTable cstfonts, cstmaps ;
	CStringArray csa ;			// Use this instead of m_csaTables
    if  (!LoadRCFile(csrcfspec, m_csaDefineNames, m_csaDefineValues,
					 m_csaIncludes, m_csaRemnants, csa, m_cst, cstfonts,
					 cstmaps, Win2000)) {
		cs.LoadString(IDS_RCRepFailed1) ;
        AfxMessageBox(cs, MB_ICONEXCLAMATION) ;
        return false ;
	} ;

	// LoadRCFile() will have correctly reloaded m_csaDefineNames,
	// m_csaDefineValues, and m_csaIncludes.  Nothing needs to be done with csa.
	// Now, the rest of the data needs to be processed.  Start by finding and
	// removing the standard comment header from the remnants array.

	cs.LoadString(IDS_RCCommentHdr2) ;
	cs.TrimLeft() ;
	cs.TrimRight() ;
	CString csrem ;
	for (int n = 0 ; n < m_csaRemnants.GetSize() ; n++) {
		//TRACE("Rem[%d] = '%s'   hdr2 = '%s'\n", n, m_csaRemnants[n], cs) ;
		csrem = m_csaRemnants[n] ;
		csrem.TrimLeft() ;
		csrem.TrimRight() ;
		if (csrem == cs)
			break ;
	} ;
	if (n < m_csaRemnants.GetSize()) {
		n -= 2 ;
		int nc = n + 6 ;
		m_csaRemnants.RemoveAt(n, nc) ;
	} ;

	// Find and remove the standard include files from m_csaIncludes.

	cs.LoadString(IDS_StdIncludeFile1) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile2) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile3) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile4) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile5) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_OldIncludeFile1) ;
	RemUnneededRCInclude(cs) ;

	// Get the path to the RC file.

	CString csrcpath ;
	csrcpath = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\')) + 1) ;

	// Update the old/current GTT list with data from the new GTT list.

	CUIntArray cuaboldfound, cuabnewfound ;
	int nc ;	// Count of elements in new list.
	UpdateResourceList(cstmaps, m_csoaAtlas, cuaboldfound, cuabnewfound,
					   csrcpath, nc) ;

	// GTT List Update Step 3:  Update the old list with data for items from
	// the new list whenever a new list item was not found in the old list.

	CGlyphMap* pcgm ;
	WORD wkey ;
	for (n = 0 ; n < nc ; n++) {
		if (cuabnewfound[n])
			continue ;
		pcgm = new CGlyphMap ;
		cstmaps.Details(n, wkey, cs) ;
		pcgm->nSetRCID((int) wkey) ;				// Set resource handle
		UpdateResourceItem(pcgm, csrcpath, wkey, cs, FNT_GTTS) ;
		m_csoaAtlas.InsertAt(n, pcgm) ;
	} ;

	// Update the old/current UFM list with data from the new UFM list.

	UpdateResourceList(cstfonts, m_csoaFonts, cuaboldfound, cuabnewfound,
					   csrcpath, nc) ;

	// UFM List Update Step 3:  Update the old list with data for items from
	// the new list whenever a new list item was not found in the old list.

	CFontInfo* pcfi ;
	for (n = 0 ; n < nc ; n++) {
		if (cuabnewfound[n])
			continue ;
		pcfi = new CFontInfo ;
		cstfonts.Details(n, wkey, cs) ;
		UpdateResourceItem(pcfi, csrcpath, wkey, cs, FNT_UFMS) ;
		m_csoaFonts.InsertAt(n, pcfi) ;
	} ;

	// All went well so...
	
	return true ;
}


/******************************************************************************

  CDriverResources::UpdateResourceList

  Three steps are needed to update a resource list.  Two of those steps are
  performed in this version of UpdateResourceList().

  Step 1: Compare the old and new lists.  Whenever a new resource file matches
  an old one, update the RC ID when necessary and mark them both as being found.

  Step 2: Remove any of the old resource class instances that were not found in
  Step 1.

******************************************************************************/

void CDriverResources::UpdateResourceList(CStringTable& cst, CSafeObArray& csoa,
										  CUIntArray& cuaboldfound,
										  CUIntArray& cuabnewfound,
										  CString& csrcpath, int& nc)
{
	// Declare and initialize the variables that will control the loops, etc.

	nc = cst.Count() ;
	cuabnewfound.RemoveAll() ;
	cuabnewfound.SetSize(nc) ;
	int ncold = csoa.GetSize() ;
	cuaboldfound.RemoveAll() ;
	cuaboldfound.SetSize(ncold) ;
	WORD wkey ;
	CString cs ;

	// Try to find each new resource in the list of old resources.

	for (int n = 0 ; n < nc ; n++) {
		cst.Details(n, wkey, cs) ;
		cs = csrcpath + cs ;
		for (int n2 = 0 ; n2 < ncold ; n2++) {
			//TRACE("+++ Resource path = %s\n", ((CProjectNode *) csoa[n2])->FileName()) ;
			if (cs == ((CProjectNode *) csoa[n2])->FileName()) {

				// Update the matching old resource's ID if it isn't the same
				// as the new one.

				if (wkey != ((CProjectNode *) csoa[n2])->nGetRCID())
					((CProjectNode *) csoa[n2])->nSetRCID(wkey) ;

				// Note that a match for the old and new resources was found.

				cuabnewfound[n] = (unsigned) true ;
				cuaboldfound[n2] = (unsigned) true ;
				break ;
			} ;
		} ;
	} ;

	// Remove the old resource class instances that are no longer in the new
	// list.

	for (n = ncold - 1 ; n >= 0 ; n--) {
		if (cuaboldfound[n])
			continue ;
		csoa.RemoveAt(n) ;
	} ;
}


/******************************************************************************

  CDriverResources::UpdateResourceItem

  This function does most of the work for the third resource update step.  It
  initializes new resources that are going to be added to the resource list.
  Essentially, it does what the serialize routines do.

******************************************************************************/

void CDriverResources::UpdateResourceItem(CProjectNode* pcpn, CString& csrcpath,
										  WORD wkey, CString& cs,
										  FIXEDNODETYPE fnt)
{
	// Build the full filespec for the resource, its name, and its path.

	CString csfspec, csname, cspath ;
	csfspec = csrcpath + cs ;
	int n = csfspec.ReverseFind(_T('\\')) ;
	cspath = csfspec.Left(n + 1) ;
	csname = csfspec.Mid(n + 1)  ;
	n = csname.ReverseFind(_T('.')) ;
	if (n >= 0)
		csname = csname.Left(n) ;
	
	// Use the file name (no extension) as the default resource name.

	CString csfs ;
	pcpn->Rename(csname) ;
	csfs = pcpn->Name() ;

	// Set the file node's path and file name.
	
	pcpn->m_cfn.SetPathAndName(cspath, csname) ;
	csfs = pcpn->FileName() ;
	
	// Set the rc id and resource type.

	pcpn->nSetRCID(wkey) ;
	pcpn->m_crinRCID.fntSetType(FNT_GTTS) ;
}


/******************************************************************************

  CDriverResources::Fill

  This is a CProjectNode override- it fills in the material relevant to this
  driver.

******************************************************************************/

void    CDriverResources::Fill(CTreeCtrl *pctcWhere, CProjectRecord& cpr)
{
    CWaitCursor cwc;

    NoteOwner(cpr);
    SetWorkspace(this);
    CBasicNode::Fill(pctcWhere);

	// Add the resources node
	m_cfnResources.Fill(pctcWhere, m_hti) ;
    m_cfnResources.NoteOwner(cpr) ;

    //  Fill in the font information
    m_cfnFonts.NoteOwner(cpr);
    for (unsigned u = 0; u < FontCount(); u++) {
        Font(u).SetWorkspace(this);
        Font(u).EditorInfo(FontTemplate());
    }
    m_cfnFonts.Fill(pctcWhere, m_cfnResources.Handle());
    m_cfnFonts.SetWorkspace(this);

    //  Fill in the glyph map information
    m_cfnAtlas.NoteOwner(cpr);
    for (u = 0; u < MapCount(); u++) {
        GlyphTable(u).SetWorkspace(this);
        GlyphTable(u).EditorInfo(GlyphMapDocTemplate());
    }
    m_cfnAtlas.Fill(pctcWhere, m_cfnResources.Handle());
    m_cfnAtlas.SetWorkspace(this);

	// Add the strings node
    m_csnStrings.Fill(pctcWhere, m_cfnResources.Handle());
    m_csnStrings.NoteOwner(cpr);
    m_csnStrings.SetWorkspace(this);

    //  Fill in the model data information.
    for (u = 0; u < Models(); u++) {
        Model(u).SetWorkspace(this);
        Model(u).EditorInfo(GPDTemplate());
    }
    m_cfnModels.NoteOwner(cpr);
    m_cfnModels.Fill(pctcWhere, m_hti);
    m_cfnModels.SetWorkspace(this);

	// Expand the first couple of levels of the tree
	pctcWhere -> Expand(m_hti, TVE_EXPAND);
	pctcWhere -> Expand(m_cfnResources.Handle(), TVE_EXPAND);

    //  Load the font and GTT files, then map them together.  Also load any
    //  predefined tables now.

    for (u = 0; u < MapCount(); u++)
        GlyphTable(u).Load();

    for (u = 0; u < FontCount(); u++)
		LinkAndLoadFont(Font(u), true) ;

	// Save a copy of the Win2K path in this class because the path is easier to
	// get and use when it is in this class.

	m_csW2000Path = cpr.GetW2000Path() ;
}


/******************************************************************************

  CDriverResources::LinkAndLoadFont


******************************************************************************/
// raid 0003
void CDriverResources::LinkAndLoadFont(CFontInfo& cfi, bool bworkspaceload, bool bonlyglyph)
{
	CGlyphMap* pcgm ;

	// If this is part of a workspace load (ie, called from Fill()), load the
	// font the first time to get the GTT ID and code page number in the font.

	if (bworkspaceload)
		cfi.Load(true) ;

	// Now that the font has been loaded, use the data in it to see if it
	// references a predefined GTT.

	pcgm = CGlyphMap::Public(cfi.Translation(), (WORD) cfi.m_ulDefaultCodepage,
							 ((CProjectRecord*) GetOwner())->GetDefaultCodePage(),
							 cfi.GetFirst(), cfi.GetLast()) ;

	// If a GTT was found, save a pointer to it in the font's class.  Otherwise,
	// look for the font's GTT amongst the GTTs in the font's workspace.  Again,
	// save a pointer to the GTT if a match is found.

    if  (pcgm)
        cfi.SetTranslation(pcgm) ;
    else {
		//TRACE(    "UFM = %s   GTT ID = %d\n", cfi.Name(), cfi.Translation()) ;
        for (unsigned uGTT = 0; uGTT < MapCount(); uGTT++) {
			//TRACE("Checking %dth ID = %d    Name = %s\n", uGTT+1, 
			//	  GlyphTable(uGTT).nGetRCID(), GlyphTable(uGTT).Name()) ;
            if  (cfi.Translation() == ((WORD) GlyphTable(uGTT).nGetRCID())) {
                cfi.SetTranslation(&GlyphTable(uGTT)) ;
				break ;
			} ;
		} ;
	} ;

	if (bonlyglyph && cfi.m_pcgmTranslation != NULL)
		return ;
	// Load the font again if we now know the linkage; ie the GTT/CP.
	// Otherwise, warn the user.  (The font is loaded again because parts of
	// the UFM cannot be correctly loaded until the GTT is available.)

	if (cfi.m_pcgmTranslation != NULL)
		cfi.Load(true) ;
	else {
		cfi.SetNoGTTCP(true) ;
		CString csmsg ;
		csmsg.Format(IDS_NoGTTForUFMError, cfi.Name()) ; 
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
	} ;
}


/******************************************************************************

  CDriverResources::WorkspaceChecker

  Check the workspace for completeness and tidiness.  The following checks are
  made:
	1.  All GTTs referenced in the UFMs exist.
	2. 	All GTTs are referenced by at least one UFM.
	3.  All UFMs referenced in the GPDs exist.
	4.  All UFMs are referenced by at least one GPD.
	5.  All strings referenced in the GPDs exist.
	6.	All strings are referenced by at least one GPD.
	7.  All GPD model names are unique.
	8.  All GPD file names are unique.

  Workspaces that pass tests 1, 3, 5, 7, and 8 are considered to be complete.
  These test must be passed before the driver is built and used. Workspaces
  that pass tests 2, 4, and 6 are considered to be tidy.  Failure to pass these
  tests generate warnings.

******************************************************************************/

bool CDriverResources::WorkspaceChecker(bool bclosing)
{
	bool		bwsproblem ;		// True iff an error or warning was found

    //  This might take a while, so...

    CWaitCursor cwc ;

	// First reset any existing error window for this workspace to make sure
	// that the window won't contain duplicate error/warning messages.	Then
	// initialize the error found flag.

	ResetWorkspaceErrorWindow(bclosing) ;
	bwsproblem = false ;

	// Perform the GTT related checks (1 & 2)

	DoGTTWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Perform the GPD related checks (7 & 8)

	DoGPDWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Perform the UFM related checks (3 & 4)

	DoUFMWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Perform the string related checks (5 & 6).  This check should only be
	// done if the workspace contains RC IDs for the strings that we want to
	// check.

	CProjectRecord* pcpr = (CProjectRecord *) m_pcdOwner ;
	if (pcpr != NULL && pcpr->GetMDWVersion() > MDW_DEFAULT_VERSION)
		DoStringWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Tell the user if no problems were found.  Only do this when the
	// workspace is not closing.

	if (!bwsproblem && !bclosing) {
		CString csmsg ;
		csmsg.Format(IDS_NoWSProblems, Name()) ;
		AfxMessageBox(csmsg) ;
	} ;

	// Let the caller know if any problems were found.

	return bwsproblem ;
}


/******************************************************************************

  CDriverResources::DoGTTWorkspaceChecks

  The following checks are made:
	1.  All GTTs referenced in the UFMs exist.
	2. 	All GTTs are referenced by at least one UFM.

******************************************************************************/

void CDriverResources::DoGTTWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	short		srcid ;			// Current RC ID being checked
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	ucount2 ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2 ;			// Loop counters
	CString		csmsg ;			// Error or warning message
	CGlyphMap*	pcgm ;			// Used to streamline code
	CFontInfo*	pcfi ;			// Used to streamline code
	
	// Clear the referenced flag in each GTT node

	for (ucount = MapCount(), u = 0 ; u < ucount ; u++)
        GlyphTable(u).ClearRefFlag() ;

	// Completeness Check #1
	// Check each UFM to make sure that the GTT it references, exists.  This is
	// done by checking the GTT RC ID in each UFM against all of the GTT RC IDs
	// to see if a match is found.

	for (ucount = FontCount(), u = 0 ; u < ucount ; u++) {
		pcfi = &Font(u) ;

		// Get the GTT RC ID referenced in the current UFM.  Continue if the ID
		// is one of the special GTT IDs (-1 to -18).

		srcid = pcfi->Translation() ;
		if (srcid >= CGlyphMap::Wansung && srcid <= CGlyphMap::CodePage437)
			continue ;

		// Try to find a matching GTT ID.  If one is found, mark that GTT as
		// being referenced.
	
		for (ucount2 = MapCount(), u2 = 0 ; u2 < ucount2 ; u2++) {
			if (srcid == GlyphTable(u2).nGetRCID()) {
				GlyphTable(u2).SetRefFlag() ;
				break ;
			} ;
		} ;

		// If the GTT was not found, format and post an error message.  Also,
		// set the flag indicating that an error has occurred.

		if (u2 >= ucount2) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			if(srcid == 0)  //RAID 18518
				csmsg.Format(IDS_UFMCompWarning, pcfi->Name(), srcid) ;
			else			//END RAID
				csmsg.Format(IDS_UFMCompError, pcfi->Name(), srcid) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcfi) ;
			bwsproblem = true ;
		} ;
	} ;

	// Tidiness Check #2
	// Each GTT that is referenced by a UFM was marked above.  Now we need to
	// find out if any GTT is unreferenced.  Post a warning message for each
	// unreferenced GTT.

	for (ucount = MapCount(), u = 0 ; u < ucount ; u++) {
		pcgm = &GlyphTable(u) ;
        if (!pcgm->GetRefFlag()) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_GTTTidyWarning, pcgm->Name(), pcgm->nGetRCID()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcgm) ;
		} ;
	} ;
}


void CDriverResources::DoUFMWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	int			nrcid ;			// Current RC ID being checked
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	ucount2 ;		// Count of nodes, etc processed in a loop
	unsigned	ucount3 ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2, u3 ;		// Loop counters
	CString		csmsg ;			// Error or warning message
	CFontInfo*	pcfi ;			// Used to streamline code
	CModelData*	pcmd ;			// Used to streamline code
	
	// Clear the referenced flag in each UFM

	for (ucount = FontCount(), u = 0 ; u < ucount ; u++)
        Font(u).ClearRefFlag() ;

	// Completeness Check #3
	// Check to see if all of the UFMs referenced by each GPD exist in the
	// workspace.

    for (ucount = Models(), u = 0; u < ucount ; u++) {
        pcmd = &Model(u) ;

		// Update the list of UFMs in the GPD.  This may fail.  If it does,
		// post an error message explaining the problem and how to fix it.
		// Then skip further processing of this GPD.

		if (!pcmd->UpdateResIDs(true)) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_BadGPDError, pcmd->Name()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
			bwsproblem = true ;
			continue ;
		} ;

		// Check to see if each UFM referenced by the GPD is in the workspace.

		for (ucount2 = pcmd->NumUFMsInGPD(), u2 = 0 ; u2 < ucount2 ; u2++) {
			// Skip this UFM if it is 0x7fffffff.  That ID has a special
			// meaning.

			if ((nrcid = pcmd->GetUFMRCID(u2)) == 0x7fffffff || nrcid < 0
			 || nrcid >= 32768)
				continue ;
			
			// Try to find a UFM in the workspace that matches the current ID
			// from the GPD.  If one is found, mark that UFM as being
			// referenced.

			for (ucount3 = FontCount(), u3 = 0 ; u3 < ucount3 ; u3++) {
				if (nrcid == Font(u3).nGetRCID()) {
					Font(u3).SetRefFlag() ;
					break ;
				} ;
			} ;

			// If the UFM was not found, format and post an error message.
			// Also, set the flag indicating that an error has occurred.

			if (u3 >= ucount3) {
				if (IgnoreChecksWhenClosing(bclosing))
					return ;
				csmsg.Format(IDS_GPDUFMCompError, pcmd->Name(), nrcid) ;
				PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
				bwsproblem = true ;
			} ;
		} ;
	} ;

	// Tidiness Check #4
	// Each UFM that is referenced by a GPD was marked above.  Now we need to
	// find out if any UFM is unreferenced.  Post a warning message for each
	// unreferenced UFM.

	for (ucount = FontCount(), u = 0 ; u < ucount ; u++) {
		pcfi = &Font(u) ;
        if (!pcfi->GetRefFlag()) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_UFMTidyWarning, pcfi->Name(), pcfi->nGetRCID()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcfi) ;
		} ;
	} ;
}


/******************************************************************************

  CDriverResources::DoStringWorkspaceChecks

  The following checks are made:
	5.  All strings referenced in the GPDs exist.
	6.	All strings are referenced by at least one GPD.

******************************************************************************/

void CDriverResources::DoStringWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	int			nrcid ;			// Current RC ID being checked
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	ucount2 ;		// Count of nodes, etc processed in a loop
	unsigned	ucount3 ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2, u3 ;		// Loop counters
	CString		csmsg ;			// Error or warning message
	CModelData*	pcmd ;			// Used to streamline code
	WORD		wkey ;			// String RC ID
	CString		csstr ;			// String associated with wkey & other strings
	
	// Clear the referenced flags for each of the strings in the table

	m_cst.InitRefFlags() ;

	// Completeness Check #5
	// Check to see if all of the strings referenced by each GPD exist in the
	// workspace.

    for (ucount = Models(), u = 0; u < ucount ; u++) {
        pcmd = &Model(u) ;

		// Update the list of strings in the GPD.  This may fail.  If it does,
		// post an error message explaining the problem and how to fix it.
		// Then skip further processing of this GPD.

		if (!pcmd->UpdateResIDs(false)) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_BadGPDError, pcmd->Name()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
			bwsproblem = true ;
			continue ;
		} ;

		// Check to see if each string referenced by the GPD is in the
		// workspace.

		for (ucount2 = pcmd->NumStringsInGPD(), u2 = 0 ; u2 < ucount2 ; u2++) {
			// Get the current string ID from the GPD.

			nrcid = pcmd->GetStringRCID(u2) ;
			
			// Skip this ID if it is 0x7fffffff or in the range of IDs in 
			// common.rc or the ID comes from a resource DLL or the ID is 0 
			// because 0 IDs are just placeholders for constant strings in the
			// GPD.

			if (nrcid == 0x7fffffff
			 || (nrcid >= FIRSTCOMMONRCSTRID && nrcid <= LASTCOMMONRCSTRID)
			 || nrcid >= 65536 || nrcid == 0)
				continue ;

			// Try to find a string in the workspace that matches the current
			// ID from the GPD.  If one is found, mark that string as being
			// referenced.

			for (ucount3 = m_cst.Count(), u3 = 0 ; u3 < ucount3 ; u3++) {
				m_cst.Details(u3, wkey, csstr) ;
				if (nrcid == wkey) {
					m_cst.SetRefFlag(u3) ;
					break ;
				} ;
			} ;

			// If the string was not found, format and post an error message.
			// Also, set the flag indicating that an error has occurred.

			if (u3 >= ucount3) {
				if (IgnoreChecksWhenClosing(bclosing))
					return ;
				csmsg.Format(IDS_GPDStrCompError, pcmd->Name(), nrcid) ;
				PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
				bwsproblem = true ;
			} ;
		} ;
	} ;

	// Tidiness Check #6
	// Each string that is referenced by a GPD was marked above.  Now we need to
	// find out if any string is unreferenced.  Post a warning message for each
	// unreferenced string.

	for (ucount = m_cst.Count(), u = 0 ; u < ucount ; u++) {
        if (m_cst.GetRefFlag(u))		// Skip this string if it was referenced
			continue ;

		m_cst.Details(u, wkey, csstr) ;	// Skip this string if ID in low range
		if (wkey >= 1 && wkey <= 256)
			continue ;
		
		if (IgnoreChecksWhenClosing(bclosing))
			return ;
		csmsg.Format(IDS_StrTidyWarning, csstr, wkey) ;
		// NULL should be replaced with something that will allow the
		// string editor to be invoked once the string editor is
		// implemented.
		PostWSCheckingMessage(csmsg, NULL) ;
		bwsproblem = true ;
	} ;
}


/******************************************************************************

  CDriverResources::DoGPDWorkspaceChecks

  The following checks are made:
	7.  All GPD model names are unique.
	8.  All GPD file names are unique.

******************************************************************************/

void CDriverResources::DoGPDWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2 ;			// Loop counters
	CString		csmsg ;			// Error or warning message
	CString		csstr ;			// Temp string
	
	// Completeness Check #7
	// Check to see if all of the GPD model names are unique.

    for (ucount = Models(), u = 0; u < ucount ; u++) {					
		csstr = Model(u).Name() ;
		for (u2 = 0 ; u2 < u ; u2++) {									

			// If these model names don't match, continue checking.

			if (csstr != Model(u2).Name())
				continue ;

			// A duplicate was found so post an error message and indicate
			// that there is a problem.

			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_GPDModNameCompError, u, csstr) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) &Model(u)) ;
			bwsproblem = true ;
		} ;
	} ;

	// Completeness Check #8
	// Check to see if all of the GPD file names are unique.

    for (ucount = Models(), u = 0; u < ucount ; u++) {					
		csstr = Model(u).FileTitleExt() ;
		for (u2 = 0 ; u2 < u ; u2++) {									

			// If these model names don't match, continue checking.

			if (csstr != Model(u2).FileTitleExt())
				continue ;

			// A duplicate was found so post an error message  and indicate
			// that there is a problem.

			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_GPDFileNameCompError, u, csstr) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) &Model(u)) ;
			bwsproblem = true ;
		} ;
	} ;
}


/******************************************************************************

  CDriverResources::IgnoreChecksWhenClosing

  This function is used to end workspace checking and return to the caller
  when the workspace is closing iff the user says to do so.  This routine is
  only called - and therefore the user is only prompted - when an error or
  warning has been detected.  The up side of this is that no user intervention
  is needed unless a problem is detected.  The downside is that more checking
  (and sometimes all of the checking) has to be performed before we can find
  out if we should stop.  This is why the GPD checking is the last thing done
  by WorkspaceChecker().  Hopefully, if there is a problem, it will be found
  in the faster checks before the GPD checks have to be done.

******************************************************************************/

bool CDriverResources::IgnoreChecksWhenClosing(bool bclosing)
{
	// If this is the first message to be posted and the WS is closing, ask
	// the user what he wants to do.

	if (m_bFirstCheckMsg) {
		m_bIgnoreChecks = false ;	// Assume checks are NOT ignored
		if (bclosing) {
			CString csmsg ;
			csmsg.Format(IDS_WSCloseCheckPrmt, Name()) ;
			int nrc = AfxMessageBox(csmsg, MB_YESNO) ;
			m_bIgnoreChecks = (nrc == IDNO) ;
		} ;

		// Reset flag now that first check processing is done

		m_bFirstCheckMsg = false ;	
	} ;

	// By the time this point is reached, the value of m_bIgnoreChecks will
	// contain whatever should be returned by this function.

	return m_bIgnoreChecks ;
}


/******************************************************************************

  CDriverResources::PostWSCheckingMessage

  Create the checking results window if needed and then post a message to it.

******************************************************************************/

bool CDriverResources::PostWSCheckingMessage(CString csmsg, CProjectNode* ppn)
{
	// Create the workspace checking, error and warning display window if one
	// does not exist.

	if (m_pwscdCheckDoc == NULL) {
		m_pwscdCheckDoc = new CWSCheckDoc(this) ;
		if (m_pwscdCheckDoc == NULL)
			return false ;
		CString cstitle ;
		cstitle.Format(IDS_WSCheckTitle, Name()) ;
		m_pwscdCheckDoc->SetTitle(cstitle) ;
		CMultiDocTemplate*  pcmdt = WSCheckTemplate() ;	
		m_pcmcwCheckFrame = (CMDIChildWnd *) pcmdt->CreateNewFrame(m_pwscdCheckDoc, NULL) ;
		if  (m_pcmcwCheckFrame) {
			pcmdt->InitialUpdateFrame(m_pcmcwCheckFrame, m_pwscdCheckDoc, TRUE) ;
			pcmdt->AddDocument(m_pwscdCheckDoc) ;
		} else {
			delete m_pwscdCheckDoc ;
			m_pwscdCheckDoc = NULL ;
			m_bIgnoreChecks = true ;
			return false ;
		} ;
		m_bFirstCheckMsg = false ;
	} ;

	// Post the message and return

	m_pwscdCheckDoc->PostWSCMsg(csmsg, ppn) ;
	return true ;
}


/******************************************************************************

  CDriverResources::ResetWorkspaceErrorWindow

  If there is an existing checking results window for this workspace, clear
  out its contents.  Next, initialize a couple of flags that have to be set
  before the ws checking begins.

******************************************************************************/

void CDriverResources::ResetWorkspaceErrorWindow(bool bclosing)
{
	// Clear the checking window if there is one.

	if (m_pwscdCheckDoc && m_pcmcwCheckFrame && IsWindow(m_pcmcwCheckFrame->m_hWnd))
		m_pwscdCheckDoc->DeleteAllMessages() ;
	else {
		m_pwscdCheckDoc = NULL ;
		m_pcmcwCheckFrame = NULL ;
		// BUG_BUG - Do I need to delete these classes first???
	} ;

	// Initialize checking flags

	m_bFirstCheckMsg = true ;
	m_bIgnoreChecks = false ;
}


/******************************************************************************

  CDriverResources::RunEditor

  Run the String Editor if requested and the string RC ID is not a common ID.
  Otherwise, run the UFM Editor with the requested UFM loaded if the UFM ID
  is valid.

  Return true if it is possible to run an editor.  Otherwise, return false.

******************************************************************************/

bool CDriverResources::RunEditor(bool bstring, int nrcid)
{
	// If the String Editor is requested...

	if (bstring) {
		// Can't do anything if this is a special or common string ID.

		if (nrcid == 0x7fffffff
		 || (nrcid >= FIRSTCOMMONRCSTRID && nrcid <= LASTCOMMONRCSTRID))
			return false ;

		// Run the editor and return true because this was possible.

		m_csnStrings.SetFirstSelRCID(nrcid) ;
		m_csnStrings.Edit() ;
		return true ;
	} ;

	// UFM Editor requested so...
	
	// Fail if the UFM ID is invalid.

	if (nrcid < 1 || nrcid > (int) FontCount())
		return false ;

	// Since the UFMs might not be in RC ID order, I have to search for the UFM
	// with the matching ID.

	for (unsigned u = 0 ; u < FontCount() ; u++)
		if (Font(u).nGetRCID() == nrcid) {
			Font(u).Edit() ;
			return true ;
		} ;

	// Could not find UFM with matching RC ID so...

	return false ;
}



void CDriverResources::CopyResources(CStringArray& csaUFMFiles, CStringArray& csaGTTFiles, CString& csModel,CStringArray& csaRcid)
{
	// copy files to CDriverResources member data
	// UFM 
	for (int i = 0 ;  i < csaUFMFiles.GetSize(); i++ ) {
		CFontInfo* pcfi = new CFontInfo ; 
		pcfi->SetFileName(csaUFMFiles.GetAt(i)) ;
		pcfi->Rename(pcfi->FileTitle() ) ;
		m_csoaFonts.Add(pcfi) ;
	}

	// GTT
	for (i = 0 ; i < csaGTTFiles.GetSize() ; i ++ ) {
		CGlyphMap* pcgm = new CGlyphMap ;
		pcgm->SetFileName(csaGTTFiles.GetAt(i)) ;
		pcgm->Rename(pcgm->FileTitle() ) ;
		m_csoaAtlas.Add(pcgm) ;
	}

	// GPD
	
	for (i = 0 ; i < 1 ; i ++ ) {
		CModelData* pcmd = new CModelData ;
		pcmd->SetFileName(csModel);
		pcmd->Rename(pcmd->FileTitle() );
		m_csoaModels.Add(pcmd) ;
	}

	for (i = 0 ; i < csaRcid.GetSize() ; i ++ ) {
		AddStringEntry(csaRcid[i], m_cst) ;
	}
}



/******************************************************************************

  CDriverResources::SyncUFMWidth

To Do : call all UFM and reload the width table regard to change of the GTT
return; true at end of the process

******************************************************************************/
	
	

BOOL CDriverResources::SyncUFMWidth()
{
	unsigned uufms, u ;
	for (uufms = FontCount(), u = 0 ; u < uufms ; u++) {
		CFontInfo& cfi = Font(u) ;	
		CString cspath = cfi.FileName() ;

		cfi.CheckReloadWidths() ;
		cfi.Store(cspath,true ) ;
			
	}
	return true ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stredit.cpp ===
// StrEdit.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"
#include <gpdparse.h>
#include "rcfile.h"
#include "projrec.h"
#include "projnode.h"
#include "comctrls.h"
#include "StrEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStringEditorView

IMPLEMENT_DYNCREATE(CStringEditorView, CFormView)

CStringEditorView::CStringEditorView()
	: CFormView(CStringEditorView::IDD)
{
	//{{AFX_DATA_INIT(CStringEditorView)
	m_csGotoID = _T("");
	m_csSearchString = _T("");
	m_csLabel1 = _T("Press INS to add or insert a new string.\tDouble click an item or press ENTER to begin editing.");
	m_csLabel2 = _T("Press DEL to delete the selected strings.\tPress TAB to move between columns when editing.");
	//}}AFX_DATA_INIT

	m_bFirstActivate = true ;
}

CStringEditorView::~CStringEditorView()
{
}

void CStringEditorView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStringEditorView)
	DDX_Control(pDX, IDC_SESearchBox, m_ceSearchBox);
	DDX_Control(pDX, IDC_SEGotoBox, m_ceGotoBox);
	DDX_Control(pDX, IDC_SEGotoBtn, m_cbGoto);
	DDX_Control(pDX, IDC_SELstCtrl, m_cflstStringData);
	DDX_Text(pDX, IDC_SEGotoBox, m_csGotoID);
	DDX_Text(pDX, IDC_SESearchBox, m_csSearchString);
	DDX_Text(pDX, IDC_SELabel1, m_csLabel1);
	DDX_Text(pDX, IDC_SELabel2, m_csLabel2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStringEditorView, CFormView)
	//{{AFX_MSG_MAP(CStringEditorView)
	ON_BN_CLICKED(IDC_SEGotoBtn, OnSEGotoBtn)
	ON_BN_CLICKED(IDC_SESearchBtn, OnSESearchBtn)
	ON_WM_DESTROY()
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStringEditorView diagnostics

#ifdef _DEBUG
void CStringEditorView::AssertValid() const
{
	CFormView::AssertValid();
}

void CStringEditorView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CStringEditorView message handlers

/******************************************************************************

  CStringEditorView::OnSEGotoBtn

  Find and select the list control row that contains the requested RC ID.

******************************************************************************/

void CStringEditorView::OnSEGotoBtn()
{
	CString		cserrmsg ;		// Used to display error messages

	// Get the RC ID string and trim it.  Convert it to an integer to make sure
	// it is valid.

	UpdateData(TRUE) ;
	m_csGotoID.TrimLeft() ;
	m_csGotoID.TrimRight() ;
	int nrcid = atoi(m_csGotoID) ;
	if (nrcid <= 0) {
		cserrmsg.Format(IDS_BadGotoRCID, m_csGotoID) ;
		AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	// Now that we know what RC ID the user wants, try to find and select it.

	FindSelRCIDEntry(nrcid, true) ;
}


/******************************************************************************

  CStringEditorView::FindSelRCIDEntry

  Find and select the list control row that contains the requested RC ID.
  Return true if the entry was found.  Otherwise, display an error message if
  berror = true and return false.

******************************************************************************/

bool CStringEditorView::FindSelRCIDEntry(int nrcid, bool berror)
{
	CString		cserrmsg ;		// Used to display error messages

	// Look for an item with the specified RC ID.  Complain and return if it
	// is not found.

	LV_FINDINFO lvfi ;
	lvfi.flags = LVFI_STRING ;
	TCHAR acbuf[16] ;
	lvfi.psz = _itoa(nrcid, acbuf, 10) ;
	int nitem = m_cflstStringData.FindItem(&lvfi) ;
	if (nitem == -1) {
		if (berror) {
			cserrmsg.Format(IDS_NoGotoRCID, acbuf) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
		} 
		return false ;
	} ;

	// Select the row containing the specified RC ID and deselect any other
	// selected rows.

	m_cflstStringData.SingleSelect(nitem) ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CStringEditorView::OnSESearchBtn

  Find and select the list control row that contains the requested search
  string.  The search begins with the row after the first selected row and
  will wrap around to the beginning of the table if needed and stop at the
  first selected row.  Of course, it only happens that way if it doesn't
  find a matching field first.  The fields (including the RC ID field) in
  each row are checked from left to right.  A case insensitive search is
  performed.  The search string must be contained within a field string.
  IE, "abc", "abcde", and "bc" will all match the search string "bc".

******************************************************************************/

void CStringEditorView::OnSESearchBtn()
{
	CString			cserrmsg ;	// Used to display error messages

	// Get the search string.  Complain if it is empty.

	UpdateData(TRUE) ;
	if (m_csSearchString == _T("")) {
		AfxMessageBox(IDS_BadSearchString, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	CWaitCursor	cwc ;

	// Get the currently selected row number and the number of rows in the
	// table.

	int ncurrentrow = m_cflstStringData.GetNextItem(-1, LVNI_SELECTED) ;
	int numrows = m_cflstStringData.GetItemCount() ;

	// Make an uppercased copy of the search string.

	CString cssrchstr(m_csSearchString) ;
	cssrchstr.MakeUpper() ;

	// Search for the string in the part of the table starting after the
	// current row and ending at the end of the table.  If a match is found,
	// select the row and return.

	if (SearchHelper(cssrchstr, ncurrentrow + 1, numrows))
		return ;

	// Search for the string in the part of the table starting at the first
	// row and ending at the first selected row.  If a match is found, select
	// the row and return.

	if (SearchHelper(cssrchstr, 0, ncurrentrow + 1))
		return ;

	// Tell the user that a match was not found.

	cserrmsg.Format(IDS_NoSearchString, m_csSearchString) ;
	AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
}


/******************************************************************************

  CStringEditorView::SearchHelper

  Search the specified rows for one that contains a field that contains the
  search string.  See OnSESearchBtn() for more details.

******************************************************************************/

bool CStringEditorView::SearchHelper(CString cssrchstr, int nfirstrow,
									 int numrows)
{
	CStringArray	csafields ; // Used to hold fields in a row
	bool			bfound = false ;	// True iff a match is found

	// Search the specified rows.

	for (int nrow = nfirstrow ; nrow < numrows ; nrow++) {
		m_cflstStringData.GetRowData(nrow, csafields) ;

		// Check each field in the current row for a match.

		for (int nfld = 0 ; nfld < m_cflstStringData.GetNumColumns() ; nfld++) {
			csafields[nfld].MakeUpper() ;
			if (csafields[nfld].Find(cssrchstr) >= 0) {
				bfound = true ;
				break ;
			} ;
		} ;
		
		// Select the row and return success if a match was found.

		if (bfound) {
			m_cflstStringData.SingleSelect(nrow) ;
			return true ;
		} ;
	} ;

	// No match was found so...

	return false ;
}


/******************************************************************************

  CStringEditorView::OnInitialUpdate

  Resize the frame to better fit the controls in it.  Then load the list
  control with the RC IDs and strings for this project.

******************************************************************************/

void CStringEditorView::OnInitialUpdate()
{
    CRect	crtxt ;				// Coordinates of first label
	CRect	crbtnfrm ;			// Coordinates of goto button and frame

	CFormView::OnInitialUpdate() ;
	CWaitCursor cwc ;

	// Get the dimensions of the first label

	HWND	hlblhandle ;		
	GetDlgItem(IDC_SELabel1, &hlblhandle) ;
	::GetWindowRect(hlblhandle, crtxt) ;
	crtxt.NormalizeRect() ;
	

	// Get the dimensions of the Goto button and then combine them with the
	// dimensions of the label to get the dimensions for the form.

	m_cbGoto.GetWindowRect(crbtnfrm) ;
	crbtnfrm.top = crtxt.top ;
	crbtnfrm.right = crtxt.right ;

	// Make sure the frame is big enough for these 2 controls, everything in
	// between, plus a little bit more.

	crbtnfrm.right += 32 ;
	crbtnfrm.bottom += 32 ;
    GetParentFrame()->CalcWindowRect(crbtnfrm) ;
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crbtnfrm.Width(), crbtnfrm.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE) ;

	// Make a copy of the string table information for two reasons.  First,
	// CFullEditListCtrl takes data in a different format.  Second, the string
	// table can't be changed until the user says ok.  The local variables can
	// be updated when needed.  Begin by sizing the local arrays.

	CStringTable* pcst = ((CStringEditorDoc*) GetDocument())->GetRCData() ;
	m_uStrCount	= pcst->Count() ;
	m_csaStrings.SetSize(m_uStrCount) ;
	m_cuiaRCIDs.SetSize(m_uStrCount) ;

	// Copy the string table if it has a nonzero length.

	CString	cstmp ;
	if (m_uStrCount > 0) {
		WORD	wkey ;
		for (unsigned u = 0 ; u < m_uStrCount ; u++) {
			pcst->Details(u, wkey, cstmp) ;
			m_cuiaRCIDs[u] = (unsigned) wkey ;
			m_csaStrings[u] = cstmp ;
		} ;
	} ;

	// Now, initialize the list control by telling it we want full row select
	// and the number of rows and columns needed.

	m_cflstStringData.InitControl(LVS_EX_FULLROWSELECT, m_uStrCount, 2) ;

	// Put the RC IDs into the list control's first column.

	cstmp.LoadString(IDS_StrEditRCIDColLab) ;
	m_cflstStringData.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 20, true, true,
									 COLDATTYPE_INT, (CObArray*) &m_cuiaRCIDs) ;

	// Put the strings into the list control's second column.

	cstmp.LoadString(IDS_StrEditStringColLab) ;
	m_cflstStringData.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -36, true,
									 true, COLDATTYPE_STRING,
									 (CObArray*) &m_csaStrings) ;

	m_cflstStringData.SetFocus() ;	// The list control gets the focus
}


/******************************************************************************

  CStringEditorView::OnActivateView

  If the editor has been invoked from the GPD Editor (or wherever) and there
  is a string entry that should be selected based on its RC ID, do it.

******************************************************************************/

void CStringEditorView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
	CFormView::OnActivateView(bActivate, pActivateView, pDeactiveView) ;

	// Do nothing if the view is not being activated.  Skip the first
	// activate too because the view hasn't been displayed yet.  This
	// is a problem when there is an invalid RC ID.

	if (!bActivate || pActivateView != this || m_bFirstActivate) {
		m_bFirstActivate = false ;
		return ;
	} ;

	// Do nothing if the strings node pointer hasn't been set yet.

	CStringEditorDoc* pcsed = (CStringEditorDoc*) GetDocument() ;
	CStringsNode* pcsn = pcsed->GetStrNode() ;
	if (pcsn == NULL) {		// raid 3176

		m_csLabel1.LoadString(IDS_StrEditNoEdit);
		m_csLabel2 = _T(" ");  
		UpdateData(FALSE); 
		
		m_cflstStringData.EnableWindow(FALSE);
		int rcid;
		CWinApp *cwa = AfxGetApp();
		rcid = cwa->GetProfileInt(_T("StrEditDoc"),_T("StrEditDoc"),1);
		if ( -1 != rcid )	{
			cwa->WriteProfileInt(_T("StrEditDoc"),_T("StrEditDoc"), -1);
			FindSelRCIDEntry(rcid,true);
		}
		return ;
	}
	// Select the entry containing the specified RC ID if the RC ID is valid.
	// Otherwise, just select row 0.

	int nrcid = pcsn->GetFirstSelRCID() ;
	if (nrcid != -1) {
		((CStringEditorDoc*) GetDocument())->GetStrNode()->SetFirstSelRCID(-1) ;
		FindSelRCIDEntry(nrcid, true) ;
	} ;
}


/******************************************************************************

  CStringEditorView::OnDestroy

  When the view is being destroyed, called the parent string node and tell it
  to delete the corresponding document class and clear its pointer to the
  document class.

******************************************************************************/

void CStringEditorView::OnDestroy()
{
	CFormView::OnDestroy();
	
	if (((CStringEditorDoc*) GetDocument())->GetStrNode())
        ((CStringEditorDoc*) GetDocument())->GetStrNode()->OnEditorDestroyed() ;
}


/******************************************************************************

  CStringEditorView::SaveStringTable

  Update this project's string table if needed and (optionally) the user
  requests it.

  If the user wants to save the table (optional) and the table is valid, save
  it and return true.  If the table hasn't changed or the user doesn't want to
  save the table, return true.  Otherwise, return false.

******************************************************************************/

bool CStringEditorView::SaveStringTable(CStringEditorDoc* pcsed, bool bprompt)
{
	// Make sure the new table contents are sorted in ascending order by RC ID.

	m_cflstStringData.SortControl(0) ;
	if (!m_cflstStringData.GetColSortOrder(0))
		m_cflstStringData.SortControl(0) ;

	// Get the string table data out of the list control and into the member
	// variables.  Then get a pointer to the project's string table.

	m_cflstStringData.GetColumnData((CObArray*) &m_cuiaRCIDs, 0) ;
	m_cflstStringData.GetColumnData((CObArray*) &m_csaStrings, 1) ;
	CStringTable* pcst = ((CStringEditorDoc*) GetDocument())->GetRCData() ;

	// Check the table/array lengths and the individual items to see if
	// anything has changed.

	bool		bchanged = false ;
	CString		cstmp ;
	WORD		wkey ;
	unsigned	unumitems = (unsigned)m_cuiaRCIDs.GetSize() ;
	if (pcst->Count() != unumitems)
		bchanged = true ;
	else {
		for (unsigned u = 0 ; u < unumitems ; u++) {
			pcst->Details(u, wkey, cstmp) ;
			if ((unsigned) wkey != m_cuiaRCIDs[u] || cstmp != m_csaStrings[u]) {
				bchanged = true ;
				break ;
			} ;
		} ;
	} ;

	// Return true if nothing is saved because nothing has changed.

	if (!bchanged)
		return true ;

	// If requested,  ask the user if the changes should be saved.  Return
	// true if he says no.

	CProjectRecord* pcpr = pcsed->GetOwner() ;
	if (bprompt) {
		cstmp.Format(IDS_SaveStrTabPrompt, pcpr->DriverName()) ;
		if (AfxMessageBox(cstmp, MB_ICONQUESTION + MB_YESNO) == IDNO)
			return true ;
	} ;

	// Check to see if there are any invalid or duplicate RC IDs or if there
	// are any missing strings.  If any are found, complain, select the
	// offending row, and return false since nothing is saved.

	for (unsigned u = 0 ; u < unumitems ; u++) {
		if (((int) m_cuiaRCIDs[u]) <= 0) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_InvalidRCID) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
		if (m_cuiaRCIDs[u] >= 10000 && m_cuiaRCIDs[u] <= 20000) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_ReservedRCIDUsed) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
		if (u > 0 && m_cuiaRCIDs[u] == m_cuiaRCIDs[u - 1]) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_DuplicateRCID) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
		if (m_csaStrings[u].GetLength() == 0) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_EmptyStringInStrTab) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
	} ;

	// The new data is valid and should be saved so copy it into the project's
	// string table.

	pcst->Reset() ;
	for (u = 0 ; u < unumitems ; u++)
		pcst->Map((WORD) m_cuiaRCIDs[u], m_csaStrings[u]) ;

	// Mark the project's RC/MDW file data as being dirty and then return true
	// since the data was saved.

	pcpr->SetRCModifiedFlag(TRUE) ;
	pcpr->SetModifiedFlag(TRUE) ;
	return true ;
}


/******************************************************************************

  CStringEditorView::PreTranslateMessage

  Check for a return key being released while the Goto box or the Search box
  has the focus.  Treat the key like the Goto button or the Search button
  being pressed when this is detected.

******************************************************************************/

BOOL CStringEditorView::PreTranslateMessage(MSG* pMsg)
{
	// When the return key was just released...

	if (pMsg->message == WM_KEYUP && pMsg->wParam == VK_RETURN) {
		// ...and the Goto box has the focus, perform a goto operation.

		if (GetFocus() == &m_ceGotoBox)
			OnSEGotoBtn() ;		

		// ...or the Search box has the focus, perform a search operation.

		else if (GetFocus() == &m_ceSearchBox)
			OnSESearchBtn() ;
	} ;
		
	// Always process the key normally, too.  I think this is ok in this case.

	return CFormView::PreTranslateMessage(pMsg) ;
}


LRESULT CStringEditorView::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_STRINGEDITOR) ;
	return TRUE ;
}



/******************************************************************************

  CStringEditorView::OnFileSave()

  FILE SAVE message handler.

  just call SaveSTringTable(document, bprompt);
//raid 27250
******************************************************************************/


void CStringEditorView::OnFileSave() 
{
	
	CStringEditorDoc* pcsed = (CStringEditorDoc* )GetDocument();

	if( !pcsed ->GetOwner() ) {	// R 3176
		CString cstmp;
		cstmp.LoadString(IDS_StrEditNoSave) ;
		AfxMessageBox(cstmp);
		return;
	}

	SaveStringTable(pcsed,0);

}








/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc

IMPLEMENT_DYNCREATE(CStringEditorDoc, CDocument)

CStringEditorDoc::CStringEditorDoc()
{
	// Raid 3176
	
	CDriverResources* pcdr = new CDriverResources();
	CStringArray csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5;
	CStringTable cst, cstFonts, cstTemp2;
	CString csrcfile;
	m_pcstRCData = new CStringTable;
	
	// seek rc file
	CWinApp *cwa = AfxGetApp();
	csrcfile = cwa->GetProfileString(_T("StrEditDoc"),_T("StrEditDocS") );

	pcdr->LoadRCFile(csrcfile, csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5,
				*m_pcstRCData, cstFonts, cstTemp2,Win2000);
	
	m_pcsnStrNode = NULL;
	m_pcprOwner = NULL;
	
	
}


/******************************************************************************

  CStringEditorDoc::CStringEditorDoc

  This is the only form of the constructor that should be called.  It will save
  pointers to the project's string node, document class, and RC file string
  table.  Blow if any of these pointers is NULL.

******************************************************************************/

CStringEditorDoc::CStringEditorDoc(CStringsNode* pcsn, CProjectRecord* pcpr,
								   CStringTable* pcst)
{
	VERIFY(m_pcsnStrNode = pcsn) ;
	VERIFY(m_pcprOwner = pcpr) ;
	VERIFY(m_pcstRCData = pcst) ;

	//m_pcsnStrNode = NULL ;
}


BOOL CStringEditorDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}


CStringEditorDoc::~CStringEditorDoc()
{
}


BEGIN_MESSAGE_MAP(CStringEditorDoc, CDocument)
	//{{AFX_MSG_MAP(CStringEditorDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc diagnostics

#ifdef _DEBUG
void CStringEditorDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CStringEditorDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc serialization

void CStringEditorDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	
	}
	else
	{
	
	}
}


/******************************************************************************

  CStringEditorDoc::CanCloseFrame

  Save the new string table if this is needed, the user says ok, and the new
  table's contents are valid.  Don't let the frame close if the user wants
  the table saved but it couldn't be saved because the table is invalid.

******************************************************************************/

BOOL CStringEditorDoc::CanCloseFrame(CFrameWnd* pFrame)
{
	if (!SaveStringTable())
		return FALSE ;
	
	return CDocument::CanCloseFrame(pFrame);
}


/******************************************************************************

  CStringEditorDoc::SaveStringTable

  Save the new string table if this is needed, the user says ok, and the new
  table's contents are valid.  Don't let the frame close if the user wants
  the table saved but it couldn't be saved because the table is invalid.  This
  is done by returning false.  True is returned in all other circumstances.

******************************************************************************/

bool CStringEditorDoc::SaveStringTable()
{
	// Begin looking for a view pointer.  This should work but if it doesn't,
	// just say all is ok by returning true.

	POSITION pos = GetFirstViewPosition() ;
	if (pos == NULL)
		return true ;
	
	// Finish getting the view pointer and call the view to save the string
	// table when needed.  Return whatever the view function returns.
	
	CStringEditorView* pcsev = (CStringEditorView*) GetNextView(pos) ;
	return (pcsev->SaveStringTable(this, true)) ;
}


/******************************************************************************

  CStringEditorDoc::SaveModified

  Make sure that the MFC's default saving mechanism never kicks in by always
  clearing the document's modified flag.

******************************************************************************/

BOOL CStringEditorDoc::SaveModified()
{
	SetModifiedFlag(FALSE) ;
	
	return CDocument::SaveModified();
}






BOOL CStringEditorDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	if (!CDocument::OnOpenDocument(lpszPathName))
		return FALSE;
	

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stredit.h ===
#if !defined(AFX_STREDIT_H__50303D0C_054D_11D2_AB62_00C04FA30E4A__INCLUDED_)
#define AFX_STREDIT_H__50303D0C_054D_11D2_AB62_00C04FA30E4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// StrEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStringEditorView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif


class CFullEditListCtrl ;
class CStringEditorDoc ;


class CStringEditorView : public CFormView
{
protected:
	CStringEditorView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CStringEditorView)

// Form Data
public:
	//{{AFX_DATA(CStringEditorView)
	enum { IDD = IDD_StringEditor };
	CEdit	m_ceSearchBox;
	CEdit	m_ceGotoBox;
	CButton	m_cbGoto;
	CFullEditListCtrl	m_cflstStringData;
	CString	m_csGotoID;
	CString	m_csSearchString;
	CString	m_csLabel1;
	CString	m_csLabel2;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:
	bool SaveStringTable(CStringEditorDoc* pcsed, bool bprompt) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStringEditorView)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CStringEditorView();
	bool SearchHelper(CString cssrchstr, int nfirstrow, int numrows) ;
	bool FindSelRCIDEntry(int nrcid, bool berror) ;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CStringEditorView)
	afx_msg void OnSEGotoBtn();
	afx_msg void OnSESearchBtn();
	afx_msg void OnDestroy();
	afx_msg void OnFileSave();
	//}}AFX_MSG
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

protected:			
	CStringArray	m_csaStrings ;	// String table's strings
	CUIntArray		m_cuiaRCIDs ;	// String table's RC IDs
	unsigned		m_uStrCount ;	// Number of strings
	bool			m_bFirstActivate ;	// True iff first time activated
};

/////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc document

class CStringEditorDoc : public CDocument
{
protected:
	CStringEditorDoc() ;		// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CStringEditorDoc)

	CStringsNode*	m_pcsnStrNode ;	// Used to reference editor's string node
	CProjectRecord* m_pcprOwner ;	// Used to reference editor's project document
	CStringTable*	m_pcstRCData ;	// Used to reference project's string table

// Attributes
public:
	// The next 3 functions are used to reference the pointers passed to this
	// class's constructor.

	CStringsNode*	GetStrNode() { return m_pcsnStrNode ; }	
	CProjectRecord* GetOwner()   { return m_pcprOwner ; }
	CStringTable*	GetRCData()  { return m_pcstRCData ; }
	
// Operations
public:
    CStringEditorDoc(CStringsNode* pcsn, CProjectRecord* pcpr, 
					 CStringTable* pcst) ;
	bool SaveStringTable() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStringEditorDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStringEditorDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CStringEditorDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STREDIT_H__50303D0C_054D_11D2_AB62_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\writefnt.cpp ===
/******************************* MODULE HEADER *******************************
 * writefnt.c
 *      Function to take a FI_DATA_HEADER structure and write the data to
 *      the passed in file handle as a font record.  This layout is used
 *      in both minidrivers and the font installer font file.
 *
 * Copyright (C) 1992   Microsoft Corporation.
 *
 *****************************************************************************/

#include        "StdAfx.H"
#include        "fontinst.h"

/************************* Function Header *********************************
 * bWrite
 *      Writes data out to a file handle.  Returns TRUE on success.
 *      Functions as a nop if the size request is zero.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  17:38 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      # 1
 *
 ****************************************************************************/

static BOOL    bWrite(HANDLE hFile, PVOID pvBuf, int iSize ) {
    /*
     *   Simplify the ugly NT interface.  Returns TRUE if the WriteFile
     * call returns TRUE and the number of bytes written equals the
     * number of bytes desired.
     */

    
    BOOL   bRet;
    DWORD  dwSize;              /* Filled in by WriteFile */


    bRet = TRUE;

    if( iSize > 0 &&
        (!WriteFile( hFile, pvBuf, (DWORD)iSize, &dwSize, NULL ) ||
         (DWORD)iSize != dwSize) )
             bRet = FALSE;              /* Too bad */


    return  bRet;
}

/******************************* Function Header *****************************
 * iWriteFDH
 *      Write the FI_DATA_HEADER data out to our file.  We do the conversion
 *      from addresses to offsets, and write out any data we find.
 *
 * RETURNS:
 *      The number of bytes actually written; -1 for error, 0 for nothing.
 *
 * HISTORY:
 *  16:58 on Thu 05 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      Based on an experimental version first used in font installer.
 *
 *  17:11 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 *****************************************************************************/

int iWriteFDH(HANDLE hFile, FI_DATA *pFD) {
    /*
     *   Decide how many bytes will be written out.  We presume that the
     * file pointer is located at the correct position when we are called.
     */

    int  iSize;         /* Evaluate output size */


    FI_DATA_HEADER   fdh;       /* Header written to file */




    if  (!pFD)
        return  0;      /* Perhaps only deleting?  */

    memset( &fdh, 0, sizeof( fdh ) );           /* Zero for convenience */

    /*
     *  Set the miscellaneous flags etc.
     */

    fdh.cjThis = sizeof( fdh );

    fdh.fCaps = pFD->fCaps;
    fdh.wFontType= pFD->wFontType; /* Device Font Type */

    fdh.wXRes = pFD->wXRes;
    fdh.wYRes = pFD->wYRes;

    fdh.sYAdjust = pFD->sYAdjust;
    fdh.sYMoved = pFD->sYMoved;

    fdh.u.sCTTid = (short)pFD->dsCTT.cBytes;

    fdh.dwSelBits = pFD->dwSelBits;

    fdh.wPrivateData = pFD->wPrivateData;


    iSize = sizeof( fdh );              /* Our header already */
    fdh.dwIFIMet = iSize;               /* Location of IFIMETRICS */

    iSize += pFD->dsIFIMet.cBytes;              /* Bytes in struct */

    /*
     *   And there may be a width table too!  The pFD values are zero if none.
     */

    if( pFD->dsWidthTab.cBytes )
    {
        fdh.dwWidthTab = iSize;

        iSize += pFD->dsWidthTab.cBytes;
    }

    /*
     *  Finally are the select/deselect strings.
     */

    if( pFD->dsSel.cBytes )
    {
        fdh.dwCDSelect = iSize;
        iSize += pFD->dsSel.cBytes;
    }

    if( pFD->dsDesel.cBytes )
    {
        fdh.dwCDDeselect = iSize;
        iSize += pFD->dsDesel.cBytes;
    }

    /*
     *   There may also be some sort of identification string.
     */

    if( pFD->dsIdentStr.cBytes )
    {
        fdh.dwIdentStr = iSize;
        iSize += pFD->dsIdentStr.cBytes;
    }

    if( pFD->dsETM.cBytes )
    {
        fdh.dwETM = iSize;
        iSize += pFD->dsETM.cBytes;
    }


    /*
     *   Sizes all figured out,  so write the data!
     */

    if( !bWrite( hFile, &fdh, sizeof( fdh ) ) ||
        !bWrite( hFile, pFD->dsIFIMet.pvData, pFD->dsIFIMet.cBytes ) ||
        !bWrite( hFile, pFD->dsWidthTab.pvData, pFD->dsWidthTab.cBytes ) ||
        !bWrite( hFile, pFD->dsSel.pvData, pFD->dsSel.cBytes ) ||
        !bWrite( hFile, pFD->dsDesel.pvData, pFD->dsDesel.cBytes ) ||
        !bWrite( hFile, pFD->dsIdentStr.pvData, pFD->dsIdentStr.cBytes ) ||
        !bWrite( hFile, pFD->dsETM.pvData, pFD->dsETM.cBytes ) )
                return   -1;


    return  iSize;                      /* Number of bytes written */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\utility.cpp ===
/******************************************************************************

  Header File:  Utility Classes.CPP

  These classes are generally useful classes which can be used for a variety
  of purposes.  I created this separate file for quicker reuse later, and also
  to avoid having to include some very specific header file just to get these
  general-purpose classes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "Utility Classes.H"
#else
#include    "Utility.H"
#endif

/******************************************************************************

  CMapWordToDWord class

  This class uses CMapWordToPtr to do its dirty work.  When the need arises, I
  will make it serializable

******************************************************************************/

BOOL    CMapWordToDWord::Lookup(WORD wKey, DWORD& dwItem) const {
    union {
        void*   pv;
        DWORD   dw;
    };

    if  (!CMapWordToPtr::Lookup(wKey, pv))
        return  FALSE;

    dwItem = dw;
    return  TRUE;
}

/******************************************************************************

  CMapWordToDWord::GetNextAssoc

  This is the map iteration method.  We call the same method on the bas class,
  and update the DWORD parameter if the underlying method is successful.

******************************************************************************/

void    CMapWordToDWord::GetNextAssoc(POSITION& pos, WORD& wKey, 
                                      DWORD& dwItem) const {
    union {
        void*   pv;
        DWORD   dw;
    };

    CMapWordToPtr::GetNextAssoc(pos, wKey, pv);

    dwItem = dw;
}

/******************************************************************************

  CMapWordToDWord::Operator[]

  This implements an l-value only operator usable for adding new associations or
  updating existing ones.

******************************************************************************/

DWORD&  CMapWordToDWord::operator[](WORD wKey) {
    return  (DWORD&) CMapWordToPtr::operator[](wKey);
}

/******************************************************************************

  CSafeObArray class implementation

  This provides a "Safe" CObArray class which can't leak!

******************************************************************************/

IMPLEMENT_SERIAL(CSafeObArray, CObject, 0);

/******************************************************************************

  CSafeObArray::~CSafeObArray

  The class destructor will delete the object foreach non-NULL pointer in the 
  array.

******************************************************************************/

CSafeObArray::~CSafeObArray() {
    for (unsigned u = 0; u < GetSize(); u++)
        if  (m_coa[u])
            delete  m_coa[u];
}

/******************************************************************************

  CSafeObArray::RemoveAll

  Almost the same as the destructor, isn't it?

******************************************************************************/

void    CSafeObArray::RemoveAll() {
    for (unsigned u = 0; u < GetSize(); u++)
        if  (m_coa[u])
            delete  m_coa[u];

    m_coa.RemoveAll();
}

/******************************************************************************

  CSafeObArray::RemoveAt

  This removes one element from the array- after deleting it, of course.

******************************************************************************/

void    CSafeObArray::RemoveAt(int i) {
    if  (m_coa[i])
        delete  m_coa[i];
    m_coa.RemoveAt(i);
}


/******************************************************************************

  CSafeObArray::Copy

  Copy the contents of one array to another.

******************************************************************************/

void    CSafeObArray::Copy(CSafeObArray& csoa)
{
	m_coa.Copy(*(csoa.GetCOA())) ;
}


/******************************************************************************

  CSafeObArray::Serialize

  I call the CObject serializer to maintain the proper typ einformation, then
  let the CObArray serialize itself.

******************************************************************************/

void    CSafeObArray::Serialize(CArchive& car) {
    if  (car.IsLoading())
        RemoveAll();

    CObject::Serialize(car);
    m_coa.Serialize(car);
}

/******************************************************************************

  CSafeMapWordToOb implementation

  Making the workd safe for maps.

******************************************************************************/

IMPLEMENT_SERIAL(CSafeMapWordToOb, CObject, 0)

/******************************************************************************

  CSafeMapWordToOb::~CSafeMapWordToOb

  The class destructor must ensure the underlying objects are deleted.

******************************************************************************/

CSafeMapWordToOb::~CSafeMapWordToOb() {
    WORD    wKey;
    CObject *pco;

    for (POSITION pos = m_cmw2o.GetStartPosition(); pos; ) {
        m_cmw2o.GetNextAssoc(pos, wKey, pco);
        if  (pco)
            delete  pco;
    }
}

/******************************************************************************

  CSafeMapWordToOb::operator[]

  The problem here is that this is used only to put elements in the map-
  therefore, I intercept the call and delete any existing item.  This could 
  cause problems if the same pointer is re-inserted into the map, but for now,
  I'll take my chances.

******************************************************************************/

CObject*&   CSafeMapWordToOb::operator[](WORD wKey) {
    CObject*&   pco = m_cmw2o.operator[](wKey);

    if  (pco)   delete  pco;
    return  pco;
}

/******************************************************************************

  CSafeMapWordToOb::RemoveKey

  Pretty Obvious- if there was an object there, remove it.

******************************************************************************/

BOOL    CSafeMapWordToOb::RemoveKey(WORD wKey) {

    CObject *pco;

    if  (!m_cmw2o.Lookup(wKey, pco))
        return  FALSE;

    if  (pco)
        delete  pco;

    return m_cmw2o.RemoveKey(wKey);
}

/******************************************************************************

  CSafeMapWordToOb::RemoveAll

  Again, this is pretty obvious- destroy anything that lives!

******************************************************************************/

void    CSafeMapWordToOb::RemoveAll() {
    WORD    wKey;
    CObject *pco;

    for (POSITION pos = m_cmw2o.GetStartPosition(); pos; ) {
        GetNextAssoc(pos, wKey, pco);
        if  (pco)
            delete  pco;
    }

    m_cmw2o.RemoveAll();
}

/******************************************************************************

  CSafeMapWordToOb::Serialize

  First, I depopulate the map if it is being loaded.  Then I call the CObject
  serializer to handle run-time typing checks, and then serialize the
  underlying map.

******************************************************************************/

void    CSafeMapWordToOb::Serialize(CArchive& car) {
    if  (car.IsLoading())
        RemoveAll();

    CObject::Serialize(car);
    m_cmw2o.Serialize(car);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\tips.cpp ===
/******************************************************************************

  Source File:  Tip of the Day.CPP

  This implements the Tip of the Day dialog.  It was originally generated by
  Component Gallery, but I expect to be changing it shortly.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.
  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "Resource.H"
// CG: This file added by 'Tip of the Day' component.

#include    <WinReg.H>
#include    <Sys\Stat.H>
#include    <Sys\Types.H>
#include	"tips.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTipOfTheDay dialog

#define MAX_BUFLEN 1000

static const TCHAR szSection[] = _T("Tip");
static const TCHAR szIntFilePos[] = _T("FilePos");
static const TCHAR szTimeStamp[] = _T("TimeStamp");
static const TCHAR szIntStartup[] = _T("StartUp");

CTipOfTheDay::CTipOfTheDay(CWnd* pParent /*=NULL*/)
	: CDialog(IDD_TIP, pParent) {

	//{{AFX_DATA_INIT(CTipOfTheDay)
	m_bStartup = TRUE;
	//}}AFX_DATA_INIT

	// We need to find out what the startup and file position parameters are
	// If startup does not exist, we assume that the Tips on startup is checked TRUE.
	CWinApp* pApp = AfxGetApp();
	m_bStartup = !pApp->GetProfileInt(szSection, szIntStartup, 0);
	UINT iFilePos = pApp->GetProfileInt(szSection, szIntFilePos, 0);
	
	//raid 104081 :: tips.txt file is in the same directory with help file
	CString csTipFile = pApp->m_pszHelpFilePath;
	csTipFile = csTipFile.Left(csTipFile.ReverseFind(_T('\\')));
	csTipFile = csTipFile + _T("\\tips.txt");
	
	// Now try to open the tips file
	m_pStream = fopen(csTipFile, "r");
	if (m_pStream == NULL) 
	{
		m_strTip.LoadString(CG_IDS_FILE_ABSENT);
		return;
	} 

	// If the timestamp in the INI file is different from the timestamp of
	// the tips file, then we know that the tips file has been modified
	// Reset the file position to 0 and write the latest timestamp to the
	// ini file
	struct _stat buf;
	_fstat(_fileno(m_pStream), &buf);
	CString strCurrentTime = ctime(&buf.st_ctime);
	strCurrentTime.TrimRight();
	CString strStoredTime = 
		pApp->GetProfileString(szSection, szTimeStamp, NULL);
	if (strCurrentTime != strStoredTime) 
	{
		iFilePos = 0;
		pApp->WriteProfileString(szSection, szTimeStamp, strCurrentTime);
	}

	if (fseek(m_pStream, iFilePos, SEEK_SET) != 0) 
	{
		AfxMessageBox(CG_IDP_FILE_CORRUPT);
	}
	else 
	{
		GetNextTipString(m_strTip);
	}
}

CTipOfTheDay::~CTipOfTheDay() {
	// This destructor is executed whether the user had pressed the escape key
	// or clicked on the close button. If the user had pressed the escape key,
	// it is still required to update the filepos in the ini file with the 
	// latest position so that we don't repeat the tips! 
    
	// But make sure the tips file existed in the first place....
	if (m_pStream != NULL) {
		CWinApp* pApp = AfxGetApp();
		pApp->WriteProfileInt(szSection, szIntFilePos, ftell(m_pStream));
		fclose(m_pStream);
	}
}
        
void CTipOfTheDay::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTipOfTheDay)
	DDX_Check(pDX, IDC_STARTUP, m_bStartup);
	DDX_Text(pDX, IDC_TIPSTRING, m_strTip);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTipOfTheDay, CDialog)
	//{{AFX_MSG_MAP(CTipOfTheDay)
	ON_BN_CLICKED(IDC_NEXTTIP, OnNextTip)
	ON_WM_CTLCOLOR()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTipOfTheDay message handlers

void CTipOfTheDay::OnNextTip() {
	GetNextTipString(m_strTip);
	UpdateData(FALSE);
}

void CTipOfTheDay::GetNextTipString(CString& strNext) {
	LPTSTR lpsz = strNext.GetBuffer(MAX_BUFLEN);

	// This routine identifies the next string that needs to be
	// read from the tips file
	BOOL bStop = FALSE;
	while (!bStop) 	{
		if (_fgetts(lpsz, MAX_BUFLEN, m_pStream) == NULL) {
			// We have either reached EOF or enocuntered some problem
			// In both cases reset the pointer to the beginning of the file
			// This behavior is same as VC++ Tips file
			if (fseek(m_pStream, 0, SEEK_SET) != 0) 
				AfxMessageBox(CG_IDP_FILE_CORRUPT);
		} 
		else { // raid 200630
			if (*lpsz != ' ' && *lpsz != '\t' && 
				*lpsz != '\n' && *lpsz != ';' && *lpsz != '*') {
				// There should be no space at the beginning of the tip
				// This behavior is same as VC++ Tips file
				// Comment lines are ignored and they start with a semicolon
				bStop = TRUE;
			}
		}
	}
	strNext.ReleaseBuffer();
}

HBRUSH CTipOfTheDay::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) {
	if (pWnd->GetDlgCtrlID() == IDC_TIPSTRING)
		return (HBRUSH)GetStockObject(WHITE_BRUSH);

	return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

void CTipOfTheDay::OnOK() {
	CDialog::OnOK();
	
    // Update the startup information stored in the INI file
	CWinApp* pApp = AfxGetApp();
	pApp->WriteProfileInt(szSection, szIntStartup, !m_bStartup);
}

BOOL CTipOfTheDay::OnInitDialog() {
	CDialog::OnInitDialog();

	// If Tips file does not exist then disable NextTip
	if (m_pStream == NULL)
		GetDlgItem(IDC_NEXTTIP)->EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CTipOfTheDay::OnPaint() {
	CPaintDC dc(this); // device context for painting

	// Get paint area for the big static control
	CWnd* pStatic = GetDlgItem(IDC_BULB);
	CRect rect;
	pStatic->GetWindowRect(&rect);
	ScreenToClient(&rect);

	// Paint the background white.
	CBrush brush;
	brush.CreateStockObject(WHITE_BRUSH);
	dc.FillRect(rect, &brush);

	// Load bitmap and get dimensions of the bitmap
	CBitmap bmp;
	bmp.LoadBitmap(IDB_LIGHTBULB);
	BITMAP bmpInfo;
	bmp.GetBitmap(&bmpInfo);

	// Draw bitmap in top corner and validate only top portion of window
	CDC dcTmp;
	dcTmp.CreateCompatibleDC(&dc);
	dcTmp.SelectObject(&bmp);
	rect.bottom = bmpInfo.bmHeight + rect.top;
	dc.BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), 
		&dcTmp, 0, 0, SRCCOPY);

	// Draw out "Did you know..." message next to the bitmap
	CString strMessage;
	strMessage.LoadString(CG_IDS_DIDYOUKNOW);
	rect.left += bmpInfo.bmWidth;
	dc.DrawText(strMessage, rect, DT_VCENTER | DT_SINGLELINE);

	// Do not call CDialog::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\utility.h ===
/******************************************************************************

  Header File:  Utility Classes.H

  These classes are generally useful classes which can be used for a variety
  of purposes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(UTILITY_CLASSES)
#define UTILITY_CLASSES

/******************************************************************************

  CMapWordToDWord class

  This class uses CMapWordToPtr to do its dirty work.  When the need arises, I
  will make it serializable

******************************************************************************/

class CMapWordToDWord : public CMapWordToPtr {

public:
    unsigned    Count() const { return (unsigned)CMapWordToPtr::GetCount(); }
    BOOL        Lookup(WORD wKey, DWORD& dwItem) const;

    void        GetNextAssoc(POSITION& pos, WORD& wKey, DWORD& dwItem) const;

    DWORD&      operator[](WORD wKey);
};

/******************************************************************************

  CSafeObArray- This class, unlike CObArray, will delete any objects removed
  from the array.  Otherwise it is identical.

******************************************************************************/

class CSafeObArray : public CObject {
    CObArray    m_coa;
    DECLARE_SERIAL(CSafeObArray)
public:
    CSafeObArray() {}
    ~CSafeObArray();

    //  Attributes
    unsigned    GetSize() const { return (unsigned) m_coa.GetSize(); }
    CObject*    operator[](unsigned u) const { return m_coa.GetAt(u); }

    //Operations
    int     Add(CObject *pco) { return((int)m_coa.Add(pco)) ; }
    void    InsertAt(unsigned uid, CObject *pco) { m_coa.InsertAt(uid, pco); }
    void    RemoveAll();
    void    RemoveAt(int i);
    void    SetAt(int i, CObject *pco) { m_coa.SetAt(i, pco) ; }
    void    Copy(CSafeObArray& csoa) ;
	void	SetSize(int nsize, int ngrow = -1) { m_coa.SetSize(nsize, ngrow) ; }
	CObArray* GetCOA() { return &m_coa ; }
    virtual void    Serialize(CArchive& car);
};

/******************************************************************************

  CSafeMapWordToOb

  This class encapsulates a CMapWordToOb object, but it does what the
  documentation says the CMapWordToOb does, and definitely oes not do- delete
  the underling objects when the map no longer references them!

******************************************************************************/

class CSafeMapWordToOb : public CObject {
    CMapWordToOb    m_cmw2o;
    DECLARE_SERIAL(CSafeMapWordToOb)

public:
    CSafeMapWordToOb() {}
    ~CSafeMapWordToOb();

    //  Attributes

    unsigned    GetCount() const { return (unsigned) m_cmw2o.GetCount(); }

    BOOL    Lookup(WORD wKey, CObject*& pco) const {
        return m_cmw2o.Lookup(wKey, pco);
    }

    POSITION    GetStartPosition() const { return m_cmw2o.GetStartPosition(); }

    void        GetNextAssoc(POSITION& pos, WORD& wKey, CObject*& pco) const {
        m_cmw2o.GetNextAssoc(pos, wKey, pco);
    }

    //  Operations

    CObject*&   operator[](WORD wKey);
    BOOL        RemoveKey(WORD wKey);
    void        RemoveAll();

    virtual void    Serialize(CArchive& car);
};


class CStringTable : public CObject {

    DECLARE_SERIAL(CStringTable)

    CString             m_csEmpty;
    CUIntArray          m_cuaKeys;
    CStringArray        m_csaValues;
	CUIntArray			m_cuaRefFlags ;	// Referenced flags used in WS checking

public:

    CStringTable() {}

    //  Attributes
    unsigned    Count() const { return (unsigned)m_cuaKeys.GetSize(); }

    CString operator[](WORD wKey) const;

    void    Details(unsigned u, WORD &wKey, CString &csValue);

    //  Operations

    void    Map(WORD wKey, CString csValue);

    void    Remove(WORD wKey);

    void    Reset() {
        m_csaValues.RemoveAll();
        m_cuaKeys.RemoveAll();
    }

    virtual void    Serialize(CArchive& car);

	// Reference flag management routines

	bool GetRefFlag(unsigned u) { return (m_cuaRefFlags[u] != 0) ; }
	void SetRefFlag(unsigned u) { m_cuaRefFlags[u] = (unsigned) true ; }
	void ClearRefFlag(unsigned u) { m_cuaRefFlags[u] = (unsigned) false ; }
	void InitRefFlags() ;
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\wscheck.h ===
#if !defined(AFX_WSCHECK_H__82E3CFBA_D2DB_11D1_AB19_00C04FA30E4A__INCLUDED_)
#define AFX_WSCHECK_H__82E3CFBA_D2DB_11D1_AB19_00C04FA30E4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WSCheck.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWSCheckView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif


class CDriverResources ;		// Forward declarations
class CProjectNode ;


class CWSCheckView : public CFormView
{
protected:
	CWSCheckView() ;           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWSCheckView)

// Form Data
public:
	//{{AFX_DATA(CWSCheckView)
	enum { IDD = IDD_WSCheck };
	CListBox	m_lstErrWrn;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

	void PostWSCMsg(CString& csmsg, CProjectNode* ppn) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWSCheckView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWSCheckView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWSCheckView)
	afx_msg void OnDblclkErrWrnLstBox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc document

class CWSCheckDoc : public CDocument
{
protected:
	CWSCheckDoc() ;			// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWSCheckDoc)

	CDriverResources*	m_pcdrOwner ;	// Ptr to document's creator

// Attributes
public:

// Operations
public:
	CWSCheckDoc(CDriverResources* pcdr) ;

	void PostWSCMsg(CString& csmsg, CProjectNode* ppn) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWSCheckDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWSCheckDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CWSCheckDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WSCHECK_H__82E3CFBA_D2DB_11D1_AB19_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\wscheck.cpp ===
// WSCheck.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"
#include "WSCheck.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWSCheckView

IMPLEMENT_DYNCREATE(CWSCheckView, CFormView)

CWSCheckView::CWSCheckView()
	: CFormView(CWSCheckView::IDD)
{
	//{{AFX_DATA_INIT(CWSCheckView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWSCheckView::~CWSCheckView()
{
}

void CWSCheckView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWSCheckView)
	DDX_Control(pDX, IDC_ErrWrnLstBox, m_lstErrWrn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWSCheckView, CFormView)
	//{{AFX_MSG_MAP(CWSCheckView)
	ON_LBN_DBLCLK(IDC_ErrWrnLstBox, OnDblclkErrWrnLstBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWSCheckView diagnostics

#ifdef _DEBUG
void CWSCheckView::AssertValid() const
{
	CFormView::AssertValid();
}

void CWSCheckView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CWSCheckView message handlers


void CWSCheckView::OnDblclkErrWrnLstBox() 
{
	// TODO: Add your control notification handler code here
	
}


/******************************************************************************

  CWSCheckView::OnInitialUpdate

  Resize the frame to better fit the visible controls in it.

******************************************************************************/

void CWSCheckView::OnInitialUpdate() 
{
    CRect	crtxt ;				// Coordinates of list box label
	CRect	crlbfrm ;			// Coordinates of list box and frame

	CFormView::OnInitialUpdate() ;

	// Get the dimensions of the list box label

	HWND	hlblhandle ;		
	GetDlgItem(IDC_WSCLabel, &hlblhandle) ;
	::GetWindowRect(hlblhandle, crtxt) ;
	crtxt.NormalizeRect() ;

	// Get the dimensions of the list box and then add the height of the label
	// to those dimensions.

	m_lstErrWrn.GetWindowRect(crlbfrm) ;
	crlbfrm.bottom += crtxt.Height() ;

	// Make sure the frame is big enough for these 2 controls plus a little bit
	// more.

	crlbfrm.right += 40 ;
	crlbfrm.bottom += 40 ;
    GetParentFrame()->CalcWindowRect(crlbfrm) ;
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crlbfrm.Width(), crlbfrm.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE) ;

	/*
	CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);								// Position property sheet within the
																			//  child frame
    GetParentFrame()->CalcWindowRect(crPropertySheet);
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(), 
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	*/
}


/******************************************************************************

  CWSCheckView::PostWSCMsg

  Add an error or warning message along with its associated Project Node 
  pointer to the list box.

******************************************************************************/

void CWSCheckView::PostWSCMsg(CString& csmsg, CProjectNode* ppn)
{	
	int n = m_lstErrWrn.AddString(csmsg) ;
	m_lstErrWrn.SetItemData(n, (DWORD) PtrToUlong(ppn)) ;
}


/******************************************************************************

  CWSCheckView::DeleteAllMessages

  Delete all of the messages in the list box.

******************************************************************************/

void CWSCheckView::DeleteAllMessages(void)
{
	m_lstErrWrn.ResetContent() ;
}


/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc

IMPLEMENT_DYNCREATE(CWSCheckDoc, CDocument)

CWSCheckDoc::CWSCheckDoc()
{
}


/******************************************************************************

  CWSCheckDoc::CWSCheckDoc

  This is the only form of the constructor that should be called.  It will save
  a pointer the class that created it.

******************************************************************************/

CWSCheckDoc::CWSCheckDoc(CDriverResources* pcdr) 
{
	m_pcdrOwner = pcdr ;
}


CWSCheckDoc::~CWSCheckDoc()
{
}


BOOL CWSCheckDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}


/******************************************************************************

  CWSCheckDoc::PostWSCMsg

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CWSCheckDoc::PostWSCMsg(CString& csmsg, CProjectNode* ppn)
{	
	POSITION pos = GetFirstViewPosition() ;   
	if (pos != NULL) {
		CWSCheckView* pwscv = (CWSCheckView *) GetNextView(pos) ;      
		pwscv->PostWSCMsg(csmsg, ppn) ;
		pwscv->UpdateWindow() ;
	} ;  
}


/******************************************************************************

  CWSCheckDoc::DeleteAllMessages

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CWSCheckDoc::DeleteAllMessages(void)
{
	POSITION pos = GetFirstViewPosition() ;   
	if (pos != NULL) {
		CWSCheckView* pwscv = (CWSCheckView *) GetNextView(pos) ;      
		pwscv->DeleteAllMessages() ;
		pwscv->UpdateWindow() ;
	} ;  
}


BEGIN_MESSAGE_MAP(CWSCheckDoc, CDocument)
	//{{AFX_MSG_MAP(CWSCheckDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc diagnostics

#ifdef _DEBUG
void CWSCheckDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWSCheckDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc serialization

void CWSCheckDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkgttufm\mkgttufm.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    mkgttufm.c

Abstract:

    Create CTT and PFM assignment table

Environment:

    Windows NT PostScript driver

Revision History:

    01/17/97 -eigos-
    Created it.

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE       256

#define OUTPUT_VERBOSE      0x01
#define OUTPUT_ALL_MODELS   0x02
#define OUTPUT_CREATE_BATCH 0x04

#define RCFILE_FONTFILES    0
#define RCFILE_CTTFILES     1
#define RCFILE_GPCFILE      2
#define RCFILE_STRINGTABLE  3

#define WRITEDATATOFILE(pData) \
    if (!WriteFile(hOutFile, \
                   (pData), \
                   (strlen(pData)), \
                   &dwWrittenSize, \
                   NULL)) \
    { \
        fprintf(stderr, gcstrWriteFileError ); \
        ERR(("WriteFile")); \
    }

//
// Error messages
//

#define ERROR_INVALID_ARGUMENT      -1
#define ERROR_OPENFILE              -2
#define ERROR_HEAP_CREATE           -3
#define ERROR_RC_PARSING            -4
#define ERROR_HEAP_ALLOC            -5
#define ERROR_MODEL_DATA            -6
#define ERROR_CREATE_RES_FONT_LIST  -7
#define ERROR_CREATE_CART_FONT_LIST -8
#define ERROR_WRITEFILE             -9

#define ARGUMENT_ERR_MSG_LINE        6

static BYTE *gcstrArgumentError[ARGUMENT_ERR_MSG_LINE] = {
"Usage: mkgttufm [-vac] [Model Name ID] <RC file name> [Batch file name]\n",
"                -v Verbose\n",
"                -a Create all Model's data.\n",
"                   [ModelName ID] is not necessary.\n",
"                -c Create font resource conversion batch file.\n",
"                   [Batch file name] is necessary\n"};


static BYTE gcstrOpenFileFailure[]   = "Cannot open file \"%ws\".\n";
static BYTE gcstrHeapCreateFailure[] = "Failed to Create Heap.\a";
static BYTE gcstrRCParsing[]         = "Failed to process RC file.\n";
static BYTE gcstrHeapAlloc[]         = "Failed to allocate memory.\n";
static BYTE gcstrModelData[]         = "Model data is corrupted.\n";
static BYTE gcstrCreateResFontList[] = "Model:%d creation: BCreateResFontList failed.\n";
static BYTE gcstrCreateCartFontList[]= "Model:%d creation: BCreateCartFontList failed.\n";
static BYTE gcstrWriteFileError[]    = "WriteFile failed\n";

//
// Globals
//

DWORD gdwOutputFlags;

static SHORT gResWordLen[4] = { 7,   // RCFILE_FONTFILES   = 0
                               11,   // RCFILE_CTTFILES    = 1
                                9,   // RCFILE_GPCFILE     = 2
                               11 }; // RCFILE_STRINGTABLE = 3

//
// data structure that returns to the caller of library.
//

typedef struct tagPFM_ID_LIST {
    SHORT sFontID;       // Font ID
    SHORT sCTTID;        // CTT ID
} PFM_ID_LIST, *PPFM_ID_LIST;

typedef struct tagMODEL_FONTLIST {
    SHORT  sID;           // Model data ID
    SHORT  sStringID;     // Model string ID
    SHORT  sDefaultCTT;   // Default CTT ID
    DWORD  dwNumOfResFont;
    PSHORT psResFontList; // Pointer from the top of this structure to font list
    DWORD  dwNumOfCart;   // Number of cont cartridge
    DWORD  dwCartList;    // Pointer from the top of this structure to cartridge
                          // list
} MODEL_FONTLIST, *PMODEL_FONTLIST;

typedef struct tagCART_FONTLIST {
    SHORT sID;           // Cartridge ID
    SHORT sStringID;     // Cartridge string ID
    DWORD dwNumCartFont;
    DWORD dwFontList;    // Offset from the top of this structure to font list 
} CART_FONTLIST, *PCART_FONTLIST;

//
// Internal use only
//

typedef struct tagFILE_NAME{
    WORD  wNext;
    SHORT sID;
    WCHAR wchFileName[1];
} FILE_NAME, *PFILE_NAME;

//
// Internal function prototype
//

BOOL
BArgCheck(
    IN  INT,
    IN  CHAR **,
    OUT PDWORD,
    OUT PWSTR,
    OUT PWSTR);

BOOL
BProcessRCFile(
    IN  HANDLE,
    IN  PBYTE,
    IN  PWSTR,
    IN  DWORD,
    IN  PDWORD,
    OUT PFILE_NAME*,
    IN  PDWORD,
    OUT PFILE_NAME*);

BOOL
BCreateResFontList(
    IN  HANDLE,
    IN  PDH,
    IN  PMODELDATA,
    IN  DWORD,
    IN  DWORD,
    OUT PSHORT,
    IN  PSHORT);

BOOL
BCreateCartFontList(
    IN  HANDLE,
    IN  PDH,
    IN  PMODELDATA,
    IN  DWORD,
    IN  PDWORD,
    IN  PCART_FONTLIST,
    OUT PCART_FONTLIST*);


PBYTE
PGetNextToken(
    IN  PSTR,
    OUT PSHORT);

PBYTE
PGetNextResWord(
    IN  PSTR,
    OUT PSHORT);


DWORD
DwMergeFonts(
    IN  DWORD,
    IN  PSHORT,
    IN  PSHORT,
    OUT PSHORT);


SHORT
SGetCTTID(
    IN DWORD,
    IN SHORT,
    IN PPFM_ID_LIST);

SHORT
SCountFontNum(
    IN PDH,
    IN WORD,
    IN WORD);
SHORT
SAdditionalFont(
    IN SHORT,
    IN PSHORT);


VOID
VPrintFontList(
    IN PMODEL_FONTLIST,
    IN DWORD,
    IN PPFM_ID_LIST);

VOID
VCreateBatchFile(
    IN PMODEL_FONTLIST,
    IN DWORD,
    IN PPFM_ID_LIST,
    IN PFILE_NAME,
    IN DWORD,
    IN PFILE_NAME,
    IN HANDLE);

PCWSTR
PcwstrGetFileName(
    SHORT,
    PFILE_NAME,
    DWORD);

DWORD
DwCTTID2CodePage(
    SHORT sCTTID);

//
//
// Functions
//
//

int  __cdecl
main(
    IN int     argc,
    IN char  **argv)
/*++

Routine Description:

    main

Arguments:

    argc - Number of parameters in the following
    argv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{
    PFILE_NAME      pPFMFileNameListSrc, pPFMFileNameList;
    PFILE_NAME      pCTTFileNameListSrc, pCTTFileNameList;
    PFILE_NAME      pStringIDListSrc,    pStringIDList;

    PPFM_ID_LIST    pPFM_ID, pPFM_ID_Src;

    PMODEL_FONTLIST pModelFontList, pModelFontListSrc;
    MODEL_FONTLIST  ModelFontList;

    PCART_FONTLIST  pCartFontList, pCartFontListSrc;
    PCART_FONTLIST  pCartList;

    PDH             pGPCData;
    PMODELDATA      pModelData;
    PGPCFONTCART    pFontCart;
    FONTIN          FontIn;
    EXTTEXTMETRIC   Etm;

    HFILEMAP hRCFile, hPFMFile, hGPCFile;

    HANDLE hHeap, hOutFile;

    DWORD dwRCFileSize, dwGPCFileSize, dwPFMFileSize;

    DWORD dwTotalNumOfPFM, dwTotalNumOfCTT;
    DWORD dwFontCartTotalSize;
    DWORD dwModelID;
    DWORD dwOffset;
    DWORD dwNFonts;
    DWORD dwI;

    PSHORT psTempList1, psTempList2;

    SHORT sModelDataSize;
    SHORT sModelDataCount;
    SHORT sNumOfFontCart;
    SHORT sFontCartSize;
    SHORT sOrientOffset;
    SHORT sI, sJ;

    WCHAR awchRCFile[FILENAME_SIZE];
    WCHAR awchGPCFile[FILENAME_SIZE];
    WCHAR awchOutFile[FILENAME_SIZE];

    PBYTE pRCFile;
    PBYTE pPFM;

    BOOL  bFlipFlop;

    dwModelID = 0;

    //
    // Argument check 
    // mkgttufm [-va] [Model Name ID] <RC file name> <Output file name>
    //      -v Verbose
    //      -a Create all Model's data. In this case ModelName is not necessary.
    //

    if (!BArgCheck(argc,
                   argv,
                   &dwModelID,
                   awchRCFile,
                   awchOutFile))
    {
        for (sI = 0; sI < ARGUMENT_ERR_MSG_LINE; sI++)
        {
            fprintf( stderr, gcstrArgumentError[sI]);
        }
        return ERROR_INVALID_ARGUMENT;
    }

    //
    // Open *.RC file.
    //
    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("***********************************************************\n");
        printf("FILE: %ws\n", awchRCFile);
        printf("***********************************************************\n");
    }

    if (!(hRCFile = MapFileIntoMemory( (PTSTR)awchRCFile,
                                       (PVOID)&pRCFile,
                                       (PDWORD)&dwRCFileSize )))
    {
        fprintf( stderr, gcstrOpenFileFailure, awchRCFile);
        return ERROR_OPENFILE;
    }


    //
    // Heap Creation
    //

    if (!(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 0x10000, 0x10000)))
    {
        fprintf( stderr, gcstrHeapCreateFailure);
        ERR(("CreateHeap failed: %d\n", GetLastError()));
        return ERROR_HEAP_CREATE;
    }

    //
    // Parse RC file and get GPC file name, PFM file name and CTT file name
    //

    if (!BProcessRCFile(hHeap,
                        pRCFile,
                        awchGPCFile,
                        FILENAME_SIZE,
                        &dwTotalNumOfPFM,
                        &pPFMFileNameListSrc,
                        &dwTotalNumOfCTT,
                        &pCTTFileNameListSrc))
    {
        HeapDestroy(hHeap);
        fprintf(stderr, gcstrRCParsing);
        return ERROR_RC_PARSING;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("***********************************************************\n");
        printf("All CTT data in this minidriver\n");
        printf("***********************************************************\n");
        pCTTFileNameList = pCTTFileNameListSrc;
        for (dwI = 0; dwI < dwTotalNumOfCTT; dwI ++)
        {
            printf("CTT[%3d], File=%ws\n",
                               pCTTFileNameList->sID,
                               pCTTFileNameList->wchFileName);
            (PBYTE)pCTTFileNameList += pCTTFileNameList->wNext;
        }
    }

    //
    // Open all PFM files and get CTT ID
    //

    if (!(pPFM_ID_Src = HeapAlloc(hHeap,
                                  0,
                                  dwTotalNumOfPFM * sizeof(PFM_ID_LIST))))
    {
        HeapDestroy(hHeap);
        fprintf(stderr, gcstrHeapAlloc);
        ERR(("HeapAlloc failed: %d\n", GetLastError()));
        return ERROR_HEAP_ALLOC;
    }

    pPFM_ID = pPFM_ID_Src;

    pPFMFileNameList = pPFMFileNameListSrc;

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("***********************************************************\n");
        printf("All fonts in this minidriver\n");
        printf("***********************************************************\n");
    }

    for (dwI =  0; dwI < dwTotalNumOfPFM; dwI ++)
    {
        if (!(hPFMFile = MapFileIntoMemory(
                                       (PTSTR)pPFMFileNameList->wchFileName,
                                       (PVOID)&pPFM,
                                       (PDWORD)&dwPFMFileSize)))
        {
            fprintf(stderr,
                    gcstrOpenFileFailure,
                    (PTSTR)pPFMFileNameList->wchFileName);
            HeapDestroy(hHeap);
            return ERROR_OPENFILE;
        }

        FontIn.pETM  = &Etm;
        FontIn.pBase = pPFM;
        BAlignPFM(&FontIn);

        //
        // Fill out PFM_ID
        //

        pPFM_ID->sFontID = pPFMFileNameList->sID;
        pPFM_ID->sCTTID  = FontIn.DI.sTransTab;

        if (gdwOutputFlags & OUTPUT_VERBOSE)
        {
            printf("Font[%3d]:sCTTID=%2d, File=%ws\n",
                                   pPFM_ID->sFontID,
                                   pPFM_ID->sCTTID,
                                   pPFMFileNameList->wchFileName);
        }

        pPFM_ID++;

        UnmapFileFromMemory(hPFMFile);

        (PBYTE)pPFMFileNameList += pPFMFileNameList->wNext;
    }

    //
    // Open GPC file
    //

    if (!(hGPCFile = MapFileIntoMemory((PTSTR)awchGPCFile,
                                       (PVOID)&pGPCData,
                                       &dwGPCFileSize)))
    {
        fprintf( stderr, gcstrOpenFileFailure, awchGPCFile);
        return ERROR_OPENFILE;
    }

    //
    // Get Model data
    //

    sModelDataCount = pGPCData->rghe[HE_MODELDATA].sCount;
    sModelDataSize  = pGPCData->rghe[HE_MODELDATA].sLength;
    pModelData      = (PMODELDATA)((PBYTE)pGPCData +
                      pGPCData->rghe[HE_MODELDATA].sOffset);

    if (dwModelID > (DWORD)sModelDataCount)
    {
        HeapDestroy(hHeap);
        fprintf(stderr, gcstrModelData);
        return ERROR_MODEL_DATA;
    }

    //
    // Get Font cartridge information
    //

    sNumOfFontCart = pGPCData->rghe[HE_FONTCART].sCount;
    sFontCartSize  = pGPCData->rghe[HE_FONTCART].sLength;


    pFontCart      = (PGPCFONTCART)((PBYTE)pGPCData +
                                 pGPCData->rghe[HE_FONTCART].sOffset);

    //
    // Count memory size
    //

    dwFontCartTotalSize = (DWORD)sNumOfFontCart * sizeof(CART_FONTLIST);


    for (sI = 0; sI < sNumOfFontCart; sI ++)
    {

        dwFontCartTotalSize += (SCountFontNum(pGPCData,
                                       pFontCart->orgwPFM[FC_ORGW_PORT],
                                       pFontCart->orgwPFM[FC_ORGW_LAND])
                                + 1) * sizeof(SHORT);

        (PBYTE)pFontCart += sFontCartSize;
    }

    pCartFontListSrc =
    pCartFontList = HeapAlloc(hHeap,
                              0,
                              dwFontCartTotalSize);

    if (!pCartFontList)
    {
        HeapDestroy(hHeap);
        fprintf(stderr, gcstrHeapAlloc);
        ERR(("HeapAlloc failed: %d\n", GetLastError()));
        return ERROR_HEAP_ALLOC;
    }

    pFontCart = (PGPCFONTCART)((PBYTE)pGPCData +
                                pGPCData->rghe[HE_FONTCART].sOffset);

    dwOffset  = sNumOfFontCart * sizeof(CART_FONTLIST); 

    psTempList1 = HeapAlloc(hHeap,
                            HEAP_ZERO_MEMORY,
                            2 * sizeof(SHORT) * dwTotalNumOfPFM);

    if (!psTempList1)
    {
        ERR(("HeapAlloc failed: %d\n", GetLastError()));
        return FALSE;
    }

    psTempList2 = psTempList1 + dwTotalNumOfPFM;

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("***********************************************************\n");
        printf("Font Cartridge info\n");
        printf("Number of Font Cartridge = %d\n", sNumOfFontCart);
    }

    for (sI = 1; sI <= sNumOfFontCart; sI ++)
    {

        if (pModelData->fGeneral & MD_ROTATE_FONT_ABLE)
        {
            sOrientOffset = 1;
            bFlipFlop = TRUE;
        }
        else
        {
            sOrientOffset = 0;
            bFlipFlop = FALSE;
        }

        *psTempList1 = *psTempList2 = 0;

        pCartFontList->sID        = sI;
        pCartFontList->sStringID  = pFontCart->sCartNameID;
        pCartFontList->dwFontList = dwOffset;

        if (gdwOutputFlags & OUTPUT_VERBOSE)
        {
            printf("***********************************************************\n");
            printf("Font cartridge ID        = %d\n", sI);
            printf("Font cartridge string ID = %d\n", pFontCart->sCartNameID);
        }

        for (sJ = 0; sJ <= sOrientOffset; sJ++)
        {
            dwNFonts = DwMergeFonts(dwTotalNumOfPFM,
                                    bFlipFlop ? psTempList1 : psTempList2,
                                    (PSHORT) ((PBYTE)pGPCData +
                                         pGPCData->loHeap +
                                         pFontCart->orgwPFM[FC_ORGW_PORT + sJ]),
                                    bFlipFlop ? psTempList2 : psTempList1);

           bFlipFlop = !bFlipFlop;

           if (dwNFonts == dwTotalNumOfPFM)
           {
               break;
           }
        }

        if (gdwOutputFlags & OUTPUT_VERBOSE)
        {
            printf("Number of font           = %d\n", dwNFonts);
            printf("-----------------------------------------------------------\n");
            for (dwI = 0; dwI < dwNFonts; dwI ++)
            {
                printf("FontID[%2d] = %d\n", dwI + 1, psTempList1[dwI]);
            }
        }

        pCartFontList->dwNumCartFont = dwNFonts;

        CopyMemory((PBYTE)pCartFontList + dwOffset,
                   psTempList1,
                   (dwNFonts + 1) * sizeof(SHORT));

        dwOffset += sizeof(SHORT) * (dwNFonts + 1) - sizeof(CART_FONTLIST);
        (PBYTE)pFontCart += sFontCartSize;
        pCartFontList ++;
    }

    //
    // Get CTT ID
    //

    if (!(gdwOutputFlags & OUTPUT_ALL_MODELS))
    {
        (PBYTE)pModelData += sModelDataSize * dwModelID;
        pModelFontListSrc = 
        pModelFontList    = &ModelFontList;

        pModelFontList->sID           = (SHORT)dwModelID;
        pModelFontList->sStringID     = pModelData->sIDS;
        pModelFontList->sDefaultCTT   = pModelData->sDefaultCTT;

        pModelFontList->dwNumOfResFont = SCountFontNum(pGPCData,
                                      pModelData->rgoi[MD_OI_PORT_FONTS],
                                      pModelData->rgoi[MD_OI_LAND_FONTS]);

        pModelFontList->psResFontList = HeapAlloc(
                          hHeap,
                          HEAP_ZERO_MEMORY,
                          (pModelFontList->dwNumOfResFont + 1) * sizeof(SHORT));

        if (pModelFontList->psResFontList == NULL)
        {
            HeapDestroy(hHeap);
            fprintf(stderr, gcstrHeapAlloc);
            ERR(("HeapAlloc failed: %d\n", GetLastError()));
            return FALSE;
        }

        if (!BCreateResFontList(hHeap,
                                pGPCData,
                                pModelData,
                                dwTotalNumOfPFM,
                                pModelFontList->dwNumOfResFont,
                                pModelFontList->psResFontList,
                                psTempList1))
        {
            HeapDestroy(hHeap);
            fprintf(stderr, gcstrCreateResFontList, dwModelID);
            return ERROR_CREATE_RES_FONT_LIST;
        }

        if (!BCreateCartFontList(hHeap,
                                pGPCData,
                                pModelData,
                                dwTotalNumOfPFM,
                                &(pModelFontList->dwNumOfCart),
                                pCartFontListSrc,
                                (PCART_FONTLIST*)&(pModelFontList->dwCartList)))
        {
            HeapDestroy(hHeap);
            fprintf(stderr, gcstrCreateCartFontList, dwModelID);
            return ERROR_CREATE_CART_FONT_LIST;
        }
    }
    else
    {
        pModelFontListSrc = 
        pModelFontList    = HeapAlloc(hHeap,
                                 0,
                                 sModelDataCount * sizeof(MODEL_FONTLIST));

        dwOffset = sModelDataCount * sizeof(MODEL_FONTLIST);

        for (sI = 0; sI < sModelDataCount; sI ++, pModelFontList++)
        {
            pModelFontList->sID           = sI;
            pModelFontList->sStringID     = pModelData->sIDS;
            pModelFontList->sDefaultCTT   = pModelData->sDefaultCTT;

            pModelFontList->dwNumOfResFont = SCountFontNum(pGPCData,
                                          pModelData->rgoi[MD_OI_PORT_FONTS],
                                          pModelData->rgoi[MD_OI_LAND_FONTS]);

            pModelFontList->psResFontList = HeapAlloc(
                              hHeap,
                              HEAP_ZERO_MEMORY,
                              (pModelFontList->dwNumOfResFont + 1) *
                              sizeof(SHORT));

            if (pModelFontList->psResFontList == NULL)
            {
                HeapDestroy(hHeap);
                fprintf(stderr, gcstrHeapAlloc);
                ERR(("HeapAlloc failed: %d\n", GetLastError()));
                return FALSE;
            }
            if (!BCreateResFontList(hHeap,
                                   pGPCData,
                                   pModelData,
                                   dwTotalNumOfPFM,
                                   pModelFontList->dwNumOfResFont,
                                   pModelFontList->psResFontList,
                                   psTempList1))
            {
                HeapDestroy(hHeap);
                fprintf(stderr, gcstrCreateResFontList, sI);
                return ERROR_CREATE_RES_FONT_LIST;
            }

            if (!BCreateCartFontList(
                              hHeap,
                              pGPCData,
                              pModelData,
                              dwTotalNumOfPFM,
                              &(pModelFontList->dwNumOfCart),
                              pCartFontListSrc,
                              (PCART_FONTLIST*)&(pModelFontList->dwCartList)))
            {
                HeapDestroy(hHeap);
                fprintf(stderr, gcstrCreateCartFontList, sI);
                return ERROR_CREATE_CART_FONT_LIST;
            }

            dwOffset += pModelFontList->dwNumOfResFont * sizeof(SHORT);
            (PBYTE)pModelData +=  sModelDataSize;
        }
    }

    UnmapFileFromMemory(hGPCFile);


    if (!(gdwOutputFlags & OUTPUT_ALL_MODELS))
    {
        VPrintFontList(pModelFontListSrc, dwTotalNumOfPFM, pPFM_ID_Src);

        if (gdwOutputFlags & OUTPUT_CREATE_BATCH)
        {
            hOutFile = CreateFile(awchOutFile,
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  0);

            VCreateBatchFile(pModelFontListSrc,
                             dwTotalNumOfPFM,
                             pPFM_ID_Src,
                             pPFMFileNameListSrc,
                             dwTotalNumOfCTT,
                             pCTTFileNameListSrc,
                             hOutFile);

            CloseHandle(hOutFile);
        }
    }
    else
    {
        pModelFontList = pModelFontListSrc;

        if (gdwOutputFlags & OUTPUT_CREATE_BATCH)
        {
            hOutFile = CreateFile(awchOutFile,
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  0);
        }

        for (sI = 0; sI < sModelDataCount; sI ++, pModelFontList++)
        {
            VPrintFontList(pModelFontListSrc, dwTotalNumOfPFM, pPFM_ID_Src);

            if (gdwOutputFlags & OUTPUT_CREATE_BATCH)
            {
                VCreateBatchFile(pModelFontList,
                                 dwTotalNumOfPFM,
                                 pPFM_ID_Src,
                                 pPFMFileNameListSrc,
                                 dwTotalNumOfCTT,
                                 pCTTFileNameListSrc,
                                 hOutFile);
            }
        }

        if (gdwOutputFlags & OUTPUT_CREATE_BATCH)
        {
            CloseHandle(hOutFile);
        }
    }

    HeapDestroy(hHeap);

    return 0;
}

//
//
// Helper functions.
//
//

BOOL
BProcessRCFile(
    IN  HANDLE   hHeap,
    IN  PBYTE    pCurrent,
    IN  PWSTR    pwstrGPCFileName,
    IN  DWORD    dwcwGPCFileName,
    IN  PDWORD   pdwTotalNumOfPFM,
    OUT PFILE_NAME *ppPFMFileName,
    IN  PDWORD   pdwTotalNumOfCTT,
    OUT PFILE_NAME *ppCTTFileName)
{
    PFILE_NAME pPFMFileNameListSrc, pPFMFileNameList;
    PFILE_NAME pCTTFileNameListSrc, pCTTFileNameList;

    DWORD dwPFMListSize, dwCTTListSize;
    DWORD dwcwWrittenSize, dwRestOfBuffer;
    SHORT sResType;
    SHORT sLen, sID;
    CHAR  strID[8];
    CHAR  strFileName[32];
    PBYTE pTemp;

    if (!pCurrent)
    {
        return FALSE;
    }

    //
    // Initial size
    //

    *pdwTotalNumOfPFM = 0;
    *pdwTotalNumOfCTT = 0;

    dwPFMListSize = 400 * (sizeof(FILE_NAME) + 32 * sizeof(WCHAR));

    pPFMFileNameListSrc = 
    pPFMFileNameList    = (PFILE_NAME)HeapAlloc(hHeap,
                                                0,
                                                dwPFMListSize);

    dwCTTListSize = 10 * (sizeof(FILE_NAME) + 32 * sizeof(WCHAR));
    pCTTFileNameListSrc = 
    pCTTFileNameList    = (PFILE_NAME)HeapAlloc(hHeap,
                                                0,
                                                dwCTTListSize);

    while (pCurrent = PGetNextResWord(pCurrent, &sResType))
    {
        if (sResType == RCFILE_STRINGTABLE)
        {
            //
            // skip "STRINGTABLE"
            //

            pCurrent = pCurrent + gResWordLen[sResType];

            while (pCurrent = PGetNextToken(pCurrent, (PSHORT)&sLen))
            {
                if (sLen == 5 && !strncmp(pCurrent, "BEGIN", sLen))
                {
                    break;
                }
                else
                {
                    pCurrent += sLen;
                }
            }

            if (!pCurrent)
            {
                return FALSE;
            }

            //
            // skip over "BEGIN"
            //

            pCurrent += sLen;

            //
            // process until reaching "END"
            //

            while (pCurrent = PGetNextToken(pCurrent, (PSHORT)&sLen))
            {
                if (sLen == 3 && !strncmp(pCurrent, "END", sLen))
                {
                    break;
                }
                else
                {
                    pCurrent += sLen;
                }
            }

            if (!pCurrent)
            {
                return FALSE;
            }

            //
            // skip over "END", which
            // is the only way we can
            // be here...
            //

            pCurrent += 3;

        }
        else
        {
            //
            // We have a file name...
            //

            //
            // remember the position past the reserved word.
            //

            pTemp = pCurrent + gResWordLen[sResType];

            //
            // move back to the last token.
            //

            pCurrent -= 1;
            while (isspace(*pCurrent))
            {
                pCurrent--;
            }

            //
            // move to the head of the token before the reserved word
            // We expect an id # before RC_TABLES, RC_FONT or RC_TRANSTAB.
            // First, initialize the sLength count of the id.
            //

            sLen = 0;

            while (!isspace(*pCurrent))
            {
                pCurrent--;
                sLen++;
            }

            pCurrent++;

            //
            // convert the id
            //

            ZeroMemory(strID, sizeof(strID));
            strncpy(strID, pCurrent, sLen);

            if (!(sID = atoi(strID)))
            {
                return FALSE;
            }

            //
            // Extract the associated file name.
            // But first, skip load and memory options.
            //

            while (pTemp = PGetNextToken(pTemp, (PSHORT)&sLen))
            {
                if ((sLen == 10 && !strncmp(pTemp, "LOADONCALL",  sLen)) ||
                    (sLen == 7  && !strncmp(pTemp, "PRELOAD",     sLen)) ||
                    (sLen == 8  && !strncmp(pTemp, "MOVEABLE",    sLen)) ||
                    (sLen == 11 && !strncmp(pTemp, "DISCARDABLE", sLen)) ||
                    (sLen == 5  && !strncmp(pTemp, "FIXED",       sLen))  )
                {
                    // continue skipping
                    pTemp += sLen;
                }
                else
                {
                    break;
                }
            }

            if (!pTemp)
            {
                return FALSE;
            }

            //
            // 'pTemp' points to the file
            //  name.  Copy to strFileName
            //

            memset(strFileName, 0, sizeof(strFileName));
            strncpy(strFileName, pTemp, sLen);
            strFileName[sLen] = 0;

            switch (sResType)
            {
            case RCFILE_GPCFILE:
                if (!(dwcwWrittenSize = MultiByteToWideChar(CP_ACP,
                                                            0,
                                                            strFileName,
                                                            sLen,
                                                            pwstrGPCFileName,
                                                            dwcwGPCFileName)))
                {
                    ERR(("MultiByteToWideChar failed: %d\n", GetLastError()));
                    VERBOSE(("String : %s\n", strFileName)); 
                    return FALSE;
                }

                pwstrGPCFileName[dwcwWrittenSize] = (WCHAR)NULL;
                break;

            case RCFILE_FONTFILES:
                dwRestOfBuffer = pPFMFileNameList - pPFMFileNameListSrc;
                dwRestOfBuffer = dwPFMListSize - dwRestOfBuffer;

                if (dwRestOfBuffer < 32 * sizeof(WCHAR))
                {
                    dwPFMListSize += 50 * (sizeof(DWORD) + 32 * sizeof(WCHAR));
                    HeapReAlloc(hHeap, 0, pPFMFileNameListSrc, dwPFMListSize);
                }

                if (!(dwcwWrittenSize = MultiByteToWideChar(
                                         CP_ACP,
                                         0,
                                         strFileName,
                                         sLen,
                                         pPFMFileNameList->wchFileName,
                                         dwRestOfBuffer)))
                {
                    ERR(("MultiByteToWideChar failed: %d\n", GetLastError()));
                    VERBOSE(("String : %s\n", strFileName)); 
                    return FALSE;
                }

                pPFMFileNameList->wchFileName[dwcwWrittenSize++] = (WCHAR)NULL;
                pPFMFileNameList->sID     = sID;
                pPFMFileNameList->wNext   = sizeof(FILE_NAME) +
                                            dwcwWrittenSize * sizeof(WCHAR);
                (PBYTE)pPFMFileNameList  += pPFMFileNameList->wNext;
                (*pdwTotalNumOfPFM)++;
                break;

            case RCFILE_CTTFILES:
                dwRestOfBuffer = pCTTFileNameList - pCTTFileNameListSrc;
                dwRestOfBuffer = dwCTTListSize - dwRestOfBuffer;

                if (dwRestOfBuffer < 32 * sizeof(WCHAR))
                {
                    dwCTTListSize += 50 * (sizeof(DWORD) + 32 * sizeof(WCHAR));
                    HeapReAlloc(hHeap, 0, pCTTFileNameListSrc, dwCTTListSize);
                }

                if (!(dwcwWrittenSize = MultiByteToWideChar(
                                         CP_ACP,
                                         0,
                                         strFileName,
                                         sLen,
                                         pCTTFileNameList->wchFileName,
                                         dwRestOfBuffer)))
                {
                    ERR(("MultiByteToWideChar failed: %d\n", GetLastError()));
                    VERBOSE(("String : %s\n", strFileName)); 
                    return FALSE;
                }

                pCTTFileNameList->wchFileName[dwcwWrittenSize++] = (WCHAR)NULL;
                pCTTFileNameList->sID     = sID;
                pCTTFileNameList->wNext   = sizeof(FILE_NAME) +
                                            dwcwWrittenSize * sizeof(WCHAR);
                (PBYTE)pCTTFileNameList  += pCTTFileNameList->wNext;
                (*pdwTotalNumOfCTT)++;
                break;
                break;
            }

            //
            // move the current buffer
            // pointer over the file name.
            //
            pCurrent = pTemp + sLen;

        }

        //
        // move pointers forward.
        // Skip space characters
        //

        while (isspace(*pCurrent))
        {
            pCurrent++;
        }

    } /* while */

    *ppPFMFileName = pPFMFileNameListSrc;
    *ppCTTFileName = pCTTFileNameListSrc;

    return TRUE;
}


PBYTE 
PGetNextToken(
    IN  PSTR    pBuf,
    OUT PSHORT  psLen)
/*++

Routine Description:

    Search for the next token in the buffer (null-terminated) and
    return the pointer to the first character in the token. Its
    Length is returned via pssLen. A token is a character string
    that is not inside a comment and does not contain any space
    characters (\x09, \x0A, \x0B, \x0C, \x0D and \x20). It can be
    at most 128 bytes long.

Arguments:

    pBuf - far ptr to null term str buffer
    psLen - nera ptr to where to write strsLen of token to

Return Value:

    ptr to first char in token

--*/
{
    SHORT sI;

    while (*pBuf)
    {
        //
        // skip space characters
        //

        while (isspace(*pBuf))
        {
            pBuf++;
        }

        //
        // get past comments
        //

        if (*pBuf == '/')
        {
            if (*(pBuf + 1) == '/')
            {
                //
                // single-line comment. Search until the end of the line.
                // It can be twice as fast if we write our own loops here.
                //

                pBuf = strstr(pBuf, "\x0D\x0A") + 2;
                continue;  // back to start of while
            }
            else if (*(pBuf + 1) == '*')
            {
                //
                // multi-line comment. Search for "*/".
                //

                pBuf = strstr(pBuf, "*/") + 2;
                continue; // back to start of while
            }
        }

        //
        // this is the beginning of a token
        //

        for (sI = 0; !isspace(pBuf[sI]) && pBuf[sI]!=0; sI++);

        *psLen = sI;

        if (pBuf)
        {
            return pBuf;
        }
    }

    *psLen = 0;
    return NULL;
}


PBYTE
PGetNextResWord(
    IN  PSTR    pBuf,
    OUT PSHORT  psResType)
/*++

Routine Description:

    Search for the next reserved word (RC_TABLES, RC_FONT, RC_TRANSTAB,
    or STRINGTABLE) in the buffer. Return the pointer to the first
    character in the reserved word. Its type is returned via a parameter.

    Note: strtok deliberately not used here since it inserts
          null terminators into the buffer.

    Note: This routine will assume PGetNextToken skips
          any reserved words that occur within a comment.
Arguments:

    pBuf -
    psResType - 

Return Value:

    ptr to next reserved word, NULL if none found

--*/
{
    SHORT sLen;

    while (pBuf = PGetNextToken(pBuf, (PSHORT)&sLen))
    {
        if (sLen == gResWordLen[RCFILE_FONTFILES] &&
            !strncmp(pBuf, "RC_FONT", sLen))
        {
            *psResType = RCFILE_FONTFILES;
            return pBuf;
        }
        else
        if (sLen == gResWordLen[RCFILE_GPCFILE] &&
            !strncmp(pBuf, "RC_TABLES", sLen))
        {
            *psResType = RCFILE_GPCFILE;
            return pBuf;
        }
        else
        if (sLen == gResWordLen[RCFILE_CTTFILES] &&
            !strncmp(pBuf, "RC_TRANSTAB", sLen))
        {
            *psResType = RCFILE_CTTFILES;
            return pBuf;
        }
        else
        if (sLen == gResWordLen[RCFILE_STRINGTABLE] &&
        !strncmp(pBuf, "STRINGTABLE", sLen))
        {
            *psResType = RCFILE_STRINGTABLE;
            return pBuf;
        }
        else
            // continue searching.
            pBuf += sLen;
    } // while

    *psResType = -1;

    return NULL;
}


DWORD
DwMergeFonts(
    IN  DWORD  dwTotalNumOfPFM,
    IN  PSHORT pBase,     // source 1
    IN  PSHORT pSrc,      // source 2
    OUT PSHORT pDest)     // result buffer. Can hold max dwTotalNumOfPFM entries
/*++

Routine Description:

    Merge two font id lists into one.

Arguments:

    pBase - an ordered list of font id's to be merged.
    lpSrc - an ordered list of font id's, but the first two id's
            represent a range of contiguous font id's
    lpDest - a buffer for the result, which is a
             a list of font id's just like the base list. The
             max limit is dwTotalNumOfPFM (not including terminating 0).

Return Value:

    the actual # of font id's in the result list.

--*/
{
    SHORT i;   // trace pBase list.
    SHORT j;   // trace pSrc list;
    SHORT k;   // trace destination buffer
    SHORT sID;

    k = 0;

    for (i = 0; pBase[i] != 0 && pBase[i] < pSrc[0] && k < (SHORT)dwTotalNumOfPFM; )
    {
        pDest[k++] = pBase[i++];
    }

    //
    // expand the range represented by pSrc[0]..pSrc[1]
    //

    if (pSrc[0] > 0)
    {
        for (sID = pSrc[0]; sID <= pSrc[1] && k < (SHORT)dwTotalNumOfPFM; sID++)
        {
            pDest[k++] = sID;
        }

        j = 2;

        //
        // skip repeated ones.
        //

        while (pBase[i] != 0 && pBase[i] <= pSrc[1])
        {
            i++;
        }
    }
    else
    {
        //
        // pSrc[] list is empty.
        //

        j = 0;
    }

    // merge the rest of the lists
    while (pBase[i] != 0 && pSrc[j] != 0 && k < (SHORT)dwTotalNumOfPFM)
    {
        if (pBase[i] < pSrc[j])
            pDest[k++] = pBase[i++];
        else if (pBase[i] > pSrc[j])
            pDest[k++] = pSrc[j++];
        else
        {
            // pBase[i] == pSrc[j] case
            pDest[k++] = pBase[i++];
            j++;
        }
    }

    if (pBase[i] == 0)
    {
        while (pSrc[j] != 0 &&
               pSrc[j] <= (SHORT)dwTotalNumOfPFM &&
               k < (SHORT)dwTotalNumOfPFM)
        {
            pDest[k++] = pSrc[j++];
        }
    }

    if (pSrc[j] == 0)
    {
        while (pBase[i] != 0 &&
               pBase[i] <= (SHORT)dwTotalNumOfPFM &&
               k < (SHORT)dwTotalNumOfPFM)
        {
            pDest[k++] = pBase[i++];
        }
    }

    //
    // terminate the result list by zero.
    //

    pDest[k] = 0;

    return k;
}

BOOL
BCreateResFontList(
    IN  HANDLE     hHeap,
    IN  PDH        pGPCData,
    IN  PMODELDATA pModelData,
    IN  DWORD      dwTotalNumOfPFM,
    IN  DWORD      dwNumOfFont,
    OUT PSHORT    psList,
    IN  PSHORT    psTempBuffer)
{
    DWORD  dwNFonts;
    PSHORT psTempList1, psTempList2;
    SHORT  sOrientOffset, sI;
    BOOL   bFlipFlop;

    if (pModelData->fGeneral & MD_ROTATE_FONT_ABLE)
    {
        sOrientOffset = 1;
        bFlipFlop = TRUE;
    }
    else
    {
        sOrientOffset = 0;
        bFlipFlop = FALSE;
    }

    psTempList1 = psTempBuffer;
    psTempList2 = psTempList1 + 1 + dwNumOfFont;

    *psTempList1 = *psTempList2 = 0;

    //
    // look at resident (ROM) fonts.
    //

    for (sI = 0; sI <= sOrientOffset; sI++)
    {
        dwNFonts = DwMergeFonts(dwTotalNumOfPFM,
                                bFlipFlop ? psTempList1 : psTempList2,
                                (PSHORT) ((PBYTE)pGPCData +
                                       pGPCData->loHeap +
                                       pModelData->rgoi[MD_OI_PORT_FONTS + sI]),
                                bFlipFlop ? psTempList2 : psTempList1);

       bFlipFlop = !bFlipFlop;

       if (dwNFonts == dwTotalNumOfPFM)
       {
           break;
       }
    }

    CopyMemory(psList, psTempList1, sizeof(SHORT) * (1 + dwNumOfFont));

    return TRUE;
}

BOOL
BCreateCartFontList(
    IN  HANDLE          hHeap,
    IN  PDH             pGPCData,
    IN  PMODELDATA      pModelData,
    IN  DWORD           dwTotalNumOfPFM,
    IN  PDWORD          pdwNumOfCart,
    IN  PCART_FONTLIST  pCartFontListSrc,
    OUT PCART_FONTLIST *ppCartFontList)
{
    PCART_FONTLIST pCartSrc, pCart;
    DWORD          dwNFonts, dwCartNumOfThisModel, dwTotalFontInAllCart;
    DWORD          dwOffset, dwI;
    PSHORT         psFontCart, psFontCartSrc;

    //
    // Get Cartridge number
    //

    psFontCartSrc = 
    psFontCart =  (PSHORT)((PBYTE)pGPCData +
                          pGPCData->loHeap +
                          pModelData->rgoi[MD_OI_FONTCART]);

    dwCartNumOfThisModel = 0;
    dwTotalFontInAllCart = 0;

    while(*psFontCart)
    {
        dwTotalFontInAllCart +=  pCartFontListSrc[*psFontCart-1].dwNumCartFont;
        psFontCart++;
        dwCartNumOfThisModel++;
    }

    if (dwCartNumOfThisModel == 0)
    {
        *ppCartFontList = NULL;
        *pdwNumOfCart   = 0;
        return TRUE;
    }

    *pdwNumOfCart = dwCartNumOfThisModel;

    //
    // then, look at internal cartridge fonts.
    //

    pCart = pCartSrc = HeapAlloc(hHeap,
                         HEAP_ZERO_MEMORY,
                         dwCartNumOfThisModel * sizeof(CART_FONTLIST) +
                         dwTotalFontInAllCart * sizeof(SHORT) +
                         dwCartNumOfThisModel * sizeof(SHORT));

    if (!pCart)
    {
        ERR(("HeapAlloc failed: %d\n", GetLastError()));
        return FALSE;
    }

    psFontCart = psFontCartSrc;
    dwOffset   = dwCartNumOfThisModel * sizeof(CART_FONTLIST);

    for (dwI = 0; dwI < dwCartNumOfThisModel; dwI++, psFontCart++)
    {
        pCart->sID           = pCartFontListSrc[*psFontCart-1].sID;
        pCart->sStringID     = pCartFontListSrc[*psFontCart-1].sStringID;
        pCart->dwNumCartFont = pCartFontListSrc[*psFontCart-1].dwNumCartFont;
        pCart->dwFontList    = dwOffset;

        CopyMemory((PBYTE)pCart + pCart->dwFontList,
                   (PBYTE)(pCartFontListSrc + *psFontCart - 1) +
                   pCartFontListSrc[*psFontCart-1].dwFontList,
                   (pCartFontListSrc[*psFontCart-1].dwNumCartFont + 1) *
                   sizeof(SHORT));  

        dwOffset += sizeof(SHORT) *
                   (pCartFontListSrc[*psFontCart-1].dwNumCartFont + 1) -
                   sizeof(CART_FONTLIST);
        pCart++;
    }

    *ppCartFontList = pCartSrc;
}


BOOL
BArgCheck(
    IN  INT    iArgc,
    IN  CHAR **ppArgv,
    OUT PDWORD pdwModelID,
    OUT PWSTR  pwstrRCFile,
    OUT PWSTR  pwstrOutFile)
{

    DWORD dwI;
    INT   iParamType, iRet;

    ASSERT(pdwModelID   != NULL ||
           pwstrRCFile  != NULL  );


    if (iArgc < 3 || iArgc > 5)
    {
        return FALSE;
    }

    ppArgv++;
    iArgc --;

    iParamType     = 0;
    *pdwModelID    = 0;
    gdwOutputFlags = 0;

    while (iArgc > 0)
    {
        if (**ppArgv == '-' || **ppArgv == '/')
        {
            dwI = 1;
            while(*(*ppArgv+dwI))
            {
                switch(*(*ppArgv+dwI))
                {
                case 'v':
                    gdwOutputFlags |= OUTPUT_VERBOSE;
                    break;

                case 'a':
                    gdwOutputFlags |= OUTPUT_ALL_MODELS;
                    iParamType = 1;
                    break;

                case 'c':
                    gdwOutputFlags |= OUTPUT_CREATE_BATCH;
                    break;
                }
                dwI ++;
            }
        }
        else
        {
            if (iParamType == 0)
            {
                *pdwModelID = (DWORD)atoi(*ppArgv);
            }
            else
            if (iParamType == 1)
            {
                iRet = MultiByteToWideChar(CP_ACP,
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrRCFile,
                                           FILENAME_SIZE);
                *(pwstrRCFile + iRet) = (WCHAR)NULL;
            }
            if (iParamType == 2)
            {
                iRet = MultiByteToWideChar(CP_ACP,
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrOutFile,
                                           FILENAME_SIZE);
                *(pwstrOutFile + iRet) = (WCHAR)NULL;
            }
            iParamType ++;
        }
        iArgc --;
        ppArgv++;
    }

    return TRUE;
}

SHORT
SGetCTTID(
    IN DWORD        dwTotalNumOfPFM,
    IN SHORT        sFontID,
    IN PPFM_ID_LIST pPFM_ID)
{
    SHORT sI;

    for (sI = 0; sI < (SHORT)dwTotalNumOfPFM; sI ++, pPFM_ID++)
    {
        if(sFontID == pPFM_ID->sFontID) 
        {
            return pPFM_ID->sCTTID;
        }
    }

    return (SHORT)0x8FFF;
}

VOID
VPrintFontList(
    IN PMODEL_FONTLIST pModelFontList,
    IN DWORD           dwTotalNumOfPFM,
    IN PPFM_ID_LIST    pPFM_ID)
{
    PCART_FONTLIST pCartFontList;
    DWORD          dwI, dwJ;
    PSHORT         psFontID;
    SHORT          sCTTID;

    printf("***********************************************************\n");
    printf("Model ID                : %d\n", pModelFontList->sID);
    printf("Model Name String ID    : %d\n", pModelFontList->sStringID);
    printf("Default CTT ID          : %d\n", pModelFontList->sDefaultCTT);
    printf("Number of resident font : %d\n", pModelFontList->dwNumOfResFont);
    printf("Number of font cartridge: %d\n", pModelFontList->dwNumOfCart);
    printf("***********************************************************\n");
    printf("Resident font list\n");
    printf("***********************************************************\n");

    psFontID = (PSHORT)(pModelFontList->psResFontList);

    for (dwI = 1; dwI <= pModelFontList->dwNumOfResFont; dwI++, psFontID++)
    {
        sCTTID = SGetCTTID(dwTotalNumOfPFM, *psFontID, pPFM_ID);

        if (sCTTID == (SHORT)0x8FFF)
        {
            printf("Invalid CTT ID\n");
        }
        else
        {
            if (sCTTID == 0)
            {
                sCTTID = pModelFontList->sDefaultCTT;
            }

            printf("FontID[%3d]=%3d, CTTID=%3d\n", dwI, *psFontID, sCTTID);
        }
    }

    if (pModelFontList->dwNumOfCart)
    {
        printf("***********************************************************\n");
        printf("Cartridge font list\n");
    }

    pCartFontList = (PCART_FONTLIST)pModelFontList->dwCartList;
    for (dwI = 0; dwI < pModelFontList->dwNumOfCart; dwI ++, pCartFontList++)
    {
        printf("***********************************************************\n");
        printf("CartridgeID     = %d\n", pCartFontList->sID);
        printf("StringID        = %d\n", pCartFontList->sStringID);
        printf("Number of fonts = %d\n", pCartFontList->dwNumCartFont);
        printf("-----------------------------------------------------------\n");

        psFontID = (PSHORT)((PBYTE)pCartFontList + pCartFontList->dwFontList);

        for (dwJ = 0; dwJ < pCartFontList->dwNumCartFont; dwJ ++, psFontID++)
        {
            sCTTID = SGetCTTID(dwTotalNumOfPFM, *psFontID, pPFM_ID);

            if (sCTTID == (SHORT)0x8FFF)
            {
                printf("Invalid CTT ID\n");
            }
            else
            {
                if (sCTTID == 0)
                {
                    sCTTID = pModelFontList->sDefaultCTT;
                }

                printf("FontID[%3d]=%3d, CTTID=%3d\n", dwJ + 1,
                                                       *psFontID,
                                                       sCTTID);
            }
        }
    }
}

VOID
VCreateBatchFile(
    IN PMODEL_FONTLIST pModelFontList,
    IN DWORD           dwTotalNumOfPFM,
    IN PPFM_ID_LIST    pPFM_ID,
    IN PFILE_NAME      pPFM_FileNameSrc,
    IN DWORD           dwTotalNumOfCTT,
    IN PFILE_NAME      pCTT_FileNameSrc,
    IN HANDLE          hOutFile)
{
    PCART_FONTLIST pCartFontList;
    PFILE_NAME     pPFM_FileName, pCTT_FileName;
    PCWSTR         pcwstrPFMFileName, pcwstrCTTFileName;
    WCHAR          wchFileName1[FILENAME_SIZE];
    WCHAR          wchFileName2[FILENAME_SIZE];
    DWORD          dwWrittenSize;
    DWORD          dwI, dwJ, dwK;
    PSHORT         psFontID;
    SHORT          sCTTID;
    BYTE           aubBuff[512];
    DWORD          dwPFM2UFMMode;
    DWORD          dwCodePage;

    #define        PFM2UFM_GTTMODE   0
    #define        PFM2UFM_CODEPAGE  1
    #define        PFM2UFM_DEF_CTTID 2

    WRITEDATATOFILE("@rem ***********************************************************\n");
    WRITEDATATOFILE("@rem CTT -> GTT\n");
    WRITEDATATOFILE("@rem ***********************************************************\n");
    pCTT_FileName = pCTT_FileNameSrc;
    for (dwI = 0; dwI < dwTotalNumOfCTT; dwI ++)
    {
        dwJ = 0;
        while(pCTT_FileName->wchFileName[dwJ] != '.' ||
              pCTT_FileName->wchFileName[dwJ + 1] == '.' ||
              pCTT_FileName->wchFileName[dwJ + 1] == '\\')
        {
            wchFileName1[dwJ] = pCTT_FileName->wchFileName[dwJ];
            dwJ ++;
        }

        wchFileName1[dwJ] = (WCHAR)NULL;
        sprintf((PSTR)aubBuff, "ctt2gtt %ws.txt %ws.ctt %ws.gtt\n",
                                                            wchFileName1,
                                                            wchFileName1,
                                                            wchFileName1);
        WRITEDATATOFILE(aubBuff);

        (PBYTE)pCTT_FileName += pCTT_FileName->wNext;
    }

    WRITEDATATOFILE("@rem ***********************************************************\n");
    sprintf((PSTR)aubBuff, "@rem Model ID                : %d\n", pModelFontList->sID);
    WRITEDATATOFILE(aubBuff);
    sprintf((PSTR)aubBuff, "@rem Model Name String ID    : %d\n", pModelFontList->sStringID);
    WRITEDATATOFILE(aubBuff);
    WRITEDATATOFILE("@rem ***********************************************************\n");
    WRITEDATATOFILE("@rem Resident font\n");
    WRITEDATATOFILE("@rem ***********************************************************\n");

    psFontID = (PSHORT)(pModelFontList->psResFontList);

    for (dwI = 1; dwI <= pModelFontList->dwNumOfResFont; dwI++, psFontID++)
    {
        sCTTID = SGetCTTID(dwTotalNumOfPFM, *psFontID, pPFM_ID);

        if (sCTTID == (SHORT)0x8FFF)
        {
            WRITEDATATOFILE("Invalid CTT ID\n");
        }
        else
        {
            if (sCTTID == 0)
            {
                sCTTID = pModelFontList->sDefaultCTT;
            }

            pcwstrPFMFileName = PcwstrGetFileName(*psFontID, pPFM_FileNameSrc, dwTotalNumOfPFM);
            pcwstrCTTFileName = PcwstrGetFileName(sCTTID, pCTT_FileNameSrc, dwTotalNumOfCTT);
            if (pcwstrPFMFileName != NULL)
            {
                if (pcwstrCTTFileName)
                {
                    dwJ = 0;
                    while(pcwstrCTTFileName[dwJ] != '.'     ||
                          pcwstrCTTFileName[dwJ + 1] == '.' ||
                          pcwstrCTTFileName[dwJ + 1] == '\\' )
                    {
                        wchFileName1[dwJ] = pcwstrCTTFileName[dwJ];
                        dwJ ++;
                    }

                    wchFileName1[dwJ] = (WCHAR)NULL;
                    dwPFM2UFMMode = PFM2UFM_GTTMODE;
                }
                else
                if (sCTTID == 0)
                {
                    dwPFM2UFMMode = PFM2UFM_CODEPAGE;
                    dwCodePage = 1252;
                }
                else
                if (-3 <= sCTTID && sCTTID <= -1)
                {
                    dwPFM2UFMMode = PFM2UFM_DEF_CTTID;
                }
                else
                if (-263 <= sCTTID && sCTTID <= -256)
                {
                    dwPFM2UFMMode = PFM2UFM_CODEPAGE;
                    dwCodePage    = DwCTTID2CodePage(sCTTID);
                }

                dwJ = 0;
                while(pcwstrCTTFileName[dwJ] != '.'     ||
                      pcwstrCTTFileName[dwJ + 1] == '.' ||
                      pcwstrCTTFileName[dwJ + 1] == '\\')
                {
                    wchFileName2[dwJ] = pcwstrPFMFileName[dwJ];
                    dwJ ++;
                }

                wchFileName2[dwJ] = (WCHAR)NULL;

                if (dwPFM2UFMMode == PFM2UFM_GTTMODE)
                {
                    sprintf((PSTR)aubBuff, "pfm2ufm UniqName %ws %ws.gtt %ws.ufm\n",
                                        pcwstrPFMFileName,
                                        wchFileName1,
                                        wchFileName2);
                }
                else
                if (dwPFM2UFMMode == PFM2UFM_CODEPAGE)
                {
                    sprintf((PSTR)aubBuff, "pfm2ufm -c UniqName %ws %d %ws.ufm\n",
                                        pcwstrPFMFileName,
                                        dwCodePage,
                                        wchFileName2);
                }
                if (dwPFM2UFMMode == PFM2UFM_DEF_CTTID)
                {
                    sprintf((PSTR)aubBuff, "pfm2ufm -p UniqName %ws %d %ws.ufm\n",
                                        pcwstrPFMFileName,
                                        -sCTTID,
                                        wchFileName2);
                }

                WRITEDATATOFILE(aubBuff);
            }
            else
            {
                sprintf((PSTR)aubBuff, "Error: FontID=%d, CTTID=%d\n",
                                        *psFontID, sCTTID);
                WRITEDATATOFILE(aubBuff);
            }
        }
    }

    if (pModelFontList->dwNumOfCart)
    {
        WRITEDATATOFILE("@rem ***********************************************************\n");
        WRITEDATATOFILE("@rem Cartridge font list\n");
    }

    pCartFontList = (PCART_FONTLIST)pModelFontList->dwCartList;
    for (dwI = 0; dwI < pModelFontList->dwNumOfCart; dwI ++, pCartFontList++)
    {
        WRITEDATATOFILE("@rem ***********************************************************\n");
        sprintf((PSTR)aubBuff, "@rem CartridgeID     = %d\n", pCartFontList->sID);
        WRITEDATATOFILE(aubBuff);
        sprintf((PSTR)aubBuff, "@rem StringID        = %d\n", pCartFontList->sStringID);
        WRITEDATATOFILE(aubBuff);
        sprintf((PSTR)aubBuff, "@rem Number of fonts = %d\n", pCartFontList->dwNumCartFont);
        WRITEDATATOFILE(aubBuff);
        WRITEDATATOFILE("@rem -----------------------------------------------------------\n");

        psFontID = (PSHORT)((PBYTE)pCartFontList + pCartFontList->dwFontList);

        for (dwJ = 0; dwJ < pCartFontList->dwNumCartFont; dwJ ++, psFontID++)
        {
            sCTTID = SGetCTTID(dwTotalNumOfPFM, *psFontID, pPFM_ID);

            if (sCTTID == (SHORT)0x8FFF)
            {
                WRITEDATATOFILE("@rem Invalid CTT ID\n");
            }
            else
            {
                if (sCTTID == 0)
                {
                    sCTTID = pModelFontList->sDefaultCTT;
                }

                pcwstrPFMFileName = PcwstrGetFileName(*psFontID, pPFM_FileNameSrc, dwTotalNumOfPFM);
                pcwstrCTTFileName = PcwstrGetFileName(sCTTID, pCTT_FileNameSrc, dwTotalNumOfCTT);
                if (pcwstrPFMFileName != NULL)
                {

                    if (pcwstrCTTFileName)
                    {
                        dwK = 0;
                        while(pcwstrCTTFileName[dwK] != '.'     ||
                              pcwstrCTTFileName[dwK + 1] == '.' ||
                              pcwstrCTTFileName[dwK + 1] == '\\')
                        {
                            wchFileName1[dwK] = pcwstrCTTFileName[dwK];
                            dwK ++;
                        }

                        wchFileName1[dwK] = (WCHAR)NULL;
                        dwPFM2UFMMode = PFM2UFM_GTTMODE;
                    }
                    else
                    if (sCTTID == 0)
                    {
                        dwPFM2UFMMode = PFM2UFM_CODEPAGE;
                    }
                    else
                    if (-3 <= sCTTID && sCTTID <= -1)
                    {
                        dwPFM2UFMMode = PFM2UFM_DEF_CTTID;
                    }
                    else
                    if (-263 <= sCTTID && sCTTID <= -256)
                    {
                        dwPFM2UFMMode = PFM2UFM_CODEPAGE;
                        dwCodePage    = DwCTTID2CodePage(sCTTID);
                    }


                    dwK = 0;
                    while(pcwstrCTTFileName[dwK] != '.'     ||
                          pcwstrCTTFileName[dwK + 1] == '.' ||
                          pcwstrCTTFileName[dwK + 1] == '\\')
                    {
                        wchFileName2[dwK] = pcwstrPFMFileName[dwK];
                        dwK ++;
                    }

                    wchFileName2[dwK] = (WCHAR)NULL;

                    if (dwPFM2UFMMode == PFM2UFM_GTTMODE)
                    {
                        sprintf((PSTR)aubBuff, "pfm2ufm UniqName %ws %ws.gtt %ws.ufm\n",
                                            pcwstrPFMFileName,
                                            wchFileName1,
                                            wchFileName2);
                    }
                    else
                    if (dwPFM2UFMMode == PFM2UFM_CODEPAGE)
                    {
                        sprintf((PSTR)aubBuff, "pfm2ufm -c UniqName %ws %d %ws.ufm\n",
                                            pcwstrPFMFileName,
                                            dwCodePage,
                                            wchFileName2);
                    }
                    if (dwPFM2UFMMode == PFM2UFM_DEF_CTTID)
                    {
                        sprintf((PSTR)aubBuff, "pfm2ufm -p UniqName %ws %d %ws.ufm\n",
                                            pcwstrPFMFileName,
                                            -sCTTID,
                                            wchFileName2);
                    }

                    WRITEDATATOFILE(aubBuff);
                }
                else
                {
                    sprintf((PSTR)aubBuff, "Error: FontID=%d, CTTID=%d\n",
                                            *psFontID, sCTTID);
                    WRITEDATATOFILE(aubBuff);
                }
            }
        }
    }
}


SHORT
SCountFontNum(
    IN PDH  pGPCData,
    IN WORD wFontListPort,
    IN WORD wFontListLand)
{
    PSHORT psFontListPortSrc, psFontListPort, psFontListLand;
    SHORT  sReturn, sI;
    BOOL   bAdd;

    sReturn = 0;

    if (wFontListPort == (WORD)0)
    {
        return sReturn;
    }

    psFontListPortSrc = 
    psFontListPort = (PSHORT)((PBYTE)pGPCData +
                              pGPCData->loHeap +
                              wFontListPort);

    if (*psFontListPort > 0)
    {
        sReturn     = *(psFontListPort + 1) - *psFontListPort + 1;
        psFontListPort += 2;
    }

    while(*psFontListPort)
    {
        sReturn ++;
        psFontListPort ++;
    }

    psFontListLand = (PSHORT)((PBYTE)pGPCData +
                              pGPCData->loHeap +
                              wFontListLand);

    if (wFontListLand == (WORD)0)
    {
        return sReturn;
    }

    if (*psFontListLand > 0)
    {
        for (sI = *psFontListLand; sI <= *(psFontListLand + 1); sI ++)
        {
            sReturn += SAdditionalFont(sI, psFontListPortSrc);
        }

        psFontListLand +=2;

        while(*psFontListLand)
        {
            sReturn += SAdditionalFont(*psFontListLand, psFontListPortSrc);
            psFontListLand ++;
        }
    }

    return sReturn;
}

SHORT
SAdditionalFont(
    IN SHORT  sI,
    IN PSHORT psFontList)
{
    SHORT sReturn;
    BOOL  bFound;

    if (*psFontList <= sI && sI <= *(psFontList + 1))
    {
        return 0;
    }

    psFontList += 2;
    bFound = FALSE;

    while(*psFontList)
    {
        if (sI == *psFontList)
        {
            return 0;
        }
        psFontList++;
    }

    return 1;
}

PCWSTR
PcwstrGetFileName(
    SHORT      sID,
    PFILE_NAME pFileName,
    DWORD      dwTotal)
{

    DWORD dwI;

    for (dwI = 0; dwI < dwTotal; dwI ++)
    {
        if (pFileName->sID == sID)
        {
            return pFileName->wchFileName;
        }
        (PBYTE)pFileName += pFileName->wNext;
    }

    return NULL;
}

DWORD
DwCTTID2CodePage(
    SHORT sCTTID)
{
    DWORD dwRet;

    switch (sCTTID)
    {
    case CTT_CP437:
    case CTT_CP850:
    case CTT_CP863:
        dwRet = 1252;
        break;

    case CTT_BIG5:
        dwRet = 950;
        break;

    case CTT_ISC:
        dwRet = 949;
        break;

    case CTT_JIS78:
        dwRet = 932;
        break;

    case CTT_JIS83:
        dwRet = 932;
        break;

    case CTT_JIS78_ANK:
        dwRet = 932;
        break;

    case CTT_JIS83_ANK:
        dwRet = 932;
        break;

    case CTT_NS86:
        dwRet = 950;
        break;

    case CTT_TCA:
        dwRet = 950;
        break;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkgttufm\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

Environment:

    Windows NT printer drivers

Revision History:

    01/09/97 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        <unilib.h>
#include        <prntfont.h>
#include        <fmlib.h>

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkuff\dumpuff.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dumpUFF.c

Abstract:

    UFF dump tool

Environment:

    Windows NT PostScript driver

Revision History:

    12/20/96 -eigos-
    Created it.

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256

//
// Globals
//

BYTE *gcstrdwFlags1[] = {
                        "FONT_DIR_SORTED"
};
BYTE *gcstrdwFlags2[] = {
                        "FONT_FL_UFM",
                        "FONT_FL_IFI",
                        "FONT_FL_SOFTFONT",
                        "FONT_FL_PERMANENT_SF",
                        "FONT_FL_DEVICEFONT",
                        "FONT_FL_GLYPHET_GTT",
                        "FONT_FL_GLYPHSET_RLE",
                        "FONT_FL_RESERVED"
};

//
// Internal prototype
//

BOOL BDumpUFF(IN PUFF_FILEHEADER);
VOID DumpData(IN PBYTE pData);


BOOL
BDumpUFF(
    IN PUFF_FILEHEADER pUFF)
{

    PUFF_FONTDIRECTORY pFontDir;
    DWORD dwI, dwJ;

#if 0
    printf("%x%x%x%x\n", *(PDWORD)pUFF,
                         *((PDWORD)pUFF+1),
                         *((PDWORD)pUFF+2),
                         *((PDWORD)pUFF+3));
#endif

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf(" UFF File\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("UFF.dwSignature          = 0x%x\n", pUFF->dwSignature);
    printf("                         = %c%c%c%c\n",
                                      (0x00FF & pUFF->dwSignature),
                                      (0xFF00 & pUFF->dwSignature) >> 8,
                                      (0xFF0000 & pUFF->dwSignature) >> 16,
                                      (0xFF000000 & pUFF->dwSignature) >> 24);
    printf("UFF.dwVersion            = %d\n", pUFF->dwVersion);
    printf("UFF.dwSize               = %d\n", pUFF->dwSize);
    printf("UFF.nFonts               = %d\n", pUFF->nFonts);
    printf("UFF.nGlyphSets           = %d\n", pUFF->nGlyphSets);
    printf("UFF.nVarData             = %d\n", pUFF->nVarData);
    printf("UFF.offFontDir           = 0x%x\n", pUFF->offFontDir);
    printf("UFF.dwFlags              = 0x%x\n", pUFF->dwFlags);
    for( dwI = 0; dwI < 32; dwI ++ )
    {
        if (pUFF->dwFlags & (0x00000001 << dwI))
            printf("                           %s\n", gcstrdwFlags1[dwI]);
    }

    pFontDir = (PUFF_FONTDIRECTORY)((PBYTE)pUFF + pUFF->offFontDir);
    for (dwI = 0; dwI < pUFF->nFonts; dwI ++, pFontDir ++)
    {
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("UFF_FONTREC.dwSignature    = %d\n",   pFontDir->dwSignature);
        printf("                           = %c%c%c%c\n",
                                  (0x00FF & pFontDir->dwSignature),
                                  (0xFF00 & pFontDir->dwSignature) >> 8,
                                  (0xFF0000 & pFontDir->dwSignature) >> 16,
                                  (0xFF000000 & pFontDir->dwSignature) >> 24);
        printf("UFF_FONTREC.wSize          = %d\n",   pFontDir->wSize);
        printf("UFF_FONTREC.wFontID        = %d\n",   pFontDir->wFontID);
        printf("UFF_FONTREC.sGlyphID       = %d\n",   pFontDir->sGlyphID);
        printf("UFF_FONTREC.wFlags         = %d\n",   pFontDir->wFlags);
        for( dwJ = 0; dwJ < 32; dwJ ++ )
        {
            if (pUFF->dwFlags & (0x00000001 << dwJ))
                printf("                           %s\n", gcstrdwFlags2[dwJ]);
        }
        printf("UFF_FONTREC.dwInstallerSig = %d\n",   pFontDir->dwInstallerSig);
        printf("                         = %c%c%c%c\n",
                              (0x00FF & pFontDir->dwInstallerSig),
                              (0xFF00 & pFontDir->dwInstallerSig) >> 8,
                              (0xFF0000 & pFontDir->dwInstallerSig) >> 16,
                              (0xFF000000 & pFontDir->dwInstallerSig) >> 24);
        printf("UFF.offFontName            = 0x%x\n", pFontDir->offFontName);
        printf("                           = %ws\n", (PBYTE)pUFF+pFontDir->offFontName);
        printf("UFF.offCartridgeName       = 0x%x\n", pFontDir->offCartridgeName);
        printf("                           = %ws\n", (PBYTE)pUFF+pFontDir->offCartridgeName);
        printf("UFF.offFontData            = 0x%x\n", pFontDir->offFontData);
        printf("UFF.offGlyphData           = 0x%x\n", pFontDir->offGlyphData);
        printf("UFF.offVarData             = 0x%x\n", pFontDir->offVarData);
    }

    return TRUE;
}


VOID
DumpData(
        IN PBYTE pData)
{
    PDATA_HEADER pDataHeader = (PDATA_HEADER)pData;
    DWORD dwI;

    printf("dwSignature = 0x%x\n", pDataHeader->dwSignature);
    printf("            = %c%c%c%c\n",
                          (0x00FF & pDataHeader->dwSignature),
                          (0xFF00 & pDataHeader->dwSignature) >> 8,
                          (0xFF0000 & pDataHeader->dwSignature) >> 16,
                          (0xFF000000 & pDataHeader->dwSignature) >> 24);
    printf("wSize       = %d\n", pDataHeader->wSize);
    printf("wDataID     = %d(0x%x)\n", pDataHeader->wDataID, pDataHeader->wDataID);
    printf("dwDataSize  = %d\n", pDataHeader->dwDataSize);

    pData += sizeof(DATA_HEADER);

    for (dwI = 0; dwI < 16; dwI ++, pData += 16)
    {
        printf(" %08x %08x %08x %08x\n", *(PDWORD)pData, *(PDWORD)(pData+4), *(PDWORD)(pData+8), *(PDWORD)(pData+12));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkuff\local.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    local.h

Abstract:


Environment:

    Windows NT printer drivers

Revision History:


--*/

//
// flag definitions for gdwOutputFlags
//

#define OUTPUT_VERBOSE 0x00000001


#define FILENAME_SIZE 256

typedef struct _DATAFILE DATAFILE, *PDATAFILE;
typedef struct _CARTLIST CARTLIST, *PCARTLIST;
typedef struct _FILELIST FILELIST, *PFILELIST;

typedef struct _DATAFILE
{
    DWORD rcID;
    DWORD dwSignature;
    SHORT rcTrans;
    DWORD dwSize;
    PWSTR pwstrFileName;
    PWSTR pwstrDataName;
    DATAFILE *pNext;
} DATAFILE, *PDATAFILE;

typedef struct _CARTLIST
{
    PWSTR pwstrCartName;
    PDATAFILE pFontFile;
    PDATAFILE pTransFile;
    PCARTLIST pNext;
} CARTLIST, *PCARTLIST;

typedef struct _FILELIST
{
    DWORD dwCartridgeNum;
    PCARTLIST pCartList;
    PCARTLIST pCurrentCartList;
} FILELIST, *PFILELIST;


BOOL
BGetInfo(
    HANDLE hHeap,
    PBYTE pData,
    DWORD dwSize,
    FILELIST *pFileList);

BOOL
BDumpUFF(
    IN PUFF_FILEHEADER pUFF);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkuff\makefile.inc ===
mkuff.exe: obj\i386\mkuff.exe
    copy obj\i386\mkuff.exe sample
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\pclxl\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

Environment:

    Windows NT printer drivers

Revision History:

    01/09/97 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkuff\parse.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Parse a text file.

Environment:

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

#define IS_COMMENT(c)  ((c) == (BYTE)';')
#define EOL    '\n'

//
// Local function prototypes
//

PBYTE PubSkipComment( PBYTE );

extern DWORD             gdwOutputFlags;

INT
IGetCart(
    HANDLE    hHeap,
    PBYTE     pData,
    CARTLIST *pCartlist);

INT
IGetFont(
    HANDLE    hHeap,
    PBYTE     pData,
    CARTLIST *pCartList);

INT
IGetTrans(
    HANDLE    hHeap,
    PBYTE     pData,
    CARTLIST *pCartList);

//
// Main function
//

BOOL
BGetInfo(
    HANDLE hHeap,
    PBYTE pData,
    DWORD dwSize,
    FILELIST *pFileList)
{

    CARTLIST *pCartList;

    BYTE  aubType[32];
    PBYTE pstrType;
    PBYTE pTextData;
    INT   iRet;

    ASSERT(pData != NULL && pFileList != NULL);

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        fprintf( stdout, "Start BGetInfo\n");
    }

    pstrType = aubType;
    pTextData = pData;

    do 
    {
        pTextData = PubSkipComment(pTextData);

        if (pTextData == NULL)
        {
            iRet = EOF;
            break;
        }

        iRet = sscanf( pTextData, "%s:", pstrType);

        if (iRet != 0 && iRet != EOF)
        {
            pTextData += strlen(pstrType);
        }
        else
            *pstrType = 0;

        pTextData = PubSkipComment(pTextData);

        switch(*pstrType) 
        {
        case 'c':
        case 'C':
            if(!_stricmp(pstrType+1, "artridgename:"))
            {
                if( !(pCartList = (CARTLIST *)HeapAlloc(
                                             hHeap,
                                             0,
                                             sizeof(CARTLIST))))
                {
                    return  0;
                }

                ZeroMemory(pCartList, sizeof(CARTLIST));

                iRet = IGetCart(hHeap,
                                pTextData,
                                pCartList);

                if (pFileList->pCurrentCartList)
                {
                    pFileList->pCurrentCartList->pNext = pCartList;
                    pFileList->pCurrentCartList = pCartList;
                }
                else
                {
                    pFileList->pCartList =
                    pFileList->pCurrentCartList = pCartList;
                }

                pFileList->dwCartridgeNum ++;


                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }
            }
            break;

        case 'f':
        case 'F':
            if(!_stricmp(pstrType+1, "ont:"))
            {
                iRet = IGetFont(hHeap,
                                pTextData,
                                pFileList->pCurrentCartList);

                if (iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }

            }
            break;

        case 't':
        case 'T':
            if(!_stricmp(pstrType+1, "rans:"))
            {
                iRet = IGetTrans(hHeap,
                                pTextData,
                                pFileList->pCurrentCartList);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }

            }
            break;

        default:
            pTextData++;
        }
    }
    while(*pTextData != EOF && dwSize > (DWORD)(pTextData - pData));

    return TRUE;
}

PBYTE
PubSkipComment(
    PBYTE pData)
{
    ASSERT(pData != NULL);

    do
    {
        if (IS_COMMENT(*pData))
        {
            while (*pData != EOL)
                pData++;
            pData++;
        }
        else if (*pData == ' ')
        {
            pData++;
        }
        else if (*pData == 0x0d)
        {
            pData++;
        }
        else if (*pData == EOL)
        {
            pData++;
        }
        else if (*pData == EOF)
        {
            pData = NULL;
            break;
        }
        else
            break;

    } while (TRUE);

    return pData;
}

INT
IGetCart(
    HANDLE    hHeap,
    PBYTE     pData,
    CARTLIST *pCartList)
{
    PWSTR pwstrCartName;
    PBYTE pDataTmp;
    INT   iCount, iStrLen, iRet, iCartID, iI;

    pwstrCartName = NULL;

    iRet = sscanf( pData, "%d", &iCartID);

    while (*pData != '"' && *pData != EOF)
    {
        pData++;
    }

    if (*pData == '"')
    {
        pData++;
        iCount = 0;
        pDataTmp = pData;

        iStrLen = 0;
        while(*pDataTmp != '"')
        {
            pDataTmp ++;
            iStrLen ++;
        }

        if (iStrLen)
        {
            if( !(pwstrCartName = (PWSTR)HeapAlloc( hHeap,
                                                    0,
                                                    (iStrLen + 1) * sizeof(WCHAR))) )
            {
                return  0;
            }

            iRet = MultiByteToWideChar(CP_ACP,
                                       0,
                                       pData,
                                       iStrLen,
                                       pwstrCartName, 
                                       FILENAME_SIZE);

            *(pwstrCartName + iRet) = (WCHAR)NULL;
        }

    }

    iCount++;

    for (iI = 1; iI < iCartID && pCartList->pNext; iI ++) 
    {
        pCartList = pCartList->pNext;
    }

    if (pCartList)
    {
        if (pwstrCartName)
            pCartList->pwstrCartName = pwstrCartName;
        else
            pCartList->pwstrCartName = NULL;
    }

    return iCount;
}

INT
IGetFont(
    HANDLE    hHeap,
    PBYTE     pData,
    CARTLIST *pCartList)
{
    DATAFILE *pFontFileTmp, *pFontFile;
    PBYTE    pDataTmp, pNameString;
    INT      iCount;
    INT      iRet;
    INT      iFileStrLen, iNameStrLen;
    DWORD    dwRCID;

    iRet = sscanf( pData, "%d", &dwRCID);

    while (*pData != '"' && *pData != EOF)
    {
        pData++;
    }


    if (*pData == '"')
    {
        pData++;
        iNameStrLen = 0;
        pNameString = pData;
        while (*pData!= '"')
        {
            pData++;
            iNameStrLen ++;
        }
    }

    pData++;

    while (*pData != '"' && *pData != EOF)
    {
        pData++;
    }

    if (*pData == '"')
    {
        pData++;
        iFileStrLen = 0;
        pDataTmp = pData;

        while(*pDataTmp != '"')
        {
            pDataTmp ++;
            iFileStrLen ++;
        }


        if( !(pFontFile = (DATAFILE *)HeapAlloc(
                                     hHeap,
                                     0,
                                     sizeof(DATAFILE) +
                                     (iNameStrLen + 1) * sizeof(WCHAR) +
                                     (iFileStrLen + 1) * sizeof(WCHAR))))
        {
            fprintf( stderr, "Can't allocate memory\n");
            return  0;
        }

        ZeroMemory(pFontFile, sizeof(DATAFILE) +
                              (iNameStrLen + 1) * sizeof(WCHAR)
                              (iFileStrLen + 1) * sizeof(WCHAR));

        pFontFile->rcID = dwRCID;
        pFontFile->pwstrFileName = (PWSTR)(pFontFile + 1);
        pFontFile->pwstrDataName = pFontFile->pwstrFileName + iFileStrLen + 1;

        iRet = MultiByteToWideChar(CP_ACP,
                                   0,
                                   pNameString,
                                   iNameStrLen,
                                   pFontFile->pwstrDataName, 
                                   FILENAME_SIZE);

        *(pFontFile->pwstrDataName + iRet) = (WCHAR)NULL;

        iRet = MultiByteToWideChar(CP_ACP,
                                   0,
                                   pData,
                                   iFileStrLen,
                                   pFontFile->pwstrFileName, 
                                   FILENAME_SIZE);

        *(pFontFile->pwstrFileName + iRet) = (WCHAR)NULL;

        if (pFontFileTmp = pCartList->pFontFile)
        {
            while (pFontFileTmp->pNext)
            {
                pFontFileTmp = pFontFileTmp->pNext;
            }

            pFontFileTmp->pNext = pFontFile;

        }
        else
        {
            pCartList->pFontFile = pFontFile;
        }


    }


    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        fprintf(stdout, "IGetFont\n");
        fprintf(stdout, "rcID=%d, pwstrFileName=\"%ws\", pwstrDataName=\"%ws\"\n",
                pFontFile->rcID,
                pFontFile->pwstrFileName,
                pFontFile->pwstrDataName);
    }

    return 1;
}

INT
IGetTrans(
    HANDLE    hHeap,
    PBYTE     pData,
    CARTLIST *pCartList)
{
    DATAFILE *pTransFileTmp, *pTransFile;
    PBYTE    pDataTmp;
    INT      iCount;
    INT      iRet;
    INT      iStrLen;
    DWORD    dwRCID;

    iRet = sscanf( pData, "%d", &dwRCID);


    while (*pData != '"' && *pData != EOF)
    {
        pData++;
    }

    iCount = 0;

    if (*pData == '"')
    {
        pData++;
        iStrLen = 0;
        pDataTmp = pData;

        while(*pDataTmp != '"')
        {
            pDataTmp ++;
            iStrLen ++;
        }


        if( !(pTransFile = (DATAFILE *)HeapAlloc(
                                     hHeap,
                                     0,
                                     sizeof(DATAFILE) + (iStrLen + 1) * sizeof(WCHAR))))
        {
            return  0;
        }

        ZeroMemory(pTransFile, sizeof(DATAFILE) + iStrLen * sizeof(WCHAR));

        pTransFile->rcID = dwRCID;
        pTransFile->pwstrFileName = (PWSTR)(pTransFile + 1);

        iRet = MultiByteToWideChar(CP_ACP,
                                   0,
                                   pData,
                                   iStrLen,
                                   pTransFile->pwstrFileName, 
                                   FILENAME_SIZE);

        *(pTransFile->pwstrFileName + iRet) = (WCHAR)NULL;

        if (pTransFileTmp = pCartList->pTransFile)
        {
            while (pTransFileTmp->pNext)
            {
                pTransFileTmp = pTransFileTmp->pNext;
            }

            pTransFileTmp->pNext = pTransFile;

        }
        else
        {
            pCartList->pTransFile = pTransFile;
        }


    }

    iCount++;

    return iCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkuff\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    CTT to UNI_GLYPHSETDATA conversion tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <prntfont.h>
#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        <unilib.h>
#include        <fmoldfm.h>

#include        "local.h"

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\mkuff\mkuff.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    mkuff.c

Abstract:


Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

DWORD             gdwOutputFlags;

//
// Local function prototypes
//

BOOL
BiArgcheck(
    IN     INT    iArgc,
    IN     CHAR **ppArgv,
    IN OUT PWSTR   pwstrInFileName,
    IN OUT PWSTR   pwstrOutFileName);

PBYTE
PCreateUFFFileHeader(
    HANDLE    hHeap,
    PFILELIST pFileList,
    PDWORD    pdwUFFSize);

//
// Globals
//

BYTE gcstrError1[] = "Usage:  mkuff [-v] [Input Text file] [Output UFF file]\n";
BYTE gcstrError2[] = "mkuff: HeapCreate() failed\n.";
BYTE gcstrError3[] = "BGetInfo failed.\n";
BYTE gcstrError4[] = "Cannot create output file '%ws'.\n";
BYTE gcstrError5[] = "PCreateUFFFileHeader failed\n";
BYTE gcstrError6[] = "WriteFile fails: writes %ld bytes\n";
BYTE gcstrError8[] = "Cannot open file \"%ws\".\n";


INT  __cdecl
main(
    IN INT     iArgc,
    IN CHAR  **ppArgv)
/*++

Routine Description:

    main

Arguments:

    iArgc - Number of parameters in the following
    ppArgv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{

    HANDLE hHeap, hInFile, hOutput;
    PBYTE  pInFile, pUFFFile;
    DWORD  dwInFileSize, dwI, dwUFFHeaderSize, dwWrittenSize, dwFileSize;

    PWSTR  wstrInFileName[FILENAME_SIZE];
    PWSTR  wstrOutFileName[FILENAME_SIZE];

    FILELIST FileList;
    DATA_HEADER DataHeader;
    PCARTLIST pCartList;
    PDATAFILE pDataTmp;
    PDATAFILE pFontFile;
    HANDLE hFontFile;
    PBYTE pFontData;

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        fprintf( stdout, "Start mkuff\n");
    }

    if (!BiArgcheck(iArgc, ppArgv, (PWSTR)wstrInFileName, (PWSTR)wstrOutFileName))
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        fprintf( stdout, "InFile: %ws\nOutFile: %ws\n", wstrInFileName, wstrOutFileName);
    }

    //
    // Heap Creation
    //

    if (!(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 0x10000, 0x10000)))
    {
        fprintf( stderr, gcstrError2);
        ERR(("CreateHeap failed: %d\n", GetLastError()));
        return -2;
    }

    hInFile = MapFileIntoMemory((PWSTR)wstrInFileName,
                                (PVOID)&pInFile,
                                &dwInFileSize );

    ZeroMemory(&FileList, sizeof(FILELIST));

    if (!BGetInfo(hHeap, pInFile, dwInFileSize, &FileList))
    {
        fprintf( stderr, gcstrError3);
        ERR(("CreateHeap failed: %d\n", GetLastError()));
        return -3;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        PDATAFILE pFontFile;
        PDATAFILE pTransFile;
        PCARTLIST pCartList;

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("FileList\n");

        pCartList = FileList.pCartList;

        for (dwI = 0; dwI < FileList.dwCartridgeNum; dwI ++, pCartList = pCartList->pNext)
        {
            if (pCartList->pwstrCartName)
                fprintf( stdout, "CartRidge(%d): ""%ws""\n", dwI, pCartList->pwstrCartName);
            pFontFile = pCartList->pFontFile;
            while( pFontFile )
            {
                fprintf( stdout, "FontFile(%d): %ws, FontName:%ws\n", pFontFile->rcID, pFontFile->pwstrFileName, pFontFile->pwstrDataName);
                pFontFile = pFontFile->pNext;
            }

            pTransFile = pCartList->pTransFile;
            while( pTransFile )
            {
                fprintf( stdout, "TransFile(%d): %ws\n", pTransFile->rcID, pTransFile->pwstrFileName);
                pTransFile = pTransFile->pNext;
            }
        }
    }

    UnmapFileFromMemory(hInFile);

    pUFFFile = PCreateUFFFileHeader(hHeap, &FileList, &dwUFFHeaderSize);

    if (pUFFFile == NULL)
    {
        fprintf( stderr, gcstrError5);
        return -5;

    }

    hOutput = CreateFile((PWSTR)wstrOutFileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if( hOutput == INVALID_HANDLE_VALUE )
    {
        fprintf( stderr, gcstrError4,  wstrOutFileName);
        return -4;
    }

    WriteFile( hOutput,
               pUFFFile,
               dwUFFHeaderSize,
               &dwWrittenSize,
               NULL );

    if( dwWrittenSize != dwUFFHeaderSize)
    {
        fprintf( stderr, gcstrError6, dwWrittenSize);
        return  -6;
    }

    //
    // Open font file and write data
    //

    pCartList = FileList.pCartList;
    while (pCartList)
    {
        pDataTmp = pCartList->pFontFile;
        while (pDataTmp)
        {
            hFontFile = MapFileIntoMemory(pDataTmp->pwstrFileName,
                                          (PVOID)&pFontData,
                                          &dwFileSize );

            DataHeader.dwSignature = pDataTmp->dwSignature;
            DataHeader.wSize = sizeof(DATA_HEADER);
            DataHeader.wDataID = (WORD)pDataTmp->rcID;
            DataHeader.dwDataSize = (WORD)dwFileSize;
            DataHeader.dwReserved = 0;

            if (hFontFile)
            {
                WriteFile( hOutput,
                           &DataHeader,
                           sizeof(DATA_HEADER),
                           &dwWrittenSize,
                           NULL);

                if( dwWrittenSize != sizeof(DATA_HEADER))
                {
                    fprintf( stderr, gcstrError6, dwWrittenSize);
                    return  -6;
                }

                WriteFile( hOutput,
                           pFontData,
                           dwFileSize,
                           &dwWrittenSize,
                           NULL);

                if( dwWrittenSize != dwFileSize)
                {
                    fprintf( stderr, gcstrError6, dwWrittenSize);
                    return  -6;
                }

                UnmapFileFromMemory(hFontFile);
            }
            else
                break;

            pDataTmp = pDataTmp->pNext;
        }
        pDataTmp = pCartList->pTransFile;
        while (pDataTmp)
        {
            hFontFile = MapFileIntoMemory(pDataTmp->pwstrFileName,
                                          (PVOID)&pFontData,
                                          &dwFileSize );
            DataHeader.dwSignature = pDataTmp->dwSignature;
            DataHeader.wSize = sizeof(DATA_HEADER);
            DataHeader.wDataID = (WORD)pDataTmp->rcID;
            DataHeader.dwDataSize = (WORD)dwFileSize;
            DataHeader.dwReserved = 0;

            if (hFontFile)
            {
                WriteFile( hOutput,
                           &DataHeader,
                           sizeof(DATA_HEADER),
                           &dwWrittenSize,
                           NULL);

                if( dwWrittenSize != sizeof(DATA_HEADER))
                {
                    fprintf( stderr, gcstrError6, dwWrittenSize);
                    return  -6;
                }
                WriteFile( hOutput,
                           pFontData,
                           dwFileSize,
                           &dwWrittenSize,
                           NULL);

                if( dwWrittenSize != dwFileSize)
                {
                    fprintf( stderr, gcstrError6, dwWrittenSize);
                    return  -6;
                }

                UnmapFileFromMemory(hFontFile);
            }
            else
                break;

            pDataTmp = pDataTmp->pNext;
        }

        pCartList = pCartList->pNext;
    }

    CloseHandle(hOutput);

    HeapDestroy(hHeap);

    return  0;

}


BOOL
BiArgcheck(
    IN     INT    iArgc,
    IN     CHAR **ppArgv,
    IN OUT PWSTR   pwstrInFileName,
    IN OUT PWSTR   pwstrOutFileName)
/*++

Routine Description:

    iArgcheck

Arguments:

    iArgc - Number of parameters in the following
    ppArgv - The parameters, starting with our name
    pwstrInFileName -
    pwstrOutFileName -

Return Value:

    If TRUE, function succeeded. Othewise FALSE.

Note:


--*/
{
    INT iI;
    INT iRet;

    if (iArgc > 4 || iArgc < 3)
    {
        return  FALSE;
    }

    if (iArgc == 4)
    {
        gdwOutputFlags |= OUTPUT_VERBOSE;
        ppArgv++;
    }

    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrInFileName, FILENAME_SIZE);
    *(pwstrInFileName + iRet) = (WCHAR)NULL;
    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrOutFileName, FILENAME_SIZE);
    *(pwstrOutFileName + iRet) = (WCHAR)NULL;




    return TRUE;
}


PBYTE
PCreateUFFFileHeader(
    HANDLE hHeap,
    PFILELIST pFileList,
    PDWORD pdwUFFHeaderSize)
{
    HANDLE hFontFile;
    PDATAFILE pFontFile, pTransFile;
    PCARTLIST pCartList;
    PDATAFILE pDataTmp;
    PUFF_FILEHEADER pUFFHeader;
    PUFF_FONTDIRECTORY pUFFFontDir, pFirstFontDir;
    
    PBYTE pFontData;
    DWORD dwNumOfFontNameChars, dwNumOfData, dwNumOfFonts, dwNumOfTrans, dwUFFHeaderSize, dwFileSize, dwNumOfCartNameChars, dwI;
    DWORD dwOffset, offCartridgeName;
    PWSTR pwstrCartNameBuf, pwstrFontNameBuf;

    *pdwUFFHeaderSize = 0;

    dwNumOfFontNameChars = dwNumOfCartNameChars = dwNumOfFonts = dwNumOfTrans = 0;
    pCartList = pFileList->pCartList;
    while (pCartList)
    {
        pDataTmp = pCartList->pFontFile;
        while (pDataTmp)
        {
            dwNumOfFontNameChars += 1 + wcslen(pDataTmp->pwstrDataName);
            pDataTmp = pDataTmp->pNext;
            dwNumOfFonts ++;
        }

        pDataTmp = pCartList->pTransFile;
        while (pDataTmp)
        {
            pDataTmp = pDataTmp->pNext;
            dwNumOfTrans ++;
        }

        if (pCartList->pwstrCartName)
            dwNumOfCartNameChars += 1 + wcslen(pCartList->pwstrCartName);

        pCartList = pCartList->pNext;
    }

    dwNumOfData = dwNumOfFonts + dwNumOfTrans;

    dwUFFHeaderSize = sizeof(UFF_FILEHEADER) +
                      sizeof(UFF_FONTDIRECTORY) * dwNumOfFonts +
                      dwNumOfCartNameChars * sizeof(WCHAR) +
                      dwNumOfFontNameChars * sizeof(WCHAR);

    pUFFHeader = (PUFF_FILEHEADER)HeapAlloc(hHeap, 0, dwUFFHeaderSize);

    if (pUFFHeader == NULL)
    {
        return NULL;
    }

    //
    // Fill in header.
    //

    pUFFHeader->dwSignature = UFF_FILE_MAGIC;
    pUFFHeader->dwVersion   = UFF_VERSION_NUMBER;
    pUFFHeader->dwSize      = sizeof(UFF_FILEHEADER);
    pUFFHeader->nFonts      = dwNumOfFonts;
    pUFFHeader->nGlyphSets  = dwNumOfTrans;
    pUFFHeader->nVarData    = 0;
    pUFFHeader->offFontDir  = sizeof(UFF_FILEHEADER);
    pUFFHeader->dwFlags     = 0;
    pUFFHeader->dwReserved[0] = 0;
    pUFFHeader->dwReserved[1] = 0;
    pUFFHeader->dwReserved[2] = 0;
    pUFFHeader->dwReserved[3] = 0;


    //
    // Fill in UFF_FONTDIRECTORY
    //
    // ------------------
    // UFF_FONTHEADER
    // ------------------
    // UFF_FONTDIRECTORY * (Number of fonts)
    // ------------------
    // Cartridge name
    // ------------------
    // Font name
    // ------------------
    // First cartridge font data
    // ------------------
    // First cartridge glyph data
    // ------------------
    // Second cartridge font data
    // ------------------
    // Second cartridge glyph data
    // ------------------
    //

    pUFFFontDir = (PUFF_FONTDIRECTORY)(pUFFHeader + 1);
    pwstrCartNameBuf = (PWSTR)(pUFFFontDir + dwNumOfFonts);
    pwstrFontNameBuf = pwstrCartNameBuf + dwNumOfCartNameChars;
    pCartList = pFileList->pCartList;
    dwOffset = sizeof(UFF_FILEHEADER) +
               sizeof(UFF_FONTDIRECTORY) * dwNumOfFonts +
               dwNumOfCartNameChars * sizeof(WCHAR) +
               dwNumOfFontNameChars * sizeof(WCHAR);

    while(pCartList)
    {
        pFontFile  = pCartList->pFontFile;
        pTransFile = pCartList->pTransFile;
        pFirstFontDir = pUFFFontDir;
        if (pCartList->pwstrCartName)
        {
            offCartridgeName = (PBYTE)pwstrCartNameBuf - (PBYTE)pUFFHeader;
            wcscpy(pwstrCartNameBuf, pCartList->pwstrCartName);
            pwstrCartNameBuf += wcslen(pCartList->pwstrCartName) + 1;
        }
        else
            offCartridgeName = (DWORD)NULL;

        while (pFontFile)
        {
            hFontFile = MapFileIntoMemory(pFontFile->pwstrFileName,
                                          (PVOID)&pFontData,
                                          &dwFileSize );
            if (hFontFile)
            {
                pFontFile->dwSize = dwFileSize;

                if (1)
                {
                    pFontFile->dwSignature = DATA_IFI_SIG;
                    pFontFile->rcTrans = ((FI_DATA_HEADER*)pFontData)->u.sCTTid;
                }
                else
                {
                    pFontFile->dwSignature = DATA_UFM_SIG;
                    pFontFile->rcTrans = (SHORT)((UNIFM_HDR*)pFontData)->lGlyphSetDataRCID;
                }

                UnmapFileFromMemory(hFontFile);
            }
            else
                return NULL;


            pUFFFontDir->dwSignature    = FONT_REC_SIG;
            pUFFFontDir->wSize          = sizeof(UFF_FONTDIRECTORY);
            pUFFFontDir->wFontID        = (WORD)pFontFile->rcID;
            pUFFFontDir->sGlyphID       = (SHORT)pFontFile->rcTrans;
            pUFFFontDir->wFlags         = 0;
            pUFFFontDir->dwInstallerSig = WINNT_INSTALLER_SIG;

            if (pFontFile->pwstrDataName)
            {
                pUFFFontDir->offFontName = (PBYTE)pwstrFontNameBuf - (PBYTE)pUFFHeader;
                wcscpy(pwstrFontNameBuf, pFontFile->pwstrDataName);
                pwstrFontNameBuf += wcslen(pFontFile->pwstrDataName) + 1;
            }
            else
                pUFFFontDir->offFontName = (DWORD)NULL;

                
            pUFFFontDir->offCartridgeName = offCartridgeName;
            pUFFFontDir->offFontData      = dwOffset;
            pUFFFontDir->offGlyphData     = 0;
            pUFFFontDir->offVarData       = 0;
            pUFFFontDir++;

            dwOffset += pFontFile->dwSize + sizeof(DATA_HEADER);
            pFontFile = pFontFile->pNext;
        }
        while (pTransFile)
        {
            hFontFile = MapFileIntoMemory(pTransFile->pwstrFileName,
                                          (PVOID)&pFontData,
                                          &dwFileSize );
            if (1)
            {
                pTransFile->dwSignature = DATA_RLE_SIG;
            }
            else
                pTransFile->dwSignature = DATA_GTT_SIG;

            if (hFontFile)
            {
                pTransFile->dwSize = dwFileSize;
                while (pFirstFontDir < pUFFFontDir)
                {
                    if (pFirstFontDir->sGlyphID == (SHORT)pTransFile->rcID)
                        pFirstFontDir->offGlyphData = dwOffset;
                    pFirstFontDir ++;
                }
                dwOffset += dwFileSize + sizeof(DATA_HEADER);

                UnmapFileFromMemory(hFontFile);
            }
            else
                return NULL;

            pTransFile = pTransFile->pNext;
        }

        pCartList = pCartList->pNext;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        BDumpUFF(pUFFHeader);
    }

    *pdwUFFHeaderSize = dwUFFHeaderSize;

    return (PBYTE)pUFFHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\pfm2ufm\pfm2ufm.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    pfm2ufm.c

Abstract:

    Program to read Windows 16 PFM format data and convert to NT's
    IFIMETRICS data.  Note that since IFIMETRICS is somewhat more
    elaborate than PFM data,  some of the values are best guesses.
    These are made on the basis of educated guesses.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/16/96 -eigos-
        Created from rasdd.

--*/

#include        "precomp.h"

#if !defined(DEVSTUDIO) //  MDS doesn't need this stuff...

//
// Global variables
//

#define NUM_OF_ERROR1 15
static BYTE *gcstrError1[NUM_OF_ERROR1] = {
                 "Usage: pfm2ufm [-vcpf] [-s#] [-aCodePage] uniqname pfmfile [gttfile/codepage/predefined gtt id] ufmfile\n",
                 "   -v print out PFM and IFIMETRICS\n",
                 "   -c specify codepage instead of gtt file\n",
                 "   -p specify predefined gtt id instead of gtt file\n",
                 "   -f enable font simulation\n",
                 "   -a facename conversion to unicode using codepage\n",
                 "   -s# specify scaling option, can be -s0, -s1, -s2\n\n",
                 "   uniqname is used to create IFIMETRIC.dpwszUniqueName\n",
                 "   pfm_file is input, read only usage\n",
                 "   gtt_file is input, read only usage\n",
                 "   predefind gtt id can be -1,-2,-3,-10,-11,-13,-14,-15,-16,-17,-18\n",
                 "   ufm_file is output\n       Files must be different\n\n",
                 "   E.g.\n",
                 "   (Specify code page) pfm2ufm -c UniqName XXX.PFM 1452 XXX.UFM\n",
                 "   (Specify predefined gtt id) pfm2ufm -p UniqName XXX.PFM -13 XXX.UFM\n"
                 "   (FaceName codepage conversion) pfm2ufm -p -a437 UniqName XXX.PFM -1 XXX.UFM\n"
                 };
static BYTE gcstrError2[]    = "HeapCreate() fails in pfm2ufm.\n";
static BYTE gcstrError3[]    = "Cannot open input file: %ws.\n";
static BYTE gcstrError4[]    = "%ws is not a valid PFM file - ignored.\n";
static BYTE gcstrError5[]    = "Could not align PFM file.\n";
static BYTE gcstrError6[]    = "Failed to convert from FONTINFO to IFIMETRICS.\n";
static BYTE gcstrError7[]    = "Could not get font selection command\n";
static BYTE gcstrError8[]    = "Could not get font unselection command\n";
static BYTE gcstrError9[]    = "Could not open gtt file '%ws'\n";
static BYTE gcstrError10[]   = "Cannot convert PFM to UFM\n";
static BYTE gcstrError11[]   = "Cannot create output file: '%ws'\n";
static BYTE gcstrError12[]   = "Cannot write %ws data to output file.\n";
static BYTE gcstrError13[]   = "Invalid ctt id: %d\n";

static WCHAR *gwstrGTT[3]    = { TEXT("CP437_GTT"),
                                 TEXT("CP850_GTT"),
                                 TEXT("CP863_GTT") };

#define WRITEDATAINTOFILE(pData, dwSize, pwstrErrorStr) \
    if (!WriteFile(hUFMFile, \
                   (pData), \
                   (dwSize), \
                   &dwWrittenSize, \
                   NULL)) \
    { \
        fprintf(stderr, gcstrError12, (pwstrErrorStr)); \
        return -12; \
    }

#else

#define WRITEDATAINTOFILE(pData, dwSize) \
    if (!WriteFile(hUFMFile, \
                   (pData), \
                   (dwSize), \
                   &dwWrittenSize, \
                   NULL)) \
        return  FALSE;

#endif

DWORD gdwOutputFlags;

//
// Internal macros
//

#define FILENAME_SIZE 512

//
// Internal structure define
//

typedef VOID (*VPRINT) (char*,...);

//
// Internal function definition
//

VOID VPrintIFIMETRICS (IFIMETRICS*,    VPRINT);
VOID VPrintPFM        (PFMHEADER*,     VPRINT);
VOID VPrintPFMExt     (PFMEXTENSION*,  VPRINT);
VOID VPrintETM        (EXTTEXTMETRIC*, VPRINT);
VOID VPrintFontCmd    (CD*,            BOOL, VPRINT);
VOID VPrintKerningPair(w3KERNPAIR*,    DWORD, VPRINT);
VOID VPrintWidthTable (PSHORT,         DWORD, VPRINT);

BOOL BArgCheck(IN INT, IN CHAR**, OUT PWSTR, OUT PWSTR, OUT PWSTR, OUT PWSTR, OUT PDWORD);
BOOL BValidatePFM(BYTE *, DWORD);
DWORD DwGetCodePageFromCTTID(LONG);
DWORD DwGetCodePageFromGTTID(LONG);
INT ICodePage2GTTID( DWORD dwCodePage);
INT ICttID2GttID( LONG lPredefinedCTTID);

#if defined(DEVSTUDIO)

BOOL    BConvertPFM(LPBYTE  lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT, 
                    PWSTR pwstrUnique, LPSTR lpstrUFM, int iGTTID) {

    HANDLE            hHeap;
    HANDLE            hUFMFile;

    PUNI_GLYPHSETDATA pGlyph = (PUNI_GLYPHSETDATA) lpbGTT;
    EXTTEXTMETRIC     Etm;

    FONTOUT           FOutData;
    FONTIN            FInData;
    FONTMISC          FMiscData;

    DWORD             dwWrittenSize;

    //
    //  Create a heap.
    //

    if ( !(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )) )
        return FALSE;
    
    //
    // Init MiscData
    //

    FMiscData.pwstrUniqName = pwstrUnique;
    
    //
    // Init FInData
    //

    ZeroMemory( &FInData, sizeof(FONTIN));
    FInData.pETM = &Etm;

    //
    //  Convert PFM to UFM
    //

    if (!BConvertPFM2UFM(hHeap,
                         lpbPFM,
                         pGlyph,
                         dwCodePage,
                         &FMiscData,
                         &FInData,
                         iGTTID, 
                         &FOutData,
                         0L))
        return FALSE;

    //
    // Create the output file.
    //

    hUFMFile = CreateFileA( lpstrUFM,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          0 );

    if( hUFMFile == (HANDLE)-1 )
        return  FALSE;

    //
    // Write the output file.
    //

    //  First, tweak the GTT ID- the library code pulls it from the PFM,
    //  which may not be correct.

    WRITEDATAINTOFILE(&FOutData.UniHdr,     sizeof(UNIFM_HDR));
    WRITEDATAINTOFILE(&FOutData.UnidrvInfo, sizeof(UNIDRVINFO));

    if (FOutData.SelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.SelectFont.pCmdString,
                          FOutData.SelectFont.dwSize);
    }

    if (FOutData.UnSelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.UnSelectFont.pCmdString,
                          FOutData.UnSelectFont.dwSize);
    }

    //  Pad to get DWORD alignment

    SetFilePointer(hUFMFile, 
        FOutData.UnidrvInfo.dwSize - (sizeof FOutData.UnidrvInfo +
        FOutData.SelectFont.dwSize + FOutData.UnSelectFont.dwSize), NULL, 
        FILE_CURRENT);

    WRITEDATAINTOFILE(FOutData.pIFI, FOutData.dwIFISize);
    if  (FOutData.pETM) 
    {
        WRITEDATAINTOFILE(FOutData.pETM, sizeof(EXTTEXTMETRIC));
    }
    if (FOutData.dwWidthTableSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pWidthTable, FOutData.dwWidthTableSize);
    }
    if (FOutData.dwKernDataSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pKernData, FOutData.dwKernDataSize);
    }

    //  Clean it all up...

    CloseHandle(hUFMFile);
    HeapDestroy(hHeap);

    return  TRUE;

}

#else
// 
// Input data
//     Unique face name
//     ID string
//     pfm file name
//     gtt file name
//     ufm file name
//
// main function 
// 
// 1. Check argument. Unique facename, pfm filename, gtt file name, ufm filename
// 2. Open pfm file
// 3. PFM file validation
//     4. Align non-aligned PFM file 
//     5. Convert Fontinfo to Ifimetrics 
//     6. Get font selection/unselection command
//     7. Get kerning pair table and convert it to GTT base table
//     8. Get width table and convert it to GTT base table
// 9. Open UFM file
// 10. Write to UFM file
//

INT __cdecl
main(
    INT    iArgc,
    CHAR **ppArgv)
/*++

Routine Description:

    main function of pfm to unifm converter

Arguments:

    iArgc - the number of an argument
    ppArgv - the pointer to the argument string list

Return Value:

    0 if successful, otherwise failed to complete conversion

--*/

{
    HFILEMAP          hPFMFileMap;
    HFILEMAP          hGTTFileMap;
    HANDLE            hHeap;
    HANDLE            hUFMFile;

    PUNI_GLYPHSETDATA pGlyph;

    FONTOUT           FOutData;
    FONTIN            FInData;
    FONTMISC          FMiscData;

    EXTTEXTMETRIC     Etm;

    HMODULE           hModule;
    HRSRC             hRes;
    DWORD             dwOffset;
    DWORD             dwPFMSize;
    DWORD             dwGTTSize;
    DWORD             dwWrittenSize;
    DWORD             dwCodePage;
    DWORD             dwCodePageOfFacenameConv;
    DWORD             dwGTTID;
    LONG              lPredefinedCTTID;

    WCHAR             awchUniqName[FILENAME_SIZE];
    WCHAR             awchPFMFile[FILENAME_SIZE];
    WCHAR             awchGTTFile[FILENAME_SIZE];
    WCHAR             awchUFMFile[FILENAME_SIZE];

    DWORD             dwFlags = 0L;

    INT               iI, iGTTID;

    PBYTE             pPFMData;

    //RIP(("Start pfm2ufm\n"));

    //
    // Argument check
    //

    if (!BArgCheck(iArgc,
                   ppArgv,
                   awchUniqName,
                   awchPFMFile,
                   awchGTTFile,
                   awchUFMFile,
                   &dwCodePageOfFacenameConv))
    {
        for (iI = 0; iI < NUM_OF_ERROR1; iI ++)
        {
            fprintf( stderr, gcstrError1[iI]);
        }
        return -1;
    }

    //
    // Create a heap.
    //

    if ( !(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )) )
    {
        fprintf( stderr, gcstrError2);
        return -2;
    }

    //
    // Open PFM file
    //

    if( !(hPFMFileMap = MapFileIntoMemory(awchPFMFile,
                                          &pPFMData,
                                          &dwPFMSize)))
    {
        fprintf( stderr, gcstrError3, awchPFMFile );
        return -3;
    }

    //
    // PFM validation.
    // PFM Header, DRIVERINFO, PFMEXTENSION, DRIVERINFO_VERSION
    //

    if( !BValidatePFM( pPFMData, dwPFMSize ) )
    {
        fprintf( stderr, gcstrError4, awchPFMFile );
        return -4;
    }

    //
    // Open GTT file/Get codepage/predefined GTT
    //

    iGTTID = 0;

    pGlyph = NULL;

    if (gdwOutputFlags & OUTPUT_CODEPAGEMODE)
    {
        dwCodePage = _wtol(awchGTTFile);
        iGTTID = ICodePage2GTTID(dwCodePage);
    }
    else
    if (gdwOutputFlags & OUTPUT_PREDEFINED)
    {
        hModule = GetModuleHandle(TEXT("pfm2ufm.exe"));
        lPredefinedCTTID = _wtol(awchGTTFile);

        //
        // Bug support
        // Previous implementation only support plug value like
        // 1, 2, 3, 13, 263 etc.
        // We need to support this type still
        //

        if (lPredefinedCTTID > 0)
            lPredefinedCTTID = -lPredefinedCTTID;

        iGTTID = lPredefinedCTTID;

        //
        // UNI16 FE CTT ID handlig
        //
        if (-256 >= lPredefinedCTTID && lPredefinedCTTID >= -263)
        {
             //
             // CTT_BIG5      -261  // Chinese (PRC, Singapore)
             // CTT_ISC       -258  // Korean
             // CTT_JIS78     -256  // Japan
             // CTT_JIS83     -259  // Japan
             // CTT_JIS78_ANK -262  // Japan
             // CTT_JIS83_ANK -263  // Japan
             // CTT_NS86      -257  // Chinese (PRC, Singapore)
             // CTT_TCA       -260  // Chinese (PRC, Singapore)
             //
             gdwOutputFlags &= ~OUTPUT_PREDEFINED;
             gdwOutputFlags |= OUTPUT_CODEPAGEMODE;
             dwCodePage = DwGetCodePageFromCTTID(lPredefinedCTTID);
             iGTTID     = ICttID2GttID(lPredefinedCTTID);
        }
        else
        //
        // UNI32 GTTID handling
        //
        if (-18 <= iGTTID && iGTTID <= -10 ||
            -3  <= iGTTID && iGTTID <= -1   )
        {
            dwCodePage  = DwGetCodePageFromGTTID(iGTTID);
            if (-3 <= iGTTID && iGTTID <= -1)
            {
                if (lPredefinedCTTID)
                {
                    hRes = FindResource(hModule,
	        gwstrGTT[lPredefinedCTTID - 1],
	        TEXT("RC_GLYPH"));
                    pGlyph = (PUNI_GLYPHSETDATA)LoadResource(hModule, hRes);
                }
            }
        }
        else
        //
        // UNI16 US ID handling
        //
        if (1 <= lPredefinedCTTID || lPredefinedCTTID <= 3)
        {
            //
            // CC_CP437 -1
            // CC_CP850 -2
            // CC_CP863 -3
            //
            dwCodePage  = DwGetCodePageFromCTTID(lPredefinedCTTID);

            if (lPredefinedCTTID)
            {
                hRes = FindResource(hModule,
	    gwstrGTT[lPredefinedCTTID - 1],
	    TEXT("RC_GLYPH"));
                pGlyph = (PUNI_GLYPHSETDATA)LoadResource(hModule, hRes);
            }
        }
    }
    else
    {
        if( !(hGTTFileMap = MapFileIntoMemory(awchGTTFile,
                                              &pGlyph,
                                              &dwGTTSize)))
        {
            fprintf( stderr, gcstrError9, awchGTTFile );
            return -9;
        }

        dwCodePage = 0;
    }

    //
    // Init MiscData
    //

    FMiscData.pwstrUniqName = awchUniqName;

    //
    // Init FInData
    //

    ZeroMemory( &FInData, sizeof(FONTIN));
    FInData.pETM = &Etm;

    if ( gdwOutputFlags & OUTPUT_FONTSIM)
        FInData.dwFlags = FLAG_FONTSIM;
    else
        FInData.dwFlags = 0;
    
    if ( gdwOutputFlags & OUTPUT_FACENAME_CONV)
        FInData.dwCodePageOfFacenameConv = dwCodePageOfFacenameConv;
    else
        FInData.dwCodePageOfFacenameConv = 0;

    if ( gdwOutputFlags & OUTPUT_SCALING_ANISOTROPIC )
        dwFlags |= PFM2UFM_SCALING_ANISOTROPIC;
    else if ( gdwOutputFlags & OUTPUT_SCALING_ARB_XFORMS )
        dwFlags |= PFM2UFM_SCALING_ARB_XFORMS;

    //
    // Convert PFM to UFM
    //

    if (!BConvertPFM2UFM(hHeap,
                         pPFMData,
                         pGlyph,
                         dwCodePage,
                         &FMiscData,
                         &FInData,
                         iGTTID,
                         &FOutData,
                         dwFlags))
    {
        fprintf( stderr, gcstrError10 );
        return -10;
    }

    if (gdwOutputFlags & OUTPUT_PREDEFINED)
    {
        FreeResource(hRes);
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        VPrintPFM         (&FInData.PFMH, printf);
        VPrintPFMExt      (&FInData.PFMExt, printf);
        if (FInData.pETM)
        {
            VPrintETM         (FInData.pETM, printf);
        }
        VPrintFontCmd     (FInData.pCDSelectFont, TRUE, printf);
        VPrintFontCmd     (FInData.pCDUnSelectFont, FALSE, printf);
        VPrintKerningPair (FInData.pKernPair,
                           FInData.dwKernPairSize,
                           printf);
        VPrintWidthTable  (FInData.psWidthTable,
                           FInData.dwWidthTableSize,
                           printf);
        VPrintIFIMETRICS(FOutData.pIFI, printf);
    }

    //
    // Create the output file.
    //

    hUFMFile = CreateFile( awchUFMFile,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          0 );

    if( hUFMFile == (HANDLE)-1 )
    {
        fprintf( stderr, gcstrError11, awchUFMFile );
        return  -11;
    }

    //
    // Write the output file.
    //

    WRITEDATAINTOFILE(&FOutData.UniHdr,     sizeof(UNIFM_HDR),  L"UNIFM_HDR");
    WRITEDATAINTOFILE(&FOutData.UnidrvInfo, sizeof(UNIDRVINFO), L"UNIDRVINFO");

    if (FOutData.SelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.SelectFont.pCmdString,
                          FOutData.SelectFont.dwSize,
                          L"SelectFont");
    }

    if (FOutData.UnSelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.UnSelectFont.pCmdString,
                          FOutData.UnSelectFont.dwSize,
                          L"UnSelectFont");
    }

    //  Pad to get DWORD alignment

    SetFilePointer(hUFMFile, 
        FOutData.UnidrvInfo.dwSize - (sizeof FOutData.UnidrvInfo +
        FOutData.SelectFont.dwSize + FOutData.UnSelectFont.dwSize), NULL, 
        FILE_CURRENT);

    WRITEDATAINTOFILE(FOutData.pIFI, FOutData.dwIFISize, L"IFIMETRICS");
    if (FOutData.pETM != NULL)
    {
        WRITEDATAINTOFILE(FOutData.pETM, sizeof(EXTTEXTMETRIC), L"EXTEXTMETRIC");
    }
    if (FOutData.dwWidthTableSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pWidthTable, FOutData.dwWidthTableSize, L"WIDTHTABLE");
    }
    if (FOutData.dwKernDataSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pKernData, FOutData.dwKernDataSize, L"KERNDATA");
    }

    //
    //   All done,  so clean up and away
    //

    UnmapViewOfFile( hGTTFileMap );              /* Input no longer needed */

    UnmapViewOfFile( hPFMFileMap );              /* Input no longer needed */

    CloseHandle(hUFMFile);

    HeapDestroy( hHeap );               /* Probably not needed */

    return  0;
}

//
// Internal functions
//

BOOL
BValidatePFM(
    IN BYTE  *pBase,
    IN DWORD  dwSize)

/*++

Routine Description:

    Look at a memory mapped PFM file,  and see if it seems reasonable.

Arguments:

    pBase - base address of file
    dwSize - size of bytes available

Return Value:

    TRUE if successful, otherwise PFM file is invalid.

--*/

{
    res_PFMHEADER     *rpfm;     // In Win 3.1 format, UNALIGNED!!
    res_PFMEXTENSION  *rpfme;    // Final access to offset to DRIVERINFO
    DRIVERINFO         di;       // The actual DRIVERINFO data!
    DWORD              dwOffset; // Calculate offset of interest as we go


    //
    //    First piece of sanity checking is the size!  It must be at least
    //  as large as a PFMHEADER structure plus a DRIVERINFO structure.
    //

    if( dwSize < (sizeof( res_PFMHEADER ) +
                  sizeof( DRIVERINFO ) +
                  sizeof( res_PFMEXTENSION )) )
    {
        return  FALSE;
    }

    //
    //    Step along to find the DRIVERINFO structure, as this contains
    //  some identifying information that we match to look for legitimacy.
    //

    rpfm = (res_PFMHEADER *)pBase;           /* Looking for fixed pitch */

    dwOffset = sizeof( res_PFMHEADER );

    if( rpfm->dfPixWidth == 0 )
    {
        /*   Proportionally spaced, so allow for the width table too! */
        dwOffset += (rpfm->dfLastChar - rpfm->dfFirstChar + 2) *
                    sizeof( short );

    }

    rpfme = (res_PFMEXTENSION *)(pBase + dwOffset);

    //
    //   Next is the PFMEXTENSION data
    //

    dwOffset += sizeof( res_PFMEXTENSION );

    if( dwOffset >= dwSize )
    {
        return  FALSE;
    }

    dwOffset = DwAlign4( rpfme->b_dfDriverInfo );

    if( (dwOffset + sizeof( DRIVERINFO )) > dwSize )
    {
        return   FALSE;
    }

    //
    //    A memcpy is used because this data is typically not aigned. Ugh!
    //

    CopyMemory( &di, pBase + dwOffset, sizeof( di ) );


    if( di.sVersion > DRIVERINFO_VERSION )
    {
        return   FALSE;
    }

    return  TRUE;
}

BOOL
BCheckIFIMETRICS(
    IFIMETRICS *pIFI,
    VPRINT vPrint
    )
/*++

Routine Description:

    This is where you put sanity checks on an incomming IFIMETRICS structure.

Arguments:


Return Value:

    TRUE if successful, otherwise PFM file is invalid.

--*/

{
    BOOL bGoodPitch;

    BYTE jPitch = pIFI->jWinPitchAndFamily &
                  (DEFAULT_PITCH | FIXED_PITCH | VARIABLE_PITCH);


    if (pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
    {
        bGoodPitch = (jPitch == FIXED_PITCH);
    }
    else
    {
        bGoodPitch = (jPitch == VARIABLE_PITCH);
    }

    if (!bGoodPitch)
    {
        vPrint("\n\n<INCONSISTENCY DETECTED>\n");
        vPrint( "    jWinPitchAndFamily = %-#2x, flInfo = %-#8lx\n\n",
                    pIFI->jWinPitchAndFamily, pIFI->flInfo);

        return FALSE;
    }

    return TRUE;
}


BOOL
BArgCheck(
    IN  INT    iArgc,
    IN  CHAR **ppArgv,
    OUT PWSTR  pwstrUniqName,
    OUT PWSTR  pwstrPFMFile,
    OUT PWSTR  pwstrGTTFile,
    OUT PWSTR  pwstrUFMFile,
    OUT PDWORD pdwCodePageOfFacenameConv)
{

    DWORD dwI;
    PTSTR pstrCodePageOfFacenameConv;
    INT   iCount, iRet;

    ASSERT(pwstrUniqName != NULL ||
           pwstrPFMFile  != NULL ||
           pwstrGTTFile  != NULL ||
           pwstrUFMFile  != NULL  );


    if (iArgc < 5)
    {
        return FALSE;
    }

    ppArgv++;
    iArgc --;
    iCount = 0;

    while (iArgc > 0)
    {
        if ( (**ppArgv == '-' || **ppArgv == '/') &&

                // minus value GTT or CTT ID handling
             !(**ppArgv == '-' && 0x30 <= *(*ppArgv+1) && *(*ppArgv+1) <= 0x39)
           )
        {
            dwI = 1;
            while(*(*ppArgv+dwI))
            {
                switch(*(*ppArgv+dwI))
                {
                case 'v':
                    gdwOutputFlags |= OUTPUT_VERBOSE;
                    break;

                case 'c':
                    gdwOutputFlags |= OUTPUT_CODEPAGEMODE;
                    break;

                case 'p':
                    gdwOutputFlags |= OUTPUT_PREDEFINED;
                    break;

                case 'f':
                    gdwOutputFlags |= OUTPUT_FONTSIM;
                    break;

                case 'n':
                    gdwOutputFlags |= OUTPUT_FONTSIM_NONADD;
                    break;

                case 'a':
                    gdwOutputFlags |= OUTPUT_FACENAME_CONV;
                    pstrCodePageOfFacenameConv = (PTSTR)(*ppArgv + dwI + 1);
                    *pdwCodePageOfFacenameConv = (DWORD)atoi((const char*)pstrCodePageOfFacenameConv);
                    break;
                case 's':
                    if ('1' == *((PSTR)(*ppArgv + dwI + 1)))
                        gdwOutputFlags |= OUTPUT_SCALING_ANISOTROPIC;
                    else if ('2' == *((PSTR)(*ppArgv + dwI + 1)))
                        gdwOutputFlags |= OUTPUT_SCALING_ARB_XFORMS;
                    break;
                }
                dwI ++;
            }

            if ((gdwOutputFlags & (OUTPUT_PREDEFINED|OUTPUT_CODEPAGEMODE)) ==
                 (OUTPUT_PREDEFINED|OUTPUT_CODEPAGEMODE) )
            {
                return FALSE;
            }
        }
        else
        {
            if (iCount == 0)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrUniqName,
                                           FILENAME_SIZE);
                *(pwstrUniqName + iRet) = (WCHAR)NULL;
            }
            else if (iCount == 1)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrPFMFile,
                                           FILENAME_SIZE);
                *(pwstrPFMFile + iRet) = (WCHAR)NULL;

            }
            else if (iCount == 2)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrGTTFile,
                                           FILENAME_SIZE);
                *(pwstrGTTFile + iRet) = (WCHAR)NULL;
            }
            else if (iCount == 3)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrUFMFile,
                                           FILENAME_SIZE);
                *(pwstrUFMFile + iRet) = (WCHAR)NULL;
            }

            if (iRet == 0)
            {
                return FALSE;
            }

            iCount ++;
        }
        iArgc --;
        ppArgv++;
    }

    return TRUE;
}

//
// Verbose output functions
//

VOID
VPrintIFIMETRICS(
    IFIMETRICS *pIFI,
    VPRINT vPrint
    )
/*++

Routine Description:

    Dumps the IFMETERICS to the screen

Arguments:

    pIFI - pointer to IFIMETRICS
    vPrint - output function pointer

Return Value:

    None

--*/
{
    //
    // Convenient pointer to Panose number
    //

    PANOSE *ppan = &pIFI->panose;

    PWSTR pwszFamilyName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFamilyName);
    PWSTR pwszStyleName  = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszStyleName) ;
    PWSTR pwszFaceName   = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName)  ;
    PWSTR pwszUniqueName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszUniqueName);

    vPrint("********* IFIMETRICS ***************\n");
    vPrint("cjThis                 %-#8lx\n" , pIFI->cjThis );
    vPrint("cjIfiExtra             %-#8lx\n" , pIFI->cjIfiExtra);
    vPrint("pwszFamilyName         \"%ws\"\n", pwszFamilyName );

    if( pIFI->flInfo & FM_INFO_FAMILY_EQUIV )
    {
        /*  Aliasing is in effect!  */

        while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            vPrint("                               \"%ws\"\n", pwszFamilyName );
    }

    vPrint("pwszStyleName          \"%ws\"\n", pwszStyleName );
    vPrint("pwszFaceName           \"%ws\"\n", pwszFaceName );
    vPrint("pwszUniqueName         \"%ws\"\n", pwszUniqueName );
    vPrint("dpFontSim              %-#8lx\n" , pIFI->dpFontSim );
    vPrint("lEmbedId               %d\n",      pIFI->lEmbedId    );
    vPrint("lItalicAngle           %d\n",      pIFI->lItalicAngle);
    vPrint("lCharBias              %d\n",      pIFI->lCharBias   );
    vPrint("dpCharSets             %d\n",      pIFI->dpCharSets   );
    vPrint("jWinCharSet            %04x\n"   , pIFI->jWinCharSet );
    vPrint("jWinPitchAndFamily     %04x\n"   , pIFI->jWinPitchAndFamily );
    vPrint("usWinWeight            %d\n"     , pIFI->usWinWeight );
    vPrint("flInfo                 %-#8lx\n" , pIFI->flInfo );
    vPrint("fsSelection            %-#6lx\n" , pIFI->fsSelection );
    vPrint("fsType                 %-#6lx\n" , pIFI->fsType );
    vPrint("fwdUnitsPerEm          %d\n"     , pIFI->fwdUnitsPerEm );
    vPrint("fwdLowestPPEm          %d\n"     , pIFI->fwdLowestPPEm );
    vPrint("fwdWinAscender         %d\n"     , pIFI->fwdWinAscender );
    vPrint("fwdWinDescender        %d\n"     , pIFI->fwdWinDescender );
    vPrint("fwdMacAscender         %d\n"     , pIFI->fwdMacAscender );
    vPrint("fwdMacDescender        %d\n"     , pIFI->fwdMacDescender );
    vPrint("fwdMacLineGap          %d\n"     , pIFI->fwdMacLineGap );
    vPrint("fwdTypoAscender        %d\n"     , pIFI->fwdTypoAscender );
    vPrint("fwdTypoDescender       %d\n"     , pIFI->fwdTypoDescender );
    vPrint("fwdTypoLineGap         %d\n"     , pIFI->fwdTypoLineGap );
    vPrint("fwdAveCharWidth        %d\n"     , pIFI->fwdAveCharWidth );
    vPrint("fwdMaxCharInc          %d\n"     , pIFI->fwdMaxCharInc );
    vPrint("fwdCapHeight           %d\n"     , pIFI->fwdCapHeight );
    vPrint("fwdXHeight             %d\n"     , pIFI->fwdXHeight );
    vPrint("fwdSubscriptXSize      %d\n"     , pIFI->fwdSubscriptXSize );
    vPrint("fwdSubscriptYSize      %d\n"     , pIFI->fwdSubscriptYSize );
    vPrint("fwdSubscriptXOffset    %d\n"     , pIFI->fwdSubscriptXOffset );
    vPrint("fwdSubscriptYOffset    %d\n"     , pIFI->fwdSubscriptYOffset );
    vPrint("fwdSuperscriptXSize    %d\n"     , pIFI->fwdSuperscriptXSize );
    vPrint("fwdSuperscriptYSize    %d\n"     , pIFI->fwdSuperscriptYSize );
    vPrint("fwdSuperscriptXOffset  %d\n"     , pIFI->fwdSuperscriptXOffset);
    vPrint("fwdSuperscriptYOffset  %d\n"     , pIFI->fwdSuperscriptYOffset);
    vPrint("fwdUnderscoreSize      %d\n"     , pIFI->fwdUnderscoreSize );
    vPrint("fwdUnderscorePosition  %d\n"     , pIFI->fwdUnderscorePosition);
    vPrint("fwdStrikeoutSize       %d\n"     , pIFI->fwdStrikeoutSize );
    vPrint("fwdStrikeoutPosition   %d\n"     , pIFI->fwdStrikeoutPosition );
    vPrint("chFirstChar            %-#4x\n"  , (int) (BYTE) pIFI->chFirstChar );
    vPrint("chLastChar             %-#4x\n"  , (int) (BYTE) pIFI->chLastChar );
    vPrint("chDefaultChar          %-#4x\n"  , (int) (BYTE) pIFI->chDefaultChar );
    vPrint("chBreakChar            %-#4x\n"  , (int) (BYTE) pIFI->chBreakChar );
    vPrint("wcFirsChar             %-#6x\n"  , pIFI->wcFirstChar );
    vPrint("wcLastChar             %-#6x\n"  , pIFI->wcLastChar );
    vPrint("wcDefaultChar          %-#6x\n"  , pIFI->wcDefaultChar );
    vPrint("wcBreakChar            %-#6x\n"  , pIFI->wcBreakChar );
    vPrint("ptlBaseline            {%d,%d}\n"  , pIFI->ptlBaseline.x,
            pIFI->ptlBaseline.y );
    vPrint("ptlAspect              {%d,%d}\n"  , pIFI->ptlAspect.x,
            pIFI->ptlAspect.y );
    vPrint("ptlCaret               {%d,%d}\n"  , pIFI->ptlCaret.x,
            pIFI->ptlCaret.y );
    vPrint("rclFontBox             {%d,%d,%d,%d}\n",pIFI->rclFontBox.left,
                                                    pIFI->rclFontBox.top,
                                                    pIFI->rclFontBox.right,
                                                    pIFI->rclFontBox.bottom );
    vPrint("achVendId              \"%c%c%c%c\"\n",pIFI->achVendId[0],
                                               pIFI->achVendId[1],
                                               pIFI->achVendId[2],
                                               pIFI->achVendId[3] );
    vPrint("cKerningPairs          %d\n"     , pIFI->cKerningPairs );
    vPrint("ulPanoseCulture        %-#8lx\n" , pIFI->ulPanoseCulture);
    vPrint(
           "panose                 {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                             , ppan->bFamilyType
                                             , ppan->bSerifStyle
                                             , ppan->bWeight
                                             , ppan->bProportion
                                             , ppan->bContrast
                                             , ppan->bStrokeVariation
                                             , ppan->bArmStyle
                                             , ppan->bLetterform
                                             , ppan->bMidline
                                             , ppan->bXHeight );
    BCheckIFIMETRICS(pIFI, vPrint);
}

VOID
VPrintPFM(
    PFMHEADER *pPFMHdr,
    VPRINT vPrint)
/*++

Routine Description:

    Dumps the PFM to the screen

Arguments:

    pFInData - pointer to FONTIN
    vPrint - output function pointer

Return Value:

    None

--*/
{

    vPrint("*************************************************************\n");
    vPrint(" PFM HEADER\n");
    vPrint("*************************************************************\n");
    vPrint("PFM.dfType            =  %d\n", pPFMHdr->dfType);
    vPrint("PFM.dfPoints          =  %d\n", pPFMHdr->dfPoints);
    vPrint("PFM.dfVertRes         =  %d\n", pPFMHdr->dfVertRes);
    vPrint("PFM.dfHorizRes        =  %d\n", pPFMHdr->dfHorizRes);
    vPrint("PFM.dfAscent          =  %d\n", pPFMHdr->dfAscent);
    vPrint("PFM.dfInternalLeading =  %d\n", pPFMHdr->dfInternalLeading);
    vPrint("PFM.dfExternalLeading =  %d\n", pPFMHdr->dfExternalLeading);
    vPrint("PFM.dfItalic          =  %d\n", pPFMHdr->dfItalic);
    vPrint("PFM.dfUnderline       =  %d\n", pPFMHdr->dfUnderline);
    vPrint("PFM.dfStrikeOut       =  %d\n", pPFMHdr->dfStrikeOut);
    vPrint("PFM.dfWeight          =  %d\n", pPFMHdr->dfWeight);
    vPrint("PFM.dfCharSet         =  %d\n", pPFMHdr->dfCharSet);
    vPrint("PFM.dfPixWidth        =  %d\n", pPFMHdr->dfPixWidth);
    vPrint("PFM.dfPixHeight       =  %d\n", pPFMHdr->dfPixHeight);
    vPrint("PFM.dfPitchAndFamily  =  %d\n", pPFMHdr->dfPitchAndFamily);
    vPrint("PFM.dfAvgWidth        =  %d\n", pPFMHdr->dfAvgWidth);
    vPrint("PFM.dfMaxWidth        =  %d\n", pPFMHdr->dfMaxWidth);
    vPrint("PFM.dfFirstChar       =  %d\n", pPFMHdr->dfFirstChar);
    vPrint("PFM.dfLastChar        =  %d\n", pPFMHdr->dfLastChar);
    vPrint("PFM.dfDefaultChar     =  %d\n", pPFMHdr->dfDefaultChar);
    vPrint("PFM.dfBreakChar       =  %d\n", pPFMHdr->dfBreakChar);
    vPrint("PFM.dfWidthBytes      =  %d\n", pPFMHdr->dfWidthBytes);
    vPrint("PFM.dfDevice          =  %d\n", pPFMHdr->dfDevice);
    vPrint("PFM.dfFace            =  %d\n", pPFMHdr->dfFace);
    vPrint("PFM.dfBitsPointer     =  %d\n", pPFMHdr->dfBitsPointer);


}

VOID
VPrintPFMExt(
    PFMEXTENSION *pPFMExt,
    VPRINT        vPrint)
{
    vPrint("*************************************************************\n");
    vPrint(" PFM EXTENSION\n");
    vPrint("*************************************************************\n");
    vPrint("PFMExt.dfSizeFields       =  %d\n", pPFMExt->dfSizeFields);
    vPrint("PFMExt.dfExtMetricsOffset =  %d\n", pPFMExt->dfExtMetricsOffset);
    vPrint("PFMExt.dfExtentTable      =  %d\n", pPFMExt->dfExtentTable);
    vPrint("PFMExt.dfOriginTable      =  %d\n", pPFMExt->dfOriginTable);
    vPrint("PFMExt.dfPairKernTable    =  %d\n", pPFMExt->dfPairKernTable);
    vPrint("PFMExt.dfTrackKernTable   =  %d\n", pPFMExt->dfTrackKernTable);
    vPrint("PFMExt.dfDriverInfo       =  %d\n", pPFMExt->dfDriverInfo);
    vPrint("PFMExt.dfReserved         =  %d\n", pPFMExt->dfReserved);
}

VOID
VPrintETM(
    EXTTEXTMETRIC *pETM,
    VPRINT         vPrint)
{
    vPrint("*************************************************************\n");
    vPrint(" EXTTEXTMETRIC\n");
    vPrint("*************************************************************\n");
    vPrint("pETM->emSize                       = %d\n", pETM->emSize);
    vPrint("pETM->emPointSize                  = %d\n", pETM->emPointSize);
    vPrint("pETM->emOrientation                = %d\n", pETM->emOrientation);
    vPrint("pETM->emMasterHeight               = %d\n", pETM->emMasterHeight);
    vPrint("pETM->emMinScale                   = %d\n", pETM->emMinScale);
    vPrint("pETM->emMaxScale                   = %d\n", pETM->emMaxScale);
    vPrint("pETM->emMasterUnits                = %d\n", pETM->emMasterUnits);
    vPrint("pETM->emCapHeight                  = %d\n", pETM->emCapHeight);
    vPrint("pETM->emXHeight                    = %d\n", pETM->emXHeight);
    vPrint("pETM->emLowerCaseAscent            = %d\n", pETM->emLowerCaseAscent);
    vPrint("pETM->emLowerCaseDescent           = %d\n", pETM->emLowerCaseDescent);
    vPrint("pETM->emSlant                      = %d\n", pETM->emSlant);
    vPrint("pETM->emSuperScript                = %d\n", pETM->emSuperScript);
    vPrint("pETM->emSubScript                  = %d\n", pETM->emSubScript);
    vPrint("pETM->emSuperScriptSize            = %d\n", pETM->emSuperScriptSize);
    vPrint("pETM->emSubScriptSize              = %d\n", pETM->emSubScriptSize);
    vPrint("pETM->emUnderlineOffset            = %d\n", pETM->emUnderlineOffset);
    vPrint("pETM->emUnderlineWidth             = %d\n", pETM->emUnderlineWidth);
    vPrint("pETM->emDoubleUpperUnderlineOffset = %d\n", pETM->emDoubleUpperUnderlineOffset);
    vPrint("pETM->emDoubleLowerUnderlineOffset = %d\n", pETM->emDoubleLowerUnderlineOffset);
    vPrint("pETM->emDoubleUpperUnderlineWidth  = %d\n", pETM->emDoubleUpperUnderlineWidth);
    vPrint("pETM->emDoubleLowerUnderlineWidth  = %d\n", pETM->emDoubleLowerUnderlineWidth);
    vPrint("pETM->emStrikeOutOffset            = %d\n", pETM->emStrikeOutOffset);
    vPrint("pETM->emStrikeOutWidth             = %d\n", pETM->emStrikeOutWidth);
    vPrint("pETM->emKernPairs                  = %d\n", pETM->emKernPairs);
    vPrint("pETM->emKernTracks                 = %d\n", pETM->emKernTracks);
}

VOID
VPrintFontCmd(
    CD     *pCD,
    BOOL    bSelect,
    VPRINT  vPrint)
{
    INT   iI;
    PBYTE pCommand;

    if (!pCD)
        return;

    pCommand = (PBYTE)(pCD + 1);

    if (!pCD->wLength)
    {
        return;
    }

    if (bSelect)
    {
        vPrint("*************************************************************\n");
        vPrint(" COMMAND\n");
        vPrint("*************************************************************\n");

        vPrint("Font Select Command = ");
    }
    else
    {
        vPrint("Font UnSelect Command = ");
    }

    for (iI = 0; iI < pCD->wLength; iI ++, pCommand++)
    {
        if (*pCommand < 0x20 || 0x7e < *pCommand )
        {
            vPrint("\\x%X",*pCommand);
        }
        else
        {
            vPrint("%c",*pCommand);
        }
    }

    vPrint("\n");
}

VOID
VPrintKerningPair(
    w3KERNPAIR *pKernPair,
    DWORD       dwKernPairSize,
    VPRINT      vPrint)
{
}

VOID
VPrintWidthTable(
    PSHORT psWidthTable,
    DWORD  dwWidthTableSize,
    VPRINT vPrint)
{
}

#endif  //  defined(DEVSTUDIO)

DWORD
DwGetCodePageFromGTTID(
    LONG lPredefinedGTTID)
{
    DWORD dwRet;
    switch(lPredefinedGTTID)
    {
        case CC_CP437:
            dwRet = 437;
            break;

        case CC_CP850:
            dwRet = 850;
            break;

        case CC_CP863:
            dwRet = 863;
            break;

        case CC_BIG5:
            dwRet = 950;
            break;

        case CC_ISC:
            dwRet = 949;
            break;

        case CC_JIS:
            dwRet = 932;
            break;

        case CC_JIS_ANK:
            dwRet = 932;
            break;

        case CC_NS86:
            dwRet = 949;
            break;

        case CC_TCA:
            dwRet = 950;
            break;

        case CC_GB2312:
            dwRet = 936;
            break;

        case CC_SJIS:
            dwRet = 932;
            break;

        case CC_WANSUNG:
            dwRet = 949;
            break;

        default:
            dwRet =1252;
            break;

    }
    return dwRet;
}

DWORD
DwGetCodePageFromCTTID(
    LONG lPredefinedCTTID)
{
    DWORD dwRet;

    switch (lPredefinedCTTID)
    {
    case CTT_CP437:
        dwRet = 437;
        break;

    case CTT_CP850:
        dwRet = 850;
        break;

    case CTT_CP863:
        dwRet = 863;
        break;

    case CTT_BIG5:
        dwRet = 950;
        break;

    case CTT_ISC:
        dwRet = 949;
        break;

    case CTT_JIS78:
        dwRet = 932;
        break;

    case CTT_JIS83:
        dwRet = 932;
        break;

    case CTT_JIS78_ANK:
        dwRet = 932;
        break;

    case CTT_JIS83_ANK:
        dwRet = 932;
        break;

    case CTT_NS86:
        dwRet = 950;
        break;

    case CTT_TCA:
        dwRet = 950;
        break;
    default:
        dwRet = 1252;
        break;
    }

    return dwRet;
}

INT ICodePage2GTTID(
    DWORD dwCodePage)
{
    INT iRet;

    switch (dwCodePage)
    {
    case 1252:
        iRet = 0;
        break;

    case 950:
        iRet = CC_BIG5;
        break;

    case 949:
        iRet = CC_WANSUNG;
        break;

    case 932:
        iRet = CC_JIS_ANK;
        break;

    default:
        iRet = 0;
        break;
    }

    return iRet;
}

INT ICttID2GttID(
    LONG lPredefinedCTTID)
{
    INT iRet = lPredefinedCTTID;
    switch (lPredefinedCTTID)
    {

    case CTT_CP437:
        iRet = CC_CP437;
        break;

    case CTT_CP850:
        iRet = CC_CP850;
        break;

    case CTT_CP863:
        iRet = CC_CP863;
        break;

    case CTT_BIG5:
        iRet = CC_BIG5;
        break;

    case CTT_ISC:
        iRet = CC_ISC;
        break;

    case CTT_JIS78:
        iRet = CC_JIS;
        break;

    case CTT_JIS83:
        iRet = CC_JIS;
        break;

    case CTT_JIS78_ANK:
        iRet = CC_JIS_ANK;
        break;

    case CTT_JIS83_ANK:
        iRet = CC_JIS_ANK;
        break;

    case CTT_NS86:
        iRet = CC_NS86;
        break;

    case CTT_TCA:
        iRet = CC_TCA;
        break;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\pclxl\pclxl.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    pclxl.c

Abstract:

    PCL XL dump tool

Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE       256

#define OUTPUT_VERBOSE      0x01

//
// Error messages
//

#define ERROR_INVALID_ARGUMENT      -1
#define ERROR_OPENFILE              -2
#define ERROR_HEAP_CREATE           -3
#define ERROR_PARSE_XL_DATA         -4
#define ERROR_HEAP_ALLOC            -5

#define ARGUMENT_ERR_MSG_LINE        1

const BYTE *gcstrArgumentError[ARGUMENT_ERR_MSG_LINE] = {
    "Usage: pclxl [output data]\n"
};


const BYTE gcstrOpenFileFailure[]   = "Cannot open file \"%ws\".\n";
const BYTE gcstrHeapCreateFailure[] = "Failed to Create Heap.\a";
const BYTE gcstrHeapAlloc[]         = "Failed to allocate memory.\n";
const BYTE gcstrParseError[]        = "Failed to parse data.\n";

//
// Globals
//

DWORD gdwOutputFlags;
DWORD gdwStatusFlags;

#define STATUS_ARRAY             0x01
#define STATUS_EMBEDED_DATA      0x02
#define STATUS_EMBEDED_DATA_BYTE 0x03

#if 0
//
// Binary Stream Tag Values
//

//
const BYTE gcstrNULL[] = "NULL"; // 0x00         White Space  NULL

//
// 0x01 - 0x08  Not Used
//
const BYTE gcstrHT[] = "HT"; // 0x09
const BYTE gcstrLF[] = "LF"; // 0x0a
const BYTE gcstrVT[] = "VT"; // 0x0b
const BYTE gcstrFF[] = "FF"; // 0x0c
const BYTE gcstrCR[] = "CR"; // 0x0d
// 0x09 - 0x0d  White Space  HT, LF, VT, FF, CR
//
// 0x0e - 0x1f  Not Used
//
const BYTE gcstrSP[] = "SP"; // 0x20
// 0x20         White Space  Space
//
// 0x21 - 0x26  Not Used
//
// 0x27         Reserved for Beginning of ASCII binding.
// 0x28         Reserved for Beginning of binary binding - high byte first.
// 0x29         Reserved for Beginning of binary binding - low byte first.
//
// 0x41 - 0xb9  Operators
//
const BYTE gcstrBeginSession[] = "BeginSession";
const BYTE gcstrEndSession[] = "EndSession";
const BYTE gcstrBeginPage[] = "BeginPage";
const BYTE gcstrEndPage[] = "EndPage";
// 0x45
// 0x46
const BYTE gcstrComment[] = "Comment";
const BYTE gcstrOpenDataSource[] = "OpenDataSource";
const BYTE gcstrCloseDataSource[] = "ClosedataSource";
// 0x4a
// 0x4b
// 0x4c
// 0x4d
// 0x4e
const BYTE gcstrBeginFontHeader[] = "BeginFontHeader";
const BYTE gcstrReadFontHeader[] = "ReadFontHeader";
const BYTE gcstrEndFontHeader[] = "EndFontHeader";
const BYTE gcstrBeginChar[] = "BeginChar";
const BYTE gcstrReadChar[] = "ReadChar";
const BYTE gcstrEndChar[] = "EndChar";
const BYTE gcstrRemoveFont[] = "RemoveFont";
// 0x56
// 0x57
// 0x58
// 0x59
// 0x5a
const BYTE gcstrBeginStream[] = "BeginStream";
const BYTE gcstrReadStream[] = "ReadStream";
const BYTE gcstrEndStream[] = "EndStream";
const BYTE gcstrExecStream[] = "ExecStresm";
// 0x5f
const BYTE gcstrPopGS[] = "PopGS";
const BYTE gcstrPushGS[] = "PushGS";
const BYTE gcstrSetClipReplace[] = "SetClipReplace";
const BYTE gcstrSetBrushSource[] = "SetBrushSource";
const BYTE gcstrSetCharAngle[] = "SetCharAngle";
const BYTE gcstrSetCharScale[] = "SetCharScale";
const BYTE gcstrSetCharShear[] = "SetCharShear";
const BYTE gcstrSetClipIntersect[] = "SetClipIntersect";
const BYTE gcstrSetClipRectangle[] = "SetClipRectangle";
const BYTE gcstrSetClipToPage[] = "SetClipToPage";
const BYTE gcstrSetColorSpace[] = "SetColorSpace";
const BYTE gcstrSetCursor[] = "SetCursor";
const BYTE gcstrSetCursorRel[] = "SetCursorRel";
const BYTE gcstrSetHalftoneMethod[] = "SetHalftoneMethod";
const BYTE gcstrSetFillMode[] = "SetFillMode";
const BYTE gcstrSetFont[] = "SetFont";
const BYTE gcstrSetLineDash[] = "SetLineDash";
const BYTE gcstrSetLineCap[] = "SetLineCap";
const BYTE gcstrSetLineJoin[] = "SetLineJoin";
const BYTE gcstrSetMiterLimit[] = "SetMitterLimit";
const BYTE gcstrSetPageDefaultCTM[] = "SetPageDefaultCTM";
const BYTE gcstrSetPageOrigin[] = "SetPageOrigin";
const BYTE gcstrSetPageRotation[] = "SetPageRotation";
const BYTE gcstrSetPageScale[] = "SetPageScale";
const BYTE gcstrSetPatternTxMode[] = "SetPatternTxMode";
const BYTE gcstrSetPenSource[] = "SetPenSource";
const BYTE gcstrSetPenWidth[] = "SetPenWidth";
const BYTE gcstrSetROP[] = "SetROP";
const BYTE gcstrSetSourceTxMode[] = "SetSourceTxMode";
const BYTE gcstrSetCharBoldValue[] = "SetCharBoldValue";
// 0x7e
const BYTE gcstrSetClipMode[] = "SetClipMode";
const BYTE gcstrSetPathToClip[] = "SetPathToClip";
const BYTE gcstrSetCharSubMode[] = "SetCharSubMode";
// 0x82
// 0x83
const BYTE gcstrCloseSubPath[] = "CloseSubPath";
const BYTE gcstrNewPath[] = "NewPath";
const BYTE gcstrPaintPath[] = "PaintPath";
// 0x87
// 0x88
// 0x89
// 0x8a
// 0x8b
// 0x8c
// 0x8d
// 0x8e
// 0x8f
// 0x90
const BYTE gcstrArcPath[] = "ArcPath";
// 0x92
const BYTE gcstrBezierPath[] = "BezierPath";
// 0x94
const BYTE gcstrBezierRelPath[] = "BezierRelPath";
const BYTE gcstrChord[] = "Chord";
const BYTE gcstrChordPath[] = "ChordPath";
const BYTE gcstrEllipse[] = "Ellipse";
const BYTE gcstrEllipsePath[] = "EliipsePath";
// 0x9a
const BYTE gcstrLinePath[] = "LinePath";
// 0x9c
const BYTE gcstrLineRelPath[] = "LineRelPath";
const BYTE gcstrPie[] = "Pie";
const BYTE gcstrPiePath[] = "PiePath";
const BYTE gcstrRectangle[] = "Rectangle";
const BYTE gcstrRectanglePath[] = "RectanglePath";
const BYTE gcstrRoundRectangle[] = "RoundRectangle";
const BYTE gcstrRoundRectanglePath[] = "RoudnRectanglePath";
// 0xa4
// 0xa5
// 0xa6
// 0xa7
const BYTE gcstrText[] = "Text";
const BYTE gcstrTextPath[] = "TextPath";
// 0xa8
// 0xa9
// 0xaa
// 0xab
// 0xac
// 0xad
// 0xae
// 0xaf
const BYTE gcstrBeginImage[] = "BeginImage";
const BYTE gcstrReadImage[] = "ReadImage";
const BYTE gcstrEndImage[] = "EndImage";
const BYTE gcstrBeginRestPattern[] = "BeginRestPattern";
const BYTE gcstrReadRastPattern[] = "ReadRastPattern";
const BYTE gcstrEndRastPattern[] = "EndRastPattern";
const BYTE gcstrBeginScan[] = "BeginScan";
// 0xb7
const BYTE gcstrEndScan[] = "EndScan";
const BYTE gcstrScanLineRel[] = "ScanLineRel";

// 0xba - 0xbf  Reserved for future use.
// 0xc0         ubyte
// 0xc1         uint16
// 0xc2         uint32
// 0xc3         sint16
// 0xc4         sint32
// 0xc5         real32
// 0xc6
// 0xc7
// 0xc8         ubyte_array
// 0xc9         uint16_array
// 0xca         uint32_array
// 0xcb         sint16_array
// 0xcc         sint32_array
// 0xcd         real32_array
// 0xce
// 0xcf
// 0xd0         ubyte_xy
// 0xd1         uint16_xy
// 0xd2         uint32_xy
// 0xd3         sint16_xy
// 0xd4         sint32_xy
// 0xd5         real32_xy
// 0xd6
// 0xd7
// 0xd8
// 0xd9
// 0xda
// 0xdb
// 0xdc
// 0xdd
// 0xde
// 0xdf
// 0xe0         ubyte_box
// 0xe1         uint16_box
// 0xe2         uint32_box
// 0xe3         sint16_box
// 0xe4         sint32_box
// 0xe5         real32_box
//
// 0xe6 - 0xef  Reserved form future use.
//
// 0xf0 - 0xf7  Reserved form future use.
//
// 0xf8         attr_ubyte
// 0xf9         attr_uint16
//
// 0xfa         dataLength  Embedded Data Follows
//
// 0xfb         dataLengthByte Emmedded Data Follows (0-255 bytes)
//
// 0xfc - 0xff  Reserved for future use.
//
//
#endif

typedef enum _TAG_TYPE { NotUsed, WhiteSpace, Operator, DataType, Attribute, EmbedData, Binding, Reserved} TAG_TYPE;

typedef struct _BINARY_TAG {
    TAG_TYPE TagType;
    PBYTE pubTagName;
} BINARY_TAG, *PBINARY_TAG;

const BINARY_TAG
BinaryTagArray[256] = {
    {WhiteSpace, "NULL"  },// 0x00
    {NotUsed,  NULL         },// 0x01
    {NotUsed,  NULL         },// 0x02
    {NotUsed,  NULL         },// 0x03
    {NotUsed,  NULL         },// 0x04
    {NotUsed,  NULL         },// 0x05
    {NotUsed,  NULL         },// 0x06
    {NotUsed,  NULL         },// 0x07
    {NotUsed,  NULL         },// 0x08
    {WhiteSpace, "HT"    },// 0x09
    {WhiteSpace, "LF"    },// 0x0a
    {WhiteSpace, "VT"    },// 0x0b
    {WhiteSpace, "FF"    },// 0x0c
    {WhiteSpace, "CR"    },// 0x0d
    {NotUsed,  NULL         },// 0x0e
    {NotUsed,  NULL         },// 0x0f

    {NotUsed,  NULL         },// 0x10
    {NotUsed,  NULL         },// 0x11
    {NotUsed,  NULL         },// 0x12
    {NotUsed,  NULL         },// 0x13
    {NotUsed,  NULL         },// 0x14
    {NotUsed,  NULL         },// 0x15
    {NotUsed,  NULL         },// 0x16
    {NotUsed,  NULL         },// 0x17
    {NotUsed,  NULL         },// 0x18
    {NotUsed,  NULL         },// 0x19
    {NotUsed,  NULL         },// 0x1a
    {NotUsed,  NULL         },// 0x1b
    {NotUsed,  NULL         },// 0x1c
    {NotUsed,  NULL         },// 0x1d
    {NotUsed,  NULL         },// 0x1e
    {NotUsed,  NULL         },// 0x1f

    {WhiteSpace, "SP"    },// 0x20
    {NotUsed,  NULL         },// 0x21
    {NotUsed,  NULL         },// 0x22
    {NotUsed,  NULL         },// 0x23
    {NotUsed,  NULL         },// 0x24
    {NotUsed,  NULL         },// 0x25
    {NotUsed,  NULL         },// 0x26
    {Binding,  NULL         },// 0x27
    {Binding,  NULL         },// 0x28
    {Binding,  NULL         },// 0x29
    {NotUsed,  NULL         },// 0x2a
    {NotUsed,  NULL         },// 0x2b
    {NotUsed,  NULL         },// 0x2c
    {NotUsed,  NULL         },// 0x2d
    {NotUsed,  NULL         },// 0x2e
    {NotUsed,  NULL         },// 0x2f

    {NotUsed,  NULL         },// 0x30
    {NotUsed,  NULL         },// 0x31
    {NotUsed,  NULL         },// 0x32
    {NotUsed,  NULL         },// 0x33
    {NotUsed,  NULL         },// 0x34
    {NotUsed,  NULL         },// 0x35
    {NotUsed,  NULL         },// 0x36
    {NotUsed,  NULL         },// 0x37
    {NotUsed,  NULL         },// 0x38
    {NotUsed,  NULL         },// 0x39
    {NotUsed,  NULL         },// 0x3a
    {NotUsed,  NULL         },// 0x3b
    {NotUsed,  NULL         },// 0x3c
    {NotUsed,  NULL         },// 0x3d
    {NotUsed,  NULL         },// 0x3e
    {NotUsed,  NULL         },// 0x3f

    {NotUsed,  NULL         },// 0x40
    {Operator, "BeginSession"        },// 0x41
    {Operator, "EndSession"          },// 0x42
    {Operator, "BeginPage"         },// 0x43
    {Operator, "EndPage"         },// 0x44
    {Operator, NULL         },// 0x45
    {Operator, NULL         },// 0x46
    {Operator, "Comment"         },// 0x47
    {Operator, "OpenDataSource"         },// 0x48
    {Operator, "CloseDataSource" },// 0x49
    {Operator, NULL         },// 0x4a
    {Operator, NULL         },// 0x4b
    {Operator, NULL         },// 0x4c
    {Operator, NULL         },// 0x4d
    {Operator, NULL         },// 0x4e
    {Operator, "BeginFontHeader"         },// 0x4f

    {Operator, "ReadFontHeader"         },// 0x50
    {Operator, "EndFontHeader"         },// 0x51
    {Operator, "BeginChar"         },// 0x52
    {Operator, "ReadChar"         },// 0x53
    {Operator, "EndChar"         },// 0x54
    {Operator, "RemoveFont"         },// 0x55
    {Operator, NULL         },// 0x56
    {Operator, NULL         },// 0x57
    {Operator, NULL         },// 0x58
    {Operator, NULL         },// 0x59
    {Operator, NULL         },// 0x5a
    {Operator, "BeginStream"         },// 0x5b
    {Operator, "ReadStream"         },// 0x5c
    {Operator, "EndStream"         },// 0x5d
    {Operator, "ExecStream"         },// 0x5e
    {Operator, NULL         },// 0x5f

    {Operator, "PopGS"         },// 0x60
    {Operator, "PushGS"         },// 0x61
    {Operator, "SetClipReplace"         },// 0x62
    {Operator, "SetBrushSource"         },// 0x63
    {Operator, "SetCharAngle"         },// 0x64
    {Operator, "SetCharScale"         },// 0x65
    {Operator, "SetCharShear"         },// 0x66
    {Operator, "SetClipIntersect"         },// 0x67
    {Operator, "SetClipRectangle"         },// 0x68
    {Operator, "SetClipToPage"         },// 0x69
    {Operator, "SetColorSpace"         },// 0x6a
    {Operator, "SetCursor"         },// 0x6b
    {Operator, "SetCursorRel"         },// 0x6c
    {Operator, "SetHalftoneMethod"         },// 0x6d
    {Operator, "SetFillMode"         },// 0x6e
    {Operator, "SetFont"        },// 0x6f

    {Operator, "SetLineDash"        },// 0x70
    {Operator, "SetLineCap"        },// 0x71
    {Operator, "SetLineJoin"        },// 0x72
    {Operator, "SetMiterLimit"        },// 0x73
    {Operator, "SetPageDefaultCTM"        },// 0x74
    {Operator, "SetPageOrigin"        },// 0x75
    {Operator, "SetPageRotation"        },// 0x76
    {Operator, "SetPageScale"        },// 0x77
    {Operator, "SetPatternTxMode"        },// 0x78
    {Operator, "SetPenSource"        },// 0x79
    {Operator, "SetPenWidth"        },// 0x7a
    {Operator, "SetROP"        },// 0x7b
    {Operator, "SetSourceTxMode"        },// 0x7c
    {Operator, "SetCharBoldValue"        },// 0x7d
    {Operator, NULL        },// 0x7e
    {Operator, "SetClipMode"        },// 0x7f

    {Operator, "SetPathToClip"        },// 0x80
    {Operator, "SetCharSubMode"        },// 0x81
    {Operator, NULL        },// 0x82
    {Operator, NULL        },// 0x83
    {Operator, "CloseSubPath"        },// 0x84
    {Operator, "NewPath"        },// 0x85
    {Operator, "PaintPath"        },// 0x86
    {Operator, NULL         },// 0x87
    {Operator, NULL         },// 0x88
    {Operator, NULL         },// 0x89
    {Operator, NULL         },// 0x8a
    {Operator, NULL         },// 0x8b
    {Operator, NULL         },// 0x8c
    {Operator, NULL         },// 0x8d
    {Operator, NULL         },// 0x8e
    {Operator, NULL         },// 0x8f

    {Operator, NULL         },// 0x90
    {Operator, "ArcPath"         },// 0x91
    {Operator, NULL         },// 0x92
    {Operator, "BezierPath"        },// 0x93
    {Operator, NULL         },// 0x94
    {Operator, "BezierRelPath"        },// 0x95
    {Operator, "Chord"        },// 0x96
    {Operator, "ChordPath"        },// 0x97
    {Operator, "Ellipse"        },// 0x98
    {Operator, "EllipsePath"        },// 0x99
    {Operator, NULL         },// 0x9a
    {Operator, "LinePath"        },// 0x9b
    {Operator, "Pie"        },// 0x9c
    {Operator, "PiePath"        },// 0x9d
    {Operator, "Rectangle"        },// 0x9e
    {Operator, "RectanglePath"        },// 0x9f

    {Operator, "RoundRectangle"        },// 0xa0
    {Operator, "RoundRectanglePath"        },// 0xa1
    {Operator, NULL         },// 0xa2
    {Operator, NULL         },// 0xa3
    {Operator, NULL         },// 0xa4
    {Operator, NULL         },// 0xa5
    {Operator, NULL         },// 0xa6
    {Operator, NULL         },// 0xa7
    {Operator, "Text"        },// 0xa8
    {Operator, "TextPath"        },// 0xa9
    {Operator, NULL         },// 0xaa
    {Operator, NULL         },// 0xab
    {Operator, NULL         },// 0xac
    {Operator, NULL         },// 0xad
    {Operator, NULL         },// 0xae
    {Operator, NULL         },// 0xaf

    {Operator, "BeginImage"        },// 0xb0
    {Operator, "ReadImage"        },// 0xb1
    {Operator, "EndImage"        },// 0xb2
    {Operator, "BeginRestPattern"        },// 0xb3
    {Operator, "ReadRastPattern"        },// 0xb4
    {Operator, "EndRastPattern"        },// 0xb5
    {Operator, "BeginScan"        },// 0xb6
    {Operator, NULL         },// 0xb7
    {Operator, "EndScan"        },// 0xb8
    {Operator, "ScanLineRel"        },// 0xb9
    {Operator, NULL         },// 0xba
    {Reserved, NULL         },// 0xbb
    {Reserved, NULL         },// 0xbc
    {Reserved, NULL         },// 0xbd
    {Reserved, NULL         },// 0xbe
    {Reserved, NULL         },// 0xbf

    {DataType,"ubyte"          },// 0xc0
    {DataType,"uint16"      },// 0xc1
    {DataType,"uint32"      },// 0xc2
    {DataType,"sint16"      },// 0xc3
    {DataType,"sint32"      },// 0xc4
    {DataType,"real32"      },// 0xc5
    {DataType,NULL        },// 0xc6
    {DataType,NULL        },// 0xc7
    {DataType, "ubyte_array"         },// 0xc8
    {DataType, "uint16_array"        },// 0xc9
    {DataType, "uint32_array"        },// 0xca
    {DataType, "sint16_array"        },// 0xcb
    {DataType, "sint32_array"        },// 0xcc
    {DataType, "real32_array"        },// 0xcd
    {DataType,NULL        },// 0xce
    {DataType,NULL        },// 0xcf

    {DataType,"ubyte_xy"        },// 0xd0
    {DataType,"uint16_xy"        },// 0xd1
    {DataType, "uint32_xy"        },// 0xd2
    {DataType, "sint16_xy"        },// 0xd3
    {DataType, "sint32_xy"        },// 0xd4
    {DataType, "real32_xy"        },// 0xd5
    {DataType,NULL        },// 0xd6
    {DataType,NULL        },// 0xd7
    {DataType,NULL        },// 0xd8
    {DataType,NULL        },// 0xd9
    {DataType,NULL        },// 0xda
    {DataType,NULL        },// 0xdb
    {DataType,NULL        },// 0xdc
    {DataType,NULL        },// 0xdd
    {DataType,NULL        },// 0xde
    {DataType,NULL        },// 0xdf

    {DataType,"ubyte_box"        },// 0xe0
    {DataType,"uint16_box"       },// 0xe1
    {DataType,"uint32_box"       },// 0xe2
    {DataType,"sint16_box"       },// 0xe3
    {DataType,"sint32_box"       },// 0xe4
    {DataType,"real32_box"       },// 0xe5
    {DataType,NULL        },// 0xe6
    {DataType,NULL        },// 0xe7
    {DataType,NULL        },// 0xe8
    {DataType,NULL        },// 0xe9
    {DataType,NULL        },// 0xea
    {DataType,NULL        },// 0xeb
    {DataType,NULL        },// 0xec
    {DataType,NULL        },// 0xed
    {DataType,NULL        },// 0xee
    {DataType,NULL        },// 0xef

    {Reserved,NULL        },// 0xf0
    {Reserved,NULL        },// 0xf1
    {Reserved,NULL        },// 0xf2
    {Reserved,NULL        },// 0xf3
    {Reserved,NULL        },// 0xf4
    {Reserved,NULL        },// 0xf5
    {Reserved,NULL        },// 0xf6
    {Reserved,NULL        },// 0xf7
    {Attribute,"attr_ubyte"        },// 0xf8
    {Attribute,"attr_uint16"        },// 0xf9
    {EmbedData,"dataLength"    },// 0xfa
    {EmbedData,"dataLengthByte"    },// 0xfb
    {Reserved, NULL }, //0xfc
    {Reserved, NULL }, //0xfd
    {Reserved, NULL }, //0xfe
    {Reserved, NULL }  //0xff

    
};

//
// Attribute IDs
//
const PBYTE pubAttributeID[180] = {
    NULL, // 0
    NULL,
    "PaletteDepth",
    "ColorSpace",
    "NullBrush",
    "NullPen",
    "PaleteData",
    NULL,
    "PatternSelectID",
    "GrayLevel",
    NULL,
    "RGBColor",
    "PatternOrigin",
    "NewDestinationSize",
    NULL,
    NULL,
    NULL,

    NULL, // 17
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    "DeviceMatrix", // 33
    "DitherMatrixDataType",
    "DitherOrigin",
    "MediaDestination",
    "MediaSize",
    "MediaSource",
    "MediaType",
    "Orientation",
    "PageAngle",
    "PageOrigin",
    "PageScale",
    "ROP3",
    "TxMode",
    NULL,
    "CustomMediaSize",
    "CustomMediaSizeUnits", // 48

    "PageCopies", // 49
    "DitherMatrixSize",
    "DithermatrixDepth",
    "SimplexPageMode",
    "DuplexPageMode",
    "DuplexPageSize",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL, // 64

    "ArgDirection",
    "BoundingBox",
    "DashOffset",
    "EllipseDimension",
    "EndPoint",
    "FillMode",
    "LineCapStyle",
    "LineJointStyle",
    "MiterLength",
    "PenDashStyle",
    "PenWidth",
    "Point",
    "NumberOfPoints",
    "SolidLine",
    "StartPoint",
    "PointType", // 80

    "ControlPoint1", // 81
    "ControlPoint2",
    "ClipRegion",
    "ClipMode",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL, // 96

    NULL, // 97
    "ColorDepth",
    "BlockHeight",
    "ColorMapping",
    "CompressMode",
    "DestinationBox",
    "DestinationSize",
    "PatternPersistence",
    "PatternDefineID",
    NULL,
    "SourceHeight",
    "SourceWidth",
    "StartLine",
    "XPairType",
    "NumberOfXPairs",
    NULL, // 112

    "XStart", // 113
    "XEnd",
    "NumberOfScanLines",
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL, // 128

    "CommentData", // 129
    "DataOrg",
    NULL,
    NULL,
    NULL,
    "Measure",
    NULL,
    "SourceType",
    "UnitsPerMeasure",
    NULL,
    "StreamName",
    "StreamDataLength",
    NULL,
    NULL,
    "ErrorReport",
    NULL, // 144

    NULL, // 145
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL, // 160

    "CharAngle", // 161
    "CharCode",
    "CharDataSize",
    "CharScale",
    "CharShear",
    "CharSize",
    "FontHeaderLength",
    "FontName",
    "FontFormat",
    "SymbolSet",
    "TextData",
    "CharSubModeArray",
    NULL,
    NULL,
    "XSpacingData",
    "YSpacingData",
    "CharBoldValue",
    NULL,
    NULL
};









//
// PJL strings
//
const BYTE gcstrPJL[] = "PJL";
const BYTE gcstrJOB[] = "JOB";
const BYTE gcstrSET[] = "SET";
const BYTE gcstrCOMMENT[] = "COMMENT";
const BYTE gcstrENTER[] = "ENTER";
const BYTE gcstrLANGUAGE[] = "LANGUAGE";
const BYTE gcstrPCLXL[] = "PCLXL";

#define NU 0x0
#define ESC 0x1b
#define SP  0x20
#define HT  0x09
#define LF  0x0a
#define VT  0x0b
#define FF  0x0c
#define CR  0x0d

//
// Internal function prototype
//

BOOL
BArgCheck(
    IN  INT,
    IN  CHAR **,
    OUT PWSTR);

VOID
VArgumentError();

BOOL
BParseXLData(PVOID pXLFile);

PBYTE
PRemovePJL(PBYTE pXLFile);

PBYTE PDecodeXL(PBYTE pData);

PBYTE
PSkipSpace(PBYTE pData);

PBYTE
PSkipLine(PBYTE pData);

PBYTE
PSkipWord(PBYTE pData);

//
//
// Functions
//
//

int  __cdecl
main(
    IN int     argc,
    IN char  **argv)
/*++

Routine Description:

    main

Arguments:

    argc - Number of parameters in the following
    argv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{
    WCHAR awchXLFileName[FILENAME_SIZE];
    DWORD dwXLFileSize;
    PVOID pXLFile;
    HANDLE hXLFile;

    //
    // Argument check 
    // pclxl [Output data]
    //

    gdwStatusFlags = 0;

    if (!BArgCheck(argc,
                   argv,
                   awchXLFileName))
    {
        VArgumentError();
        return ERROR_INVALID_ARGUMENT;
    }

    //
    // Open *.RC file.
    //
    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("***********************************************************\n");
        printf("FILE: %ws\n", awchXLFileName);
        printf("***********************************************************\n");
    }

    if (!(hXLFile = MapFileIntoMemory( (PTSTR)awchXLFileName,
                                       (PVOID)&pXLFile,
                                       (PDWORD)&dwXLFileSize )))
    {
        fprintf( stderr, gcstrOpenFileFailure, awchXLFileName);
        return ERROR_OPENFILE;
    }

    if (!BParseXLData(pXLFile))
    {
        fprintf( stderr, gcstrParseError);
        return ERROR_PARSE_XL_DATA;
    }

#if 0
    //
    // Heap Creation
    //

    if (!(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 0x10000, 0x10000)))
    {
        fprintf( stderr, gcstrHeapCreateFailure);
        ERR(("CreateHeap failed: %d\n", GetLastError()));
        return ERROR_HEAP_CREATE;
    }
#endif

    UnmapFileFromMemory(hXLFile);

    return 0;
}

BOOL
BArgCheck(
        INT argc,
        CHAR **argv,
        PWSTR pwstrFileName)
{

   if (argc != 2)
       return FALSE;

   argv++;
   MultiByteToWideChar(CP_ACP,
                       0,
                       *argv,
                       strlen(*argv)+1,
                       pwstrFileName,
                       FILENAME_SIZE);

   return TRUE; 
}

VOID
VArgumentError()
{
    SHORT sI;
    for (sI = 0; sI < ARGUMENT_ERR_MSG_LINE; sI++)
    {
        fprintf( stderr, gcstrArgumentError[sI]);
    }
}

BOOL
BParseXLData(
        PBYTE pXLFile)
{
    PBYTE pubFile;

    //
    // Remove PJL command
    //
    pubFile =  PRemovePJL(pXLFile);

    //
    //
    //
    while (*pubFile != ESC)
        pubFile = PDecodeXL(pubFile);

    return TRUE;
}

PBYTE
PRemovePJL(
        PBYTE pXLFile)
{
    BOOL bBreak = FALSE;

    if ((*pXLFile++ != ESC) ||
        (*pXLFile++ != '%')   ||
        (*pXLFile++ != '-')   ||
        (*pXLFile++ != '1')   ||
        (*pXLFile++ != '2')   ||
        (*pXLFile++ != '3')   ||
        (*pXLFile++ != '4')   ||
        (*pXLFile++ != '5')   ||
        (*pXLFile++ != 'X')    )
        return NULL;

    while (*pXLFile == '@' && !bBreak)
    {
        //
        // Broken PJL command. Return FALSE.
        //
        if (*pXLFile == '@')
            pXLFile ++;

        if (strncmp(pXLFile, gcstrPJL, 3))
            return NULL;

        pXLFile = PSkipWord(pXLFile);

        switch (*pXLFile)
        {
        case 'C':
            if (!strncmp(pXLFile, gcstrCOMMENT, 7))
            {
                pXLFile = PSkipLine(pXLFile);

            }
            break;

        case 'E':
            if (!strncmp(pXLFile, gcstrENTER, 5))
            {
                pXLFile = PSkipWord(pXLFile);
                if (!strncmp(pXLFile, gcstrLANGUAGE, 8))
                {
                    pXLFile += 9;
                    if (!strncmp(pXLFile, gcstrPCLXL, 5))
                    {
                        bBreak = TRUE;
                        pXLFile = PSkipLine(pXLFile);
                    }
                }
            }
            break;

        case 'J':
            if (!strncmp(pXLFile, gcstrJOB, 3))
            {
                pXLFile = PSkipLine(pXLFile);

            }
            break;


        case 'S':
            if (!strncmp(pXLFile, gcstrSET, 3))
            {
                pXLFile = PSkipLine(pXLFile);

            }
            break;

        default:
            return NULL;
        }
    }

    return pXLFile;
}

PBYTE
PSkipWord(
        PBYTE pData)
{
    while (*pData != SP)
        pData++;

    while (*pData == SP)
        pData++;

    return pData;
}

PBYTE
PSkipLine(
        PBYTE pData)
{
    while (*pData != LF)
        pData ++;

    pData ++;

    return pData;
}

PBYTE
PSkipSpace(
        PBYTE pData)
{
    while (*pData == SP)
        pData ++;

    return pData;
}
PBYTE
PSkipWhiteSpace(
        PBYTE pData)
{
    while (*pData == NU ||
           *pData == SP ||
           *pData == HT ||
           *pData == LF ||
           *pData == VT ||
           *pData == HT ||
           *pData == CR)
    {
        pData++;
    }

    return pData;
}

PBYTE
PDecodeXL(
        PBYTE pData)
{
    SHORT sNumOfData, sI;
    DWORD dwI, dwNumOfData;
    BYTE ubType;

    switch(BinaryTagArray[*pData].TagType)
    {
        case NotUsed:
            printf("NotUsed(0x%x)\n\n",*pData);
            pData++;
            break;

        case WhiteSpace:
            pData = PSkipWhiteSpace(pData);
            break;

        case Operator:
            printf("%s\n\n",BinaryTagArray[*pData].pubTagName,*pData);
            pData++;
            break;

        case DataType:
            ubType = *pData;
            pData++;

            sNumOfData = 0;

            if (0xc0 <= ubType && ubType <= 0xc5)
            {
                //
                // One value
                //
                sNumOfData = 1;
            }
            else if (0xc8 <= ubType && ubType <= 0xcd)
            {
                //
                // Array
                //
                sNumOfData = 0;
            }
            else if (0xd0 <= ubType && ubType <= 0xd5)
            {
                //
                // Two values
                //
                sNumOfData = 2;
            }
            else if (0xe0 <= ubType && ubType <= 0xe5)
            {
                //
                // Four values
                //
                sNumOfData = 4;
            }

            printf("    (");

            if (sNumOfData)
            {
                while (sNumOfData-- > 0)
                {
                    switch(ubType%8)
                    {
                        case 0:
                            printf("%d", (BYTE)*pData);
                            pData++;
                            break;
                        case 1:
                            printf("%d", *(PUSHORT)pData);
                            pData+=2;
                            break;
                        case 2:
                            printf("%d", *(PULONG)pData);
                            pData+=4;
                            break;
                        case 3:
                            printf("%d", *(PSHORT)pData);
                            pData+=2;
                            break;
                        case 4:
                            printf("%d", *(PLONG)pData);
                            pData+=4;
                            break;
                        case 5:
                            printf("0x%x", *(PDWORD)pData);
                            pData+=4;
                            break;
                    }
                    if (sNumOfData >= 1)
                        printf(", ");
                }
            }
            else
            {
                if (*pData == 0xc0)
                {
                    pData++;
                    sNumOfData = *pData;
                    pData ++;
                }
                else if (*pData == 0xc1)
                {
                    pData++;
                    sNumOfData = *(PUSHORT)pData;
                    pData += 2;
                }

                switch(ubType%8)
                {
                    case 0:
                        for (sI = 0; sI < sNumOfData; sI ++, pData++)
                            printf("%c", *pData);
                        break;
                    case 1:
                        for (sI = 0; sI < sNumOfData; sI ++, pData+=2)
                            printf("%d", *(PUSHORT)pData);
                        break;
                    case 2:
                        for (sI = 0; sI < sNumOfData; sI ++, pData+=4)
                            printf("%d", *(PULONG)pData);
                        break;
                    case 3:
                        for (sI = 0; sI < sNumOfData; sI ++, pData+=2)
                            printf("%d", *(PSHORT)pData);
                        break;
                    case 4:
                        for (sI = 0; sI < sNumOfData; sI ++, pData+=4)
                            printf("%d", *(PLONG)pData);
                        break;
                    case 5:
                        for (sI = 0; sI < sNumOfData; sI ++, pData+=4)
                            printf("0x%x", *(PDWORD)pData);
                        break;
                }

            }

            printf(")");
            break;

        case Attribute:
            if (*pData == 0xf8)
            {
                printf(":%s\n",pubAttributeID[*(PBYTE)(pData+1)]);
                pData += 2;
            }
            else if (*pData == 0xf9)
            {
                printf(":%s\n",pubAttributeID[*(PDWORD)(pData+1)]);
                pData+=2;
            }
            break;
                        
        case EmbedData:
            printf("Hex(");
            if (*pData == 0xfa)
            {
                pData++;
                dwNumOfData = *(PDWORD)pData;
                pData +=4;
                for (dwI = 0; dwI < dwNumOfData; dwI ++, pData++)
                {
                    printf("%x",*pData);
                }
            }
            else if (*pData == 0xfb)
            {
                pData++;
                sNumOfData = *(PBYTE)pData;
                pData++;
                for (sI = 0; sI < sNumOfData; sI ++, pData++)
                {
                    printf("%x",*pData);
                }
            }
            printf(")");
            break;

        case Binding:
            printf("Binding: ");
            if (*pData == 0x27)
                printf("ASCII\n");
            else if (*pData == 0x28)
                printf("binary - high byte first\n");
            else if (*pData == 0x29)
                printf("binary - low byte first\n");

            pData ++;
            printf("Comment:");
            while (*pData != LF)
            {
                printf("%c", *pData);
                pData++;
            }
            printf("\n");
            break;

        case Reserved:
            printf("Reserved\n");
            pData ++;
            break;
    }

    return pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\udgtt\utils.c ===
VOID
fatal(char *s, ...)
{
    va_list args;

    va_start(args, s);
    fprintf(stderr, "%s: ", namestr);
    vfprintf(stderr, s, args);
    fprintf(stderr, "\n");
    exit(1);
}

VOID
usage()
{
    fprintf(stderr, "usage: %s\n", usagestr);
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\pfm2ufm\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    UNI_GLYPHSETDATA dump tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <uni16res.h>
#include        <uni16gpc.h>
#include        <prntfont.h>
#include        <unilib.h>
#include        <fmlib.h>
#include        <unirc.h>

#define OUTPUT_VERBOSE        0x00000001
#define OUTPUT_CODEPAGEMODE   0x00000002
#define OUTPUT_PREDEFINED     0x00000004
#define OUTPUT_FONTSIM        0x00000008
#define OUTPUT_FONTSIM_NONADD 0x00000010
#define OUTPUT_FACENAME_CONV  0x00000020
#define OUTPUT_SCALING_ANISOTROPIC  0x00000040
#define OUTPUT_SCALING_ARB_XFORMS   0x00000080

#define PFM2UFM_SCALING_ANISOTROPIC     1
#define PFM2UFM_SCALING_ARB_XFORMS      2

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\pfm2ufm\pfmconv.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    pfmconv.c

Abstract:

    Windows NT utilities to handle new font format

Environment:

    Windows NT Universal printer driver

Revision History:

    10/31/96 -eigos-
        Created it.

--*/

#include "precomp.h"

//
// Internal macros
//

#define DRIVERINFO_VERSION_WIN31    0x0100
#define DRIVERINFO_VERSION_SIMULATE 0x0150
#define DRIVERINFO_VERSION          0x0200

#define FONT_SIM_NO_ITALIC          1
#define FONT_SIM_NO_BOLD            2
#define FONT_SIM_DJ_BOLD            4

//
// HP DeskJet permutation flags
//

#define HALF_PITCH                  0x01
#define DOUBLE_PITCH                0x02
#define HALF_HEIGHT                 0x04
#define MAKE_BOLD                   0x08

#define BASE_BOLD_MASK      0x30
#define BASE_BOLD_SHIFT     4
#define BASE_BOLD_ADD_0     0x00
#define BASE_BOLD_ADD_1     0x10
#define BASE_BOLD_ADD_2     0x20
#define BASE_BOLD_ADD_3     0x30

//    6/6/97 yasuho: Some PFM have -1 value in wPrivateData.
#define DO_DJFONTSIMBOLD(pFInData)  ((pFInData->DI.wPrivateData != 0xFFFF) && (pFInData->DI.wPrivateData & MAKE_BOLD))

#define DO_FONTSIM(pFInData) \
    (((pFInData)->DI.sVersion == DRIVERINFO_VERSION_WIN31)    || \
     ((pFInData)->DI.sVersion == DRIVERINFO_VERSION_SIMULATE) || \
     IS_DBCSCHARSET((pFInData)->PFMH.dfCharSet) )

#define DWORD_ALIGN(p) ((((ULONG)(p)) + 3) & ~3)

#define IS_DBCSCTTTYPE(sCTT)     \
    (  ((sCTT) == CTT_JIS78)     \
    || ((sCTT) == CTT_JIS78_ANK) \
    || ((sCTT) == CTT_JIS83)     \
    || ((sCTT) == CTT_JIS83_ANK) \
    || ((sCTT) == CTT_NS86)      \
    || ((sCTT) == CTT_TCA)       \
    || ((sCTT) == CTT_BIG5)      \
    || ((sCTT) == CTT_ISC))

#define CTT_TYPE_TO_CHARSET(sCTT) \
    (((sCTT) == CTT_JIS78)     ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_JIS78_ANK) ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_JIS83)     ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_JIS83_ANK) ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_NS86)      ? CHINESEBIG5_CHARSET : \
    (((sCTT) == CTT_TCA)       ? CHINESEBIG5_CHARSET : \
    (((sCTT) == CTT_BIG5)      ? CHINESEBIG5_CHARSET : \
    (((sCTT) == CTT_ISC)       ? HANGEUL_CHARSET : 1))))))))
    
#define OUTPUT_VERBOSE 0x00000001

#define BBITS       8
#define DWBITS       (BBITS * sizeof( DWORD ))
#define DW_MASK       (DWBITS - 1)


//
// Definitions
//

extern DWORD gdwOutputFlags;

typedef VOID (*VPRINT) (char*,...);

//
// Internal function prorotypes
//

BOOL BCreateWidthTable( IN HANDLE, IN PWORD, IN WORD, IN WORD, IN PSHORT, OUT PWIDTHTABLE *, OUT PDWORD);
BOOL BCreateKernData( IN HANDLE, IN w3KERNPAIR*, IN DWORD, OUT PKERNDATA*, OUT PDWORD);
WORD WGetGlyphHandle(PUNI_GLYPHSETDATA, WORD);
PUNI_GLYPHSETDATA PGetDefaultGlyphset( IN HANDLE, IN WORD, IN WORD, IN DWORD);
LONG LCtt2Cc(IN SHORT, IN SHORT);

//
//
// PFM file handling functions
//
//

BOOL
BFontInfoToIFIMetric(
    IN HANDLE       hHeap,
    IN FONTIN     *pFInData,
    IN PWSTR        pwstrUniqNm,
    IN DWORD        dwCodePageOfFacenameConv,
    IN OUT PIFIMETRICS *ppIFI,
    IN OUT PDWORD   pdwSize,
    IN DWORD        dwFlags)

/*++

Routine Description:

    Convert the Win 3.1 format PFM data to NT's IFIMETRICS.  This is
    typically done before the minidrivers are built,  so that they
    can include IFIMETRICS, and thus have less work to do at run time.

Arguments:

    pFInData - Font data info for conversion
    pwstrUniqNm - Unique name component

Return Value:

    TRUE if successfull, otherwise FALSE.

--*/

{
    FONTSIM  *pFontSim;
    FONTDIFF *pfdiffBold = 0, *pfdiffItalic = 0, *pfdiffBoldItalic = 0;
    PIFIEXTRA pIFIExtra;

    FWORD  fwdExternalLeading;

    INT    icWChar;             /* Number of WCHARS to add */
    INT    icbAlloc;             /* Number of bytes to allocate */
    INT    iI;                  /* Loop index */
    INT    iCount;              /* Number of characters in Win 3.1 font */

    WCHAR *pwchTmp;             /* For string manipulations */

    WCHAR   awcAttrib[ 256 ];   /* Generate attributes + BYTE -> WCHAR */
    BYTE    abyte[ 256 ];       /* Used (with above) to get wcLastChar etc */

    WORD fsFontSim = 0;
    INT cFontDiff;
    UINT uiCodePage;

    CHARSETINFO ci;

    //
    // Calculate the size of three face names buffer
    //

    icWChar =  3 * strlen( pFInData->pBase + pFInData->PFMH.dfFace );

    //
    //   Produce the desired attributes: Italic, Bold, Light etc.
    // This is largely guesswork,  and there should be a better method.
    // Write out an empty string 
    //

    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';

    if( pFInData->PFMH.dfItalic )
    {
        wcscat( awcAttrib, L" Italic" );
    }

    if( pFInData->PFMH.dfWeight >= 700 )
    {
        wcscat( awcAttrib, L" Bold" );
    }
    else if( pFInData->PFMH.dfWeight < 200 )
    {
        wcscat( awcAttrib, L" Light" );
    }

    //
    //   The attribute string appears in 3 entries of IFIMETRICS,  so
    // calculate how much storage this will take.  NOTE THAT THE LEADING
    // CHAR IN awcAttrib is NOT placed in the style name field,  so we
    // subtract one in the following formula to account for this.
    //

    if( awcAttrib[ 0 ] )
    {
        icWChar += 3 * wcslen( awcAttrib ) - 1;
    }

    //
    // Should be printer name
    //

    icWChar += wcslen( pwstrUniqNm ) + 1;

    //
    // Terminating nulls
    //

    icWChar += 4;

    //
    // Total size of IFIMETRICS structure
    //

    icbAlloc = DWORD_ALIGN(sizeof( IFIMETRICS ) + sizeof( WCHAR ) * icWChar);

    //
    // For HeskJet font.
    //
    if (DO_DJFONTSIMBOLD(pFInData))
    {
        fsFontSim |= FONT_SIM_DJ_BOLD;
        icbAlloc = DWORD_ALIGN(icbAlloc) +
                   DWORD_ALIGN(sizeof(FONTSIM)) +
                   DWORD_ALIGN(sizeof(FONTDIFF));
    }
    else
    //
    // For CJK font.
    // Judge which font simulation to be enabled, then allocate the
    // necessary storage.
    //
    if (DO_FONTSIM(pFInData) || pFInData->dwFlags & FLAG_FONTSIM)
    {
        cFontDiff = 4;

        //
        // Decide which attribute should be diabled.  We won't simulate
        // if the user does not desires it.  We won't italicize in case
        // it is an italic font, etc.
        //

        if ( pFInData->PFMH.dfItalic || (pFInData->DI.fCaps & DF_NOITALIC))
        {
            fsFontSim |= FONT_SIM_NO_ITALIC;
            cFontDiff /= 2;
        }

        if( pFInData->PFMH.dfWeight >= 700 || (pFInData->DI.fCaps & DF_NO_BOLD))
        {
            fsFontSim |= FONT_SIM_NO_BOLD;
            cFontDiff /= 2;
        }

        cFontDiff--;

        if ( cFontDiff > 0)
        {
            icbAlloc  = DWORD_ALIGN(icbAlloc);
            icbAlloc += (DWORD_ALIGN(sizeof(FONTSIM)) +
                        cFontDiff * DWORD_ALIGN(sizeof(FONTDIFF)));
        }
    }
#if DBG
    DbgPrint( "cFontDiff = %d", cFontDiff);
#endif

    //
    // IFIEXTRA
    //
    // Fill out IFIEXTRA.cig.
    //

    icbAlloc += sizeof(IFIEXTRA);

    //
    // Allocate memory
    //

    *ppIFI = (IFIMETRICS *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, icbAlloc);
    *pdwSize = icbAlloc;

    if (NULL == *ppIFI)
    {
        return FALSE;
    }

    (*ppIFI)->cjThis     = icbAlloc;
    (*ppIFI)->cjIfiExtra = 0;

    //
    // The family name:  straight from the FaceName - no choice??
    //
    // -IFIMETRICS memory image-
    //   IFIMETRICS
    //   IFIEXTRA
    //   FamilyName
    //   StyleName
    //   FaceName
    //   UniqueName
    //

    pIFIExtra                 = (PIFIEXTRA)(*ppIFI + 1);
    pIFIExtra->dpFontSig      = 0;
    pIFIExtra->cig            = pFInData->PFMH.dfLastChar -
                                pFInData->PFMH.dfFirstChar + 1;
    pIFIExtra->dpDesignVector = 0;
    pIFIExtra->dpAxesInfoW    = 0;


    pwchTmp = (WCHAR*)((PBYTE)(*ppIFI + 1) + sizeof(IFIEXTRA));
	(*ppIFI)->dpwszFamilyName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));

    if (dwCodePageOfFacenameConv)
        uiCodePage = dwCodePageOfFacenameConv;
    else
        uiCodePage = UlCharsetToCodePage(pFInData->PFMH.dfCharSet);

    DwCopyStringToUnicodeString( uiCodePage,
                                 pFInData->pBase + pFInData->PFMH.dfFace,
                                 pwchTmp,
                                 icWChar);

    pwchTmp += wcslen( pwchTmp ) + 1;
    icWChar -= wcslen( pwchTmp ) + 1;

    //
    // Now the face name:  we add bold, italic etc to family name
    //
    (*ppIFI)->dpwszFaceName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));


    DwCopyStringToUnicodeString( uiCodePage,
                                 pFInData->pBase + pFInData->PFMH.dfFace,
                                 pwchTmp,
                                 icWChar);

    wcscat( pwchTmp, awcAttrib );

    //
    //   Now the unique name - well, sort of, anyway
    //

    pwchTmp += wcslen( pwchTmp ) + 1;         /* Skip what we just put in */
    (*ppIFI)->dpwszUniqueName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));

    wcscpy( pwchTmp, pwstrUniqNm );     /* Append printer name for uniqueness */
    wcscat( pwchTmp, L" " );
    wcscat( pwchTmp, (PWSTR)((BYTE *)(*ppIFI) + (*ppIFI)->dpwszFaceName) );

    /*  Onto the attributes only component */

    pwchTmp += wcslen( pwchTmp ) + 1;         /* Skip what we just put in */
    (*ppIFI)->dpwszStyleName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));
    wcscat( pwchTmp, &awcAttrib[ 1 ] );


#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "BFontInfoToIFIMetrics: STACK CORRUPTED BY awcAttrib" );

        HeapFree(hHeap, 0, (LPSTR)(*ppIFI) );         /* No memory leaks */

        return  FALSE;
    }


    if( ((BYTE *)(pwchTmp + wcslen( pwchTmp ) + 1)) > ((BYTE *)(*ppIFI) + icbAlloc) )
    {
        DbgPrint( "BFontInfoToIFIMetrics: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwchTmp + wcslen( pwchTmp ) + 1)),
                ((BYTE *)(*ppIFI) + icbAlloc) );

        HeapFree(hHeap, 0, (LPSTR)(*ppIFI) );         /* No memory leaks */

        return  0;

    }
#endif

    pwchTmp += wcslen( pwchTmp ) + 1;         /* Skip what we just put in */

    //
    // For HeskJet font.
    //
    if (fsFontSim & FONT_SIM_DJ_BOLD)
    {
        pFontSim = (FONTSIM *)pwchTmp;

        (*ppIFI)->dpFontSim = (PTRDIFF)((BYTE *)pFontSim - (BYTE *)(*ppIFI) );

        pFontSim->dpBold = DWORD_ALIGN(sizeof(FONTSIM));
        pfdiffBold = (FONTDIFF *)((BYTE *)pFontSim + pFontSim->dpBold);

        pFontSim->dpItalic     = 0;
        pFontSim->dpBoldItalic = 0;
    }
    else
    if ((DO_FONTSIM( pFInData ) || pFInData->dwFlags & FLAG_FONTSIM) && cFontDiff > 0)
    //
    // For CJK font.
    // Judge which font simulation to be enabled, then allocate the
    // necessary storage.
    //
    {
        PTRDIFF dpTmp;

        // n.b.: FONTSIM, FONTDIFF have to be dword-aligned

//      pFontSim = (FONTSIM *)PtrToUlong(pwchTmp);

		pFontSim = (FONTSIM *)pwchTmp;

        (*ppIFI)->dpFontSim = (PTRDIFF)((BYTE *)pFontSim - (BYTE *)(*ppIFI) );

        dpTmp = DWORD_ALIGN(sizeof(FONTSIM));

        if (!(fsFontSim & FONT_SIM_NO_BOLD))
        {
            pFontSim->dpBold = dpTmp;
            pfdiffBold = (FONTDIFF *)((BYTE *)pFontSim + dpTmp);
            dpTmp += DWORD_ALIGN(sizeof(FONTDIFF));

            if (!(fsFontSim & FONT_SIM_NO_ITALIC))
            {
                pFontSim->dpBoldItalic = dpTmp;
                pfdiffBoldItalic = (FONTDIFF *)((BYTE *)pFontSim + dpTmp);
                dpTmp += DWORD_ALIGN(sizeof(FONTDIFF));
            }
        }
        else
        if (!(fsFontSim & FONT_SIM_NO_ITALIC))
        {
            pFontSim->dpItalic = dpTmp;
            pfdiffItalic = (FONTDIFF *)((BYTE *)pFontSim + dpTmp);
            dpTmp += DWORD_ALIGN(sizeof(FONTDIFF));
        }

        pwchTmp = (WCHAR *)((BYTE *)pFontSim + dpTmp);
    }

    // check again...

    if ((BYTE *)(pwchTmp) > ((BYTE *)(*ppIFI) + icbAlloc))
    {
#if DBG
        DbgPrint( "BFontInfoToIFIMetrics: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)pwchTmp),
                ((BYTE *)(*ppIFI) + icbAlloc) );
#endif

        HeapFree( hHeap, 0, (LPSTR)(*ppIFI) );         /* No memory leaks */

        return  0;

    }

    {
        int i;

        (*ppIFI)->lEmbedId     = 0;
        (*ppIFI)->lItalicAngle = 0;
        (*ppIFI)->lCharBias    = 0;
        (*ppIFI)->dpCharSets   = 0; // no multiple charsets in rasdd fonts
    }
    (*ppIFI)->jWinCharSet = (BYTE)pFInData->PFMH.dfCharSet;

    //
    // If FE Ctt table is used, this overrides what defined in charset
    //

    if (IS_DBCSCTTTYPE(-(pFInData->DI.sTransTab)))
    {
        (*ppIFI)->jWinCharSet = CTT_TYPE_TO_CHARSET(-(pFInData->DI.sTransTab));
    }


    if( pFInData->PFMH.dfPixWidth )
    {
        (*ppIFI)->jWinPitchAndFamily |= FIXED_PITCH;
        (*ppIFI)->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);


       if(IS_DBCSCHARSET((*ppIFI)->jWinCharSet))
        {
            // it is too strict to call a DBCS font "fixed pitch" since it has
            // both halfwidth glyphs and fullwidth glyphs.
            (*ppIFI)->flInfo &= ~FM_INFO_CONSTANT_WIDTH;
            (*ppIFI)->flInfo |= (FM_INFO_OPTICALLY_FIXED_PITCH |
                             FM_INFO_DBCS_FIXED_PITCH);
        }


    }
    else
    {
        (*ppIFI)->jWinPitchAndFamily |= VARIABLE_PITCH;

        if(IS_DBCSCHARSET((*ppIFI)->jWinCharSet))
        {
            // DBCS glyphs are always fixed pitch even if the SBCS part is
            // variable pitch.
            (*ppIFI)->flInfo |= FM_INFO_DBCS_FIXED_PITCH;
        }
    }


    (*ppIFI)->jWinPitchAndFamily |= (((BYTE) pFInData->PFMH.dfPitchAndFamily) & 0xf0);

    (*ppIFI)->usWinWeight = (USHORT)pFInData->PFMH.dfWeight;

    //
    // IFIMETRICS::flInfo
    //

    (*ppIFI)->flInfo |=
        FM_INFO_TECH_BITMAP    |
        FM_INFO_1BPP           |
        FM_INFO_INTEGER_WIDTH  |
        FM_INFO_NOT_CONTIGUOUS |
        FM_INFO_RIGHT_HANDED;


    /*
     *    A scalable font?  This happens when there is EXTTEXTMETRIC data,
     *  and that data has a min size different to the max size.
     */

    if( pFInData->pETM &&
        pFInData->pETM->emMinScale != pFInData->pETM->emMaxScale )
    {
       (*ppIFI)->flInfo        |= FM_INFO_ISOTROPIC_SCALING_ONLY;
       (*ppIFI)->fwdUnitsPerEm  = pFInData->pETM->emMasterUnits;
    }
    else
    {
        (*ppIFI)->fwdUnitsPerEm =
            (FWORD) (pFInData->PFMH.dfPixHeight - pFInData->PFMH.dfInternalLeading);
    }

#ifndef PFM2UFM_SCALING_ANISOTROPIC
#define PFM2UFM_SCALING_ANISOTROPIC     1
#endif
#ifndef PFM2UFM_SCALING_ARB_XFORMS
#define PFM2UFM_SCALING_ARB_XFORMS      2
#endif

    if ((*ppIFI)->flInfo & FM_INFO_ISOTROPIC_SCALING_ONLY) {

        // Allow forcing non-standard scaling only if the
        // font is already scalable.
        if ((dwFlags & PFM2UFM_SCALING_ANISOTROPIC)) {
           (*ppIFI)->flInfo &= ~FM_INFO_ISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo |= FM_INFO_ANISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo &= ~FM_INFO_ARB_XFORMS;
        }
        else  if ((dwFlags & PFM2UFM_SCALING_ARB_XFORMS)) {
           (*ppIFI)->flInfo &= ~FM_INFO_ISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo &= ~FM_INFO_ANISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo |= FM_INFO_ARB_XFORMS;
        }
    }

    (*ppIFI)->fsSelection =
        ((pFInData->PFMH.dfItalic            ) ? FM_SEL_ITALIC     : 0)    |
        ((pFInData->PFMH.dfUnderline         ) ? FM_SEL_UNDERSCORE : 0)    |
        ((pFInData->PFMH.dfStrikeOut         ) ? FM_SEL_STRIKEOUT  : 0)    |
        ((pFInData->PFMH.dfWeight >= FW_BOLD ) ? FM_SEL_BOLD       : 0) ;

    (*ppIFI)->fsType        = FM_NO_EMBEDDING;
    (*ppIFI)->fwdLowestPPEm = 1;


    /*
     * Calculate fwdWinAscender, fwdWinDescender, fwdAveCharWidth, and
     * fwdMaxCharInc assuming a bitmap where 1 font unit equals one
     * pixel unit
     */

    (*ppIFI)->fwdWinAscender = (FWORD)pFInData->PFMH.dfAscent;

    (*ppIFI)->fwdWinDescender =
        (FWORD)pFInData->PFMH.dfPixHeight - (*ppIFI)->fwdWinAscender;

    (*ppIFI)->fwdMaxCharInc   = (FWORD)pFInData->PFMH.dfMaxWidth;
    (*ppIFI)->fwdAveCharWidth = (FWORD)pFInData->PFMH.dfAvgWidth;

    fwdExternalLeading = (FWORD)pFInData->PFMH.dfExternalLeading;

//
// If the font was scalable, then the answers must be scaled up
// !!! HELP HELP HELP - if a font is scalable in this sense, then
//     does it support arbitrary transforms? [kirko]
//

    if( (*ppIFI)->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY |
                          FM_INFO_ANISOTROPIC_SCALING_ONLY |
                          FM_INFO_ARB_XFORMS))
    {
        /*
         *    This is a scalable font:  because there is Extended Text Metric
         *  information available,  and this says that the min and max
         *  scale sizes are different:  thus it is scalable! This test is
         *  lifted directly from the Win 3.1 driver.
         */

        int iMU,  iRel;            /* Adjustment factors */

        iMU  = pFInData->pETM->emMasterUnits;
        iRel = pFInData->PFMH.dfPixHeight;

        (*ppIFI)->fwdWinAscender = ((*ppIFI)->fwdWinAscender * iMU) / iRel;

        (*ppIFI)->fwdWinDescender = ((*ppIFI)->fwdWinDescender * iMU) / iRel;

        (*ppIFI)->fwdMaxCharInc = ((*ppIFI)->fwdMaxCharInc * iMU) / iRel;

        (*ppIFI)->fwdAveCharWidth = ((*ppIFI)->fwdAveCharWidth * iMU) / iRel;

        fwdExternalLeading = (fwdExternalLeading * iMU) / iRel;
    }

    (*ppIFI)->fwdMacAscender =    (*ppIFI)->fwdWinAscender;
    (*ppIFI)->fwdMacDescender = - (*ppIFI)->fwdWinDescender;

    (*ppIFI)->fwdMacLineGap   =  fwdExternalLeading;

    (*ppIFI)->fwdTypoAscender  = (*ppIFI)->fwdMacAscender;
    (*ppIFI)->fwdTypoDescender = (*ppIFI)->fwdMacDescender;
    (*ppIFI)->fwdTypoLineGap   = (*ppIFI)->fwdMacLineGap;

    // for Windows 3.1J compatibility

    if(IS_DBCSCHARSET((*ppIFI)->jWinCharSet))
    {
        (*ppIFI)->fwdMacLineGap = 0;
        (*ppIFI)->fwdTypoLineGap = 0;
    }

    if( pFInData->pETM )
    {
        /*
         *    Zero is a legitimate default for these.  If 0, gdisrv
         *  chooses some default values.
         */
        (*ppIFI)->fwdCapHeight = pFInData->pETM->emCapHeight;
        (*ppIFI)->fwdXHeight = pFInData->pETM->emXHeight;

        (*ppIFI)->fwdSubscriptYSize = pFInData->pETM->emSubScriptSize;
        (*ppIFI)->fwdSubscriptYOffset = pFInData->pETM->emSubScript;

        (*ppIFI)->fwdSuperscriptYSize = pFInData->pETM->emSuperScriptSize;
        (*ppIFI)->fwdSuperscriptYOffset = pFInData->pETM->emSuperScript;

        (*ppIFI)->fwdUnderscoreSize = pFInData->pETM->emUnderlineWidth;
        (*ppIFI)->fwdUnderscorePosition = pFInData->pETM->emUnderlineOffset;

        (*ppIFI)->fwdStrikeoutSize = pFInData->pETM->emStrikeOutWidth;
        (*ppIFI)->fwdStrikeoutPosition = pFInData->pETM->emStrikeOutOffset;

    }
    else
    {
        /*  No additional information, so do some calculations  */
        (*ppIFI)->fwdSubscriptYSize = (*ppIFI)->fwdWinAscender/4;
        (*ppIFI)->fwdSubscriptYOffset = -((*ppIFI)->fwdWinAscender/4);

        (*ppIFI)->fwdSuperscriptYSize = (*ppIFI)->fwdWinAscender/4;
        (*ppIFI)->fwdSuperscriptYOffset = (3 * (*ppIFI)->fwdWinAscender)/4;

        (*ppIFI)->fwdUnderscoreSize = (*ppIFI)->fwdWinAscender / 12;
        if( (*ppIFI)->fwdUnderscoreSize < 1 )
            (*ppIFI)->fwdUnderscoreSize = 1;

        (*ppIFI)->fwdUnderscorePosition = -pFInData->DI.sUnderLinePos;

        (*ppIFI)->fwdStrikeoutSize     = (*ppIFI)->fwdUnderscoreSize;

        (*ppIFI)->fwdStrikeoutPosition = (FWORD)pFInData->DI.sStrikeThruPos;
        if( (*ppIFI)->fwdStrikeoutPosition  < 1 )
            (*ppIFI)->fwdStrikeoutPosition = ((*ppIFI)->fwdWinAscender + 2) / 3;
    }

    (*ppIFI)->fwdSubscriptXSize = (*ppIFI)->fwdAveCharWidth/4;
    (*ppIFI)->fwdSubscriptXOffset =  (3 * (*ppIFI)->fwdAveCharWidth)/4;

    (*ppIFI)->fwdSuperscriptXSize = (*ppIFI)->fwdAveCharWidth/4;
    (*ppIFI)->fwdSuperscriptXOffset = (3 * (*ppIFI)->fwdAveCharWidth)/4;



    (*ppIFI)->chFirstChar = pFInData->PFMH.dfFirstChar;
    (*ppIFI)->chLastChar  = pFInData->PFMH.dfLastChar;

    //
    //   We now do the conversion of these to Unicode.  We presume the
    // input is in the ANSI code page,  and call the NLS converion
    // functions to generate proper Unicode values.
    //

    iCount = pFInData->PFMH.dfLastChar - pFInData->PFMH.dfFirstChar + 1;

    for( iI = 0; iI < iCount; ++iI )
        abyte[ iI ] = iI + pFInData->PFMH.dfFirstChar;

    DwCopyStringToUnicodeString( uiCodePage,
                                 abyte,
                                 awcAttrib,
                                 iCount);

    //
    // Now fill in the IFIMETRICS WCHAR fields.
    //

    (*ppIFI)->wcFirstChar = 0xffff;
    (*ppIFI)->wcLastChar = 0;

    //
    //   Look for the first and last
    //

    for( iI = 0; iI < iCount; ++iI )
    {
        if( (*ppIFI)->wcFirstChar > awcAttrib[ iI ] )
            (*ppIFI)->wcFirstChar = awcAttrib[ iI ];

        if( (*ppIFI)->wcLastChar < awcAttrib[ iI ] )
            (*ppIFI)->wcLastChar = awcAttrib[ iI ];

    }

    (*ppIFI)->wcDefaultChar = awcAttrib[ pFInData->PFMH.dfDefaultChar ];

    (*ppIFI)->wcBreakChar = awcAttrib[ pFInData->PFMH.dfBreakChar ];

    (*ppIFI)->chDefaultChar = pFInData->PFMH.dfDefaultChar + pFInData->PFMH.dfFirstChar;
    (*ppIFI)->chBreakChar   = pFInData->PFMH.dfBreakChar   + pFInData->PFMH.dfFirstChar;


    if( pFInData->PFMH.dfItalic )
    {
    //
    // tan (17.5 degrees) = .3153
    //
        (*ppIFI)->ptlCaret.x      = 3153;
        (*ppIFI)->ptlCaret.y      = 10000;
    }
    else
    {
        (*ppIFI)->ptlCaret.x      = 0;
        (*ppIFI)->ptlCaret.y      = 1;
    }

    (*ppIFI)->ptlBaseline.x = 1;
    (*ppIFI)->ptlBaseline.y = 0;

    (*ppIFI)->ptlAspect.x =  pFInData->PFMH.dfHorizRes;
    (*ppIFI)->ptlAspect.y =  pFInData->PFMH.dfVertRes;

    (*ppIFI)->rclFontBox.left   = 0;
    (*ppIFI)->rclFontBox.top    =   (LONG) (*ppIFI)->fwdWinAscender;
    (*ppIFI)->rclFontBox.right  =   (LONG) (*ppIFI)->fwdMaxCharInc;
    (*ppIFI)->rclFontBox.bottom = - (LONG) (*ppIFI)->fwdWinDescender;

    (*ppIFI)->achVendId[0] = 'U';
    (*ppIFI)->achVendId[1] = 'n';
    (*ppIFI)->achVendId[2] = 'k';
    (*ppIFI)->achVendId[3] = 'n';

    (*ppIFI)->cKerningPairs = 0;

    (*ppIFI)->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    (*ppIFI)->panose.bFamilyType      = PAN_ANY;
    (*ppIFI)->panose.bSerifStyle      = PAN_ANY;
    if(pFInData->PFMH.dfWeight >= FW_BOLD)
    {
        (*ppIFI)->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else if (pFInData->PFMH.dfWeight > FW_EXTRALIGHT)
    {
        (*ppIFI)->panose.bWeight = PAN_WEIGHT_MEDIUM;
    }
    else
    {
        (*ppIFI)->panose.bWeight = PAN_WEIGHT_LIGHT;
    }
    (*ppIFI)->panose.bProportion      = PAN_ANY;
    (*ppIFI)->panose.bContrast        = PAN_ANY;
    (*ppIFI)->panose.bStrokeVariation = PAN_ANY;
    (*ppIFI)->panose.bArmStyle        = PAN_ANY;
    (*ppIFI)->panose.bLetterform      = PAN_ANY;
    (*ppIFI)->panose.bMidline         = PAN_ANY;
    (*ppIFI)->panose.bXHeight         = PAN_ANY;

    if (fsFontSim & FONT_SIM_DJ_BOLD)
    {
        FONTDIFF FontDiff;
        SHORT    sAddBold;

        FontDiff.jReserved1        = 0;
        FontDiff.jReserved2        = 0;
        FontDiff.jReserved3        = 0;
        FontDiff.bWeight           = (*ppIFI)->panose.bWeight;
        FontDiff.usWinWeight       = (*ppIFI)->usWinWeight;
        FontDiff.fsSelection       = (*ppIFI)->fsSelection;
        FontDiff.fwdAveCharWidth   = (*ppIFI)->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc     = (*ppIFI)->fwdMaxCharInc;
        FontDiff.ptlCaret          = (*ppIFI)->ptlCaret;

        if (pfdiffBold)
        {
            sAddBold = (pFInData->DI.wPrivateData & BASE_BOLD_MASK) >>
                        BASE_BOLD_SHIFT;

            *pfdiffBold                  = FontDiff;
            pfdiffBold->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;
            pfdiffBold->fwdAveCharWidth += sAddBold;
            pfdiffBold->fwdMaxCharInc   += sAddBold;
        }
    }
    else
    if ( (DO_FONTSIM( pFInData ) || pFInData->dwFlags & FLAG_FONTSIM) &&
         cFontDiff > 0 )
    {
        FONTDIFF FontDiff;

        FontDiff.jReserved1        = 0;
        FontDiff.jReserved2        = 0;
        FontDiff.jReserved3        = 0;
        FontDiff.bWeight           = (*ppIFI)->panose.bWeight;
        FontDiff.usWinWeight       = (*ppIFI)->usWinWeight;
        FontDiff.fsSelection       = (*ppIFI)->fsSelection;
        FontDiff.fwdAveCharWidth   = (*ppIFI)->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc     = (*ppIFI)->fwdMaxCharInc;
        FontDiff.ptlCaret          = (*ppIFI)->ptlCaret;

        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBold->bWeight                = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection           |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight            = FW_BOLD;
            pfdiffBold->fwdAveCharWidth       += 1;
            pfdiffBold->fwdMaxCharInc         += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection         |= FM_SEL_ITALIC;
            pfdiffItalic->ptlCaret.x           = 1;
            pfdiffItalic->ptlCaret.y           = 2;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;
            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
            pfdiffBoldItalic->ptlCaret.x       = 1;
            pfdiffBoldItalic->ptlCaret.y       = 2;
        }
    }

    return TRUE;
}


BOOL
BGetFontSelFromPFM(
    HANDLE      hHeap,
    FONTIN     *pFInData,       // Access to font info,  aligned
    BOOL        bSelect,
    CMDSTRING  *pCmdStr)
{
    LOCD locd;     // From originating data
    CD  *pCD, **ppCDTrg;


    if (bSelect)
    {
        locd   = pFInData->DI.locdSelect;
        ppCDTrg = &pFInData->pCDSelectFont;
    }
    else
    {
        locd   = pFInData->DI.locdUnSelect;
        ppCDTrg = &pFInData->pCDUnSelectFont;
    }


    if( locd != 0xFFFFFFFF) // NOOCD
    {
        DWORD   dwSize;

        pCD = (CD *)(pFInData->pBase + locd);

        //
        //   The data pointed at by pCD may not be aligned,  so we copy
        // it into a local structure.  This local structure then allows
        // us to determine how big the CD really is (using it's length field),
        // so then we can allocate storage and copy as required.
        //

        //
        // Allocate storage area in the heap 
        //

        dwSize = pCD->wLength;

        pCmdStr->pCmdString = (PBYTE)HeapAlloc( hHeap,
                                                0,
                                                (dwSize + 3) & ~0x3 );

        if (NULL == pCmdStr->pCmdString)
            //
            // Check if HeapAlloc succeeded.
            //
            return FALSE;

        pCmdStr->dwSize = dwSize;

        CopyMemory((PBYTE)pCmdStr->pCmdString, (PBYTE)(pCD + 1), dwSize);

        *ppCDTrg = pCD;

        return  TRUE;
    }

    pCmdStr->dwSize = 0;

    return   FALSE;
}

BOOL
BAlignPFM(
    FONTIN   *pFInData) //  Has ALL we need!

/*++

Routine Description:

    Convert the non-aligned windows format data into a properly
    aligned structure for our use.  Only some of the data is converted
    here,  since we are mostly interested in extracting the addresses
    contained in these structures.

Arguments:

    pFInData - pointer to FONTIN


Return Value:

    TRUE if successfull, otherwise fail to convert.

--*/

{
    BYTE    *pb;        /* Miscellaneous operations */

    res_PFMHEADER    *pPFM;    /* The resource data format */
    res_PFMEXTENSION *pR_PFME;    /* Resource data PFMEXT format */


    /*
     *   Align the PFMHEADER structure.
     */

    pPFM = (res_PFMHEADER *)pFInData->pBase;

    pFInData->PFMH.dfType            = pPFM->dfType;
    pFInData->PFMH.dfPoints          = pPFM->dfPoints;
    pFInData->PFMH.dfVertRes         = pPFM->dfVertRes;
    pFInData->PFMH.dfHorizRes        = pPFM->dfHorizRes;
    pFInData->PFMH.dfAscent          = pPFM->dfAscent;
    pFInData->PFMH.dfInternalLeading = pPFM->dfInternalLeading;
    pFInData->PFMH.dfExternalLeading = pPFM->dfExternalLeading;
    pFInData->PFMH.dfItalic          = pPFM->dfItalic;
    pFInData->PFMH.dfUnderline       = pPFM->dfUnderline;
    pFInData->PFMH.dfStrikeOut       = pPFM->dfStrikeOut;

    pFInData->PFMH.dfWeight          = DwAlign2( pPFM->b_dfWeight );

    pFInData->PFMH.dfCharSet         = pPFM->dfCharSet;
    pFInData->PFMH.dfPixWidth        = pPFM->dfPixWidth;
    pFInData->PFMH.dfPixHeight       = pPFM->dfPixHeight;
    pFInData->PFMH.dfPitchAndFamily  = pPFM->dfPitchAndFamily;

    pFInData->PFMH.dfAvgWidth        = DwAlign2( pPFM->b_dfAvgWidth );
    pFInData->PFMH.dfMaxWidth        = DwAlign2( pPFM->b_dfMaxWidth );

    pFInData->PFMH.dfFirstChar       = pPFM->dfFirstChar;
    pFInData->PFMH.dfLastChar        = pPFM->dfLastChar;
    pFInData->PFMH.dfDefaultChar     = pPFM->dfDefaultChar;
    pFInData->PFMH.dfBreakChar       = pPFM->dfBreakChar;

    pFInData->PFMH.dfWidthBytes      = DwAlign2( pPFM->b_dfWidthBytes );

    pFInData->PFMH.dfDevice          = DwAlign4( pPFM->b_dfDevice );
    pFInData->PFMH.dfFace            = DwAlign4( pPFM->b_dfFace );
    pFInData->PFMH.dfBitsPointer     = DwAlign4( pPFM->b_dfBitsPointer );
    pFInData->PFMH.dfBitsOffset      = DwAlign4( pPFM->b_dfBitsOffset );


    /*
     *   The PFMEXTENSION follows the PFMHEADER structure plus any width
     *  table info.  The width table will be present if the PFMHEADER has
     *  a zero width dfPixWidth.  If present,  adjust the extension address.
     */

    pb = pFInData->pBase + sizeof( res_PFMHEADER );  /* Size in resource data */

    if( pFInData->PFMH.dfPixWidth == 0 )
    {
        pb += (pFInData->PFMH.dfLastChar - pFInData->PFMH.dfFirstChar + 2) *
              sizeof( short );
    }

    pR_PFME = (res_PFMEXTENSION *)pb;

    //
    // Now convert the extended PFM data.
    //

    pFInData->PFMExt.dfSizeFields       = pR_PFME->dfSizeFields;

    pFInData->PFMExt.dfExtMetricsOffset = DwAlign4( pR_PFME->b_dfExtMetricsOffset );
    pFInData->PFMExt.dfExtentTable      = DwAlign4( pR_PFME->b_dfExtentTable );

    pFInData->PFMExt.dfOriginTable      = DwAlign4( pR_PFME->b_dfOriginTable );
    pFInData->PFMExt.dfPairKernTable    = DwAlign4( pR_PFME->b_dfPairKernTable );
    pFInData->PFMExt.dfTrackKernTable   = DwAlign4( pR_PFME->b_dfTrackKernTable );
    pFInData->PFMExt.dfDriverInfo       = DwAlign4( pR_PFME->b_dfDriverInfo );
    pFInData->PFMExt.dfReserved         = DwAlign4( pR_PFME->b_dfReserved );

    CopyMemory( &pFInData->DI,
                pFInData->pBase + pFInData->PFMExt.dfDriverInfo,
                sizeof( DRIVERINFO ) );

    //
    // Also need to fill in the address of the EXTTEXTMETRIC. This
    // is obtained from the extended PFM data that we just converted!
    //

    if( pFInData->PFMExt.dfExtMetricsOffset )
    {
        //
        //    This structure is only an array of shorts, so there is
        //  no alignment problem.  However,  the data itself is not
        //  necessarily aligned in the resource!
        //

        int    cbSize;
        BYTE  *pbIn;             /* Source of data to shift */

        pbIn = pFInData->pBase + pFInData->PFMExt.dfExtMetricsOffset;
        cbSize = DwAlign2( pbIn );

        if( cbSize == sizeof( EXTTEXTMETRIC ) )
        {
            /*   Simply copy it!  */
            CopyMemory( pFInData->pETM, pbIn, cbSize );
        }
        else
        {
            pFInData->pETM = NULL;        /* Not our size, so best not use it */
        }

    }
    else
    {
        pFInData->pETM = NULL;             /* Is non-zero when passed in */
    }


    return TRUE;
}

BOOL
BGetWidthVectorFromPFM(
    HANDLE   hHeap,
    FONTIN  *pFInData,        // Details of the current font 
    PSHORT   *ppWidth,
    PDWORD    pdwSize)
{

    //
    // For debugging code,  verify that we have a width table!  Then,
    // allocate memory and copy into it.
    //

    int     icbSize;                 // Number of bytes required

    if( pFInData->PFMH.dfPixWidth )
    {
        ERR(( "BGetWidthVectorFromPFM called for FIXED PITCH FONT\n" ));
        return  FALSE;
    }

    //
    // There are LastChar - FirstChar width entries,  plus the default
    // char.  And the widths are shorts.
    //

    icbSize = (pFInData->PFMH.dfLastChar - pFInData->PFMH.dfFirstChar + 2) *
              sizeof( short );

    *ppWidth = (PSHORT) HeapAlloc( hHeap, 0, icbSize );
    *pdwSize = icbSize;

    //
    // If this is a bitmap font,  then use the width table, but use
    // the extent table (in PFMEXTENSION area) as these are ready to
    // to scale.
    //


    if( *ppWidth )
    {
        BYTE   *pb;

        if( pFInData->pETM &&
            pFInData->pETM->emMinScale != pFInData->pETM->emMaxScale &&
            pFInData->PFMExt.dfExtentTable )
        {
            //
            //   Scalable,  so use the extent table
            //

            pb = pFInData->pBase + pFInData->PFMExt.dfExtentTable;
        }
        else
        {
            //
            //   Not scalable
            //

            pb = pFInData->pBase + sizeof( res_PFMHEADER );
        }

        CopyMemory( *ppWidth, pb, icbSize );
    }
    else
    {
        ERR(( "GetWidthVec(): HeapAlloc( %ld ) fails\n", icbSize ));
        return FALSE;
    }


    return  TRUE;
}


BOOL
BGetKerningPairFromPFM(
    HANDLE       hHeap,
    FONTIN     *pFInData, 
    w3KERNPAIR **ppSrcKernPair)
{

    if (pFInData->PFMExt.dfPairKernTable)
    {
        *ppSrcKernPair = (w3KERNPAIR*)(pFInData->pBase + pFInData->PFMExt.dfPairKernTable);
        return TRUE;
    }

    return FALSE;
}

LONG
LCtt2Cc(
    IN SHORT sTransTable,
    IN SHORT sCharSet)
{
    LONG lRet;

    if (sTransTable > 0)
    {
        lRet = (LONG)sTransTable;
    }
    else
    {
        switch (sTransTable)
        {
        case CTT_CP437:
        case CTT_CP850:
        case CTT_CP863:
            lRet = (LONG)sTransTable;
            break;

        case CTT_BIG5:
            lRet = (LONG)CC_BIG5;
            break;

        case CTT_ISC:
            lRet = (LONG)CC_ISC;
            break;

        case CTT_JIS78:
        case CTT_JIS83:
            lRet = (LONG)CC_JIS;
            break;

        case CTT_JIS78_ANK:
        case CTT_JIS83_ANK:
            lRet = (LONG)CC_JIS_ANK;
            break;

        case CTT_NS86:
            lRet = (LONG)CC_NS86;
            break;

        case CTT_TCA:
            lRet = (LONG)CC_TCA;
            break;

        default:
            switch (sCharSet)
            {
            case SHIFTJIS_CHARSET:
                lRet = CC_SJIS;
                break;

            case HANGEUL_CHARSET:
                lRet = CC_WANSUNG;
                break;

            case GB2312_CHARSET:
                lRet = CC_GB2312;
                break;

            case CHINESEBIG5_CHARSET:
                lRet = CC_BIG5;
                break;

            default:
                lRet = 0;
                break;
            }
            break;
        }
    }

    return lRet;
}

WORD
WGetGlyphHandle(
    PUNI_GLYPHSETDATA pGlyph,
    WORD wUnicode)
{

    PGLYPHRUN pGlyphRun;
    DWORD     dwI;
    WORD      wGlyphHandle;
    BOOL      bFound;

    pGlyphRun         = (PGLYPHRUN)((PBYTE)pGlyph + pGlyph->loRunOffset);
    wGlyphHandle      = 0;
    bFound            = FALSE;

    for (dwI = 0; dwI < pGlyph->dwRunCount; dwI ++)
    {
        if (pGlyphRun->wcLow <= wUnicode &&
            wUnicode < pGlyphRun->wcLow + pGlyphRun->wGlyphCount)
        {
            // 
            // Glyph handle starting from ONE!
            //

            wGlyphHandle += wUnicode - pGlyphRun->wcLow + 1;
            bFound        = TRUE;
            break;
        }

        wGlyphHandle += pGlyphRun->wGlyphCount;
        pGlyphRun++;
    }

    if (!bFound)
    {
        //
        // Couldn't find.
        //

        wGlyphHandle = 0;
    }

    return wGlyphHandle;
}


BOOL
BCreateWidthTable(
    IN HANDLE        hHeap,
    IN PWORD         pwGlyphHandleVector,
    IN WORD          wFirst,
    IN WORD          wLast,
    IN PSHORT        psWidthVectorSrc,
    OUT PWIDTHTABLE *ppWidthTable,
    OUT PDWORD       pdwWidthTableSize)
{
    struct {
        WORD wGlyphHandle;
        WORD wCharCode;
    } GlyphHandleVectorTrg[256];

    PWIDTHRUN pWidthRun;
    DWORD     loWidthTableOffset;
    PWORD     pWidth;
    WORD      wI, wJ;
    WORD      wHandle, wMiniHandle, wMiniHandleId, wRunCount;

    //
    // Sort in the order of Glyph Handle.
    // Simple sort
    // Basically it's not necessary to think about a performance.
    //
    // pwGlyphHandleVector 0 -> glyph handle of character code wFirst
    //                     1 -> glyph handle of character code wFirst + 1
    //                     2 -> glyph handle of character code wFirst + 2
    //                     ...
    //
    // GlyphHandleVectorTrg 0 -> minimum glyph handle
    //                      1 -> second minimum glyph handle
    //                      2 -> third minimum glyph handle
    //

    for (wJ = 0; wJ <= wLast - wFirst; wJ++)
    {
        wMiniHandle = 0xFFFF;
        wMiniHandleId =  wFirst;

        for (wI = wFirst ; wI <= wLast; wI++)
        {
            if (wMiniHandle > pwGlyphHandleVector[wI])
            {
                wMiniHandle   = pwGlyphHandleVector[wI];
                wMiniHandleId = wI;
            }
        }

        pwGlyphHandleVector[wMiniHandleId]    = 0xFFFF;
        GlyphHandleVectorTrg[wJ].wGlyphHandle = wMiniHandle;
        GlyphHandleVectorTrg[wJ].wCharCode    = wMiniHandleId;
    }

    //
    // Count Width run
    //

    wHandle   = GlyphHandleVectorTrg[0].wGlyphHandle;
    wRunCount = 1;

    for (wI = 1; wI < wLast - wFirst + 1 ; wI++)
    {
        if (++wHandle != GlyphHandleVectorTrg[wI].wGlyphHandle)
        {
            wHandle = GlyphHandleVectorTrg[wI].wGlyphHandle;
            wRunCount ++;
        }
    }

    //
    // Allocate WIDTHTABLE buffer
    //

    *pdwWidthTableSize = sizeof(WIDTHTABLE) +
                         (wRunCount - 1) * sizeof(WIDTHRUN) +
                         sizeof(SHORT) * wLast + 1 - wFirst;
               
    *ppWidthTable = HeapAlloc(hHeap,
                              0,
                              *pdwWidthTableSize);

    if (!*ppWidthTable)
    {
        *pdwWidthTableSize = 0;
        return FALSE;
    }

    //
    // Fill in a WIDTHTABLE
    //

    (*ppWidthTable)->dwSize   = sizeof(WIDTHTABLE) +
                                sizeof(WIDTHRUN) * (wRunCount - 1) +
                                sizeof(SHORT) * (wLast + 1 - wFirst);
    (*ppWidthTable)->dwRunNum = wRunCount;

    loWidthTableOffset = sizeof(WIDTHTABLE) +
                         (wRunCount - 1) * sizeof(WIDTHRUN); 

    pWidth = (PWORD)((PBYTE)*ppWidthTable + loWidthTableOffset);
    pWidthRun = (*ppWidthTable)->WidthRun;

    wHandle =
    pWidthRun[0].wStartGlyph       = GlyphHandleVectorTrg[0].wGlyphHandle;
    pWidthRun[0].loCharWidthOffset = loWidthTableOffset;

    pWidthRun[0].wGlyphCount = 1;
    wJ = 1;
    wI = 0;

    while (wI < wRunCount)
    {
        while (GlyphHandleVectorTrg[wJ].wGlyphHandle == ++wHandle)
        {
            pWidthRun[wI].wGlyphCount ++;
            wJ ++;
        };

        wI++;
        wHandle = 
        pWidthRun[wI].wStartGlyph       = GlyphHandleVectorTrg[wJ].wGlyphHandle;
        pWidthRun[wI].loCharWidthOffset = loWidthTableOffset;
        pWidthRun[wI].wGlyphCount       = 1;

        loWidthTableOffset += sizeof(SHORT) *
                              pWidthRun[wI].wGlyphCount;
        wJ ++;
    }

    for (wI = 0; wI < wLast + 1 - wFirst; wI ++)
    {
        pWidth[wI] = psWidthVectorSrc[GlyphHandleVectorTrg[wI].wCharCode-wFirst];
    }

    return TRUE;
}


BOOL
BCreateKernData(
    HANDLE      hHeap,
    w3KERNPAIR *pKernPair,
    DWORD       dwCodePage,
    PKERNDATA  *ppKernData,
    PDWORD      pdwKernDataSize)
{
    FD_KERNINGPAIR   *pDstKernPair;
    DWORD             dwNumOfKernPair;
    DWORD             dwI, dwJ, dwId;
    WORD              wUnicode[2];
    WCHAR             wcMiniSecond, wcMiniFirst;
    BYTE              ubMultiByte[2];
    BOOL              bFound;

    //
    // Count kerning pairs
    //

    dwNumOfKernPair = 0;

    while( pKernPair[dwNumOfKernPair].kpPair.each[0] != 0 &&
           pKernPair[dwNumOfKernPair].kpPair.each[1] != 0  )
           
    {
        dwNumOfKernPair ++;
    }

    if (!dwNumOfKernPair)
    {
        *pdwKernDataSize = 0;
        *ppKernData = NULL;

        return TRUE;
    }

    //
    // Allocate memory
    //

    *pdwKernDataSize = sizeof(FD_KERNINGPAIR) * dwNumOfKernPair;

    pDstKernPair = HeapAlloc(hHeap,
                             HEAP_ZERO_MEMORY,
                             *pdwKernDataSize);
                             
    if (!pDstKernPair)
    {
        HeapDestroy(hHeap);
        return FALSE;
    }

    //
    // Convert kerning pair table from character code base to unicode base.
    //

    for (dwI = 0; dwI < dwNumOfKernPair; dwI ++)
    {
        ubMultiByte[0] = (BYTE)pKernPair->kpPair.each[0];
        ubMultiByte[1] = (BYTE)pKernPair->kpPair.each[1];

        MultiByteToWideChar(dwCodePage,
                            0,
                            (LPCSTR)ubMultiByte,
                            2,
                            (LPWSTR)wUnicode,
                            2);

        pDstKernPair[dwI].wcFirst  = wUnicode[0];
        pDstKernPair[dwI].wcSecond = wUnicode[1];
        pDstKernPair[dwI].fwdKern  = pKernPair->kpKernAmount;
        pKernPair++;
    }

    //
    // Sort kerning pair table.  
    //  An extra FD_KERNPAIR is allocated for the NULL sentinel 
    //  (built into KERNDATA size)- it is zero'd by the HeapAlloc
    //

    *pdwKernDataSize += sizeof(KERNDATA);

    (*ppKernData) = HeapAlloc(hHeap,
                              HEAP_ZERO_MEMORY,
                              *pdwKernDataSize);
                             
    if (*ppKernData == NULL)
    {
        HeapDestroy(hHeap);
        return FALSE;
    }

    //
    // Fill the final format of kerning pair.
    //

    (*ppKernData)->dwSize        = *pdwKernDataSize;
    (*ppKernData)->dwKernPairNum = dwNumOfKernPair;

    for (dwI = 0; dwI < dwNumOfKernPair; dwI ++)
    {
        wcMiniSecond = 0xFFFF;
        wcMiniFirst  = 0xFFFF;
        dwId         = 0xFFFF;
        bFound       = FALSE;

        for (dwJ = 0; dwJ < dwNumOfKernPair; dwJ ++)
        {
            if (pDstKernPair[dwJ].wcSecond < wcMiniSecond)
            {
                wcMiniSecond = pDstKernPair[dwJ].wcSecond;
                wcMiniFirst  = pDstKernPair[dwJ].wcFirst;
                dwId         = dwJ;
                bFound       = TRUE;
            }
            else
            if (pDstKernPair[dwJ].wcSecond == wcMiniSecond)
            {
                if (pDstKernPair[dwJ].wcFirst < wcMiniFirst)
                {
                    wcMiniFirst  = pDstKernPair[dwJ].wcFirst;
                    dwId         = dwJ;
                    bFound       = TRUE;
                }
            }
        }

        if (bFound)
        {
            (*ppKernData)->KernPair[dwI].wcFirst  = wcMiniFirst;
            (*ppKernData)->KernPair[dwI].wcSecond = wcMiniSecond;
            (*ppKernData)->KernPair[dwI].fwdKern  = 
                                      pDstKernPair[dwId].fwdKern;
            pDstKernPair[dwId].wcSecond = 0xFFFF;
            pDstKernPair[dwId].wcFirst  = 0xFFFF;
        }
    }

    return TRUE;
}

BOOL
BConvertPFM2UFM(
    HANDLE            hHeap,
    PBYTE             pPFMData, 
    PUNI_GLYPHSETDATA pGlyph,
    DWORD             dwCodePage,
    PFONTMISC         pMiscData,
    PFONTIN           pFInData,
    INT               iGTTID,
    PFONTOUT          pFOutData,
    DWORD             dwFlags)
{
    DWORD   dwOffset;
    DWORD   dwI;
    SHORT   sWidthVectorSrc[256];
    WORD    awMtoUniDst[256];
    WORD    awGlyphHandle[256];
    BYTE    aubMultiByte[256];


    //
    // Zero out the header structure.  This means we can ignore any
    // irrelevant fields, which will then have the value 0, which is
    // the value for not used.
    //


    pFInData->pBase = pPFMData;

    if ( !BAlignPFM( pFInData))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // dwCodePage has to be same as pGlyph->loCodePageInfo->dwCodePage.
    //

    if (pGlyph && pGlyph->loCodePageOffset)
    {
        dwCodePage = ((PUNI_CODEPAGEINFO)((PBYTE)pGlyph +
                                    pGlyph->loCodePageOffset))->dwCodePage;
        
    }
    else
    {
        pGlyph = PGetDefaultGlyphset(hHeap,
                                     (WORD)pFInData->PFMH.dfFirstChar,
                                     (WORD)pFInData->PFMH.dfLastChar,
                                     dwCodePage);
    }

    if (NULL == pGlyph)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Fill in IFIMETRICS
    //

    if ( !BFontInfoToIFIMetric(hHeap,
                               pFInData,
                               pMiscData->pwstrUniqName,
                               pFInData->dwCodePageOfFacenameConv,
                               &pFOutData->pIFI,
                               &pFOutData->dwIFISize,
                               dwFlags))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if (BGetKerningPairFromPFM(hHeap, pFInData, &pFInData->pKernPair))
    {
        if (!BCreateKernData(hHeap,
                            pFInData->pKernPair,
                            dwCodePage,
                            &pFOutData->pKernData,
                            &pFOutData->dwKernDataSize))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        pFOutData->pIFI->cKerningPairs = pFOutData->pKernData->dwKernPairNum;
    }
    else
    {
        pFOutData->dwKernDataSize = 0;
        pFOutData->pKernData      = NULL;
    }

    BGetFontSelFromPFM(hHeap, pFInData, TRUE, &pFOutData->SelectFont);

    BGetFontSelFromPFM(hHeap, pFInData, FALSE, &pFOutData->UnSelectFont);

    if( pFInData->PFMH.dfPixWidth == 0 &&
        BGetWidthVectorFromPFM(hHeap,
                               pFInData,
                               &(pFInData->psWidthTable),
                               &(pFInData->dwWidthTableSize)))
    {
        for (dwI = 0; dwI < 256; dwI++)
        {
            aubMultiByte[dwI] = (BYTE)dwI;
        }

        MultiByteToWideChar(dwCodePage,
                            0,
                            (LPCSTR)aubMultiByte,
                            256,
                            (LPWSTR)awMtoUniDst,
                            256 );
                            
        //
        // Glyph handle base
        //

        for (dwI = (DWORD)pFInData->PFMH.dfFirstChar;
             dwI <= (DWORD)pFInData->PFMH.dfLastChar;
             dwI ++)
        {
            awGlyphHandle[dwI] = WGetGlyphHandle(pGlyph, awMtoUniDst[dwI]);
        }

        if (!BCreateWidthTable(hHeap,
                               awGlyphHandle,
                               (WORD)pFInData->PFMH.dfFirstChar,
                               (WORD)pFInData->PFMH.dfLastChar,
                               pFInData->psWidthTable,
                               &pFOutData->pWidthTable,
                               &pFOutData->dwWidthTableSize))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    else
    {
        pFOutData->dwWidthTableSize = 0;
        pFOutData->pWidthTable      = NULL;
    }

    //
    // Fill in UNIFM
    //

    //  Fix the ETM pointer, instead oi leaving it uninitialized.
    pFOutData -> pETM = pFInData -> pETM;

    pFOutData->UniHdr.dwSize            = sizeof(UNIFM_HDR) +
                                          DWORD_ALIGN(sizeof(UNIDRVINFO) +
                                          pFOutData->SelectFont.dwSize +
                                          pFOutData->UnSelectFont.dwSize) +
                                          pFOutData->dwIFISize +
                                          !!pFOutData -> pETM * sizeof(EXTTEXTMETRIC) +
                                          pFOutData->dwWidthTableSize +
                                          pFOutData->dwKernDataSize;
    pFOutData->UniHdr.dwVersion         = UNIFM_VERSION_1_0;
    pFOutData->UniHdr.ulDefaultCodepage = dwCodePage;
                       
    pFOutData->UniHdr.lGlyphSetDataRCID = iGTTID;

    pFOutData->UniHdr.loUnidrvInfo      = sizeof(UNIFM_HDR);

    pFOutData->UniHdr.loIFIMetrics      = pFOutData->UniHdr.loUnidrvInfo +
                                          DWORD_ALIGN(sizeof(UNIDRVINFO) +
                                          pFOutData->SelectFont.dwSize +
                                          pFOutData->UnSelectFont.dwSize);

    dwOffset = pFOutData->UniHdr.loIFIMetrics + pFOutData->dwIFISize;

    if  (pFOutData->pETM)
    {
        pFOutData->UniHdr.loExtTextMetric = dwOffset;
        dwOffset += sizeof(EXTTEXTMETRIC);
    }
    else 
    {
        pFOutData->UniHdr.loExtTextMetric = 0;
    }

    if (pFOutData->dwWidthTableSize && pFOutData->pWidthTable)
    {
        pFOutData->UniHdr.loWidthTable = dwOffset;
        dwOffset += pFOutData->dwWidthTableSize;
    }
    else
    {
        pFOutData->UniHdr.loWidthTable = 0;
    }

    if (pFOutData->dwKernDataSize && pFOutData->pKernData)
    {
        pFOutData->UniHdr.loKernPair = dwOffset;
    }
    else
    {
        pFOutData->UniHdr.loKernPair = 0;
    }

    memset(pFOutData->UniHdr.dwReserved, 0, sizeof pFOutData->UniHdr.dwReserved);

    //
    // Fill in DRIVERINFO
    //


    pFOutData->UnidrvInfo.dwSize           = DWORD_ALIGN(sizeof(UNIDRVINFO) +
                                           pFOutData->SelectFont.dwSize +
                                           pFOutData->UnSelectFont.dwSize);

    pFOutData->UnidrvInfo.flGenFlags       = 0;
    pFOutData->UnidrvInfo.wType            = pFInData->DI.wFontType;
    pFOutData->UnidrvInfo.fCaps            = pFInData->DI.fCaps;
    pFOutData->UnidrvInfo.wXRes            = pFInData->PFMH.dfHorizRes;
    pFOutData->UnidrvInfo.wYRes            = pFInData->PFMH.dfVertRes;
    pFOutData->UnidrvInfo.sYAdjust         = pFInData->DI.sYAdjust;
    pFOutData->UnidrvInfo.sYMoved          = pFInData->DI.sYMoved;
    pFOutData->UnidrvInfo.sShift           = pFInData->DI.sShift;
    pFOutData->UnidrvInfo.wPrivateData     = pFInData->DI.wPrivateData;

    if (pFOutData->pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY   |
                                   FM_INFO_ANISOTROPIC_SCALING_ONLY |
                                   FM_INFO_ARB_XFORMS)              )
    {
        pFOutData->UnidrvInfo.flGenFlags  |= UFM_SCALABLE;
    }

    dwOffset =  sizeof(UNIDRVINFO);

    if (pFOutData->SelectFont.dwSize != 0)
    {
        pFOutData->UnidrvInfo.SelectFont.loOffset = dwOffset;
        pFOutData->UnidrvInfo.SelectFont.dwCount  = pFOutData->SelectFont.dwSize;
        dwOffset += pFOutData->SelectFont.dwSize;
    }
    else
    {
        pFOutData->UnidrvInfo.SelectFont.loOffset  = (DWORD)0;
        pFOutData->UnidrvInfo.SelectFont.dwCount   = (DWORD)0;
    }

    if (pFOutData->UnSelectFont.dwSize != 0)
    {
        pFOutData->UnidrvInfo.UnSelectFont.loOffset  = dwOffset;
        pFOutData->UnidrvInfo.UnSelectFont.dwCount   = pFOutData->UnSelectFont.dwSize;
        dwOffset += pFOutData->UnSelectFont.dwSize;
    }
    else
    {
        pFOutData->UnidrvInfo.UnSelectFont.loOffset  = (DWORD)0;
        pFOutData->UnidrvInfo.UnSelectFont.dwCount   = (DWORD)0;
    }

    memset(pFOutData->UnidrvInfo.wReserved, 0, sizeof pFOutData->UnidrvInfo.wReserved);

    return TRUE;
}

PUNI_GLYPHSETDATA
PGetDefaultGlyphset(
    IN HANDLE hHeap,
    IN WORD   wFirstChar,
    IN WORD   wLastChar,
    IN DWORD  dwCodePage)
{
    PUNI_GLYPHSETDATA pGlyphSetData;
    PGLYPHRUN         pGlyphRun, pGlyphRunTmp;
    DWORD             dwcbBits, *pdwBits, dwNumOfRuns;
    WORD              wI, wNumOfHandle;
    WCHAR             awchUnicode[256], wchMax, wchMin;
    BYTE              aubAnsi[256];
    BOOL              bInRun;
    DWORD              dwGTTLen;
#ifdef BUILD_FULL_GTT
    PUNI_CODEPAGEINFO pCPInfo;
    PMAPTABLE          pMap;
    PTRANSDATA          pTrans;
    int                  i, j, k, m ;
    WORD              wUnicode ;
#endif

    wNumOfHandle = wLastChar - wFirstChar + 1;

    for( wI = wFirstChar; wI <= wLastChar; ++wI )
    {
        aubAnsi[wI - wFirstChar] = (BYTE)wI;
    }

    if( ! MultiByteToWideChar(dwCodePage,
                              0,
                              aubAnsi,
                              wNumOfHandle,
                              awchUnicode,
                              wNumOfHandle))
    {
        return NULL;
    }

    //
    //  Get min and max Unicode value
    //  Find the largest Unicode value, then allocate storage to allow us
    //  to  create a bit array of valid unicode points.  Then we can
    //  examine this to determine the number of runs.
    //

    for( wchMax = 0, wchMin = 0xffff, wI = 0; wI < wNumOfHandle; ++wI )
    {
        if( awchUnicode[ wI ] > wchMax )
            wchMax = awchUnicode[ wI ];
        if( awchUnicode[ wI ] < wchMin )
            wchMin = awchUnicode[ wI ];
    }

    //
    //  Create Unicode bits table from CTT.
    //  Note that the expression 1 + wchMax IS correct.   This comes about
    //  from using these values as indices into the bit array,  and that
    //  this is essentially 1 based.
    //

    dwcbBits = (1 + wchMax + DWBITS - 1) / DWBITS * sizeof( DWORD );

    if( !(pdwBits = (DWORD *)HeapAlloc( hHeap, 0, dwcbBits )) )
    {
        return  FALSE;     /*  Nothing going */
    }

    ZeroMemory( pdwBits, dwcbBits );

    //
    //   Set bits in this array corresponding to Unicode code points
    //

    for( wI = 0; wI < wNumOfHandle; ++wI )
    {
        pdwBits[ awchUnicode[ wI ] / DWBITS ]

                    |= (1 << (awchUnicode[ wI ] & DW_MASK));
    }

    //
    // Count the number of run.
    //

    //
    //  Now we can examine the number of runs required.  For starters,
    //  we stop a run whenever a hole is discovered in the array of 1
    //  bits we just created.  Later we MIGHT consider being a little
    //  less pedantic.
    //

    bInRun = FALSE;
    dwNumOfRuns = 0;

    for( wI = 0; wI <= wchMax; ++wI )
    {
        if( pdwBits[ wI / DWBITS ] & (1 << (wI & DW_MASK)) )
        {
            /*   Not in a run: is this the end of one? */
            if( !bInRun )
            {
                /*   It's time to start one */
                bInRun = TRUE;
                ++dwNumOfRuns;

            }

        }
        else
        {
            if( bInRun )
            {
                /*   Not any more!  */
                bInRun = FALSE;
            }
        }
    }

    //
    // 7. Allocate memory for GTT and begin to fill in its header.
    //

    dwGTTLen = sizeof(UNI_GLYPHSETDATA) + dwNumOfRuns *    sizeof(GLYPHRUN) ;
#ifdef BUILD_FULL_GTT
    dwGTTLen += sizeof(UNI_CODEPAGEINFO) + sizeof(MAPTABLE) 
                + sizeof(TRANSDATA) * (wNumOfHandle - 1) ;
#endif

    if( !(pGlyphSetData = (PUNI_GLYPHSETDATA)HeapAlloc(hHeap,
                                                       HEAP_ZERO_MEMORY,
                                                       dwGTTLen )) )
    {
        return  FALSE;
    }

#ifdef BUILD_FULL_GTT
    pGlyphSetData->dwSize         = dwGTTLen ;
    pGlyphSetData->dwVersion     = UNI_GLYPHSETDATA_VERSION_1_0 ;
    pGlyphSetData->lPredefinedID = CC_NOPRECNV ;
    pGlyphSetData->dwGlyphCount  = wNumOfHandle ;
#endif
    pGlyphSetData->dwRunCount    = dwNumOfRuns;
    pGlyphSetData->loRunOffset   = sizeof(UNI_GLYPHSETDATA);
    pGlyphRun = pGlyphRunTmp     = (PGLYPHRUN)(pGlyphSetData + 1);

    //
    // 8. Create GLYPHRUN
    //

    bInRun = FALSE;

    for (wI = 0; wI <= wchMax; wI ++)
    {
        if (pdwBits[ wI/ DWBITS ] & (1 << (wI & DW_MASK)) )
        {
            if (!bInRun)
            {
                bInRun = TRUE;
                pGlyphRun->wcLow = wI;
                pGlyphRun->wGlyphCount = 1;
            }
            else
            {
                pGlyphRun->wGlyphCount++;
            }
        }
        else
        {

            if (bInRun)
            {
                bInRun = FALSE;
                pGlyphRun++;
            }
        }
    }

    //
    // 9. Create CODEPAGEINFO and set related GTT header fields.
    //

#ifdef BUILD_FULL_GTT
    pGlyphSetData->dwCodePageCount = 1 ;
    pGlyphSetData->loCodePageOffset = pGlyphSetData->loRunOffset 
                                      + dwNumOfRuns * sizeof(GLYPHRUN) ;
    pCPInfo = (PUNI_CODEPAGEINFO) 
              ((UINT_PTR) pGlyphSetData + pGlyphSetData->loCodePageOffset) ;
    pCPInfo->dwCodePage = dwCodePage ;
    pCPInfo->SelectSymbolSet.dwCount = pCPInfo->SelectSymbolSet.loOffset = 0 ;
    pCPInfo->UnSelectSymbolSet.dwCount = pCPInfo->UnSelectSymbolSet.loOffset = 0 ;

    //
    // 10. Create MAPTABLE and set related GTT header fields.
    //

    pGlyphSetData->loMapTableOffset = pGlyphSetData->loCodePageOffset +
                                      sizeof(UNI_CODEPAGEINFO) ;
    pMap = (PMAPTABLE) ((UINT_PTR) pGlyphSetData + pGlyphSetData->loMapTableOffset) ;
    pMap->dwSize = sizeof(MAPTABLE) + sizeof(TRANSDATA) * (wNumOfHandle - 1) ;
    pMap->dwGlyphNum = wNumOfHandle ;
    pTrans = (PTRANSDATA) &(pMap->Trans[0]) ;        

    pGlyphRun = pGlyphRunTmp ;
    for (i = m = 0 ; i <= (int) pGlyphSetData->dwRunCount ; i++, pGlyphRun++) {
        for (j = 0 ; j <= pGlyphRun->wGlyphCount ; j ++) {
            wUnicode = pGlyphRun->wcLow + j ;
            for (k = 0 ; k <= 255 ; k ++) 
                if (wUnicode == awchUnicode[k])
                    break ;
            ASSERT(k < 256) ;
            pTrans->uCode.ubCode = aubAnsi[k] ;
            pTrans->ubCodePageID = 0 ;
            pTrans->ubType = MTYPE_DIRECT ;
            pTrans++;
        } ;
        m += pGlyphRun->wGlyphCount ;
    } ;
    ASSERT(m != wNumOfHandle) ;
#endif

    return pGlyphSetData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\udgtt\dgtt.c ===
/*
 *    dgtt - dump GTT file
 *
 *    TODO:
 *
 *    HISTORY:
 *
 *    4/28/99 yasuho        Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

#include <windows.h>

#include <prntfont.h>

char *version = "dgtt.exe v0.9 1999/4/28";

FILE        *in, *out, *logfile;
UNI_GLYPHSETDATA gtt;
UNI_CODEPAGEINFO cpi;
GLYPHRUN        run;
MAPTABLE        map;
TRANSDATA    tr;

#define ISQUOTE(c) \
    (!((c) > 0x20 && (c) < 0x7f && (c) != '<' && (c) != '>'))
#define BEGINQUOTE "<"
#define ENDQUOTE ">"

char *namestr = "dgtt";
char *usagestr = "dgtt [-v] gttfile [txtfile]";

#include "utils.c"

typedef struct {
    INT iCp;
    BYTE *pCmdSel;
    INT iCmdSelLen;
    BYTE *pCmdUnsel;
    INT iCmdUnselLen;
} CPCMDINFO;

CPCMDINFO *pCpCmdInfo;

typedef struct {
    WORD wUc;
    INT iCp;
    BYTE jType;
    BYTE *pCmd;
    INT iCmdLen;
} GINFO;

GINFO *pGInfo;

INT bVerbose;

/*
 *    PrintString
 */
void PrintString(
    FILE *fp,
    PBYTE str, DWORD offset, DWORD count)
{
    PBYTE        cp;
    DWORD        di;

    cp = NULL;
    fprintf(fp, "%s", str);
    if (count == 0)
        goto done;
    if ((cp = malloc(count)) == NULL)
        fatal("malloc PrintString");
    if (fseek(in, offset, 0) < 0)
        fatal("fseek PrintString");
    if (fread(cp, count, 1, in) != 1)
        fatal("fread PrintString");
    fprintf(fp, "0x");
    for (di = 0; di < count; di++)
        fprintf(fp, "%02x", (BYTE)cp[di]);
done:
    fprintf(fp, "\n");
    if (cp)
        free(cp);
}

void
PrintQuoted(
    FILE *fp,
    PBYTE buf,
    int n)
{
    int c, i, fquoted;

    fprintf(fp, "\"");

    fquoted = 0;
    for (i = 0; i < n; i++) {
        c = buf[i];

        if (ISQUOTE(c)) {
            if (!fquoted) {
                fprintf(fp, BEGINQUOTE);
                fquoted = !fquoted;
            }
            fprintf(fp, "%02x", c);
        }
        else {
            if (fquoted) {
                fprintf(fp, ENDQUOTE);
                fquoted = !fquoted;
            }
            fprintf(fp, "%c", c);
        }
    }
    if (fquoted) {
        fprintf(fp, ENDQUOTE);
    }

    fprintf(fp, "\"");
}

/*
 *    PrintTRANSCmd
 */
void PrintTRANSCmd(
    TRANSDATA *tp,
    INT di)
{
    PBYTE        cmd;
    WORD        len;
    DWORD        offset;

    offset = gtt.loMapTableOffset + tp->uCode.sCode;
    if (fseek(in, offset, 0) < 0)
        fatal("fseek PrintTRANSCmd");
    if (fread(&len, sizeof len, 1, in) != 1)
        fatal("fread PrintTRANSCmd");
//    fprintf(out, "; Size=%d\n", len);
    if (len == 0)
        return;
    if ((cmd = malloc(len)) == NULL)
        fatal("malloc PrintTRANSCmd");
    if (fread(cmd, len, 1, in) != 1)
        fatal("fread PrintTRANSCmd");

    if (bVerbose) {
        fprintf(logfile, "; ");
        PrintQuoted(logfile, cmd, len);
        fprintf(logfile, "\n");
    }

    pGInfo[di].pCmd = cmd;
    pGInfo[di].iCmdLen = len;
}

void
PrintDump(
    FILE *fp,
    PBYTE buf,
    int n)
{
    INT i;

    for (i = 0; i < n; i++) {
        if (i > 0) {
            fprintf(fp, " ");
        }
        fprintf(fp, "%d", buf[i]);
    }
}

LoadCmdString(
    BYTE **buf,
    DWORD offset,
    DWORD count)
{
    PBYTE        cp;

    if (count == 0)
        return 0;

    if ((cp = malloc(count)) == NULL)
        fatal("malloc PrintString");
    if (fseek(in, offset, 0) < 0)
        fatal("fseek PrintString");
    if (fread(cp, count, 1, in) != 1)
        fatal("fread PrintString");

    *buf = cp;
    return count;
}

/*
 *    dumpgtt
 */
void dumpgtt()
{
    DWORD        di, offset, count, gid;
    INT i, j, k;
    BYTE ajBuf[5];

    //
    // leave informational comment in the dump logfile
    //
    fprintf(out, ";\n");
    fprintf(out, ";\n; created by %s\n", version);
    fprintf(out, ";\n");

    //
    //    GLYPHSETDATA
    //
    if (fread(&gtt, sizeof gtt, 1, in) != 1)
        fatal("GLYPHSETDATA");

    if (bVerbose) {
        fprintf(logfile, ";\n");
        fprintf(logfile, "; UNI_GLYPHSETDATA\n");
        fprintf(logfile, "; dwSize=%ld\n", gtt.dwSize);
        fprintf(logfile, "; dwVersion=0x%lx\n", gtt.dwVersion);
        fprintf(logfile, "; dwFlags=0x%lx\n", gtt.dwFlags);
        fprintf(logfile, "; lPredefinedID=%ld\n", gtt.lPredefinedID);
        fprintf(logfile, "; dwGlyphCount=%ld\n", gtt.dwGlyphCount);
        fprintf(logfile, "; dwRunCount=%ld\n", gtt.dwRunCount);
        fprintf(logfile, "; loRunOffset=0x%lx\n", gtt.loRunOffset);
        fprintf(logfile, "; dwCodePageCount=%ld\n", gtt.dwCodePageCount);
        fprintf(logfile, "; loCodePageOffset=0x%lx\n", gtt.loCodePageOffset);
        fprintf(logfile, "; loMapTableOffset=0x%lx\n", gtt.loMapTableOffset);
        fprintf(logfile, ";\n");
    }

    fprintf(out, ";\n");
    fprintf(out, "; (header)\n");
    fprintf(out, "H\n"); // keyword
    fprintf(out, "%08x ; dwVersion\n", gtt.dwVersion);
    fprintf(out, "%08x ; dwFlags\n", gtt.dwFlags);
    fprintf(out, "%ld ; lPredefinedID\n", gtt.lPredefinedID);

    pGInfo = (GINFO *)malloc(sizeof (GINFO) * gtt.dwGlyphCount);
    if (NULL == pGInfo) {
        fatal("error allocating memory");
    }

    //
    //    CODEPAGEINFO
    //


    pCpCmdInfo = (CPCMDINFO *)malloc(
        sizeof (CPCMDINFO) * gtt.dwCodePageCount);
    if (NULL == pCpCmdInfo) {
        fatal("error allocating memory");
    }

    offset = gtt.loCodePageOffset;
    for (di = 0; di < gtt.dwCodePageCount; di++) {
        if (fseek(in, offset, 0) < 0)
            fatal("fseek CODEPAGEINFO");
        if (fread(&cpi, sizeof cpi, 1, in) != 1)
            fatal("CODEPAGEINFO");
        offset += sizeof cpi;

        pCpCmdInfo[di].iCp = (INT)cpi.dwCodePage;
        LoadCmdString(&(pCpCmdInfo[di].pCmdSel),
            cpi.SelectSymbolSet.loOffset,
            cpi.SelectSymbolSet.dwCount);
        pCpCmdInfo[di].iCmdSelLen = cpi.SelectSymbolSet.dwCount;

        LoadCmdString(&(pCpCmdInfo[di].pCmdUnsel),
            cpi.UnSelectSymbolSet.loOffset,
            cpi.UnSelectSymbolSet.dwCount);
        pCpCmdInfo[di].iCmdUnselLen = cpi.UnSelectSymbolSet.dwCount;

        if (bVerbose) {
            fprintf(logfile, ";\n");
            fprintf(logfile, "; UNI_CODEPAGEINFO (%d)\n", di+1);
            fprintf(logfile, "; dwCodePage=%ld\n", cpi.dwCodePage);
            fprintf(logfile, "; SelectSymbolSet.dwCount=%ld\n",
                cpi.SelectSymbolSet.dwCount);
            PrintString(logfile, "; SelectSymbolSet.Cmd=",
                cpi.SelectSymbolSet.loOffset,
                cpi.SelectSymbolSet.dwCount);
            fprintf(logfile, "; UnSelectSymbolSet.dwCount=%ld\n",
                cpi.UnSelectSymbolSet.dwCount);
            PrintString(logfile, "; UnSelectSymbolSet.Cmd=",
                cpi.UnSelectSymbolSet.loOffset,
                cpi.UnSelectSymbolSet.dwCount);
            fprintf(logfile, ";\n");
        }
    }


    fprintf(out, ";\n");
    fprintf(out, "; (codepage definitions)\n");
    fprintf(out, "C\n"); // keyword
    fprintf(out, "%ld ; dwCodePageCount\n", gtt.dwCodePageCount);

    for (i = 0; i < (INT)gtt.dwCodePageCount; i++) {

        fprintf(out, "%ld ; dwCodePage\n", pCpCmdInfo[i].iCp);

        PrintDump(out, pCpCmdInfo[i].pCmdSel, pCpCmdInfo[i].iCmdSelLen);
        fprintf(out, " ; ");
        PrintQuoted(out, pCpCmdInfo[i].pCmdSel, pCpCmdInfo[i].iCmdSelLen);
        fprintf(out, " (SelectSymbolSet)\n");

        PrintDump(out, pCpCmdInfo[i].pCmdUnsel, pCpCmdInfo[i].iCmdUnselLen);
        fprintf(out, " ; ");
        PrintQuoted(out, pCpCmdInfo[i].pCmdUnsel, pCpCmdInfo[i].iCmdUnselLen);
        fprintf(out, " (UnSelectSymbolSet)\n");
    }

    //
    //    GLYPHRUN
    //
    gid = 1;
    k = 0;

    if (fseek(in, gtt.loRunOffset, 0) < 0)
        fatal("fseek loRunOffset");

    if (bVerbose) {
        fprintf(logfile, ";\n");
    }

    for (di = 0; di < gtt.dwRunCount; di++) {
        if (fread(&run, sizeof run, 1, in) != 1)
            fatal("fread GLYPHRUN");

        if (bVerbose) {
            fprintf(logfile, "; GLYPHRUN (%ld)\n", di+1);
            fprintf(logfile, "; wcLow=0x%04x\n", run.wcLow);
            fprintf(logfile, "; wGlyphCount=%ld\n", run.wGlyphCount);
            if (run.wGlyphCount > 1) {
                fprintf(logfile, "; (glyphs %d - %d)\n",
                    gid, (gid + run.wGlyphCount - 1));
            }
            else {
                fprintf(logfile, "; (glyph %d)\n", gid);
            }
            fprintf(logfile, ";\n");
        }

        for (j = 0; j < run.wGlyphCount; j++) {
            pGInfo[k++].wUc = run.wcLow + j;
        }

        gid += run.wGlyphCount;
    }

    //
    //    MAPTABLE
    //
    if (fseek(in, gtt.loMapTableOffset, 0) < 0)
        fatal("fseek MAPTABLE");
    count = sizeof(MAPTABLE) - sizeof(TRANSDATA);
    if (fread(&map, count, 1, in) != 1)
        fatal("fread MAPTABLE");

    if (bVerbose) {
        fprintf(logfile, ";\n");
        fprintf(logfile, "; MAPTABLE\n");
        fprintf(logfile, "; dwSize=%ld\n", map.dwSize);
        fprintf(logfile, "; dwGlyphNum=%ld\n", map.dwGlyphNum);
        fprintf(logfile, ";\n");
    }

    //
    //    TRANSDATA
    //

    if (bVerbose) {
        fprintf(logfile, ";\n");
    }

    offset = gtt.loMapTableOffset + count;
    for (di = 0; di < map.dwGlyphNum; di++) {
        if (fseek(in, offset, 0) < 0)
            fatal("fseek TRANSDATA");
        if (fread(&tr, sizeof tr, 1, in) != 1)
            fatal("fread TRANSDATA");
        offset += sizeof tr;

        pGInfo[di].iCp = tr.ubCodePageID;
        pGInfo[di].jType = tr.ubType;

        if (bVerbose) {
            fprintf(logfile, "; TRANSDATA (%d)\n", (di + 1));
            fprintf(logfile, "; ubCodePageID=%d\n",
                tr.ubCodePageID);
        }


        switch ((tr.ubType & MTYPE_FORMAT_MASK)) {
        case MTYPE_DIRECT:

            if (bVerbose) {
                fprintf(logfile, "; MTYPE_DIRECT\n");
                fprintf(logfile, "; ubCode=0x%02x\n", tr.uCode.ubCode);
            }

            pGInfo[di].iCmdLen = 1;
            pGInfo[di].pCmd = (BYTE *)malloc(1);
            pGInfo[di].pCmd[0] = tr.uCode.ubCode;

            break;
        case MTYPE_PAIRED:

            if (bVerbose) {
                fprintf(logfile, "; MTYPE_PAIRED\n");
                fprintf(logfile, "; ubPairs[0]=0x%02x\n", tr.uCode.ubPairs[0]);
                fprintf(logfile, "; ubPairs[1]=0x%02x\n", tr.uCode.ubPairs[1]);
            }

            pGInfo[di].iCmdLen = 2;
            pGInfo[di].pCmd = (BYTE *)malloc(2);
            pGInfo[di].pCmd[0] = tr.uCode.ubPairs[0];
            pGInfo[di].pCmd[1] = tr.uCode.ubPairs[1];

            break;
        case MTYPE_COMPOSE:

            if (bVerbose) {
                fprintf(logfile, "; MTYPE_COMPOSE\n");
                fprintf(logfile, "; sCode=0x%04x\n", tr.uCode.sCode);
            }

            PrintTRANSCmd(&tr, di);

            break;
        default:

            if (bVerbose) {
                fprintf(logfile, "; MTYPE_UNKNOWN (%02x)\n",
                    (tr.ubType & MTYPE_FORMAT_MASK));
                fprintf(logfile, "; sCode=0x%04x\n", tr.uCode.sCode);
            }
        }

        if (bVerbose) {
            fprintf(logfile, "; \n");
        }
    }

    fprintf(out, ";\n");
    fprintf(out, "; (glyph definitions)\n");
    fprintf(out, "G\n"); // keyword
    fprintf(out, "%d ; dwGlyphCount\n", gtt.dwGlyphCount);

    for (i = 0; i < (INT)gtt.dwGlyphCount; i++) {

        k = WideCharToMultiByte(pCpCmdInfo[0].iCp, 0,
            &(pGInfo[i].wUc), 1, ajBuf, sizeof(ajBuf), NULL, NULL);
        if (0 == k) {
            fatal("WideCharToMultiByte");
        }
        ajBuf[k] = '\0';

        fprintf(out, "%04x %d %d ",
            pGInfo[i].wUc, pGInfo[i].iCp, pGInfo[i].jType);
        PrintDump(out, pGInfo[i].pCmd, pGInfo[i].iCmdLen);
        fprintf(out, " ; (%02x) ", ajBuf[0]);
        PrintQuoted(out, pGInfo[i].pCmd, pGInfo[i].iCmdLen);
        fprintf(out, "\n");
    }

    fprintf(out, ";\n");

    for (i = 0; i < (INT)gtt.dwGlyphCount; i++) {
        free(pGInfo[i].pCmd);
    }
    free(pGInfo);
}


/*
 *    main
 */
void __cdecl main(int argc, char *argv[])
{
    INT i, j;

    argc--, argv++;

    if (argc == 0)
        usage();

    out = stdout;
    logfile = stdout;

    j = 0;
    for (i = 0; i < argc; i++) {

        if ('-' == argv[i][0]) {

            switch(argv[i][1]) {
            case 'v':
                bVerbose = 1;
                break;
            }
        }
        else {
            switch (j++) {
            case 0:
                if (NULL == (in = fopen(argv[i], "rb")))
                    fatal(argv[i]);
                break;
            case 1:
                if (NULL == (out = fopen(argv[i], "w")))
                    fatal(argv[1]);
                break;
            }
        }
    }

    dumpgtt();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\brush.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    brush.c

Abstract:

    DrvRealizeBrush

Environment:

    Windows NT Unidrv driver

Revision History:

    05/14/97 -amandan-
        Created

--*/

#include "unidrv.h"

BRGBColorSpace(PDEV *);


LONG
FindCachedHTPattern(
    PDEV    *pPDev,
    WORD    wChecksum
    )

/*++

Routine Description:

    This function find the cached text brush pattern color, if not there then
    it will add it to the cached.


Arguments:

    pPDev       - Pointer to our PDEV
    wCheckSum   - Checksum of pattern brush


Return Value:

    LONG    >0  - Found the cached, return value is the pattern ID
            =0  - Out of memory, not cached
            <0  - not in the cached, add to the cached, return value is
                  the negated pattern ID

Author:

    08-Apr-1997 Tue 19:42:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD  pDBCache;
    WORD    cMaxDB;
    WORD    cUsedDB;
    WORD    Index;


    //
    // The first is the cMaxDB, the 2nd is the cUsedDB
    //

    if (pDBCache = pPDev->GState.pCachedPatterns)
    {
        cMaxDB    = *(pDBCache + 0);
        cUsedDB   = *(pDBCache + 1);
        pDBCache += 2;

        for (Index = 1; Index <= cUsedDB; Index++, pDBCache++)
        {
            if (*pDBCache == wChecksum)
            {

                VERBOSE(("\n\tRaddd:FindCachedHTPat(%04lx): FOUND=%ld    ",
                            wChecksum, Index));

                return((LONG)Index);
            }
        }

        //
        // If we can't find a cached one, add the new one to the list
        //

        if (cUsedDB < cMaxDB)
        {
            *pDBCache               = wChecksum;
            *(pPDev->GState.pCachedPatterns + 1) += 1;

            VERBOSE(("\n\tRaddd:FindCachedHTPat(%04lx): NOT FOUND=%ld    ",
                        wChecksum, -(LONG)Index));

            return(-(LONG)Index);
        }

    }
    else
    {

        cUsedDB =
        cMaxDB  = 0;
    }

    //
    // We need to expand the checksum cached buffer
    //

    VERBOSE(("\n\tUnidrv:FindCachedHTPat(%04lx): pDBCache=%08lx, cUsedDB=%ld, cMaxDB=%ld",
                wChecksum, pDBCache, cUsedDB, cMaxDB));

    if (((cMaxDB + DBCACHE_INC) < DBCACHE_MAX)  &&
        (pDBCache = (LPWORD)MemAllocZ((cMaxDB + DBCACHE_INC + 2) *
                                                            sizeof(WORD))))
    {

        if ((cMaxDB) && (pPDev->GState.pCachedPatterns))
        {

            CopyMemory(pDBCache + 2,
                       pPDev->GState.pCachedPatterns + 2,
                       cMaxDB * sizeof(WORD));

            MemFree(pPDev->GState.pCachedPatterns);
        }

        *(pDBCache + 0)           = cMaxDB + DBCACHE_INC;
        *(pDBCache + 1)           = cUsedDB + 1;
        *(pDBCache + 2 + cUsedDB) = wChecksum;
        pPDev->GState.pCachedPatterns    = pDBCache;

        VERBOSE (("\n\tUnidrv:FindCachedHTPat(%04lx): pDBCache=%08lx, cUsedDB=%ld, cMaxDB=%ld, EMPTY=%ld   ",
                    wChecksum, pDBCache, *(pDBCache + 1), *(pDBCache + 0), -(LONG)(cUsedDB + 1)));

        return(-(LONG)(cUsedDB + 1));
    }

    //
    // Out of memory
    //

    WARNING(("\n\tUnidrv:FindCachedHTPat: OUT OF MEMORY"));

    return(0);

}


BOOL
Download1BPPHTPattern(
    PDEV    *pPDev,
    SURFOBJ *pso,
    DWORD   dwPatID
    )

/*++

Routine Description:

    This function donload a user define pattern

Arguments:

    pPDev       - Pointer to the PDEV

    pDevBrush   - Pointer to the cached device brush


Return Value:

    INT to indicate a pattern number downloaed/defined

Author:

    08-Apr-1997 Tue 19:41:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    SURFOBJ so;
    LPBYTE  pb;
    LPBYTE  pbEnd;
    LPBYTE  pSrc;
    DWORD   cbCX;
    DWORD   cb;
    WORD    cxcyRes;
    INT     Len;
    BYTE    Buf[64];
    BYTE    XorMask;
    BYTE    EndMask;


    so    = *pso;
    pb    = Buf;
    pbEnd = pb + sizeof(Buf) - 4;
    cbCX  = (DWORD)(((DWORD)so.sizlBitmap.cx + 7) >> 3);


    //
    // Update standard variable and send command
    //

    pPDev->dwPatternBrushType = BRUSH_USERPATTERN;
    pPDev->dwPatternBrushSize = (DWORD)(cbCX * so.sizlBitmap.cy) + 12;
    pPDev->dwPatternBrushID = dwPatID;

    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DOWNLOAD_PATTERN));


    //
    // Send header and pattern data
    //

    *pb++ = 20;
    *pb++ = 0;
    *pb++ = (so.iBitmapFormat == BMF_1BPP) ? 1 : 8;
    *pb++ = 0;
    *pb++ = HIBYTE((WORD)so.sizlBitmap.cx);
    *pb++ = LOBYTE((WORD)so.sizlBitmap.cx);
    *pb++ = HIBYTE((WORD)so.sizlBitmap.cy);
    *pb++ = LOBYTE((WORD)so.sizlBitmap.cy);
    *pb++ = HIBYTE((WORD)pPDev->ptGrxRes.x);
    *pb++ = LOBYTE((WORD)pPDev->ptGrxRes.x);
    *pb++ = HIBYTE((WORD)pPDev->ptGrxRes.y);
    *pb++ = LOBYTE((WORD)pPDev->ptGrxRes.y);

    //
    // The XorMask is used to flip the BLACK/WHITE bit depends on the output
    // and EndMask is to mask off any unwanted bit in the last byte to 0
    // this is to fix LJ5si, LJ4si firmware bugs, REMEMBER our palette always
    // in RGB additive mode so the passed in 1BPP format has 0=Black, 1=White
    //

    XorMask = (BRGBColorSpace(pPDev)) ? 0x00 : 0xff;

    if (!(EndMask = (BYTE)(0xff << (8 - (so.sizlBitmap.cx & 0x07)))))
    {
        EndMask = 0xff;
    }

    VERBOSE(("\n\tRaddd:DownLoaHTPattern: PatID=%ld, Format=%ld, %ld x %ld, XorMask=%02lx, EndMaks=%02lx\t\t",
          dwPatID, pso->iBitmapFormat, so.sizlBitmap.cx, so.sizlBitmap.cy,
          XorMask, EndMask));

    while (so.sizlBitmap.cy--)
    {
        cb                  = cbCX;
        pSrc                = so.pvScan0;
        (LPBYTE)so.pvScan0 += so.lDelta;

        while (cb--)
        {
            *pb++ = (BYTE)(*pSrc++ ^ XorMask);

            if (!cb) {

                *(pb - 1) &= EndMask;
            }

            if (pb >= pbEnd) {

                WriteSpoolBuf(pPDev, Buf, (DWORD)(pb - Buf));
                pb = Buf;
            }
        }
    }

    //
    // Send remaining data
    //

    if (Len = (INT)(pb - Buf))
    {
        WriteSpoolBuf(pPDev, Buf, Len);
    }

    return(TRUE);
}


WORD
GetBMPChecksum(
    SURFOBJ *pso,
    PRECTW  prcw
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1997 Tue 11:32:37 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  pb;
    RECTW   rcw;
    LONG    cy;
    LONG    cPixels;
    LONG    lDelta;
    WORD    wChecksum;
    UINT    c1stPixels;
    UINT    Format;
    BYTE    BegMask;
    BYTE    EndMask;
    BYTE    XorMask;


    rcw      = *prcw;
    Format   = (UINT)pso->iBitmapFormat;
    wChecksum = 0;

    VERBOSE(("\nComputeChecksum(%ld): (%4ld, %4ld)-(%4ld, %4ld)=%3ldx%3ld\t\t",
                Format, rcw.l, rcw.t, rcw.r, rcw.b,
                rcw.r - rcw.l, rcw.b - rcw.t));

    if (rcw.l > (WORD)pso->sizlBitmap.cx) {

        rcw.l = (WORD)pso->sizlBitmap.cx;
    }

    if (rcw.t > (WORD)pso->sizlBitmap.cy) {

        rcw.t = (WORD)pso->sizlBitmap.cy;
    }

    if (rcw.r > (WORD)pso->sizlBitmap.cx) {

        rcw.r = (WORD)pso->sizlBitmap.cx;
    }

    if (rcw.b > (WORD)pso->sizlBitmap.cy) {

        rcw.b = (WORD)pso->sizlBitmap.cy;
    }

    if ((rcw.r <= rcw.l) || (rcw.b <= rcw.t)) {

        return(wChecksum);
    }

    cPixels = (LONG)(rcw.r - rcw.l);
    cy      = (LONG)(rcw.b - rcw.t);
    lDelta  = pso->lDelta;
    pb      = (LPBYTE)pso->pvScan0 + ((LONG)rcw.t * lDelta);
    XorMask = 0xFF;

    //
    // rcw.r and rcw.b are exclusive
    //

    --rcw.r;
    --rcw.b;

    switch (Format) {

    case BMF_1BPP:

        pb         += (rcw.l >> 3);
        c1stPixels  = (UINT)(8 - (rcw.l & 0x07));
        BegMask     = (BYTE)(0xff >> (rcw.l & 0x07));
        EndMask     = (BYTE)(0xff << (8 - (rcw.r & 0x07)));

        break;

    case BMF_4BPP:

        if (rcw.l & 0x01) {

            BegMask    = 0x07;
            c1stPixels = 4;

        } else {

            BegMask    = 0x77;
            c1stPixels = 0;
        }

        pb       += (rcw.l >> 1);
        cPixels <<= 2;
        EndMask   = (BYTE)((rcw.r & 0x01) ? 0x70 : 0x77);
        XorMask   = 0x77;

        break;

    case BMF_8BPP:
    case BMF_16BPP:
    case BMF_24BPP:

        BegMask      =
        EndMask      = 0xFF;
        c1stPixels   = (UINT)(Format - BMF_8BPP + 1);
        pb          += (rcw.l * c1stPixels);
        cPixels     *= (c1stPixels << 3);
        c1stPixels   = 0;

        break;
    }

    while (cy--) {

        LPBYTE  pbCur;
        LONG    Count;
        WORD    w;


        pbCur  = pb;
        pb    += lDelta;
        Count  = cPixels;
        w      = (WORD)((c1stPixels) ? ((*pbCur++ ^ XorMask) & BegMask) : 0);

        if ((Count -= c1stPixels) >= 8) {

            do {

                w        <<= 8;
                w         |= (*pbCur++ ^ XorMask);
                wChecksum  += w;

            } while ((Count -= 8) >= 8);
        }

        if (Count > 0) {

            w <<= 8;
            w  |= (WORD)((*pbCur ^ XorMask) & EndMask);

        } else {

            w &= EndMask;
        }

        wChecksum += w;
    }

     VERBOSE(("\nComputeChecksum(%ld:%04lx): (%4ld, %4ld)-(%4ld, %4ld)=%3ldx%3ld [%3ld], pb=%08lx [%02lx:%02lx], %1ld\t",
                Format, wChecksum,
                rcw.l, rcw.t, rcw.r + 1, rcw.b + 1,
                rcw.r - rcw.l + 1, rcw.b - rcw.t + 1, cPixels,
                pb, BegMask, EndMask, c1stPixels));

    return(wChecksum);
}


BOOL
BRGBColorSpace(
    PDEV    *pPDev
    )
{

     LISTNODE   *pListNode = NULL;

     if (pPDev->pDriverInfo && pPDev->pColorModeEx)
         pListNode = LISTNODEPTR(pPDev->pDriverInfo,pPDev->pColorModeEx->liColorPlaneOrder);

     while (pListNode)
     {
            switch (pListNode->dwData)
            {

            case COLOR_RED:
            case COLOR_GREEN:
            case COLOR_BLUE:
                return TRUE;

            default:
                break;
            }

           if (pListNode->dwNextItem == END_OF_LIST)
                break;
            else
                pListNode = LOCALLISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
    }

    return FALSE;

}

BOOL
BFoundCachedBrush(
    PDEV    *pPDev,
    PDEVBRUSH pDevBrush
    )
{

    //
    // search the cache only if we want to use the last color. If
    // MODE_BRUSH_RESET_COLOR is set then we want to explicitly reset the brush
    // color by sending the command to the printer.
    //
    if (  (!(pPDev->ctl.dwMode & MODE_BRUSH_RESET_COLOR)) )
    {
        if ( (pDevBrush->dwBrushType == pPDev->GState.CurrentBrush.dwBrushType) &&
             (pDevBrush->iColor == pPDev->GState.CurrentBrush.iColor) )
        {
            return TRUE;
        }

    }
    else
    {
        //
        // Reset the MODE_BRUSH_RESET_COLOR flag as we want to search the cache
        // next time.
        //
        pPDev->ctl.dwMode &= ~MODE_BRUSH_RESET_COLOR;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\udgtt\udgtt.c ===
/*
 *    udgtt - un-dump GTT file
 *
 *    TODO:
 *
 *    HISTORY:
 *
 *    4/28/99 yasuho        Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>

#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <prntfont.h>

FILE *infile, *outfile, *logfile;

UNI_GLYPHSETDATA Header;
UNI_CODEPAGEINFO *pCpCmdInfo;

MAPTABLE *pMapTable;

GLYPHRUN *pRuns;

typedef struct {
    WORD wUc;
    INT iCp;
    BYTE jType;
    BYTE *pCmd;
    INT iCmdLen;
} GINFO;

typedef struct {
    BYTE *pCmdSel;
    INT iCmdSelLen;
    BYTE *pCmdUnsel;
    INT iCmdUnselLen;
} CINFO;

GINFO *pGInfo;
CINFO *pCInfo;

INT bVerbose;

BYTE buf[512];
BYTE Cmd[512];
INT iCmdLen;

char *namestr = "udgtt";
char *usagestr = "udgtt [-v] gttfile [txtfile]";

#include "utils.c"

VOID
LoadHeader()
{
    DWORD dwTemp;
    INT k;

    k = 0;
    while (1) {

        if (NULL == fgets(buf, sizeof(buf), infile)) {
            *buf = '\0';
            return;
        }

        if (';' == *buf)
            break;
       
        switch (k++) {
        case 0:
            sscanf(buf, "%lx", &dwTemp);
            Header.dwVersion = dwTemp;
            break;
        case 1:
            sscanf(buf, "%lx", &dwTemp);
            Header.dwFlags = dwTemp;
            break;
        case 2:
            sscanf(buf, "%ld", &dwTemp);
            Header.lPredefinedID = dwTemp;
            break;
        }
    }

    if (bVerbose) {
        fprintf(logfile, "dwVersion=%lx\n", Header.dwVersion);
        fprintf(logfile, "dwFlags=%lx\n", Header.dwFlags);
        fprintf(logfile, "lPredefinedID=%ld\n", Header.lPredefinedID);
    }
}

int
LoadNumValue(
   BYTE **ppBuf)
{
    BYTE *pTemp;
    INT iRet;

    pTemp = *ppBuf;

    if (isspace(*pTemp)) {
        while (isspace(*pTemp))
            pTemp++;
    }

    if ('X' == *pTemp || 'x' == *pTemp || isdigit(*pTemp)) {

        if ('X' == *pTemp || 'x' == *pTemp) {
            pTemp++;
            sscanf(pTemp, "%x", &iRet);
        }
        else {
            sscanf(pTemp, "%d", &iRet);
        }

        while (isxdigit(*pTemp))
                pTemp++;
    }

    *ppBuf = pTemp;
    return iRet;
}

VOID
LoadCmdString(
    BYTE *pTemp)
{
    INT k;
    INT iTemp;

    k = 0;

    while (*pTemp) {

        if (isspace(*pTemp)) {
            while (isspace(*pTemp))
                pTemp++;
        }

        if (';' == *pTemp) {
            break;
        }
        
        iTemp = LoadNumValue(&pTemp);
        Cmd[k++] = (BYTE)iTemp;
    }

    iCmdLen = k;
}

VOID
LoadCpInfo()
{
    DWORD dwTemp;
    INT j, k, n;

    fgets(buf, sizeof(buf), infile);
    sscanf(buf, "%ld", &dwTemp);
    Header.dwCodePageCount = dwTemp;

    pCInfo = (CINFO *)calloc(1, sizeof (CINFO) * dwTemp);
    pCpCmdInfo = (UNI_CODEPAGEINFO *)calloc(1,
        sizeof (UNI_CODEPAGEINFO) * dwTemp);

    k = 0;
    j = 0;
    while (1) {
        if (NULL == fgets(buf, sizeof(buf), infile)) {
            *buf = '\0';
            return;
        }
        if (';' == *buf)
            break;

        switch ((k++) % 3) {
        case 0:
            sscanf(buf, "%ld", &dwTemp);
            pCpCmdInfo[j].dwCodePage = dwTemp;
            break;
        case 1:
            LoadCmdString(buf);
            pCInfo[j].pCmdSel = calloc(1, iCmdLen);
            memcpy(pCInfo[j].pCmdSel, Cmd, iCmdLen);
            pCInfo[j].iCmdSelLen = iCmdLen;
            break;
        case 2:
            LoadCmdString(buf);
            pCInfo[j].pCmdUnsel = calloc(1, iCmdLen);
            memcpy(pCInfo[j].pCmdUnsel, Cmd, iCmdLen);
            pCInfo[j].iCmdUnselLen = iCmdLen;
            j++;
            break;
        }
    }

    if (bVerbose) {
        fprintf(logfile, "dwCodePageCount=%ld\n", Header.dwCodePageCount);
    }
}

VOID
LoadGlyphInfoInternal(
    GINFO *pGI,
    BYTE *s)
{
    INT iTemp;
    BYTE *pTemp;
    INT k;

    pTemp = s;
    sscanf(pTemp, "%04x", &iTemp);
    pGI->wUc = iTemp;
    pTemp += 4;

    iTemp = LoadNumValue(&pTemp);
    pGI->iCp = iTemp;
    iTemp = LoadNumValue(&pTemp);
    pGI->jType = iTemp;

    LoadCmdString(pTemp);

    pGI->pCmd = calloc(1, iCmdLen);
    memcpy(pGI->pCmd, Cmd, iCmdLen);
    pGI->iCmdLen = iCmdLen;

    if (bVerbose) {
        fprintf(logfile, "%04x %d", pGI->wUc, pGI->iCp);
        fprintf(logfile, "\n");
    }
}


VOID
LoadGlyphInfo()
{
    DWORD dwTemp;
    INT k;

    fgets(buf, sizeof(buf), infile);
    sscanf(buf, "%ld", &dwTemp);
    Header.dwGlyphCount = dwTemp;

    pGInfo = (GINFO *)calloc(1, (sizeof (GINFO) * dwTemp));
    pMapTable = (MAPTABLE *)calloc(1,
        (sizeof (MAPTABLE) + sizeof (TRANSDATA) * (dwTemp - 1)));

    k = 0;
    while (1) {
        if (NULL == fgets(buf, sizeof(buf), infile)) {
            *buf = '\0';
            break;
        }

        if (';' == *buf) {
            *buf = '\0';
            continue;
        }

        if (!isxdigit(*buf))
            break;

        if (k >= (INT)dwTemp) {
            fatal("too many glyph defs\n");
        }

        LoadGlyphInfoInternal(&(pGInfo[k++]), buf);
    }

    Header.dwGlyphCount = (DWORD)k;

    if (bVerbose) {
        fprintf(logfile, "dwGlyphCount=%ld\n", Header.dwGlyphCount);
    }
}

VOID
CountRuns()
{
    INT i, j;
    WORD wUc;

    j = 0;
    wUc = 0x0000;
    for (i = 0; i < (INT)Header.dwGlyphCount; i++) {

        if (wUc > pGInfo[i].wUc) {
            fatal("unicode value duplicated %x", pGInfo[i].wUc);
        }
        else if (wUc < pGInfo[i].wUc) {
            j++;
            wUc = pGInfo[i].wUc;
            if (NULL != pRuns) {
                pRuns[j - 1].wcLow = pGInfo[i].wUc;
            }
        }

        wUc++;
        if (NULL != pRuns) {
            pRuns[j - 1].wGlyphCount++;
        }
    }

    if (NULL == pRuns) {
        Header.dwRunCount = (DWORD)j;
    }
    
    if (bVerbose) {
        fprintf(logfile, "dwRunCount=%d\n", Header.dwRunCount);
    }
}

int __cdecl
CompGInfo(
    const void *p1, const void *p2)
{
    GINFO *pGI1 = (GINFO *)p1;
    GINFO *pGI2 = (GINFO *)p2;

    return ((int)pGI1->wUc - (int)pGI2->wUc);
}

VOID
SortGlyphs()
{
    qsort(pGInfo, Header.dwGlyphCount, sizeof (GINFO), CompGInfo);
    CountRuns(); // just count # of runs
    pRuns = (GLYPHRUN *)calloc(1, (sizeof (GLYPHRUN) * Header.dwRunCount));
    CountRuns(); // load run info
}

VOID
WriteHeader(
    BOOL bSeek)
{
    if (0 != fseek(outfile, 0L, SEEK_SET))
        fatal("fseek error");

    if (1 != fwrite(&Header, sizeof (Header), 1, outfile))
        fatal("fwrite error");
}

LONG
AdjustOffset(
    FILE *fp)
{
    LONG lTemp, lTemp2;
    BYTE ajBuf[3];

    if (0 > (lTemp = ftell(outfile)))
        fatal("ftell");

    if (0 != (lTemp2 = lTemp % 4)) {
        lTemp2 = 4 - lTemp2;
        memset(ajBuf, 0, 3);
        if (1 != fwrite(pRuns, lTemp, 1, outfile))
            fatal("fwrite");
    }

    return (lTemp + lTemp2);
}

VOID
WriteGlyphRuns()
{
    LONG lTemp;

    Header.loRunOffset = AdjustOffset(outfile);

    lTemp = sizeof (GLYPHRUN) * Header.dwRunCount;
    if (1 != fwrite(pRuns, lTemp, 1, outfile))
        fatal("fwrite GLYPHRUN");
}

VOID
WriteCpInfo(
    BOOL bSeek)
{
    INT i;
    LONG lTemp;

    if (bSeek) {
        if (0 != fseek(outfile, Header.loCodePageOffset, SEEK_SET))
            fatal("fseek");
    }
    else {
        Header.loCodePageOffset = AdjustOffset(outfile);
    }

    for (i = 0; i < (INT)Header.dwCodePageCount; i++) {
        if (1 != fwrite(&(pCpCmdInfo[i]), sizeof(UNI_CODEPAGEINFO), 1, outfile))
            fatal("fwrite CODEPAGEINFO");
    }
}

VOID
WriteMapTable(
    BOOL bSeek)
{
    LONG lTemp;

    pMapTable->dwGlyphNum = Header.dwGlyphCount;

    if (bSeek) {
        if (0 != fseek(outfile, Header.loMapTableOffset, SEEK_SET))
            fatal("fseek");
    }
    else {
        Header.loMapTableOffset = AdjustOffset(outfile);
    }

    lTemp = sizeof (MAPTABLE) + sizeof(TRANSDATA) * (Header.dwGlyphCount - 1);

    if (1 != fwrite(pMapTable, lTemp, 1, outfile))
        fatal("fwrite MAPTABLE");
}

VOID
WriteCommands()
{
    INT iTemp;
    LONG lTemp;
    INT i;
    WORD wTemp;

    AdjustOffset(outfile);

    for (i = 0; i < (INT)Header.dwCodePageCount; i++) {

        if (0 < pCInfo[i].iCmdSelLen) {
            if (0 > (lTemp = ftell(outfile)))
                fatal("ftell");
            if (1 != fwrite(pCInfo[i].pCmdSel, pCInfo[i].iCmdSelLen, 1, outfile))
                fatal("fwrite");
            pCpCmdInfo[i].SelectSymbolSet.dwCount = pCInfo[i].iCmdSelLen;
          