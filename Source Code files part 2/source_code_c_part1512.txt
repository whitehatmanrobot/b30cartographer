 // fall through
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEXKILL:
            case D3DSIO_TEX:
            case D3DSIO_TEXBEM:
            case D3DSIO_TEXBEML:
            case D3DSIO_TEXREG2AR:
            case D3DSIO_TEXREG2GB:
            case D3DSIO_TEXM3x2PAD:
            case D3DSIO_TEXM3x2TEX:
            case D3DSIO_TEXM3x3PAD:
            case D3DSIO_TEXM3x3TEX:
            case D3DSIO_TEXM3x3SPEC:
            case D3DSIO_TEXM3x3VSPEC:
            case D3DSIO_TEXM3x2DEPTH:
            case D3DSIO_TEXDP3:
            case D3DSIO_TEXREG2RGB:
            case D3DSIO_TEXDEPTH:
            case D3DSIO_TEXDP3TEX:
            case D3DSIO_TEXM3x3:
                pInst->bTexOp = TRUE;
                break;
            }
            if (pInst->bTexOp)
            {
                // update stage count and assign ptr to TSS for this op
                if (bLegacyTexOp)
                {
                    m_cActiveTextureStages =
                        max(m_cActiveTextureStages,(pInst->DstParam&D3DSP_REGNUM_MASK)+1);
                    pInst->uiTSSNum = (pInst->DstParam&D3DSP_REGNUM_MASK)-1;
                }
                else
                {
                    UINT Stage;
                    BOOL bStageUsed = TRUE;

                    switch(pInst->Opcode & D3DSI_OPCODE_MASK)
                    {
                    case D3DSIO_TEXCOORD:
                    case D3DSIO_TEXDEPTH:
                    case D3DSIO_TEXKILL:
                        if( bMinimizeReferencedTexCoords )
                        {
                            bStageUsed = FALSE;
                            break;
                        }
                        // falling through
                    case D3DSIO_TEX:
                    default:
                        Stage = pInst->DstParam&D3DSP_REGNUM_MASK;
                        break;
                    }

                    if( bStageUsed )
                    {
                        m_cActiveTextureStages = max(m_cActiveTextureStages,Stage+1);
                        pInst->uiTSSNum = Stage;
                    }
                }
            }

            if( pPrevious_NonTrivial_Inst )
            {
                // Queue write of last instruction if the current instruction has the
                // COISSUE flag.
                if( pInst->Opcode & D3DSI_COISSUE )
                {
                    pPrevious_NonTrivial_Inst->bQueueWrite = TRUE;
                }

                // Flush writes after the previous instruction if it had the COISSUE
                // flag and the current instruction doesn't have it.
                if( !(pInst->Opcode & D3DSI_COISSUE) && (pPrevious_NonTrivial_Inst->Opcode & D3DSI_COISSUE) )
                {
                    pPrevious_NonTrivial_Inst->bFlushQueue = TRUE;
                }
            }

            pPrevious_NonTrivial_Inst = pInst;

            if( bMinimizeReferencedTexCoords )
            {
                UpdateReferencedTexCoords(pInst, &m_ReferencedTexCoordMask);
            }

            pInst++;
        }

        if( !bMinimizeReferencedTexCoords )
        {
           m_ReferencedTexCoordMask = (1<<m_cActiveTextureStages) - 1;
        }
    }

    // ------------------------------------------------------------------------
    //
    // Third pass through the shader (through the list of instructions made
    // in the last pass) to translate instructions into a more basic ("RISC") 
    // instruction set for the refrast executor.
    //
    // ------------------------------------------------------------------------
    {
        #define _Set(RegType, RegNum)               Set(RegType,RegNum,pRast)

        #define _NewPSInst(__INST)                                                              \
            {                                                                                   \
                RDPSOffset = pRDPSInst - pRDPSInstBuffer + LastRDPSInstSize;                    \
                m_RDPSInstBuffer.SetGrowSize(MAX(512,RDPSOffset));                              \
                if( FAILED(m_RDPSInstBuffer.Grow(RDPSOffset + sizeof(__INST##_PARAMS))))        \
                {return E_OUTOFMEMORY;}                                                         \
                pRDPSInstBuffer = &m_RDPSInstBuffer[0];                                         \
                pRDPSInst = pRDPSInstBuffer + RDPSOffset;                                       \
                ((__INST##_PARAMS UNALIGNED64*)pRDPSInst)->Inst = __INST;                                   \
                LastRDPSInstSize = sizeof(__INST##_PARAMS);                                     \
            }

        #define _InstParam(__INST)     (*(__INST##_PARAMS UNALIGNED64*)pRDPSInst)

        #define _NoteInstructionEvent  _NewPSInst(RDPSINST_NEXTD3DPSINST); \
                                        _InstParam(RDPSINST_NEXTD3DPSINST).pInst = pInst;

        #define _EnterQuadPixelLoop    if(!bInQuadPixelLoop)                                                       \
                                        {                                                                          \
                                            _NewPSInst(RDPSINST_QUADLOOPBEGIN);                                    \
                                            RDPSLoopOffset = RDPSOffset + sizeof(RDPSINST_QUADLOOPBEGIN_PARAMS);   \
                                            bInQuadPixelLoop = TRUE;                                               \
                                        }

        #define _LeaveQuadPixelLoop     if(bInQuadPixelLoop)                                             \
                                        {                                                               \
                                            _NewPSInst(RDPSINST_QUADLOOPEND);                           \
                                            _InstParam(RDPSINST_QUADLOOPEND).JumpBackByOffset =         \
                                                                            RDPSOffset - RDPSLoopOffset;\
                                            bInQuadPixelLoop = FALSE;                                   \
                                        }

        #define _EmitDstMod(__dstReg,__mask)    _NewPSInst(RDPSINST_DSTMOD);                            \
                                                _InstParam(RDPSINST_DSTMOD).DstReg    = __dstReg;       \
                                                _InstParam(RDPSINST_DSTMOD).WriteMask = __mask;         \
                                                _InstParam(RDPSINST_DSTMOD).fScale    = DstScale;       \
                                                _InstParam(RDPSINST_DSTMOD).fRangeMin = DstRange[0];    \
                                                _InstParam(RDPSINST_DSTMOD).fRangeMax = DstRange[1];    
                    

        // Th macro _EmitProj emits instructions to do the following:
        // - Put reciprocal of source (x,y,z,w) component __COMPONENT (ex. w) into scratch register 0 component (for w example:) 4
        // - Replicate reciprocal to rgb components of scratch register 0 (w example yields: 1/,1/w,1/w, <--1/w)
        // - Multiply source register register by scratch register (x/w,y/w,z/w,1) and put the result into the dest register.
        #define _EmitProj(__DESTTYPE,__DESTNUM,__SRCTYPE,__SRCNUM,__COMPONENT)                                                      \
                    _NewPSInst(RDPSINST_RCP);                                                                                       \
                    _InstParam(RDPSINST_RCP).DstReg._Set(RDPSREG_SCRATCH,0);                                                        \
                    _InstParam(RDPSINST_RCP).SrcReg0._Set(__SRCTYPE,__SRCNUM);                                                      \
                    _InstParam(RDPSINST_RCP).bSrcReg0_Negate = FALSE;                                                               \
                    _InstParam(RDPSINST_RCP).WriteMask  = __COMPONENT;                                                              \
                                                                                                                                    \
                    _NewPSInst(RDPSINST_SWIZZLE);                                                                                   \
                    _InstParam(RDPSINST_SWIZZLE).DstReg._Set(RDPSREG_SCRATCH,0);                                                    \
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0._Set(RDPSREG_SCRATCH,0);                                                   \
                    _InstParam(RDPSINST_SWIZZLE).WriteMask  = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1                           \
                                                            | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;                          \
                    _InstParam(RDPSINST_SWIZZLE).Swizzle    =                                                                       \
                                      (RDPS_COMPONENTMASK_0 == __COMPONENT) ? RDPS_REPLICATERED :                                   \
                                      (RDPS_COMPONENTMASK_1 == __COMPONENT) ? RDPS_REPLICATEGREEN :                                 \
                                      (RDPS_COMPONENTMASK_2 == __COMPONENT) ? RDPS_REPLICATEBLUE : RDPS_REPLICATEALPHA;             \
                                                                                                                                    \
                    _NewPSInst(RDPSINST_MUL);                                                                                       \
                    _InstParam(RDPSINST_MUL).DstReg._Set(__DESTTYPE,__DESTNUM);                                                     \
                    _InstParam(RDPSINST_MUL).SrcReg0._Set(RDPSREG_SCRATCH,0);                                                       \
                    _InstParam(RDPSINST_MUL).SrcReg1._Set(__SRCTYPE,__SRCNUM);                                                      \
                    _InstParam(RDPSINST_MUL).bSrcReg0_Negate = FALSE;                                                               \
                    _InstParam(RDPSINST_MUL).bSrcReg1_Negate = FALSE;                                                               \
                    _InstParam(RDPSINST_MUL).WriteMask  =                                                                           \
                                      (RDPS_COMPONENTMASK_0 == __COMPONENT) ? RDPS_COMPONENTMASK_0 :                                \
                                      (RDPS_COMPONENTMASK_1 == __COMPONENT) ? RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 :         \
                                      (RDPS_COMPONENTMASK_2 == __COMPONENT) ? RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 |         \
                                                                              RDPS_COMPONENTMASK_2 : RDPS_COMPONENTMASK_ALL;

        BYTE    ComponentSwizzle[4] = {RDPS_REPLICATERED, RDPS_REPLICATEGREEN, RDPS_REPLICATEBLUE, RDPS_REPLICATEALPHA};
        BYTE    ComponentMask[4]    = {RDPS_COMPONENTMASK_0, RDPS_COMPONENTMASK_1, RDPS_COMPONENTMASK_2, RDPS_COMPONENTMASK_3};
        int     QueueIndex          = -1; // current queue location (for staging results when simulating coissue)
        UINT    i;
        BOOL    bInQuadPixelLoop = FALSE;

        RefRast* pRast = &m_pRD->m_Rast;

        RDPSRegister ZeroReg; ZeroReg._Set(RDPSREG_ZERO,0);
        RDPSRegister OneReg;  OneReg._Set(RDPSREG_ONE,0);
        RDPSRegister TwoReg;  TwoReg._Set(RDPSREG_TWO,0);

        // destination parameter controls
        RDPSRegister    DstReg;
        FLOAT           DstScale;           // Result Shift Scale - +/- 2**n only
        FLOAT           DstRange[2];        // clamp dest to this range
        BYTE            DstWriteMask;       // per-component write mask
        PRGBAVEC        pDstReg;            // address of dest register

        // source parameter controls
        RDPSRegister SrcReg[3];

        BYTE*   pRDPSInstBuffer     = NULL;
        BYTE*   pRDPSInst           = pRDPSInstBuffer;
        size_t  RDPSOffset, RDPSLoopOffset;
        size_t  LastRDPSInstSize    = 0;

        DWORD   Version = *m_pCode;
    
        for (UINT CurrentPSInst=0; CurrentPSInst < m_cInst; CurrentPSInst++)
        {
            PixelShaderInstruction* pInst = m_pInst + CurrentPSInst;
            DWORD   Opcode = pInst->Opcode & D3DSI_OPCODE_MASK;
            DWORD   SrcSwizzle[3];     
            BYTE    SourceReadMasks[3];
            BYTE    SourceReadMasksAfterSwizzle[3];
            BOOL    bForceNeg1To1Clamp[3]  = {FALSE, FALSE, FALSE};
            BOOL    bEmitQueueWrite        = FALSE;
            RDPSRegister QueuedWriteDstReg;
            BYTE    QueuedWriteDstWriteMask;
            BYTE    ProjComponent[3]       = {0,0,0};
            BOOL    bEmitProj[3]           = {FALSE, FALSE, FALSE};
            BOOL    bProjOnEval[3]         = {FALSE, FALSE, FALSE};
            BOOL    bEmitSrcMod[3]         = {FALSE, FALSE, FALSE};
            BOOL    bEmitSwizzle[3]        = {FALSE, FALSE, FALSE};
            BOOL    bSrcNegate[3]          = {FALSE, FALSE, FALSE};
            BOOL    bSrcBias[3]            = {FALSE, FALSE, FALSE};
            BOOL    bSrcTimes2[3]          = {FALSE, FALSE, FALSE};
            BOOL    bSrcComplement[3]      = {FALSE, FALSE, FALSE};
        
            switch( Opcode )
            {
                continue;
            case D3DSIO_DEF:
                // nothing to do -> DEF has already been processed out and is not an true instruction
                continue;
            case D3DSIO_COMMENT:
                continue;
            case D3DSIO_PHASE:
            case D3DSIO_NOP:
    #if DBG
                _NoteInstructionEvent
    #endif
                continue;
            }

    #if DBG
                _NoteInstructionEvent
    #endif

            // do some preliminary setup for this instruction

            UINT RegNum = pInst->DstParam & D3DSP_REGNUM_MASK;
            switch (pInst->DstParam & D3DSP_REGTYPE_MASK)
            {
            case D3DSPR_TEXTURE:
                DstReg._Set(RDPSREG_TEXTURE, RegNum); break;
            case D3DSPR_TEMP:
                DstReg._Set(RDPSREG_TEMP, RegNum); break;
            default:
                _ASSERT( FALSE, "RDPShader::Initialize - Unexpected destination register type." );
                break;
            }

            DstWriteMask = (pInst->DstParam & D3DSP_WRITEMASK_ALL) >> RDPS_COMPONENTMASK_SHIFT;

            if( pInst->bQueueWrite )
            {
                QueueIndex++;

                QueuedWriteDstReg = DstReg;
                QueuedWriteDstWriteMask = DstWriteMask;
                DstReg._Set(RDPSREG_QUEUEDWRITE,QueueIndex);
                _ASSERT(QueueIndex <= RDPS_MAX_NUMQUEUEDWRITEREG, "Too many queued writes in pixelshader (improperly handled co-issue)." );
                bEmitQueueWrite = TRUE;
            }

            CalculateSourceReadMasks(pInst, SourceReadMasks, FALSE,Version);
            CalculateSourceReadMasks(pInst, SourceReadMasksAfterSwizzle, TRUE,Version);
            for (i=0; i < pInst->SrcParamCount; i++)
            {
                RegNum = pInst->SrcParam[i]&D3DSP_REGNUM_MASK;
                switch (pInst->SrcParam[i] & D3DSP_REGTYPE_MASK)
                {
                case D3DSPR_TEMP:
                    SrcReg[i]._Set(RDPSREG_TEMP, RegNum); break;
                case D3DSPR_TEXTURE:
                    SrcReg[i]._Set(RDPSREG_TEXTURE, RegNum); break;
                case D3DSPR_INPUT:
                    SrcReg[i]._Set(RDPSREG_INPUT, RegNum); break;
                case D3DSPR_CONST:
                    SrcReg[i]._Set(RDPSREG_CONST, RegNum);
                    // Force a [-1,1] clamp after applying modifier (for constants only)
                    // This overrides the the standard [-MaxPixelShaderValue,MaxPixelShaderValue] clamp.
                    // An IHV that supports MaxPixelShaderValue > 1 forgot to do this for constants.
                    bForceNeg1To1Clamp[i] = TRUE;
                    break;
                default:
                    _ASSERT( FALSE, "RDPShader::Initialize - Unexpected source register type." );
                    break;
                }

                if( (D3DSPSM_DZ == (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK)) || 
                    (D3DSPSM_DW == (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK)) )
                {
                    if( D3DSPSM_DZ == (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK))
                    {
                        ProjComponent[i] = RDPS_COMPONENTMASK_2;
                    }
                    else // _DW
                    {
                        if( D3DPS_VERSION(1,4) == Version )
                            ProjComponent[i] = RDPS_COMPONENTMASK_2;
                        else
                            ProjComponent[i] = RDPS_COMPONENTMASK_3;
                    }

                    
                    if( D3DSPR_TEXTURE == (pInst->SrcParam[i] & D3DSP_REGTYPE_MASK ) ) // t# register being used to represent evaluated texcoord.
                    {
                        bProjOnEval[i] = TRUE;
                    }                               
                    else
                        bEmitProj[i] = TRUE;
                }
                else
                {
                    bEmitSrcMod[i] = TRUE;

                    switch (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK)
                    {
                    default:
                    case D3DSPSM_NONE:      
                        if( !bForceNeg1To1Clamp[i] ) 
                            bEmitSrcMod[i] = FALSE; 
                        break;
                    case D3DSPSM_NEG:       
                        bSrcNegate[i]   = TRUE; // negate is not part of source modifier
                        if( !bForceNeg1To1Clamp[i] ) 
                            bEmitSrcMod[i] = FALSE; 
                        break;
                    case D3DSPSM_BIAS:
                        bSrcBias[i]         = TRUE;
                        break;
                    case D3DSPSM_BIASNEG:
                        bSrcNegate[i]       = TRUE; 
                        bSrcBias[i]         = TRUE;
                        break;
                    case D3DSPSM_SIGN:              // _bx2
                        bSrcBias[i]         = TRUE;
                        bSrcTimes2[i]       = TRUE;
                        break;
                    case D3DSPSM_SIGNNEG:           // negative _bx2
                        bSrcNegate[i]       = TRUE; // negate is not part of source modifier
                        bSrcBias[i]         = TRUE;
                        bSrcTimes2[i]       = TRUE;
                        break;                        
                    case D3DSPSM_COMP:    
                        bSrcComplement[i]   = TRUE;
                        break;
                    case D3DSPSM_X2:
                        bSrcTimes2[i]       = TRUE;
                        break;
                    case D3DSPSM_X2NEG:     
                        bSrcNegate[i]       = TRUE; // negate is not part of source modifier
                        bSrcTimes2[i]       = TRUE;
                        break;
                    }

                    _ASSERT(!(bSrcComplement[i] && (bSrcTimes2[i]||bSrcBias[i]||bSrcNegate[i])),"RDPShader::Initialize - Complement cannot be combined with other modifiers.");
                }

                SrcSwizzle[i] = (pInst->SrcParam[i] & D3DSP_SWIZZLE_MASK) >> D3DSP_SWIZZLE_SHIFT;
                bEmitSwizzle[i] = (D3DSP_NOSWIZZLE != (pInst->SrcParam[i] & D3DSP_SWIZZLE_MASK));
            }

            // set clamp values
            switch (pInst->DstParam & D3DSP_DSTMOD_MASK)
            {
            default:
            case D3DSPDM_NONE:
                if(pInst->bTexOp)
                {
                    DstRange[0] = -FLT_MAX;
                    DstRange[1] =  FLT_MAX;
                }
                else
                {
                    DstRange[0] = fMin;
                    DstRange[1] = fMax;
                }
                break;
            case D3DSPDM_SATURATE:
                DstRange[0] = 0.F;
                DstRange[1] = 1.F;
                break;
            }

            UINT ShiftScale =
                (pInst->DstParam & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT;
            if (ShiftScale & 0x8)
            {
                ShiftScale = ((~ShiftScale)&0x7)+1; // negative magnitude
                DstScale = 1.f/(FLOAT)(1<<ShiftScale);
            }
            else
            {
                DstScale = (FLOAT)(1<<ShiftScale);
            }

            // finished preliminary setup, now start emitting ops...

            _EnterQuadPixelLoop

            if( bEmitQueueWrite )
            {
                _NewPSInst(RDPSINST_QUEUEWRITE); 
                _InstParam(RDPSINST_QUEUEWRITE).DstReg          = QueuedWriteDstReg;
                _InstParam(RDPSINST_QUEUEWRITE).WriteMask       = QueuedWriteDstWriteMask;
            }

            for (i=0; i < pInst->SrcParamCount; i++)
            {
                if( bEmitProj[i] )
                {
                    _EmitProj(RDPSREG_POSTMODSRC,i,SrcReg[i].GetRegType(),SrcReg[i].GetRegNum(),ProjComponent[i]);
                    SrcReg[i]._Set(RDPSREG_POSTMODSRC,i);
                }

                if( bEmitSrcMod[i] )
                {
                    _NewPSInst(RDPSINST_SRCMOD);
                    _InstParam(RDPSINST_SRCMOD).DstReg._Set(RDPSREG_POSTMODSRC,i);
                    _InstParam(RDPSINST_SRCMOD).SrcReg0            = SrcReg[i];
                    _InstParam(RDPSINST_SRCMOD).WriteMask          = SourceReadMasks[i];
                    _InstParam(RDPSINST_SRCMOD).bBias              = bSrcBias[i];
                    _InstParam(RDPSINST_SRCMOD).bTimes2            = bSrcTimes2[i];
                    _InstParam(RDPSINST_SRCMOD).bComplement        = bSrcComplement[i];
                    _InstParam(RDPSINST_SRCMOD).fRangeMin          = bForceNeg1To1Clamp[i] ? -1.0f : fMin;
                    _InstParam(RDPSINST_SRCMOD).fRangeMax          = bForceNeg1To1Clamp[i] ? 1.0f : fMax;
                    SrcReg[i]._Set(RDPSREG_POSTMODSRC,i);
                }

                if( bEmitSwizzle[i] && !bProjOnEval[i] )
                {
                    _NewPSInst(RDPSINST_SWIZZLE);
                    _InstParam(RDPSINST_SWIZZLE).DstReg._Set(RDPSREG_POSTMODSRC,i);
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0   = SrcReg[i];
                    _InstParam(RDPSINST_SWIZZLE).WriteMask = SourceReadMasksAfterSwizzle[i];
                    _InstParam(RDPSINST_SWIZZLE).Swizzle   = SrcSwizzle[i];
                    SrcReg[i]._Set(RDPSREG_POSTMODSRC,i);
                }
            }

            switch(Opcode)
            {
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEXKILL:
                {
                    if( !(  (D3DSIO_TEXKILL == Opcode)  && 
                            (D3DSPR_TEMP    == (pInst->DstParam & D3DSP_REGTYPE_MASK))
                         )
                      )
                    {
                        UINT CoordSet = pInst->SrcParam[0] ? (pInst->SrcParam[0] & D3DSP_REGNUM_MASK) : 
                                                             (pInst->DstParam & D3DSP_REGNUM_MASK);

                        RDPSRegister CoordReg;
                        if(bProjOnEval[0])
                            CoordReg._Set(RDPSREG_POSTMODSRC,0);
                        else
                            CoordReg = DstReg;

                        // For TEXCOORD, clamp 0. to 1 only there is no source parameter (ps.1.0, ps.1.1)
                        // For TEXKILL, never clamp
                        // NOTE: the TEXCOORD clamp is a temporary limitation for DX8 shader models
                        BOOL bTexCoordClamp = ((D3DSIO_TEXCOORD == Opcode) && (!pInst->SrcParam[0])) ? TRUE : FALSE;

                        _NewPSInst(RDPSINST_EVAL);
                        _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                        _InstParam(RDPSINST_EVAL).uiCoordSet                = CoordSet;
                        _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // projection disabled (unless _p modifier used -> _EmitProj below)
                        _InstParam(RDPSINST_EVAL).bClamp                    = bTexCoordClamp;

                        if( bProjOnEval[0] )
                        {
                            if( bEmitSwizzle[0] )
                            {
                                _NewPSInst(RDPSINST_SWIZZLE);
                                _InstParam(RDPSINST_SWIZZLE).DstReg    = DstReg;
                                _InstParam(RDPSINST_SWIZZLE).SrcReg0   = CoordReg;
                                _InstParam(RDPSINST_SWIZZLE).WriteMask = SourceReadMasksAfterSwizzle[0];
                                _InstParam(RDPSINST_SWIZZLE).Swizzle   = SrcSwizzle[0];
                            }
                            _EmitProj(DstReg.GetRegType(),DstReg.GetRegNum(),DstReg.GetRegType(),DstReg.GetRegNum(),ProjComponent[0]);
                        }

                        // check version (first DWORD of code token stream), and always
                        //  set 4th component to 1.0 for ps.1.3 or earlier
                        if ( D3DPS_VERSION(1,3) >= Version )
                        {
                            _NewPSInst(RDPSINST_MOV);
                            _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                            _InstParam(RDPSINST_MOV).SrcReg0            = OneReg; // 1.0f
                            _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE; 
                            _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_3;
                        }
                    }

                    _EmitDstMod(DstReg,DstWriteMask)

                    if( D3DSIO_TEXKILL == Opcode )
                    {
                        _NewPSInst(RDPSINST_KILL);
                        _InstParam(RDPSINST_KILL).DstReg    = DstReg;
                    }
                }
                break;
            case D3DSIO_TEX:
                {
                    RDPSRegister CoordReg;
                    BOOL bDoSampleCoords = TRUE;

                    UINT CoordSet = pInst->SrcParam[0] ? (pInst->SrcParam[0] & D3DSP_REGNUM_MASK) : 
                                                         (pInst->DstParam & D3DSP_REGNUM_MASK);

                    if( pInst->SrcParam[0] )
                    {
                        CoordReg = SrcReg[0];
                        if( D3DSPR_TEMP  == (pInst->SrcParam[0] & D3DSP_REGTYPE_MASK) )
                            bDoSampleCoords = FALSE;
                    }
                    else // no source param.
                    {
                        CoordReg._Set(RDPSREG_SCRATCH,0);
                    }

                    if( bDoSampleCoords )
                    {
                        _NewPSInst(RDPSINST_EVAL);
                        _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                        _InstParam(RDPSINST_EVAL).uiCoordSet                = CoordSet;
                        _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = bProjOnEval[0]; // if we have _p modifier, we do _EmitProj below
                        _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
                    }

                    if( bProjOnEval[0] )
                    {
                        if( bEmitSwizzle[0] )
                        {
                            _NewPSInst(RDPSINST_SWIZZLE);
                            _InstParam(RDPSINST_SWIZZLE).DstReg._Set(RDPSREG_POSTMODSRC,0);
                            _InstParam(RDPSINST_SWIZZLE).SrcReg0   = CoordReg;
                            _InstParam(RDPSINST_SWIZZLE).WriteMask = SourceReadMasksAfterSwizzle[0];
                            _InstParam(RDPSINST_SWIZZLE).Swizzle   = SrcSwizzle[0];
                            CoordReg._Set(RDPSREG_POSTMODSRC,0);
                        }
                        _EmitProj(RDPSREG_POSTMODSRC,0,CoordReg.GetRegType(),CoordReg.GetRegNum(),ProjComponent[0]);
                        CoordReg._Set(RDPSREG_POSTMODSRC,0);
                    }

                    _LeaveQuadPixelLoop

                    PRGBAVEC    pCoordReg = CoordReg.GetRegPtr();

                    _NewPSInst(RDPSINST_TEXCOVERAGE);
                    _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                    // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pCoordReg[1][0]; // du/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pCoordReg[2][0]; // du/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pCoordReg[1][1]; // dv/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pCoordReg[2][1]; // dv/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pCoordReg[1][2]; // dw/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pCoordReg[0][2];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pCoordReg[2][2]; // dw/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pCoordReg[0][2];

                    _EnterQuadPixelLoop

                    _NewPSInst(RDPSINST_SAMPLE);
                    _InstParam(RDPSINST_SAMPLE).DstReg     = DstReg;
                    _InstParam(RDPSINST_SAMPLE).CoordReg   = CoordReg;
                    _InstParam(RDPSINST_SAMPLE).uiStage    = pInst->DstParam & D3DSP_REGNUM_MASK;

                    _EmitDstMod(DstReg,DstWriteMask)
                }
                break;
            case D3DSIO_TEXDP3:
            case D3DSIO_TEXDP3TEX:
                {
                    RDPSRegister CoordReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;

                    if( D3DSIO_TEXDP3 == Opcode )
                    {
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg          = DstReg;
                        _InstParam(RDPSINST_DP3).SrcReg0         = SrcReg[0];
                        _InstParam(RDPSINST_DP3).SrcReg1         = CoordReg;
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask       = RDPS_COMPONENTMASK_ALL;
                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                    else // D3DSIO_TEXDP3TEX
                    {
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg          = CoordReg;
                        _InstParam(RDPSINST_DP3).SrcReg0         = SrcReg[0];
                        _InstParam(RDPSINST_DP3).SrcReg1         = CoordReg;
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask       = RDPS_COMPONENTMASK_0;

                        _NewPSInst(RDPSINST_MOV);
                        _InstParam(RDPSINST_MOV).DstReg          = CoordReg;
                        _InstParam(RDPSINST_MOV).SrcReg0         = ZeroReg; // 0.0f
                        _InstParam(RDPSINST_MOV).bSrcReg0_Negate = FALSE;
                        _InstParam(RDPSINST_MOV).WriteMask       = RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;

                        _LeaveQuadPixelLoop

                        PRGBAVEC pCoordReg = CoordReg.GetRegPtr();

                        _NewPSInst(RDPSINST_TEXCOVERAGE);
                        _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                        _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                        // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pCoordReg[1][0];         // du/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pCoordReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pCoordReg[2][0];         // du/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pCoordReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 =                           // dv/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 =                           // dv/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =                           // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =                           // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0];  // 0.0f

                        _EnterQuadPixelLoop

                        _NewPSInst(RDPSINST_SAMPLE);
                        _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                        _InstParam(RDPSINST_SAMPLE).CoordReg    = CoordReg;
                        _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                        _EmitDstMod(DstReg,DstWriteMask)           
                    }
                }
                break;
            case D3DSIO_TEXREG2AR:
            case D3DSIO_TEXREG2GB:
            case D3DSIO_TEXREG2RGB:
                {
                    UINT I0, I1;
                    PRGBAVEC pSrcReg0 = SrcReg[0].GetRegPtr();

                    switch( Opcode )
                    {
                    case D3DSIO_TEXREG2AR:
                        I0 = 3;
                        I1 = 0;
                        break;
                    case D3DSIO_TEXREG2GB:
                        I0 = 1;
                        I1 = 2;
                        break;
                    case D3DSIO_TEXREG2RGB:
                        I0 = 0;
                        I1 = 1;
                        break;
                    }

                    _LeaveQuadPixelLoop

                    _NewPSInst(RDPSINST_TEXCOVERAGE);
                    _InstParam(RDPSINST_TEXCOVERAGE).uiStage    = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                    // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pSrcReg0[1][I0]; // du/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pSrcReg0[0][I0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pSrcReg0[2][I0]; // du/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pSrcReg0[0][I0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pSrcReg0[1][I1]; // dv/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pSrcReg0[0][I1]; 
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pSrcReg0[2][I1]; // dv/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pSrcReg0[0][I1];
                    switch( Opcode )
                    {
                    case D3DSIO_TEXREG2AR:
                    case D3DSIO_TEXREG2GB:
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =  // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =  // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0]; // 0.0f
                        break;
                    case D3DSIO_TEXREG2RGB:
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pSrcReg0[1][2]; // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pSrcReg0[0][2];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pSrcReg0[2][2]; // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pSrcReg0[0][2]; 
                        break;
                    }

                    _EnterQuadPixelLoop

                    RDPSRegister CoordReg;  
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    _NewPSInst(RDPSINST_SWIZZLE);
                    _InstParam(RDPSINST_SWIZZLE).DstReg         = CoordReg;
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0        = SrcReg[0];
                    _InstParam(RDPSINST_SWIZZLE).WriteMask      = RDPS_COMPONENTMASK_0;
                    _InstParam(RDPSINST_SWIZZLE).Swizzle        = ComponentSwizzle[I0];

                    _NewPSInst(RDPSINST_SWIZZLE);
                    _InstParam(RDPSINST_SWIZZLE).DstReg         = CoordReg;
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0        = SrcReg[0];
                    _InstParam(RDPSINST_SWIZZLE).WriteMask      = RDPS_COMPONENTMASK_1;
                    _InstParam(RDPSINST_SWIZZLE).Swizzle        = ComponentSwizzle[I1];

                    _NewPSInst(RDPSINST_MOV);
                    _InstParam(RDPSINST_MOV).DstReg             = CoordReg;
                    _InstParam(RDPSINST_MOV).SrcReg0            = (D3DSIO_TEXREG2RGB == Opcode ? SrcReg[0] : ZeroReg );
                    _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_2;

                    _NewPSInst(RDPSINST_SAMPLE);
                    _InstParam(RDPSINST_SAMPLE).DstReg          = DstReg;
                    _InstParam(RDPSINST_SAMPLE).CoordReg        = CoordReg;
                    _InstParam(RDPSINST_SAMPLE).uiStage         = pInst->DstParam & D3DSP_REGNUM_MASK;

                    _EmitDstMod(DstReg,DstWriteMask)
                }
                break;
            case D3DSIO_TEXBEM:
            case D3DSIO_TEXBEML:
            case D3DSIO_TEXBEM_LEGACY:      // refrast only -> used with legacy fixed function rasterizer
            case D3DSIO_TEXBEML_LEGACY:     // refrast only -> used with legacy fixed function rasterizer
                {                
                    BOOL bDoLuminance = ((D3DSIO_TEXBEML == Opcode) || (D3DSIO_TEXBEML_LEGACY == Opcode));
                    RDPSRegister CoordReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = FALSE;
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;

                    _NewPSInst(RDPSINST_BEM);
                    _InstParam(RDPSINST_BEM).DstReg             = CoordReg;
                    _InstParam(RDPSINST_BEM).SrcReg0            = CoordReg;
                    _InstParam(RDPSINST_BEM).SrcReg1            = SrcReg[0];
                    _InstParam(RDPSINST_BEM).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_BEM).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_BEM).WriteMask          = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1;
                    _InstParam(RDPSINST_BEM).uiStage            = pInst->uiTSSNum;

                    _EmitDstMod(CoordReg,RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1)

                    _LeaveQuadPixelLoop

                    PRGBAVEC pCoordReg = CoordReg.GetRegPtr();

                    _NewPSInst(RDPSINST_TEXCOVERAGE);
                    _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                    // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pCoordReg[1][0]; // du/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pCoordReg[2][0]; // du/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pCoordReg[1][1]; // dv/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pCoordReg[2][1]; // dv/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =                   // dw/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =                   // dw/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0]; // 0.0f

                    _EnterQuadPixelLoop

                    _NewPSInst(RDPSINST_SAMPLE);
                    _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                    _InstParam(RDPSINST_SAMPLE).CoordReg    = CoordReg;
                    _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                    if( bDoLuminance )
                    {
                        _NewPSInst(RDPSINST_LUMINANCE);
                        _InstParam(RDPSINST_LUMINANCE).DstReg             = DstReg;
                        _InstParam(RDPSINST_LUMINANCE).SrcReg0            = DstReg;
                        _InstParam(RDPSINST_LUMINANCE).SrcReg1            = SrcReg[0];
                        _InstParam(RDPSINST_LUMINANCE).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_LUMINANCE).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_LUMINANCE).uiStage            = pInst->uiTSSNum;
                    }

                    _EmitDstMod(DstReg,DstWriteMask)
                }
                break;
            case D3DSIO_TEXDEPTH:
                _NewPSInst(RDPSINST_DEPTH);
                _InstParam(RDPSINST_DEPTH).DstReg   = DstReg;
                break;
            case D3DSIO_TEXM3x2PAD:
                {
                    RDPSRegister CoordReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    // do dot product for first row of matrix multiply

                    // evaluate texture coordinate; projection disabled
                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
               
                    // do row of transform - tex coord * vector loaded from texture (on previous stage)
                    _NewPSInst(RDPSINST_DP3);
                    _InstParam(RDPSINST_DP3).DstReg._Set(DstReg.GetRegType(),DstReg.GetRegNum()+1);
                    _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                    _InstParam(RDPSINST_DP3).SrcReg1            = CoordReg;
                    _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).WriteMask          = RDPS_COMPONENTMASK_0;
                }
                break;
            case D3DSIO_TEXM3x3PAD:
                {
                    BOOL bSecondPad = (D3DSIO_TEXM3x3PAD != ((pInst + 1)->Opcode & D3DSI_OPCODE_MASK));
                    BOOL bInVSPECSequence = (D3DSIO_TEXM3x3VSPEC == (((pInst + (bSecondPad?1:2))->Opcode) & D3DSI_OPCODE_MASK));
                    RDPSRegister CoordReg, EyeReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);
                    EyeReg._Set(RDPSREG_SCRATCH,1);

                    // do dot product for first row of matrix multiply

                    // evaluate texture coordinate; projection disabled
                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
               
                    // do row of transform - tex coord * vector loaded from texture (on previous stage)
                    _NewPSInst(RDPSINST_DP3);
                    _InstParam(RDPSINST_DP3).DstReg._Set(DstReg.GetRegType(),DstReg.GetRegNum()+(bSecondPad?1:2));
                    _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                    _InstParam(RDPSINST_DP3).SrcReg1            = CoordReg;
                    _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).WriteMask          = bSecondPad?RDPS_COMPONENTMASK_1:RDPS_COMPONENTMASK_0;

                    if(bInVSPECSequence)
                    {
                        // eye vector encoded in 4th element of texture coordinates
                        _NewPSInst(RDPSINST_SWIZZLE);
                        _InstParam(RDPSINST_SWIZZLE).DstReg     = EyeReg;
                        _InstParam(RDPSINST_SWIZZLE).SrcReg0    = CoordReg;
                        _InstParam(RDPSINST_SWIZZLE).WriteMask  = bSecondPad?RDPS_COMPONENTMASK_1:RDPS_COMPONENTMASK_0;
                        _InstParam(RDPSINST_SWIZZLE).Swizzle    = RDPS_REPLICATEALPHA;
                    }
                }
                break;
            case D3DSIO_TEXM3x2TEX:
            case D3DSIO_TEXM3x3:
            case D3DSIO_TEXM3x3TEX:
            case D3DSIO_TEXM3x3SPEC:
            case D3DSIO_TEXM3x3VSPEC:
            case D3DSIO_TEXM3x2DEPTH:
                {
                    BOOL bIs3D = (D3DSIO_TEXM3x2TEX != Opcode) && (D3DSIO_TEXM3x2DEPTH != Opcode);
                    RDPSRegister CoordReg, EyeReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);
                    EyeReg._Set(RDPSREG_SCRATCH,1);

                    // do dot product for last row of matrix multiply

                    // evaluate texture coordinate; projection disabled
                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
               
                    // do row of transform - tex coord * vector loaded from texture (on previous stage)
                    _NewPSInst(RDPSINST_DP3);
                    _InstParam(RDPSINST_DP3).DstReg             = DstReg;
                    _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                    _InstParam(RDPSINST_DP3).SrcReg1            = CoordReg;
                    _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).WriteMask          = bIs3D ? RDPS_COMPONENTMASK_2 : RDPS_COMPONENTMASK_1;

                    if(D3DSIO_TEXM3x3VSPEC == Opcode)
                    {
                        // eye vector encoded in 4th element of texture coordinates
                        _NewPSInst(RDPSINST_SWIZZLE);
                        _InstParam(RDPSINST_SWIZZLE).DstReg     = EyeReg;
                        _InstParam(RDPSINST_SWIZZLE).SrcReg0    = CoordReg;
                        _InstParam(RDPSINST_SWIZZLE).WriteMask  = RDPS_COMPONENTMASK_2;
                        _InstParam(RDPSINST_SWIZZLE).Swizzle    = RDPS_REPLICATEALPHA;
                    }

                    // Now do stuff that depends on which TEXM3x* instruction this is...

                    if( D3DSIO_TEXM3x3 == Opcode )
                    {
                        _NewPSInst(RDPSINST_MOV);
                        _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                        _InstParam(RDPSINST_MOV).SrcReg0            = OneReg; // 1.0f
                        _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_3;
                
                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                    else if ( (D3DSIO_TEXM3x2TEX == Opcode) ||
                              (D3DSIO_TEXM3x3TEX == Opcode) )
                    {
                        // do straight lookup with transformed tex coords - this
                        // vector is not normalized, but normalization is not necessary
                        // for a cubemap lookup

                        // compute gradients for diffuse lookup
                        _LeaveQuadPixelLoop

                        PRGBAVEC pDstReg = DstReg.GetRegPtr();

                        _NewPSInst(RDPSINST_TEXCOVERAGE);
                        _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                        _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                        // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pDstReg[1][0]; // du/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pDstReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pDstReg[2][0]; // du/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pDstReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pDstReg[1][1]; // dv/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pDstReg[0][1];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pDstReg[2][1]; // dv/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pDstReg[0][1];
                        if( bIs3D )
                        {
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pDstReg[1][2]; // dw/dx
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pDstReg[0][2];
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pDstReg[2][2]; // dw/dy
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pDstReg[0][2];
                        }
                        else
                        {
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =       // dw/dx
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =       // dw/dy
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0]; // 0.0f
                        }

                        _EnterQuadPixelLoop

                        // do lookup
                        if( !bIs3D )
                        {
                            _NewPSInst(RDPSINST_MOV);
                            _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                            _InstParam(RDPSINST_MOV).SrcReg0            = ZeroReg; // 0.0f
                            _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE;
                            _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_2;  
                        }

                        _NewPSInst(RDPSINST_SAMPLE);
                        _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                        _InstParam(RDPSINST_SAMPLE).CoordReg    = DstReg;
                        _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                    else if ( Opcode == D3DSIO_TEXM3x2DEPTH )
                    {
                        // Take resulting u,v values and compute u/v, which
                        // can be interpreted is z/w = perspective correct depth.
                        // Then perturb the z coord for the pixel.
                        _NewPSInst(RDPSINST_DEPTH);
                        _InstParam(RDPSINST_DEPTH).DstReg   = DstReg;
                    }
                    else if ( (Opcode == D3DSIO_TEXM3x3SPEC) ||
                              (Opcode == D3DSIO_TEXM3x3VSPEC) )
                    {
                        RDPSRegister NdotE, NdotN, RCPNdotN, Scale, ReflReg;
                        NdotE._Set(RDPSREG_SCRATCH,2);
                        NdotN._Set(RDPSREG_SCRATCH,3);
                        RCPNdotN    = NdotN;    // reuse same register
                        Scale       = NdotE;    // reuse same register
                        ReflReg  = CoordReg; // reuse same register

                        // compute reflection vector and do lookup - the normal needs
                        // to be normalized here, which is included in this expression
                        if (D3DSIO_TEXM3x3SPEC == Opcode)
                        {
                            // eye vector is constant register
                            EyeReg = SrcReg[1];
                        } // else (TEXM3x3VSPEC) -> eye is what was copied out of the 4th component of 3 texcoords


                        // Compute reflection vector: 2(NdotE/NdotN) * N - E ...

                        // Calculate NdotE
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg             = NdotE;
                        _InstParam(RDPSINST_DP3).SrcReg0            = DstReg; // N
                        _InstParam(RDPSINST_DP3).SrcReg1            = EyeReg; // E
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask          = RDPS_COMPONENTMASK_3;

                        // Calculate NdotN
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg             = NdotN;
                        _InstParam(RDPSINST_DP3).SrcReg0            = DstReg; // N
                        _InstParam(RDPSINST_DP3).SrcReg1            = DstReg; // N
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask          = RDPS_COMPONENTMASK_3;

                        // Calculate scale = 2(NdotE/NdotN):

                        // a) Calculate reciprocal of NdotN
                        _NewPSInst(RDPSINST_RCP);
                        _InstParam(RDPSINST_RCP).DstReg             = RCPNdotN;
                        _InstParam(RDPSINST_RCP).SrcReg0            = NdotN;
                        _InstParam(RDPSINST_RCP).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_RCP).WriteMask          = RDPS_COMPONENTMASK_3;

                        // b) Multiply NdotE by reciprocal NdotN
                        _NewPSInst(RDPSINST_MUL);
                        _InstParam(RDPSINST_MUL).DstReg             = Scale;
                        _InstParam(RDPSINST_MUL).SrcReg0            = NdotE;
                        _InstParam(RDPSINST_MUL).SrcReg1            = RCPNdotN;
                        _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).WriteMask          = RDPS_COMPONENTMASK_3;

                        // c) Multiply by 2
                        _NewPSInst(RDPSINST_MUL);
                        _InstParam(RDPSINST_MUL).DstReg             = Scale;
                        _InstParam(RDPSINST_MUL).SrcReg0            = Scale;
                        _InstParam(RDPSINST_MUL).SrcReg1            = TwoReg; // 2.0f
                        _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).WriteMask          = RDPS_COMPONENTMASK_3;

                        // d) Replicate result to rgb
                        _NewPSInst(RDPSINST_SWIZZLE);
                        _InstParam(RDPSINST_SWIZZLE).DstReg     = Scale;
                        _InstParam(RDPSINST_SWIZZLE).SrcReg0    = Scale;
                        _InstParam(RDPSINST_SWIZZLE).WriteMask  = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
                        _InstParam(RDPSINST_SWIZZLE).Swizzle    = RDPS_REPLICATEALPHA;

                        // Calculate reflection = scale * N - E

                        _NewPSInst(RDPSINST_MUL);
                        _InstParam(RDPSINST_MUL).DstReg             = ReflReg;
                        _InstParam(RDPSINST_MUL).SrcReg0            = Scale;  // scale *
                        _InstParam(RDPSINST_MUL).SrcReg1            = DstReg; // N
                        _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).WriteMask          = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;

                        _NewPSInst(RDPSINST_SUB);
                        _InstParam(RDPSINST_SUB).DstReg             = ReflReg;
                        _InstParam(RDPSINST_SUB).SrcReg0            = ReflReg; // (scale * N) - 
                        _InstParam(RDPSINST_SUB).SrcReg1            = EyeReg;  // E
                        _InstParam(RDPSINST_SUB).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_SUB).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_SUB).WriteMask          = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;

                        // compute gradients for reflection lookup
                        _LeaveQuadPixelLoop

                        PRGBAVEC pReflReg = ReflReg.GetRegPtr();

                        _NewPSInst(RDPSINST_TEXCOVERAGE);
                        _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                        _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                        // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pReflReg[1][0]; // du/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pReflReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pReflReg[2][0]; // du/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pReflReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pReflReg[1][1]; // dv/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pReflReg[0][1];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pReflReg[2][1]; // dv/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pReflReg[0][1];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pReflReg[1][2]; // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pReflReg[0][2];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pReflReg[2][2]; // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pReflReg[0][2];

                        _EnterQuadPixelLoop

                        // do lookup
                        _NewPSInst(RDPSINST_SAMPLE);
                        _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                        _InstParam(RDPSINST_SAMPLE).CoordReg    = ReflReg;
                        _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                }
                break;
            case D3DSIO_BEM:
                _NewPSInst(RDPSINST_BEM);
                _InstParam(RDPSINST_BEM).DstReg             = DstReg;
                _InstParam(RDPSINST_BEM).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_BEM).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_BEM).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_BEM).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_BEM).WriteMask          = DstWriteMask;
                _InstParam(RDPSINST_BEM).uiStage            = pInst->DstParam & D3DSP_REGNUM_MASK;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_MOV:
                _NewPSInst(RDPSINST_MOV);
                _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                _InstParam(RDPSINST_MOV).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_MOV).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_FRC:
                _NewPSInst(RDPSINST_FRC);
                _InstParam(RDPSINST_FRC).DstReg             = DstReg;
                _InstParam(RDPSINST_FRC).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_FRC).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_FRC).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_ADD:
                _NewPSInst(RDPSINST_ADD);
                _InstParam(RDPSINST_ADD).DstReg             = DstReg;
                _InstParam(RDPSINST_ADD).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_ADD).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_ADD).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_ADD).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_ADD).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_SUB:
                _NewPSInst(RDPSINST_SUB);
                _InstParam(RDPSINST_SUB).DstReg             = DstReg;
                _InstParam(RDPSINST_SUB).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_SUB).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_SUB).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_SUB).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_SUB).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_MUL:
                _NewPSInst(RDPSINST_MUL);
                _InstParam(RDPSINST_MUL).DstReg             = DstReg;
                _InstParam(RDPSINST_MUL).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_MUL).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_MUL).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_DP3:
                _NewPSInst(RDPSINST_DP3);
                _InstParam(RDPSINST_DP3).DstReg             = DstReg;
                _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_DP3).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_DP3).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_DP4:
                _NewPSInst(RDPSINST_DP4);
                _InstParam(RDPSINST_DP4).DstReg             = DstReg;
                _InstParam(RDPSINST_DP4).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_DP4).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_DP4).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_DP4).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_DP4).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_MAD:
                _NewPSInst(RDPSINST_MAD);
                _InstParam(RDPSINST_MAD).DstReg             = DstReg;
                _InstParam(RDPSINST_MAD).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_MAD).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_MAD).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_MAD).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_MAD).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_MAD).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_MAD).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_LRP:
                _NewPSInst(RDPSINST_LRP);
                _InstParam(RDPSINST_LRP).DstReg             = DstReg;
                _InstParam(RDPSINST_LRP).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_LRP).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_LRP).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_LRP).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_LRP).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_LRP).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_LRP).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_CND:
                _NewPSInst(RDPSINST_CND);
                _InstParam(RDPSINST_CND).DstReg             = DstReg;
                _InstParam(RDPSINST_CND).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_CND).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_CND).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_CND).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_CND).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_CND).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_CND).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_CMP:
                _NewPSInst(RDPSINST_CMP);
                _InstParam(RDPSINST_CMP).DstReg             = DstReg;
                _InstParam(RDPSINST_CMP).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_CMP).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_CMP).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_CMP).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_CMP).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_CMP).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_CMP).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            default:
                break;
            }

            if( pInst->bFlushQueue )
            {
                _EnterQuadPixelLoop
                _NewPSInst(RDPSINST_FLUSHQUEUE);
                QueueIndex = -1;
            }

#if DBG
            _LeaveQuadPixelLoop
#endif
        }

        // Flush queue at end of shader if there is anything on it
        if( -1 != QueueIndex )
        {
            _EnterQuadPixelLoop
            _NewPSInst(RDPSINST_FLUSHQUEUE);
            QueueIndex = -1;
        }

        _LeaveQuadPixelLoop

        _NewPSInst(RDPSINST_END);

#if DBG
        if( pRast->m_bDebugPrintTranslatedPixelShaderTokens )
            RDPSDisAsm(pRDPSInstBuffer, m_pConstDefs, m_cConstDefs,pCaps->MaxPixelShaderValue, Version);
#endif
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\rastedge.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rastedge.cpp
//
// Direct3D Reference Device - Edge Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// Set - Computes edge function and associated information.
//
//-----------------------------------------------------------------------------
void
RDEdge::Set(
    BOOL bDetPositive,
    INT32 iX0, INT32 iY0,
    INT32 iX1, INT32 iY1)
{
    // compute A,B (gradient) terms - these are n.4 fixed point
    m_iA = iY0 - iY1;
    m_iB = iX1 - iX0;

    // flip gradient signs if backfacing so functions are consistently
    // greater than zero outside of primitive
    if ( bDetPositive ) { m_iA = -m_iA; m_iB = -m_iB; }

    // compute C term
    //
    // function is by definition zero at the vertices, so:
    //     0 = A*Xv + B*Yv + C  =>  C = - A*Xv - B*Yv
    //
    // A*Xv & B*Yv are n.4 * n.4 = n.8, so C is n.8 fixed point
    m_iC = - ( (INT64)iX0 * (INT64)m_iA ) - ( (INT64)iY0 * (INT64)m_iB );

    // compute edge function sign flags - must be done consistently for vertical
    // and horizontal cases to adhere to point sample fill rules
    BOOL bEdgeAEQZero = ( m_iA == 0. );
    BOOL bEdgeBEQZero = ( m_iB == 0. );
    BOOL bEdgeAGTZero = ( m_iA > 0. );
    BOOL bEdgeBGTZero = ( m_iB > 0. );
    m_bAPos = bEdgeAEQZero ? bEdgeBGTZero : bEdgeAGTZero;
    m_bBPos = bEdgeBEQZero ? bEdgeAGTZero : bEdgeBGTZero;
}

//-----------------------------------------------------------------------------
//
// Supports the Direct3D left-top fill rule.
//
// inputs are n.4 floating point
//
//-----------------------------------------------------------------------------
BOOL
RDEdge::Test( INT32 iX, INT32 iY )
{
    // evaluate edge distance function (n.8 fixed point)
    INT64 iEdgeDist =
        ( (INT64)m_iA * (INT64)iX ) +  // n.4 * n.4 = n.8
        ( (INT64)m_iB * (INT64)iY ) +  // n.4 * n.4 = n.8
        (INT64)m_iC;                   // n.8

    // pixel sample position is outside edge if distance is > zero
    //
    // This implements the D3D left-top fill rule
    //
    // For exactly-on-edge case (distance == zero), the sign of the Y gradient
    // is used to determine if the pixel is to be considered inside or outside
    // of the edge. For the non-horizontal case, the m_bAPos bit is based
    // simply on the sign of the Y slope.  This implements the 'left' part of
    // the 'left-top' rule.
    //
    // For the horizontal case,  the sign of the B gradient (X slope) is taken
    // into account in the computation of the m_bAPos bit when the A gradient
    // is exactly zero, which forces a pixel exactly on a 'top' edge to be
    // considered in and a pixel exactly on a 'bottom' edge to be considered out.
    //
    if ( ( iEdgeDist > 0 ) || ( ( iEdgeDist == 0 ) && m_bAPos ) )
    {
        // pixel is out
        return FALSE;
    }
    // pixel is in
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\refrast.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refrast.cpp
//
// Direct3D Reference Device - rasterizer miscellaneous
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RDColor                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
void
RDColor::ConvertFrom( RDSurfaceFormat Type, const char* pSurfaceBits )
{
    UINT16 u16BITS;
    UINT8 u8BITS;

    switch (Type)
    {
    default:
    case RD_SF_NULL: return;
    case RD_SF_B8G8R8A8: *this = *((UINT32*)pSurfaceBits); break;
    case RD_SF_B8G8R8X8: *this = *((UINT32*)pSurfaceBits); A = 1.F; break;

    case RD_SF_B5G6R5:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(6+5)) & 0x001F)/31.f;
        G = ((u16BITS>>   5) & 0x003F)/63.f;
        B = ((u16BITS      ) & 0x001F)/31.f;
        A = 1.F;
        break;

    case RD_SF_B5G5R5X1:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
        G = ((u16BITS>>   5) & 0x001F)/31.f;
        B = ((u16BITS      ) & 0x001F)/31.f;
        A = 1.F;
        break;

    case RD_SF_B5G5R5A1:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
        G = ((u16BITS>>   5) & 0x001F)/31.f;
        B = ((u16BITS      ) & 0x001F)/31.f;
        A = ( u16BITS & 0x8000 ) ? 1.f : 0.f;
        break;

    case RD_SF_B4G4R4A4:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>  (4+4)) & 0x000F)/15.f;
        G = ((u16BITS>>    (4)) & 0x000F)/15.f;
        B = ((u16BITS         ) & 0x000F)/15.f;
        A = ((u16BITS>>(4+4+4)) & 0x000F)/15.f;
        break;

    case RD_SF_B4G4R4X4:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(4+4)) & 0x000F)/15.f;
        G = ((u16BITS>>  (4)) & 0x000F)/15.f;
        B = ((u16BITS       ) & 0x000F)/15.f;
        A = 1.f;
        break;

    case RD_SF_B8G8R8:
        R = *((UINT8*)pSurfaceBits+2)/255.f;
        G = *((UINT8*)pSurfaceBits+1)/255.f;
        B = *((UINT8*)pSurfaceBits+0)/255.f;
        A = 1.F;
        break;

    case RD_SF_L8:
        R = G = B = *((UINT8*)pSurfaceBits)/255.f;
        A = 1.F;
        break;

    case RD_SF_L8A8:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = G = B = (UINT8)(0xff & u16BITS)/255.f;
        A = (UINT8)(0xff & (u16BITS >> 8))/255.f;
        break;

    case RD_SF_A8:
        R = G = B = 0.f;
        A = *((UINT8*)pSurfaceBits)/255.f;
        break;

    case RD_SF_B2G3R3:
        u8BITS = *((UINT8*)pSurfaceBits);
        R = ((u8BITS>>(3+2)) & 0x07)/7.f;
        G = ((u8BITS>>   2) & 0x07)/7.f;
        B = ((u8BITS      ) & 0x03)/3.f;
        A = 1.F;
        break;

    case RD_SF_L4A4:
        u16BITS = *((UINT8*)pSurfaceBits);
        R = G = B = (u16BITS & 0x0f)/15.f;
        A =    ((u16BITS>>4) & 0x0f)/15.f;
        break;

    case RD_SF_B2G3R3A8:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(3+2)) & 0x07)/7.f;
        G = ((u16BITS>>   2) & 0x07)/7.f;
        B = ((u16BITS      ) & 0x03)/3.f;
        A = (UINT8)(0xff & (u16BITS >> 8))/255.f;
        break;

    case RD_SF_U8V8:
        {
            INT8 iDU = *(( INT8*)pSurfaceBits+0);
            INT8 iDV = *(( INT8*)pSurfaceBits+1);
            R = CLAMP_SIGNED8(iDU);     // fDU
            G = CLAMP_SIGNED8(iDV);     // fDV
            B = 1.0F;                   // fL
            A = 1.F;
        }
        break;

    case RD_SF_U16V16:
        {
            INT16 iDU = *(( INT16*)pSurfaceBits+0);
            INT16 iDV = *(( INT16*)pSurfaceBits+1);
            R = CLAMP_SIGNED16(iDU);     // fDU
            G = CLAMP_SIGNED16(iDV);     // fDV
            B = 1.0f;   // 1.0 here is intentional
            A = 1.0f;
        }
        break;

    case RD_SF_U5V5L6:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            INT8 iDU = (INT8)(u16BITS & 0x1f);
            INT8 iDV = (INT8)((u16BITS>>5) & 0x1f);
            UINT8 uL = (UINT8)(u16BITS >> 10);
            R = CLAMP_SIGNED5(iDU);      // fDU
            G = CLAMP_SIGNED5(iDV);      // fDV
            // the unsigned uL is normalized with 2^N - 1, since this is the
            // largest representable value
            B = (FLOAT)uL * (1.0F/63.0F);       // fL
            A = 1.0f;
        }
        break;

    case RD_SF_U8V8L8X8:
        {
            INT8 iDU = *(( INT8*)pSurfaceBits+0);
            INT8 iDV = *(( INT8*)pSurfaceBits+1);
            UINT8 uL  = *((UINT8*)pSurfaceBits+2);
            R = CLAMP_SIGNED8(iDU);     // fDU
            G = CLAMP_SIGNED8(iDV);     // fDV
            // the unsigned uL is normalized with 2^N - 1, since this is the
            // largest representable value
            B = (FLOAT)uL * (1.0F/255.0F);      // fL
            A = 1.0f;
        }
        break;
    case RD_SF_U8V8W8Q8:
        {
            INT8 iDU = *(( INT8*)pSurfaceBits+0);
            INT8 iDV = *(( INT8*)pSurfaceBits+1);
            INT8 iDW = *(( INT8*)pSurfaceBits+2);
            INT8 iDQ = *(( INT8*)pSurfaceBits+3);
            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED8(iDU);     // fDU
            G = CLAMP_SIGNED8(iDV);     // fDV
            B = CLAMP_SIGNED8(iDW);     // fDW
            A = CLAMP_SIGNED8(iDQ);     // fDQ
        }
        break;
    case RD_SF_U10V11W11:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            INT16 iDU = (INT16)((u32BITS>>(0    )) & 0x3FF);
            INT16 iDV = (INT16)((u32BITS>>(10   )) & 0x7FF);
            INT16 iDW = (INT16)((u32BITS>>(10+11)) & 0x7FF);

            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED10(iDU);    // fDU
            G = CLAMP_SIGNED11(iDV);    // fDV
            B = CLAMP_SIGNED11(iDW);    // fDW
            A = 1.0f;
        }
        break;
    case RD_SF_R10G10B10A2:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = ((u32BITS>>(0    ))  & 0x3FF)/1023.f;
            G = ((u32BITS>>(10   ))  & 0x3FF)/1023.f;
            B = ((u32BITS>>(10+10))  & 0x3FF)/1023.f;
            A = ((u32BITS>>(10+10+10)) & 0x3)/3.f;
        }
    break;
    case RD_SF_R8G8B8A8:
        {
            R = *(( UINT8*)pSurfaceBits+0)/255.f;
            G = *(( UINT8*)pSurfaceBits+1)/255.f;
            B = *(( UINT8*)pSurfaceBits+2)/255.f;
            A = *(( UINT8*)pSurfaceBits+3)/255.f;
        }
    break;
    case RD_SF_R8G8B8X8:
        {
            R = *(( UINT8*)pSurfaceBits+0)/255.f;
            G = *(( UINT8*)pSurfaceBits+1)/255.f;
            B = *(( UINT8*)pSurfaceBits+2)/255.f;
            A = 1.f;
        }
    break;
    case RD_SF_R16G16:
        {
            R = *(( UINT16*)pSurfaceBits+0)/65535.f;
            G = *(( UINT16*)pSurfaceBits+1)/65535.f;
            B = 1.0f;   // 1.0 here is intentional
            A = 1.0f;
        }
    break;
    case RD_SF_U11V11W10:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            INT16 iDU = (INT16)((u32BITS>>(0    )) & 0x7FF);
            INT16 iDV = (INT16)((u32BITS>>(11   )) & 0x7FF);
            INT16 iDW = (INT16)((u32BITS>>(11+11)) & 0x3FF);

            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED11(iDU);    // fDU
            G = CLAMP_SIGNED11(iDV);    // fDV
            B = CLAMP_SIGNED10(iDW);    // fDW
            A = 1.0f;
        }
    break;
    case RD_SF_U10V10W10A2:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            INT16 iDU = (INT16)((u32BITS>>(0    )) & 0x3FF);
            INT16 iDV = (INT16)((u32BITS>>(10   )) & 0x3FF);
            INT16 iDW = (INT16)((u32BITS>>(10+10)) & 0x3FF);

            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED10(iDU);    // fDU
            G = CLAMP_SIGNED10(iDV);    // fDV
            B = CLAMP_SIGNED10(iDW);    // fDW

            // Note: The A component is treated as an unsigned component
            A = ((u32BITS>>(10+10+10)) & 0x3)/3.f; 
        }
    break;
    case RD_SF_U8V8X8A8:
        {
            INT8 iU = *(( INT8*)pSurfaceBits+0);
            INT8 iV = *(( INT8*)pSurfaceBits+1);
            
            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED8(iU);
            G = CLAMP_SIGNED8(iV);
            B = 1.0f;

            // Note: The A component is treated as unsigned 
            A = *(( INT8*)pSurfaceBits+3)/255.f;
        }
    break;
    case RD_SF_U8V8X8L8:
        {
            INT8 iU = *(( INT8*)pSurfaceBits+0);
            INT8 iV = *(( INT8*)pSurfaceBits+1);
            INT8 iL = *(( INT8*)pSurfaceBits+3);
            
            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED8(iU);
            G = CLAMP_SIGNED8(iV);
            B = CLAMP_SIGNED8(iL);
            A = 1.0f;
        }
    break;
    // shadow map texture formats (read only, not needed for ConvertTo)
    case RD_SF_Z16S0:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)u16BITS * (1.0F/(FLOAT)0xffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_Z24X4S4:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u32BITS>>8) * (1.0F/(FLOAT)0xffffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_X4S4Z24:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u32BITS&0x00ffffff) * (1.0F/(FLOAT)0xffffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_Z15S1:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u16BITS>>1) * (1.0F/(FLOAT)0x7fff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_S1Z15:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u16BITS&0x7fff) * (1.0F/(FLOAT)0x7fff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_Z32S0:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)u32BITS * (1.0F/(FLOAT)0xffffffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;
    }
}

// Convert surface type format to RDColor
void
RDColor::ConvertTo( RDSurfaceFormat Type, float fRoundOffset, char* pSurfaceBits ) const
{
    int iR, iG, iB, iA;

    switch (Type)
    {
    case RD_SF_B8G8R8A8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = (UINT8)((FLOAT)A * 255. + fRoundOffset);
        break;

    case RD_SF_B8G8R8X8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = 0x00;
        break;

    case RD_SF_B8G8R8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        break;

    case RD_SF_B4G4R4A4:
        iA = (FLOAT)A * 15. + fRoundOffset;
        iR = (FLOAT)R * 15. + fRoundOffset;
        iG = (FLOAT)G * 15. + fRoundOffset;
        iB = (FLOAT)B * 15. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iA<<12) | (iR<<8) | (iG<<4) | iB;
        break;

    case RD_SF_B4G4R4X4:
        iR = (FLOAT)R * 15. + fRoundOffset;
        iG = (FLOAT)G * 15. + fRoundOffset;
        iB = (FLOAT)B * 15. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (0x00<<12) | (iR<<8) | (iG<<4) | iB;
        break;

    case RD_SF_B5G6R5:
        iR = (FLOAT)R * 31. + fRoundOffset; // apply rounding bias then truncate
        iG = (FLOAT)G * 63. + fRoundOffset;
        iB = (FLOAT)B * 31. + fRoundOffset;
        *((UINT16*)pSurfaceBits) =            (iR<<11) | (iG<<5) | iB;
        break;

    case RD_SF_B5G5R5A1:
        iA = (FLOAT)A *  1. + fRoundOffset;
        iR = (FLOAT)R * 31. + fRoundOffset;
        iG = (FLOAT)G * 31. + fRoundOffset;
        iB = (FLOAT)B * 31. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iA<<15) | (iR<<10) | (iG<<5) | iB;
        break;

    case RD_SF_B5G5R5X1:
        iR = (FLOAT)R * 31. + fRoundOffset;
        iG = (FLOAT)G * 31. + fRoundOffset;
        iB = (FLOAT)B * 31. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iR<<10) | (iG<<5) | iB;
        break;

    case RD_SF_B2G3R3:
        iR = (FLOAT)R * 7. + fRoundOffset;
        iG = (FLOAT)G * 7. + fRoundOffset;
        iB = (FLOAT)B * 3. + fRoundOffset;
        *((UINT8*)pSurfaceBits) = (iR<<5) | (iG<<2) | iB;
        break;

    case RD_SF_B2G3R3A8:
        iA = (FLOAT)A * 255. + fRoundOffset;
        iR = (FLOAT)R * 7. + fRoundOffset;
        iG = (FLOAT)G * 7. + fRoundOffset;
        iB = (FLOAT)B * 3. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iA<<8) | (iR<<5) | (iG<<2) | iB;
        break;

    case RD_SF_R10G10B10A2:
        iR = (FLOAT)R * 1023.f + fRoundOffset;
        iG = (FLOAT)G * 1023.f + fRoundOffset;
        iB = (FLOAT)B * 1023.f + fRoundOffset;
        iA = (FLOAT)A * 3.f + fRoundOffset;
        *((UINT32*)pSurfaceBits) = (iA<<(10+10+10)) | (iB<<(10+10)) | (iG<<10) | iR;
        break;

    case RD_SF_R8G8B8A8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = (UINT8)((FLOAT)A * 255. + fRoundOffset);
        break;

    case RD_SF_R8G8B8X8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = 0x00;
        break;

    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\refrasti.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refrasti.hpp
//
// Direct3D Reference Device - Main Internal Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFRASTI_HPP
#define  _REFRASTI_HPP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Texture Mapping Utility Functions                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// various approximations and tricks to speed up the texture map coverage
// computations
//

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
#define FLOAT_OOEXPSCALE        ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

static inline FLOAT
RR_LOG2(FLOAT f)
{
    return (FLOAT)(AS_INT32(f) - INT32_FLOAT_ONE) * FLOAT_OOEXPSCALE;
}

static inline FLOAT
RR_ALOG2(FLOAT f)
{
    INT32 i = (INT32)(f * FLOAT_EXPSCALE) + INT32_FLOAT_ONE;
    return AS_FLOAT((long int)i);
}

static inline FLOAT
RR_ABSF(FLOAT f)
{
    UINT32 i = AS_UINT32(f) & 0x7fffffff;
    return AS_FLOAT((unsigned long int)i);
}

static inline FLOAT
RR_SQRT(FLOAT f)
{
    INT32 i = (AS_INT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return AS_FLOAT((long int)i);
}

//
// Steve Gabriel's version of an octagonal approximation euclidian distance -
// return is approximating sqrt(fX*fX + fY*fY)
//
static inline FLOAT
RR_LENGTH(FLOAT fX, FLOAT fY)
{
    fX = RR_ABSF(fX);
    fY = RR_ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

// compute level of detail (texel->pixel coverage)
void
ComputeSimpleLevelOfDetail(
    const RDTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeCubeMapLevelOfDetail(
    const RDTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeAnisotropicLevelOfDetail(
    const RDTextureCoord& TCoord, FLOAT fMaxAniso,  //  inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] );   //  outputs

// color interpolation utilities
void LerpColor(RDColor& Color,
    const RDColor& Color0, const RDColor& Color1, UINT8 uT);
void BiLerpColor( RDColor& OutColor,
    const RDColor& Color00, const RDColor& Color01,
    const RDColor& Color10, const RDColor& Color11,
    UINT8 uA, UINT8 uB);
void BiLerpColor3D( RDColor& OutColor,
    const RDColor& Color000, const RDColor& Color010,
    const RDColor& Color100, const RDColor& Color110,
    const RDColor& Color001, const RDColor& Color011,
    const RDColor& Color101, const RDColor& Color111,
    UINT8 uA, UINT8 uB, UINT8 uC);

///////////////////////////////////////////////////////////////////////////////
#endif  // _REFRASTI_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\psutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// psutil.cpp
//
// Direct3D Reference Device - Pixel Shader Utilities
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

#define _ADDSTR( _Str )             {_snprintf( pStr, 256, "%s" _Str , pStr );}
#define _ADDSTRP( _Str, _Param )    {_snprintf( pStr, 256, "%s" _Str , pStr, _Param );}

//-----------------------------------------------------------------------------
//
// PixelShaderInstDisAsm - Generates instruction disassembly string for a single
// pixel shader instruction.  String interface is similar to _snprintf.
//
//-----------------------------------------------------------------------------
int
PixelShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags )
{
    UINT    i,j;
    DWORD*  pToken = pShader;
    
    // stage in local string, then copy
    char pStr[256] = "";

    DWORD Inst = *pToken++;

    if( Inst & D3DSI_COISSUE )
    {
        _ADDSTR("+");
    }

    DWORD Opcode = (Inst & D3DSI_OPCODE_MASK);
    DWORD DstParam = 0;
    DWORD SrcParam[3];
    DWORD SrcParamCount = 0;

    if (*pToken & (1L<<31))
    {
        DstParam = *pToken++;
        while (*pToken & (1L<<31))
        {
            SrcParam[SrcParamCount] = *pToken++;
            SrcParamCount++;
        }
    }

    switch (Opcode)
    {
    case D3DSIO_PHASE: _ADDSTR("phase"); break;
    case D3DSIO_NOP: _ADDSTR("nop"); break;
    case D3DSIO_MOV: _ADDSTR("mov"); break;
    case D3DSIO_ADD: _ADDSTR("add"); break;
    case D3DSIO_SUB: _ADDSTR("sub"); break;
    case D3DSIO_MUL: _ADDSTR("mul"); break;
    case D3DSIO_MAD: _ADDSTR("mad"); break;
    case D3DSIO_LRP: _ADDSTR("lrp"); break;
    case D3DSIO_CND: _ADDSTR("cnd"); break;
    case D3DSIO_DP3: _ADDSTR("dp3"); break;
    case D3DSIO_DEF: _ADDSTR("def"); break;
    case D3DSIO_DP4: _ADDSTR("dp4"); break;
    case D3DSIO_CMP: _ADDSTR("cmp"); break;
    case D3DSIO_FRC: _ADDSTR("frc"); break;
    case D3DSIO_BEM: _ADDSTR("bem"); break;

    case D3DSIO_TEXCOORD    : if(SrcParamCount)
                                  _ADDSTR("texcrd")
                              else 
                                  _ADDSTR("texcoord"); 
                              break;
    case D3DSIO_TEX         : if(SrcParamCount)
                                  _ADDSTR("texld")
                              else
                                  _ADDSTR("tex"); 
                              break;
    case D3DSIO_TEXKILL     : _ADDSTR("texkill"); break;
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEM      : _ADDSTR("texbem"); break;
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXBEML     : _ADDSTR("texbeml"); break;
    case D3DSIO_TEXREG2AR   : _ADDSTR("texreg2ar"); break;
    case D3DSIO_TEXREG2GB   : _ADDSTR("texreg2gb"); break;
    case D3DSIO_TEXM3x2PAD  : _ADDSTR("texm3x2pad"); break;
    case D3DSIO_TEXM3x2TEX  : _ADDSTR("texm3x2tex"); break;
    case D3DSIO_TEXM3x3PAD  : _ADDSTR("texm3x3pad"); break;
    case D3DSIO_TEXM3x3TEX  : _ADDSTR("texm3x3tex"); break;
    case D3DSIO_TEXM3x3SPEC : _ADDSTR("texm3x3spec"); break;
    case D3DSIO_TEXM3x3VSPEC: _ADDSTR("texm3x3vspec"); break;
    case D3DSIO_TEXM3x2DEPTH : _ADDSTR("texm3x2depth"); break;
    case D3DSIO_TEXDP3      : _ADDSTR("texdp3"); break;
    case D3DSIO_TEXREG2RGB  : _ADDSTR("texreg2rgb"); break;
    case D3DSIO_TEXDEPTH    : _ADDSTR("texdepth"); break;
    case D3DSIO_TEXDP3TEX   : _ADDSTR("texdp3tex"); break;
    case D3DSIO_TEXM3x3     : _ADDSTR("texm3x3"); break;
    case D3DSIO_END         : _ADDSTR("END"); break;
    default:
        _ASSERT(FALSE,"Attempt to disassemble unknown instruction!");
    }

    if (DstParam)
    {
        switch ( (DstParam & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT )
        {
        default:
        case 0x0: break;
        case 0x1: _ADDSTR("_x2"); break;
        case 0x2: _ADDSTR("_x4"); break;
        case 0x3: _ADDSTR("_x8"); break;
        case 0xF: _ADDSTR("_d2"); break;
        case 0xE: _ADDSTR("_d4"); break;
        case 0xD: _ADDSTR("_d8"); break;
        }
        switch (DstParam & D3DSP_DSTMOD_MASK)
        {
        default:
        case D3DSPDM_NONE:      break;
        case D3DSPDM_SATURATE:  _ADDSTR("_sat"); break;
        }

        switch (DstParam & D3DSP_REGTYPE_MASK)
        {
        default:
        case D3DSPR_TEMP:    _ADDSTRP(" r%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXTURE: _ADDSTRP(" t%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_CONST:   _ADDSTRP(" c%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        }
        if (D3DSP_WRITEMASK_ALL != (DstParam & D3DSP_WRITEMASK_ALL))
        {
            _ADDSTR(".");
            if (DstParam & D3DSP_WRITEMASK_0) _ADDSTR("r");
            if (DstParam & D3DSP_WRITEMASK_1) _ADDSTR("g");
            if (DstParam & D3DSP_WRITEMASK_2) _ADDSTR("b");
            if (DstParam & D3DSP_WRITEMASK_3) _ADDSTR("a");
        }

        if( D3DSIO_DEF == Opcode )
        {
            for( i = 0; i < 4; i++ )
                _ADDSTRP(", %f", (float)(*pToken++) );
            goto EXIT;
        }
    }

    for( i = 0; i < SrcParamCount; i++ )
    {
        _ADDSTR(",");

        switch (SrcParam[i] & D3DSP_SRCMOD_MASK)
        {
        default:
        case D3DSPSM_NONE:    _ADDSTR(" "); break;
        case D3DSPSM_NEG:     _ADDSTR(" -"); break;
        case D3DSPSM_BIAS:    _ADDSTR(" "); break;
        case D3DSPSM_BIASNEG: _ADDSTR(" -"); break;
        case D3DSPSM_SIGN:    _ADDSTR(" "); break;
        case D3DSPSM_SIGNNEG: _ADDSTR(" -"); break;
        case D3DSPSM_COMP:    _ADDSTR(" 1-"); break;
        case D3DSPSM_X2:      _ADDSTR(" "); break;
        case D3DSPSM_X2NEG:   _ADDSTR(" -"); break;
        }
        switch (SrcParam[i] & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP:    _ADDSTRP("r%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_INPUT:   _ADDSTRP("v%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_CONST:   _ADDSTRP("c%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXTURE: _ADDSTRP("t%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        }
        switch (SrcParam[i] & D3DSP_SRCMOD_MASK)
        {
        default:
        case D3DSPSM_NONE:    break;
        case D3DSPSM_NEG:     break;
        case D3DSPSM_BIAS:    _ADDSTR("_bias"); break;
        case D3DSPSM_BIASNEG: _ADDSTR("_bias"); break;
        case D3DSPSM_SIGN:    _ADDSTR("_bx2"); break;
        case D3DSPSM_SIGNNEG: _ADDSTR("_bx2"); break;
        case D3DSPSM_COMP:    break;
        case D3DSPSM_X2:      _ADDSTR("_x2"); break;
        case D3DSPSM_X2NEG:   _ADDSTR("_x2"); break;
        case D3DSPSM_DZ:      _ADDSTR("_db"); break;
        case D3DSPSM_DW:      _ADDSTR("_da"); break;
        }
        switch (SrcParam[i] & D3DVS_SWIZZLE_MASK)
        {
        case D3DSP_NOSWIZZLE:       break;
        case D3DSP_REPLICATEALPHA:  _ADDSTR(".a"); break;
        case D3DSP_REPLICATERED:    _ADDSTR(".r"); break;
        case D3DSP_REPLICATEGREEN:  _ADDSTR(".g"); break;
        case D3DSP_REPLICATEBLUE:   _ADDSTR(".b"); break;
        default:
            _ADDSTR(".");
            for(j = 0; j < 4; j++)
            {
                switch(((SrcParam[i] & D3DVS_SWIZZLE_MASK) >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3)
                {
                case 0:
                    _ADDSTR("r");
                    break;
                case 1:
                    _ADDSTR("g");
                    break;
                case 2:
                    _ADDSTR("b");
                    break;
                case 3:
                    _ADDSTR("a");
                    break;
                }
            }
            break;
        }
    }
EXIT:
    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

int
RDPSInstSrcDisAsm(
    char* pStrRet, int StrSizeRet, RDPSRegister& SrcReg, BYTE Swizzle, BOOL bNegate, BOOL bForceShowFullSwizzle = FALSE )
{
    // stage in local string, then copy
    char pStr[256] = "";
    UINT i;
    BOOL bDoRegNum = TRUE;

    if( bNegate )
        _ADDSTR( "-" );

    switch( SrcReg.GetRegType() )
    {
    case RDPSREG_INPUT:
        _ADDSTR( "v" ); break;
    case RDPSREG_TEMP:
        _ADDSTR( "r" ); break;
    case RDPSREG_CONST:
        _ADDSTR( "c" ); break;
    case RDPSREG_TEXTURE:
        _ADDSTR( "t" ); break;
    case RDPSREG_POSTMODSRC:
        _ADDSTR( "postModSrc" ); break;
    case RDPSREG_SCRATCH:
        _ADDSTR( "scratch" ); break;
    case RDPSREG_QUEUEDWRITE:
        _ADDSTR( "queuedWrite" ); break;
    case RDPSREG_ZERO:
        _ADDSTR( "<0.0f>" ); bDoRegNum = FALSE; break;
    case RDPSREG_ONE:
        _ADDSTR( "<1.0f>" ); bDoRegNum = FALSE; break;
    case RDPSREG_TWO:
        _ADDSTR( "<2.0f>" ); bDoRegNum = FALSE; break;
    default:
        _ASSERT(FALSE,"RDPSInstSrcDisAsm - Unknown register type.");
        break;
    }

    if( bDoRegNum )
    {
        _ADDSTRP("%d", SrcReg.GetRegNum() );
    }


    if( !bForceShowFullSwizzle )
    {
        switch( Swizzle )
        {
        case RDPS_NOSWIZZLE:                         break;
        case RDPS_REPLICATERED:     _ADDSTR( ".r" ); break;
        case RDPS_REPLICATEGREEN:   _ADDSTR( ".g" ); break;
        case RDPS_REPLICATEBLUE:    _ADDSTR( ".b" ); break;
        case RDPS_REPLICATEALPHA:   _ADDSTR( ".a" ); break;
        default: bForceShowFullSwizzle = TRUE; break;
        }
    }
    if( bForceShowFullSwizzle )
    {
        _ADDSTR( "." );
        for( i=0; i<4; i++ )
        {
            switch( Swizzle & 0x3 )
            {
            case RDPS_SELECT_R: _ADDSTR("r"); break;
            case RDPS_SELECT_G: _ADDSTR("g"); break;
            case RDPS_SELECT_B: _ADDSTR("b"); break;
            case RDPS_SELECT_A: _ADDSTR("a"); break;
            }
            Swizzle >>= 2;        
        }
    }

    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

int
RDPSInstDestDisAsm(
    char* pStrRet, int StrSizeRet, RDPSRegister& DestReg, BYTE WriteMask )
{
    // stage in local string, then copy
    char pStr[256] = "";

    switch( DestReg.GetRegType() )
    {
    case RDPSREG_TEMP:
        _ADDSTR( "r" ); break;
    case RDPSREG_TEXTURE:
        _ADDSTR( "t" ); break;
    case RDPSREG_POSTMODSRC:
        _ADDSTR( "postModSrc" ); break;
    case RDPSREG_SCRATCH:
        _ADDSTR( "scratch" ); break;
    case RDPSREG_QUEUEDWRITE:
        _ADDSTR( "queuedWrite" ); break;
    default:
        _ASSERT(FALSE,"RDPSInstSrcDisAsm - Unknown or invalid destination register type.");
        break;
    }

    _ADDSTRP("%d", DestReg.GetRegNum() );

    if( 0 == WriteMask )
    {
        _ASSERT(FALSE,"RDPSInstSrcDisAsm - Invalid destination write mask (0).");
    }
    else if( RDPS_COMPONENTMASK_ALL != WriteMask )
    {
        _ADDSTR(".");
        if( RDPS_COMPONENTMASK_0 & WriteMask )
        {
            _ADDSTR("r");
        }
        if( RDPS_COMPONENTMASK_1 & WriteMask )
        {
            _ADDSTR("g");
        }
        if( RDPS_COMPONENTMASK_2 & WriteMask )
        {
            _ADDSTR("b");
        }
        if( RDPS_COMPONENTMASK_3 & WriteMask )
        {
            _ADDSTR("a");
        }
    }

    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

//-----------------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------------
void
RDPSDisAsm(BYTE* pRDPSInstBuffer, ConstDef* pConstDefs, UINT cConstDefs, FLOAT fMaxPixelShaderValue, DWORD dwVersion)
{
    #define _InstParam(__INST)         (*(__INST##_PARAMS UNALIGNED64*)pRDPSInstBuffer)
    #define _StepOverInst(__INST)       pRDPSInstBuffer += sizeof(__INST##_PARAMS);
    #define _DeclArgs(__INST)           __INST##_PARAMS& Args = _InstParam(__INST);
    // stage in local string, then copy
    char pStr[256] = "";
    char pTempStr[256] = "";

    _ADDSTR("-----------------------------------------------------------------------------");
    RDDebugPrintf( pStr ); *pStr = 0;

    _ADDSTR("CreatePixelShader - Listing refrast's 'RISC' translation of pixel shader.    ");
    RDDebugPrintf( pStr ); *pStr = 0;

    _ADDSTR("                    Using MaxPixelShaderValue: ");
    if( FLT_MAX == fMaxPixelShaderValue )
    {
        _ADDSTR("FLT_MAX");
    }
    else
    {
        _ADDSTRP("%f",fMaxPixelShaderValue);
    }
    RDDebugPrintf( pStr ); *pStr = 0;
    _ADDSTR("                    Pixel shader version:      ");
    _ADDSTRP("ps.%d", D3DSHADER_VERSION_MAJOR(dwVersion));
    _ADDSTRP(".%d", D3DSHADER_VERSION_MINOR(dwVersion));
    RDDebugPrintf( pStr ); *pStr = 0;

    _ADDSTR("-----------------------------------------------------------------------------");
    RDDebugPrintf( pStr ); *pStr = 0;

    for( UINT i = 0; i < cConstDefs; i++ )
    {
        _ADDSTRP("def         c%d, [",pConstDefs[i].RegNum);
        _ADDSTRP("%f,",pConstDefs[i].f[0]);
        _ADDSTRP("%f,",pConstDefs[i].f[1]);
        _ADDSTRP("%f,",pConstDefs[i].f[2]);
        _ADDSTRP("%f] (post-MaxPSVal-clamp shown)",pConstDefs[i].f[3]);
        RDDebugPrintf( pStr ); *pStr = 0;
    }
    
    while(RDPSINST_END != _InstParam(RDPSINST_BASE).Inst)
    {
#ifdef _IA64_
        _ASSERT(0 == ((ULONG_PTR)pRDPSInstBuffer & 0x7), "RDPSDisAsm() - Misaligned instuction pointer!");
#endif
        switch(_InstParam(RDPSINST_BASE).Inst)
        {
        case RDPSINST_EVAL:
            {
                _DeclArgs(RDPSINST_EVAL)
                _ADDSTR("eval        ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); 
                _ADDSTRP("%s <-- ", pTempStr);
                _ADDSTRP("CoordSet: %d, ", Args.uiCoordSet );
                _ADDSTR("bIgnoreD3DTTFF_PROJECTED: ");
                if( Args.bIgnoreD3DTTFF_PROJECTED ) 
                {
                    _ADDSTR( "TRUE");
                }
                else
                {
                    _ADDSTR( "FALSE");
                }
                _ADDSTR(", bClamp: ");
                if( Args.bClamp )
                {
                    _ADDSTR( "TRUE");
                }
                else
                {
                    _ADDSTR( "FALSE");
                }
            }
            _StepOverInst(RDPSINST_EVAL)
            break;
        case RDPSINST_SAMPLE:
            {
                _DeclArgs(RDPSINST_SAMPLE)
                _ADDSTR("sample      ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s <-- ", pTempStr);
                _ADDSTRP("TexStage: %d, TexCoords: ", Args.uiStage);
                RDPSInstSrcDisAsm(pTempStr,256,Args.CoordReg,RDPS_NOSWIZZLE,FALSE); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_SAMPLE)
            break;
        case RDPSINST_KILL:
            {
                _DeclArgs(RDPSINST_KILL)
                _ADDSTR("kill        ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_KILL)
            break;
        case RDPSINST_BEM:
            {
                _DeclArgs(RDPSINST_BEM)
                _ADDSTR("bem         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                _ADDSTRP("D3DTSS_BUMPENVMAT** Stage: %d", Args.uiStage);
            }
            _StepOverInst(RDPSINST_BEM)
            break;
        case RDPSINST_LUMINANCE:
            {
                _DeclArgs(RDPSINST_LUMINANCE)
                _ADDSTR("luminance   ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                _ADDSTRP("D3DTSS_BUMPENVLSCALE/OFFSET Stage: %d", Args.uiStage);
            }
            _StepOverInst(RDPSINST_LUMINANCE)
            break;
        case RDPSINST_DEPTH:
            {
                _DeclArgs(RDPSINST_DEPTH)
                _ADDSTR("depth       ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_DEPTH)
            break;
        case RDPSINST_SRCMOD:
            {
                _DeclArgs(RDPSINST_SRCMOD)
                _ADDSTR("srcMod      ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                if( Args.bComplement )
                    _ADDSTR("1-");
                if( Args.bTimes2 )
                    _ADDSTR("2*");
                if( Args.bTimes2 && Args.bBias )
                    _ADDSTR("(");
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,FALSE); _ADDSTRP("%s", pTempStr);
                if( Args.bBias )
                    _ADDSTR("-0.5");
                if( Args.bTimes2 && Args.bBias )
                    _ADDSTR(")");
                _ADDSTR(", Clamp[");
                if( -FLT_MAX == Args.fRangeMin )
                {
                    _ADDSTR("-FLT_MAX,");
                }
                else
                {
                    _ADDSTRP("%.0f,",Args.fRangeMin);
                }
                if( FLT_MAX == Args.fRangeMax )
                {
                    _ADDSTR("FLT_MAX]");
                }
                else
                {
                    _ADDSTRP("%.0f]",Args.fRangeMax);
                }
            }
            _StepOverInst(RDPSINST_SRCMOD)
            break;
        case RDPSINST_SWIZZLE:
            {
                _DeclArgs(RDPSINST_SWIZZLE)
                _ADDSTR("swizzle     ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,Args.Swizzle,FALSE,TRUE); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_SWIZZLE)
            break;
        case RDPSINST_DSTMOD:
            {
                _DeclArgs(RDPSINST_DSTMOD)
                _ADDSTR("dstMod      ");

                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.DstReg,RDPS_NOSWIZZLE,FALSE); _ADDSTRP("%s", pTempStr);

                if( (1.0f == Args.fScale) ||
                    (2.0f == Args.fScale) ||
                    (4.0f == Args.fScale) ||
                    (8.0f == Args.fScale) )
                {
                    _ADDSTRP("*%.0f",Args.fScale);
                }
                else if( (0.5f == Args.fScale) ||
                         (0.25f == Args.fScale) ||
                         (0.125f == Args.fScale) )
                {
                    _ADDSTRP("/%.0f",1/Args.fScale);
                }
                else
                    _ASSERT(FALSE,"RDPSDisAsm - Unexpected dest shift.");

                _ADDSTR(", Clamp[");
                if( -FLT_MAX == Args.fRangeMin )
                {
                    _ADDSTR("-FLT_MAX,");
                }
                else
                {
                    if( Args.fRangeMin == ceil(Args.fRangeMin) )
                    {
                        _ADDSTRP("%.0f,",Args.fRangeMin);
                    }
                    else
                    {
                        _ADDSTRP("%.4f,",Args.fRangeMin);
                    }
                }
                if( FLT_MAX == Args.fRangeMax )
                {
                    _ADDSTR("FLT_MAX]");
                }
                else
                {
                    if( Args.fRangeMax == floor(Args.fRangeMax) )
                    {
                        _ADDSTRP("%.0f]",Args.fRangeMax);
                    }
                    else
                    {
                        _ADDSTRP("%.4f]",Args.fRangeMax);
                    }
                }
            }
            _StepOverInst(RDPSINST_DSTMOD)
            break;
        case RDPSINST_MOV:
            {
                _DeclArgs(RDPSINST_MOV)
                _ADDSTR("mov         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_MOV)
            break;
        case RDPSINST_RCP:
            {
                _DeclArgs(RDPSINST_RCP)
                _ADDSTR("rcp         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_RCP)
            break;
        case RDPSINST_FRC:
            {
                _DeclArgs(RDPSINST_FRC)
                _ADDSTR("frc         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_FRC)
            break;
        case RDPSINST_ADD:
            {
                _DeclArgs(RDPSINST_ADD)
                _ADDSTR("add         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_ADD)
            break;
        case RDPSINST_SUB:
            {
                _DeclArgs(RDPSINST_SUB)
                _ADDSTR("sub         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_SUB)
            break;
        case RDPSINST_MUL:
            {
                _DeclArgs(RDPSINST_MUL)
                _ADDSTR("mul         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_MUL)
            break;
        case RDPSINST_DP3:
            {
                _DeclArgs(RDPSINST_DP3)
                _ADDSTR("dp3         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_DP3)
            break;
        case RDPSINST_DP4:
            {
                _DeclArgs(RDPSINST_DP4)
                _ADDSTR("dp4 ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_DP4)
            break;
        case RDPSINST_MAD:
            {
                _DeclArgs(RDPSINST_MAD)
                _ADDSTR("mad         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_MAD)
            break;
        case RDPSINST_LRP:
            {
                _DeclArgs(RDPSINST_LRP)
                _ADDSTR("lrp         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_LRP)
            break;
        case RDPSINST_CND:
            {
                _DeclArgs(RDPSINST_LRP)
                _ADDSTR("cnd         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_CND)
            break;
        case RDPSINST_CMP:
            {
                _DeclArgs(RDPSINST_CMP)
                _ADDSTR("cmp         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_CMP)
            break;
        case RDPSINST_TEXCOVERAGE:
            // don't bother to spew this (ref specific)
            _StepOverInst(RDPSINST_TEXCOVERAGE)
            break;
        case RDPSINST_QUADLOOPBEGIN:
            // don't bother to spew this
            _StepOverInst(RDPSINST_QUADLOOPBEGIN)
            break;
        case RDPSINST_QUADLOOPEND:
            // don't bother to spew this
            _StepOverInst(RDPSINST_QUADLOOPEND)
            break;
        case RDPSINST_QUEUEWRITE:
            {
                _DeclArgs(RDPSINST_QUEUEWRITE)
                _ADDSTR("queueWrite  ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s", pTempStr);
                _StepOverInst(RDPSINST_QUEUEWRITE)
                break;
            }
        case RDPSINST_FLUSHQUEUE:
            _ADDSTR("flushQueue  ");
            _StepOverInst(RDPSINST_FLUSHQUEUE)
            break;
        case RDPSINST_NEXTD3DPSINST:
            _ADDSTRP("------------------------------------------------- D3D PS Inst: '%s'",
                        _InstParam(RDPSINST_NEXTD3DPSINST).pInst->Text);
            _StepOverInst(RDPSINST_NEXTD3DPSINST)
            break;
        default:
            _ASSERT(FALSE,"RDPSDisAsm - Unrecognized refrast internal pixel shader instruction.");
            break;
        }
        if( 0 != *pStr )
        {
            RDDebugPrintf( pStr ); 
            *pStr = 0;
        }
    }
    _ADDSTR("------------------------------------------------- End of pixel shader. ------");
    RDDebugPrintf( pStr ); 
}


//-----------------------------------------------------------------------------
//
// UpdateLegacyPixelShader - Constructs pixel shader which performs all of
// the texture lookups, including bump mapping, for the legacy pixel shading
// model.  Result of running this shader is the full set of texture lookups
// in the temporary registers, which are then blended with the pixel diffuse
// and specular colors using the legacy texture blend code.
//
//-----------------------------------------------------------------------------

// destination parameter token
#define D3DSPD( _RegFile, _Num ) (\
    (1L<<31) |  (D3DSPR_##_RegFile) |\
    ((_Num)&D3DSP_REGNUM_MASK) |\
    (D3DSP_WRITEMASK_0|D3DSP_WRITEMASK_1|D3DSP_WRITEMASK_2|D3DSP_WRITEMASK_3) )

// source paramater token
#define D3DPSPS( _RegFile, _Num ) (\
    (1L<<31) | ((_Num)&D3DSP_REGNUM_MASK) |\
    D3DSP_NOSWIZZLE | (D3DSPR_##_RegFile) )

void
RefRast::UpdateLegacyPixelShader( void )
{
    if (m_pLegacyPixelShader) delete m_pLegacyPixelShader;
    m_pLegacyPixelShader = NULL;

    DWORD Tokens[64];
    DWORD* pToken = Tokens;

    *pToken++ = D3DPS_VERSION(0xfe,0xfe);
    BOOL bSkipNextStage = FALSE;
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        if ( m_pRD->m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }
        if (bSkipNextStage) { bSkipNextStage = FALSE; continue; }

        BOOL bIsBEM  = ( m_pRD->m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP );
        BOOL bIsBEML = ( m_pRD->m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE );
        if ( bIsBEM || bIsBEML )
        {
            // DX6/7 BEM(L) was set for stage with bump map (i.e. first of two), while DX8
            // BEM(L) is set for a subsequent stage, so we have to set a 'standard' texture
            // to this stage and BEM(L) for the next stage, then stop anything else from being
            // set for the next stage
            *pToken++ = D3DSIO_TEX;
            *pToken++ = D3DSPD(TEXTURE, iStage);
            *pToken++ = (bIsBEM) ? (D3DSIO_TEXBEM_LEGACY) : (D3DSIO_TEXBEML_LEGACY);
            *pToken++ = D3DSPD(TEXTURE, iStage+1);
            *pToken++ = D3DPSPS(TEXTURE, iStage);
            bSkipNextStage = TRUE;
        }
        else
        {
            // simple lookup into 'iStage' texture register
            *pToken++ = D3DSIO_TEX;
            *pToken++ = D3DSPD(TEXTURE, iStage);
        }
    }
    *pToken++ = D3DPS_END();

    if ( pToken > (Tokens+2) )
    {
        m_pLegacyPixelShader = new RDPShader;
        if (NULL == m_pLegacyPixelShader)
            DPFERR("E_OUTOFMEMORY");
        m_pLegacyPixelShader->Initialize( m_pRD, Tokens, 4*(pToken-Tokens), m_pRD->GetCaps8() );
    }

    if (m_pRD->m_pDbgMon) m_pRD->m_pDbgMon->StateChanged( D3DDM_SC_PSMODIFYSHADERS );
    return;
}

//-----------------------------------------------------------------------------
//
// Pixel Shader DP2 Command Functions
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::Dp2CreatePixelShader( DWORD handle, DWORD dwCodeSize, LPDWORD pCode )
{
    HRESULT hr = S_OK;

    HR_RET( m_PShaderHandleArray.Grow( handle ) );

    //
    // Validation sequence
    //
#if DBG
    _ASSERT( m_PShaderHandleArray[handle].m_tag == 0,
             "A shader exists with the given handle, tag is non-zero" );
#endif
    _ASSERT( m_PShaderHandleArray[handle].m_pShader == NULL,
             "A shader exists with the given handle" );


    RDPShader* pShader;

    pShader = m_PShaderHandleArray[handle].m_pShader = new RDPShader;

    if( pShader == NULL )
        return E_OUTOFMEMORY;

    hr = pShader->Initialize( this, pCode, dwCodeSize, GetCaps8() );
    if( FAILED( hr ) )
    {
        delete pShader;
        m_PShaderHandleArray[handle].m_pShader = NULL;
#if DBG
        m_PShaderHandleArray[handle].m_tag = 0;
#endif
        return hr;
    }

#if DBG
    // Everything successful, mark this handle as in use.
    m_PShaderHandleArray[handle].m_tag = 1;
#endif
    if (m_pDbgMon) m_pDbgMon->StateChanged( D3DDM_SC_PSMODIFYSHADERS );
    return hr;
}

HRESULT
RefDev::Dp2DeletePixelShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2PIXELSHADER pPS =
        (LPD3DHAL_DP2PIXELSHADER)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        DWORD handle = pPS[i].dwHandle;

        _ASSERT( m_PShaderHandleArray.IsValidIndex( handle ),
             "DeletePixelShader: invalid shader handle" );

        _ASSERT( m_PShaderHandleArray[handle].m_pShader,
             "DeletePixelShader: invalid shader" );

        delete m_PShaderHandleArray[handle].m_pShader;
        m_PShaderHandleArray[handle].m_pShader = NULL;
#if DBG
        m_PShaderHandleArray[handle].m_tag = 0;
#endif

        if( handle == m_CurrentPShaderHandle )
        {
            m_CurrentPShaderHandle = 0;
            m_dwRastFlags |= RDRF_PIXELSHADER_CHANGED;
        }
    }
    if (m_pDbgMon) m_pDbgMon->StateChanged( D3DDM_SC_PSMODIFYSHADERS );
    return hr;
}

HRESULT
RefDev::Dp2SetPixelShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    RDPShader* pShader = NULL;
    LPD3DHAL_DP2PIXELSHADER pPS =
        (LPD3DHAL_DP2PIXELSHADER)(pCmd + 1);

    // Just set the last Pixel Shader in this array
    DWORD handle = pPS[pCmd->wStateCount-1].dwHandle;

    if (handle)
    {
        if( !m_PShaderHandleArray.IsValidIndex( handle ) 
            ||
            (m_PShaderHandleArray[handle].m_pShader == NULL) )
        {
            DPFERR( "Such a Pixel Shader has not been created" );
            return E_INVALIDARG;
        }
        
        pShader = m_PShaderHandleArray[handle].m_pShader;
    }
    
    m_CurrentPShaderHandle = handle;
    m_dwRastFlags |= RDRF_PIXELSHADER_CHANGED;


    if( pShader )
    {
        for( UINT i = 0; i < pShader->m_cConstDefs; i++ )
        {
            // constant regs are duplicated for 4 pixel grid
            for (UINT iP=0; iP<4; iP++)
            {
                // Consts from DEF instructions have already been clamped,
                // so just copy them.
                memcpy( m_Rast.m_ConstReg[pShader->m_pConstDefs[i].RegNum][iP],
                        pShader->m_pConstDefs[i].f, 4*sizeof(FLOAT) ); 
            }
        }
    }

    if (m_pDbgMon) m_pDbgMon->StateChanged( D3DDM_SC_PSSETSHADER );
    return hr;
}

HRESULT
RefDev::Dp2SetPixelShaderConsts( DWORD StartReg, DWORD dwCount,
                                               LPDWORD pData )
{
    HRESULT hr = S_OK;

    if ( (StartReg+dwCount) > RDPS_MAX_NUMCONSTREG )
    {
        DPFERR("start/count out of range in SetPixelShaderConstant");
        return D3DERR_INVALIDCALL;
    }

    FLOAT* pfData = (FLOAT*)pData;
    FLOAT fMin = -(GetCaps8()->MaxPixelShaderValue);
    FLOAT fMax =  (GetCaps8()->MaxPixelShaderValue);
    UINT End = StartReg + dwCount;
    for (UINT iR=StartReg; iR<End; iR++)
    {
        // clamp constants on input to range of values in pixel shaders
        FLOAT fConst[4];
        fConst[0] = MAX( fMin, MIN( fMax, *(pfData+0) ) );
        fConst[1] = MAX( fMin, MIN( fMax, *(pfData+1) ) );
        fConst[2] = MAX( fMin, MIN( fMax, *(pfData+2) ) );
        fConst[3] = MAX( fMin, MIN( fMax, *(pfData+3) ) );
        pfData += 4;

        // constant regs are duplicated for 4 pixel grid
        for (UINT iP=0; iP<4; iP++)
        {
            m_Rast.m_ConstReg[iR][iP][0] = fConst[0];
            m_Rast.m_ConstReg[iR][iP][1] = fConst[1];
            m_Rast.m_ConstReg[iR][iP][2] = fConst[2];
            m_Rast.m_ConstReg[iR][iP][3] = fConst[3];
        }
    }
    if (m_pDbgMon) m_pDbgMon->StateChanged( D3DDM_SC_PSCONSTANTS );
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\rastprim.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rastprim.cpp
//
// Direct3D Reference Device - Rasterizer Primitive Routines
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
RefRast::~RefRast()
{
    delete m_pLegacyPixelShader;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void RefRast::Init( RefDev* pRD )
{
    m_pRD = pRD;
    m_bIsLine = FALSE;
    m_iFlatVtx = 0;

    // initialize attributes           xD  Persp  Clamp
    m_Attr[RDATTR_DEPTH   ].Init( this, 1, FALSE, TRUE );
    m_Attr[RDATTR_FOG     ].Init( this, 1, TRUE,  TRUE );
    m_Attr[RDATTR_COLOR   ].Init( this, 4, TRUE,  TRUE );
    m_Attr[RDATTR_SPECULAR].Init( this, 4, TRUE,  TRUE );
    m_Attr[RDATTR_TEXTURE0].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE1].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE2].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE3].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE4].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE5].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE6].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE7].Init( this, 4, TRUE,  FALSE );

    m_iPix = 0;
    memset( m_bPixelIn, 0, sizeof(m_bPixelIn) );
    memset( m_bSampleCovered, 0, sizeof(m_bSampleCovered) );
    m_bLegacyPixelShade = TRUE;
    m_pCurrentPixelShader = NULL;
    m_CurrentPSInst = 0;
#if DBG
    {
        DWORD v = 0;
        if( GetD3DRefRegValue(REG_DWORD, "VerboseCreatePixelShader", &v, sizeof(DWORD)) && v != 0 )
            m_bDebugPrintTranslatedPixelShaderTokens = TRUE;
        else
            m_bDebugPrintTranslatedPixelShaderTokens = FALSE;
    }
#endif

    // default value registers
    UINT i, j;
    for( i = 0 ; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            m_ZeroReg[i][j] = 0.0f;
            m_OneReg[i][j]  = 1.0f;
            m_TwoReg[i][j]  = 2.0f;
        }
    }

    m_bLegacyPixelShade = TRUE;
    m_pLegacyPixelShader = NULL;

    memset( m_bPixelDiscard, 0, sizeof(m_bPixelDiscard) );

    // multi-sample stuff
    m_CurrentSample = 0;
    m_SampleMask = 0xffffffff;
    SetSampleMode( 1, TRUE );
    m_bSampleCovered[0][0] =
    m_bSampleCovered[0][1] =
    m_bSampleCovered[0][2] =
    m_bSampleCovered[0][3] = TRUE;

    memset( m_TexCvg, 0, sizeof(m_TexCvg) );
    memset( m_TexFlt, 0, sizeof(m_TexFlt) );
}

//-----------------------------------------------------------------------------
//
// SampleAndInvertRHW - Sample 1/W at current given location, invert, return
//
//-----------------------------------------------------------------------------
FLOAT RefRast::SampleAndInvertRHW( FLOAT fX, FLOAT fY )
{
    FLOAT fPixelRHW = fX*m_fRHWA + fY*m_fRHWB + m_fRHWC;
    FLOAT fPixelW = ( 0. != fPixelRHW ) ? ( 1./fPixelRHW ) : ( 0. );
    return fPixelW;
}

//-----------------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------------
BOOL
RefRast::EvalPixelPosition( int iPix )
{
    BOOL bPixelIn;

    if (m_SampleCount > 1)
    {
        bPixelIn = FALSE; // assume out, then set if any in

        // generating multiple samples, so must evaluate all
        // sample positions for in/out
        do
        {
            BOOL bPixelSampleIn = GetCurrentSampleMask();
            if (!bPixelSampleIn) continue;

            // get sample location
            INT32 iX = GetCurrentSampleX(iPix);
            INT32 iY = GetCurrentSampleY(iPix);

            // test each edge
            for ( int iEdge=0; iEdge<m_iEdgeCount; iEdge++ )
            {
                bPixelSampleIn &= m_Edge[iEdge].Test( iX, iY );
                if (!bPixelSampleIn) break;
            }

            m_bSampleCovered[m_CurrentSample][iPix] = bPixelSampleIn;

            // accumulate per-sample test into per-pixel test
            bPixelIn |= bPixelSampleIn;

        } while (NextSample());
    }
    else
    {
        bPixelIn = TRUE; // assume pixel is inside all edges

        // single sample, so just test pixel center
        for ( int iEdge=0; iEdge<m_iEdgeCount; iEdge++ )
        {
            bPixelIn &= m_Edge[iEdge].Test( m_iX[iPix]<<4, m_iY[iPix]<<4 );
            if (!bPixelIn) break;
        }
    }
    return bPixelIn;

}

///////////////////////////////////////////////////////////////////////////////
//
// Triangle (& Point) Setup
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// PerTriangleSetup - Per-triangle portion of triangle setup excluding any
// per-edge or per-attribute work.  Includes snapping of x,y coords to n.4
// grid to enable subsequent edge computations to be exact fixed point;
// computation of determinant; culling; computation and intersection tests
// of scan area; and setup of perspective correction function.
//
//-----------------------------------------------------------------------------
BOOL RefRast::PerTriangleSetup(
    FLOAT* pVtx0, FLOAT* pVtx1, FLOAT* pVtx2,
    DWORD CullMode,
    RECT* pClip)
{
    m_bIsLine = FALSE;

    FLOAT fX0 = *(pVtx0+0);
    FLOAT fY0 = *(pVtx0+1);
    FLOAT fX1 = *(pVtx1+0);
    FLOAT fY1 = *(pVtx1+1);
    FLOAT fX2 = *(pVtx2+0);
    FLOAT fY2 = *(pVtx2+1);

    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    m_iX0 = FloatToNdot4(fX0);
    m_iY0 = FloatToNdot4(fY0);
    m_iX1 = FloatToNdot4(fX1);
    m_iY1 = FloatToNdot4(fY1);
    m_iX2 = FloatToNdot4(fX2);
    m_iY2 = FloatToNdot4(fY2);

    // compute integer deltas
    INT32 iDelX10 = m_iX1 - m_iX0;
    INT32 iDelX02 = m_iX0 - m_iX2;
    INT32 iDelY01 = m_iY0 - m_iY1;
    INT32 iDelY20 = m_iY2 - m_iY0;

    // compute determinant in n.8 fixed point (n.4 * n.4 = n.8)
    m_iDet =
        ( (INT64)iDelX10 * (INT64)iDelY20 ) -
        ( (INT64)iDelX02 * (INT64)iDelY01 );

    // check for degeneracy (no area)
    if ( 0 == m_iDet ) { return TRUE; }

    // do culling
    switch ( CullMode )
    {
    case D3DCULL_NONE:  break;
    case D3DCULL_CW:    if ( m_iDet > 0 )  { return TRUE; }  break;
    case D3DCULL_CCW:   if ( m_iDet < 0 )  { return TRUE; }  break;
    }

    // compute bounding box for scan area
    FLOAT fXMin = MIN( fX0, MIN( fX1, fX2 ) );
    FLOAT fXMax = MAX( fX0, MAX( fX1, fX2 ) );
    FLOAT fYMin = MIN( fY0, MIN( fY1, fY2 ) );
    FLOAT fYMax = MAX( fY0, MAX( fY1, fY2 ) );
    // convert to integer (round to +inf)
    m_iXMin = (INT32)(fXMin+.5);
    m_iXMax = (INT32)(fXMax+.5);
    m_iYMin = (INT32)(fYMin+.5);
    m_iYMax = (INT32)(fYMax+.5);

    // clip bbox to rendering surface
    m_iXMin = MAX( m_iXMin, pClip->left   );
    m_iXMax = MIN( m_iXMax, pClip->right  );
    m_iYMin = MAX( m_iYMin, pClip->top    );
    m_iYMax = MIN( m_iYMax, pClip->bottom );

    // reject if no coverage
    if ( ( m_iXMin < pClip->left   ) ||
         ( m_iXMax > pClip->right  ) ||
         ( m_iYMin < pClip->top    ) ||
         ( m_iYMax > pClip->bottom ) )
    {
        return TRUE;
    }

    // compute float versions of snapped coord data
    m_fX0 = (FLOAT)m_iX0 * 1.0F/16.0F;
    m_fY0 = (FLOAT)m_iY0 * 1.0F/16.0F;
    m_fDelX10 = (FLOAT)iDelX10 * 1.0F/16.0F;
    m_fDelX02 = (FLOAT)iDelX02 * 1.0F/16.0F;
    m_fDelY01 = (FLOAT)iDelY01 * 1.0F/16.0F;
    m_fDelY20 = (FLOAT)iDelY20 * 1.0F/16.0F;

    // compute inverse determinant
    FLOAT fDet = (1./(FLOAT)(1<<8)) * (FLOAT)m_iDet;
    m_fTriOODet = 1.f/fDet;

    // compute linear function for 1/W (for perspective correction)
    m_fRHW0 = *(pVtx0+3);
    m_fRHW1 = *(pVtx1+3);
    m_fRHW2 = *(pVtx2+3);

    // compute linear deltas along two edges
    FLOAT fDelAttrib10 = m_fRHW1 - m_fRHW0;
    FLOAT fDelAttrib20 = m_fRHW2 - m_fRHW0;

    // compute A & B terms (dVdX and dVdY)
    m_fRHWA = m_fTriOODet * ( fDelAttrib10 * m_fDelY20 + fDelAttrib20 * m_fDelY01 );
    m_fRHWB = m_fTriOODet * ( fDelAttrib20 * m_fDelX10 + fDelAttrib10 * m_fDelX02 );

    // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
    m_fRHWC = m_fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Line Setup & Evaluate
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// PointDiamondCheck - Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is pixel-relative
// test - this corresponds to an upper-left test for a vertex-relative position.
//
//-----------------------------------------------------------------------------
static BOOL
PointDiamondCheck(
    INT32 iXFrac, INT32 iYFrac,
    BOOL bSlopeIsOne, BOOL bSlopeIsPosOne )
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf ) return TRUE;

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
        return TRUE;

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
        return TRUE;

    // return true if slope is one, vertex is on edge, and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
            return TRUE;

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
            return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//
// PerLineSetup - Does per-line setup including scan conversion
//
// This implements the Grid Intersect Quanization (GIQ) convention (which is
// also used in Windows).
//
// Returns: TRUE if line is discarded; FALSE if line to be drawn
//
//-----------------------------------------------------------------------------
BOOL
RefRast::PerLineSetup(
    FLOAT* pVtx0, FLOAT* pVtx1,
    BOOL bLastPixel,
    RECT* pClip)
{
    m_bIsLine = TRUE;

    FLOAT fX0 = *(pVtx0+0);
    FLOAT fY0 = *(pVtx0+1);
    FLOAT fX1 = *(pVtx1+0);
    FLOAT fY1 = *(pVtx1+1);

    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    m_iX0 = FloatToNdot4( fX0 );
    m_iY0 = FloatToNdot4( fY0 );
    m_iX1 = FloatToNdot4( fX1 );
    m_iY1 = FloatToNdot4( fY1 );

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = m_iX1 - m_iX0;
    INT32 iYSize = m_iY1 - m_iY0;

    if ( ( iXSize == 0 ) && ( iYSize == 0 ) ) { return TRUE; }

    // determine major direction and compute line function
    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( labs( iXSize ) >= labs( iYSize )  )
    {
        // here for X major
        m_bLineXMajor = TRUE;
        m_fLineMajorLength = (FLOAT)iXSize * (1./16.);

        // line function: y = F(x) = ( [0]*x + [1] ) / [2]
        m_iLineEdgeFunc[0] = iYSize;
        m_iLineEdgeFunc[1] = (INT64)m_iY0*(INT64)m_iX1 - (INT64)m_iY1*(INT64)m_iX0;
        m_iLineEdgeFunc[2] = iXSize;
    }
    else
    {
        // here for Y major
        m_bLineXMajor = FALSE;
        m_fLineMajorLength = (FLOAT)iYSize * (1./16.);

        // line function: x = F(y) = ( [0]*y + [1] ) / [2]
        m_iLineEdgeFunc[0] = iXSize;
        m_iLineEdgeFunc[1] = (INT64)m_iX0*(INT64)m_iY1 - (INT64)m_iX1*(INT64)m_iY0;
        m_iLineEdgeFunc[2] = iYSize;
    }

    BOOL bSlopeIsOne = ( labs( iXSize ) == labs( iYSize ) );
    BOOL bSlopeIsPosOne =
        bSlopeIsOne &&
        ( ( (FLOAT)m_iLineEdgeFunc[0]/(FLOAT)m_iLineEdgeFunc[2] ) > 0. );

    // compute candidate pixel location for line endpoints
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for exception (slope == +1)
    // case else use nearest ceiling
    //
    // nearest ceiling of Y is ceil( Y - .5), and is done by converting to floor via:
    //
    //   ceil( A/B ) = floor( (A+B-1)/B )
    //
    // where A is coordinate - .5, and B is 0x10 (thus A/B is an n.4 fixed point number)
    //
    // A+B-1 = ( (Y - half) + B - 1 = ( (Y-0x8) + 0x10 - 0x1 = Y + 0x7
    // since B is 2**4, divide by B is right shift by 4
    //
    INT32 iPixX0 = ( m_iX0 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixX1 = ( m_iX1 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixY0 = ( m_iY0 + 0x7 ) >> 4;
    INT32 iPixY1 = ( m_iY1 + 0x7 ) >> 4;


    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( m_iX0 - (iPixX0<<4), m_iY0 - (iPixY0<<4), bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( m_iX1 - (iPixX1<<4), m_iY1 - (iPixY1<<4), bSlopeIsOne, bSlopeIsPosOne );

    // compute step value
    m_iLineStep = ( m_fLineMajorLength > 0 ) ? ( +1 ) : ( -1 );

    // compute float and integer major start (V0) and end (V1) positions
    INT32 iLineMajor0 = ( m_bLineXMajor ) ? ( m_iX0 ) : ( m_iY0 );
    INT32 iLineMajor1 = ( m_bLineXMajor ) ? ( m_iX1 ) : ( m_iY1 );
    m_iLineMin = ( m_bLineXMajor ) ? ( iPixX0 ) : ( iPixY0 );
    m_iLineMax = ( m_bLineXMajor ) ? ( iPixX1 ) : ( iPixY1 );

// need to do lots of compares which are flipped if major direction is negative
#define LINEDIR_CMP( _A, _B ) \
( ( m_fLineMajorLength > 0 ) ? ( (_A) < (_B) ) : ( (_A) > (_B) ) )

    // do first pixel handling - keep first pixel if not in or behind diamond
    if ( !( bV0InDiamond || LINEDIR_CMP( iLineMajor0, (m_iLineMin<<4) ) ) )
    {
        m_iLineMin += m_iLineStep;
    }

    // do last-pixel handling - keep last pixel if past diamond (in which case
    // the pixel is always filled) or if in diamond and rendering last pixel
    if ( !( ( !bV1InDiamond && LINEDIR_CMP( (m_iLineMax<<4), iLineMajor1 ) ) ||
            ( bV1InDiamond && bLastPixel ) ) )
    {
        m_iLineMax -= m_iLineStep;
    }

    // return if no (major) extent (both before and after clamping to render buffer)
    if ( LINEDIR_CMP( m_iLineMax, m_iLineMin ) ) return TRUE;

    // snap major extent to render buffer
    INT16 iRendBufMajorMin = m_bLineXMajor ? pClip->left  : pClip->top;
    INT16 iRendBufMajorMax = m_bLineXMajor ? pClip->right : pClip->bottom;
    if ( ( ( m_iLineMin < iRendBufMajorMin ) &&
           ( m_iLineMax < iRendBufMajorMin ) ) ||
         ( ( m_iLineMin > iRendBufMajorMax ) &&
           ( m_iLineMax > iRendBufMajorMax ) ) )  { return TRUE; }
    m_iLineMin = MAX( 0, MIN( iRendBufMajorMax, m_iLineMin ) );
    m_iLineMax = MAX( 0, MIN( iRendBufMajorMax, m_iLineMax ) );

    // return if no (major) extent
    if ( LINEDIR_CMP( m_iLineMax, m_iLineMin ) ) return TRUE;

    // number of steps to iterate
    m_cLineSteps = abs( m_iLineMax - m_iLineMin );

    // initial state for per-pixel line iterator
    m_iMajorCoord = m_iLineMin;

    // compute float versions of snapped coord data
    m_fX0 = (FLOAT)m_iX0 * 1.0F/16.0F;
    m_fY0 = (FLOAT)m_iY0 * 1.0F/16.0F;

    // compute linear function for 1/W (for perspective correction)
    m_fRHW0 = *(pVtx0+3);
    m_fRHW1 = *(pVtx1+3);

    FLOAT fDelta = ( m_fRHW1 - m_fRHW0 ) / m_fLineMajorLength;
    m_fRHWA = ( m_bLineXMajor ) ? ( fDelta ) : ( 0. );
    m_fRHWB = ( m_bLineXMajor ) ? ( 0. ) : ( fDelta );
    m_fRHWC = m_fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
//
// DivRoundDown(A,B) = ceiling(A/B - 1/2)
//
// ceiling(A/B - 1/2) == floor(A/B + 1/2 - epsilon)
// == floor( (A + (B/2 - epsilon))/B )
//
// Does correct thing for all sign combinations of A and B.
//
//-----------------------------------------------------------------------------
static INT64
DivRoundDown(INT64 iA, INT32 iB)
{
    INT32 i = 0;
    static const INT32 iEps[3] =
    {
        1,      // iA > 0, iB > 0
        0,      // iA < 0, iB > 0  OR iA > 0, iB < 0
        1       // iA < 0, iB < 0
    };
    if (iA < 0)
    {
        i++;
        iA = -iA;
    }
    if (iB < 0)
    {
        i++;
        iB = -iB;
    }
    iA += (iB-iEps[i]) >> 1;
    iA /= iB;
    if (iEps[i] == 0)
        iA = -iA;
    return(iA);
}

//-----------------------------------------------------------------------------
//
// DoScanCnvLine - Walks the line major axis, computes the appropriate minor
// axis coordinate, and generates pixels.
//
//-----------------------------------------------------------------------------
void
RefRast::StepLine( void )
{
    // evaluate line function to compute minor coord for this major
    INT64 iMinorCoord =
        ( ( m_iLineEdgeFunc[0] * (INT64)(m_iMajorCoord<<4) ) + m_iLineEdgeFunc[1] );
    iMinorCoord = DivRoundDown(iMinorCoord, m_iLineEdgeFunc[2]<<4);

    // grab x,y
    m_iX[0] = m_bLineXMajor ? m_iMajorCoord : iMinorCoord;
    m_iY[0] = m_bLineXMajor ? iMinorCoord : m_iMajorCoord;

    // step major for next evaluation
    m_iMajorCoord += m_iLineStep;
}


///////////////////////////////////////////////////////////////////////////////
//
// Multi-Sample Controls
//
///////////////////////////////////////////////////////////////////////////////

#define _SetSampleDelta( _SampleNumber, _XOffset, _YOffset ) \
{ \
    m_SampleDelta[_SampleNumber][0] = ((INT32)((_XOffset)*16.F)); \
    m_SampleDelta[_SampleNumber][1] = ((INT32)((_YOffset)*16.F)); \
}

void
RefRast::SetSampleMode( UINT MultiSamples, BOOL bAntialias )
{
    switch (MultiSamples)
    {
    default:
    case 1:
        m_SampleCount = 1;
        _SetSampleDelta( 0, 0., 0. );
        break;

    case 4:
        m_SampleCount = 4;
        _SetSampleDelta( 0, -.25, -.25 );
        _SetSampleDelta( 1, +.25, -.25 );
        _SetSampleDelta( 2, +.25, +.25 );
        _SetSampleDelta( 3, -.25, +.25 );
        break;

    case 9:
        m_SampleCount = 9;
        _SetSampleDelta( 0, -.333, -.333 );
        _SetSampleDelta( 1, -.333,   0.0 );
        _SetSampleDelta( 2, -.333, +.333 );
        _SetSampleDelta( 3,   0.0, -.333 );
        _SetSampleDelta( 4,   0.0,   0.0 );
        _SetSampleDelta( 5,   0.0, +.333 );
        _SetSampleDelta( 6, +.333, -.333 );
        _SetSampleDelta( 7, +.333,   0.0 );
        _SetSampleDelta( 8, +.333, +.333 );
        break;
    }

    // if not FSAA then sample all at pixel center
    if (!bAntialias)
    {
        for (UINT Sample=0; Sample<m_SampleCount; Sample++)
        {
            _SetSampleDelta( Sample, 0., 0. );
        }
    }

    m_CurrentSample = 0;
    m_bSampleCovered[0][0] =
    m_bSampleCovered[0][1] =
    m_bSampleCovered[0][2] =
    m_bSampleCovered[0][3] = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\setup.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// setup.cpp
//
// Direct3D Reference Device - Primitive Setup
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

// texture coordinates for use in point sprite mode
static const
FLOAT g_PSTexCoord[3][4] =
{
    { 0., 0., 0., 1. },
    { 1., 0., 0., 1. },
    { 0., 1., 0., 1. },
};


void
RefRast::SetAttributeFunctions(
    const RDVertex& Vtx0,
    const RDVertex& Vtx1,
    const RDVertex& Vtx2 )
{
    _ASSERT( Vtx0.m_qwFVF, "0x0 FVF code in setup" );

    // compute depth function
    if ( D3DZB_USEW == m_pRD->GetRS()[D3DRS_ZENABLE] )
    {
        FLOAT fW0 = 1./Vtx0.GetRHW();
        FLOAT fW1 = 1./Vtx1.GetRHW();
        FLOAT fW2 = 1./Vtx2.GetRHW();
        m_Attr[RDATTR_DEPTH].Setup( &fW0, &fW1, &fW2 );
    }
    else
    {
        FLOAT z0 = Vtx0.GetZ();
        FLOAT z1 = Vtx1.GetZ();
        FLOAT z2 = Vtx2.GetZ();

        m_Attr[RDATTR_DEPTH].Setup( &z0, &z1, &z2 );
    }

    if( m_pRD->GetRS()[D3DRS_SHADEMODE] == D3DSHADE_FLAT )
    {
        m_Attr[RDATTR_COLOR].m_bFlatShade = TRUE;
        m_Attr[RDATTR_SPECULAR].m_bFlatShade = TRUE;
    }
    else
    {
        m_Attr[RDATTR_COLOR].m_bFlatShade = FALSE;
        m_Attr[RDATTR_SPECULAR].m_bFlatShade = FALSE;
    }

    // compute color functions
    m_Attr[RDATTR_COLOR].Setup(
        Vtx0.GetDiffuse(), Vtx1.GetDiffuse(), Vtx2.GetDiffuse() );

    m_Attr[RDATTR_SPECULAR].Setup(
        Vtx0.GetSpecular(), Vtx1.GetSpecular(), Vtx2.GetSpecular() );

    // compute vertex fog function
    if ( m_pRD->GetRS()[D3DRS_FOGENABLE] &&
         ( m_pRD->GetRS()[D3DRS_FOGTABLEMODE] == D3DFOG_NONE ) )
    {
        FLOAT fF0 = Vtx0.GetFog();
        FLOAT fF1 = Vtx1.GetFog();
        FLOAT fF2 = Vtx2.GetFog();
        m_Attr[RDATTR_FOG].Setup( &fF0, &fF1, &fF2 );
    }

    for (INT32 iStage = 0; iStage < D3DHAL_TSS_MAXSTAGES; iStage++)
    {
        FLOAT TexCrd0[4];
        FLOAT TexCrd1[4];
        FLOAT TexCrd2[4];

        if( !(m_pRD->m_ReferencedTexCoordMask & (1<<iStage) ) )
            continue;
        
        if (m_pRD->m_bPointSprite)
        {
            // set texture coords to map full range
            m_Attr[RDATTR_TEXTURE0+iStage].Setup( &g_PSTexCoord[0][0], 
                                                  &g_PSTexCoord[1][0], 
                                                  &g_PSTexCoord[2][0]);
        }
        else
        {
            // TCI pass through
            UINT CoordSet;
            if( m_pRD->m_bOverrideTCI )
            {
                CoordSet = iStage;
            }
            else
            {
                CoordSet = (UINT)m_pRD->GetTSS(iStage)[D3DTSS_TEXCOORDINDEX] & 0x0000FFFF;
            }

            for( UINT i=0; i<4; i++)
            {
                TexCrd0[i] = Vtx0.GetTexCrd( i, CoordSet );
                TexCrd1[i] = Vtx1.GetTexCrd( i, CoordSet );
                TexCrd2[i] = Vtx2.GetTexCrd( i, CoordSet );
            }
            
            if( m_pRD->GetTSS(iStage)[D3DTSS_TEXTURETRANSFORMFLAGS] & 
                D3DTTFF_PROJECTED )
            {
                // Always divide by the 4th coordinate while projecting.
                m_Attr[RDATTR_TEXTURE0+iStage].SetProjection(3);

                // For the projection, fix up the 4th coordinate
                // for the fixed function vertex-shaders.
                if( m_pRD->m_pCurrentVShader->IsFixedFunction() )
                {
                    TexCrd0[3] = Vtx0.GetLastTexCrd( CoordSet );
                    TexCrd1[3] = Vtx1.GetLastTexCrd( CoordSet );
                    TexCrd2[3] = Vtx2.GetLastTexCrd( CoordSet );
                }
            }
            else
            {
                m_Attr[RDATTR_TEXTURE0+iStage].SetProjection(0);
            }

            m_Attr[RDATTR_TEXTURE0+iStage].SetWrapFlags(
                m_pRD->GetRS()[D3DRS_WRAP0+CoordSet] );

            m_Attr[RDATTR_TEXTURE0+iStage].Setup( TexCrd0, TexCrd1, TexCrd2 );
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Triangle Drawing
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DrawTriangle - Takes three vertices and does triangle setup, setting the
// primitive, attribute, and edge structures which are input to the triangle
// scanner, then invokes the scan conversion.
//
// wFlags - Edge (and other) flags.
//
//-----------------------------------------------------------------------------

void
RefDev::DrawTriangle(
   RDVertex* pV0, RDVertex* pV1, RDVertex* pV2, WORD wFlags )
{
    if (m_pDbgMon) m_pDbgMon->NextEvent(D3DDM_EVENT_PRIMITIVE);
    UpdateRastState();

    // sort to ensure consistent attribute evaluation
    // for identical vertices passed in different order
    RDVertex* pV[3];
    {
        FLOAT fD0 = *(pV0->GetPtrXYZ()+0) + *(pV0->GetPtrXYZ()+1);
        FLOAT fD1 = *(pV1->GetPtrXYZ()+0) + *(pV1->GetPtrXYZ()+1);
        FLOAT fD2 = *(pV2->GetPtrXYZ()+0) + *(pV2->GetPtrXYZ()+1);
        UINT MinVtx = 0;
        if ( (fD1 < fD0) )                MinVtx = 1;
        if ( (fD2 < fD0) && (fD2 < fD1) ) MinVtx = 2;
        switch (MinVtx)
        {
        case 0: pV[0] = pV0; pV[1] = pV1; pV[2] = pV2; m_Rast.m_iFlatVtx = 0; break;
        case 1: pV[0] = pV1; pV[1] = pV2; pV[2] = pV0; m_Rast.m_iFlatVtx = 2; break;
        case 2: pV[0] = pV2; pV[1] = pV0; pV[2] = pV1; m_Rast.m_iFlatVtx = 1; break;
        }
    }

    if ( m_Rast.PerTriangleSetup(
          pV[0]->GetPtrXYZ(), pV[1]->GetPtrXYZ(), pV[2]->GetPtrXYZ(),
          m_dwRenderState[D3DRS_CULLMODE],
          &(m_pRenderTarget->m_Clip)) )
    {
        return; // discarded due to degenerate, cull, or no viewport overlap
    }

    // process point and wireframe fill mode
    if ( m_dwRenderState[D3DRS_FILLMODE] == D3DFILL_POINT )
    {
        if( m_dwRenderState[D3DRS_SHADEMODE] == D3DSHADE_FLAT )
        {
            // Colors from the first vertex are used for all vertices in flat
            // shading mode
            
            RDCOLOR4 diffuse1 = pV1->m_diffuse;
            RDCOLOR4 diffuse2 = pV2->m_diffuse;
            RDCOLOR4 specular1 = pV1->m_specular;
            RDCOLOR4 specular2 = pV2->m_specular;

            // Colors are modified in place
            pV1->m_diffuse  = pV0->m_diffuse;
            pV1->m_specular = pV0->m_specular;
            pV2->m_diffuse  = pV0->m_diffuse;
            pV2->m_specular = pV0->m_specular;

            DrawPoint( pV0 );
            DrawPoint( pV1 );
            DrawPoint( pV2 );

            // Restore old color values
            pV1->m_diffuse  = diffuse1;
            pV2->m_diffuse  = diffuse2;
            pV1->m_specular = specular1;
            pV2->m_specular = specular2;
        }
        else
        {
            DrawPoint( pV0 );
            DrawPoint( pV1 );
            DrawPoint( pV2 );
        }
        return;
    }
    else if ( m_dwRenderState[D3DRS_FILLMODE] == D3DFILL_WIREFRAME )
    {
        // use original vertex pointers for lines so edge enables line up
        if ( wFlags & D3DTRIFLAG_EDGEENABLE1 ) { DrawLine( pV0, pV1, pV0 ); }
        if ( wFlags & D3DTRIFLAG_EDGEENABLE2 ) { DrawLine( pV1, pV2, pV0 ); }
        if ( wFlags & D3DTRIFLAG_EDGEENABLE3 ) { DrawLine( pV2, pV0, pV0 ); }
        return;
    }

    // compute edge functions
    m_Rast.m_Edge[0].Set( m_Rast.m_iDet > 0,
        m_Rast.m_iX0, m_Rast.m_iY0, m_Rast.m_iX1, m_Rast.m_iY1 );
    m_Rast.m_Edge[1].Set( m_Rast.m_iDet > 0,
        m_Rast.m_iX1, m_Rast.m_iY1, m_Rast.m_iX2, m_Rast.m_iY2 );
    m_Rast.m_Edge[2].Set( m_Rast.m_iDet > 0,
        m_Rast.m_iX2, m_Rast.m_iY2, m_Rast.m_iX0, m_Rast.m_iY0 );

    // compute attribute functions
    m_Rast.SetAttributeFunctions( *pV[0], *pV[1], *pV[2] );

    // not culled, so rasterize it
    m_Rast.DoScanCnvTri(3);
}

///////////////////////////////////////////////////////////////////////////////
//
// Point Drawing
//
///////////////////////////////////////////////////////////////////////////////

void
RefDev::DrawPoint(
   RDVertex* pvV0Public )
{
    if (m_pDbgMon) m_pDbgMon->NextEvent(D3DDM_EVENT_PRIMITIVE);
    UpdateRastState();

    // copy pointsprite enable for duration of point rendering (only)
    m_bPointSprite = m_dwRenderState[D3DRS_POINTSPRITEENABLE];

    RDVertex V0, V1, V2;
    V0 = V1 = V2 = *pvV0Public;

    FLOAT fS = 1.0f;
    if (pvV0Public->m_qwFVF & D3DFVF_PSIZE)
    {
        fS = V0.GetPointSize();
    }
    else
    {
        fS = m_fRenderState[D3DRS_POINTSIZE];
    }
    fS = MAX( m_fRenderState[D3DRS_POINTSIZE_MIN], fS );
    fS = MIN( MIN(m_fRenderState[D3DRS_POINTSIZE_MAX], RD_MAX_POINT_SIZE), fS );

    // divide point size by 2 to get delta
    fS *= .5f;

    // Move points based on point size
    FLOAT *pXY = V0.GetPtrXYZ();
    FLOAT fX3 = pXY[0] + fS;
    FLOAT fY3 = pXY[1] + fS;
    pXY[0] += -fS;
    pXY[1] += -fS;

    pXY = V1.GetPtrXYZ();
    pXY[0] +=  fS;
    pXY[1] += -fS;

    pXY = V2.GetPtrXYZ();
    pXY[0] += -fS;
    pXY[1] +=  fS;


    if ( m_Rast.PerTriangleSetup(
          V0.GetPtrXYZ(), V1.GetPtrXYZ(), V2.GetPtrXYZ(),
          D3DCULL_NONE, // never cull points
          &(m_pRenderTarget->m_Clip)) )
    {
        m_bPointSprite = FALSE;
        return;
    }

    // compute edge functions
    INT32 iX3 = FloatToNdot4( fX3 );
    INT32 iY3 = FloatToNdot4( fY3 );
#define DP_POINT_UL  m_Rast.m_iX0, m_Rast.m_iY0 // upper left
#define DP_POINT_UR  m_Rast.m_iX1, m_Rast.m_iY1 // upper right
#define DP_POINT_LL  m_Rast.m_iX2, m_Rast.m_iY2 // lower left
#define DP_POINT_LR  iX3, iY3                       // lower right
    m_Rast.m_Edge[0].Set( m_Rast.m_iDet > 0, DP_POINT_UL, DP_POINT_UR );
    m_Rast.m_Edge[1].Set( m_Rast.m_iDet > 0, DP_POINT_UR, DP_POINT_LR );
    m_Rast.m_Edge[2].Set( m_Rast.m_iDet > 0, DP_POINT_LR, DP_POINT_LL );
    m_Rast.m_Edge[3].Set( m_Rast.m_iDet > 0, DP_POINT_LL, DP_POINT_UL );

    // compute attribute functions
    m_Rast.SetAttributeFunctions( V0, V1, V2 );

    // not culled, so rasterize it
    m_Rast.DoScanCnvTri(4);

    m_bPointSprite = FALSE;
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
// Line Drawing
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DrawLine - Takes two vertices and draws a line.
//
//-----------------------------------------------------------------------------
void
RefDev::DrawLine(
   RDVertex* pV0, RDVertex* pV1, RDVertex* pVFlat )
{
    if (m_pDbgMon) m_pDbgMon->NextEvent(D3DDM_EVENT_PRIMITIVE);
    UpdateRastState();

    if( m_Rast.m_SampleCount > 1 )
    {
        // if multisampling draw quad
        D3DVALUE Perp[2];
        RDVertex Quad[4];
        Perp[0] = pV1->m_pos.y - pV0->m_pos.y;
        Perp[1] = -(pV1->m_pos.x - pV0->m_pos.x);
        float Length = SQRTF(Perp[0]*Perp[0] + Perp[1]*Perp[1]);

        if( 0 == Length )
            return;

        float Scale = 0.7f / Length;    // 0.7 makes the line width 1.4. 
                                        // (arbitrary "nice looking" choice)
                                        // Dividing by Length to normalize perp. vector.
        Perp[0] *= Scale;
        Perp[1] *= Scale;

        Quad[0] = *pV0;
        Quad[0].m_pos.x -= Perp[0];
        Quad[0].m_pos.y -= Perp[1];

        Quad[1] = *pV0;
        Quad[1].m_pos.x += Perp[0];
        Quad[1].m_pos.y += Perp[1];

        Quad[2] = *pV1;
        Quad[2].m_pos.x += Perp[0];
        Quad[2].m_pos.y += Perp[1];

        Quad[3] = *pV1;
        Quad[3].m_pos.x -= Perp[0];
        Quad[3].m_pos.y -= Perp[1];

        DWORD dwCull = m_dwRenderState[D3DRS_CULLMODE];
        DWORD dwFill = m_dwRenderState[D3DRS_FILLMODE];
        m_dwRenderState[D3DRS_CULLMODE] = D3DCULL_NONE;
        m_dwRenderState[D3DRS_FILLMODE] = D3DFILL_SOLID;

        DrawTriangle(&Quad[0],&Quad[1],&Quad[2],0 );
        DrawTriangle(&Quad[0],&Quad[2],&Quad[3],0 );

        m_dwRenderState[D3DRS_CULLMODE] = dwCull;
        m_dwRenderState[D3DRS_FILLMODE] = dwFill;

        return;
    }

    if ( m_Rast.PerLineSetup(
          pV0->GetPtrXYZ(), pV1->GetPtrXYZ(),
          m_dwRenderState[D3DRS_LASTPIXEL],
          &(m_pRenderTarget->m_Clip)) )
    {
        return; // discarded due to degenerate or no viewport overlap
    }

    // compute attribute functions
    m_Rast.SetAttributeFunctions( *pV0, *pV1, pVFlat ? (*pVFlat) : (*pV0) );

    // rasterize it
    m_Rast.DoScanCnvLine();
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\sources.inc ===
TARGETNAME = refrast
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);..\..\drv

SOURCES = \
        ..\refrast.cpp\
        ..\setup.cpp\
        ..\rastprim.cpp\
        ..\rastattr.cpp\
        ..\rastedge.cpp\
        ..\scancnv.cpp\
        ..\texfilt.cpp\
        ..\ctexfilt.cpp\
        ..\texstage.cpp\
        ..\pixproc.cpp\
        ..\pshader.cpp\
        ..\psutil.cpp\
        ..\psexec.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\scancnv.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// scancnv.cpp
//
// Direct3D Reference Device - Primitive Scan Conversion
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Scan Conversion Utilities                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ComputeFogIntensity - Computes scalar fog intensity value and writes it to
// the RDPixel.FogIntensity value.
//
//-----------------------------------------------------------------------------
FLOAT
RefRast::ComputeFogIntensity( FLOAT fX, FLOAT fY )
{
    if ( !m_pRD->GetRS()[D3DRS_FOGENABLE] )
    {
        // fog blending not enabled, so don't need to compute fog intensity
        return 0.;
    }

    // compute fog intensity

    // select between vertex and table fog - vertex fog is selected if
    // fog is enabled but the renderstate fog table mode is disabled
    if ( D3DFOG_NONE == m_pRD->GetRS()[D3DRS_FOGTABLEMODE] )
    {
        // table fog disabled, so use interpolated vertex fog value for fog intensity
        FLOAT tmpFloat[4];
        m_Attr[RDATTR_FOG].Sample( tmpFloat, fX, fY );
        return tmpFloat[0];
    }

    // here for table fog, so compute fog from Z or W
    FLOAT fFogDensity, fPow;
    FLOAT fFogStart, fFogEnd;

    // select fog index - this is either Z or W depending on the W range
    //
    // use Z if projection matrix is set to an affine projection, else use W
    // (both for perspective projection and an unset projection matrix - the
    // latter is preferred for legacy content which uses TLVERTEX)
    //
    FLOAT fFogIndex =
        ( ( 1.f == m_pRD->m_pRenderTarget->m_fWRange[0] ) &&
          ( 1.f == m_pRD->m_pRenderTarget->m_fWRange[1] ) )
        ? ( m_Attr[RDATTR_DEPTH].Sample( fX, fY ) )
        : ( SampleAndInvertRHW( fX, fY ) ); // use W for non-affine projection
    FLOAT fFogIntensity;

    switch ( m_pRD->GetRS()[D3DRS_FOGTABLEMODE] )
    {
    case D3DFOG_LINEAR:
        fFogStart = m_pRD->GetRSf()[D3DRS_FOGSTART];
        fFogEnd   = m_pRD->GetRSf()[D3DRS_FOGEND];
        if (fFogIndex >= fFogEnd)
        {
            fFogIntensity = 0.0f;
        }
        else if (fFogIndex <= fFogStart)
        {
            fFogIntensity = 1.0f;
        }
        else
        {
            fFogIntensity = ( fFogEnd - fFogIndex ) / ( fFogEnd - fFogStart );
        }
        break;

    case D3DFOG_EXP:
        fFogDensity = m_pRD->GetRSf()[D3DRS_FOGDENSITY];
        fPow = fFogDensity * fFogIndex;
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        fFogIntensity = (float)exp( -fPow );
        break;

    case D3DFOG_EXP2:
        fFogDensity = m_pRD->GetRSf()[D3DRS_FOGDENSITY];
        fPow = fFogDensity * fFogIndex;
        fFogIntensity = (float)exp( -(fPow*fPow) );
        break;
    }
    return fFogIntensity;
}

//-----------------------------------------------------------------------------
//
// SnapDepth - Snap off extra depth bits by converting to/from buffer format
// - necessary to make depth buffer equality tests function correctly
//
//-----------------------------------------------------------------------------
void RefRast::SnapDepth()
{
    if (m_pRD->m_pRenderTarget->m_pDepth)
    {
        switch ( m_pRD->m_pRenderTarget->m_pDepth->GetSurfaceFormat() )
        {
        case RD_SF_Z16S0: m_Depth[m_iPix] = UINT16( m_Depth[m_iPix] ); break;
        case RD_SF_Z24X4S4:
        case RD_SF_Z24X8:
        case RD_SF_Z24S8: m_Depth[m_iPix] = UINT32( m_Depth[m_iPix] ); break;
        case RD_SF_Z15S1: m_Depth[m_iPix] = UINT16( m_Depth[m_iPix] ); break;
        case RD_SF_Z32S0: m_Depth[m_iPix] = UINT32( m_Depth[m_iPix] ); break;
        case RD_SF_S1Z15: m_Depth[m_iPix] = UINT16( m_Depth[m_iPix] ); break;
        case RD_SF_X4S4Z24:
        case RD_SF_X8Z24:
        case RD_SF_S8Z24: m_Depth[m_iPix] = UINT32( m_Depth[m_iPix] ); break;
        }
    }
}

//-----------------------------------------------------------------------------
//
// DoScanCnvGenPixel - This is called for each 2x2 grid of pixels, and extracts and
// processes attributes from the interpolator state, and passes the pixels on to
// the pixel processing module.
//
//-----------------------------------------------------------------------------
void
RefRast::DoScanCnvGenPixels( void )
{
    for ( m_iPix = 0; m_iPix < 4; m_iPix++ )
    {
        FLOAT fPixX = (FLOAT)m_iX[m_iPix];
        FLOAT fPixY = (FLOAT)m_iY[m_iPix];

        m_fW[m_iPix] = SampleAndInvertRHW( fPixX, fPixY );

        // RHW needed for non-in pixels, but nothing else so bail
        if ( !m_bPixelIn[m_iPix] ) continue;

        // get depth from clamp interpolator and clamp
        if ( m_pRD->GetRS()[D3DRS_ZENABLE] ||
             m_pRD->GetRS()[D3DRS_FOGENABLE])
        {
            if (m_pRD->m_pRenderTarget->m_pDepth)
                m_Depth[m_iPix].SetSType(m_pRD->m_pRenderTarget->m_pDepth->GetSurfaceFormat());

            // evaluate depth at all sample locations
            do
            {
                // compute sample location
                FLOAT fSampX = GetCurrentSamplefX(m_iPix);
                FLOAT fSampY = GetCurrentSamplefY(m_iPix);

                if ( D3DZB_USEW == m_pRD->GetRS()[D3DRS_ZENABLE] )
                {
                    // depth buffering with W value
                    FLOAT fW = SampleAndInvertRHW( fSampX, fSampY );
                    // apply normalization to get to 0. to 1. range
                    fW = (fW - m_pRD->m_fWBufferNorm[0]) * m_pRD->m_fWBufferNorm[1];
                    m_Depth[m_iPix] = fW;
                }
                else
                {
                    // depth buffering with Z value
                    m_Depth[m_iPix] =
                        m_Attr[RDATTR_DEPTH].Sample( fSampX, fSampY );
                }

                // snap off extra bits by converting to/from buffer format - necessary
                // to make depth buffer equality tests function correctly
                SnapDepth();

                m_SampleDepth[m_CurrentSample][m_iPix] = m_Depth[m_iPix];

            } while (NextSample());
        }

        // set pixel diffuse and specular color from clamped interpolator values
        m_Attr[RDATTR_COLOR].Sample( m_InputReg[0][m_iPix], fPixX, fPixY );
        m_Attr[RDATTR_SPECULAR].Sample( m_InputReg[1][m_iPix], fPixX, fPixY );

        // compute fog intensity
        m_FogIntensity[m_iPix] = ComputeFogIntensity( fPixX, fPixY );

    }
    DoPixels();
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Triangle Scan Conversion                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DoScanCnvTri - Scans the bounding box of the triangle and generates pixels.
//
// Does 4 pixels at a time in a 2x2 grid.
//
//-----------------------------------------------------------------------------
void
RefRast::DoScanCnvTri( int iEdgeCount )
{
    m_iEdgeCount = iEdgeCount;

    //
    // do simple scan of surface-intersected triangle bounding box
    //
    for ( m_iY[0] = m_iYMin;
          m_iY[0] <= m_iYMax;
          m_iY[0] += 2 )
    {
        m_iY[1] = m_iY[0]+0;
        m_iY[2] = m_iY[0]+1;
        m_iY[3] = m_iY[0]+1;
        BOOL bPartialY = (m_iY[3] > m_iYMax);

        for ( m_iX[0] = m_iXMin;
              m_iX[0] <= m_iXMax;
              m_iX[0] += 2 )
        {
            m_iX[1] = m_iX[0]+1;
            m_iX[2] = m_iX[0]+0;
            m_iX[3] = m_iX[0]+1;
            BOOL bPartialX = (m_iX[3] > m_iXMax);

            m_bPixelIn[0] = EvalPixelPosition(0);
            m_bPixelIn[1] = ( bPartialX ) ? ( FALSE ) : EvalPixelPosition(1);
            m_bPixelIn[2] = ( bPartialY ) ? ( FALSE ) : EvalPixelPosition(2);
            m_bPixelIn[3] = ( bPartialX || bPartialY ) ? ( FALSE ) : EvalPixelPosition(3);

            if ( m_bPixelIn[0] ||
                 m_bPixelIn[1] ||
                 m_bPixelIn[2] ||
                 m_bPixelIn[3] )
            {
                // at least one pixel in
                DoScanCnvGenPixels();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line Scan Conversion                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.  Always returns true if wRepeatFactor is 0, which
// means pattern is disabled.
//
//----------------------------------------------------------------------------

// NOTE: The implementation of LinePattern in RefDev is incorrect. Please refer 
//       to the DDK documentation for the right implementation.
static BOOL
LinePatternStateMachine(DWORD dwLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    union
    {
        D3DLINEPATTERN LPat;
        DWORD dwLPat;
    } LinePat;
    LinePat.dwLPat = dwLinePattern;

    if (LinePat.LPat.wRepeatFactor)
    {
        WORD wBit = (LinePat.LPat.wLinePattern >> wPatterni) & 1;
        if (++wRepeati >= LinePat.LPat.wRepeatFactor)
        {
            wRepeati = 0;
            wPatterni = (wPatterni+1) & 0xf;
        }
        return (BOOL)wBit;
    }
    else
    {
        return TRUE;
    }
}

//-----------------------------------------------------------------------------
//
// DoScanCnvLine - Walks the line major axis, computes the appropriate minor
// axis coordinate, and generates pixels.
//
//-----------------------------------------------------------------------------
void
RefRast::DoScanCnvLine( void )
{
    // state for line pattern state machine
    WORD wRepeati = 0;
    WORD wPatterni = 0;

    m_bPixelIn[0] = TRUE;
    m_bPixelIn[1] =
    m_bPixelIn[2] =
    m_bPixelIn[3] = FALSE;

    for ( int cStep = 0; cStep <= m_cLineSteps; cStep++ )
    {
        // compute next x,y location in line
        StepLine();

//        if (m_pDbgMon->ScreenMask(m_iX[0], m_iY[0]))
//            continue;

        // check if the point is inside the viewport
        if ( ( m_iX[0] >= m_pRD->m_pRenderTarget->m_Clip.left   ) &&
             ( m_iX[0] <= m_pRD->m_pRenderTarget->m_Clip.right  ) &&
             ( m_iY[0] >= m_pRD->m_pRenderTarget->m_Clip.top    ) &&
             ( m_iY[0] <= m_pRD->m_pRenderTarget->m_Clip.bottom ) )
        {
            // The line pattern should have been walked in from its origin, which may have been
            // offscreen, to be completely correct.
            if (LinePatternStateMachine(m_pRD->GetRS()[D3DRS_LINEPATTERN], wRepeati, wPatterni))
            {
                DoScanCnvGenPixels();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\texfilt.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// texfilt.cpp
//
// Direct3D Reference Device - Texture Map Filtering Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

void
RefRast::UpdateTextureControls( void )
{
    for (int iStage=0; iStage<m_pRD->m_cActiveTextureStages; iStage++)
    {
        // check for requirement to do level-of-detail (coverage) computation - either
        // for mipmap or per-pixel filter selection
        BOOL bComputeLOD =
            ( m_pRD->GetTSS(iStage)[D3DTSS_MIPFILTER] == D3DTEXF_POINT ) ||
            ( m_pRD->GetTSS(iStage)[D3DTSS_MIPFILTER] == D3DTEXF_LINEAR ) ||
            ( m_pRD->GetTSS(iStage)[D3DTSS_MAGFILTER] != m_pRD->GetTSS(iStage)[D3DTSS_MINFILTER] );

        // check for anisotropic filtering in either mag filter or in min filter
        BOOL bDoAniso =
            ( D3DTEXF_ANISOTROPIC == m_pRD->GetTSS(iStage)[D3DTSS_MAGFILTER] ) ||
            ( bComputeLOD && (D3DTEXF_ANISOTROPIC == m_pRD->GetTSS(iStage)[D3DTSS_MINFILTER]) );

        // compute filter type for coverage computation
        if (bDoAniso)           m_TexFlt[iStage].CvgFilter = D3DTEXF_ANISOTROPIC;
        else if (bComputeLOD)   m_TexFlt[iStage].CvgFilter = D3DTEXF_LINEAR;
        else                    m_TexFlt[iStage].CvgFilter = D3DTEXF_NONE;

        // compute filter type for magnify (also used for non-LOD case)
        switch ( m_pRD->GetTSS(iStage)[D3DTSS_MAGFILTER] )
        {
        default:
        case D3DTEXF_POINT:         m_TexFlt[iStage].MagFilter = D3DTEXF_POINT; break;
        case D3DTEXF_FLATCUBIC:
        case D3DTEXF_GAUSSIANCUBIC:
        case D3DTEXF_LINEAR:        m_TexFlt[iStage].MagFilter = D3DTEXF_LINEAR; break;
        case D3DTEXF_ANISOTROPIC:   m_TexFlt[iStage].MagFilter = D3DTEXF_ANISOTROPIC; break;
        }

        // compute filter type(s) for minify
        switch ( m_pRD->GetTSS(iStage)[D3DTSS_MINFILTER] )
        {
        default:
        case D3DTEXF_POINT:         m_TexFlt[iStage].MinFilter = D3DTEXF_POINT;  break;
        case D3DTEXF_LINEAR:        m_TexFlt[iStage].MinFilter = D3DTEXF_LINEAR; break;
        case D3DTEXF_ANISOTROPIC:   m_TexFlt[iStage].MinFilter = D3DTEXF_ANISOTROPIC;  break;
        }

        switch ( m_pRD->GetTSS(iStage)[D3DTSS_MIPFILTER] )
        {
        default:
        case D3DTEXF_NONE:          m_TexFlt[iStage].MipFilter = D3DTEXF_NONE; break;
        case D3DTEXF_POINT:         m_TexFlt[iStage].MipFilter = D3DTEXF_POINT; break;
        case D3DTEXF_LINEAR:        m_TexFlt[iStage].MipFilter = D3DTEXF_LINEAR; break;
        }

        // set default state
        m_TexCvg[iStage].fLOD = 0.f;
        m_TexCvg[iStage].iLOD = 0;
        m_TexCvg[iStage].iLODMap[0] = 0;
        m_TexCvg[iStage].iLODMap[1] = 0;
        m_TexCvg[iStage].fLODFrc[0] = 1.f;
        m_TexCvg[iStage].fLODFrc[1] = 1.f;
        m_TexCvg[iStage].bMagnify = FALSE;
        m_TexCvg[iStage].cLOD = 1;
    }
}

//
// called once per each set of 2x2 samples
//
void
RefRast::ComputeTextureCoverage( int iStage, FLOAT (*fGradients)[2] )
{
    if ( !m_pRD->m_pTexture[iStage] ) return;
    if ( m_pRD->m_pTexture[iStage]->m_uFlags & RR_TEXTURE_CUBEMAP )
    {
        // store gradients for cubemaps
        memcpy( m_TexCvg[iStage].fGradients, fGradients, 3*2*sizeof(FLOAT) );
        return;
    }

    if ( D3DTEXF_NONE == m_TexFlt[iStage].CvgFilter ) return;

    // scale gradients to texture LOD 0 size
    for (int iD=0; iD < m_pRD->m_pTexture[iStage]->m_cDimension; iD++ )
    {
        fGradients[iD][0] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][iD];
        fGradients[iD][1] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][iD];
    }

    if ( (m_TexFlt[iStage].CvgFilter == D3DTEXF_ANISOTROPIC) &&
         (m_pRD->m_pTexture[iStage]->m_cDimension == 2) ) // do aniso for 2D textures only
    {
        ComputeAnisoCoverage( fGradients, MIN( 16.f, (FLOAT)m_pRD->GetTSS(iStage)[D3DTSS_MAXANISOTROPY]),
            m_TexCvg[iStage].fLOD, m_TexCvg[iStage].fAnisoRatio, m_TexCvg[iStage].fAnisoLine );
    }
    else
    {
        ComputeMipCoverage( fGradients, m_TexCvg[iStage].fLOD, m_pRD->m_pTexture[iStage]->m_cDimension );
        m_TexCvg[iStage].fAnisoRatio = 1.f;
    }

    ComputePerLODControls( iStage );
}

//
// called by ComputeTextureCoverage and ComputeCubeTextureFilter
//
void
RefRast::ComputePerLODControls( int iStage )
{
    m_TexCvg[iStage].fLOD += m_pRD->GetTSSf(iStage)[D3DTSS_MIPMAPLODBIAS];
    m_TexCvg[iStage].iLOD = AS_INT16( m_TexCvg[iStage].fLOD + FLOAT_5_SNAP );
    m_TexCvg[iStage].bMagnify = (m_TexCvg[iStage].iLOD <= 0);

    m_TexCvg[iStage].cLOD = 1;
    m_TexCvg[iStage].fLODFrc[0] = 1.f;
    if ( m_TexCvg[iStage].bMagnify || ( m_TexFlt[iStage].MipFilter == D3DTEXF_NONE ) )
    {
        m_TexCvg[iStage].iLODMap[0] = 0;
        // clamp to max LOD
        m_TexCvg[iStage].iLODMap[0] = MAX( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        // clamp to available maps
        m_TexCvg[iStage].iLODMap[0] = MIN( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );
    }
    else if ( m_TexFlt[iStage].MipFilter == D3DTEXF_POINT )
    {
        // round and truncate (add .5 and shift off fractional bits)
        m_TexCvg[iStage].iLODMap[0] = (m_TexCvg[iStage].iLOD + (1<<(RRTEX_LODFRAC-1))) >> RRTEX_LODFRAC;
        // clamp to max LOD
        m_TexCvg[iStage].iLODMap[0] = MAX( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        // clamp to available maps
        m_TexCvg[iStage].iLODMap[0] = MIN( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );
    }
    else // mip filter D3DTEXF_LINEAR
    {
        // compute index for two adjacent LODs
        m_TexCvg[iStage].iLODMap[0] = m_TexCvg[iStage].iLOD >> RRTEX_LODFRAC;  // floor
        m_TexCvg[iStage].iLODMap[1] = m_TexCvg[iStage].iLODMap[0] + 1;
        // clamp to max LOD
        m_TexCvg[iStage].iLODMap[0] = MAX( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        m_TexCvg[iStage].iLODMap[1] = MAX( m_TexCvg[iStage].iLODMap[1], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        // clamp to available maps
        m_TexCvg[iStage].iLODMap[0] = MIN( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );
        m_TexCvg[iStage].iLODMap[1] = MIN( m_TexCvg[iStage].iLODMap[1], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );

        // check that both maps actually contribute to texel
        if ( (m_TexCvg[iStage].iLODMap[0] != m_TexCvg[iStage].iLODMap[1]) &&
             (m_TexCvg[iStage].iLOD & RRTEX_LODFRACMASK) )
        {
            m_TexCvg[iStage].fLODFrc[1]  = (FLOAT)(m_TexCvg[iStage].iLOD & RRTEX_LODFRACMASK) * RRTEX_LODFRACF;
            m_TexCvg[iStage].fLODFrc[0] = 1.f - m_TexCvg[iStage].fLODFrc[1];
            m_TexCvg[iStage].cLOD = 2;
        }
    }
}

void
RefRast::ComputePointSampleCoords(
    int iStage, INT32 iLOD, FLOAT fCrd[],
    INT32 iCrd[] )
{
    for (int iD=0; iD<m_pRD->m_pTexture[iStage]->m_cDimension; iD++)
    {
        FLOAT fScaledCrd =
            ( fCrd[iD] * m_pRD->m_pTexture[iStage]->m_fTexels[iLOD][iD] ) - .5f;
        // truncate to -infinity to be compatible with ANDing off low order
        // bits of a fixed point fScaledCoord.  This makes the generation of
        // iCoord more hardware like, and does not make a glitch at 0 for
        // a wrapped texture.
        if ( fCrd[iD] >= 0.f ) iCrd[iD] = (INT32)( fScaledCrd + .5f );
        else                   iCrd[iD] = (INT32)( fScaledCrd - .5f );
    }
}

void
RefRast::ComputeLinearSampleCoords(
    int iStage, INT32 iLOD, FLOAT fCrd[],
    INT32 iCrdFlr[], INT32 iCrdClg[], FLOAT fCrdFrcF[], FLOAT fCrdFrcC[]  )
{
    for (int iD=0; iD<m_pRD->m_pTexture[iStage]->m_cDimension; iD++)
    {
        FLOAT fScaledCrd =
            ( fCrd[iD] * m_pRD->m_pTexture[iStage]->m_fTexels[iLOD][iD] ) - .5f;
        INT32 iCrd = FloatToNdot5(fScaledCrd);
        iCrdFlr[iD] = iCrd >> RRTEX_MAPFRAC;
        iCrdClg[iD] = iCrdFlr[iD] + 1;
        fCrdFrcC[iD] = (FLOAT)(iCrd & RRTEX_MAPFRACMASK) * RRTEX_MAPFRACF;
        fCrdFrcF[iD] = 1.f - fCrdFrcC[iD];
    }
}

void
RefRast::SetUp1DTextureSample(
    int iStage, int Start,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 iCrdF, INT32 iCrdC,
    FLOAT fCrdFrcF, FLOAT fCrdFrcC )
{
    m_TexFlt[iStage].pSamples[Start+0].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+1].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+0].iCrd[0] = iCrdF;
    m_TexFlt[iStage].pSamples[Start+1].iCrd[0] = iCrdC;
    m_TexFlt[iStage].pSamples[Start+0].fWgt = fCrdFrcF*fLODScale;
    m_TexFlt[iStage].pSamples[Start+1].fWgt = fCrdFrcC*fLODScale;
}

#define _Set2( _DstAr, _Src0, _Src1 ) \
    _DstAr[0] = _Src0; _DstAr[1] = _Src1;

void
RefRast::SetUp2DTextureSample(
    int iStage, int Start,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 iCrdF[], INT32 iCrdC[],
    FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] )
{
    m_TexFlt[iStage].pSamples[Start+0].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+1].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+2].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+3].iLOD = iLODMap;
    _Set2( m_TexFlt[iStage].pSamples[Start+0].iCrd, iCrdF[0], iCrdF[1] )
    _Set2( m_TexFlt[iStage].pSamples[Start+1].iCrd, iCrdC[0], iCrdF[1] )
    _Set2( m_TexFlt[iStage].pSamples[Start+2].iCrd, iCrdC[0], iCrdC[1] )
    _Set2( m_TexFlt[iStage].pSamples[Start+3].iCrd, iCrdF[0], iCrdC[1] )
    m_TexFlt[iStage].pSamples[Start+0].fWgt = fCrdFrcF[0] * fCrdFrcF[1] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+1].fWgt = fCrdFrcC[0] * fCrdFrcF[1] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+2].fWgt = fCrdFrcC[0] * fCrdFrcC[1] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+3].fWgt = fCrdFrcF[0] * fCrdFrcC[1] * fLODScale;
}

#define _Set3( _DstAr, _Src0, _Src1, _Src2 ) \
    _DstAr[0] = _Src0; _DstAr[1] = _Src1; _DstAr[2] = _Src2;

void
RefRast::SetUp3DTextureSample(
    int iStage, int Start,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 iCrdF[], INT32 iCrdC[],
    FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] )
{
    m_TexFlt[iStage].pSamples[Start+0].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+1].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+2].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+3].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+4].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+5].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+6].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+7].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+0].fWgt = fCrdFrcF[0] * fCrdFrcF[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+1].fWgt = fCrdFrcC[0] * fCrdFrcF[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+2].fWgt = fCrdFrcC[0] * fCrdFrcC[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+3].fWgt = fCrdFrcF[0] * fCrdFrcC[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+4].fWgt = fCrdFrcF[0] * fCrdFrcF[1] * fCrdFrcC[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+5].fWgt = fCrdFrcC[0] * fCrdFrcF[1] * fCrdFrcC[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+6].fWgt = fCrdFrcC[0] * fCrdFrcC[1] * fCrdFrcC[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+7].fWgt = fCrdFrcF[0] * fCrdFrcC[1] * fCrdFrcC[2] * fLODScale;
    _Set3( m_TexFlt[iStage].pSamples[Start+0].iCrd, iCrdF[0], iCrdF[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+1].iCrd, iCrdC[0], iCrdF[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+2].iCrd, iCrdC[0], iCrdC[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+3].iCrd, iCrdF[0], iCrdC[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+4].iCrd, iCrdF[0], iCrdF[1], iCrdC[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+5].iCrd, iCrdC[0], iCrdF[1], iCrdC[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+6].iCrd, iCrdC[0], iCrdC[1], iCrdC[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+7].iCrd, iCrdF[0], iCrdC[1], iCrdC[2] )
}

//
// called once for each pixel
//
void
RefRast::ComputeTextureFilter( int iStage, FLOAT fCrd[] )
{
    m_TexFlt[iStage].cSamples = 0;
    if ( !m_pRD->m_pTexture[iStage] ) return;

    if ( m_pRD->m_pTexture[iStage]->m_uFlags & RR_TEXTURE_CUBEMAP )
    {
        ComputeCubeTextureFilter( iStage, fCrd );
        return;
    }
    // here for 1,2,3D texture
    int iL,iD;
#define _PerDimension(_Par) for (_Par=0;_Par<m_pRD->m_pTexture[iStage]->m_cDimension;_Par++)
    D3DTEXTUREFILTERTYPE Filter =
        m_TexCvg[iStage].bMagnify ? m_TexFlt[iStage].MagFilter : m_TexFlt[iStage].MinFilter;
    switch ( Filter )
    {
    default:
    case D3DTEXF_POINT:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples].iLOD = m_TexCvg[iStage].iLODMap[iL];
            m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples].fWgt = m_TexCvg[iStage].fLODFrc[iL];
            ComputePointSampleCoords( iStage, m_TexCvg[iStage].iLODMap[iL], fCrd,
                m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples].iCrd );
            m_TexFlt[iStage].cSamples++;
        }
        break;

    case D3DTEXF_LINEAR:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            INT32 iCrdFlr[3], iCrdClg[3];
            FLOAT fCrdFrcF[3], fCrdFrcC[3];
            ComputeLinearSampleCoords(
                iStage, m_TexCvg[iStage].iLODMap[iL], fCrd,
                iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
            switch ( m_pRD->m_pTexture[iStage]->m_cDimension )
            {
            default:
            case 1:
                SetUp1DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], m_TexCvg[iStage].fLODFrc[iL],
                    iCrdFlr[0], iCrdClg[0], fCrdFrcF[0], fCrdFrcC[0] );
                m_TexFlt[iStage].cSamples += 2;
                break;
            case 2:
                SetUp2DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], m_TexCvg[iStage].fLODFrc[iL],
                    iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                m_TexFlt[iStage].cSamples += 4;
                break;
            case 3:
                SetUp3DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], m_TexCvg[iStage].fLODFrc[iL],
                    iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                m_TexFlt[iStage].cSamples += 8;
                break;
            }
        }
        break;

    case D3DTEXF_ANISOTROPIC:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            FLOAT fStepScale[3];
            fStepScale[0] = 1.f/m_pRD->m_pTexture[iStage]->m_fTexels[m_TexCvg[iStage].iLODMap[iL]][0];
            fStepScale[1] = 1.f/m_pRD->m_pTexture[iStage]->m_fTexels[m_TexCvg[iStage].iLODMap[iL]][1];
            fStepScale[2] = 0.f;

            FLOAT fUnitStep[3];
            _PerDimension(iD) { fUnitStep[iD] = fStepScale[iD]*m_TexCvg[iStage].fAnisoLine[iD]; }

            int cAnisoSamples;
            FLOAT fACrd[16][3];
            FLOAT fAScale[16];
            if ( m_TexCvg[iStage].fAnisoRatio <= 1.f )
            {
                // just like mip D3DTEXF_LINEAR
                cAnisoSamples = 1; fAScale[0] = 1.f;
                _PerDimension(iD) { fACrd[0][iD] = fCrd[iD]; }
            }
            else if ( m_TexCvg[iStage].fAnisoRatio <= 2.f )
            {
                // take two sets of samples and average
                cAnisoSamples = 2; fAScale[0] = fAScale[1] = .5f;
                FLOAT fStepSize = .5f*(m_TexCvg[iStage].fAnisoRatio - 1.f);
                _PerDimension(iD)
                {
                    FLOAT fStep = fStepSize*fUnitStep[iD];
                    fACrd[0][iD] = fCrd[iD] + fStep;
                    fACrd[1][iD] = fCrd[iD] - fStep;
                }
            }
            else
            {
                // walk line of anisotropy in both directions from center point
                FLOAT fInvRatio = 1.f/m_TexCvg[iStage].fAnisoRatio;
                FLOAT fRatioRemainder = m_TexCvg[iStage].fAnisoRatio;
                // start steps centered 1/2 away
                _PerDimension(iD)
                {
                    fACrd[0][iD] = fCrd[iD] + fUnitStep[iD]*.5f;
                    fACrd[1][iD] = fCrd[iD] - fUnitStep[iD]*.5f;
                }
                cAnisoSamples = 0;
                do
                {
                    fAScale[cAnisoSamples+0] = fInvRatio;
                    fAScale[cAnisoSamples+1] = fInvRatio;
                    if ( fRatioRemainder < 2.f )
                    {
                        fAScale[cAnisoSamples+0] *= .5f*fRatioRemainder;
                        fAScale[cAnisoSamples+1] *= .5f*fRatioRemainder;
                    }
                    if ( fRatioRemainder > 2.f )
                    {
                        _PerDimension(iD)
                        {
                            fACrd[cAnisoSamples+2][iD] = fACrd[cAnisoSamples+0][iD] + fUnitStep[iD];
                            fACrd[cAnisoSamples+3][iD] = fACrd[cAnisoSamples+1][iD] - fUnitStep[iD];
                        }
                    }
                    cAnisoSamples += 2;
                    fRatioRemainder -= 2.f;
                }
                while ( fRatioRemainder > 0.f );
            }
            for ( int iS = 0; iS < cAnisoSamples; iS ++ )
            {
                INT32 iCrdFlr[3], iCrdClg[3];
                FLOAT fCrdFrcF[3], fCrdFrcC[3];
                ComputeLinearSampleCoords(
                    iStage, m_TexCvg[iStage].iLODMap[iL], fACrd[iS],
                    iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                FLOAT fSampleScale = fAScale[iS]*m_TexCvg[iStage].fLODFrc[iL];
                switch ( m_pRD->m_pTexture[iStage]->m_cDimension )
                {
                default:
                case 1:
                    SetUp1DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], fSampleScale,
                        iCrdFlr[0], iCrdClg[0], fCrdFrcF[0], fCrdFrcC[0] );
                    m_TexFlt[iStage].cSamples += 2;
                    break;
                case 2:
                    SetUp2DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], fSampleScale,
                        iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                    m_TexFlt[iStage].cSamples += 4;
                    break;
                case 3:
                    SetUp3DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], fSampleScale,
                        iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                    m_TexFlt[iStage].cSamples += 8;
                    break;
                }
            }
        }
        break;
    }
}

const DWORD g_D3DTSS_ADDRESS_MAP[3] = { D3DTSS_ADDRESSU, D3DTSS_ADDRESSV, D3DTSS_ADDRESSW };

void
RefRast::SampleTexture( INT32 iStage, FLOAT fCol[] )
{
    if ( m_pRD->m_pTexture[iStage] == NULL )
    {
        // return opaque black if no texture bound
        fCol[0] = fCol[1] = fCol[2] = 0.f;
        fCol[3] = 1.f;
        return;
    }
    fCol[0] = fCol[1] = fCol[2] = fCol[3] = 0.f;
    TextureSample* pS = m_TexFlt[iStage].pSamples;
    RDSurface2D* pTex = m_pRD->m_pTexture[iStage];
    for (int iS = 0; iS < m_TexFlt[iStage].cSamples; iS++, pS++ )
    {
        if ( pS->fWgt )
        {
            BOOL bUseBorder = FALSE;
            for (int iD=0; iD < pTex->m_cDimension; iD++)
            {
                INT32 iCrdMax = (pTex->m_cTexels[pS->iLOD][iD] - 1);
                if ( ( pS->iCrd[iD] < 0) || ( pS->iCrd[iD] > iCrdMax ) )
                {
                    switch ( m_pRD->GetTSS(iStage)[g_D3DTSS_ADDRESS_MAP[iD]] )
                    {
                    case D3DTADDRESS_WRAP:
                        // Pow-2 texture:                        
                        // pS->iCrd[iD] = pS->iCrd[iD] & iCrdMax;

                        // Non-Pow-2 texture:
                        pS->iCrd[iD] %= (iCrdMax + 1);
                        if( pS->iCrd[iD] < 0 )
                            pS->iCrd[iD] = iCrdMax + 1 + pS->iCrd[iD];
                        break;
                    case D3DTADDRESS_MIRROR:
                        // Pow-2 texture:
                        // lop off non-fractional bits + flip index if LSB (non-fraction) is set
                        // BOOL bFlip; bFlip = pS->iCrd[iD] & (iCrdMax+1);
                        // pS->iCrd[iD] &= iCrdMax; 
                        // if (bFlip) { pS->iCrd[iD] = iCrdMax - pS->iCrd[iD]; }

                        // Non-Pow-2 texture:
                        if( pS->iCrd[iD] < 0 )
                            pS->iCrd[iD] = -pS->iCrd[iD] - 1;
                        BOOL bFlip; bFlip = ((pS->iCrd[iD]/(iCrdMax + 1)) & 1);
                        pS->iCrd[iD] %= (iCrdMax + 1);
                        if( bFlip ) pS->iCrd[iD] = iCrdMax - pS->iCrd[iD];

                        break;
                    case D3DTADDRESS_BORDER:
                        bUseBorder = TRUE;
                        break;
                    case D3DTADDRESS_MIRRORONCE:
                        if ( pS->iCrd[iD] < 0 )  pS->iCrd[iD] = (-pS->iCrd[iD]) - 1;
                        // fall through to clamp for outside of -1 to +1 range
                    case D3DTADDRESS_CLAMP:
                        pS->iCrd[iD] = MAX( 0, MIN( pS->iCrd[iD], iCrdMax ) );
                        break;
                    }
                }
            }
            RDColor Texel;
            (bUseBorder)
                ? Texel = m_pRD->GetTSS(iStage)[D3DTSS_BORDERCOLOR]
                : pTex->ReadColor(
                    pS->iCrd[0], pS->iCrd[1], pS->iCrd[2], pS->iLOD,
                    Texel, m_bPixelDiscard[m_iPix] );

            fCol[0] += ( Texel.R * pS->fWgt );
            fCol[1] += ( Texel.G * pS->fWgt );
            fCol[2] += ( Texel.B * pS->fWgt );
            fCol[3] += ( Texel.A * pS->fWgt );
        }
    }
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for standard trilinear mipmapping, in which
// the four texture index gradients are consolidated into a single number
// to select level of detail.
//
// The basic approach is to compute the lengths of the pixel coverage for
// the per-dimensional extent of the approximate pixel coverage area.  The
// max of lengths are used for the single LOD result.
//
//-----------------------------------------------------------------------------
void
ComputeMipCoverage( const FLOAT (*fGradients)[2], FLOAT& fLOD, int cDim )
{
    // compute length of coverage in each dimension
    FLOAT fLen[2];
    switch (cDim)
    {
    default:
    case 1:  fLOD = 0.f; return;
    case 2:
        fLen[0] = RR_LENGTH( fGradients[0][0], fGradients[1][0] );
        fLen[1] = RR_LENGTH( fGradients[0][1], fGradients[1][1] );
        break;
    case 3:
        fLen[0] = RR_SQRT(
            (fGradients[0][0]*fGradients[0][0]) +
            (fGradients[1][0]*fGradients[1][0]) +
            (fGradients[2][0]*fGradients[2][0]) );
        fLen[1] = RR_SQRT(
            (fGradients[0][1]*fGradients[0][1]) +
            (fGradients[1][1]*fGradients[1][1]) +
            (fGradients[2][1]*fGradients[2][1]) );
        break;
    }

    // take the MAX for the coverage
    FLOAT fCoverage = MAX( fLen[0], fLen[1] );

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}

//-----------------------------------------------------------------------------
//
// Computes level of detail and other factors in preparation for anisotropic
// filtering.  This is for 2D texture maps only.
//
//-----------------------------------------------------------------------------
void
ComputeAnisoCoverage(
    const FLOAT (*fGradients)[2], FLOAT fMaxAniso, // inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] )   // outputs
{
    // compute axis lengths and determinant
    FLOAT fLenX2 = (fGradients[0][0]*fGradients[0][0])+(fGradients[1][0]*fGradients[1][0]);
    FLOAT fLenY2 = (fGradients[0][1]*fGradients[0][1])+(fGradients[1][1]*fGradients[1][1]);
    FLOAT fDet = RR_ABSF((fGradients[0][0]*fGradients[1][1])-(fGradients[0][1]*fGradients[1][0]));

    // select major axis
    BOOL bXMajor = (fLenX2 > fLenY2);

    // select and normalize steps; compute aniso ratio
    FLOAT fMaj2 = (bXMajor) ? (fLenX2) : (fLenY2);
    FLOAT fMaj = RR_SQRT(fMaj2);
    FLOAT fMajNorm = 1./fMaj;
    fDelta[0] = ( bXMajor ? fGradients[0][0] : fGradients[0][1] ) * fMajNorm;
    fDelta[1] = ( bXMajor ? fGradients[1][0] : fGradients[1][1] ) * fMajNorm;
    if( !FLOAT_EQZ(fDet) )
        fRatio = fMaj2/fDet;
    else
        fRatio = FLT_MAX;

    // clamp ratio and compute LOD
    FLOAT fMin;
    if ( fRatio > fMaxAniso )
    {
        // ratio is clamped - LOD is based on ratio (preserves area)
        fRatio = fMaxAniso;
        fMin = fMaj/fRatio;
    }
    else
    {
        // ratio not clamped - LOD is based on area
        fMin = fDet/fMaj;
    }

    // clamp to top LOD
    if (fMin < 1.0)
    {
        fRatio = MAX( 1.0, fRatio*fMin );
        fMin = 1.0;
    }

    // take log2 of minor for LOD
    fLOD = RR_LOG2(fMin);
}

// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\rast\texstage.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// texstage.cpp
//
// Direct3D Reference Device - Texture Processing Stage Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// ComputeTextureBlendArg - Computes texture argument for blending, using the
// specified argument control (D3DTA_* fields).  This is called 4 times per
// texture processing stage: 2 arguments for color and 2 arguments for alpha.
//
//-----------------------------------------------------------------------------
void
RefRast::ComputeTextureBlendArg(
    DWORD dwArgCtl, BOOL bAlphaOnly,
    const RDColor& DiffuseColor,
    const RDColor& SpecularColor,
    const RDColor& CurrentColor,
    const RDColor& TextureColor,
    const RDColor& TempColor,
    RDColor& BlendArg)
{
    // argument MUX
    switch ( dwArgCtl & D3DTA_SELECTMASK )
    {
    case D3DTA_DIFFUSE:  BlendArg = DiffuseColor; break;
    case D3DTA_CURRENT:  BlendArg = CurrentColor; break;
    case D3DTA_SPECULAR: BlendArg = SpecularColor; break;
    case D3DTA_TEXTURE:  BlendArg = TextureColor; break;
    case D3DTA_TFACTOR:
        BlendArg = m_pRD->GetRS()[D3DRS_TEXTUREFACTOR]; break;
    case D3DTA_TEMP:     BlendArg = TempColor; break;
    }

    // take compliment of all channels
    if ( dwArgCtl & D3DTA_COMPLEMENT )
    {
        BlendArg.A = 1.f - BlendArg.A;
        if ( !bAlphaOnly )
        {
            BlendArg.R = ( 1.f - BlendArg.R );
            BlendArg.G = ( 1.f - BlendArg.G );
            BlendArg.B = ( 1.f - BlendArg.B );
        }
    }

    // replicate alpha to color (after compliment)
    if ( !bAlphaOnly && ( dwArgCtl & D3DTA_ALPHAREPLICATE ) )
    {
        BlendArg.R =
        BlendArg.G =
        BlendArg.B = BlendArg.A;
    }
}

//-----------------------------------------------------------------------------
//
// DoTextureBlendStage - Does texture blend for one texture processing stage,
// combining results from the texture processing with the interpolated color(s)
// and previous stage's color.
//
// Note: All color channel multiplies should be done in such a way that a unit
// value on one side passes the value on the other side.  Thus for 8 bit color
// channels, '0xff * value' should return value, and 0xff * 0xff = 0xff,
// not 0xfe(01).
//
// RDColorChannel performs these operations with floating point. 8 bit color
// values of 0x00 to 0xff are mapped into the 0. to 1. range.  Performing these
// multiplies in fixed point requires an adjustment to adhere to this rule.
//
//
//-----------------------------------------------------------------------------
void
RefRast::DoTextureBlendStage(
    int iStage,
    const RDColor& DiffuseColor,
    const RDColor& SpecularColor,
    const RDColor& CurrentColor,
    const RDColor& TextureColor,
    RDColor& TempColor,
    RDColor& CurrentReturnColor)
{
    DPFM(5, TEX, ("DoTextureBlend\n"));

    RDColor BlendedColor;

    if (iStage >= 1)
    {
        if (m_pRD->GetTSS(iStage-1)[D3DTSS_COLOROP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            // cast away the const'ness, just for PREMODULATE
            ((RDColor&)CurrentColor).R = CurrentColor.R * TextureColor.R;
            ((RDColor&)CurrentColor).G = CurrentColor.G * TextureColor.G;
            ((RDColor&)CurrentColor).B = CurrentColor.B * TextureColor.B;
        }
        if (m_pRD->GetTSS(iStage-1)[D3DTSS_ALPHAOP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            ((RDColor&)CurrentColor).A *= CurrentColor.A * TextureColor.A;
        }
    }

    // compute arg0,1,2 for color channel blend
    RDColor ColorArg0, ColorArg1, ColorArg2;
    RDColor AlphaArg0, AlphaArg1, AlphaArg2;
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_COLORARG0], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, ColorArg0 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_COLORARG1], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, ColorArg1 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_COLORARG2], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, ColorArg2 );

    // do color channel blend
    FLOAT fModulateScale;
    FLOAT fBlendFactor;
    switch ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] )
    {

    case D3DTOP_SELECTARG1:
        BlendedColor.R = ColorArg1.R;
        BlendedColor.G = ColorArg1.G;
        BlendedColor.B = ColorArg1.B;
        break;
    case D3DTOP_SELECTARG2:
        BlendedColor.R = ColorArg2.R;
        BlendedColor.G = ColorArg2.G;
        BlendedColor.B = ColorArg2.B;
        break;

    case D3DTOP_ADD:
        BlendedColor.R = ColorArg1.R + ColorArg2.R;
        BlendedColor.G = ColorArg1.G + ColorArg2.G;
        BlendedColor.B = ColorArg1.B + ColorArg2.B;
        break;
    case D3DTOP_ADDSIGNED:
        BlendedColor.R = ColorArg1.R + ColorArg2.R - .5f;
        BlendedColor.G = ColorArg1.G + ColorArg2.G - .5f;
        BlendedColor.B = ColorArg1.B + ColorArg2.B - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        BlendedColor.R = (ColorArg1.R + ColorArg2.R - .5f)*2.0f;
        BlendedColor.G = (ColorArg1.G + ColorArg2.G - .5f)*2.0f;
        BlendedColor.B = (ColorArg1.B + ColorArg2.B - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        BlendedColor.R = 1.f - ((1.f - ColorArg1.R) + ColorArg2.R);
        BlendedColor.G = 1.f - ((1.f - ColorArg1.G) + ColorArg2.G);
        BlendedColor.B = 1.f - ((1.f - ColorArg1.B) + ColorArg2.B);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        BlendedColor.R = ColorArg1.R + (1.f - ColorArg1.R)*ColorArg2.R;
        BlendedColor.G = ColorArg1.G + (1.f - ColorArg1.G)*ColorArg2.G;
        BlendedColor.B = ColorArg1.B + (1.f - ColorArg1.B)*ColorArg2.B;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateC;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateC;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateC;
_DoModulateC:
        BlendedColor.R = ColorArg1.R * ColorArg2.R * fModulateScale;
        BlendedColor.G = ColorArg1.G * ColorArg2.G * fModulateScale;
        BlendedColor.B = ColorArg1.B * ColorArg2.B * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: fBlendFactor = DiffuseColor.A; goto _DoBlendC;
    case D3DTOP_BLENDTEXTUREALPHA: fBlendFactor = TextureColor.A; goto _DoBlendC;
    case D3DTOP_BLENDCURRENTALPHA: fBlendFactor = CurrentColor.A; goto _DoBlendC;
    case D3DTOP_BLENDFACTORALPHA:
        fBlendFactor = RGBA_GETALPHA( m_pRD->GetRS()[D3DRS_TEXTUREFACTOR] )*(1./255.);
        goto _DoBlendC;
_DoBlendC:
        BlendedColor.R = fBlendFactor * (ColorArg1.R - ColorArg2.R) + ColorArg2.R;
        BlendedColor.G = fBlendFactor * (ColorArg1.G - ColorArg2.G) + ColorArg2.G;
        BlendedColor.B = fBlendFactor * (ColorArg1.B - ColorArg2.B) + ColorArg2.B;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        BlendedColor.R = ColorArg1.R + ( (1.f - TextureColor.A) * ColorArg2.R );
        BlendedColor.G = ColorArg1.G + ( (1.f - TextureColor.A) * ColorArg2.G );
        BlendedColor.B = ColorArg1.B + ( (1.f - TextureColor.A) * ColorArg2.B );
        break;

    case D3DTOP_PREMODULATE:
        // just copy ColorArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        BlendedColor.R = ColorArg1.R;
        BlendedColor.G = ColorArg1.G;
        BlendedColor.B = ColorArg1.B;
        break;
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
        BlendedColor.R = ColorArg1.R + ColorArg1.A*ColorArg2.R;
        BlendedColor.G = ColorArg1.G + ColorArg1.A*ColorArg2.G;
        BlendedColor.B = ColorArg1.B + ColorArg1.A*ColorArg2.B;
        break;
    case D3DTOP_MODULATECOLOR_ADDALPHA:
        BlendedColor.R = ColorArg1.R*ColorArg2.R + ColorArg1.A;
        BlendedColor.G = ColorArg1.G*ColorArg2.G + ColorArg1.A;
        BlendedColor.B = ColorArg1.B*ColorArg2.B + ColorArg1.A;
        break;
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
        BlendedColor.R = (1.f - ColorArg1.A)*ColorArg2.R + ColorArg1.R;
        BlendedColor.G = (1.f - ColorArg1.A)*ColorArg2.G + ColorArg1.G;
        BlendedColor.B = (1.f - ColorArg1.A)*ColorArg2.B + ColorArg1.B;
        break;
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        BlendedColor.R = (1.f - ColorArg1.R)*ColorArg2.R + ColorArg1.A;
        BlendedColor.G = (1.f - ColorArg1.G)*ColorArg2.G + ColorArg1.A;
        BlendedColor.B = (1.f - ColorArg1.B)*ColorArg2.B + ColorArg1.A;
        break;

    case D3DTOP_DOTPRODUCT3:
        BlendedColor.R = ((ColorArg1.R-0.5f)*2.0f*(ColorArg2.R-0.5f)*2.0f +
             (ColorArg1.G-0.5f)*2.0f*(ColorArg2.G-0.5f)*2.0f +
             (ColorArg1.B-0.5f)*2.0f*(ColorArg2.B-0.5f)*2.0f);
        BlendedColor.G = BlendedColor.R;
        BlendedColor.B = BlendedColor.R;
        BlendedColor.A = BlendedColor.R;
        goto _SkipAlphaChannelBlend;
        break;

    case D3DTOP_MULTIPLYADD:
        BlendedColor.R = ColorArg0.R + (ColorArg1.R * ColorArg2.R);
        BlendedColor.G = ColorArg0.G + (ColorArg1.G * ColorArg2.G);
        BlendedColor.B = ColorArg0.B + (ColorArg1.B * ColorArg2.B);
        break;

    case D3DTOP_LERP:   // (Arg0)*Arg1 + (1-Arg0)*Arg2 = Arg2 + Arg0*(Arg1-Arg2)
        BlendedColor.R = ColorArg2.R + ColorArg0.R*(ColorArg1.R - ColorArg2.R);
        BlendedColor.G = ColorArg2.G + ColorArg0.G*(ColorArg1.G - ColorArg2.G);
        BlendedColor.B = ColorArg2.B + ColorArg0.B*(ColorArg1.B - ColorArg2.B);
        break;
    }


    // compute arg0,1,2 for alpha channel blend
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAARG0], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, AlphaArg0 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAARG1], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, AlphaArg1 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAARG2], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, AlphaArg2 );

    // do alpha channel blend
    switch ( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAOP] )
    {
    case D3DTOP_LEGACY_ALPHAOVR:
        if (m_pRD->m_pTexture[0])
        {
            BlendedColor.A = ( m_pRD->m_pTexture[0]->m_bHasAlpha ) ? AlphaArg1.A : AlphaArg2.A;
        }
        else
        {
            BlendedColor.A = AlphaArg1.A;
        }
        break;

    case D3DTOP_SELECTARG1:
        BlendedColor.A = AlphaArg1.A;
        break;
    case D3DTOP_SELECTARG2:
        BlendedColor.A = AlphaArg2.A;
        break;

    case D3DTOP_ADD:
        BlendedColor.A = AlphaArg1.A + AlphaArg2.A;
        break;
    case D3DTOP_ADDSIGNED:
        BlendedColor.A = AlphaArg1.A + AlphaArg2.A - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        BlendedColor.A = (AlphaArg1.A + AlphaArg2.A - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        BlendedColor.A = 1.f - ((1.f - AlphaArg1.A) + AlphaArg2.A);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        BlendedColor.A = AlphaArg1.A + (1.f - AlphaArg1.A)*AlphaArg2.A;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateA;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateA;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateA;
_DoModulateA:
        BlendedColor.A = AlphaArg1.A * AlphaArg2.A * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: fBlendFactor = DiffuseColor.A; goto _DoBlendA;
    case D3DTOP_BLENDTEXTUREALPHA: fBlendFactor = TextureColor.A; goto _DoBlendA;
    case D3DTOP_BLENDCURRENTALPHA: fBlendFactor = CurrentColor.A; goto _DoBlendA;
    case D3DTOP_BLENDFACTORALPHA:
        fBlendFactor = RGBA_GETALPHA( m_pRD->GetRS()[D3DRS_TEXTUREFACTOR] )*(1./255.);
        goto _DoBlendA;
_DoBlendA:
        BlendedColor.A = fBlendFactor * (AlphaArg1.A - AlphaArg2.A) + AlphaArg2.A;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        BlendedColor.A = AlphaArg1.A + ( (1.f - TextureColor.A) * AlphaArg2.A );
        break;

    case D3DTOP_PREMODULATE:
        // just copy AlphaArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        BlendedColor.A = AlphaArg1.A;
        break;

    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
    case D3DTOP_DOTPRODUCT3:
        // does nothing, not valid alpha op's
        break;

    case D3DTOP_MULTIPLYADD:
        BlendedColor.A = ColorArg0.A + (ColorArg1.A * ColorArg2.A);
        break;

    case D3DTOP_LERP:   // (Arg0)*Arg1 + (1-Arg0)*Arg2 = Arg2 + Arg0*(Arg1-Arg2)
        BlendedColor.A = ColorArg2.A + ColorArg0.A*(ColorArg1.A - ColorArg2.A);
        break;
    }

_SkipAlphaChannelBlend:

    // clamp blended color after each blend stage
    BlendedColor.Clamp();

    // write to selected result register
    switch ( m_pRD->GetTSS(iStage)[D3DTSS_RESULTARG] )
    {
    default:
    case D3DTA_CURRENT: CurrentReturnColor = BlendedColor; break;
    case D3DTA_TEMP:    TempColor = BlendedColor; break;
    }

}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
RefClipper::__CLIP_NAME(RDClipVertex **inv, RDClipVertex **outv, int count)
{
    int i;
    int out_count = 0;
    RDClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->m_clip_w * __CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->m_clip_w - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->m_clip_w * __CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->m_clip_w - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate(outv[out_count],
                            curr, prev, 
                            (prev->m_clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } 
        else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate(outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int 
RefClipper::__CLIP_LINE_NAME(RDCLIPTRIANGLE *line) 
{
    D3DVALUE in1, in2;
    RDClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->m_clip_w * __CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->m_clip_w * __CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->m_clip_w - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->m_clip_w - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(&outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(&outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\clipping.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define GET_NEW_CLIP_VERTEX \
&clip_vertices[clip_vertices_used++];


//---------------------------------------------------------------------
inline void
InterpolateColor(RDClipVertex *out,
                 RDClipVertex *p1,
                 RDClipVertex *p2,
                 D3DVALUE num_denom )
{
    FLOAT r1, g1, b1, a1;
    FLOAT r2, g2, b2, a2;

    r1 = p1->m_diffuse.r;
    g1 = p1->m_diffuse.g;
    b1 = p1->m_diffuse.b;
    a1 = p1->m_diffuse.a;
    r2 = p2->m_diffuse.r;
    g2 = p2->m_diffuse.g;
    b2 = p2->m_diffuse.b;
    a2 = p2->m_diffuse.a;
    out->m_diffuse.r = (r1 + (r2 - r1) * num_denom);
    out->m_diffuse.g = (g1 + (g2 - g1) * num_denom);
    out->m_diffuse.b = (b1 + (b2 - b1) * num_denom);
    out->m_diffuse.a = (a1 + (a2 - a1) * num_denom);
}
//---------------------------------------------------------------------
inline void
InterpolateSpecular(RDClipVertex *out,
                    RDClipVertex *p1,
                    RDClipVertex *p2,
                    D3DVALUE num_denom )
{
    FLOAT r1, g1, b1, a1;
    FLOAT r2, g2, b2, a2;

    r1 = p1->m_specular.r;
    g1 = p1->m_specular.g;
    b1 = p1->m_specular.b;
    a1 = p1->m_specular.a;
    r2 = p2->m_specular.r;
    g2 = p2->m_specular.g;
    b2 = p2->m_specular.b;
    a2 = p2->m_specular.a;
    out->m_specular.r = (r1 + (r2 - r1) * num_denom);
    out->m_specular.g = (g1 + (g2 - g1) * num_denom);
    out->m_specular.b = (b1 + (b2 - b1) * num_denom);
    out->m_specular.a = (a1 + (a2 - a1) * num_denom);
}
//---------------------------------------------------------------------
// Inline texture coordinate difference.
__inline FLOAT
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if( iMode == 0 )
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if( FLOAT_LTZ(fDiff1) )
        {
            fDiff2 += g_fOne;
        }
        else if( FLOAT_GTZ(fDiff1) )
        {
            fDiff2 -= g_fOne;
        }
        if( ABSF(fDiff1) < ABSF(fDiff2) )
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

//---------------------------------------------------------------------
inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if( !bWrap )
    {
        return ((t2 - t1) * num_denom + t1);
    }
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if( t > 1.0f ) t -= 1.0f;
        return t;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// RefClipper implementation
//
//////////////////////////////////////////////////////////////////////////////
const DWORD RefClipper::RCLIP_DIRTY_ZRANGE   = (1 << 0);
const DWORD RefClipper::RCLIP_DIRTY_VIEWRECT = (1 << 1);
const DWORD RefClipper::RCLIP_DO_FLATSHADING = (1 << 2);
const DWORD RefClipper::RCLIP_DO_WIREFRAME   = (1 << 3);
const DWORD RefClipper::RCLIP_DO_ADJUSTWRAP  = (1 << 4);
const DWORD RefClipper::RCLIP_Z_ENABLE       = (1 << 5);

RefClipper::RefClipper()
{
    m_dwFlags = 0;
    memset( &m_Viewport, 0, sizeof( m_Viewport) );

    dvX = dvY = dvWidth = dvHeight = 0.0f;
    scaleX = scaleY = scaleZ = 0.0f;
    offsetX = offsetY = offsetZ = 0.0f;
    scaleXi = scaleYi = scaleZi = 0.0f;
    minX = minY = maxX = maxY = 0.0f;
    minXgb = minYgb = maxXgb = maxYgb = 0.0f;
    gb11 = gb22 = gb41 = gb42 = 0.0f;
    Kgbx1 = Kgby1 = Kgbx2 = Kgby2 = 0.0f;

    memset( clip_vbuf1, 0, sizeof(RDClipVertex*)*RD_MAX_CLIP_VERTICES );
    memset( clip_vbuf2, 0, sizeof(RDClipVertex*)*RD_MAX_CLIP_VERTICES );
    current_vbuf = 0;
    memset( clip_vertices, 0, sizeof(RDClipVertex)*RD_MAX_CLIP_VERTICES );
    m_dwInterpolate = 0;
    clip_vertices_used = 0;

    m_clipUnion = 0;
    m_clipIntersection = 0;

   // By default enable Guardband and set the extents equal
    // to the default RefRast parameters
    m_bUseGB = TRUE;
    minXgb = (RD_GB_LEFT);
    maxXgb = RD_GB_RIGHT;
    minYgb = (RD_GB_TOP);
    maxYgb = RD_GB_BOTTOM;

    memset( m_userClipPlanes, 0, sizeof(RDVECTOR4)*RD_MAX_USER_CLIPPLANES );

#if DBG
    DWORD v = 0;
    // Guardband parameters
    if( GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) && v != 0 )
    {
        m_bUseGB = FALSE;
    }
    // Try to get test values for the guard band
    char value[80];
    if( GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &minXgb);
    if( GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &maxXgb);
    if( GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &minYgb);
    if( GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &maxYgb);
#endif // DBG
}


//---------------------------------------------------------------------
// RefClipper::UpdateViewData
//             Updates View data used by ProcessVertices[VVM]
//---------------------------------------------------------------------
HRESULT
RefClipper::UpdateViewData()
{
    HRESULT hr = D3D_OK;

    // Update viewport information
    if( m_dwFlags & RCLIP_DIRTY_ZRANGE )
    {
        scaleZ  = m_Viewport.dvMaxZ - m_Viewport.dvMinZ;
        offsetZ = m_Viewport.dvMinZ;
        // ATTENTION: This could be a Divide by Zero here if
        // the dvMaxZ == dvMinZ. Fix it later.
        scaleZi = D3DVAL(1) / scaleZ;
    }

    if( m_dwFlags & RCLIP_DIRTY_VIEWRECT )
    {
        // Bail if we are going to cause any divide by zero exceptions.
        // The likely reason is that we have a bogus viewport set by
        // TLVertex execute buffer app.
        if(m_Viewport.dwWidth == 0 || m_Viewport.dwHeight == 0 )
            return DDERR_GENERIC;

        dvX = D3DVAL(m_Viewport.dwX);
        dvY = D3DVAL(m_Viewport.dwY);
        dvWidth = D3DVAL(m_Viewport.dwWidth);
        dvHeight = D3DVAL(m_Viewport.dwHeight);

        // Coefficients to compute screen coordinates from normalized window
        // coordinates
        scaleX  = dvWidth;
        scaleY  = - dvHeight;
        offsetX = dvX;
        offsetY = dvY + dvHeight;

#if 0
        // Small offset is added to prevent generation of negative screen
        // coordinates (this could happen because of precision errors).
        // Not needed (or wanted) for devices which do guardband.
        offsetX += SMALL_NUMBER;
        offsetY += SMALL_NUMBER;
#endif

        scaleXi = D3DVAL(1) / scaleX;
        scaleYi = D3DVAL(1) / scaleY;

        minX = dvX;
        maxX = dvX + dvWidth;
        minY = dvY;
        maxY = dvY + dvHeight;

        if( m_bUseGB )
        {
            // Because we clip by guard band window we have to use its extents
            D3DVALUE w = 2.0f / dvWidth;
            D3DVALUE h = 2.0f / dvHeight;
            D3DVALUE ax1 = -(minXgb - dvX) * w + 1.0f;
            D3DVALUE ax2 =  (maxXgb - dvX) * w - 1.0f;
            D3DVALUE ay1 =  (maxYgb - dvY) * h - 1.0f;
            D3DVALUE ay2 = -(minYgb - dvY) * h + 1.0f;
            gb11 = 2.0f / (ax1 + ax2);
            gb41 = gb11 * (ax1 - 1.0f) * 0.5f;
            gb22 = 2.0f / (ay1 + ay2);
            gb42 = gb22 * (ay1 - 1.0f) * 0.5f;

            Kgbx1 = 0.5f * (1.0f - ax1);
            Kgbx2 = 0.5f * (1.0f + ax2);
            Kgby1 = 0.5f * (1.0f - ay1);
            Kgby2 = 0.5f * (1.0f + ay2);
        }
        else
        {
            minXgb = minX;
            maxXgb = maxX;
            minYgb = minY;
            maxYgb = maxY;
        }
    }

    // Clear the dirty transform flags
    m_dwFlags &= ~(RCLIP_DIRTY_VIEWRECT | RCLIP_DIRTY_ZRANGE);
    return hr;
}

//---------------------------------------------------------------------
// Make clip vertex from RDVertex
//
// cv     - clipVertex
// v      - a TL vertex
// qwFVF  - FVF of the input TL vertex
//---------------------------------------------------------------------
void
RefClipper::MakeClipVertexFromVertex( RDClipVertex& cv, RDVertex& v,
                                        DWORD dwClipMask )
{
    DWORD dwClipFlag = (DWORD) v.m_clip;

    memcpy( &cv, &v, sizeof( RDVertex ) );

    // If the clip flag for this vertex is set, that means that the
    // transformation loop has not computed the screen coordinates for
    // this vertex, it has simply stored the clip coordinates for this
    // vertex
#if 0
    if( v.m_clip & dwClipMask )
    {
        // This is a clipped vertex, simply no screen coordinates
        cv.m_pos.x  = D3DVALUE(0);
        cv.m_pos.y  = D3DVALUE(0);
        cv.m_pos.z  = D3DVALUE(0);
        cv.m_rhw    = D3DVALUE(0);

        // Since this vertex has been clipped, the transformation loop
        // has put in the clip coordinates instead
        cv.hx  = v.m_pos.x;
        cv.hy  = v.m_pos.y;
        cv.hz  = v.m_pos.z;
        cv.hw  = v.m_rhw;
    }
    else
    {
        // This vertex is not clipped, so its screen coordinates have been
        // computed

        // Transform the screen coordinate back to the clipping space
        cv.hw  = 1.0f / cv.m_rhw;
        cv.hx  = (cv.m_pos.x - offsetX) * cv.hw * scaleXi;
        cv.hy  = (cv.m_pos.y - offsetY) * cv.hw * scaleYi;
        cv.hz  = (cv.m_pos.z - offsetZ) * cv.hw * scaleZi;

    }
#endif
}

//---------------------------------------------------------------------
// RefVP::ComputeClipCodes
//---------------------------------------------------------------------
RDCLIPCODE
RefClipper::ComputeClipCodes(RDCLIPCODE* pclipIntersection,
                             RDCLIPCODE* pclipUnion,
                             FLOAT x_clip, FLOAT y_clip,
                             FLOAT z_clip, FLOAT w_clip)
{
    D3DVALUE xx = w_clip - x_clip;
    D3DVALUE yy = w_clip - y_clip;
    D3DVALUE zz = w_clip - z_clip;

    // if( x < 0 )  clip |= RDCLIP_LEFTBIT;
    // if( x >= we ) clip |= RDCLIP_RIGHTBIT;
    // if( y < 0 )  clip |= RDCLIP_BOTTOMBIT;
    // if( y >= we ) clip |= RDCLIP_TOPBIT;
    // if( z < 0 )    clip |= RDCLIP_FRONTBIT;
    // if( z >= we ) clip |= RDCLIP_BACKBIT;
    RDCLIPCODE clip =
        ((AS_INT32(x_clip)  & 0x80000000) >>  (32-RDCLIP_LEFTBIT))  |
        ((AS_INT32(y_clip)  & 0x80000000) >>  (32-RDCLIP_BOTTOMBIT))|
        ((AS_INT32(z_clip)  & 0x80000000) >>  (32-RDCLIP_FRONTBIT)) |
        ((AS_INT32(xx)      & 0x80000000) >>  (32-RDCLIP_RIGHTBIT)) |
        ((AS_INT32(yy)      & 0x80000000) >>  (32-RDCLIP_TOPBIT))   |
        ((AS_INT32(zz)      & 0x80000000) >>  (32-RDCLIP_BACKBIT));

    RDCLIPCODE clipBit = RDCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( m_xfmUserClipPlanes[j].bActive )
        {
            RDVECTOR4& plane = m_xfmUserClipPlanes[j].plane;
            FLOAT fComp = 0.0f;
            if( (x_clip*plane.x +
                 y_clip*plane.y +
                 z_clip*plane.z +
                 w_clip*plane.w) < fComp )
            {
                clip |= clipBit;
            }
        }
        clipBit <<= 1;
    }

    if( clip == 0 )
    {
        *pclipIntersection = 0;
        return clip;
    }
    else
    {
        if( m_bUseGB )
        {
            // We do guardband check in the projection space, so
            // we transform X and Y of the vertex there
            D3DVALUE xnew = x_clip * gb11 +
                            w_clip * gb41;
            D3DVALUE ynew = y_clip * gb22 +
                            w_clip * gb42;
            D3DVALUE xx = w_clip - xnew;
            D3DVALUE yy = w_clip - ynew;
            clip |= ((AS_INT32(xnew) & 0x80000000) >> (32-RDCLIPGB_LEFTBIT))   |
                    ((AS_INT32(ynew) & 0x80000000) >> (32-RDCLIPGB_BOTTOMBIT)) |
                    ((AS_INT32(xx)   & 0x80000000) >> (32-RDCLIPGB_RIGHTBIT))  |
                    ((AS_INT32(yy)   & 0x80000000) >> (32-RDCLIPGB_TOPBIT));
        }
        *pclipIntersection &= clip;
        *pclipUnion |= clip;
        return clip;
    }
}

//---------------------------------------------------------------------
// RefVP::ComputeClipCodesTL
//---------------------------------------------------------------------
void
RefClipper::ComputeClipCodesTL( RDVertex* pVtx )
{
    FLOAT x, y, z;
    DWORD clip = 0;

    _ASSERT( FVF_TRANSFORMED( pVtx->m_qwFVF ),
             "Can compute clipcodes only for Transformed vertices." );
    DWORD clipZF = (m_dwFlags & RCLIP_Z_ENABLE) ? RDCLIP_FRONT : 0;
    DWORD clipZB = (m_dwFlags & RCLIP_Z_ENABLE) ? RDCLIP_BACK : 0;

    // Invert to compenstate for the sign during the
    // divide by w.
    if( pVtx->m_rhw < 0 )
    {
        x = -pVtx->m_pos.x;
        y = -pVtx->m_pos.y;
        z = -pVtx->m_pos.z;
    }
    else
    {
        x = pVtx->m_pos.x;
        y = pVtx->m_pos.y;
        z = pVtx->m_pos.z;
    }

    if( x < minX )
        clip |= RDCLIP_LEFT;
    else if( x >= maxX )
        clip |= RDCLIP_RIGHT;

    if (y < minY)
        clip |= RDCLIP_TOP;
    else if (y >= maxY)
        clip |= RDCLIP_BOTTOM;

    if (z < 0.0f)
        clip |= clipZF;
    else if (z >= 1.0f)
        clip |= clipZB;

    if( m_bUseGB )
    {
        if( x < minXgb )
            clip |= RDCLIPGB_LEFT;
        else if( x >= maxXgb )
            clip |= RDCLIPGB_RIGHT;

        if( y < minYgb )
            clip |= RDCLIPGB_TOP;
        else if( y >= maxYgb )
            clip |= RDCLIPGB_BOTTOM;
    }

    pVtx->m_clip = clip;

    // Back transform to obtain the clip-coordinates
    pVtx->m_clip_w =  1.0f / pVtx->m_rhw;   // This is w_clip
    pVtx->m_clip_x  = (pVtx->m_pos.x - offsetX) * pVtx->m_clip_w * scaleXi;
    pVtx->m_clip_y  = (pVtx->m_pos.y - offsetY) * pVtx->m_clip_w * scaleYi;
    pVtx->m_clip_z  = (pVtx->m_pos.z - offsetZ) * pVtx->m_clip_w * scaleZi;

    return;
}

//---------------------------------------------------------------------
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//---------------------------------------------------------------------
int
RefClipper::ClipByPlane( RDClipVertex **inv, RDClipVertex **outv,
                         RDVECTOR4 *plane, DWORD dwClipFlag, int count )
{
    int i;
    int out_count = 0;
    RDClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->m_clip_x*plane->x + prev->m_clip_y*plane->y +
                  prev->m_clip_z*plane->z + prev->m_clip_w*plane->w;
    for (i = count; i; i--)
    {
        curr_inside = curr->m_clip_x*plane->x + curr->m_clip_y*plane->y +
                      curr->m_clip_z*plane->z + curr->m_clip_w*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if( FLOAT_LTZ(prev_inside) )
        { // first point is outside
            if( FLOAT_GEZ(curr_inside) )
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate( outv[out_count],
                             curr, prev,
                             (prev->m_clip & CLIPPED_ENABLE) | dwClipFlag,
                             curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if( FLOAT_LTZ(curr_inside) )
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate( outv[out_count],
                             prev, curr,
                             dwClipFlag,
                             prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int
RefClipper::ClipLineByPlane( RDCLIPTRIANGLE *line, RDVECTOR4 *plane,
                             DWORD dwClipBit )
{
    D3DVALUE in1, in2;
    RDClipVertex outv;
    in1 = line->v[0]->m_clip_x * plane->x +
          line->v[0]->m_clip_y * plane->y +
          line->v[0]->m_clip_z * plane->z +
          line->v[0]->m_clip_w * plane->w;
    in2 = line->v[1]->m_clip_x * plane->x +
          line->v[1]->m_clip_y * plane->y +
          line->v[1]->m_clip_z * plane->z +
          line->v[1]->m_clip_w * plane->w;
    if( in1 < 0 )
    {
        if( in2 < 0 )
            return 1;
        Interpolate( &outv, line->v[0], line->v[1],
                     dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    }
    else
    {
        if( in2 < 0 )
        {
            Interpolate( &outv, line->v[0], line->v[1],
                         dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void
RefClipper::ComputeScreenCoordinates( RDClipVertex **inv, int count )
{
    int i;

    for (i = 0; i < count; i++)
    {
        RDClipVertex *p;
        p = inv[i];

        //
        // Catch any vertices that need screen co-ordinates generated.
        // There are two possibilities
        //      1) Vertices generated during interpolation
        //      2) Vertices marked for clipping by the transform but
        //              not clipped here due to the finite precision
        //              of the floating point unit.
        //

        if( p->m_clip & ~CLIPPED_ENABLE )
        {
            D3DVALUE inv_w;

            inv_w = D3DVAL(1.0)/p->m_clip_w;
            switch ((int)p->m_clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->m_pos.x = minXgb; break;
            case CLIPPED_RIGHT: p->m_pos.x = maxXgb; break;
            default:
                p->m_pos.x = p->m_clip_x * scaleX * inv_w + offsetX;
                if( p->m_pos.x < minXgb )
                    p->m_pos.x = minXgb;
                if( p->m_pos.x > maxXgb )
                    p->m_pos.x = maxXgb;
            }
            switch ((int)p->m_clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->m_pos.y = maxYgb; break;
            case CLIPPED_TOP:    p->m_pos.y = minYgb; break;
            default:
                p->m_pos.y = p->m_clip_y * scaleY * inv_w + offsetY;
                if( p->m_pos.y < minYgb )
                    p->m_pos.y = minYgb;
                if( p->m_pos.y > maxYgb )
                    p->m_pos.y = maxYgb;
            }
            p->m_pos.z = p->m_clip_z * scaleZ * inv_w + offsetZ;
            p->m_rhw = inv_w;
        }
    }
}
//---------------------------------------------------------------------
void
RefClipper::Interpolate( RDClipVertex *out, RDClipVertex *p1, RDClipVertex *p2,
                         int code, D3DVALUE num, D3DVALUE denom )
{
    DWORD dwInterpolate = m_dwInterpolate;
    D3DVALUE num_denom = num / denom;

    out->m_clip = (((int)p1->m_clip & (int)p2->m_clip) & ~CLIPPED_ENABLE) | code;
    out->m_clip_x = p1->m_clip_x + (p2->m_clip_x - p1->m_clip_x) * num_denom;
    out->m_clip_y = p1->m_clip_y + (p2->m_clip_y - p1->m_clip_y) * num_denom;
    out->m_clip_z = p1->m_clip_z + (p2->m_clip_z - p1->m_clip_z) * num_denom;
    out->m_clip_w = p1->m_clip_w + (p2->m_clip_w - p1->m_clip_w) * num_denom;
    out->m_diffuse = clip_color;
    out->m_specular = clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if( dwInterpolate & RDCLIP_INTERPOLATE_COLOR )
    {
        InterpolateColor(out, p1, p2, num_denom);
    }

    if( dwInterpolate & RDCLIP_INTERPOLATE_SPECULAR )
    {
        InterpolateSpecular(out, p1, p2, num_denom);
    }

    if( dwInterpolate & RDCLIP_INTERPOLATE_TEXTURE )
    {
        UINT64 qwFVF = p1->m_qwFVF;

        // Assume that D3DRENDERSTATE_WRAPi are sequential
        DWORD numTex = FVF_TEXCOORD_NUMBER(qwFVF);
        for (DWORD i = 0; i < numTex; i++)
        {
            FLOAT* pTexture1 = (FLOAT *)&p1->m_tex[i];
            FLOAT* pTexture2 = (FLOAT *)&p2->m_tex[i];
            FLOAT* pTexture  = (FLOAT *)&out->m_tex[i];
            DWORD wrapState;

            if( m_dwFlags & RCLIP_DO_ADJUSTWRAP )
            {
                DWORD TCI = m_pDev->GetTSS(i)[D3DTSS_TEXCOORDINDEX] & 0xffff;
                wrapState = m_pDev->GetRS()[D3DRENDERSTATE_WRAP0 + TCI];
            }
            else
            {
                wrapState = m_pDev->GetRS()[D3DRENDERSTATE_WRAP0 + i];
            }

            DWORD n = GetTexCoordDim(qwFVF, i);
            // DWORD n = (DWORD)(m_dwTexCoordSizeArray[i] >> 2);
            DWORD dwWrapBit = 1;
            for (DWORD j=0; j < n; j++)
            {
                pTexture[j] = InterpolateTexture(pTexture1[j], pTexture2[j],
                                                 num_denom,
                                                 wrapState & dwWrapBit);
                dwWrapBit <<= 1;
            }
        }
    }
    if( dwInterpolate & RDCLIP_INTERPOLATE_S )
    {
        out->m_pointsize = p1->m_pointsize +
            (p2->m_pointsize - p1->m_pointsize) * num_denom;
    }
    if( dwInterpolate & RDCLIP_INTERPOLATE_FOG )
    {
        out->m_fog = p1->m_fog + (p2->m_fog - p1->m_fog) * num_denom;
    }
}

//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD m_clip_x
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD m_clip_x
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD m_clip_y
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD m_clip_y
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD m_clip_z
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD m_clip_z
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD m_clip_x
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD m_clip_x
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD m_clip_y
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD m_clip_y
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND

//---------------------------------------------------------------------
inline DWORD
ComputeClipCodeUserPlanes( RDUSERCLIPPLANE *UserPlanes, RDClipVertex *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = RDCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( UserPlanes[j].bActive )
        {
            RDVECTOR4& plane = UserPlanes[j].plane;
            if( (p->m_clip_x*plane.x +
                 p->m_clip_y*plane.y +
                 p->m_clip_z*plane.z +
                 p->m_clip_w*plane.w) < 0 )
            {
                clip |= dwClipBit;
            }
        }
        dwClipBit <<= 1;
    }
    return clip;
}

//---------------------------------------------------------------------
inline DWORD
RefClipper::ComputeClipCodeGB( RDClipVertex *p )
{
    DWORD clip = 0;
    if( p->m_clip_x < p->m_clip_w * Kgbx1 )
        clip |= RDCLIPGB_LEFT;
    if( p->m_clip_x > p->m_clip_w * Kgbx2 )
        clip |= RDCLIPGB_RIGHT;
    if( p->m_clip_y < p->m_clip_w * Kgby1 )
        clip |= RDCLIPGB_BOTTOM;
    if( p->m_clip_y > p->m_clip_w * Kgby2 )
        clip |= RDCLIPGB_TOP;
    if( p->m_clip_z > p->m_clip_w )
        clip |= RDCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes( m_xfmUserClipPlanes, p );
    p->m_clip = (p->m_clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}

//---------------------------------------------------------------------
inline DWORD
RefClipper::ComputeClipCode( RDClipVertex *p )
{
    DWORD clip = 0;
    if( FLOAT_LTZ(p->m_clip_x) )
        clip |= RDCLIP_LEFT;
    if( p->m_clip_x > p->m_clip_w )
        clip |= RDCLIP_RIGHT;
    if( FLOAT_LTZ(p->m_clip_y) )
        clip |= RDCLIP_BOTTOM;
    if( p->m_clip_y > p->m_clip_w )
        clip |= RDCLIP_TOP;
    if( p->m_clip_z > p->m_clip_w )
        clip |= RDCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes( m_xfmUserClipPlanes, p );
    p->m_clip = (p->m_clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}

//---------------------------------------------------------------------
// RefDev::UpdateClipper
//             Updates clipping data used by ProcessVertices
// BOOL bProgrammablePipeLine: If this is true, it means that the 
//                             programmable vertex machine is invoking
//                             this method.
//---------------------------------------------------------------------
HRESULT
RefDev::UpdateClipper()
{
    HRESULT hr = D3D_OK;

    HR_RET( m_Clipper.UpdateViewData() );
    DWORD dwClipPlanesEnable =
        GetRS()[D3DRENDERSTATE_CLIPPLANEENABLE];

    if( !GetRS()[D3DRENDERSTATE_CLIPPING] )
        return S_OK;

    m_Clipper.m_dwFlags &= ~RefClipper::RCLIP_DO_ADJUSTWRAP;
    if( (m_RefVP.m_dwTLState & (RDPV_DOTEXXFORM | RDPV_DOTEXGEN)) &&
        m_pCurrentVShader->IsFixedFunction() )
        m_Clipper.m_dwFlags |= RefClipper::RCLIP_DO_ADJUSTWRAP;

    // Figure out which pieces need to be interpolated in new vertices.
    m_Clipper.m_dwInterpolate = 0;
    if(  GetRS()[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD  )
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_COLOR;

        if( m_qwFVFOut & D3DFVF_SPECULAR )
        {
            m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_SPECULAR;
        }
    }

    // if( GetRS()[D3DRENDERSTATE_FOGENABLE] )
    if( m_qwFVFOut & D3DFVFP_FOG )
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_FOG;
    }

    if( FVF_TEXCOORD_NUMBER(m_qwFVFOut) != 0 )
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_TEXTURE;
    }

    if( m_qwFVFOut & D3DFVF_PSIZE ) // m_primType == D3DPT_POINTLIST
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_S;
    }

    // Clear clip union and intersection flags
    m_Clipper.m_clipIntersection = 0;
    m_Clipper.m_clipUnion = 0;

    // The matrix to transform user clip planes depends on whether it is a
    // fixed function pipeline or a programmable pipeline. 
    // Programmable pipeline: the clip-planes are transformed by the 
    //     Inverse(Mshift) to adjust for clipping in the clipper. The user is 
    //     assumed to have pre-transformed the clip-planes to the clipping 
    //     space.
    // Fixed function pipeline: the clip-planes are transformed to the clipping
    //     space by the Inverse(Mview * Mproj * Mshift).
    RDMATRIX* pUserClipPlaneMatrix = NULL; 
    RDMATRIX matProgPipe = 
    { 
        2, 0, 0, 0,
        0, 2, 0, 0,
        0, 0, 1, 0,
       -1,-1, 0, 1 
    };
    
    if( m_pCurrentVShader->IsFixedFunction() )
    {
        pUserClipPlaneMatrix = &(m_RefVP.m_TransformData.m_VPSInv);
    }
    else
    {
        pUserClipPlaneMatrix = &matProgPipe;
    }

    // Update the user defined clip plane data
    for( DWORD i=0; i<RD_MAX_USER_CLIPPLANES; i++ )
    {
        // Figure out if it is active
        m_Clipper.m_xfmUserClipPlanes[i].bActive =
            (BOOL)(dwClipPlanesEnable & 0x1);
        dwClipPlanesEnable >>= 1;

        // If it is active, transform it into eye-space using the
        // view transform. The clip planes are defined in the
        // world space.
        if( m_Clipper.m_xfmUserClipPlanes[i].bActive )
        {
            XformPlaneBy4x4Transposed( &(m_Clipper.m_userClipPlanes[i]),
                                       pUserClipPlaneMatrix,
                                       &(m_Clipper.m_xfmUserClipPlanes[i].plane) );
        }
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// DrawOnePrimitive
//
// Draw one clipped primitive.
//
//----------------------------------------------------------------------------
HRESULT
RefClipper::DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                              DWORD dwStartVertex,
                              D3DPRIMITIVETYPE PrimType,
                              UINT cVertices )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    DWORD dwCurrVtx = dwStartVertex;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = 0; i < (INT)cVertices; i++)
        {
            DrawPoint(&VtxArray[i]);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];

            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = &VtxArray[dwCurrVtx];

            // Disable last-pixel setting for shared verties and store prestate.
            m_pDev->StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                dwCurrVtx++;
                pV1 = &VtxArray[dwCurrVtx];
                DrawLine(pV0, pV1);
            }

            // Restore last-pixel setting.
            m_pDev->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if( i == 1 )
            {
                dwCurrVtx++;
                pV0 = &VtxArray[dwCurrVtx];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];

            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if( i > 0 )
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            RDCLIPCODE c0, c1, c2;

            pV2 = &VtxArray[dwCurrVtx++];
            // Preload initial pV0.
            pV1 = &VtxArray[dwCurrVtx++];
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DrawOneIndexedPrimitive
//
// Draw one list of clipped indexed primitives.
//
//----------------------------------------------------------------------------
HRESULT
RefClipper::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int  StartVertexIndex,
                                     LPWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    LPWORD puIndices = pIndices + StartIndex;
    DWORD dwCurrIndex;

    HRESULT hr;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawPoint( pV0 );
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            m_pDev->StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            m_pDev->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if( i == 1 )
            {
                pV0 = &VtxArray[StartVertexIndex + *puIndices];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if( i > 0 )
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

HRESULT
RefClipper::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int   StartVertexIndex,
                                     LPDWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    LPDWORD puIndices = pIndices + StartIndex;

    HRESULT hr;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            m_pDev->StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            m_pDev->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if( i == 1 )
            {
                pV0 = &VtxArray[StartVertexIndex + *puIndices];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if( i > 0 )
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR("Refrast Error: Unknown or unsupported primitive type "
               "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

void
RefClipper::DrawTriangle( RDVertex* pV0, RDVertex* pV1, RDVertex* pV2,
                          WORD wFlags )
{
    // If the clip-codes dont exist then compute them. This happens only
    // for Transformed vertices that are directly passed in to be rasterized.
    if( (pV0->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV0 );
    if( (pV1->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV1 );
    if( (pV2->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV2 );

    RDCLIPCODE c0 = pV0->m_clip;
    RDCLIPCODE c1 = pV1->m_clip;
    RDCLIPCODE c2 = pV2->m_clip;

    DWORD dwInter = (c0 & c1 & c2);
    DWORD dwUnion = (c0 | c1 | c2);
    DWORD dwMask = (UseGuardBand()) ? RDCLIPGB_ALL : RDCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if( dwInter )
    {
        return;
    }

    // If all the vertices are in, draw and return
    if( (dwUnion & dwMask) == 0 )
    {
        m_pDev->DrawTriangle( pV0, pV1, pV2, wFlags );
        return;
    }

    // Do Clipping
    RDCLIPTRIANGLE newtri;
    RDClipVertex cv[3];

    MakeClipVertexFromVertex( cv[0], *pV0, dwMask);
    MakeClipVertexFromVertex( cv[1], *pV1, dwMask);
    MakeClipVertexFromVertex( cv[2], *pV2, dwMask);

    newtri.v[0] = &cv[0]; cv[0].next = &cv[1];
    newtri.v[1] = &cv[1]; cv[1].next = &cv[2];
    newtri.v[2] = &cv[2]; cv[2].next = NULL;

    int count;
    RDClipVertex **ver;
    cv[0].m_clip |= CLIPPED_ENABLE;
    cv[1].m_clip |= CLIPPED_ENABLE;
    cv[2].m_clip |= CLIPPED_ENABLE;

    if( count = ClipSingleTriangle( &newtri, &ver ) )
    {
        int i;

        // Temporary Byte Array
        if( FAILED( ClipBuf.Grow(count) ) ) return;

        for (i = 0; i < count; i++)
        {
            MakeVertexFromClipVertex( ClipBuf[i], *(ver[i]) );
            ClipBuf[i].SetFVF( pV0->m_qwFVF );
        }

        // If it is in wireframe mode, convert the clipper output to
        // a line list.
        if( m_dwFlags & RCLIP_DO_WIREFRAME )
        {
            DWORD dwEdgeFlags = 0;
            for (i = 0; i < count; i++)
            {
                if( ver[i]->m_clip & CLIPPED_ENABLE ) dwEdgeFlags |= (1 << i);
            }

            m_pDev->DrawOneEdgeFlagTriangleFan( ClipBuf, count, dwEdgeFlags );
        }
        else
        {
            m_pDev->DrawOnePrimitive( ClipBuf, 0, D3DPT_TRIANGLEFAN, count );
        }
    }
}

void
RefClipper::DrawLine( RDVertex* pV0, RDVertex* pV1 )
{
    // If the clip-codes dont exist then compute them. This happens only
    // for Transformed vertices that are directly passed in to be rasterized.
    if( (pV0->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV0 );
    if( (pV1->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV1 );

    RDCLIPCODE c0 = pV0->m_clip;
    RDCLIPCODE c1 = pV1->m_clip;

    DWORD dwInter = (c0 & c1);
    DWORD dwUnion = (c0 | c1);
    DWORD dwMask = (UseGuardBand()) ? RDCLIPGB_ALL : RDCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if( dwInter )
    {
        return;
    }

    // If all the vertices are in, draw and return
    if( (dwUnion & dwMask) == 0 )
    {
        m_pDev->DrawLine( pV0, pV1 );
        return;
    }

    RDCLIPTRIANGLE newline;
    RDClipVertex cv[2];

    MakeClipVertexFromVertex( cv[0], *pV0, dwMask );
    MakeClipVertexFromVertex( cv[1], *pV1, dwMask );

    newline.v[0] = &cv[0];
    newline.v[1] = &cv[1];

    if( ClipSingleLine( &newline ) )
    {
        // Temporary Byte Array
        if( FAILED(ClipBuf.Grow( 2 )) ) return;
        MakeVertexFromClipVertex( ClipBuf[0], *(newline.v[0]) );
        MakeVertexFromClipVertex( ClipBuf[1], *(newline.v[1]) );
        ClipBuf[0].SetFVF( pV0->m_qwFVF );
        ClipBuf[1].SetFVF( pV0->m_qwFVF );

        m_pDev->DrawLine( &ClipBuf[0], &ClipBuf[1] );
    }
}

void
RefClipper::DrawPoint( RDVertex* pV0 )
{
    // If the clip-codes dont exist then compute them. This happens only
    // for Transformed vertices that are directly passed in to be rasterized.
    if( (pV0->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV0 );

    RDCLIPCODE c0 = pV0->m_clip;
    DWORD dwMask = (UseGuardBand()) ? RDCLIPGB_ALL : RDCLIP_ALL;

    // if definitely out
#if 0
    if( c0 & (RDCLIP_FRONT | RDCLIP_BACK |
              (1<<RDCLIPGB_LEFTBIT) | (1<<RDCLIPGB_RIGHTBIT) |
              (1<<RDCLIPGB_TOPBIT) | (1<<RDCLIPGB_BOTTOMBIT)) )
        return;
#else
    if( c0 & dwMask ) return;
#endif
    // is completely in, just draw it
    m_pDev->DrawPoint( pV0 );
}

////////////////////////////////////////////////////////////////////////////
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
////////////////////////////////////////////////////////////////////////////

int
RefClipper::ClipSingleTriangle( RDCLIPTRIANGLE *tri,
                                RDClipVertex ***clipVertexPointer )
{
    int accept;
    int i, j;
    int count;
    RDClipVertex **inv;
    RDClipVertex **outv;
    RDClipVertex *p;
    ULONG_PTR swapv;
    RDCOLOR4 diffuse1;          // Original colors
    RDCOLOR4 specular1;
    RDCOLOR4 diffuse2;
    RDCOLOR4 specular2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    if( m_dwFlags & RCLIP_DO_FLATSHADING )
    {
        // It is easier to set all vertices to the same color here
        RDCOLOR4 diffuse  = tri->v[0]->m_diffuse;
        RDCOLOR4 specular = tri->v[0]->m_specular;

        //Save original colors
        diffuse1  = tri->v[1]->m_diffuse;
        specular1 = tri->v[1]->m_specular;
        diffuse2  = tri->v[2]->m_diffuse;
        specular2 = tri->v[2]->m_specular;

        tri->v[1]->m_diffuse = diffuse;
        tri->v[1]->m_specular = specular;
        tri->v[2]->m_diffuse = diffuse;
        tri->v[2]->m_specular = specular;
    }
    accept = (tri->v[0]->m_clip | tri->v[1]->m_clip | tri->v[2]->m_clip);

    inv = tri->v;
    count = 3;
    outv = clip_vbuf1;
    clip_color = tri->v[0]->m_diffuse;
    clip_specular = tri->v[0]->m_specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)clip_vbuf1;
        tmp2 = (ULONG_PTR)clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (RDClipVertex**) (swapv - (ULONG_PTR) outv)

    if( accept & RDCLIP_FRONT )
    {
        count = ClipFront( inv, outv, count );
        if( count < 3 )
            goto out_of_here;
        SWAP(inv, outv);
    }
    if( UseGuardBand() )
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & RDCLIP_FRONT )
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RDClipVertex *p;
                p = inv[i];
                if( p->m_clip & CLIPPED_FRONT )
                    accept |= ComputeClipCodeGB( p );
                else
                    accept |= p->m_clip;
            }
        }
        if( accept & RDCLIP_BACK )
        {
            count = ClipBack( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_LEFT )
        {
            count = ClipLeftGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_RIGHT )
        {
            count = ClipRightGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_BOTTOM )
        {
            count = ClipBottomGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_TOP )
        {
            count = ClipTopGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & RDCLIP_FRONT )
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RDClipVertex *p;
                p = inv[i];
                if( p->m_clip & (CLIPPED_FRONT) )
                    accept |= ComputeClipCode( p );
                else
                    accept |= p->m_clip;
            }
        }
        if( accept & RDCLIP_BACK )
        {
            count = ClipBack( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_LEFT )
        {
            count = ClipLeft( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_RIGHT )
        {
            count = ClipRight( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_BOTTOM )
        {
            count = ClipBottom( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_TOP )
        {
            count = ClipTop( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
    }

    dwClipBit = RDCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    // User Clip Planes
    for( j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( accept & dwClipBit )
        {
            count = ClipByPlane( inv, outv, &(m_xfmUserClipPlanes[j].plane),
                                 dwClippedBit, count);
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

#undef SWAP

    ComputeScreenCoordinates( inv, count );

    *clipVertexPointer = inv;
    current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}

//-----------------------------------------------------------------------
//
int
RefClipper::ClipSingleLine( RDCLIPTRIANGLE *line )
{
    int         accept;
    int         j;
    D3DVALUE    in1, in2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    accept = (line->v[0]->m_clip | line->v[1]->m_clip);

    clip_color = line->v[0]->m_diffuse;
    clip_specular = line->v[0]->m_specular;

    if( accept & D3DCS_FRONT )
        if( ClipLineFront(line) )
            goto out_of_here;
    if( UseGuardBand() )
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & D3DCS_FRONT )
        {
            RDClipVertex * p;
            accept = 0;
            p = line->v[0];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCodeGB( p );
            else
                accept |= p->m_clip;
            p = line->v[1];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCodeGB( p );
            else
                accept |= p->m_clip;
        }
        if( accept & D3DCS_BACK )
            if( ClipLineBack( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_LEFT )
            if( ClipLineLeftGB( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_RIGHT )
            if( ClipLineRightGB( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_TOP )
            if( ClipLineTopGB( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_BOTTOM )
            if( ClipLineBottomGB( line ) )
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & D3DCS_FRONT )
        {
            RDClipVertex * p;
            accept = 0;
            p = line->v[0];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCode( p );
            else
                accept |= p->m_clip;
            p = line->v[1];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCode( p );
            else
                accept |= p->m_clip;
        }
        if( accept & D3DCS_BACK )
            if( ClipLineBack( line ) )
                goto out_of_here;
        if( accept & D3DCS_LEFT )
            if( ClipLineLeft( line ) )
                goto out_of_here;
        if( accept & D3DCS_RIGHT )
            if( ClipLineRight( line ) )
                goto out_of_here;
        if( accept & D3DCS_TOP )
            if( ClipLineTop( line ) )
                goto out_of_here;
        if( accept & D3DCS_BOTTOM )
            if( ClipLineBottom( line ) )
                goto out_of_here;
    }

    // User Clip Planes
    dwClipBit = RDCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    for( j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( accept & dwClipBit )
        {
            if( ClipLineByPlane( line, &m_xfmUserClipPlanes[j].plane,
                                 dwClippedBit ))
                goto out_of_here;
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

    ComputeScreenCoordinates( line->v, 2 );

    return 1;
out_of_here:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\clipping.hpp ===
#ifndef __CLIPPER_HPP_
#define __CLIPPER_HPP_

//----------------------------------------------------------------------------
// Clipping macros
//----------------------------------------------------------------------------
// Interpolation flags
#define RDCLIP_INTERPOLATE_COLOR       (1<< 0)
#define RDCLIP_INTERPOLATE_SPECULAR    (1<< 1)
#define RDCLIP_INTERPOLATE_TEXTURE     (1<< 2)
#define RDCLIP_INTERPOLATE_S           (1<< 3)
#define RDCLIP_INTERPOLATE_FOG         (1<< 4)

// Non guardband clipping bits
#define RDCLIP_LEFT   D3DCS_LEFT
#define RDCLIP_RIGHT  D3DCS_RIGHT
#define RDCLIP_TOP    D3DCS_TOP
#define RDCLIP_BOTTOM D3DCS_BOTTOM
#define RDCLIP_FRONT  D3DCS_FRONT
#define RDCLIP_BACK   D3DCS_BACK

//----------------------------------------------------------------------------
// User define clip plane bits.
// Each of these bits is set if the vertex is clipped by the associated
// clip plane.
//----------------------------------------------------------------------------
#define RDCLIP_USERCLIPPLANE0    D3DCS_PLANE0
#define RDCLIP_USERCLIPPLANE1    D3DCS_PLANE1
#define RDCLIP_USERCLIPPLANE2    D3DCS_PLANE2
#define RDCLIP_USERCLIPPLANE3    D3DCS_PLANE3
#define RDCLIP_USERCLIPPLANE4    D3DCS_PLANE4
#define RDCLIP_USERCLIPPLANE5    D3DCS_PLANE5
const DWORD RDCLIP_USERPLANES_ALL =  (RDCLIP_USERCLIPPLANE0 |
                                      RDCLIP_USERCLIPPLANE1 |
                                      RDCLIP_USERCLIPPLANE2 |
                                      RDCLIP_USERCLIPPLANE3 |
                                      RDCLIP_USERCLIPPLANE4 |
                                      RDCLIP_USERCLIPPLANE5 );

//---------------------------------------------------------------------
// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     RDCLIP_LEFT bit is set
// if x < -w*ax1           RDCLIPGB_LEFT bit is set
//---------------------------------------------------------------------

#define RDCLIPGB_LEFT    (RDCLIP_USERCLIPPLANE5 << 1)
#define RDCLIPGB_RIGHT   (RDCLIP_USERCLIPPLANE5 << 2)
#define RDCLIPGB_TOP     (RDCLIP_USERCLIPPLANE5 << 3)
#define RDCLIPGB_BOTTOM  (RDCLIP_USERCLIPPLANE5 << 4)




#define RDCLIP_ALL (RDCLIP_LEFT  | RDCLIP_RIGHT   |         \
                    RDCLIP_TOP   | RDCLIP_BOTTOM  |         \
                    RDCLIP_FRONT | RDCLIP_BACK    |         \
                    RDCLIP_USERPLANES_ALL)

#define RDCLIPGB_ALL (RDCLIPGB_LEFT | RDCLIPGB_RIGHT |      \
                      RDCLIPGB_TOP | RDCLIPGB_BOTTOM |      \
                      RDCLIP_FRONT | RDCLIP_BACK     |      \
                      RDCLIP_USERPLANES_ALL)

// If only these bits are set, then this point is inside the guard band
#define RDCLIP_INGUARDBAND (RDCLIP_LEFT | RDCLIP_RIGHT |    \
                            RDCLIP_TOP  | RDCLIP_BOTTOM)
//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define RDCLIP_LEFTBIT     1
#define RDCLIP_RIGHTBIT    2
#define RDCLIP_TOPBIT      3
#define RDCLIP_BOTTOMBIT   4
#define RDCLIP_FRONTBIT    5
#define RDCLIP_BACKBIT     6

#define RDCLIP_USERCLIPLANE0BIT     7
#define RDCLIP_USERCLIPLANE1BIT     8
#define RDCLIP_USERCLIPLANE2BIT     9
#define RDCLIP_USERCLIPLANE3BIT     10
#define RDCLIP_USERCLIPLANE4BIT     11
#define RDCLIP_USERCLIPLANE5BIT     12

#define RDCLIPGB_LEFTBIT   13
#define RDCLIPGB_RIGHTBIT  14
#define RDCLIPGB_TOPBIT    15
#define RDCLIPGB_BOTTOMBIT 16

#define CLIPPED_LEFT    (RDCLIP_USERCLIPPLANE5 << 1)
#define CLIPPED_RIGHT   (RDCLIP_USERCLIPPLANE5 << 2)
#define CLIPPED_TOP     (RDCLIP_USERCLIPPLANE5 << 3)
#define CLIPPED_BOTTOM  (RDCLIP_USERCLIPPLANE5 << 4)
#define CLIPPED_FRONT   (RDCLIP_USERCLIPPLANE5 << 5)
#define CLIPPED_BACK    (RDCLIP_USERCLIPPLANE5 << 6)

#define CLIPPED_ENABLE  (RDCLIP_USERCLIPPLANE5 << 7) // wireframe enable flag

#define CLIPPED_ALL (CLIPPED_LEFT|CLIPPED_RIGHT     \
             |CLIPPED_TOP|CLIPPED_BOTTOM            \
             |CLIPPED_FRONT|CLIPPED_BACK)

const DWORD CLIPPED_USERCLIPPLANE0 = RDCLIP_USERCLIPPLANE5 << 8;
const DWORD CLIPPED_USERCLIPPLANE1 = RDCLIP_USERCLIPPLANE5 << 9;
const DWORD CLIPPED_USERCLIPPLANE2 = RDCLIP_USERCLIPPLANE5 << 10;
const DWORD CLIPPED_USERCLIPPLANE3 = RDCLIP_USERCLIPPLANE5 << 11;
const DWORD CLIPPED_USERCLIPPLANE4 = RDCLIP_USERCLIPPLANE5 << 12;
const DWORD CLIPPED_USERCLIPPLANE5 = RDCLIP_USERCLIPPLANE5 << 13;


//---------------------------------------------------------------------
// Make RDVertex from clip vertex
//
// in    - clipVertex
// out   - RD vertex
//---------------------------------------------------------------------
inline void
MakeVertexFromClipVertex( RDVertex& v, RDClipVertex& cv )
{
    memcpy( &v, &cv, sizeof( RDVertex ) );
#if 0
    v.m_rhw = D3DVAL(1)/cv.m_clip_w;
#endif
}

//---------------------------------------------------------------------
// Returns TRUE if clipping is needed
//---------------------------------------------------------------------
inline BOOL
NeedClipping(BOOL bUseGB, RDCLIPCODE clipUnion)
{
    if( bUseGB && (clipUnion & ~RDCLIP_INGUARDBAND) )
    {
        return  TRUE;
    }
    else if( clipUnion )
    {
        return  TRUE;
    }

    return FALSE;
}


#endif //__CLIPPER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"

#include "clipping.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\reftnl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.cpp
//
// Direct3D Reference Transformation and Lighting  - public interface
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\procprim.cpp ===
#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Constructor:
//
//---------------------------------------------------------------------
RefVP::RefVP() : 
    m_LightArray(), 
    m_LightVertexTable()
{
    m_LightArray.SetGrowSize( 32 );

    memset( &m_Material, 0, sizeof(m_Material) );

    memset( &m_xfmProj, 0, sizeof(m_xfmProj) );
    memset( &m_xfmView, 0, sizeof(m_xfmView) );
    memset( m_xfmWorld, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );

    m_dwTLState = 0;
    m_dwDirtyFlags = 0;

    memset( m_xfmCurrent, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );
    memset( m_xfmToEye, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );
    memset( m_xfmToEyeInv, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );

    m_qwFVFIn = 0;

    m_numVertexBlends = 0;
    memset( &m_TransformData, 0, sizeof(m_TransformData) ) ;

    m_fPointSize = 0;
    m_fPointAttA = 0;
    m_fPointAttB = 0;
    m_fPointAttC = 0;
    m_fPointSizeMin = 0;
    m_fPointSizeMax = RD_MAX_POINT_SIZE;
    m_fTweenFactor = 0.0f;
    
    m_LightVertexTable.pfnDirectional = RDLV_Directional;
    m_LightVertexTable.pfnParallelPoint = RDLV_Directional;
    m_LightVertexTable.pfnSpot = RDLV_PointAndSpot;
    m_LightVertexTable.pfnPoint = RDLV_PointAndSpot;
    
    m_dwNumActiveTextureStages = 0;
    
    m_pDev = NULL;
}

//---------------------------------------------------------------------
// SetupStrides:
//---------------------------------------------------------------------
HRESULT
RefDev::SetupStrides()
{

    RDVDeclaration& Decl = m_pCurrentVShader->m_Declaration;
    
    // Null out the PtrStrides
    m_RefVP.m_position.Null();
    m_RefVP.m_position2.Null();
    m_RefVP.m_blendweights.Null();
    m_RefVP.m_blendindices.Null();
    m_RefVP.m_normal.Null();
    m_RefVP.m_normal2.Null();
    m_RefVP.m_specular.Null();
    m_RefVP.m_diffuse.Null();
    m_RefVP.m_pointsize.Null();
    for( int t = 0; t < 8 ; t++ )
        m_RefVP.m_tex[t].Null();

    for( DWORD i = 0; i < Decl.m_dwNumElements; i++ )
    {
        RDVElement& Element = Decl.m_VertexElements[i];
        RDVStream&  Stream =  m_VStream[Element.m_dwStreamIndex];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwStartVertex = m_dwStartVertex;
        
        switch( Element.m_dwRegister )
        {
        case D3DVSDE_POSITION:
            m_RefVP.m_position.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_POSITION2:
            m_RefVP.m_position2.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_BLENDWEIGHT:
            m_RefVP.m_blendweights.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_BLENDINDICES:
            // This only happens if the vertex declaration is a non-FVF one
            _ASSERT( !RDVSD_ISLEGACY( m_CurrentVShaderHandle ),
                     "FVF shader could not have provided a" 
                     "  separate blend-index" );
            m_RefVP.m_blendindices.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_NORMAL:
            m_RefVP.m_normal.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_NORMAL2:
            m_RefVP.m_normal2.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_PSIZE:
            m_RefVP.m_pointsize.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_DIFFUSE:
            m_RefVP.m_diffuse.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_SPECULAR:
            m_RefVP.m_specular.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD0:
            m_RefVP.m_tex[0].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD1:
            m_RefVP.m_tex[1].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD2:
            m_RefVP.m_tex[2].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD3:
            m_RefVP.m_tex[3].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD4:
            m_RefVP.m_tex[4].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD5:
            m_RefVP.m_tex[5].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD6:
            m_RefVP.m_tex[6].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD7:
            m_RefVP.m_tex[7].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        }
    }
    
    // If it is a FVF vertex shader and index-vertex blending is enabled
    // then the blend-indices are found in the last beta (which is the blend 
    // weight) of the vertex.
    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) && 
        (m_RefVP.m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND) )
    {
        m_RefVP.m_blendindices.Init(
            (float *)m_RefVP.m_blendweights.GetFirst() + 
            m_RefVP.m_numVertexBlends,
            m_RefVP.m_blendweights.GetStride() );
    }
    
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Process primitives implementation:
// 1) Compute FVF info
// 2) Grow buffers to the requisite size
// 3) Initialize clipping state
// 4) Update T&L state
// 5) Transform, Light and compute clipping for vertices
// 6) Clip and Draw the primitives
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
RefDev::ProcessPrimitive( D3DPRIMITIVETYPE PrimType,
                          DWORD StartVertex,
                          DWORD cVertices,
                          DWORD StartIndex,
                          DWORD cIndices )
{
    HRESULT hr = D3D_OK;
    DWORD dwVertexPoolSize = 0;

    // Save Prim Type for later use
    m_primType      = PrimType;
    m_dwNumVertices = cVertices;
    m_dwStartVertex = StartVertex;
    m_dwNumIndices  = cIndices;
    m_dwStartIndex  = StartIndex;

    //
    // Update T&L state (must be before FVFData is set up)
    //

    // Update Lighting and related state and flags and computes Output FVF
    HR_RET( UpdateTLState() );

    //
    // Clipping information depends both on the output FVF computation
    // and the other State, so do it here after both have been computed
    //
    HR_RET( UpdateClipper() );

    //
    // Grow TLVArray if required
    //
    if( FAILED( m_TLVArray.Grow( m_dwNumVertices ) ) )
    {
        DPFERR( "Could not grow TL vertex buffer" );
        return DDERR_OUTOFMEMORY;
    }

    //
    // Transform, Light and compute clipping for vertices
    //
    DWORD clipIntersection = m_RefVP.ProcessVertices( m_qwFVFOut, m_TLVArray, 
                                                      m_dwNumVertices );

    if( m_primType == D3DPT_POINTLIST )
    {
        // We clip points by Z planes and user clip planes, because point 
        // sprites could be still visible when a point is outside X or Y plane
        clipIntersection &= ~(RDCLIP_LEFT | RDCLIP_RIGHT | 
                              RDCLIP_TOP | RDCLIP_BOTTOM |
                              RDCLIPGB_ALL);

    }

    if( clipIntersection )
    {
        // If the entire primitive lies outside the view frustum, quit
        // without drawing
        return D3D_OK;
    }

    //
    // Clip and Draw the primitives
    //
    if( m_dwNumIndices )
    {
        if( !NeedClipping(m_Clipper.UseGuardBand(), m_Clipper.m_clipUnion) )
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
        else
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = m_Clipper.DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = m_Clipper.DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
    }
    else
    {
        if( !NeedClipping((m_Clipper.UseGuardBand()), m_Clipper.m_clipUnion) )
        {
            hr = DrawOnePrimitive( 
                m_TLVArray, 
                0, 
                m_primType, 
                m_dwNumVertices );
        }
        else
        {
            hr = m_Clipper.DrawOnePrimitive( 
                m_TLVArray, 
                0,
                m_primType, 
                m_dwNumVertices );
        }
    }

    return hr;
}



//---------------------------------------------------------------------
// RefDev::UpdateTLState
//             Updates transform and lighting related state
//---------------------------------------------------------------------
HRESULT
RefDev::UpdateTLState()
{
    HRESULT hr = D3D_OK;
    UINT64 qwFVFIn = m_RefVP.m_qwFVFIn;
    
    //
    // Sort out vertex blending.
    //

    // Total number of floats/dwords provided per vertex according to
    // the FVF.
    DWORD numBetas = 0;
    if( (qwFVFIn & D3DFVF_POSITION_MASK) != 
        (D3DFVF_XYZ & D3DFVF_POSITION_MASK) )
        numBetas   = ((qwFVFIn & D3DFVF_POSITION_MASK) >> 1) - 2;
    DWORD numWeights = GetRS()[D3DRENDERSTATE_VERTEXBLEND];

    // If tweening is enabled, there better be Position2 or Normal2
    if( numWeights == D3DVBF_TWEENING ) 
    {
        if( (qwFVFIn & (D3DFVFP_POSITION2 | D3DFVFP_NORMAL2)) == 0 )
        {
            DPFERR( "Tweening is enabled, but there is neither position2"
                    " nor normal2 available\n" );
            return E_FAIL;
        }
        if( qwFVFIn & D3DFVFP_POSITION2 )
            m_RefVP.m_dwTLState |= RDPV_DOPOSITIONTWEENING;
        if( qwFVFIn & D3DFVFP_NORMAL2 )
            m_RefVP.m_dwTLState |= RDPV_DONORMALTWEENING;
        
        numWeights = 0;
    }
    else
    {
        m_RefVP.m_dwTLState &= ~(RDPV_DOPOSITIONTWEENING | 
                                 RDPV_DONORMALTWEENING);
    }
    
    if( numWeights == D3DVBF_DISABLE ) 
        m_RefVP.m_dwTLState &= ~RDPV_DOINDEXEDVERTEXBLEND;
    if( numWeights == D3DVBF_0WEIGHTS ) numWeights = 0;
    if( m_RefVP.m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND )
    {
        // If it is a FVF shader (legacy) the blend indices are provided as
        // the betas. There should be enough betas to cover this.
        if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) && 
            (numBetas < (numWeights + 1)) )
        {
            DPFERR( "Not enough blend-weights to do indexed vertex blending" );
            return E_FAIL;
        }
        else if( !RDVSD_ISLEGACY( m_CurrentVShaderHandle ) && 
                 ((qwFVFIn & D3DFVFP_BLENDINDICES) == 0) )
        {
            DPFERR( "Blend-indices not provided" );
            return E_FAIL;
        }
    }
    else if( numWeights )
    {
        if( numBetas < numWeights )
        {
            DPFERR( "Not enough blend-weights to do vertex blending" );
            return E_FAIL;
        }
    }
    m_RefVP.m_numVertexBlends = numWeights;
    
    
    //
    // Check prim type to see if point size computation is needed
    // Need to set this before the transform state is set
    //
    m_RefVP.m_dwTLState &= ~(RDPV_DOCOMPUTEPOINTSIZE | RDPV_DOPOINTSCALE);
    switch(m_primType)
    {
    case D3DPT_POINTLIST:
        m_RefVP.m_dwTLState |= RDPV_DOCOMPUTEPOINTSIZE;
        if( GetRS()[D3DRS_POINTSCALEENABLE] )
            m_RefVP.m_dwTLState |= RDPV_DOPOINTSCALE;
        break;
    }

    // Fog or not:
    // Compute fog if: 1) Fogging is enabled
    //                 2) VertexFog mode is not FOG_NONE
    //                 3) TableFog mode is FOG_NONE
    // If both table and vertex fog are not FOG_NONE, table fog
    // is applied.
    if( GetRS()[D3DRENDERSTATE_FOGENABLE] &&
        GetRS()[D3DRENDERSTATE_FOGVERTEXMODE] &&
        !GetRS()[D3DRENDERSTATE_FOGTABLEMODE] )
    {
        m_RefVP.m_dwTLState |= RDPV_DOFOG;
        // Range Fog
        if( GetRS()[D3DRENDERSTATE_RANGEFOGENABLE] )
        {
            m_RefVP.m_dwTLState |= RDPV_RANGEFOG;
        }
        else
        {
            m_RefVP.m_dwTLState &= ~RDPV_RANGEFOG;
        }
    }
    else
    {
        m_RefVP.m_dwTLState &= ~(RDPV_DOFOG | RDPV_RANGEFOG);
    }

    // 
    // Evaluate if any texture transform/gen is required. If so, then compute
    // the output Texture Coordinates
    //
    UpdateActiveTexStageCount();
    m_RefVP.m_dwNumActiveTextureStages = m_cActiveTextureStages;
    m_RefVP.m_dwTLState &= ~(RDPV_DOTEXGEN | RDPV_DOTEXXFORM | 
                             RDPV_NEEDEYENORMAL | RDPV_NEEDEYEXYZ);
    for(  DWORD dwStage=0; dwStage<(DWORD)m_cActiveTextureStages; dwStage++  )
    {
        if( (GetTSS(dwStage)[D3DTSS_TEXTURETRANSFORMFLAGS] 
             & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE )
        {
            m_RefVP.m_dwTLState |= RDPV_DOTEXXFORM;
        }
        
        if( GetTSS(dwStage)[D3DTSS_TEXCOORDINDEX] & 0xffff0000 )
        {
            m_RefVP.m_dwTLState |= RDPV_DOTEXGEN;
        }
    }

    // Something changed in the transformation state
    // Recompute digested transform state
    HR_RET(m_RefVP.UpdateXformData());

    // Something changed in the lighting state
    if( (m_RefVP.m_dwTLState & RDPV_DOLIGHTING) &&
        (m_RefVP.m_dwDirtyFlags & RDPV_DIRTY_LIGHTING) )
    {
        RDLIGHTINGDATA& LData = m_RefVP.m_lighting;
        
        //
        // Compute Colorvertex flags only if the lighting is enabled
        //
        m_RefVP.m_dwTLState &= ~RDPV_COLORVERTEXFLAGS;
        LData.pAmbientSrc = &LData.matAmb;
        LData.pDiffuseSrc = &LData.matDiff;
        LData.pSpecularSrc = &LData.matSpec;
        LData.pEmissiveSrc = &LData.matEmis;
        LData.pDiffuseAlphaSrc = &LData.materialDiffAlpha;
        LData.pSpecularAlphaSrc = &LData.materialSpecAlpha;
        if( GetRS()[D3DRENDERSTATE_COLORVERTEX] )
        {
            switch( GetRS()[D3DRENDERSTATE_AMBIENTMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXAMB);
                        LData.pAmbientSrc = &LData.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXAMB);
                        LData.pAmbientSrc = &LData.vertexSpecular;
                    }
                }
                break;
            }

            switch( GetRS()[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXDIFF);
                        LData.pDiffuseSrc = &LData.vertexDiffuse;
                        LData.pDiffuseAlphaSrc =
                            &LData.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXDIFF);
                        LData.pDiffuseSrc = &LData.vertexSpecular;
                        LData.pDiffuseAlphaSrc =
                            &LData.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRS()[D3DRENDERSTATE_SPECULARMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXSPEC);
                        LData.pSpecularSrc = &LData.vertexDiffuse;
                        LData.pSpecularAlphaSrc =
                            &LData.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXSPEC);
                        LData.pSpecularSrc = &LData.vertexSpecular;
                        LData.pSpecularAlphaSrc =
                            &LData.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRS()[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXEMIS);
                        LData.pEmissiveSrc = &LData.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXEMIS);
                        LData.pEmissiveSrc = &LData.vertexSpecular;
                    }
                }
                break;
            }
        }

        // If specular is needed in the output and has been provided
        // in the input, force the copy of specular data
        if( qwFVFIn & D3DFVF_SPECULAR )
        {
            m_RefVP.m_dwTLState |= RDPV_VERTEXSPECULARNEEDED;
        }

        //
        // Update the remaining light state
        //
        HR_RET(m_RefVP.UpdateLightingData());
    }

    if( (m_RefVP.m_dwTLState & RDPV_DOFOG) &&
        (m_RefVP.m_dwDirtyFlags & RDPV_DIRTY_FOG) )
    {
        HR_RET(m_RefVP.UpdateFogData());
    }

    //
    // Compute output FVF
    //

    BOOL bFogEnabled = GetRS()[D3DRENDERSTATE_FOGENABLE];
    BOOL bSpecularEnabled = GetRS()[D3DRENDERSTATE_SPECULARENABLE];
    m_qwFVFOut = D3DFVF_XYZRHW;

    // If normal is present we have to compute specular and diffuse
    // Otherwise set these bits the same as input.
    // Not that normal should not be present for XYZRHW position type
    if( m_RefVP.m_dwTLState & RDPV_DOLIGHTING )
    {
        m_qwFVFOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        m_qwFVFOut |= (qwFVFIn & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR));
    }

    // Clear specular flag if specular disabled
    // else if( !this->rstates[D3DRENDERSTATE_SPECULARENABLE] )
    if( !bSpecularEnabled && ((qwFVFIn & D3DFVF_SPECULAR) == 0))
    {
        m_qwFVFOut &= ~D3DFVF_SPECULAR;
    }

    // Always set specular flag if fog is enabled
    // if( this->rstates[D3DRENDERSTATE_FOGENABLE] )
    if( bFogEnabled && (!GetRS()[D3DRENDERSTATE_FOGTABLEMODE]) )
    {
        m_qwFVFOut |= D3DFVFP_FOG;
    }

    // Reserve space for point size, if needed
    if( m_RefVP.m_dwTLState & RDPV_DOCOMPUTEPOINTSIZE )
    {
        m_qwFVFOut |= D3DFVF_PSIZE;
    }

    if( m_RefVP.m_dwTLState & (RDPV_DOTEXGEN | RDPV_DOTEXXFORM) )
    {
        // If there was any need for TexTransform or TexGen, we need to 
        // override the TCI per stage.
        m_bOverrideTCI = TRUE;
        m_qwFVFOut |= (m_cActiveTextureStages << D3DFVF_TEXCOUNT_SHIFT);

        // Now compute the texture formats
        for( dwStage = 0; dwStage < (DWORD)m_cActiveTextureStages; dwStage++ )
        {
            DWORD dwTextureFormat = 0;
            DWORD TCI = GetTSS(dwStage)[D3DTSS_TEXCOORDINDEX];
            DWORD TexGenMode = TCI & ~0xFFFF;
            TCI &= 0xFFFF;
            switch( TexGenMode )
            {
            case D3DTSS_TCI_CAMERASPACENORMAL:
                dwTextureFormat = D3DFVF_TEXCOORDSIZE3(dwStage);
                m_RefVP.m_dwTLState |= RDPV_NEEDEYENORMAL;
                break;
            case D3DTSS_TCI_CAMERASPACEPOSITION:
                dwTextureFormat = D3DFVF_TEXCOORDSIZE3(dwStage);
                m_RefVP.m_dwTLState |= RDPV_NEEDEYEXYZ;
                break;
            case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                dwTextureFormat = D3DFVF_TEXCOORDSIZE3(dwStage);
                m_RefVP.m_dwTLState |= (RDPV_NEEDEYENORMAL | RDPV_NEEDEYEXYZ);
                break;
            case 0: // No TexGen
                // Set back the input texture format
                dwTextureFormat = 
                    (D3DFVF_GETTEXCOORDSIZE( qwFVFIn, TCI ) << (dwStage*2 + 16));
                break;
            default:
                DPFERR( "Unknown TexGen mode" );
                return E_FAIL;
            }

            // Adjust the format for TexTransform
            DWORD TexXfmFlags = 
                GetTSS(dwStage)[D3DTSS_TEXTURETRANSFORMFLAGS];
            if( TexXfmFlags )
            {
                switch( TexXfmFlags & ~D3DTTFF_PROJECTED )
                {
                case D3DTTFF_DISABLE:
                    break;
                case D3DTTFF_COUNT1:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE1( dwStage );
                    break;
                case D3DTTFF_COUNT2:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE2( dwStage );
                    break;
                case D3DTTFF_COUNT3:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE3( dwStage );
                    break;
                case D3DTTFF_COUNT4:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE4( dwStage );
                    break;
                default:
                    DPFERR( "Unknown dimension" );
                    return E_FAIL;
                }
            }
            m_qwFVFOut |= dwTextureFormat;
        }
    }
    else
    {
        // Set up number of texture coordinates and copy texture formats
        DWORD numTex = FVF_TEXCOORD_NUMBER(qwFVFIn);
        m_qwFVFOut |= (numTex << D3DFVF_TEXCOUNT_SHIFT) |
            (qwFVFIn & 0xFFFF0000);
    }
    
    m_RefVP.m_qwFVFOut = m_qwFVFOut;
    
    //
    // Set up the strides for the vertex processing
    //
    return SetupStrides();
}

///////////////////////////////////////////////////////////////////////////////
// RefVP method implementations
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RefVP::ProcessVertices
//---------------------------------------------------------------------
RDCLIPCODE
RefVP::ProcessVertices( UINT64 outFVF, GArrayT<RDVertex>& VtxArray, 
                        DWORD count )
{
    UINT64      inFVF = m_qwFVFIn;
    RefClipper& Clipper = m_pDev->GetClipper();
    DWORD       flags = m_dwTLState;
    RDCLIPCODE  clipIntersection = ~0;
    RDCLIPCODE  clipUnion = 0;
    RDLIGHTINGELEMENT le;
    BOOL bVertexInEyeSpace = FALSE;
    DWORD       dwCurrVtx = 0;
    RDVECTOR3*  pPos = (RDVECTOR3 *)m_position.GetFirst();
    RDVECTOR3*  pPos2 = (RDVECTOR3 *)m_position2.GetFirst();
    float*      pBlendFactors = (float *)m_blendweights.GetFirst();
    DWORD*      pBlendIndices = (DWORD *)m_blendindices.GetFirst();
    RDVECTOR3*  pNormal = (RDVECTOR3 *)m_normal.GetFirst();
    RDVECTOR3*  pNormal2 = (RDVECTOR3 *)m_normal2.GetFirst();
    DWORD*      pDiffuse = (DWORD *)m_diffuse.GetFirst();
    DWORD*      pSpecular = (DWORD *)m_specular.GetFirst();
    float*      pPointSize = (float *)m_pointsize.GetFirst();
    float*      pTex[8];
    RDVECTOR3 positionT, normalT; // Tweening results are saved here
    
    for( int t = 0; t < 8 ; t++ )
        pTex[t] = (float *)m_tex[t].GetFirst();

    //
    // Number of vertices to blend. i.e number of blend-matrices to
    // use is numVertexBlends+1.
    //
    int numVertexBlends = m_numVertexBlends;
    m_lighting.outDiffuse  = RD_DEFAULT_DIFFUSE;
    m_lighting.outSpecular = RD_DEFAULT_SPECULAR;

    //
    // The main transform loop
    //
    for( DWORD i = count; i; i-- )
    {
        RDVertex& Vout = VtxArray[dwCurrVtx++];
        Vout.SetFVF( outFVF | D3DFVFP_CLIP );
        float x_clip=0.0f, y_clip=0.0f, z_clip=0.0f, w_clip=0.0f;
        float inv_w_clip=0.0f;
        float cumulBlend = 0; // Blend accumulated so far
        ZeroMemory( &le, sizeof(RDLIGHTINGELEMENT) );
        RDVECTOR3 ZeroNormal;
        if( pNormal == NULL )
        {
            pNormal = &ZeroNormal;
        }
                
        //
        // Transform vertex to the clipping space, and position and normal
        // into eye space, if needed.
        //

        // Tween the Position if needed
        if( flags & RDPV_DOPOSITIONTWEENING )
        {
            positionT.x = pPos->x * (1.0f - m_fTweenFactor) + 
                pPos2->x * m_fTweenFactor;
            positionT.y = pPos->y * (1.0f - m_fTweenFactor) + 
                pPos2->y * m_fTweenFactor;
            positionT.z = pPos->z * (1.0f - m_fTweenFactor) + 
                pPos2->z * m_fTweenFactor;

            pPos = &positionT;
        }
        
        if( flags & RDPV_DONORMALTWEENING )
        {
            normalT.x = pNormal->x * (1.0f - m_fTweenFactor) + 
                pNormal2->x * m_fTweenFactor;
            normalT.y = pNormal->y * (1.0f - m_fTweenFactor) + 
                pNormal2->y * m_fTweenFactor;
            normalT.z = pNormal->z * (1.0f - m_fTweenFactor) + 
                pNormal2->z * m_fTweenFactor;

            pNormal = &normalT;
        }
        
        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }

            if( flags & (RDPV_DOCOMPUTEPOINTSIZE | RDPV_DOLIGHTING |
                         RDPV_NEEDEYEXYZ) )
            {
                bVertexInEyeSpace = TRUE;
                if( flags & RDPV_DOINDEXEDVERTEXBLEND )
                {
                    BYTE m = ((BYTE *)pBlendIndices)[j];
                    UpdateWorld( m );
                    le.dvPosition.x += (pPos->x*m_xfmToEye[m]._11 +
                                        pPos->y*m_xfmToEye[m]._21 +
                                        pPos->z*m_xfmToEye[m]._31 +
                                        m_xfmToEye[m]._41) * blend;
                    le.dvPosition.y += (pPos->x*m_xfmToEye[m]._12 +
                                        pPos->y*m_xfmToEye[m]._22 +
                                        pPos->z*m_xfmToEye[m]._32 +
                                        m_xfmToEye[m]._42) * blend;
                    le.dvPosition.z += (pPos->x*m_xfmToEye[m]._13 +
                                        pPos->y*m_xfmToEye[m]._23 +
                                        pPos->z*m_xfmToEye[m]._33 +
                                        m_xfmToEye[m]._43) * blend;
                }
                else
                {
                    le.dvPosition.x += (pPos->x*m_xfmToEye[j]._11 +
                                        pPos->y*m_xfmToEye[j]._21 +
                                        pPos->z*m_xfmToEye[j]._31 +
                                        m_xfmToEye[j]._41) * blend;
                    le.dvPosition.y += (pPos->x*m_xfmToEye[j]._12 +
                                        pPos->y*m_xfmToEye[j]._22 +
                                        pPos->z*m_xfmToEye[j]._32 +
                                        m_xfmToEye[j]._42) * blend;
                    le.dvPosition.z += (pPos->x*m_xfmToEye[j]._13 +
                                        pPos->y*m_xfmToEye[j]._23 +
                                        pPos->z*m_xfmToEye[j]._33 +
                                        m_xfmToEye[j]._43) * blend;
                }
            }

            if( flags & (RDPV_DOLIGHTING | RDPV_NEEDEYENORMAL) )
            {
                if( flags & RDPV_DOINDEXEDVERTEXBLEND )
                {
                    BYTE m = ((BYTE *)pBlendIndices)[j];
                    UpdateWorld( m );
                    le.dvNormal.x += (pNormal->x*m_xfmToEyeInv[m]._11 +
                                      pNormal->y*m_xfmToEyeInv[m]._12 +
                                      pNormal->z*m_xfmToEyeInv[m]._13) * blend;
                    le.dvNormal.y += (pNormal->x*m_xfmToEyeInv[m]._21 +
                                      pNormal->y*m_xfmToEyeInv[m]._22 +
                                      pNormal->z*m_xfmToEyeInv[m]._23) * blend;
                    le.dvNormal.z += (pNormal->x*m_xfmToEyeInv[m]._31 +
                                      pNormal->y*m_xfmToEyeInv[m]._32 +
                                      pNormal->z*m_xfmToEyeInv[m]._33) * blend;
                }
                else
                {
                    // Transform vertex normal to the eye space
                    // We use inverse transposed matrix
                    le.dvNormal.x += (pNormal->x*m_xfmToEyeInv[j]._11 +
                                      pNormal->y*m_xfmToEyeInv[j]._12 +
                                      pNormal->z*m_xfmToEyeInv[j]._13) * blend;
                    le.dvNormal.y += (pNormal->x*m_xfmToEyeInv[j]._21 +
                                      pNormal->y*m_xfmToEyeInv[j]._22 +
                                      pNormal->z*m_xfmToEyeInv[j]._23) * blend;
                    le.dvNormal.z += (pNormal->x*m_xfmToEyeInv[j]._31 +
                                      pNormal->y*m_xfmToEyeInv[j]._32 +
                                      pNormal->z*m_xfmToEyeInv[j]._33) * blend;
                }
            }

            if( flags & RDPV_DOINDEXEDVERTEXBLEND )
            {
                BYTE m = ((BYTE *)pBlendIndices)[j];
                UpdateWorld( m );
                x_clip += (pPos->x*m_xfmCurrent[m]._11 +
                           pPos->y*m_xfmCurrent[m]._21 +
                           pPos->z*m_xfmCurrent[m]._31 +
                           m_xfmCurrent[m]._41) * blend;
                y_clip += (pPos->x*m_xfmCurrent[m]._12 +
                           pPos->y*m_xfmCurrent[m]._22 +
                           pPos->z*m_xfmCurrent[m]._32 +
                           m_xfmCurrent[m]._42) * blend;
                z_clip += (pPos->x*m_xfmCurrent[m]._13 +
                           pPos->y*m_xfmCurrent[m]._23 +
                           pPos->z*m_xfmCurrent[m]._33 +
                           m_xfmCurrent[m]._43) * blend;
                w_clip += (pPos->x*m_xfmCurrent[m]._14 +
                           pPos->y*m_xfmCurrent[m]._24 +
                           pPos->z*m_xfmCurrent[m]._34 +
                           m_xfmCurrent[m]._44) * blend;
            }
            else
            {
                // Apply WORLDj
                x_clip += (pPos->x*m_xfmCurrent[j]._11 +
                           pPos->y*m_xfmCurrent[j]._21 +
                           pPos->z*m_xfmCurrent[j]._31 +
                           m_xfmCurrent[j]._41) * blend;
                y_clip += (pPos->x*m_xfmCurrent[j]._12 +
                           pPos->y*m_xfmCurrent[j]._22 +
                           pPos->z*m_xfmCurrent[j]._32 +
                           m_xfmCurrent[j]._42) * blend;
                z_clip += (pPos->x*m_xfmCurrent[j]._13 +
                           pPos->y*m_xfmCurrent[j]._23 +
                           pPos->z*m_xfmCurrent[j]._33 +
                           m_xfmCurrent[j]._43) * blend;
                w_clip += (pPos->x*m_xfmCurrent[j]._14 +
                           pPos->y*m_xfmCurrent[j]._24 +
                           pPos->z*m_xfmCurrent[j]._34 +
                           m_xfmCurrent[j]._44) * blend;
            }
        }

        // Save the clip-coordinates
        Vout.m_clip_x = x_clip;
        Vout.m_clip_y = y_clip;
        Vout.m_clip_z = z_clip;
        Vout.m_clip_w = w_clip;
        
        if( (flags & RDPV_NORMALIZENORMALS) && 
            (flags & (RDPV_DOLIGHTING | RDPV_NEEDEYENORMAL)) )
        {
            Normalize(le.dvNormal);
        }

        FLOAT fPointSize = 0.0f;
        if( flags & RDPV_DOCOMPUTEPOINTSIZE )
        {
            FLOAT fDist = (FLOAT)sqrt(le.dvPosition.x*le.dvPosition.x +
                                      le.dvPosition.y*le.dvPosition.y +
                                      le.dvPosition.z*le.dvPosition.z);
            if( inFVF & D3DFVF_PSIZE )
            {
                fPointSize = *pPointSize;
            }
            else
            {
                // from D3DRENDERSTATE_POINTSIZE
                fPointSize = m_fPointSize;
            }
            if( flags & RDPV_DOPOINTSCALE )
            {
                fPointSize = (float)Clipper.m_Viewport.dwHeight*
                    fPointSize*(FLOAT)sqrt(1.0f/
                                           (m_fPointAttA + m_fPointAttB*fDist +
                                            m_fPointAttC*fDist*fDist));
            }
            
            fPointSize = max(m_fPointSizeMin, fPointSize);
            fPointSize = min(m_fPointSizeMax, fPointSize);
            FLOAT *pfSOut = &Vout.m_pointsize;
            *pfSOut = fPointSize;
        }

        //
        // Compute clip codes if needed
        //
        if( flags & RDPV_DOCLIPPING )
        {
            RDCLIPCODE clip = Clipper.ComputeClipCodes( &clipIntersection, 
                                                        &clipUnion, x_clip, 
                                                        y_clip, z_clip, 
                                                        w_clip);
            if( clip == 0 )
            {
                Vout.m_clip = 0;
                inv_w_clip = D3DVAL(1)/w_clip;
            }
            else
            {
                if( Clipper.UseGuardBand() )
                {
                    if( (clip & ~RDCLIP_INGUARDBAND) == 0 )
                    {
                        // If vertex is inside the guardband we have to compute
                        // screen coordinates
                        inv_w_clip = D3DVAL(1)/w_clip;
                        Vout.m_clip = (RDCLIPCODE)clip;
                        goto l_DoScreenCoord;
                    }
                }
                Vout.m_clip = (RDCLIPCODE)clip;
                // If vertex is outside the frustum we can not compute screen
                // coordinates. skip to lighting
#if 0
                Vout.m_pos.x = x_clip;
                Vout.m_pos.y = y_clip;
                Vout.m_pos.z = z_clip;
                Vout.m_rhw   = w_clip;
#endif
                goto l_DoLighting;
            }
        }
        else
        {
            // We have to check this only for DONOTCLIP case, because otherwise
            // the vertex with "we = 0" will be clipped and screen coordinates
            // will not be computed
            // "clip" is not zero, if "we" is zero.
            if( !FLOAT_EQZ(w_clip) )
                inv_w_clip = D3DVAL(1)/w_clip;
            else
                inv_w_clip = __HUGE_PWR2;
        }

l_DoScreenCoord:

        Vout.m_pos.x = x_clip * inv_w_clip * Clipper.scaleX +
            Clipper.offsetX;
        Vout.m_pos.y = y_clip * inv_w_clip * Clipper.scaleY +
            Clipper.offsetY;
        Vout.m_pos.z = z_clip * inv_w_clip * Clipper.scaleZ +
            Clipper.offsetZ;
        Vout.m_rhw = inv_w_clip;

l_DoLighting:

        if( flags & RDPV_DOLIGHTING )
        {
            bVertexInEyeSpace = TRUE;

            //
            // If Diffuse color is needed, extract it for color vertex.
            //
            if( flags & RDPV_VERTEXDIFFUSENEEDED )
            {
                const DWORD color = *pDiffuse;
                MakeRDCOLOR3(&m_lighting.vertexDiffuse, color);
                m_lighting.vertexDiffAlpha = color & 0xff000000;
            }

            //
            // If Specular color is needed and provided
            // , extract it for color vertex.
            //
            if( flags & RDPV_VERTEXSPECULARNEEDED )
            {
                const DWORD color = *pSpecular;
                MakeRDCOLOR3(&m_lighting.vertexSpecular, color);
                m_lighting.vertexSpecAlpha = color & 0xff000000;
            }

            //
            // Light the vertex
            //
            LightVertex( &le );

            if( outFVF & D3DFVFP_FOG )
            {
                Vout.m_fog = 
                    (FLOAT)RGBA_GETALPHA( *(m_lighting.pSpecularAlphaSrc) )/255.0f;
            }
        }
        else if( inFVF & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR) )
        {
            if( inFVF & D3DFVF_DIFFUSE )
                m_lighting.outDiffuse = *pDiffuse;
            if( inFVF & D3DFVF_SPECULAR )
            {
                m_lighting.outSpecular = *pSpecular;
                if( outFVF & D3DFVFP_FOG )
                {
                    Vout.m_fog = (FLOAT)RGBA_GETALPHA( *pSpecular )/255.0f;
                }
            }
        }

        //
        // Compute Vertex Fog if needed
        //
        if( flags & RDPV_DOFOG )
        {
            FogVertex( Vout, *pPos, &le,  numVertexBlends,
                       pBlendFactors, bVertexInEyeSpace );
        }

        if( outFVF & D3DFVF_DIFFUSE )
        {
            MakeRDCOLOR4( &Vout.m_diffuse, m_lighting.outDiffuse );
        }
        if( outFVF & D3DFVF_SPECULAR )
        {
            MakeRDCOLOR4( &Vout.m_specular, m_lighting.outSpecular );
        }

        if( flags & (RDPV_DOTEXGEN | RDPV_DOTEXXFORM) )
        {
            for( DWORD dwStage = 0; 
                 dwStage < m_dwNumActiveTextureStages; 
                 dwStage++ )
            {
                DWORD TexXfmFlags = 
                    m_pDev->GetTSS(dwStage)[D3DTSS_TEXTURETRANSFORMFLAGS];
                DWORD TCI = 
                    m_pDev->GetTSS(dwStage)[D3DTSS_TEXCOORDINDEX];
                DWORD TexGenMode = TCI & ~0xFFFF;
                TCI &= 0xFFFF;

                // Perform TexGen
                switch( TexGenMode )
                {
                case D3DTSS_TCI_CAMERASPACENORMAL:
                    Vout.m_tex[dwStage].x = le.dvNormal.x;
                    Vout.m_tex[dwStage].y = le.dvNormal.y;
                    Vout.m_tex[dwStage].z = le.dvNormal.z;
                    Vout.m_tex[dwStage].w = 1.0f;
                    break;
                case D3DTSS_TCI_CAMERASPACEPOSITION:
                    Vout.m_tex[dwStage].x = le.dvPosition.x;
                    Vout.m_tex[dwStage].y = le.dvPosition.y;
                    Vout.m_tex[dwStage].z = le.dvPosition.z;
                    Vout.m_tex[dwStage].w = 1.0f;
                    break;
                case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                {
                    FLOAT fNX = le.dvNormal.x;
                    FLOAT fNY = le.dvNormal.y;
                    FLOAT fNZ = le.dvNormal.z;
                    FLOAT fNorm = 0;
                            
                    if( m_pDev->GetRS()[D3DRENDERSTATE_LOCALVIEWER] == TRUE )
                    {
                        FLOAT fX = le.dvPosition.x;
                        FLOAT fY = le.dvPosition.y;
                        FLOAT fZ = le.dvPosition.z;
                        
                        // have to normalize before we reflect, 
                        // result will be normalized
                        FLOAT fDist = (FLOAT)sqrt(fX*fX + fY*fY + fZ*fZ);
                        if( FLOAT_NEZ( fDist ) )
                        {
                            fNorm = 1.0f/fDist;
                        }
                        fX *= fNorm; fY *= fNorm; fZ *= fNorm;
                        FLOAT fDot2 = 2.0f*(fX*fNX + fY*fNY + fZ*fNZ);
                        Vout.m_tex[dwStage].x = fX - fNX*fDot2;
                        Vout.m_tex[dwStage].y = fY - fNY*fDot2;
                        Vout.m_tex[dwStage].z = fZ - fNZ*fDot2;
                    }
                    else
                    {
                        FLOAT fDot2 = 2.0f*fNZ;
                        Vout.m_tex[dwStage].x = -fNX*fDot2;
                        Vout.m_tex[dwStage].y = -fNY*fDot2;
                        Vout.m_tex[dwStage].z = 1.f - fNZ*fDot2;
                    }
                    Vout.m_tex[dwStage].w = 1.0f;
                    break;
                }
                case 0: // No TexGen
                {
                    // Copy the tex coordinate for this stage
                    DWORD n = GetTexCoordDim( inFVF, TCI );
                    float *pCoord = (float *)&Vout.m_tex[dwStage];
                    for( DWORD j = 0; j < n; j++ )
                    {
                        pCoord[j] = pTex[TCI][j];
                    }
                    if( n < 4 ) pCoord[n] = 1.0f;
                    for( j = n+1; j < 4; j++ ) pCoord[j] = 0.0f;
                    break;
                }
                default:
                    DPFERR( "Unknown TexGen mode" );
                    return E_FAIL;
                }

                // Perform TexTransform
                if( ( TexXfmFlags & ~D3DTTFF_PROJECTED ) != D3DTTFF_DISABLE ) 
                {
                    LPD3DMATRIX pM = &m_xfmTex[dwStage];
                    FLOAT fX = Vout.m_tex[dwStage].x;
                    FLOAT fY = Vout.m_tex[dwStage].y;
                    FLOAT fZ = Vout.m_tex[dwStage].z;
                    FLOAT fW = Vout.m_tex[dwStage].w;
                    FLOAT fXout = fX*pM->_11 + fY*pM->_21 + fZ*pM->_31 + 
                        fW*pM->_41;
                    FLOAT fYout = fX*pM->_12 + fY*pM->_22 + fZ*pM->_32 + 
                        fW*pM->_42;
                    FLOAT fZout = fX*pM->_13 + fY*pM->_23 + fZ*pM->_33 + 
                        fW*pM->_43;
                    FLOAT fWout = fX*pM->_14 + fY*pM->_24 + fZ*pM->_34 + 
                        fW*pM->_44;
                    
                    Vout.m_tex[dwStage].x = fXout;
                    Vout.m_tex[dwStage].y = fYout;
                    Vout.m_tex[dwStage].z = fZout;
                    Vout.m_tex[dwStage].w = fWout;
                }
            }
        }
        else
        {
            // Copy the textures over
            // If there is no TexGen or TexTransform
            DWORD i, j;
            DWORD numTex = FVF_TEXCOORD_NUMBER(outFVF);
            for(  i = 0; i < numTex; i++ )
            {
                DWORD n = GetTexCoordDim( outFVF, i );
                // DWORD n = (DWORD)(m_dwTexCoordSizeArray[i] >> 2);
                float *pCoord = (float *)&Vout.m_tex[i];
                for( j = 0; j < n; j++ )
                {
                    pCoord[j] = pTex[i][j];
                }
            }
        }

        //
        // Update the current pointers
        //
        pPos = (RDVECTOR3 *)m_position.Next();
        pPos2 = (RDVECTOR3 *)m_position2.Next();
        pBlendFactors = (float *)m_blendweights.Next();
        pBlendIndices = (DWORD *)m_blendindices.Next();
        pNormal = (RDVECTOR3 *)m_normal.Next();
        pNormal2 = (RDVECTOR3 *)m_normal2.Next();
        pDiffuse = (DWORD *)m_diffuse.Next();
        pSpecular = (DWORD *)m_specular.Next();
        pPointSize = (float *)m_pointsize.Next();
        for( t = 0; t < 8; t++ )
            pTex[t] = (float *)m_tex[t].Next();
    }

    if( flags & RDPV_DOCLIPPING )
    {
        Clipper.m_clipIntersection = clipIntersection;
        Clipper.m_clipUnion = clipUnion;
    }
    else
    {
        Clipper.m_clipIntersection = 0;
        Clipper.m_clipUnion = 0;
    }

    // Returns whether all the vertices were off screen
    return Clipper.m_clipIntersection;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\sources.inc ===
TARGETNAME = reftnl
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\vstream.cpp  \
        ..\vshader.cpp  \
        ..\xform.cpp    \
        ..\lighting.cpp \
        ..\clipping.cpp \
        ..\reftnl.cpp   \
        ..\procprim.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\lighting.cpp ===
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
// Vertex Lighting function implementations
///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
void
RDLV_Directional(
    RDLIGHTINGDATA& LData,
    D3DLIGHT7 *pLight,
    RDLIGHTI *pLightI,
    RDLIGHTINGELEMENT *in,
    DWORD  dwFlags,
    UINT64 qwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RDPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RDPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RDPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RDPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RDPV_COLORVERTEXSPEC;

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += pLightI->Ma_La.r;
        LData.diffuse.g += pLightI->Ma_La.g;
        LData.diffuse.b += pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += pLightI->La.b * LData.pAmbientSrc->b;
    }

    //
    // If no normals are present, bail out since we cannot perform the
    // normal-dependent computations
    //
    if( (qwFVFIn & D3DFVF_NORMAL) == 0 )
    {
        return;
    }

    D3DVALUE dot = DotProduct( pLightI->direction_in_eye, in->dvNormal );
    if (FLOAT_GTZ(dot))
    {
        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            RDVECTOR3 h;      // halfway vector
            RDVECTOR3 eye;    // incident vector ie vector from eye

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( pLightI->direction_in_eye, eye, h );

            // normalize
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_GTZ(dot))
            {
                if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
                {
                    D3DVALUE coeff = pow( dot, LData.material.power );
                    if (!bDoColVertexSpecular)
                    {
                        LData.specular.r += pLightI->Ms_Ls.r * coeff;
                        LData.specular.g += pLightI->Ms_Ls.g * coeff;
                        LData.specular.b += pLightI->Ms_Ls.b * coeff;
                    }
                    else
                    {
                        LData.specular.r += (pLightI->Ls.r *
                                             LData.pSpecularSrc->r * coeff);
                        LData.specular.g += (pLightI->Ls.g *
                                             LData.pSpecularSrc->g * coeff);
                        LData.specular.b += (pLightI->Ls.b *
                                             LData.pSpecularSrc->b * coeff);
                    }
                }
            }
        }
    }
    return;
}

void
RDLV_PointAndSpot(
    RDLIGHTINGDATA &LData,
    D3DLIGHT7 *pLight,
    RDLIGHTI *pLightI,
    RDLIGHTINGELEMENT *in,
    DWORD  dwFlags,
    UINT64 qwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RDPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RDPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RDPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RDPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RDPV_COLORVERTEXSPEC;
    RDVECTOR3 d;    // Direction to light
    D3DVALUE att;
    D3DVALUE dist;
    D3DVALUE dot;

    SubtractVector( pLightI->position_in_eye, in->dvPosition, d );

    // early out if out of range or exactly on the vertex
    D3DVALUE distSquared = SquareMagnitude( d );
    if (FLOAT_CMP_POS(distSquared, >=, pLightI->range_squared) ||
        FLOAT_EQZ(distSquared))
    {
        return;
    }

    //
    // Compute the attenuation
    //
    dist = SQRTF( distSquared );
    att = pLight->dvAttenuation0 + pLight->dvAttenuation1 * dist +
        pLight->dvAttenuation2 * distSquared;

    if (FLOAT_EQZ(att))
        att = FLT_MAX;
    else
        att = (D3DVALUE)1.0/att;

    dist = D3DVAL(1)/dist;

    //
    // If the light is a spotlight compute the spot-light factor
    //
    if (pLight->dltType == D3DLIGHT_SPOT)
    {
        // Calc dot product of direction to light with light direction to
        // be compared anganst the cone angles to see if we are in the
        // light.
        // Note that cone_dot is still scaled by dist
        D3DVALUE cone_dot = DotProduct(d, pLightI->direction_in_eye) * dist;

        if (FLOAT_CMP_POS(cone_dot, <=, pLightI->cos_phi_by_2))
        {
            return;
        }

        // modify att if in the region between phi and theta
        if (FLOAT_CMP_POS(cone_dot, <, pLightI->cos_theta_by_2))
        {
            D3DVALUE val = (cone_dot - pLightI->cos_phi_by_2) *
                pLightI->inv_theta_minus_phi;

            if (!FLOAT_EQZ( pLight->dvFalloff - 1.0 ))
            {
                val = POWF( val, pLight->dvFalloff );
            }
            att *= val;
        }
    }

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += att*pLightI->Ma_La.r;
        LData.diffuse.g += att*pLightI->Ma_La.g;
        LData.diffuse.b += att*pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += att*pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += att*pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += att*pLightI->La.b * LData.pAmbientSrc->b;
    }

    // Calc dot product of light dir with normal.  Note that since we
    // didn't normalize the direction the result is scaled by the distance.
    if( (qwFVFIn & D3DFVF_NORMAL) == 0)
    {
        // If no normals are present, bail out since we cannot perform the
        // normal-dependent computations
        return;
    }
    else
    {
        dot = DotProduct( d, in->dvNormal );
    }

    if (FLOAT_GTZ( dot ))
    {
        dot *= dist*att;

        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            RDVECTOR3 h;      // halfway vector
            RDVECTOR3 eye;    // incident vector ie vector from eye

            // normalize light direction
            d.x *= dist;
            d.y *= dist;
            d.z *= dist;

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( d, eye, h );
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
            {
                D3DVALUE coeff = pow( dot, LData.material.power ) * att;
                if (!bDoColVertexSpecular)
                {
                    LData.specular.r += pLightI->Ms_Ls.r * coeff;
                    LData.specular.g += pLightI->Ms_Ls.g * coeff;
                    LData.specular.b += pLightI->Ms_Ls.b * coeff;
                }
                else
                {
                    LData.specular.r += (pLightI->Ls.r *
                                         LData.pSpecularSrc->r * coeff);
                    LData.specular.g += (pLightI->Ls.g *
                                         LData.pSpecularSrc->g * coeff);
                    LData.specular.b += (pLightI->Ls.b *
                                         LData.pSpecularSrc->b * coeff);
                }
            }
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
// RDLight
///////////////////////////////////////////////////////////////////////////////
RDLight::RDLight()
{
    m_dwFlags = RDLIGHT_NEEDSPROCESSING;
    m_Next = NULL;

    ZeroMemory(&m_Light, sizeof(m_Light));
    ZeroMemory(&m_LightI, sizeof(m_LightI));

    // Initialize the light to some default values
    m_Light.dltType        = D3DLIGHT_DIRECTIONAL;

    m_Light.dcvDiffuse.r   = 1;
    m_Light.dcvDiffuse.g   = 1;
    m_Light.dcvDiffuse.b   = 1;
    m_Light.dcvDiffuse.a   = 0;

    m_Light.dvDirection.x  = 0;
    m_Light.dvDirection.y  = 0;
    m_Light.dvDirection.z  = 1;

    // m_Light.dcvSpecular = {0,0,0,0};
    // m_Light.dcvAmbient  = {0,0,0,0};
    // m_Light.dvPosition  = {0,0,0};

    // m_Light.dvRange        = 0;
    // m_Light.dvFalloff      = 0;
    // m_Light.dvAttenuation0 = 0;
    // m_Light.dvAttenuation1 = 0;
    // m_Light.dvAttenuation2 = 0;
    // m_Light.dvTheta        = 0;
    // m_Light.dvPhi          = 0;

    return;
}


HRESULT
RDLight::SetLight(LPD3DLIGHT7 pLight)
{

    // Validate the parameters passed
    switch (pLight->dltType)
    {
    case D3DLIGHT_POINT:
    case D3DLIGHT_SPOT:
    case D3DLIGHT_DIRECTIONAL:
        break;
    default:
        // No other light types are allowed
        DPFRR(0, "Invalid light type passed");
        return DDERR_INVALIDPARAMS;
    }
    if (pLight)
        m_Light = *pLight;

    // Mark it for processing later
    m_dwFlags |= (RDLIGHT_NEEDSPROCESSING | RDLIGHT_REFERED);
    return DD_OK;
}

HRESULT
RDLight::GetLight(LPD3DLIGHT7 pLight)
{
    if (pLight == NULL) return DDERR_GENERIC;
    *pLight = m_Light;
    return D3D_OK;
}

void
RDLight::ProcessLight(D3DMATERIAL7 *mat, RDLIGHTVERTEX_FUNC_TABLE *pTbl)
{
    //
    // If it is already processed, return
    //
    if (!NeedsProcessing()) return;

    //
    // Save the ambient light  (0-1)
    //
    m_LightI.La.r  = m_Light.dcvAmbient.r;
    m_LightI.La.g  = m_Light.dcvAmbient.g;
    m_LightI.La.b  = m_Light.dcvAmbient.b;

    //
    // Save the diffuse light  (0-1)
    //
    m_LightI.Ld.r  = m_Light.dcvDiffuse.r;
    m_LightI.Ld.g  = m_Light.dcvDiffuse.g;
    m_LightI.Ld.b  = m_Light.dcvDiffuse.b;

    //
    // Save the specular light (0-1)
    //
    m_LightI.Ls.r  = m_Light.dcvSpecular.r;
    m_LightI.Ls.g  = m_Light.dcvSpecular.g;
    m_LightI.Ls.b  = m_Light.dcvSpecular.b;

    //
    // Material Ambient times Light Ambient
    //
    m_LightI.Ma_La.r = m_LightI.La.r * mat->ambient.r * D3DVALUE(255.0);
    m_LightI.Ma_La.g = m_LightI.La.g * mat->ambient.g * D3DVALUE(255.0);
    m_LightI.Ma_La.b = m_LightI.La.b * mat->ambient.b * D3DVALUE(255.0);

    //
    // Material Diffuse times Light Diffuse
    //
    m_LightI.Md_Ld.r = m_LightI.Ld.r * mat->diffuse.r * D3DVALUE(255.0);
    m_LightI.Md_Ld.g = m_LightI.Ld.g * mat->diffuse.g * D3DVALUE(255.0);
    m_LightI.Md_Ld.b = m_LightI.Ld.b * mat->diffuse.b * D3DVALUE(255.0);

    //
    // Material Specular times Light Specular
    //
    m_LightI.Ms_Ls.r = m_LightI.Ls.r * mat->specular.r * D3DVALUE(255.0);
    m_LightI.Ms_Ls.g = m_LightI.Ls.g * mat->specular.g * D3DVALUE(255.0);
    m_LightI.Ms_Ls.b = m_LightI.Ls.b * mat->specular.b * D3DVALUE(255.0);


    //
    // Assign the actual lighting function pointer, in addition to
    // performing some precomputation of light-type specific data
    //
    m_pfnLightVertex = NULL;
    switch (m_Light.dltType)
    {
    case D3DLIGHT_DIRECTIONAL:
        m_pfnLightVertex = pTbl->pfnDirectional;
        break;
    case D3DLIGHT_POINT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.inv_theta_minus_phi = 1.0f;
        m_pfnLightVertex = pTbl->pfnPoint;
        break;
    case D3DLIGHT_SPOT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.dvTheta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.dvPhi / 2.0);
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
        m_pfnLightVertex = pTbl->pfnSpot;
        break;
    default:
        DPFRR( 0, "Cannot process light of unknown type" );
        break;
    }

    // Mark it as been processed
    m_dwFlags &= ~RDLIGHT_NEEDSPROCESSING;
    return;
}

void
RDLight::Enable(RDLight **ppRoot)
{
    // Assert that it is not already enabled
    if (IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RDLight *pTmp = *ppRoot;
    *ppRoot = this;
    m_Next = pTmp;
    m_dwFlags |= (RDLIGHT_ENABLED | RDLIGHT_REFERED);

    return;
}

void
RDLight::Disable(RDLight **ppRoot)
{
    // Assert that the light is enabled
    if (!IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RDLight *pLightPrev = *ppRoot;

    // If this is the first light in the active list
    if (pLightPrev == this)
    {
        *ppRoot = m_Next;
        m_dwFlags &= ~RDLIGHT_ENABLED;
        return;
    }

    while (pLightPrev->m_Next != this)
    {
        // Though this light was marked as enabled, it is not on
        // the active list. Assert this.
        if (pLightPrev->m_Next == NULL)
        {
            m_dwFlags &= ~RDLIGHT_ENABLED;
            return;
        }

        // Else get the next pointer
        pLightPrev = pLightPrev->m_Next;
    }

    pLightPrev->m_Next = m_Next;
    m_dwFlags &= ~RDLIGHT_ENABLED;
    m_dwFlags |= RDLIGHT_REFERED;
    return;
}

void
RDLight::XformLight( RDMATRIX *mView )
{
    // If the light is not a directional light,
    // tranform its position to camera space
    if (m_Light.dltType != D3DLIGHT_DIRECTIONAL)
    {
        XformBy4x3((RDVECTOR3*)&m_Light.dvPosition, mView,
                   &m_LightI.position_in_eye);
    }

    if (m_Light.dltType != D3DLIGHT_POINT)
    {
        // Transform light direction to the eye space
        Xform3VecBy3x3( (RDVECTOR3*)&m_Light.dvDirection, mView,
                        &m_LightI.direction_in_eye );
        // Normalize it
        Normalize( m_LightI.direction_in_eye );

        // Reverse it such that the direction is to the light
        ReverseVector( m_LightI.direction_in_eye, m_LightI.direction_in_eye );
    }

    return;
}

//---------------------------------------------------------------------
// ScaleRGBColorTo255: Scales colors from 0-1 range to 0-255 range
//---------------------------------------------------------------------
void
ScaleRGBColorTo255( const D3DCOLORVALUE& src, RDCOLOR3& dest )
{
    dest.r = D3DVALUE(255.0) * src.r;
    dest.g = D3DVALUE(255.0) * src.g;
    dest.b = D3DVALUE(255.0) * src.b;
}


//---------------------------------------------------------------------
// RefVP::GrowLightArray
//             Grows the light array and recreated the active-list
//             if a realloc has taken place.
//---------------------------------------------------------------------
HRESULT
RefVP::GrowLightArray( DWORD dwIndex )
{
    HRESULT hr = S_OK;
    BOOL bRealloc = FALSE;

    HR_RET(m_LightArray.Grow( dwIndex, &bRealloc ));
    if( bRealloc == TRUE )
    {
        m_lighting.pActiveLights = NULL;
        for( DWORD i = 0; i < m_LightArray.GetSize(); i++ )
        {
            if( m_LightArray[i].IsEnabled() )
            {
                m_LightArray[i].m_Next = m_lighting.pActiveLights;
                m_lighting.pActiveLights = &(m_LightArray[i]);
            }
        }
    }

    return S_OK;
}


//---------------------------------------------------------------------
// RefVP::UpdateLightingData
//             Updates lighting data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RefVP::UpdateLightingData()
{
    HRESULT hr = D3D_OK;
    RDLIGHTINGDATA& LData = m_lighting;
    RDLight *pLight = m_lighting.pActiveLights;
    RDVECTOR3   t;
    D3DMATERIAL7 *mat = &m_Material;

    //
    // Eye in eye space
    //
    LData.eye_in_eye.x = (D3DVALUE)0;
    LData.eye_in_eye.y = (D3DVALUE)0;
    LData.eye_in_eye.z = (D3DVALUE)0;

    // ATTENTION: Colorvertex may have changed the values of the
    // material alphas
    if (m_dwDirtyFlags & RDPV_DIRTY_MATERIAL)
    {
        //
        // Save the material to be used to light vertices
        //
        LData.material = *mat;
        ScaleRGBColorTo255( mat->ambient, LData.matAmb );
        ScaleRGBColorTo255( mat->diffuse, LData.matDiff );
        ScaleRGBColorTo255( mat->specular, LData.matSpec );
        ScaleRGBColorTo255( mat->emissive, LData.matEmis );

        //
        // Compute the Material Diffuse Alpha
        //
        LData.materialDiffAlpha = mat->diffuse.a * D3DVALUE(255);
        if (mat->diffuse.a < 0)
            LData.materialDiffAlpha = 0;
        else if (LData.materialDiffAlpha > 255)
            LData.materialDiffAlpha = 255 << 24;
        else LData.materialDiffAlpha <<= 24;

        //
        // Compute the Material Specular Alpha
        //
        LData.materialSpecAlpha = mat->specular.a * D3DVALUE(255);
        if (mat->specular.a < 0)
            LData.materialSpecAlpha = 0;
        else if (LData.materialSpecAlpha > 255)
            LData.materialSpecAlpha = 255 << 24;
        else LData.materialSpecAlpha <<= 24;

        //
        // Precompute the ambient and emissive components that are
        // not dependent on any contribution by the lights themselves
        //
        LData.ambEmiss.r = LData.ambient_red   * LData.matAmb.r +
            LData.matEmis.r;
        LData.ambEmiss.g = LData.ambient_green * LData.matAmb.g +
            LData.matEmis.g;
        LData.ambEmiss.b = LData.ambient_blue  * LData.matAmb.b +
            LData.matEmis.b;

        //
        // If the dot product is less than this
        // value, specular factor is zero
        //
        if (mat->power > D3DVAL(0.001))
        {
            LData.specThreshold = D3DVAL(pow(0.001, 1.0/mat->power));
        }
    }

    while (pLight)
    {
        if ((m_dwDirtyFlags & RDPV_DIRTY_MATERIAL) ||
            pLight->NeedsProcessing())
        {
            // If the material is dirty, light needs processing, regardless
            if (m_dwDirtyFlags & RDPV_DIRTY_MATERIAL)
            {
                pLight->m_dwFlags |= RDLIGHT_NEEDSPROCESSING;
            }

            // If the light has been set, or some material paramenters
            // changed, re-process the light.
            pLight->ProcessLight( &m_Material, &m_LightVertexTable );

            // Transform the light to Eye space
            // Lights are defined in world space, so simply apply the
            // Viewing transform
            pLight->XformLight( &m_xfmView );

        }
        else if (m_dwDirtyFlags & RDPV_DIRTY_NEEDXFMLIGHT)
        {
            pLight->XformLight( &m_xfmView );
        }

        pLight = pLight->m_Next;
    }

    // Clear Lighting dirty flags
    m_dwDirtyFlags &= ~RDPV_DIRTY_LIGHTING;
    return hr;
}


//---------------------------------------------------------------------
// RefVP::UpdateFogData
//             Updates Fog data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RefVP::UpdateFogData()
{
    HRESULT hr = D3D_OK;

    if (m_lighting.fog_end == m_lighting.fog_start)
        m_lighting.fog_factor = D3DVAL(0.0);
    else
        m_lighting.fog_factor = D3DVAL(255) / (m_lighting.fog_end -
                                               m_lighting.fog_start);

    // Clear Fog dirty flags
    m_dwDirtyFlags &= ~RDPV_DIRTY_FOG;
    return hr;
}

//---------------------------------------------------------------------
// RefVP::LightVertex
//           Actual lighting computation takes place here
//---------------------------------------------------------------------
void
RefVP::LightVertex(RDLIGHTINGELEMENT *pLE)
{
    RDLIGHTINGDATA &LData = m_lighting;
    RDLight  *pLight;

    //
    // Initialize Diffuse color with the Ambient and Emissive component
    // independent of the light (Ma*La + Me)
    //

    if (m_dwTLState & (RDPV_COLORVERTEXEMIS | RDPV_COLORVERTEXAMB))
    {
        // If the material values need to be replaced, compute

        LData.diffuse.r = LData.ambient_red * LData.pAmbientSrc->r +
            LData.pEmissiveSrc->r;
        LData.diffuse.g = LData.ambient_green * LData.pAmbientSrc->g +
            LData.pEmissiveSrc->g;
        LData.diffuse.b = LData.ambient_blue  * LData.pAmbientSrc->b +
            LData.pEmissiveSrc->b;
    }
    else
    {
        // If none of the material values needs to be replaced

        LData.diffuse = LData.ambEmiss;
    }


    //
    // Initialize the Specular to Zero
    //
    LData.specular.r = D3DVAL(0);
    LData.specular.g = D3DVAL(0);
    LData.specular.b = D3DVAL(0);

    //
    // In a loop accumulate color from the activated lights
    //
    pLight = LData.pActiveLights;
    while (pLight)
    {
        if (pLight->m_pfnLightVertex)
            (*pLight->m_pfnLightVertex)(m_lighting,
                                        &pLight->m_Light,
                                        &pLight->m_LightI,
                                        pLE,
                                        m_dwTLState,
                                        m_qwFVFIn);
        pLight = pLight->m_Next;
    }

    //
    // Compute the diffuse color of the vertex
    //
    int r = FTOI(LData.diffuse.r);
    int g = FTOI(LData.diffuse.g);
    int b = FTOI(LData.diffuse.b);
    DWORD a = *LData.pDiffuseAlphaSrc;

    //
    // Clamp the r, g, b, components
    //
    if (r < 0) r = 0; else if (r > 255) r = 255;
    if (g < 0) g = 0; else if (g > 255) g = 255;
    if (b < 0) b = 0; else if (b > 255) b = 255;

    LData.outDiffuse =  a + (r<<16) + (g<<8) + b;


    //
    // Obtain the specular Alpha
    //
    a = *(LData.pSpecularAlphaSrc);

    //
    // Compute the RGB part of the specular color
    //
    if (m_dwTLState & RDPV_DOSPECULAR)
    {
        r = FTOI(LData.specular.r);
        g = FTOI(LData.specular.g);
        b = FTOI(LData.specular.b);

        //
        // Clamp the r, g, b, components
        //
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

    }
    // Need another render-state to control if the 
    // the specular color (color2) needs to be passed down to
    // the rasterizer.

    //
    // If SPECULAR is not enabled but the specular color
    // had been provided in the input vertex, simply copy.
    //
    else if (m_qwFVFOut & D3DFVF_SPECULAR )
    {
        r = FTOI(LData.vertexSpecular.r);
        g = FTOI(LData.vertexSpecular.g);
        b = FTOI(LData.vertexSpecular.b);
        a = LData.vertexSpecAlpha;
    }
    //
    // If SpecularColor is not enabled
    //
    else
    {
        r = g = b = 0;
    }

    LData.outSpecular =  a + (r<<16) + (g<<8) + b;

    return;
}

//---------------------------------------------------------------------
// RefVP::FogVertex
//           Vertex Fog computation
// Input:
//      v    - input vertex in the model space
//      le   - vertex, transformed to the camera space
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//---------------------------------------------------------------------
void
RefVP::FogVertex( RDVertex& Vout, RDVECTOR3 &v, RDLIGHTINGELEMENT *pLE,
                  int numVertexBlends, float *pBlendFactors,
                  BOOL bVertexInEyeSpace )
{
    D3DVALUE dist = 0.0f;

    //
    // Calculate the distance
    //
    if (bVertexInEyeSpace)
    {
        // Vertex is already transformed to the camera space
        if (m_dwTLState & RDPV_RANGEFOG)
        {
            dist = SQRTF(pLE->dvPosition.x*pLE->dvPosition.x +
                         pLE->dvPosition.y*pLE->dvPosition.y +
                         pLE->dvPosition.z*pLE->dvPosition.z);
        }
        else
        {
            dist = ABSF( pLE->dvPosition.z );
        }
    }
    else if (m_dwTLState & RDPV_RANGEFOG)
    {
        D3DVALUE x = 0, y = 0, z = 0;
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }
            if( m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND )
            {
                BYTE m = ((BYTE *)&pBlendFactors[numVertexBlends])[j];
                UpdateWorld( m );
                x += (v.x*m_xfmToEye[m]._11 +
                      v.y*m_xfmToEye[m]._21 +
                      v.z*m_xfmToEye[m]._31 +
                      m_xfmToEye[m]._41) * blend;
                y += (v.x*m_xfmToEye[m]._12 +
                      v.y*m_xfmToEye[m]._22 +
                      v.z*m_xfmToEye[m]._32 +
                      m_xfmToEye[m]._42) * blend;
                z += (v.x*m_xfmToEye[m]._13 +
                      v.y*m_xfmToEye[m]._23 +
                      v.z*m_xfmToEye[m]._33 +
                      m_xfmToEye[m]._43) * blend;
            }
            else
            {
                x += (v.x*m_xfmToEye[j]._11 +
                      v.y*m_xfmToEye[j]._21 +
                      v.z*m_xfmToEye[j]._31 +
                      m_xfmToEye[j]._41) * blend;
                y += (v.x*m_xfmToEye[j]._12 +
                      v.y*m_xfmToEye[j]._22 +
                      v.z*m_xfmToEye[j]._32 +
                      m_xfmToEye[j]._42) * blend;
                z += (v.x*m_xfmToEye[j]._13 +
                      v.y*m_xfmToEye[j]._23 +
                      v.z*m_xfmToEye[j]._33 +
                      m_xfmToEye[j]._43) * blend;
            }
        }

        dist = SQRTF(x*x + y*y + z*z);
    }
    else
    {
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }

            if( m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND )
            {
                BYTE m = ((BYTE *)&pBlendFactors[numVertexBlends])[j];
                UpdateWorld( m );
                dist += (v.x*m_xfmToEye[m]._13 +
                         v.y*m_xfmToEye[m]._23 +
                         v.z*m_xfmToEye[m]._33 +
                         m_xfmToEye[m]._43) * blend;
            }
            else
            {
                dist += (v.x*m_xfmToEye[j]._13 +
                         v.y*m_xfmToEye[j]._23 +
                         v.z*m_xfmToEye[j]._33 +
                         m_xfmToEye[j]._43) * blend;
            }
        }
        dist = ABSF( dist );
    }

    if (m_lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < m_lighting.fog_start)
        {
            Vout.m_fog = 1.0f;
        }
        else if (dist >= m_lighting.fog_end)
        {
            Vout.m_fog = 0.0f;
        }
        else
        {
            Vout.m_fog = (m_lighting.fog_end - dist) *
                m_lighting.fog_factor / 255.0f ;
        }
    }
    else
    {
        D3DVALUE tmp = dist * m_lighting.fog_density;
        if (m_lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        Vout.m_fog = (FLOAT)exp(-tmp);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\xform.cpp ===
#include "pch.cpp"
#pragma hdrstop


//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RefVP::UpdateXformData
//             Updates transform data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RefVP::UpdateXformData()
{
    HRESULT hr = D3D_OK;
    RDTRANSFORMDATA& TData = m_TransformData;


    // Update Mproj*Mclip
    if( m_dwDirtyFlags &  RDPV_DIRTY_PROJXFM )
    {
        D3DMATRIX MShift;
        ZeroMemory (&MShift, sizeof(D3DMATRIX));
        MShift._11 = 0.5f;
        MShift._22 = 0.5f;
        MShift._41 = 0.5f;
        MShift._42 = 0.5f;
        MShift._44 = 1.0f;
        MShift._33 = 1.0f;

        MatrixProduct(&TData.m_PS, &m_xfmProj, &MShift);
    }

    // Update Mview*Mproj*Mclip
    if( m_dwDirtyFlags & (RDPV_DIRTY_VIEWXFM | RDPV_DIRTY_PROJXFM) )
    {
        MatrixProduct(&TData.m_VPS, &m_xfmView, &TData.m_PS);
        Inverse4x4( (D3DMATRIX *)&TData.m_VPS, (D3DMATRIX *)&TData.m_VPSInv );
    }

    for( DWORD i=0; i< RD_MAX_BLEND_WEIGHTS; i++)
    {
        MatrixProduct(&m_xfmCurrent[i], &m_xfmWorld[i], &TData.m_VPS);
    }

    // Compute xfmToEye (world*view) matrix (needed for lighting and fog)
    // if needed
    if (m_dwDirtyFlags & (RDPV_DIRTY_VIEWXFM  |
                          RDPV_DIRTY_WORLDXFM |
                          RDPV_DIRTY_WORLD1XFM |
                          RDPV_DIRTY_WORLD2XFM |
                          RDPV_DIRTY_WORLD3XFM ))
    {
        m_dwDirtyFlags |= RDPV_DIRTY_INVERSEWORLDVIEW;
    }
        
    if (m_dwTLState & (RDPV_DOLIGHTING | RDPV_DOFOG | RDPV_DOCOMPUTEPOINTSIZE |
                       RDPV_DOTEXGEN) &&
        (m_dwDirtyFlags & RDPV_DIRTY_INVERSEWORLDVIEW))
    {
        for( i=0; i< RD_MAX_BLEND_WEIGHTS; i++)
        {
            MatrixProduct(&m_xfmToEye[i], &m_xfmWorld[i], &m_xfmView);
            Inverse4x4((D3DMATRIX *)&m_xfmToEye[i],
                       (D3DMATRIX *)&m_xfmToEyeInv[i]);
            m_dwDirtyFlags |= RDPV_DIRTY_NEEDXFMLIGHT;
        }
        m_dwDirtyFlags &= ~RDPV_DIRTY_INVERSEWORLDVIEW;
    }

    // Clear the world processed flags
    memset( m_WorldProcessed, 0, sizeof( m_WorldProcessed ) );
    
    // Clear the dirty transform flags
    m_dwDirtyFlags &= ~RDPV_DIRTY_XFORM;
    return hr;
}

void
RefVP::UpdateWorld( DWORD i )
{
    RDTRANSFORMDATA& TData = m_TransformData;
    if( m_WorldProcessed[i] == TRUE ) return;
    MatrixProduct(&m_xfmCurrent[i], &m_xfmWorld[i], &TData.m_VPS);
    if (m_dwTLState & (RDPV_DOLIGHTING | RDPV_DOFOG | RDPV_DOCOMPUTEPOINTSIZE |
                       RDPV_DOTEXGEN))
    {
        MatrixProduct(&m_xfmToEye[i], &m_xfmWorld[i], &m_xfmView);
        Inverse4x4((D3DMATRIX *)&m_xfmToEye[i], 
                   (D3DMATRIX *)&m_xfmToEyeInv[i]);
    }
    m_WorldProcessed[i] = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\vstream.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vshader.cpp
 *  Content:    SetStreamSource and VertexShader
 *              software implementation.
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////////
//
//          Helper functions
//
/////////////////////////////////////////////////////////////////////////

void
Copy_FLOAT1( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = *(float*)pInputStream;
    pVertexRegister->y = 0;
    pVertexRegister->z = 0;
    pVertexRegister->w = 1;
}

void
Copy_FLOAT2( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = ((float*)pInputStream)[0];
    pVertexRegister->y = ((float*)pInputStream)[1];
    pVertexRegister->z = 0;
    pVertexRegister->w = 1;
}

void
Copy_FLOAT3( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = ((float*)pInputStream)[0];
    pVertexRegister->y = ((float*)pInputStream)[1];
    pVertexRegister->z = ((float*)pInputStream)[2];
    pVertexRegister->w = 1;
}

void
Copy_FLOAT4( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = ((float*)pInputStream)[0];
    pVertexRegister->y = ((float*)pInputStream)[1];
    pVertexRegister->z = ((float*)pInputStream)[2];
    pVertexRegister->w = ((float*)pInputStream)[3];
}

void
Copy_D3DCOLOR( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const float scale = 1.0f/255.f;
    const DWORD v = ((DWORD*)pInputStream)[0];
    pVertexRegister->a = scale * RGBA_GETALPHA(v);
    pVertexRegister->r = scale * RGBA_GETRED(v);
    pVertexRegister->g = scale * RGBA_GETGREEN(v);
    pVertexRegister->b = scale * RGBA_GETBLUE(v);
}

void
Copy_UBYTE4( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const BYTE* v = (BYTE *)pInputStream;
    pVertexRegister->x = v[0];
    pVertexRegister->y = v[1];
    pVertexRegister->z = v[2];
    pVertexRegister->w = v[3];
}

void
Copy_SHORT2( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const SHORT* v = ((SHORT*)pInputStream);
    pVertexRegister->x = v[0];
    pVertexRegister->y = v[1];
    pVertexRegister->z = 0;
    pVertexRegister->w = 1;
}

void
Copy_SHORT4( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const SHORT* v = ((SHORT*)pInputStream);
    pVertexRegister->x = v[0];
    pVertexRegister->y = v[1];
    pVertexRegister->z = v[2];
    pVertexRegister->w = v[3];
}

inline HRESULT
SetVElement( RDVElement& ve, DWORD dwReg, DWORD dwDataType, DWORD dwOffset )
{
    ve.m_dwOffset = dwOffset;
    ve.m_dwRegister = dwReg;
    ve.m_dwDataType = dwDataType;
    switch( dwDataType )
    {
    case D3DVSDT_FLOAT1:
        ve.m_pfnCopy = Copy_FLOAT1;
        break;
    case D3DVSDT_FLOAT2:
        ve.m_pfnCopy = Copy_FLOAT2;
        break;
    case D3DVSDT_FLOAT3:
        ve.m_pfnCopy = Copy_FLOAT3;
        break;
    case D3DVSDT_FLOAT4:
        ve.m_pfnCopy = Copy_FLOAT4;
        break;
    case D3DVSDT_D3DCOLOR:
        ve.m_pfnCopy = Copy_D3DCOLOR;
        break;
    case D3DVSDT_UBYTE4:
        ve.m_pfnCopy = Copy_UBYTE4;
        break;
    case D3DVSDT_SHORT2:
        ve.m_pfnCopy = Copy_SHORT2;
        break;
    case D3DVSDT_SHORT4:
        ve.m_pfnCopy = Copy_SHORT4;
        break;
    default:
        return E_FAIL;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// Based on register and data type the function computes FVF dword and texture
// presence bits:
// - bits  0 - 7 in the qwFVF2 are used as texture presence bits
// - bits 12 - 14 in the qwFVF are used as count of blend weights
//-----------------------------------------------------------------------------
HRESULT
UpdateFVF( DWORD dwRegister, DWORD dwDataType, UINT64* pqwFVF, 
           UINT64* pqwFVF2, DWORD* pdwNumBetas )
{
    DWORD dwNumFloats = 0;
    
    switch( dwRegister )
    {
    case D3DVSDE_POSITION:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Position register must be FLOAT3 for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVF_XYZ;
        break;
    case D3DVSDE_POSITION2:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Position register must be FLOAT3 for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVFP_POSITION2;
        break;
    case D3DVSDE_BLENDWEIGHT:
    {
        int n = 0;
        switch (dwDataType)
        {
        case D3DVSDT_FLOAT1:
            n = 1;
            break;
        case D3DVSDT_FLOAT2:
            n = 2;
            break;
        case D3DVSDT_FLOAT3:
            n = 3;
            break;
        case D3DVSDT_FLOAT4:
            n = 4;
            break;
        default:
            DPFERR( "Invalid data type set for vertex blends" );
            return DDERR_GENERIC;
        }
        // Update number of floats after position
        *pdwNumBetas = *pdwNumBetas + n;
        break;
    }
    case D3DVSDE_NORMAL:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Normal register must be FLOAT3 for fixed-function"
                    "pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVF_NORMAL;
        break;
    case D3DVSDE_NORMAL2:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Normal register must be FLOAT3 for fixed-function"
                    "pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVFP_NORMAL2;
        break;
    case D3DVSDE_PSIZE:
        if( dwDataType != D3DVSDT_FLOAT1 )
        {
            DPFERR( "Point size register must be FLOAT1 for fixed-function"
                    "pipeline" );
            return DDERR_GENERIC;

        }
        *pqwFVF |= D3DFVF_PSIZE;
        break;
    case D3DVSDE_DIFFUSE:
        if( dwDataType != D3DVSDT_D3DCOLOR )
        {
            DPFERR( "Diffuse register must be D3DCOLOR for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;

        }
        *pqwFVF |= D3DFVF_DIFFUSE;
        break;
    case D3DVSDE_SPECULAR:
        if( dwDataType != D3DVSDT_D3DCOLOR )
        {
            DPFERR( "Specular register must be PACKEDBYTE for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;

        }
        *pqwFVF |= D3DFVF_SPECULAR;
        break;
    case D3DVSDE_BLENDINDICES:
        if ( dwDataType != D3DVSDT_UBYTE4 )
        {
            DPFERR( "Blend Indicex register must be UBYTE4 for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVFP_BLENDINDICES;
        break;
    case D3DVSDE_TEXCOORD0:
    case D3DVSDE_TEXCOORD1:
    case D3DVSDE_TEXCOORD2:
    case D3DVSDE_TEXCOORD3:
    case D3DVSDE_TEXCOORD4:
    case D3DVSDE_TEXCOORD5:
    case D3DVSDE_TEXCOORD6:
    case D3DVSDE_TEXCOORD7:
        {
            DWORD dwTextureIndex = dwRegister - D3DVSDE_TEXCOORD0;
            DWORD dwBit = 1 << dwTextureIndex;
            if( *pqwFVF2 & dwBit )
            {
                DPFERR( "Texture register is set second time" );
                return DDERR_GENERIC;

            }
            *pqwFVF2 |= dwBit;
            switch( dwDataType )
            {
            case D3DVSDT_FLOAT1:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE1(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT2:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE2(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT3:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE3(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT4:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE4(dwTextureIndex);
                break;
            default:
                DPFERR( "Invalid data type set for texture register" );
                return DDERR_GENERIC;

                break;
            }
            break;
        }
    default:
        DPFERR( "Invalid register set for fixed-function pipeline" );
        return DDERR_GENERIC;

        break;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//
//          class RDVStreamDecl
//
/////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDVStreamDecl::Constructor
//-----------------------------------------------------------------------------
RDVStreamDecl::RDVStreamDecl()
{
    m_dwNumElements = 0;
    m_dwStride = 0;
    m_dwStreamIndex = 0;
    m_bIsStreamTess = FALSE;
}

//-----------------------------------------------------------------------------
// RDVStreamDecl::MakeVElementArray
//-----------------------------------------------------------------------------
HRESULT
RDVStreamDecl::MakeVElementArray( UINT64 qwFVF )
{
    HRESULT hr = S_OK;
    DWORD dwOffset = 0; // In Bytes

    m_dwStride = GetFVFVertexSize( qwFVF );
    m_dwStreamIndex = 0;
    m_dwNumElements = 0;

    dwOffset = 0 + ( qwFVF & D3DFVF_RESERVED0 ? 4 : 0 );

    //
    // Position and Blend Weights
    //
    switch( qwFVF & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZ:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;
        break;
    case D3DFVF_XYZRHW:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT4, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*4;
        break;
    case D3DFVF_XYZB1:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT1, dwOffset );
        dwOffset += 4*1;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB2:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT2, dwOffset );
        dwOffset += 4*2;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB3:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT3, dwOffset );
        dwOffset += 4*3;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB4:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT4, dwOffset );
        dwOffset += 4*4;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB5:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT4, dwOffset );
        dwOffset += 4*5; // Even though the velement is float4, skip 5 floats.
        m_dwNumElements++;
        break;
    default:
        DPFERR( "Unable to compute offsets, strange FVF bits set" );
        return E_FAIL;
    }


    //
    // Normal
    //
    if( qwFVF & D3DFVF_NORMAL )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_NORMAL,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;
    }

    //
    // Point Size
    //
    if( qwFVF & D3DFVF_PSIZE )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_PSIZE,
                     D3DVSDT_FLOAT1, dwOffset );
        m_dwNumElements++;
        dwOffset += 4;
    }

    //
    // Diffuse Color
    //
    if( qwFVF & D3DFVF_DIFFUSE )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_DIFFUSE,
                     D3DVSDT_D3DCOLOR, dwOffset );
        m_dwNumElements++;
        dwOffset += 4;
    }

    //
    // Specular Color
    //
    if( qwFVF & D3DFVF_SPECULAR )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_SPECULAR,
                     D3DVSDT_D3DCOLOR, dwOffset );
        m_dwNumElements++;
        dwOffset += 4;
    }

    //
    // Texture coordinates
    //
    DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
    DWORD dwTextureFormats = (DWORD)((qwFVF >> 16) & 0xffff);
    // Texture formats size  00   01   10   11
    static DWORD dwTextureSize[4] = {2*4, 3*4, 4*4, 4};
    static DWORD dwTextureType[4] = {D3DVSDT_FLOAT2, D3DVSDT_FLOAT3,
                                     D3DVSDT_FLOAT4, D3DVSDT_FLOAT1};

    for (DWORD i=0; i < dwNumTexCoord; i++)
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_TEXCOORD0 + i,
                     dwTextureType[dwTextureFormats & 3], dwOffset );
        dwOffset += dwTextureSize[dwTextureFormats & 3];
        dwTextureFormats >>= 2;
        m_dwNumElements++;
    }

    return hr;
}

//-----------------------------------------------------------------------------
// RDVStreamDecl::Parse
//-----------------------------------------------------------------------------
HRESULT
RDVStreamDecl::Parse( DWORD ** ppToken,
                      BOOL bFixedFunction,
                      BOOL bStreamTess,
                      UINT64* pqwFVF,
                      UINT64* pqwFVF2,
                      DWORD*  pdwNumBetas)
{
    HRESULT hr = S_OK;

    m_bIsStreamTess = bStreamTess;

    DWORD* pToken = *ppToken;
    DWORD dwCurrentOffset = 0;
    while( TRUE )
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = RDVSD_GETTOKENTYPE( dwToken );
        switch( dwTokenType )
        {
        case D3DVSD_TOKEN_NOP:  break;
        case D3DVSD_TOKEN_TESSELLATOR:
        {
            if( bStreamTess == FALSE )
            {
                DPFERR( "Unexpected Tesselator Token for this stream" );
                return E_FAIL;
            }

            if( m_dwNumElements >= RD_MAX_NUMELEMENTS )
            {
                DPFERR( "Tesselator Stream Token:" );
                DPFERR( "   Number of vertex elements generated"
                        " is greater than max supported"  );
                return DDERR_GENERIC;
            }
            RDVElement& Element = m_Elements[m_dwNumElements++];
            const DWORD dwDataType = RDVSD_GETDATATYPE(dwToken);
            const DWORD dwRegister = RDVSD_GETVERTEXREG(dwToken);
            const DWORD dwRegisterIn = RDVSD_GETVERTEXREGIN(dwToken);
            Element.m_dwToken = dwToken;
            Element.m_dwOffset = dwCurrentOffset;
            Element.m_dwRegister = dwRegister;
            Element.m_dwDataType = dwDataType;
            Element.m_dwStreamIndex = m_dwStreamIndex;
            Element.m_dwRegisterIn = dwRegisterIn;
            Element.m_bIsTessGen = TRUE;

            switch (dwDataType)
            {
            case D3DVSDT_FLOAT2:
                dwCurrentOffset += sizeof(float) * 2;
                Element.m_pfnCopy = Copy_FLOAT2;
                break;
            case D3DVSDT_FLOAT3:
                dwCurrentOffset += sizeof(float) * 3;
                Element.m_pfnCopy = Copy_FLOAT3;
                break;
            default:
                DPFERR( "Invalid element data type in a Tesselator token" );
                return DDERR_GENERIC;
            }
            // Compute input FVF for fixed-function pipeline
            if(  bFixedFunction  )
            {

                hr = UpdateFVF( dwRegister, dwDataType, pqwFVF, pqwFVF2, 
                                pdwNumBetas );
                if( FAILED( hr ) )
                {
                    DPFERR( "UpdateFVF failed" );
                    return DDERR_INVALIDPARAMS;
                }
            }
            else
            {
                if( dwRegister >= RD_MAX_NUMINPUTREG )
                {
                    DPFERR( "D3DVSD_TOKEN_STREAMDATA:"
                            "Invalid register number" );
                    return DDERR_GENERIC;
                }
            }
            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
        {
            switch( RDVSD_GETDATALOADTYPE( dwToken ) )
            {
            case RDVSD_LOADREGISTER:
            {
                if( m_dwNumElements >= RD_MAX_NUMELEMENTS )
                {
                    DPFERR( "D3DVSD_TOKEN_STREAMDATA:" );
                    DPFERR( "   Number of vertex elements in a stream"
                            "is greater than max supported"  );
                    return DDERR_GENERIC;
                }
                RDVElement& Element = m_Elements[m_dwNumElements++];
                const DWORD dwDataType = RDVSD_GETDATATYPE(dwToken);
                const DWORD dwRegister = RDVSD_GETVERTEXREG(dwToken);
                Element.m_dwToken = dwToken;
                Element.m_dwOffset = dwCurrentOffset;
                Element.m_dwRegister = dwRegister;
                Element.m_dwDataType = dwDataType;
                Element.m_dwStreamIndex = m_dwStreamIndex;

                switch( dwDataType )
                {
                case D3DVSDT_FLOAT1:
                    dwCurrentOffset += sizeof(float);
                    Element.m_pfnCopy = Copy_FLOAT1;
                    break;
                case D3DVSDT_FLOAT2:
                    dwCurrentOffset += sizeof(float) * 2;
                    Element.m_pfnCopy = Copy_FLOAT2;
                    break;
                case D3DVSDT_FLOAT3:
                    dwCurrentOffset += sizeof(float) * 3;
                    Element.m_pfnCopy = Copy_FLOAT3;
                    break;
                case D3DVSDT_FLOAT4:
                    dwCurrentOffset += sizeof(float) * 4;
                    Element.m_pfnCopy = Copy_FLOAT4;
                    break;
                case D3DVSDT_D3DCOLOR:
                    dwCurrentOffset += sizeof(DWORD);
                    Element.m_pfnCopy = Copy_D3DCOLOR;
                    break;
                case D3DVSDT_UBYTE4:
                    dwCurrentOffset += sizeof(DWORD);
                    Element.m_pfnCopy = Copy_UBYTE4;
                    break;
                case D3DVSDT_SHORT2:
                    dwCurrentOffset += sizeof(SHORT) * 2;
                    Element.m_pfnCopy = Copy_SHORT2;
                    break;
                case D3DVSDT_SHORT4:
                    dwCurrentOffset += sizeof(SHORT) * 4;
                    Element.m_pfnCopy = Copy_SHORT4;
                    break;
                default:
                    DPFERR( "D3DVSD_TOKEN_STREAMDATA:"
                            "Invalid element data type" );
                    return DDERR_GENERIC;
                }
                // Compute input FVF for fixed-function pipeline
                if(  bFixedFunction  )
                {

                    hr = UpdateFVF( dwRegister, dwDataType, pqwFVF, pqwFVF2,
                                    pdwNumBetas );
                    if( FAILED( hr ) )
                    {
                        DPFERR( "UpdateFVF failed" );
                        return DDERR_INVALIDPARAMS;
                    }
                }
                else
                {
                    if( dwRegister >= RD_MAX_NUMINPUTREG )
                    {
                        DPFERR( "D3DVSD_TOKEN_STREAMDATA:"
                                "Invalid register number" );
                        return DDERR_GENERIC;
                    }
                }
                break;
            }
            case RDVSD_SKIP:
            {
                const DWORD dwCount = RDVSD_GETSKIPCOUNT( dwToken );
                dwCurrentOffset += dwCount * sizeof(DWORD);
                break;
            }
            default:
                DPFERR( "Invalid data load type" );
                return DDERR_GENERIC;
            }
            break;
        }
        default:
        {
            *ppToken = pToken - 1;
            m_dwStride = dwCurrentOffset;
            return S_OK;
        }
        } // switch
    } // while

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////
//
//          class RDVDeclaration
//
/////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDVDeclaration::Destructor
//-----------------------------------------------------------------------------
RDVDeclaration::~RDVDeclaration()
{
    RDVConstantData* pConst = m_pConstants;
    while( pConst )
    {
        RDVConstantData* pNext = 
            static_cast<RDVConstantData *>(pConst->m_pNext);
        delete pConst;
        pConst = pNext;
    }
}

//-----------------------------------------------------------------------------
// RDVDeclaration::MakeVElementArray
//-----------------------------------------------------------------------------
HRESULT
RDVDeclaration::MakeVElementArray( UINT64 qwFVF )
{
    HRESULT hr = S_OK;
    m_qwInputFVF = qwFVF;
    m_dwNumActiveStreams = 1;

    // Go through the FVF and make the elements
    RDVStreamDecl& Stream = m_StreamArray[0];

    hr = Stream.MakeVElementArray( qwFVF );
    if( FAILED( hr ) )
    {
        return hr;
    }

    m_dwNumElements = Stream.m_dwNumElements;
    memcpy( &m_VertexElements, &Stream.m_Elements,
            sizeof( RDVElement ) * m_dwNumElements );

    return hr;
}

//-----------------------------------------------------------------------------
// RDVDeclaration::Parse
//-----------------------------------------------------------------------------
HRESULT
RDVDeclaration::Parse( DWORD* pDecl, BOOL bFixedFunction )
{
    HRESULT hr = S_OK;
    UINT64 qwFVF  = 0;   // FVF for fixed-function pipeline
    UINT64 qwFVF2 = 0;   // Texture presence bits (8 bits)
    DWORD  dwNumBetas = 0; // The number of betas.
    DWORD   dwStreamPresent = 0;    // Bit is set if a stream is used
    DWORD* pToken = pDecl;
    BOOL    bStreamTess = FALSE;

    while( TRUE )
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = RDVSD_GETTOKENTYPE(dwToken);
        switch( dwTokenType )
        {
        case D3DVSD_TOKEN_NOP:
            break;
        case D3DVSD_TOKEN_STREAM:
        {
            DWORD dwStream;
            if( RDVSD_ISSTREAMTESS(dwToken) )
            {
                if( RDVSD_GETSTREAMNUMBER(dwToken) )
                {
                    DPFERR( "No stream number should be specified for a"
                            " Tesselator stream" );
                    return E_FAIL;
                }
                dwStream = RDVSD_STREAMTESS;
                bStreamTess = TRUE;
            }
            else
            {
                dwStream = RDVSD_GETSTREAMNUMBER(dwToken);
                bStreamTess = FALSE;
            }

            if( dwStream > RDVSD_STREAMTESS )
            {
                DPFERR( "Stream number is too big" );
                return DDERR_INVALIDPARAMS;
            }

            // Has this stream already been declared ?
            if( dwStreamPresent & (1 << dwStream) )
            {
                DPFERR( "Stream already defined in this declaration" );
                return DDERR_INVALIDPARAMS;
            }

            // Mark the stream as seen
            dwStreamPresent |= 1 << dwStream;

            RDVStreamDecl& Stream = m_StreamArray[m_dwNumActiveStreams];
            Stream.m_dwStreamIndex = dwStream;
            hr = Stream.Parse(&pToken, bFixedFunction, bStreamTess,
                              &qwFVF, &qwFVF2, &dwNumBetas);
            if( FAILED( hr ) )
            {
                return hr;
            }

            //
            // Save the stride computed for the tesselator stream
            //
            if( bStreamTess )
            {
                m_dwStreamTessStride = Stream.m_dwStride;
            }

            m_dwNumActiveStreams++;
            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
        {
            DPFERR( "D3DVSD_TOKEN_STREAMDATA could only be used"
                    "after D3DVSD_TOKEN_STREAM" );
            return DDERR_GENERIC;
        }
        case D3DVSD_TOKEN_CONSTMEM:
        {
            RDVConstantData * cd = new RDVConstantData;
            if( cd == NULL )
            {
                return E_OUTOFMEMORY;
            }
            
            cd->m_dwCount = RDVSD_GETCONSTCOUNT(dwToken);
            cd->m_dwAddress = RDVSD_GETCONSTADDRESS(dwToken);

            if( cd->m_dwCount + cd->m_dwAddress > RD_MAX_NUMCONSTREG )
            {
                delete cd;
                DPFERR( "D3DVSD_TOKEN_CONSTMEM writes outside"
                        "constant memory" );
                return DDERR_GENERIC;
            }

            const DWORD dwSize = cd->m_dwCount << 2;    // number of DWORDs
            cd->m_pData = new DWORD[dwSize];
            if( cd->m_pData == NULL )
            {
                return E_OUTOFMEMORY;
            }
            
            memcpy( cd->m_pData, pToken, dwSize << 2 );
            if( m_pConstants == NULL )
                m_pConstants = cd;
            else
                m_pConstants->Append(cd);
            pToken += dwSize;
            break;
        }
        case D3DVSD_TOKEN_EXT:
        {
            // Skip extension info
            DWORD dwCount = RDVSD_GETEXTCOUNT(dwToken);
            pToken += dwCount;
            break;
        }
        case D3DVSD_TOKEN_END:
        {
            goto l_End;
        }
        default:
        {
            DPFERR( "Invalid declaration token: %10x", dwToken );
            return DDERR_INVALIDPARAMS;
        }
        }
    }

l_End:

    // Now accumulate all the vertex elements into the declaration
    DWORD dwCurrElement = 0;
    m_dwNumElements = 0;

    // Build a VElement List in the Declaration.
    for( DWORD i=0; i<m_dwNumActiveStreams; i++ )
    {
        RDVStreamDecl& Stream = m_StreamArray[i];
        for( DWORD j=0; j<Stream.m_dwNumElements; j++ )
        {
            m_VertexElements[dwCurrElement] = Stream.m_Elements[j];
            dwCurrElement++;
        }
        m_dwNumElements += Stream.m_dwNumElements;
    }

    // If any tesselator tokens were present, then translate the m_dwRegisterIn
    // in the the StreamIndex and Offset for the tesselator tokens.
    if( bStreamTess )
    {
        for( i=0; i<m_dwNumElements; i++ )
        {
            RDVElement& ve = m_VertexElements[i];
            if( ve.m_bIsTessGen )
            {
                for( DWORD j=0; j<m_dwNumElements; j++ )
                {
                    if( m_VertexElements[j].m_dwRegister == ve.m_dwRegisterIn )
                    {
                        ve.m_dwStreamIndexIn =
                            m_VertexElements[j].m_dwStreamIndex;
                        ve.m_dwOffsetIn = m_VertexElements[j].m_dwOffsetIn;
                        break;
                    }
                }
                if( j == m_dwNumElements )
                {
                    DPFERR( "Tesselator input register is not defined in the"
                            " declaration" );
                    return E_FAIL;
                }
            }
        }
    }

    // Validate input for the fixed-function pipeline
    if( bFixedFunction )
    {
        // Pull out the number of blend weights
        BOOL bIsTransformed = (qwFVF & D3DFVF_XYZRHW);
        if( bIsTransformed )
        {
            if( dwNumBetas != 0 )
            {
                
                DPFERR( "Cannot have blend weights along with "
                        "transformed position" );
                return E_FAIL;
            }
        }
        else if( (qwFVF & D3DFVF_XYZ) == 0 )
        {
            // Position must be set
            DPFERR( "Position register must be set" );
            return E_FAIL;
        }
        
        DWORD dwPosMask = bIsTransformed ? 0x2 : 0x1;
        if( dwNumBetas )
        {
            dwPosMask += (dwNumBetas + 1);
        }
        
        m_qwInputFVF |= (qwFVF | 
                         ((DWORD)(D3DFVF_POSITION_MASK) & (dwPosMask << 1)));

        // Compute number of texture coordinates
        DWORD nTexCoord = 0;
        DWORD dwTexturePresenceBits = qwFVF2 & 0xFF;
        while( dwTexturePresenceBits & 1 )
        {
            dwTexturePresenceBits >>= 1;
            nTexCoord++;
        }

        // There should be no gaps in texture coordinates
        if( dwTexturePresenceBits )
        {
            DPFERR( "Texture coordinates should have no gaps" );
            return E_FAIL;
        }

        m_qwInputFVF |= (nTexCoord << D3DFVF_TEXCOUNT_SHIFT);

    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////
//
//          class RDVShader
//
/////////////////////////////////////////////////////////////////////////

RDVShader::RDVShader()
{
    m_pCode = NULL;
}

//-----------------------------------------------------------------------------
// RDVShader::Destructor
//-----------------------------------------------------------------------------
RDVShader::~RDVShader()
{
    delete m_pCode;
}

/////////////////////////////////////////////////////////////////////////
//
//          class RefDev
//
/////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RefDev::DrawDX8Prim
//-----------------------------------------------------------------------------
HRESULT
RefDev::DrawDX8Prim( LPD3DHAL_DP2DRAWPRIMITIVE pDP )
{
    HRESULT hr = S_OK;

    // Ignore D3DRS_PATCHSEGMENTS for non-triangle primitive types
    if( GetRSf()[D3DRS_PATCHSEGMENTS] > 1.f &&
        pDP->primType >= D3DPT_TRIANGLELIST)
    {
        // Save current data stream pointers and replace with
        // pointer to tessellation output
        hr = LinkTessellatorOutput();
        if(FAILED(hr))
        {
            return hr;
        }

        hr = ProcessTessPrimitive( pDP );

        // Restore back saved pointer
        UnlinkTessellatorOutput();

        return hr;
    }

    // If there is any tesselator output in this vertex-shader
    // then you cannot use DrawPrim. DrawRect/Tri is required.
    if( m_pCurrentVShader->m_Declaration.m_dwStreamTessStride != 0 )
    {
        DPFERR( "Cannot call DrawPrim when the current vertex shader has"
                " tesselator output." );
        return D3DERR_INVALIDCALL;
    }
    
    DWORD cVertices = GetVertexCount( pDP->primType, pDP->PrimitiveCount );

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        UINT64 qwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }

        if( FVF_TRANSFORMED(m_CurrentVShaderHandle) )
        {
            HR_RET( GrowTLVArray( cVertices ) );
            FvfToRDVertex( (Stream.m_pData + pDP->VStart * dwStride),
                           GetTLVArray(), qwFVF, dwStride, cVertices );
            if( GetRS()[D3DRENDERSTATE_CLIPPING] )
            {
                m_qwFVFOut = qwFVF;
                HR_RET( UpdateClipper() );
                HR_RET(m_Clipper.DrawOnePrimitive( GetTLVArray(),
                                                   0,
                                                   pDP->primType,
                                                   cVertices ));
            }
            else
            {
                HR_RET(DrawOnePrimitive( GetTLVArray(),
                                         0,
                                         pDP->primType,
                                         cVertices ));
            }

            return S_OK;
        }
    }

    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //

        HR_RET(ProcessPrimitive( pDP->primType, pDP->VStart,
                                 cVertices, 0, 0 ));

    }
    else
    {
        //
        // Pure Vertex Shader
        //

        HR_RET(ProcessPrimitiveVVM( pDP->primType, pDP->VStart,
                                    cVertices, 0, 0 ));
    }

    return hr;
}

//-----------------------------------------------------------------------------
// RefDev::DrawDX8Prim2
//-----------------------------------------------------------------------------
HRESULT
RefDev::DrawDX8Prim2( LPD3DHAL_DP2DRAWPRIMITIVE2 pDP )
{
    HRESULT hr = S_OK;
    DWORD cVertices = GetVertexCount( pDP->primType, pDP->PrimitiveCount );

    if( !RDVSD_ISLEGACY ( m_CurrentVShaderHandle ) ||
        !FVF_TRANSFORMED( m_CurrentVShaderHandle ) )
    {
        DPFERR( "DrawPrimitives2 should be called with transformed legacy vertices" );
        return E_FAIL;
    }
    //
    // The legacy FVF style: The Zero'th Stream is implied
    //
    UINT64 qwFVF    = m_CurrentVShaderHandle;
    RDVStream& Stream = m_VStream[0];
    DWORD dwStride = Stream.m_dwStride;
    DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

    if( Stream.m_pData == NULL || dwStride == 0 )
    {
        DPFERR( "Zero'th stream doesnt have valid VB set" );
        return DDERR_INVALIDPARAMS;
    }
    if( dwStride < dwFVFSize )
    {
        DPFERR( "The stride set for the vertex stream is less than"
                " the FVF vertex size" );
        return E_FAIL;
    }

    HR_RET( GrowTLVArray( cVertices ) );
    FvfToRDVertex( (Stream.m_pData + pDP->FirstVertexOffset),
                   GetTLVArray(), qwFVF, dwStride, cVertices );

    HR_RET(DrawOnePrimitive( GetTLVArray(), 0, pDP->primType,
                               cVertices ));

    return S_OK;
}

//-----------------------------------------------------------------------------
// RefVP::DrawDX8IndexedPrim
//-----------------------------------------------------------------------------

HRESULT
RefDev::DrawDX8IndexedPrim(
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP )
{
    HRESULT hr = S_OK;

    if( GetRSf()[D3DRS_PATCHSEGMENTS] > 1.f )
    {
        // Save current data stream pointers and replace with
        // pointer to tessellation output
        hr = LinkTessellatorOutput();
        if(FAILED(hr))
        {
            return hr;
        }

        hr = ProcessTessIndexedPrimitive( pDIP );

        // Restore back saved pointer
        UnlinkTessellatorOutput();

        return hr;
    }

    // If there is any tesselator output in this vertex-shader
    // then you cannot use DrawPrim. DrawRect/Tri is required.
    if( m_pCurrentVShader->m_Declaration.m_dwStreamTessStride != 0 )
    {
        DPFERR( "Cannot call DrawIndexedPrim when the current vertex shader"
                " has tesselator output." );
        return D3DERR_INVALIDCALL;
    }
    
    DWORD cIndices = GetVertexCount( pDIP->primType, pDIP->PrimitiveCount );

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        UINT64 qwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }

        if( m_IndexStream.m_pData == NULL )
        {
            DPFERR( "Indices are not available" );
            return E_FAIL;
        }

        if( FVF_TRANSFORMED(m_CurrentVShaderHandle) )
        {
            DWORD cVertices = pDIP->NumVertices + pDIP->MinIndex;
            HR_RET( GrowTLVArray( cVertices ) );
            FvfToRDVertex( (Stream.m_pData + pDIP->BaseVertexIndex * dwStride),
                           GetTLVArray(), qwFVF, dwStride, cVertices );
            if( GetRS()[D3DRENDERSTATE_CLIPPING] )
            {
                m_qwFVFOut = qwFVF;
                HR_RET( UpdateClipper() );
                if( m_IndexStream.m_dwStride == 4 )
                {
                    HR_RET( m_Clipper.DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPDWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
                else
                {
                    HR_RET( m_Clipper.DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
            }
            else
            {
                if( m_IndexStream.m_dwStride == 4 )
                {
                    HR_RET(DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPDWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
            }

            return S_OK;
        }
    }


    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //
        HR_RET(ProcessPrimitive( pDIP->primType,
                                 pDIP->BaseVertexIndex,
                                 pDIP->NumVertices + pDIP->MinIndex,
                                 pDIP->StartIndex,
                                 cIndices ));
    }
    else
    {
        //
        // Pure Vertex Shader
        //
        HR_RET(ProcessPrimitiveVVM( pDIP->primType,
                                    pDIP->BaseVertexIndex,
                                    pDIP->NumVertices + pDIP->MinIndex,
                                    pDIP->StartIndex,
                                    cIndices ));
    }

    return hr;
}

//-----------------------------------------------------------------------------
// RefVP::DrawDX8IndexedPrim2
//-----------------------------------------------------------------------------

HRESULT
RefDev::DrawDX8IndexedPrim2(
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pDIP )
{
    HRESULT hr = S_OK;
    DWORD cIndices = GetVertexCount( pDIP->primType, pDIP->PrimitiveCount );

    if( !RDVSD_ISLEGACY ( m_CurrentVShaderHandle ) ||
        !FVF_TRANSFORMED( m_CurrentVShaderHandle ) )
    {
        DPFERR( "DrawIndexedPrimitive2 should be called with transformed legacy vertices" );
        return E_FAIL;
    }

    //
    // The legacy FVF style: The Zero'th Stream is implied
    //
    UINT64 qwFVF    = m_CurrentVShaderHandle;
    RDVStream& Stream = m_VStream[0];
    DWORD dwStride = Stream.m_dwStride;
    DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

    if( Stream.m_pData == NULL || dwStride == 0)
    {
        DPFERR( "Zero'th stream doesnt have valid VB set" );
        return DDERR_INVALIDPARAMS;
    }
    if( dwStride < dwFVFSize )
    {
        DPFERR( "The stride set for the vertex stream is less than"
                " the FVF vertex size" );
        return E_FAIL;
    }

    if( m_IndexStream.m_pData == NULL )
    {
        DPFERR( "Indices are not available" );
        return E_FAIL;
    }

    DWORD cVertices = pDIP->NumVertices;
    HR_RET( GrowTLVArray( cVertices ) );
    FvfToRDVertex( (Stream.m_pData + pDIP->BaseVertexOffset +
                    pDIP->MinIndex * dwStride),
                   GetTLVArray(),
                   qwFVF, dwStride,
                   cVertices );

    if( m_IndexStream.m_dwStride == 4 )
    {
        HR_RET(DrawOneIndexedPrimitive(
            GetTLVArray(),
            -(int)pDIP->MinIndex,
            (LPDWORD)( m_IndexStream.m_pData + pDIP->StartIndexOffset),
            0,
            cIndices,
            pDIP->primType ));
    }
    else
    {
        HR_RET(DrawOneIndexedPrimitive(
            GetTLVArray(),
            -(int)pDIP->MinIndex,
            (LPWORD)( m_IndexStream.m_pData + pDIP->StartIndexOffset),
            0,
            cIndices,
            pDIP->primType ));
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefVP::DrawDX8ClippedTriangleFan
//-----------------------------------------------------------------------------

HRESULT
RefDev::DrawDX8ClippedTriFan(
    LPD3DHAL_CLIPPEDTRIANGLEFAN pCTF )
{
    BOOL bWireframe =
        GetRS()[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME;

    HRESULT hr = S_OK;
    DWORD cVertices = GetVertexCount( D3DPT_TRIANGLEFAN,
                                      pCTF->PrimitiveCount );

    if( !RDVSD_ISLEGACY ( m_CurrentVShaderHandle ) ||
        !FVF_TRANSFORMED( m_CurrentVShaderHandle ) )
    {
        DPFERR( "DrawPrimitives2 should be called with transformed legacy"
                " vertices" );
        return E_FAIL;
    }
    //
    // The legacy FVF style: The Zero'th Stream is implied
    //
    UINT64 qwFVF    = m_CurrentVShaderHandle;
    RDVStream& Stream = m_VStream[0];
    DWORD dwStride = Stream.m_dwStride;
    DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

    if( Stream.m_pData == NULL || dwStride == 0 )
    {
        DPFERR( "Zero'th stream doesnt have valid VB set" );
        return DDERR_INVALIDPARAMS;
    }
    if( dwStride < dwFVFSize )
    {
        DPFERR( "The stride set for the vertex stream is less than"
                " the FVF vertex size" );
        return E_FAIL;
    }

    HR_RET( GrowTLVArray( cVertices ) );
    FvfToRDVertex( (Stream.m_pData + pCTF->FirstVertexOffset),
                   GetTLVArray(), qwFVF, dwStride, cVertices );

    if( bWireframe )
    {
        HR_RET(DrawOneEdgeFlagTriangleFan( GetTLVArray(), cVertices,
                                             pCTF->dwEdgeFlags ));
    }
    else
    {
        HR_RET(DrawOnePrimitive( GetTLVArray(), 0, D3DPT_TRIANGLEFAN,
                                 cVertices ));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\ref8\tnl\vshader.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vvm.cpp
 *  Content:    Virtual Vertex Machine implementation
 *
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

float MINUS_MAX()
{
    DWORD v = 0xFF7FFFFF;
    return *(float*)&v;
}

float PLUS_MAX()
{
    DWORD v = 0x7F7FFFFF;
    return *(float*)&v;
}

//-----------------------------------------------------------------------------
// Returns instruction size, based on the op-code
//
UINT GetInstructionLength(DWORD inst)
{
    DWORD opcode = D3DSI_GETOPCODE( inst );
    // returns number of source operands + length of opcode and the destination
    switch (opcode)
    {
    case D3DSIO_MOV :  return 1 + 2;
    case D3DSIO_ADD :  return 2 + 2;
    case D3DSIO_MAD :  return 3 + 2;
    case D3DSIO_MUL :  return 2 + 2;
    case D3DSIO_RCP :  return 1 + 2;
    case D3DSIO_RSQ :  return 1 + 2;
    case D3DSIO_DP3 :  return 2 + 2;
    case D3DSIO_DP4 :  return 2 + 2;
    case D3DSIO_MIN :  return 2 + 2;
    case D3DSIO_MAX :  return 2 + 2;
    case D3DSIO_SLT :  return 2 + 2;
    case D3DSIO_SGE :  return 2 + 2;
    case D3DSIO_EXP :  return 1 + 2;
    case D3DSIO_LOG :  return 1 + 2;
    case D3DSIO_EXPP:  return 1 + 2;
    case D3DSIO_LOGP:  return 1 + 2;
    case D3DSIO_LIT :  return 1 + 2;
    case D3DSIO_DST :  return 2 + 2;
    case D3DSIO_FRC :  return 1 + 2;
    case D3DSIO_M4x4:  return 2 + 2;
    case D3DSIO_M4x3:  return 2 + 2;
    case D3DSIO_M3x4:  return 2 + 2;
    case D3DSIO_M3x3:  return 2 + 2;
    case D3DSIO_M3x2:  return 2 + 2;
    case D3DSIO_NOP :  return 1;
    default: return 1;
    case D3DSIO_COMMENT: return 1 + ((inst & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
    }
}

#if 0

//-----------------------------------------------------------------------------
HRESULT CVertexVM::GetDataPointer(DWORD dwMemType, RDVECTOR4 ** pData)
{
    try
    {
        *pData = this->GetDataAddr(dwMemType, 0);
    }
    catch (CD3DException e)
    {
        *pData = NULL;
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  RefVM implementation.
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Vertex Virtual Machine Opcode implementations
//-----------------------------------------------------------------------------
void
RefVM::WriteResult()
{
    if( m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        *m_pDest = m_TmpReg;
    }
    else
    {
        if( m_WriteMask & D3DSP_WRITEMASK_0)
            m_pDest->x = m_TmpReg.x;
        if( m_WriteMask & D3DSP_WRITEMASK_1)
            m_pDest->y = m_TmpReg.y;
        if( m_WriteMask & D3DSP_WRITEMASK_2)
            m_pDest->z = m_TmpReg.z;
        if( m_WriteMask & D3DSP_WRITEMASK_3)
            m_pDest->w = m_TmpReg.w;
    }
}
//-----------------------------------------------------------------------------
void
RefVM::InstMov()
{
    SetDestReg();
    SetSrcReg(0);

    if( m_pDest == m_reg.m_a )
    {
        float p = (float)floor(m_Source[0].x);
        *(int*)&m_pDest->x = FTOI(p);
    }
    else
    {
        m_TmpReg = m_Source[0];
        WriteResult();
    }
}
//-----------------------------------------------------------------------------
void
RefVM::InstAdd()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = m_Source[0].x + m_Source[1].x;
    m_TmpReg.y = m_Source[0].y + m_Source[1].y;
    m_TmpReg.z = m_Source[0].z + m_Source[1].z;
    m_TmpReg.w = m_Source[0].w + m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMad()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);
    SetSrcReg(2);

    m_TmpReg.x = m_Source[0].x * m_Source[1].x + m_Source[2].x;
    m_TmpReg.y = m_Source[0].y * m_Source[1].y + m_Source[2].y;
    m_TmpReg.z = m_Source[0].z * m_Source[1].z + m_Source[2].z;
    m_TmpReg.w = m_Source[0].w * m_Source[1].w + m_Source[2].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMul()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = m_Source[0].x * m_Source[1].x;
    m_TmpReg.y = m_Source[0].y * m_Source[1].y;
    m_TmpReg.z = m_Source[0].z * m_Source[1].z;
    m_TmpReg.w = m_Source[0].w * m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstRcp()
{
    SetDestReg();
    SetSrcReg(0);

    if( m_Source[0].w == 1.0f )
    {
        // Must be exactly 1.0
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = 1.0f;
    }
    else if( m_Source[0].w == 0 )
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = PLUS_MAX();
    }
    else
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = 1.0f/m_Source[0].w;
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstRsq()
{
    SetDestReg();
    SetSrcReg(0);

    float v = ABSF(m_Source[0].w);
    if( v == 1.0f )
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = 1.0f;
    }
    else if( v == 0 )
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = PLUS_MAX();
    }
    else
    {
        v = (float)(1.0f / sqrt(v));
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = v;
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstDP3()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x =
    m_TmpReg.y =
    m_TmpReg.z =
    m_TmpReg.w = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstDP4()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x =
    m_TmpReg.y =
    m_TmpReg.z =
    m_TmpReg.w = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z +
                 m_Source[0].w * m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstSlt()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = (m_Source[0].x < m_Source[1].x) ? 1.0f : 0.0f;
    m_TmpReg.y = (m_Source[0].y < m_Source[1].y) ? 1.0f : 0.0f;
    m_TmpReg.z = (m_Source[0].z < m_Source[1].z) ? 1.0f : 0.0f;
    m_TmpReg.w = (m_Source[0].w < m_Source[1].w) ? 1.0f : 0.0f;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstSge()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = (m_Source[0].x >= m_Source[1].x) ? 1.0f : 0.0f;
    m_TmpReg.y = (m_Source[0].y >= m_Source[1].y) ? 1.0f : 0.0f;
    m_TmpReg.z = (m_Source[0].z >= m_Source[1].z) ? 1.0f : 0.0f;
    m_TmpReg.w = (m_Source[0].w >= m_Source[1].w) ? 1.0f : 0.0f;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMin()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x=(m_Source[0].x < m_Source[1].x) ? m_Source[0].x : m_Source[1].x;
    m_TmpReg.y=(m_Source[0].y < m_Source[1].y) ? m_Source[0].y : m_Source[1].y;
    m_TmpReg.z=(m_Source[0].z < m_Source[1].z) ? m_Source[0].z : m_Source[1].z;
    m_TmpReg.w=(m_Source[0].w < m_Source[1].w) ? m_Source[0].w : m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMax()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x=(m_Source[0].x >= m_Source[1].x) ? m_Source[0].x : m_Source[1].x;
    m_TmpReg.y=(m_Source[0].y >= m_Source[1].y) ? m_Source[0].y : m_Source[1].y;
    m_TmpReg.z=(m_Source[0].z >= m_Source[1].z) ? m_Source[0].z : m_Source[1].z;
    m_TmpReg.w=(m_Source[0].w >= m_Source[1].w) ? m_Source[0].w : m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstExp()
{
    SetDestReg();
    SetSrcReg(0);

    float v = m_Source[0].w;

    m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = (float)pow(2, v);

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstExpP()
{
    SetDestReg();
    SetSrcReg(0);

    float w = m_Source[0].w;
    float v = (float)floor(m_Source[0].w);

    m_TmpReg.x = (float)pow(2, v);
    m_TmpReg.y = w - v;
    // Reduced precision exponent
    float tmp = (float)pow(2, w);
    DWORD tmpd = *(DWORD*)&tmp & 0xffffff00;
    m_TmpReg.z = *(float*)&tmpd;
    m_TmpReg.w = 1;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstLog()
{
    SetDestReg();
    SetSrcReg(0);

    float v = ABSF(m_Source[0].w);
    if (v != 0)
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w =
            (float)(log(v)/log(2));
    }
    else
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = MINUS_MAX();
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstLogP()
{
    SetDestReg();
    SetSrcReg(0);

    float v = ABSF(m_Source[0].w);
    if (v != 0)
    {
        int p = (int)(*(DWORD*)&v >> 23) - 127;
        m_TmpReg.x = (float)p;    // exponent
        p = (*(DWORD*)&v & 0x7FFFFF) | 0x3f800000;
        m_TmpReg.y =  *(float*)&p;// mantissa;
        float tmp = (float)(log(v)/log(2));
        DWORD tmpd = *(DWORD*)&tmp & 0xffffff00;
        m_TmpReg.z = *(float*)&tmpd;
        m_TmpReg.w = 1;
    }
    else
    {
        m_TmpReg.x = MINUS_MAX();
        m_TmpReg.y = 1.0f;
        m_TmpReg.z = MINUS_MAX();
        m_TmpReg.w = 1.0f;
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstLit()
{
    SetDestReg();
    SetSrcReg(0);

    m_TmpReg.x = 1;
    m_TmpReg.y = 0;
    m_TmpReg.z = 0;
    m_TmpReg.w = 1;
    float power = m_Source[0].w;
    const float MAXPOWER = 127.9961f;
    if (power < -MAXPOWER)
        power = -MAXPOWER;          // Fits into 8.8 fixed point format
    else
    if (power > MAXPOWER)
        power = MAXPOWER;          // Fits into 8.8 fixed point format

    if (m_Source[0].x > 0)
    {
        m_TmpReg.y = m_Source[0].x;
        if (m_Source[0].y > 0)
        {
            // Allowed approximation is EXP(power * LOG(m_Source[0].y))
            m_TmpReg.z = (float)(pow(m_Source[0].y, power));
        }
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstFrc()
{
    SetDestReg();
    SetSrcReg(0);

    m_TmpReg.x = m_Source[0].x - (float)floor(m_Source[0].x);
    m_TmpReg.y = m_Source[0].y - (float)floor(m_Source[0].y);
    m_TmpReg.z = m_Source[0].z - (float)floor(m_Source[0].z);
    m_TmpReg.w = m_Source[0].w - (float)floor(m_Source[0].w);

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstDst()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = 1;
    m_TmpReg.y = m_Source[0].y * m_Source[1].y;
    m_TmpReg.z = m_Source[0].z;
    m_TmpReg.w = m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstM4x4()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 4);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z +
                 m_Source[0].w * m_Source[1].w;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z +
                 m_Source[0].w * m_Source[2].w;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z +
                 m_Source[0].w * m_Source[3].w;
    m_TmpReg.w = m_Source[0].x * m_Source[4].x +
                 m_Source[0].y * m_Source[4].y +
                 m_Source[0].z * m_Source[4].z +
                 m_Source[0].w * m_Source[4].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstM4x3()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 3);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z +
                 m_Source[0].w * m_Source[1].w;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z +
                 m_Source[0].w * m_Source[2].w;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z +
                 m_Source[0].w * m_Source[3].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstM3x4()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 4);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z;
    m_TmpReg.w = m_Source[0].x * m_Source[4].x +
                 m_Source[0].y * m_Source[4].y +
                 m_Source[0].z * m_Source[4].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
void RefVM::InstM3x3()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 3);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
void RefVM::InstM3x2()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 2);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
// RefVM::SetData
//     Save data into the specified registers.
//-----------------------------------------------------------------------------
HRESULT
RefVM::SetData( DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                     LPVOID pBuffer )
{
    memcpy( GetDataAddr( dwMemType, dwStart ), pBuffer,
            dwCount * sizeof(RDVECTOR4) );
    return D3D_OK;
}

//-----------------------------------------------------------------------------
// RefVM::GetData
//      Fetch data from the specified registers.
//-----------------------------------------------------------------------------
HRESULT
RefVM::GetData( DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                     LPVOID pBuffer )
{
    memcpy( pBuffer, GetDataAddr( dwMemType, dwStart ),
               dwCount * sizeof(RDVECTOR4) );
    return D3D_OK;
}

//-----------------------------------------------------------------------------
// RefVM::SetDestReg
// - parses destination token
// - computes m_pDest, m_WrideMask, m_dwOffset for the destination
// - current token pointer is andvanced to the next token
//-----------------------------------------------------------------------------
#undef RET_ERR
#define RET_ERR( a )     \
{                        \
    DPFERR( a );         \
    return E_FAIL;       \
}
HRESULT
RefVM::SetDestReg()
{
    DWORD dwCurToken = *m_pCurToken;
    DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    m_dwRegOffset = D3DSI_GETREGNUM(dwCurToken);
    m_WriteMask = D3DSI_GETWRITEMASK(dwCurToken);
    switch( dwRegType )
    {
    case D3DSPR_TEMP:
        m_pDest = m_reg.m_t;
        break;
    case D3DSPR_RASTOUT:
        m_pDest = m_reg.m_out;
        break;
    case D3DSPR_ATTROUT:
        m_pDest = m_reg.m_col;
        break;
    case D3DSPR_TEXCRDOUT:
        m_pDest = m_reg.m_tex;
        break;
    case D3DSPR_ADDR:
        m_pDest = m_reg.m_a;
        break;
    default:
        RET_ERR( "Invalid register for destination" );
    }
    m_pCurToken++;
    m_pDest += m_dwRegOffset;
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefVM::SetSrcReg
//  Computes m_Source[index] and advances m_pCurToken
//-----------------------------------------------------------------------------
HRESULT
RefVM::SetSrcReg( DWORD index )
{
    const DWORD dwCurToken = *m_pCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE( dwCurToken );
    const DWORD dwOffset = D3DSI_GETREGNUM( dwCurToken );
    RDVECTOR4 *src = NULL;
    if( dwRegType == D3DSPR_CONST )
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE( dwCurToken );
        int offset = (int)dwOffset;
        if( am == D3DVS_ADDRMODE_RELATIVE )
        {
            int relOffset = *(int*)&m_reg.m_a[0].x;
            offset += relOffset;
            if( offset < 0 || offset >= RD_MAX_NUMCONSTREG )
                RET_ERR( "Constant register index is out of bounds" );
        }
        src = &m_reg.m_c[offset];
    }
    else
        src = this->GetDataAddr(dwRegType, dwOffset);

    _ASSERT( src != NULL, "src is NULL" );
    RDVECTOR4 *outsrc = &m_Source[index];
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);
    if( swizzle == D3DVS_NOSWIZZLE )
        *outsrc = *src;
    else
    {
        // Where to take X
        const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
        // Where to take Y
        const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
        // Where to take Z
        const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
        // Where to take W
        const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
        outsrc->x = ((float*)src)[dwSrcX];
        outsrc->y = ((float*)src)[dwSrcY];
        outsrc->z = ((float*)src)[dwSrcZ];
        outsrc->w = ((float*)src)[dwSrcW];
    }
    if( D3DVS_GETSRCMODIFIER( dwCurToken ) == D3DSPSM_NEG)
    {
        outsrc->x = -outsrc->x;
        outsrc->y = -outsrc->y;
        outsrc->z = -outsrc->z;
        outsrc->w = -outsrc->w;
    }
    m_pCurToken++;
    return S_OK;
}
//-----------------------------------------------------------------------------
// RefVM::SetSrcReg
//  Computes m_Source[index] and advances m_pCurToken
//-----------------------------------------------------------------------------
HRESULT
RefVM::SetSrcReg( DWORD index, DWORD count )
{
    const DWORD dwCurToken = *m_pCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    const DWORD dwOffset = D3DSI_GETREGNUM(dwCurToken);
    RDVECTOR4 *src;
    if (dwRegType == D3DSPR_CONST)
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE(dwCurToken);
        int offset = (int)dwOffset;
        if (am == D3DVS_ADDRMODE_RELATIVE)
        {
            int relOffset = *(int*)&m_reg.m_a[0].x;
            offset += relOffset;
            if (offset < 0 || offset >= RD_MAX_NUMCONSTREG)
                RET_ERR( "Constant register index is out of bounds" );
        }
        src = &m_reg.m_c[offset];
    }
    else
    {
        if (dwOffset >= RD_MAX_NUMCONSTREG)
            RET_ERR( "Constant register index is out of bounds" );
        src = this->GetDataAddr(dwRegType, dwOffset);
    }
    RDVECTOR4 *outsrc = &m_Source[index];
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);
    // Where to take X
    const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
    // Where to take Y
    const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
    // Where to take Z
    const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
    // Where to take W
    const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
    for (UINT i=0; i < count; i++)
    {
        if (swizzle == D3DVS_NOSWIZZLE)
            *outsrc = *src;
        else
        {
            outsrc->x = ((float*)src)[dwSrcX];
            outsrc->y = ((float*)src)[dwSrcY];
            outsrc->z = ((float*)src)[dwSrcZ];
            outsrc->w = ((float*)src)[dwSrcW];
        }
        if (D3DVS_GETSRCMODIFIER(dwCurToken) == D3DSPSM_NEG)
        {
            outsrc->x = -outsrc->x;
            outsrc->y = -outsrc->y;
            outsrc->z = -outsrc->z;
            outsrc->w = -outsrc->w;
        }
        outsrc++;
        src++;
    }
    m_pCurToken++;
    return S_OK;
}

//---------------------------------------------------------------------
// RefVM::GetDataAddr
//     Parses binary shader representation, compiles is and returns
//     compiled object
//---------------------------------------------------------------------
RDVECTOR4*
RefVM::GetDataAddr(DWORD dwRegType, DWORD dwElementIndex)
{
    RDVECTOR4* src;
    switch( dwRegType )
    {
    case D3DSPR_TEMP    : src = m_reg.m_t; break;
    case D3DSPR_INPUT   : src = m_reg.m_i; break;
    case D3DSPR_CONST   : src = m_reg.m_c; break;
    case D3DSPR_ADDR    : src = m_reg.m_a; break;
    case D3DSPR_RASTOUT : src = m_reg.m_out; break;
    case D3DSPR_ATTROUT : src = m_reg.m_col; break;
    case D3DSPR_TEXCRDOUT   : src = m_reg.m_tex; break;
    default:
        return NULL;
    }
    return &src[dwElementIndex];
}

//---------------------------------------------------------------------
// RefVM::ExecuteShader()
//      Executes the shader once per vertex.
//---------------------------------------------------------------------
HRESULT
RefVM::ExecuteShader(RefDev *pRD)
{
    if( m_pCurrentShaderCode == NULL )
    {
        RET_ERR( "No current shader set in the Virtual Shader Machine" );
    }

    m_pCurToken = m_pCurrentShaderCode->m_pRawBits;
    DWORD* pEnd = m_pCurToken + m_pCurrentShaderCode->m_dwSize;
    m_pCurToken++;
    m_CurInstIndex = 0;
    while( m_pCurToken < pEnd )
    {
        if( *m_pCurToken == D3DVS_END() ) break;
        DWORD dwInst = *m_pCurToken;
        DWORD dwOpCode = D3DSI_GETOPCODE( dwInst );
        m_pCurToken++;
        switch( dwOpCode )
        {
        case D3DSIO_COMMENT: m_pCurToken += (GetInstructionLength( dwInst ) - 1);
        case D3DSIO_NOP  : ; break;
        case D3DSIO_MOV  : InstMov();  break;
        case D3DSIO_ADD  : InstAdd();  break;
        case D3DSIO_MAD  : InstMad();  break;
        case D3DSIO_MUL  : InstMul();  break;
        case D3DSIO_RCP  : InstRcp();  break;
        case D3DSIO_RSQ  : InstRsq();  break;
        case D3DSIO_DP3  : InstDP3();  break;
        case D3DSIO_DP4  : InstDP4();  break;
        case D3DSIO_MIN  : InstMin();  break;
        case D3DSIO_MAX  : InstMax();  break;
        case D3DSIO_SLT  : InstSlt();  break;
        case D3DSIO_SGE  : InstSge();  break;
        case D3DSIO_EXPP : InstExpP(); break;
        case D3DSIO_LOGP : InstLogP(); break;
        case D3DSIO_EXP  : InstExp();  break;
        case D3DSIO_LOG  : InstLog();  break;
        case D3DSIO_LIT  : InstLit();  break;
        case D3DSIO_DST  : InstDst();  break;
        case D3DSIO_FRC  : InstFrc();  break;
        case D3DSIO_M4x4 : InstM4x4(); break;
        case D3DSIO_M4x3 : InstM4x3(); break;
        case D3DSIO_M3x4 : InstM3x4(); break;
        case D3DSIO_M3x3 : InstM3x3(); break;
        case D3DSIO_M3x2 : InstM3x2(); break;
        default:
            RET_ERR( "Invalid shader opcode" );
        }
        if (pRD->m_pDbgMon) pRD->m_pDbgMon->NextEvent( D3DDM_EVENT_VERTEXSHADERINST );
        if( dwOpCode != D3DSIO_COMMENT ) m_CurInstIndex++;
    }
    m_CurInstIndex = 0;

    return D3D_OK;
}

//-----------------------------------------------------------------------------
// VertexShaderInstDisAsm - Generates human-readable character string for a
// single vertex shader instruction.  String interface is similar to _snprintf.
//-----------------------------------------------------------------------------
static int VertexShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags )
{
    DWORD*  pToken = pShader;

    // stage in local string, then copy
    char pStr[256] = "";
#define _ADDSTR( _Str ) { _snprintf( pStr, 256, "%s" _Str , pStr ); }
#define _ADDSTRP( _Str, _Param ) { _snprintf( pStr, 256, "%s" _Str , pStr, _Param ); }

    DWORD Inst = *pToken++;
    DWORD Opcode = (Inst & D3DSI_OPCODE_MASK);
    switch (Opcode)
    {
    case D3DSIO_NOP:  _ADDSTR("NOP");  break;
    case D3DSIO_MOV:  _ADDSTR("MOV");  break;
    case D3DSIO_ADD:  _ADDSTR("ADD");  break;
    case D3DSIO_MAD:  _ADDSTR("MAD");  break;
    case D3DSIO_MUL:  _ADDSTR("MUL");  break;
    case D3DSIO_RCP:  _ADDSTR("RCP");  break;
    case D3DSIO_RSQ:  _ADDSTR("RSQ");  break;
    case D3DSIO_DP3:  _ADDSTR("DP3");  break;
    case D3DSIO_DP4:  _ADDSTR("DP4");  break;
    case D3DSIO_MIN:  _ADDSTR("MIN");  break;
    case D3DSIO_MAX:  _ADDSTR("MAX");  break;
    case D3DSIO_SLT:  _ADDSTR("SLT");  break;
    case D3DSIO_SGE:  _ADDSTR("SGE");  break;
    case D3DSIO_EXP:  _ADDSTR("EXP");  break;
    case D3DSIO_LOG:  _ADDSTR("LOG");  break;
    case D3DSIO_EXPP: _ADDSTR("EXPP"); break;
    case D3DSIO_LOGP: _ADDSTR("LOGP"); break;
    case D3DSIO_LIT:  _ADDSTR("LIT");  break;
    case D3DSIO_DST:  _ADDSTR("DST");  break;
    default        :  _ADDSTR("???");  break;
    }
    if (*pToken & (1L<<31))
    {
        DWORD DstParam = *pToken++;
        switch (DstParam & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP     : _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ADDR     : _ADDSTR(" Addr"); break;
        case D3DSPR_RASTOUT  : _ADDSTRP(" R%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ATTROUT  : _ADDSTRP(" A%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXCRDOUT: _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        }
        if (*pToken & (1L<<31)) _ADDSTR(" ");
        while (*pToken & (1L<<31))
        {
            DWORD SrcParam = *pToken++;
            switch (SrcParam & D3DSP_REGTYPE_MASK)
            {
            case D3DSPR_TEMP     : _ADDSTRP(" T%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_INPUT    : _ADDSTRP(" I%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_CONST    : _ADDSTRP(" C%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            }
            if (*pToken & (1L<<31)) _ADDSTR(",");
        }
    }
    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

//---------------------------------------------------------------------
// RefVM::CompileCode
//     Parses binary shader representation, compiles is and returns
//     compiled object
//---------------------------------------------------------------------
#undef RET_ERR
#define RET_ERR( a )     \
{                        \
    DPFERR( a );         \
    delete pShaderCode;  \
    return NULL;         \
}


RDVShaderCode*
RefVM::CompileCode( DWORD dwSize, LPDWORD pBits )
{
    RDVShaderCode* pShaderCode = new RDVShaderCode();
    if( pShaderCode == NULL )
        RET_ERR( "Out of memory allocating ShaderCode" );

    pShaderCode->m_dwSize = dwSize >> 2; // #DWORDs
    pShaderCode->m_pRawBits = new DWORD[pShaderCode->m_dwSize];
    if( pShaderCode->m_pRawBits == NULL )
        RET_ERR( "Out of memory allocating RawBits" );

    memcpy( pShaderCode->m_pRawBits, (LPBYTE)pBits, dwSize );


    // Based on the what output registers are modified, we compute the
    // corresponding FVF id. The id will be used for memory allocation
    // of the output buffer and will be passed to the rasterizer
    UINT64   qwOutFVF = 0;
    DWORD nTexCoord = 0;        // Number of output texture coordinates
    LPDWORD pEnd = NULL;

    // For each texture register stores the combined write mask.
    // Used to find how many floats are written to each texture coordinates
    DWORD TextureWritten[8];
    memset( TextureWritten, 0, sizeof(TextureWritten) );

    m_pCurToken = pShaderCode->m_pRawBits;
    pEnd = m_pCurToken + pShaderCode->m_dwSize;
    m_pCurToken++; // Skip the version number
    pShaderCode->m_InstCount = 0;
    while( m_pCurToken < pEnd )
    {
        if( *m_pCurToken == D3DVS_END() ) break;
        DWORD* pNextToken = m_pCurToken;
        DWORD dwInst = *m_pCurToken;
        DWORD dwOpCode = D3DSI_GETOPCODE(dwInst);
        if( *m_pCurToken == D3DVS_END() ) break;
        m_pCurToken++;
        switch( dwOpCode )
        {
        case D3DSIO_COMMENT:
        case D3DSIO_NOP  : ; break;
        case D3DSIO_MOV  :
        case D3DSIO_ADD  :
        case D3DSIO_MAD  :
        case D3DSIO_MUL  :
        case D3DSIO_RCP  :
        case D3DSIO_RSQ  :
        case D3DSIO_DP3  :
        case D3DSIO_DP4  :
        case D3DSIO_MIN  :
        case D3DSIO_MAX  :
        case D3DSIO_SLT  :
        case D3DSIO_SGE  :
        case D3DSIO_EXP  :
        case D3DSIO_LOG  :
        case D3DSIO_EXPP :
        case D3DSIO_LOGP :
        case D3DSIO_LIT  :
        case D3DSIO_DST  :
        case D3DSIO_FRC  :
        case D3DSIO_M4x4 :
        case D3DSIO_M4x3 :
        case D3DSIO_M3x4 :
        case D3DSIO_M3x3 :
        case D3DSIO_M3x2 :
        {
            // Find out if output register are modified by the command and
            // update the output FVF
            DWORD dwOffset;
            if( FAILED( SetDestReg() ) )
                RET_ERR( "Invalid shader opcode" );

            RDVECTOR4*   m_pOutRegister = NULL;
            if( m_pDest - m_dwRegOffset != m_reg.m_t )
            {
                dwOffset = m_dwRegOffset;
                m_pOutRegister = m_pDest - m_dwRegOffset;
            }
            else
                break;      // Output register is not modified

            if( m_pOutRegister == m_reg.m_out )
            {
                if (dwOffset == D3DSRO_POSITION)
                {
                    qwOutFVF |= D3DFVF_XYZRHW;
                }
                else if (dwOffset == D3DSRO_FOG)
                {
                    qwOutFVF |= D3DFVFP_FOG;
                }
                else if (dwOffset == D3DSRO_POINT_SIZE)
                {
                    qwOutFVF |= D3DFVF_PSIZE;
                }
            }
            else if( m_pOutRegister == m_reg.m_col )
            {
                if( dwOffset == 0 )
                {
                    qwOutFVF |= D3DFVF_DIFFUSE;
                }
                else
                {
                    qwOutFVF |= D3DFVF_SPECULAR;
                }
            }
            else if( m_pOutRegister == m_reg.m_tex )
            {
                if( TextureWritten[dwOffset] == 0 )
                {
                    nTexCoord++;
                }
                TextureWritten[dwOffset] |= m_WriteMask;
            }
            else if( m_pOutRegister != m_reg.m_a )
                RET_ERR( "Invalid output register offset" );
        }
        break;
        default:
            RET_ERR( "Invalid shader opcode" );
        }
        pShaderCode->m_InstCount++;
        m_pCurToken = pNextToken + GetInstructionLength(dwInst);
    }

    // allocate and set instruction array
    if (pShaderCode->m_InstCount)
    {
        pShaderCode->m_pInst = new RDVShaderInst[pShaderCode->m_InstCount];
        if( pShaderCode->m_pInst == NULL )
            RET_ERR( "Out of memory allocating Instructions" );
        memset( pShaderCode->m_pInst, 0,
            sizeof(RDVShaderInst)*pShaderCode->m_InstCount );

        DWORD dwCurInst = 0;
        m_pCurToken = pShaderCode->m_pRawBits;
        pEnd = m_pCurToken + pShaderCode->m_dwSize;
        m_pCurToken++;
        while( m_pCurToken < pEnd )
        {
            DWORD dwInst = *m_pCurToken;
            DWORD dwOpCode = D3DSI_GETOPCODE( dwInst );
            if( *m_pCurToken == D3DVS_END() ) break;
            UINT ilength = GetInstructionLength( dwInst );
            if (dwOpCode == D3DSIO_COMMENT)
            {
                pShaderCode->m_pInst[dwCurInst].m_Tokens[0] = dwInst;
                pShaderCode->m_pInst[dwCurInst].m_pComment = (m_pCurToken+1);
                pShaderCode->m_pInst[dwCurInst].m_CommentSize = ilength - 1;
            }
            else
            {
                memcpy( pShaderCode->m_pInst[dwCurInst].m_Tokens, m_pCurToken,
                    4*ilength );
                VertexShaderInstDisAsm( pShaderCode->m_pInst[dwCurInst].m_String,
                    RD_MAX_SHADERINSTSTRING, pShaderCode->m_pInst[dwCurInst].m_Tokens, 0x0 );
            }
            m_pCurToken += ilength;
            dwCurInst++;
        }
    }

    qwOutFVF |= nTexCoord << D3DFVF_TEXCOUNT_SHIFT;
    if( nTexCoord )
    {
        for( DWORD i = 0; i < nTexCoord; i++ )
        {
            if( TextureWritten[i] == 0 )
                RET_ERR( "Texture coordinates are not continuous" );
            switch( TextureWritten[i] )
            {
            case D3DSP_WRITEMASK_ALL:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE4(i);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE3(i);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE2(i);
                break;
            case D3DSP_WRITEMASK_0:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE1(i);
                break;
            default:
                RET_ERR( "Invalid write mask for texture register" );
            }
        }
    }
    pShaderCode->m_qwFVFOut = qwOutFVF;
    return pShaderCode;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RefDev implementation.
//
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RefDev::ProcessPrimitiveVVM()
//      Processess and draw the current primitive using the VVM
//---------------------------------------------------------------------
HRESULT
RefDev::ProcessPrimitiveVVM( D3DPRIMITIVETYPE primType,
                             DWORD dwStartVertex,
                             DWORD cVertices,
                             DWORD dwStartIndex,
                             DWORD cIndices )
{
    HRESULT hr = S_OK;
    RDCLIPCODE  clipIntersection = ~0;
    RDCLIPCODE  clipUnion = 0;

    // Save Prim Type for later use
    m_primType      = primType;
    m_dwNumVertices = cVertices;
    m_dwStartVertex = dwStartVertex;
    m_dwNumIndices  = cIndices;
    m_dwStartIndex  = dwStartIndex;

    RDVDeclaration* pDecl = &(m_pCurrentVShader->m_Declaration);
    RDVShaderCode*  pCode = m_pCurrentVShader->m_pCode;
    RDVVMREG* pRegisters = m_RefVM.GetRegisters();

    // Output FVF that was computed at the compile time
    m_qwFVFOut = pCode->m_qwFVFOut;

    //
    // Clipping information depends both on the output FVF computation
    // and the other State, so do it here after both have been computed
    //
    HR_RET( UpdateClipper());

    D3DVALUE scaleX = m_Clipper.scaleX;
    D3DVALUE scaleY = m_Clipper.scaleY;
    D3DVALUE scaleZ = m_Clipper.scaleZ;

    D3DVALUE offsetX = m_Clipper.offsetX;
    D3DVALUE offsetY = m_Clipper.offsetY;
    D3DVALUE offsetZ = m_Clipper.offsetZ;

    //
    // Grow buffers to the requisite size
    //

    // Grow TLVArray if required
    if( FAILED( this->m_TLVArray.Grow( m_dwNumVertices ) ) )
    {
        DPFERR( "Could not grow TL vertex buffer" );
        hr = DDERR_OUTOFMEMORY;
        return hr;
    }

    //
    // Process Vertices
    //
    for( DWORD i = 0; i < m_dwNumVertices; i++ )
    {
        RDVertex& Vout = m_TLVArray[i];
        Vout.SetFVF( pCode->m_qwFVFOut | D3DFVFP_CLIP );

        // Copy vertex elements to the input vertex registers
        for( DWORD j = 0; j < pDecl->m_dwNumElements; j++ )
        {
            RDVElement& ve = pDecl->m_VertexElements[j];
            RDVStream* pStream = &m_VStream[ve.m_dwStreamIndex];
            LPBYTE pData = (LPBYTE)pStream->m_pData + ve.m_dwOffset +
                pStream->m_dwStride * (m_dwStartVertex + i);
            RDVECTOR4* pReg = m_RefVM.GetDataAddr( D3DSPR_INPUT,
                                                      ve.m_dwRegister );

            ve.m_pfnCopy( pData, pReg );
        }

        if (m_pDbgMon) m_pDbgMon->NextEvent( D3DDM_EVENT_VERTEX );

        // Execute the shader
        m_RefVM.ExecuteShader(this);

        // Get the result from the output VVM registers
        float x, y, z, w, inv_w_clip = 0.0f;

        w = pRegisters->m_out[D3DSRO_POSITION].w;
        z = pRegisters->m_out[D3DSRO_POSITION].z;

        // Make clipping rules 0 < x < w;  0 < y < w

        x = (pRegisters->m_out[D3DSRO_POSITION].x + w) * 0.5f;
        y = (pRegisters->m_out[D3DSRO_POSITION].y + w) * 0.5f;

        // Save the clip coordinates
        Vout.m_clip_x = x;
        Vout.m_clip_y = y;
        Vout.m_clip_z = z;
        Vout.m_clip_w = w;

        //
        // Compute clip codes if needed
        //
        if( GetRS()[D3DRENDERSTATE_CLIPPING] )
        {
            RDCLIPCODE clip = m_Clipper.ComputeClipCodes(
                &clipIntersection, &clipUnion, x, y, z, w);
            if( clip == 0 )
            {
                Vout.m_clip = 0;
                inv_w_clip = 1.0f/w;
            }
            else
            {
                if( m_Clipper.UseGuardBand() )
                {
                    if( (clip & ~RDCLIP_INGUARDBAND) == 0 )
                    {
                        // If vertex is inside the guardband we have to compute
                        // screen coordinates
                        inv_w_clip = 1.0f/w;
                        Vout.m_clip = (RDCLIPCODE)clip;
                        goto l_DoScreenCoord;
                    }
                }
                Vout.m_clip = (RDCLIPCODE)clip;
                // If vertex is outside the frustum we can not compute screen
                // coordinates, hence store the clip coordinates
#if 0
                Vout.m_pos.x = x;
                Vout.m_pos.y = y;
                Vout.m_pos.z = z;
                Vout.m_rhw   = w;
#endif
                goto l_DoLighting;
            }
        }
        else
        {
            // We have to check this only for DONOTCLIP case, because otherwise
            // the vertex with "we = 0" will be clipped and screen coordinates
            // will not be computed
            // "clip" is not zero, if "we" is zero.
            if( !FLOAT_EQZ(w) )
                inv_w_clip = D3DVAL(1)/w;
            else
                inv_w_clip = __HUGE_PWR2;
        }
l_DoScreenCoord:
        Vout.m_pos.x = x * inv_w_clip * scaleX + offsetX;
        Vout.m_pos.y = y * inv_w_clip * scaleY + offsetY;
        Vout.m_pos.z = z * inv_w_clip * scaleZ + offsetZ;
        Vout.m_rhw = inv_w_clip;

l_DoLighting:
        if( m_qwFVFOut & D3DFVF_DIFFUSE )
        {
            // Clamp the colors before copying.
            if( FLOAT_LTZ(pRegisters->m_col[0].a) )
                pRegisters->m_col[0].a = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].a, >) )
                pRegisters->m_col[0].a = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[0].r) )
                pRegisters->m_col[0].r = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].r, >) )
                pRegisters->m_col[0].r = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[0].g) )
                pRegisters->m_col[0].g = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].g, >) )
                pRegisters->m_col[0].g = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[0].b) )
                pRegisters->m_col[0].b = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].b, >) )
                pRegisters->m_col[0].b = 1.0f;

            memcpy( &Vout.m_diffuse,&(pRegisters->m_col[0]),
                    sizeof(RDVECTOR4) );
        }
        if( m_qwFVFOut & D3DFVF_SPECULAR )
        {
            if( FLOAT_LTZ(pRegisters->m_col[1].a) )
                pRegisters->m_col[1].a = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].a, >) )
                pRegisters->m_col[1].a = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[1].r) )
                pRegisters->m_col[1].r = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].r, >) )
                pRegisters->m_col[1].r = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[1].g) )
                pRegisters->m_col[1].g = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].g, >) )
                pRegisters->m_col[1].g = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[1].b) )
                pRegisters->m_col[1].b = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].b, >) )
                pRegisters->m_col[1].b = 1.0f;

            memcpy( &Vout.m_specular,&(pRegisters->m_col[1]),
                    sizeof(RDVECTOR4) );
        }
        if( m_qwFVFOut & D3DFVFP_FOG )
        {
            if( FLOAT_LTZ(pRegisters->m_out[D3DSRO_FOG].x) )
                pRegisters->m_out[D3DSRO_FOG].x = 0.0f;

            if( FLOAT_CMP_PONE(pRegisters->m_out[D3DSRO_FOG].x, >) )
                pRegisters->m_out[D3DSRO_FOG].x = 1.0f;

            Vout.m_fog = pRegisters->m_out[D3DSRO_FOG].x;
        }

        // Copy the textures over
        if( m_qwFVFOut & D3DFVF_PSIZE )
        {
            Vout.m_pointsize = pRegisters->m_out[D3DSRO_POINT_SIZE].x;
        }


        // Copy the textures over

        {
            DWORD i, j;
            DWORD numTex = FVF_TEXCOORD_NUMBER(m_qwFVFOut);
            for(  i = 0; i < numTex; i++ )
            {
                DWORD n = GetTexCoordDim( m_qwFVFOut, i );
                // DWORD n = (DWORD)(m_dwTexCoordSizeArray[i] >> 2);
                float *pCoordDest = (float *)&Vout.m_tex[i];
                float *pCoordSrc = (float *)&pRegisters->m_tex[i];
                for( j = 0; j < n; j++ )
                {
                    pCoordDest[j] = pCoordSrc[j];
                }
            }
        }
    }

    if( GetRS()[D3DRENDERSTATE_CLIPPING] )
    {
        m_Clipper.m_clipIntersection = clipIntersection;
        m_Clipper.m_clipUnion = clipUnion;
    }
    else
    {
        m_Clipper.m_clipIntersection = 0;
        m_Clipper.m_clipUnion = 0;
    }


    //
    // Clip and Draw the primitives
    //

    if( m_dwNumIndices )
    {
        if( !NeedClipping((m_Clipper.UseGuardBand()), m_Clipper.m_clipUnion) )
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
        else
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = m_Clipper.DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = m_Clipper.DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
    }
    else
    {
        if( !NeedClipping((m_Clipper.UseGuardBand()), m_Clipper.m_clipUnion) )
        {
            hr = DrawOnePrimitive(
                m_TLVArray,
                0,
                m_primType,
                m_dwNumVertices );
        }
        else
        {
            hr = m_Clipper.DrawOnePrimitive(
                m_TLVArray,
                0,
                m_primType,
                m_dwNumVertices );
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\swrast.inc ===
#
# Contains common settings for pluggable software rasterizers.
#

!ifndef DXGROOT
DXGROOT = $(DXROOT)\dxg
!endif

!ifndef D3D8ROOT
D3D8ROOT = $(DXGROOT)\d3d8
!endif

SWRASTROOT = $(DXGROOT)\swrast

C_DEFINES=$(C_DEFINES) -DDIRECT3D_VERSION=0x0800

INCLUDES = $(SWRASTROOT)\inc;$(D3D8ROOT)\inc;$(DXGROOT)\inc;$(DXROOT)\inc;$(DDK_INC_PATH);$(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\ctrtest.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class TSortedAssociativeContainer, const size_t c_uiNodes>
class CSortedAssociativeContainerTester
{
protected:
    typedef TSortedAssociativeContainer TTest;
    typedef block< pair< TTest::key_type, TTest::value_type::second_type>, c_uiNodes> TNodes;
    struct SAssureOrdered:
        public unary_function< TTest::value_type, bool>
    {
        TNodes::value_type m_LstVal;
        TTest::value_compare m_Cmp;
        size_t m_uiNodes;

        SAssureOrdered( const TTest::value_compare& Cmp): m_Cmp( Cmp),
            m_uiNodes( 0)
        { }
        result_type operator()( const argument_type& Arg)
        {
            result_type Ret( false);

            if( 1!= ++m_uiNodes)
                Ret= m_Cmp( Arg, m_LstVal);
            m_LstVal.first= Arg.first;
            m_LstVal.second= Arg.second;
            return Ret;
        }
    };
    struct SAssureUnOrdered:
        public unary_function< TTest::value_type, bool>
    {
        TNodes::value_type m_LstVal;
        TTest::value_compare m_Cmp;
        size_t m_uiNodes;

        SAssureUnOrdered( const TTest::value_compare& Cmp): m_Cmp( Cmp),
            m_uiNodes( 0)
        { }
        result_type operator()( const argument_type& Arg)
        {
            result_type Ret( false);

            if( 1!= ++m_uiNodes)
                Ret= !m_Cmp( Arg, m_LstVal);
            m_LstVal.first= Arg.first;
            m_LstVal.second= Arg.second;
            return Ret;
        }
    };

protected:
    TTest m_Ctr;
    size_t m_uiPerm;
    TNodes m_Nodes;
    struct TestFailure
    {
        size_t m_uiPerm;
        TestFailure( size_t uiPerm): m_uiPerm( uiPerm) { }
    };

public:
    CSortedAssociativeContainerTester( const TTest& X= TTest()): m_Ctr( X), m_uiPerm( 0)
    {
        TTest::key_type Key( 0);
        // TTest::mapped_type Val( c_uiNodes- 1);
        TTest::value_type::second_type Val( c_uiNodes- 1);
        
        TNodes::iterator itCur( m_Nodes.begin());
        while( itCur!= m_Nodes.end())
        {
            *itCur= TNodes::value_type( Key, Val);
            ++itCur;
            ++Key;
            --Val;
        }
    }
    void Test()
    {
        do
        {
            //try
            {
                TTest NewCtr( m_Ctr);

                if( !NewCtr.empty())
                    throw TestFailure( m_uiPerm);

                if( NewCtr.size()!= 0)
                    throw TestFailure( m_uiPerm);

                if( NewCtr.begin()!= NewCtr.end())
                    throw TestFailure( m_uiPerm);

                if( NewCtr.rbegin()!= NewCtr.rend())
                    throw TestFailure( m_uiPerm);

                if( !NewCtr.valid())
                    throw TestFailure( m_uiPerm);

                TNodes::iterator itCur( m_Nodes.begin());
                while( itCur!= m_Nodes.end())
                {
                    NewCtr.insert( *itCur);
                    ++itCur;

                    if( !NewCtr.valid())
                        throw TestFailure( m_uiPerm);

                    if( NewCtr.size()!= itCur- m_Nodes.begin())
                        throw TestFailure( m_uiPerm);

                    {
                        TTest::difference_type Dist( 0);
                        TTest::iterator f( NewCtr.begin());
                        TTest::iterator l( NewCtr.end());
                        for( ; f!= l; ++f)
                            ++Dist;
                        
                        if( NewCtr.size()!= Dist)
                            throw TestFailure( m_uiPerm);

                        for( ; Dist!= 0; --Dist)
                            --f;
                        
                        if( NewCtr.begin()!= f)
                            throw TestFailure( m_uiPerm);
                    }

                    {
                        TTest::difference_type Dist( 0);
                        TTest::reverse_iterator f( NewCtr.rbegin());
                        TTest::reverse_iterator l( NewCtr.rend());
                        for( ; f!= l; ++f)
                            ++Dist;
                        
                        if( NewCtr.size()!= Dist)
                            throw TestFailure( m_uiPerm);

                        for( ; Dist!= 0; --Dist)
                            --f;
                        
                        if( NewCtr.rbegin()!= f)
                            throw TestFailure( m_uiPerm);
                    }

                    if( NewCtr.end()!= find_if( NewCtr.begin(), NewCtr.end(),
                        SAssureOrdered( NewCtr.value_comp())))
                        throw TestFailure( m_uiPerm);

                    if( NewCtr.rend()!= find_if( NewCtr.rbegin(), NewCtr.rend(),
                        SAssureUnOrdered( NewCtr.value_comp())))
                        throw TestFailure( m_uiPerm);

                    TNodes::iterator itCur2( m_Nodes.begin());
                    while( itCur2!= itCur)
                    {
                        if( NewCtr.end()== NewCtr.find( itCur2->first))
                            throw TestFailure( m_uiPerm);
                        ++itCur2;
                    }

                    TTest NotherCtr( NewCtr);

                    if( !NotherCtr.valid())
                        throw TestFailure( m_uiPerm);

                    itCur2= m_Nodes.begin();
                    while( itCur2!= itCur)
                    {
                        if( 1!= NotherCtr.erase( itCur2->first))
                            throw TestFailure( m_uiPerm);

                        if( !NotherCtr.valid())
                            throw TestFailure( m_uiPerm);

                        ++itCur2;
                        {
                            TTest::difference_type Dist( 0);
                            TTest::iterator f( NotherCtr.begin());
                            TTest::iterator l( NotherCtr.end());
                            for( ; f!= l; ++f)
                                ++Dist;
                        
                            if( NotherCtr.size()!= Dist)
                                throw TestFailure( m_uiPerm);

                            for( ; Dist!= 0; --Dist)
                                --f;
                            
                            if( NotherCtr.begin()!= f)
                                throw TestFailure( m_uiPerm);
                        }

                        {
                            TTest::difference_type Dist( 0);
                            TTest::reverse_iterator f( NotherCtr.rbegin());
                            TTest::reverse_iterator l( NotherCtr.rend());
                            for( ; f!= l; ++f)
                                ++Dist;
                        
                            if( NotherCtr.size()!= Dist)
                                throw TestFailure( m_uiPerm);

                            for( ; Dist!= 0; --Dist)
                                --f;
                            
                            if( NotherCtr.rbegin()!= f)
                                throw TestFailure( m_uiPerm);
                        }


                        if( NotherCtr.end()!= find_if( NotherCtr.begin(), NotherCtr.end(),
                            SAssureOrdered( NotherCtr.value_comp())))
                            throw TestFailure( m_uiPerm);

                        if( NotherCtr.rend()!= find_if( NotherCtr.rbegin(), NotherCtr.rend(),
                            SAssureUnOrdered( NotherCtr.value_comp())))
                            throw TestFailure( m_uiPerm);

                        TNodes::iterator itCur3( itCur2);
                        while( itCur3!= itCur)
                        {
                            if( NotherCtr.end()== NotherCtr.find( itCur3->first))
                                throw TestFailure( m_uiPerm);
                            ++itCur3;
                        }
                    }
                    if( !NotherCtr.empty())
                        throw TestFailure( m_uiPerm);
                }
            }
            /*catch( TestFailure TF)
            { assert( false); }
            catch( bad_alloc BA)
            { assert( false); }
            catch( ... )
            { assert( false); }*/
            ++m_uiPerm;
        } while( false /*next_permutation( m_Nodes.begin(), m_Nodes.end(),
            m_Ctr.value_comp())*/);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\allocator.h ===
template< class T>
class allocator;

template<>
class allocator< void>
{
public: // Types
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template< class U>
    struct rebind
    {
        typedef allocator< U> other;
    };
};

template< class T>
class allocator
{
public: // Types
    typedef T value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;

    typedef T* pointer;
    typedef T const * const_pointer;
    typedef T& reference;
    typedef T const & const_reference;

    template< class U>
    struct rebind
    {
        typedef allocator< U> other;
    };

public: // Functions
    pointer address( reference r) const
    { return &r; }
    const_pointer address( const_reference r) const
    { return &r; }

    allocator() throw()
    { }
    template< class U>
    allocator( const allocator< U>& Other) throw()
    { }
    ~allocator() throw()
    { }

    template< class U>
    bool operator==( const allocator< U>& Other) throw()
    { return true; }
    template< class U>
    bool operator!=( const allocator< U>& Other) throw()
    { return false; }

    pointer allocate( size_type n, allocator<void>::const_pointer hint= 0)
        throw( bad_alloc)
    {
        void* pRet= NULL;
        try {
            if( n<= max_size())
                pRet= operator new ( n* sizeof(value_type));
        } catch( ... ) {
        }
        if( NULL== pRet)
            throw bad_alloc();
        return reinterpret_cast< pointer>( pRet);
    }
    void deallocate( pointer p, size_type n)
    { operator delete (static_cast<void*>(p)); }

    void construct( pointer p, const T& val)
    { new (p) T( val); }
    void destroy( pointer p)
    { p->~T(); }

    size_type max_size() const throw()
    {
        numeric_limits< size_type> Dummy;
        const size_type uiRet( Dummy.max()- 1); // -1 for realistic safety.
        return (0== sizeof( T)? uiRet: uiRet/ sizeof( T));
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\block.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////////////////////////////////////////////////////
//
// block
//
// There should be a block or c_array type in STL, but MSVC might not have one,
// so here it is:
//
////////////////////////////////////////////////////////////////////////////////
template< class T, const size_t N>
struct block
{
    typedef T value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;

    typedef pointer iterator;
    typedef const_pointer const_iterator;
    
    struct reverse_iterator
    {
        typedef random_access_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;

        pointer m_pCur;

        reverse_iterator() throw()
        { }
        reverse_iterator( const iterator& x) throw(): m_pCur( x)
        { }
        operator iterator() const throw()
        { return m_pCur; }
        reference operator*() const throw()
        { return *m_pCur; }
        pointer operator->() const throw()
        { return &(*()); }
        reverse_iterator& operator++() throw()
        {
            --m_pCur;
            return (*this);
        }
        reverse_iterator operator++(int)
        {
            reverse_iterator Tmp( m_pCur);
            ++(*this);
            return Tmp;
        }
        reverse_iterator& operator--()
        {
            ++m_pCur;
            return (*this);
        }
        reverse_iterator operator--(int)
        {
            reverse_iterator Tmp( m_pCur);
            --(*this);
            return Tmp;
        }
        bool operator==( const reverse_iterator& Other) const
        { return (m_pCur== Other.m_pCur); }
        bool operator!=( const reverse_iterator& Other) const
        { return (m_pCur!= Other.m_pCur); }
    };
    struct const_reverse_iterator
    {
        typedef random_access_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;

        const_pointer m_pCur;

        const_reverse_iterator() throw()
        { }
        const_reverse_iterator( const const_iterator& x) throw(): m_pCur( x)
        { }
        const_reverse_iterator( const reverse_iterator& x) throw(): m_pCur( x)
        { }
        operator const_iterator() const throw()
        { return m_pCur; }
        reference operator*() const throw()
        { return *m_pCur; }
        pointer operator->() const throw()
        { return &(*()); }
        const_reverse_iterator& operator++() throw()
        {
            --m_pCur;
            return (*this);
        }
        const_reverse_iterator operator++(int)
        {
            const_reverse_iterator Tmp( m_pCur);
            ++(*this);
            return Tmp;
        }
        const_reverse_iterator& operator--()
        {
            ++m_pCur;
            return (*this);
        }
        const_reverse_iterator operator--(int)
        {
            reverse_iterator Tmp( m_pCur);
            --(*this);
            return Tmp;
        }
        bool operator==( const const_reverse_iterator& Other) const
        { return (m_pCur== Other.m_pCur); }
        bool operator!=( const const_reverse_iterator& Other) const
        { return (m_pCur!= Other.m_pCur); }
    };

    iterator begin() throw() { return data; }
    iterator end() throw() { return data+ N; }
    const_iterator begin() const throw() { return data; }
    const_iterator end() const throw() { return data+ N; }

    reverse_iterator rbegin() throw() { return data+ N- 1; }
    reverse_iterator rend() throw() { return data- 1; }
    const_reverse_iterator rbegin() const throw() { return data+ N- 1; }
    const_reverse_iterator rend() const throw() { return data- 1; }

    reference operator[]( size_type n) throw() {
        return data[n];
    }
    const_reference operator[]( size_type n) const throw() {
        return data[n];
    }

    size_type size() const throw() { return N; }
    size_type max_size() const throw() { return N; }
    bool empty() const throw() { return (0==N); }

    void swap( block<T,N>& x) throw() {
        size_type n(N);
        if( n!= 0) do {
            --n;
            swap( data[n], x.data[n]);
        } while( n!= 0);
    }

    T data[N];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\hash_map.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class T, const size_t Buckets, class HashFun= hash<Key>,
    class EqualKey= equal_to<Key>,
    class Allocator= allocator<pair<Key const, T> > >
class static_hash_map:
    public static_hash_table<pair<const Key, T>, Buckets, Key, HashFun,
        select1st<pair<Key const, T> >, EqualKey, Allocator>
{
public: // Types
    typedef static_hash_map< Key, T, Buckets, HashFun, EqualKey, Allocator>
        map_type;
    typedef static_hash_table<pair<Key const, T>, Buckets, Key, HashFun,
        select1st<pair<Key const, T> >, EqualKey, Allocator> table_type;

    typedef table_type::key_type key_type;
    typedef Allocator::rebind< T>::other mapped_type;
    typedef table_type::value_type value_type;
    typedef table_type::hasher hasher;
    typedef table_type::key_equal key_equal;
    typedef table_type::pointer pointer;
    typedef table_type::const_pointer const_pointer;
    typedef table_type::reference reference;
    typedef table_type::const_reference const_reference;
    typedef table_type::size_type size_type;
    typedef table_type::difference_type difference_type;
    typedef table_type::iterator iterator;
    typedef table_type::const_iterator const_iterator;
    typedef table_type::reverse_iterator reverse_iterator;
    typedef table_type::const_reverse_iterator const_reverse_iterator;
    typedef table_type::allocator_type allocator_type;

public: // Functions.
    using table_type::begin;
    using table_type::end;
    using table_type::rbegin;
    using table_type::rend;
    using table_type::size;
    using table_type::max_size;
    using table_type::empty;
    using table_type::bucket_count;
    using table_type::resize;
    using table_type::hash_funct;
    using table_type::key_eq;
    explicit static_hash_map( const HashFun& h= HashFun(),
        const EqualKey& k= EqualKey(),
        const Allocator& A= Allocator())
        :table_type( h, k, select1st< value_type>(), A)
    { }
    template< class InputIterator>
    static_hash_map( InputIterator f, InputIterator l,
        const HashFun& h= HashFun(), const EqualKey& k= EqualKey(),
        const Allocator& A= Allocator())
        :table_type( h, k, select1st< value_type>(), A)
    { insert( f, l); }
    static_hash_map( const map_type& Other): table_type( Other)
    { }
    ~static_hash_map()
    { }
    using table_type::operator=;
    using table_type::get_allocator;
    using table_type::swap;
    pair< iterator, bool> insert( const value_type& x)
    { return table_type::insert_unique( x); }
    template< class InputIterator>
    void insert( InputIterator f, InputIterator l)
    { return table_type::insert_unique( f, l); }
    using table_type::erase;
    using table_type::find;
    using table_type::count;
    using table_type::equal_range;
    mapped_type& operator[]( const key_type& k)
    {
        iterator itEntry( insert( value_type( k, mapped_type())));
        return itEntry->second;
    }
};

// TODO: Global operators.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\hash_table.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key>
class hash
{
private:
    hash() {}
};

template<>
class hash< char>:
    public unary_function< char, size_t>
{
public:
    result_type operator()( argument_type Arg) const
    { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned char>:
    public unary_function< unsigned char, size_t>
{
public:
    result_type operator()( argument_type Arg) const
    { return static_cast<result_type>(Arg); }
};
template<>
class hash< signed char>:
    public unary_function< signed char, size_t>
{
public:
    result_type operator()( argument_type Arg) const
    { return static_cast<result_type>(Arg); }
};
template<>
class hash< short>:
    public unary_function< short, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned short>:
    public unary_function< unsigned short, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< int>:
    public unary_function< int, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned int>:
    public unary_function< unsigned int, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< long>:
    public unary_function< long, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned long>:
    public unary_function< unsigned long, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};

template< class T, const size_t Buckets, class Key, class HashFun,
    class ExtractKey, class EqualKey, class Allocator>
class static_hash_table:
    public list< T, Allocator>
{
public: // Types
    typedef static_hash_table< T, Buckets, Key, HashFun, ExtractKey, EqualKey,
        Allocator> table_type;
    typedef list< T, Allocator> list_type;

    typedef Key key_type;
    using list_type::value_type;
    typedef HashFun hasher;
    typedef EqualKey key_equal;
    typedef ExtractKey key_extract;
    using list_type::pointer;
    using list_type::const_pointer;
    using list_type::reference;
    using list_type::const_reference;
    using list_type::size_type;
    using list_type::difference_type;
    using list_type::iterator;
    using list_type::const_iterator;
    using list_type::reverse_iterator;
    using list_type::const_reverse_iterator;

protected: // Types
    typedef block< iterator, Buckets+ 1> table_buckets_type;

protected: // Variables
    table_buckets_type m_buckets;
    hasher m_hasher;
    key_equal m_key_equal;
    key_extract m_key_extract;

public: // Functions
    using list_type::begin;
    using list_type::end;
    using list_type::rbegin;
    using list_type::rend;
    using list_type::size;
    using list_type::max_size;
    using list_type::empty;
    size_type bucket_count() const
    { return m_buckets.size()- 1; }
    void resize( size_type n)
    { const bool NYI( false); assert( NYI); /* TODO: NYI */ }
    hasher hash_funct() const
    { return m_hasher; }
    key_equal key_eq() const
    { return m_key_equal; }
    static_hash_table( const HashFun& H, const EqualKey& EqK,
        const ExtractKey& ExK, const allocator_type& A): list_type( A),
        m_hasher( H), m_key_equal( EqK), m_key_extract( ExK)
    {
        fill( m_buckets.begin(), m_buckets.end(), end());
    }
    static_hash_table( const table_type& HT): list_type( HT.get_allocator())
    {
        fill( m_buckets.begin(), m_buckets.end(), end());
        (*this)= HT;
    }
    ~static_hash_table()
    {
    }
    table_type& operator=( const table_type& Other)
    {
        if( this!= &Other)
        {
            clear();
            m_hasher= Other.m_hasher;
            m_key_equal= Other.m_key_equal;
            m_key_extract= Other.m_key_extract;
            // TODO: insert_equal( Other.begin(), Other.end());
            insert_unique( Other.begin(), Other.end());
        }
        return *this;
    }
    using list_type::get_allocator;
    void swap( table_type& Other)
    {
        const bool NYI( false); assert( NYI); 
        /* TODO: NYI
        swap( m_hasher, Other.m_hasher);
        swap( m_key_equal, Other.m_key_equal);
        swap( m_key_extract, Other.m_key_extract);
        if( m_Allocator== Other.m_Allocator)
        {
            list_type::swap( Other);
            m_buckets.swap( Other.m_buckets);
        }
        else
            insert_equal( Other.begin(), Other.end());
        */
    }
    pair< iterator, bool> insert_unique( const value_type& NewVal)
    {
        const key_type NewKey( m_key_extract( NewVal));
        const size_t uiBucket( m_hasher( NewKey)% bucket_count());

        table_buckets_type::iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::iterator itNextBucket( itBucket);
        ++itNextBucket;

        for( iterator itFound( *itBucket); itFound!= *itNextBucket; ++itFound)
            if( m_key_equal( NewKey, m_key_extract( *itFound)))
                return pair< iterator, bool>( itFound, false);
        
        iterator itInsertPos( *itNextBucket);

        table_buckets_type::iterator itBeginFill( m_buckets.begin());
        if( begin()!= itInsertPos)
        {
            iterator itPrevNode( itInsertPos);
            itBeginFill+= ( m_hasher( m_key_extract( *(--itPrevNode)))%
                bucket_count())+ 1;
        }
        
        iterator itNewNode( insert( itInsertPos, NewVal));
        fill( itBeginFill, ++itBucket, itNewNode);
        return pair< iterator, bool>( itNewNode, true);
    }
    template <class InputIterator>
    void insert_unique( InputIterator f, InputIterator l)
    {
        while( f!= l)
        {
            insert_unique( *f);
            ++f;
        }
    }
    iterator insert_equal( const value_type& NewVal)
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return end();
    }
    template< class InputIterator>
    void insert_equal( InputIterator f, InputIterator l)
    {
        while( f!= l)
        {
            insert_equal( *f);
            ++f;
        }
    }
    void erase( iterator pos)
    {
        table_buckets_type::iterator itBeginFill( m_buckets.begin());
        if( begin()!= pos)
        {
            iterator itPrevNode( pos);
            itBeginFill+= ( m_hasher( m_key_extract( *(--itPrevNode)))%
                bucket_count())+ 1;
        }
        table_buckets_type::iterator itEndFill( m_buckets.begin());
        itEndFill+= ( m_hasher( m_key_extract( *pos))% bucket_count())+ 1;

        iterator itNextNode( pos);
        ++itNextNode;
        fill( itBeginFill, itEndFill, itNextNode);
        list_type::erase( pos);
    }
    size_type erase( const key_type& k)
    {
        size_type uiErased( 0);
        const size_type uiBucket( m_hasher( k)% bucket_count());

        table_buckets_type::iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::iterator itNextBucket( itBucket);
        ++itNextBucket;

        iterator itChk( *itBucket);
        // Only the first in the bucket could modify the bucket values.
        if( itChk!= *itNextBucket)
        {
            if( m_key_equal( k, m_key_extract( *itChk)))
            {
                iterator itDel( itChk);
                ++itChk;
                erase( itDel);
                ++uiErased;
            }
            else
                ++itChk;
        }
        while( itChk!= *itNextBucket)
        {
            if( m_key_equal( k, m_key_extract( *itChk)))
            {
                iterator itDel( itChk);
                ++itChk;
                list_type::erase( itDel);
                ++uiErased;
            }
            else
                ++itChk;
        }
        return uiErased;
    }
    void erase( iterator f, iterator l)
    {
        while( f!= l)
        {
            erase( f);
            ++f;
        }
    }
    iterator find( const key_type& k)
    {
        const size_type uiBucket( m_hasher( k)% bucket_count());

        table_buckets_type::iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::iterator itNextBucket( itBucket);
        ++itNextBucket;

        for( iterator itFound( *itBucket); itFound!= *itNextBucket; ++itFound)
            if( m_key_equal( k, m_key_extract( *itFound)))
                return itFound;

        return end();
    } 
    const_iterator find( const key_type& k) const
    {
        const size_type uiBucket( m_hasher( k)% bucket_count());

        table_buckets_type::const_iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::const_iterator itNextBucket( itBucket);
        ++itNextBucket;

        for( const_iterator itFound( *itBucket); itFound!= *itNextBucket; ++itFound)
            if( m_key_equal( k, m_key_extract( *itFound)))
                return itFound;

        return end();
    }
    size_type count( const key_type& k) const
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return 0;
    }
    pair< iterator, iterator> equal_range( const key_type& k)
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return pair< iterator, iterator>( end(), end());
    }
    pair< const_iterator, const_iterator> equal_range( const key_type& k) const
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return pair< const_iterator, const_iterator>( end(), end());
    }
    void clear()
    {
        if( 0!= size())
        {
            fill( m_buckets.begin(), m_buckets.end(), end());
            list_type::clear();
        }
    }
};

// TODO: Global operators.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\list.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class T, class Allocator= allocator< T> >
class list
{
public: // Types
    typedef list< T, Allocator> list_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::value_type value_type;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;

protected: // Types
    struct list_node;
    typedef typename Allocator::rebind< list_node>::other
        list_node_allocator_type;
    typedef typename list_node_allocator_type::pointer list_node_pointer;
    typedef typename list_node_allocator_type::const_pointer
        list_node_const_pointer;
    struct list_node
    {
        list_node_pointer m_pNext;
        list_node_pointer m_pPrev;
        value_type m_Value;

        list_node()
        { }
        list_node( const value_type& Val): m_Value( Val)
        { }
        list_node( const list_node_pointer& pN, const list_node_pointer& pP,
            const value_type& Val): m_pNext( pN), m_pPrev( pP), m_Value( Val)
        { }
        ~list_node()
        { }
    };
    
public: // Types
    class iterator;
    class const_iterator;
    class reverse_iterator;
    class const_reverse_iterator;
    friend class iterator;
    class iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class const_iterator;
        friend class reverse_iterator;
        friend class const_reverse_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_pointer m_pNode;

    public: // Functions
        iterator()
        { }
        explicit iterator( const list_node_pointer& pNode)
            :m_pNode( pNode)
        { }
        iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        iterator& operator++()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        iterator operator++(int)
        {
            iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        iterator& operator--()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        iterator operator--(int)
        {
            iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };
    friend class const_iterator;
    class const_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_reverse_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_const_pointer m_pNode;

    public: // Functions
        const_iterator()
        { }
        explicit const_iterator( const list_node_const_pointer& pNode)
            :m_pNode( pNode)
        { }
        const_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        const_iterator& operator++()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        const_iterator operator++(int)
        {
            const_iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        const_iterator& operator--()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        const_iterator operator--(int)
        {
            const_iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const const_iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const const_iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };
    friend class reverse_iterator;
    class reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class iterator;
        friend class const_iterator;
        friend class const_reverse_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_pointer m_pNode;

    public: // Functions
        reverse_iterator()
        { }
        explicit reverse_iterator( const list_node_pointer& pNode)
            :m_pNode( pNode)
        { }
        reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        reverse_iterator& operator++()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        reverse_iterator operator++(int)
        {
            reverse_iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        reverse_iterator& operator--()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        reverse_iterator operator--(int)
        {
            reverse_iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const reverse_iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const reverse_iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };
    friend class const_reverse_iterator;
    class const_reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_const_pointer m_pNode;

    public: // Functions
        const_reverse_iterator()
        { }
        explicit const_reverse_iterator( const list_node_const_pointer& pNode)
            :m_pNode( pNode)
        { }
        const_reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        const_reverse_iterator& operator++()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        const_reverse_iterator operator++(int)
        {
            const_reverse_iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        const_reverse_iterator& operator--()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        const_reverse_iterator operator--(int)
        {
            const_reverse_iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const const_reverse_iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const const_reverse_iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };

protected: // Variables
    list_node_pointer m_pHead;
    size_type m_uiNodes;
    list_node_allocator_type m_Allocator;

protected: // Functions
    void BuildHeadNode()
    {
        m_pHead= m_Allocator.allocate( 1);
        new (&m_pHead->m_pNext) list_node_pointer( m_pHead);
        new (&m_pHead->m_pPrev) list_node_pointer( m_pHead);
    }
    void DestroyHeadNode()
    {
        m_pHead->m_pNext.~list_node_pointer();
        m_pHead->m_pPrev.~list_node_pointer();
        m_Allocator.deallocate( m_pHead, 1);
    }

public: // Functions
    iterator begin()
    { return iterator( m_pHead->m_pNext); }
    iterator end()
    { return iterator( m_pHead); }
    reverse_iterator rbegin()
    { return reverse_iterator( m_pHead->m_pPrev); }
    reverse_iterator rend()
    { return reverse_iterator( m_pHead); }
    const_iterator begin() const
    { return const_iterator( m_pHead->m_pNext); }
    const_iterator end() const
    { return const_iterator( m_pHead); }
    const_reverse_iterator rbegin() const
    { return const_reverse_iterator( m_pHead->m_pPrev); }
    const_reverse_iterator rend() const
    { return const_reverse_iterator( m_pHead->m_pPrev); }
    size_type size() const
    { return m_uiNodes; }
    size_type max_size() const
    { return m_Allocator.max_size(); }
    bool empty() const
    { return (0== m_uiNodes); }
    explicit list( const Allocator& A= Allocator())
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( A)
    {
        BuildHeadNode();
    }
    explicit list( size_type n, const T& x= T(), const Allocator& A= Allocator())
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( A)
    {
        BuildHeadNode();
        try {
            insert( begin(), n, x);
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    list( const list_type& Other)
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( Other.m_Allocator)
    {
        BuildHeadNode();
        try {
            insert( begin(), Other.begin(), Other.end());
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    template< class InputIterator>
    list( InputIterator f, InputIterator l, const Allocator& A= Allocator())
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( Other.m_Allocator)
    {
        BuildHeadNode();
        try {
            insert( begin(), f, l);
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    ~list()
    { 
        clear();
        DestroyHeadNode();
    }
    list_type& operator=( const list_type& Other)
    {
        if( this!= &Other)
        {
            // TODO: Better exception handling.
            iterator itMyCur( begin());
            iterator itMyEnd( end());
            const_iterator itOtherCur( Other.begin());
            const_iterator itOtherEnd( Other.end());
            while( itMyCur!= itMyEnd && itOtherCur!= itOtherEnd)
            {
                *itMyCur= *itOtherCur;
                ++itMyCur;
                ++itOtherCur;
            }
            erase( itMyCur, itMyEnd);
            insert( itMyCur, itOtherCur, itOtherEnd);
        }
        return (*this);
    }
    allocator_type get_allocator() const
    { return m_Allocator; }
    void swap( list_type& Other)
    {
        if( m_Allocator== Other.m_Allocator)
        {
            swap( m_pHead, Other.m_pHead);
            swap( m_uiNodes, Other.m_uiNodes);
        }
        else
        {
            iterator itMyCur( begin());
            splice( itMyCur, Other);
            itMyCur.splice( Other.begin(), *this, itMyCur, end());
        }
    }
    reference front()
    { return *begin(); }
    const_reference front() const
    { return *begin(); }
    reference back()
    { return *(--end()); }
    const_reference back() const
    { return *(--end()); }
    void push_front( const T& t)
    { insert( begin(), t); }
    void pop_front()
    { erase( begin()); }
    void push_back( const T& t)
    { insert( end(), t); }
    void pop_back()
    { erase( --end()); }
    iterator insert( iterator pos, const T& t)
    {
        list_node_pointer pNode( pos.m_pNode);
        list_node_pointer pPrev( pNode->m_pPrev);
        m_Allocator.construct( pNode->m_pPrev= m_Allocator.allocate( 1),
            list_node( pNode, pPrev, t));
        pNode= pNode->m_pPrev;
        pNode->m_pPrev->m_pNext= pNode;
        ++m_uiNodes;
        return iterator( pNode);
    }
    template< class InputIterator>
    void insert( iterator pos, InputIterator f, InputIterator l)
    {
        // TODO: Optimize
        while( f!= l)
        {
            insert( pos, *f);
            ++f;
        }
    }
    void insert( iterator pos, size_type n, const T& x)
    {
        // TODO: Optimize
        if( n!= 0) do
        {
            insert( pos, x);
        } while( --n!= 0);
    }
    iterator erase( iterator pos)
    {
        list_node_pointer pNode( pos.m_pNode);
        list_node_pointer pNext( pNode->m_pNext);
        pNode->m_pPrev->m_pNext= pNext;
        pNext->m_pPrev= pNode->m_pPrev;
        m_Allocator.destroy( pNode);
        m_Allocator.deallocate( pNode, 1);
        --m_uiNodes;
        return iterator( pNext);
    }
    iterator erase( iterator f, iterator l)
    {
        // TODO: Optimize
        while( f!= l)
        {
            iterator d( f);
            ++f;
            erase( d);
        }
        return f;
    }
    void clear()
    {
        if( 0!= size())
        {
            list_node_pointer pNode( m_pHead->m_pNext);
            list_node_pointer pNext( pNode->m_pNext);
            do
            {
                m_Allocator.destroy( pNode);
                m_Allocator.deallocate( pNode, 1);
                pNode= pNext;
                pNext= pNext->m_pNext;
            } while( pNode!= m_pHead);
            m_pHead->m_pPrev= m_pHead->m_pNext= m_pHead;
        }
    }
    void resize( size_type n, T t= T())
    {
        const size_type CurSize( m_uiNodes);
        if( CurSize< n)
            insert( end(), n- CurSize, t);
        else if( CurSize> n)
        {
            iterator itStartRange;

            if( n> CurSize/ 2)
            {
                itStartRange= end();
                size_type dist( CurSize- n+ 1);
                do {
                    --itStartRange;
                } while( --dist!= 0);
            }
            else
            {
                itStartRange= begin();
                size_type dist( n);
                if( dist!= 0) do {
                    ++itStartRange;
                } while( ++dist!= 0);
            }
            erase( itStartRange, end());
        }
    }
    template< class InputIterator>
    void assign( InputIterator f, InputIterator l)
    {
        iterator itMyCur( begin());
        iterator itMyEnd( end());
        while( itMyCur!= itMyEnd && f!= l)
        {
            *itMyCur= *f;
            ++itMyCur;
            ++f;
        }
        erase( itMyCur, itMyEnd);
        insert( itMyCur, f, l);
    }
    void assign( size_type n, const T& x= T())
    {
        iterator itMyCur( begin());
        iterator itMyEnd( end());
        while( itMyCur!= itMyEnd && f!= l)
        {
            *itMyCur= *x;
            ++itMyCur;
            ++f;
        }
        erase( itMyCur, itMyEnd);
        insert( itMyCur, n, x);
    }
/* TODO:
    void splice( iterator pos, list_type& x)
    {
        if( !x.empty())
        {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F)
        {iterator _L = _F;
        if (_P != _F && _P != ++_L)
            {_Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size; }}
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
        {if (_F != _L)
            {if (&_X != this)
                {difference_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N; }
            _Splice(_P, _X, _F, _L); }}
    void remove(const T& _V)
        {iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F; }
    typedef binder2nd<not_equal_to<T> > _Pr1;
    void remove_if(_Pr1 _Pr)
        {iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F; }
    void unique()
        {iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (*_F == *_M)
                    erase(_M);
                else
                    _F = _M; }
    typedef not_equal_to<T> _Pr2;
    void unique(_Pr2 _Pr)
        {iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (_Pr(*_F, *_M))
                    erase(_M);
                else
                    _F = _M; }
    void merge(_Myt& _X)
        {if (&_X != this)
            {iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (*_F2 < *_F1)
                    {iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2; }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0; }}
    typedef greater<T> _Pr3;
    void merge(_Myt& _X, _Pr3 _Pr)
        {if (&_X != this)
            {iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (_Pr(*_F2, *_F1))
                    {iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2; }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0; }}
    void sort()
        {if (2 <= size())
            {const size_t _MAXN = 15;
            _Myt _X(allocator), Allocator[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
                {_X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !Allocator[_I].empty(); ++_I)
                    {Allocator[_I].merge(_X);
                    Allocator[_I].swap(_X); }
                if (_I == _MAXN)
                    Allocator[_I].merge(_X);
                else
                    {Allocator[_I].swap(_X);
                    if (_I == _N)
                        ++_N; }}
            while (0 < _N)
                merge(Allocator[--_N]); }}
    void sort(_Pr3 _Pr)
        {if (2 <= size())
            {const size_t _MAXN = 15;
            _Myt _X(allocator), Allocator[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
                {_X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !Allocator[_I].empty(); ++_I)
                    {Allocator[_I].merge(_X, _Pr);
                    Allocator[_I].swap(_X); }
                if (_I == _MAXN)
                    Allocator[_I].merge(_X, _Pr);
                else
                    {Allocator[_I].swap(_X);
                    if (_I == _N)
                        ++_N; }}
            while (0 < _N)
                merge(Allocator[--_N], _Pr); }}
    void reverse()
        {if (2 <= size())
            {iterator _L = end();
            for (iterator _F = ++begin(); _F != _L; )
                {iterator _M = _F;
                _Splice(begin(), *this, _M, ++_F); }}}
protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
        {_Nodeptr _S = (_Nodeptr)allocator._Charalloc(
            1 * sizeof (list_node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S); }
    void _Freenode(_Nodeptr _S)
        {allocator.deallocate(_S, 1); }
    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
        {if (allocator == _X.allocator)
            {_Acc::_Next(_Acc::_Prev(_L._Mynode())) =
                _P._Mynode();
            _Acc::_Next(_Acc::_Prev(_F._Mynode())) =
                _L._Mynode();
            _Acc::_Next(_Acc::_Prev(_P._Mynode())) =
                _F._Mynode();
            _Nodeptr _S = _Acc::_Prev(_P._Mynode());
            _Acc::_Prev(_P._Mynode()) =
                _Acc::_Prev(_L._Mynode());
            _Acc::_Prev(_L._Mynode()) =
                _Acc::_Prev(_F._Mynode());
            _Acc::_Prev(_F._Mynode()) = _S; }
        else
            {insert(_P, _F, _L);
            _X.erase(_F, _L); }}
    void _Xran() const
        {_THROW(out_of_range, "invalid list<T> subscript"); }
*/
};
        // list TEMPLATE OPERATORS
template< class T, class Allocator> inline
bool operator==( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return (x.size()== y.size()&& equal(x.begin(), x.end(), y.begin()));
}

template< class T, class Allocator> inline
bool operator!=( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return !(x== y);
}

template< class T, class Allocator> inline
bool operator<( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return lexicographical_compare( x.begin(), x.end(), y.begin(), y.end());
}

template< class T, class Allocator> inline
bool operator>( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return y< x;
}

template< class T, class Allocator> inline
bool operator<=( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return !(y< x);
}

template< class T, class Allocator> inline
bool operator>=( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return !(x< y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\dx8sddifw.h ===
////////////////////////////////////////////////////////////////////////////////
//
// DX8SDDIFW
//
// Template library framework for creating a DX8 SDDI pluggable software
// rasterizer.
//
// Two #defines supported:
// DX8SDDIFW_NONAMESPACE: Don't use the DX8SDDIFW namespace. This can cause
//     symbols to bloat up if not needed.
// DX8SDDIFW_NOCATCHALL: Don't use catch( ... ) in certain places to create
//     a more stable driver. There are catch( ... ) clauses in certain areas
//     like DP2 command processing, so that each command succeeds or fails.
//     However, this can cause problems debugging, as Access Violations can
//     be masked and caught without causing the app to freeze or even see an
//     error.
//
////////////////////////////////////////////////////////////////////////////////
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined( DX8SDDIFW_NONAMESPACE)
namespace DX8SDDIFW
{
#endif // !defined( DX8SDDIFW_NONAMESPACE)

// Since MSVC doesn't have a block type currently, include one. This
// dependency can be removed if a similar type is provided in CRT STL.
#include "block.h"

// Utility functions for clamping a value:
template< class T> inline
void clamp_max( T& Var, const T& ClampMax)
{
    if( Var> ClampMax)
        Var= ClampMax;
}

template< class T> inline
void clamp_min( T& Var, const T& ClampMin)
{
    if( Var< ClampMin)
        Var= ClampMin;
}

template< class T> inline
void clamp( T& Var, const T& ClampMin, const T& ClampMax)
{
    assert( ClampMax>= ClampMin);
    if( Var> ClampMax)
        Var= ClampMax;
    else if( Var< ClampMin)
        Var= ClampMin;
}

////////////////////////////////////////////////////////////////////////////////
//
// CPushValue
//
// This class creates a safe run-time stack which pushes a value upon
// construction and pops the value upon destruction.
//
////////////////////////////////////////////////////////////////////////////////
template< class T>
struct CPushValue
{
protected: // Variables
    T& m_Val;
    T m_OldVal;

public: // Functions
    CPushValue( T& Val, const T& NewVal) : m_Val( Val)
    {
        m_OldVal= Val;
        Val= NewVal;
    }
    ~CPushValue() 
    {
        m_Val= m_OldVal;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// COSDetector
//
// This class can detect whether the host OS is the Win9X code base or the WinNT
// code base. The difference is important, because driver structures differ
// depending on which OS the rasterizer runs on. We don't want to build 2 lib
// versions, thus requiring the app to link with both.
//
////////////////////////////////////////////////////////////////////////////////
class COSDetector
{
public: // Types
    enum EOS
    {
        Unknown,
        Win9X,
        WinNT
    };

protected: // Variables
    const EOS m_eOS;

protected: // Functions
    static EOS DetermineOS()
    {
        OSVERSIONINFO osvi;
        ZeroMemory( &osvi, sizeof( osvi));
        osvi.dwOSVersionInfoSize= sizeof( osvi);
        if( !GetVersionEx( &osvi))
        {
            const bool Unsupported_OS_probably_Win31( false);
            assert( Unsupported_OS_probably_Win31);
            return EOS::Unknown;
        }
        else if( VER_PLATFORM_WIN32_WINDOWS== osvi.dwPlatformId)
            return EOS::Win9X;
        else if( VER_PLATFORM_WIN32_NT== osvi.dwPlatformId)
            return EOS::WinNT;
        else
        {
            const bool Unsupported_OS( false);
            assert( Unsupported_OS);
            return EOS::Unknown;
        }
    }

public: // Functions
    COSDetector():
        m_eOS( DetermineOS())
    { }
    ~COSDetector()
    { }
    EOS GetOS() const
    { return m_eOS; }
};
extern COSDetector g_OSDetector;

////////////////////////////////////////////////////////////////////////////////
//
// DDRAWI_XXX redefinitions
//
// Some DDRAWI_XXX structures differ depending on whether the binary is being
// compiled for Win9X or WinNT. We'll eliminate this difference, but to do so
// both OS structures need to be seperately defined. The structure which causes
// this is DDRAWI_DDRAWSURFACE_MORE. But for safety, more redefinition is done,
// to try to make developers aware of what's going on. 
//
////////////////////////////////////////////////////////////////////////////////

class PORTABLE_DDRAWSURFACE_LCL;
struct PORTABLE_ATTACHLIST
{
    DWORD                      dwFlags;
    PORTABLE_ATTACHLIST*       lpLink;
    PORTABLE_DDRAWSURFACE_LCL* lpAttached;  // attached surface local obj
    DDRAWI_DDRAWSURFACE_INT*   lpIAttached; // attached surface interface
};

class PORTABLE_DDRAWSURFACE_MORE;
class PORTABLE_DDRAWSURFACE_LCL
{
private:
    PORTABLE_DDRAWSURFACE_MORE*   m_lpSurfMore;
    LPDDRAWI_DDRAWSURFACE_GBL     m_lpGbl;
    ULONG_PTR                     m_hDDSurface;
    PORTABLE_ATTACHLIST*          m_lpAttachList;
    PORTABLE_ATTACHLIST*          m_lpAttachListFrom;
    DWORD                         m_dwLocalRefCnt;
    DWORD                         m_dwProcessId;
    DWORD                         m_dwFlags;
    DDSCAPS                       m_ddsCaps;
    union {
        LPDDRAWI_DDRAWPALETTE_INT m_lpDDPalette;
        LPDDRAWI_DDRAWPALETTE_INT m_lp16DDPalette;
    };
    union {
        LPDDRAWI_DDRAWCLIPPER_LCL m_lpDDClipper;
        LPDDRAWI_DDRAWCLIPPER_INT m_lp16DDClipper;
    };
    DWORD                         m_dwModeCreatedIn;
    DWORD                         m_dwBackBufferCount;
    DDCOLORKEY                    m_ddckCKDestBlt;
    DDCOLORKEY                    m_ddckCKSrcBlt;
    ULONG_PTR                     m_hDC;
    ULONG_PTR                     m_dwReserved1;
    DDCOLORKEY                    m_ddckCKSrcOverlay;
    DDCOLORKEY                    m_ddckCKDestOverlay;
    LPDDRAWI_DDRAWSURFACE_INT     m_lpSurfaceOverlaying;
    DBLNODE                       m_dbnOverlayNode;
    RECT                          m_rcOverlaySrc;
    RECT                          m_rcOverlayDest;
    DWORD                         m_dwClrXparent;
    DWORD                         m_dwAlpha;
    LONG                          m_lOverlayX;
    LONG                          m_lOverlayY;

public:
    PORTABLE_DDRAWSURFACE_MORE*& lpSurfMore()
    { return m_lpSurfMore; }
    LPDDRAWI_DDRAWSURFACE_GBL&   lpGbl()
    { return m_lpGbl; }
    ULONG_PTR&                   hDDSurface()
    { return m_hDDSurface; }
    PORTABLE_ATTACHLIST*&        lpAttachList()
    { return m_lpAttachList; }
    PORTABLE_ATTACHLIST*&        lpAttachListFrom()
    { return m_lpAttachListFrom; }
    DWORD&                       dwLocalRefCnt()
    { return m_dwLocalRefCnt; }
    DWORD&                       dwProcessId()
    { return m_dwProcessId; }
    DWORD&                       dwFlags()
    { return m_dwFlags; }
    DDSCAPS&                     ddsCaps()
    { return m_ddsCaps; }
    LPDDRAWI_DDRAWPALETTE_INT&   lpDDPalette()
    { return m_lpDDPalette; }
    LPDDRAWI_DDRAWPALETTE_INT&   lp16DDPalette()
    { return m_lp16DDPalette; }
    LPDDRAWI_DDRAWCLIPPER_LCL&   lpDDClipper()
    { return m_lpDDClipper; }
    LPDDRAWI_DDRAWCLIPPER_INT&   lp16DDClipper()
    { return m_lp16DDClipper; }
    DWORD&                       dwModeCreatedIn()
    { return m_dwModeCreatedIn; }
    DWORD&                       dwBackBufferCount()
    { return m_dwBackBufferCount; }
    DDCOLORKEY&                  ddckCKDestBlt()
    { return m_ddckCKDestBlt; }
    DDCOLORKEY&                  ddckCKSrcBlt()
    { return m_ddckCKSrcBlt; }
    ULONG_PTR&                   hDC()
    { return m_hDC; }
    ULONG_PTR&                   dwReserved1()
    { return m_dwReserved1; }
    DDCOLORKEY&                  ddckCKSrcOverlay()
    { return m_ddckCKSrcOverlay; }
    DDCOLORKEY&                  ddckCKDestOverlay()
    { return m_ddckCKDestOverlay; }
    LPDDRAWI_DDRAWSURFACE_INT&   lpSurfaceOverlaying()
    { return m_lpSurfaceOverlaying; }
    DBLNODE&                     dbnOverlayNode()
    { return m_dbnOverlayNode; }
    RECT&                        rcOverlaySrc()
    { return m_rcOverlaySrc; }
    RECT&                        rcOverlayDest()
    { return m_rcOverlayDest; }
    DWORD&                       dwClrXparent()
    { return m_dwClrXparent; }
    DWORD&                       dwAlpha()
    { return m_dwAlpha; }
    LONG&                        lOverlayX()
    { return m_lOverlayX; }
    LONG&                        lOverlayY()
    { return m_lOverlayY; }
};

class PORTABLE_DDRAWSURFACE_MORE
{
public:
    struct DDRAWI_DDRAWSURFACE_MORE_WIN9X
    {
        DWORD                       dwSize;
        IUNKNOWN_LIST FAR *         lpIUnknowns;
        LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;
        DWORD                       dwPageLockCount;
        DWORD                       dwBytesAllocated;
        LPDDRAWI_DIRECTDRAW_INT     lpDD_int;
        DWORD                       dwMipMapCount;
        LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;
        LPHEAPALIASINFO             lpHeapAliasInfo;
        DWORD                       dwOverlayFlags;
        LPVOID                      rgjunc;
        LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;
        LPDDOVERLAYFX               lpddOverlayFX;
        DDSCAPSEX                   ddsCapsEx;
        DWORD                       dwTextureStage;
        LPVOID                      lpDDRAWReserved;
        LPVOID                      lpDDRAWReserved2;
        LPVOID                      lpDDrawReserved3;
        DWORD                       dwDDrawReserved4;
        LPVOID                      lpDDrawReserved5;
        LPDWORD                     lpGammaRamp;
        LPDWORD                     lpOriginalGammaRamp;
        LPVOID                      lpDDrawReserved6;
        DWORD                       dwSurfaceHandle;
        DWORD                       qwDDrawReserved8[2];
        LPVOID                      lpDDrawReserved9;
        DWORD                       cSurfaces;
        LPDDSURFACEDESC2            pCreatedDDSurfaceDesc2;
        PORTABLE_DDRAWSURFACE_LCL** slist;
        DWORD                       dwFVF;
        LPVOID                      lpVB;
    };
    struct DDRAWI_DDRAWSURFACE_MORE_WINNT
    {
        DWORD                       dwSize;
        IUNKNOWN_LIST FAR *         lpIUnknowns;
        LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;
        DWORD                       dwPageLockCount;
        DWORD                       dwBytesAllocated;
        LPDDRAWI_DIRECTDRAW_INT     lpDD_int;
        DWORD                       dwMipMapCount;
        LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;
        LPHEAPALIASINFO             lpHeapAliasInfo;
        DWORD                       dwOverlayFlags;
        LPVOID                      rgjunc;
        LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;
        LPDDOVERLAYFX               lpddOverlayFX;
        DDSCAPSEX                   ddsCapsEx;
        DWORD                       dwTextureStage;
        LPVOID                      lpDDRAWReserved;
        LPVOID                      lpDDRAWReserved2;
        LPVOID                      lpDDrawReserved3;
        DWORD                       dwDDrawReserved4;
        LPVOID                      lpDDrawReserved5;
        LPDWORD                     lpGammaRamp;
        LPDWORD                     lpOriginalGammaRamp;
        LPVOID                      lpDDrawReserved6;
        DISPLAYMODEINFO             dmiDDrawReserved7;
        DWORD                       dwSurfaceHandle;
        DWORD                       qwDDrawReserved8[2];
        LPVOID                      lpDDrawReserved9;
        DWORD                       cSurfaces;
        LPDDSURFACEDESC2            pCreatedDDSurfaceDesc2;
        PORTABLE_DDRAWSURFACE_LCL** slist;
        DWORD                       dwFVF;
        LPVOID                      lpVB;
    };

private:
    union {
        DDRAWI_DDRAWSURFACE_MORE_WIN9X m_Win9X;
        DDRAWI_DDRAWSURFACE_MORE_WINNT m_WinNT;
    };

public:
    DWORD&                       dwSize()
    { return m_Win9X.dwSize; }
    IUNKNOWN_LIST FAR *&         lpIUnknowns()
    { return m_Win9X.lpIUnknowns; }
    LPDDRAWI_DIRECTDRAW_LCL&     lpDD_lcl()
    { return m_Win9X.lpDD_lcl; }
    DWORD&                       dwPageLockCount()
    { return m_Win9X.dwPageLockCount; }
    DWORD&                       dwBytesAllocated()
    { return m_Win9X.dwBytesAllocated; }
    LPDDRAWI_DIRECTDRAW_INT&     lpDD_int()
    { return m_Win9X.lpDD_int; }
    DWORD&                       dwMipMapCount()
    { return m_Win9X.dwMipMapCount; }
    LPDDRAWI_DDRAWCLIPPER_INT&   lpDDIClipper()
    { return m_Win9X.lpDDIClipper; }
    LPHEAPALIASINFO&             lpHeapAliasInfo()
    { return m_Win9X.lpHeapAliasInfo; }
    DWORD&                       dwOverlayFlags()
    { return m_Win9X.dwOverlayFlags; }
    LPVOID&                      rgjunc()
    { return m_Win9X.rgjunc; }
    LPDDRAWI_DDVIDEOPORT_LCL&    lpVideoPort()
    { return m_Win9X.lpVideoPort; }
    LPDDOVERLAYFX&               lpddOverlayFX()
    { return m_Win9X.lpddOverlayFX; }
    DDSCAPSEX&                   ddsCapsEx()
    { return m_Win9X.ddsCapsEx; }
    DWORD&                       dwTextureStage()
    { return m_Win9X.dwTextureStage; }
    LPVOID&                      lpDDRAWReserved()
    { return m_Win9X.lpDDRAWReserved; }
    LPVOID&                      lpDDRAWReserved2()
    { return m_Win9X.lpDDRAWReserved2; }
    LPVOID&                      lpDDrawReserved3()
    { return m_Win9X.lpDDrawReserved3; }
    DWORD&                       dwDDrawReserved4()
    { return m_Win9X.dwDDrawReserved4; }
    LPVOID&                      lpDDrawReserved5()
    { return m_Win9X.lpDDrawReserved5; }
    LPDWORD&                     lpGammaRamp()
    { return m_Win9X.lpGammaRamp; }
    LPDWORD&                     lpOriginalGammaRamp()
    { return m_Win9X.lpOriginalGammaRamp; }
    LPVOID&                      lpDDrawReserved6()
    { return m_Win9X.lpDDrawReserved6; }
    DWORD&                       dwSurfaceHandle()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.dwSurfaceHandle;
        case( COSDetector::WinNT): return m_WinNT.dwSurfaceHandle;
        default: assert( 2!= 2); return m_WinNT.dwSurfaceHandle;
    } }
    DWORD&                       qwDDrawReserved8_0_()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.qwDDrawReserved8[0];
        case( COSDetector::WinNT): return m_WinNT.qwDDrawReserved8[0];
        default: assert( 2!= 2); return m_WinNT.qwDDrawReserved8[0];
    } }
    DWORD&                       qwDDrawReserved8_1_()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.qwDDrawReserved8[1];
        case( COSDetector::WinNT): return m_WinNT.qwDDrawReserved8[1];
        default: assert( 2!= 2); return m_WinNT.qwDDrawReserved8[1];
    } }
    LPVOID&                      lpDDrawReserved9()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.lpDDrawReserved9;
        case( COSDetector::WinNT): return m_WinNT.lpDDrawReserved9;
        default: assert( 2!= 2); return m_WinNT.lpDDrawReserved9;
    } }
    DWORD&                       cSurfaces()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.cSurfaces;
        case( COSDetector::WinNT): return m_WinNT.cSurfaces;
        default: assert( 2!= 2); return m_WinNT.cSurfaces;
    } }
    LPDDSURFACEDESC2&            pCreatedDDSurfaceDesc2()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.pCreatedDDSurfaceDesc2;
        case( COSDetector::WinNT): return m_WinNT.pCreatedDDSurfaceDesc2;
        default: assert( 2!= 2); return m_WinNT.pCreatedDDSurfaceDesc2;
    } }
    PORTABLE_DDRAWSURFACE_LCL**& slist()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.slist;
        case( COSDetector::WinNT): return m_WinNT.slist;
        default: assert( 2!= 2); return m_WinNT.slist;
    } }
    DWORD&                       dwFVF()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.dwFVF;
        case( COSDetector::WinNT): return m_WinNT.dwFVF;
        default: assert( 2!= 2); return m_WinNT.dwFVF;
    } }
    LPVOID&                      lpVB()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.lpVB;
        case( COSDetector::WinNT): return m_WinNT.lpVB;
        default: assert( 2!= 2); return m_WinNT.lpVB;
    } }
};

class PORTABLE_CONTEXTCREATEDATA
{
private:
    union {
        LPDDRAWI_DIRECTDRAW_GBL    m_lpDDGbl;
        LPDDRAWI_DIRECTDRAW_LCL    m_lpDDLcl;
    };
    union {
        LPDIRECTDRAWSURFACE        m_lpDDS;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSLcl;
    };
    union {
        LPDIRECTDRAWSURFACE        m_lpDDSZ;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSZLcl;
    };
    union {
        DWORD                      m_dwPID;
        ULONG_PTR                  m_dwrstates;
    };
    ULONG_PTR                      m_dwhContext;
    HRESULT                        m_ddrval;

public:
    LPDDRAWI_DIRECTDRAW_GBL&        lpDDGbl()
    { return m_lpDDGbl; }
    LPDDRAWI_DIRECTDRAW_LCL&        lpDDLcl()
    { return m_lpDDLcl; }
    LPDIRECTDRAWSURFACE&            lpDDS()
    { return m_lpDDS; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSLcl()
    { return m_lpDDSLcl; }
    LPDIRECTDRAWSURFACE&            lpDDSZ()
    { return m_lpDDSZ; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSZLcl()
    { return m_lpDDSZLcl; }
    DWORD&                          dwPID()
    { return m_dwPID; }
    ULONG_PTR&                      dwrstates()
    { return m_dwrstates; }
    ULONG_PTR&                      dwhContext()
    { return m_dwhContext; }
    HRESULT&                        ddrval()
    { return m_ddrval; }
};

class PORTABLE_SETRENDERTARGETDATA
{
private:
    ULONG_PTR                      m_dwhContext;
    union {
        LPDIRECTDRAWSURFACE        m_lpDDS;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSLcl;
    };
    union {
        LPDIRECTDRAWSURFACE        m_lpDDSZ;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSZLcl;
    };
    HRESULT                        m_ddrval;

public:
    ULONG_PTR&                      dwhContext()
    { return m_dwhContext; }
    LPDIRECTDRAWSURFACE&            lpDDS()
    { return m_lpDDS; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSLcl()
    { return m_lpDDSLcl; }
    LPDIRECTDRAWSURFACE&            lpDDSZ()
    { return m_lpDDSZ; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSZLcl()
    { return m_lpDDSZLcl; }
    HRESULT&                        ddrval()
    { return m_ddrval; }
};

class PORTABLE_DRAWPRIMITIVES2DATA
{
private:
    ULONG_PTR                      m_dwhContext;
    DWORD                          m_dwFlags;
    DWORD                          m_dwVertexType;
    PORTABLE_DDRAWSURFACE_LCL*     m_lpDDCommands;
    DWORD                          m_dwCommandOffset;
    DWORD                          m_dwCommandLength;
    union {
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDVertex;
        LPVOID                     m_lpVertices;
    };
    DWORD                          m_dwVertexOffset;
    DWORD                          m_dwVertexLength;
    DWORD                          m_dwReqVertexBufSize;
    DWORD                          m_dwReqCommandBufSize;
    LPDWORD                        m_lpdwRStates;
    union {
        DWORD                      m_dwVertexSize;
        HRESULT                    m_ddrval;
    };
    DWORD                          m_dwErrorOffset;

public:
    ULONG_PTR&                      dwhContext()
    { return m_dwhContext; }
    DWORD&                          dwFlags()
    { return m_dwFlags; }
    DWORD&                          dwVertexType()
    { return m_dwVertexType; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDCommands()
    { return m_lpDDCommands; }
    DWORD&                          dwCommandOffset()
    { return m_dwCommandOffset; }
    DWORD&                          dwCommandLength()
    { return m_dwCommandLength; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDVertex()
    { return m_lpDDVertex; }
    LPVOID&                         lpVertices()
    { return m_lpVertices; }
    DWORD&                          dwVertexOffset()
    { return m_dwVertexOffset; }
    DWORD&                          dwVertexLength()
    { return m_dwVertexLength; }
    DWORD&                          dwReqVertexBufSize()
    { return m_dwReqVertexBufSize; }
    DWORD&                          dwReqCommandBufSize()
    { return m_dwReqCommandBufSize; }    
    LPDWORD&                        lpdwRStates()
    { return m_lpdwRStates; }
    DWORD&                          dwVertexSize()
    { return m_dwVertexSize; }
    HRESULT&                        ddrval()
    { return m_ddrval; }
    DWORD&                          dwErrorOffset()
    { return m_dwErrorOffset; }
};

class PORTABLE_CREATESURFACEEXDATA
{
private:
    DWORD                       m_dwFlags;
    LPDDRAWI_DIRECTDRAW_LCL     m_lpDDLcl;
    PORTABLE_DDRAWSURFACE_LCL*  m_lpDDSLcl;
    HRESULT                     m_ddRVal;

public:
    DWORD&                       dwFlags()
    { return m_dwFlags; }
    LPDDRAWI_DIRECTDRAW_LCL&     lpDDLcl()
    { return m_lpDDLcl; }
    PORTABLE_DDRAWSURFACE_LCL*&  lpDDSLcl()
    { return m_lpDDSLcl; }
    HRESULT&                     ddRVal()
    { return m_ddRVal; }
};

class PORTABLE_CREATESURFACEDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL     m_lpDD;
    LPDDSURFACEDESC             m_lpDDSurfaceDesc;
    PORTABLE_DDRAWSURFACE_LCL** m_lplpSList;
    DWORD                       m_dwSCnt;
    HRESULT                     m_ddRVal;
    LPDDHAL_CREATESURFACE       m_CreateSurface;

public:
    LPDDRAWI_DIRECTDRAW_GBL&     lpDD()
    { return m_lpDD; }
    LPDDSURFACEDESC&             lpDDSurfaceDesc()
    { return m_lpDDSurfaceDesc; }
    PORTABLE_DDRAWSURFACE_LCL**& lplpSList()
    { return m_lplpSList; }
    DWORD&                       dwSCnt()
    { return m_dwSCnt; }
    HRESULT&                     ddRVal()
    { return m_ddRVal; }
    LPDDHAL_CREATESURFACE&       CreateSurface()
    { return m_CreateSurface; }
};

class PORTABLE_DESTROYSURFACEDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL      m_lpDD;
    PORTABLE_DDRAWSURFACE_LCL*   m_lpDDSurface;
    HRESULT                      m_ddRVal;
    LPDDHALSURFCB_DESTROYSURFACE m_DestroySurface;

public:
    LPDDRAWI_DIRECTDRAW_GBL&      lpDD()
    { return m_lpDD; }
    PORTABLE_DDRAWSURFACE_LCL*&   lpDDSurface()
    { return m_lpDDSurface; }
    HRESULT&                      ddRVal()
    { return m_ddRVal; }
    LPDDHALSURFCB_DESTROYSURFACE& DestroySurface()
    { return m_DestroySurface; }
};

class PORTABLE_LOCKDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL    m_lpDD;
    PORTABLE_DDRAWSURFACE_LCL* m_lpDDSurface;
    DWORD                      m_bHasRect;
    RECTL                      m_rArea;
    LPVOID                     m_lpSurfData;
    HRESULT                    m_ddRVal;
    LPDDHALSURFCB_LOCK         m_Lock;
    DWORD                      m_dwFlags;

public:
    LPDDRAWI_DIRECTDRAW_GBL&    lpDD()
    { return m_lpDD; }
    PORTABLE_DDRAWSURFACE_LCL*& lpDDSurface()
    { return m_lpDDSurface; }
    DWORD&                      bHasRect()
    { return m_bHasRect; }
    RECTL&                      rArea()
    { return m_rArea; }
    LPVOID&                     lpSurfData()
    { return m_lpSurfData; }
    HRESULT&                    ddRVal()
    { return m_ddRVal; }
    LPDDHALSURFCB_LOCK&         Lock()
    { return m_Lock; }
    DWORD&                      dwFlags()
    { return m_dwFlags; }
};

class PORTABLE_UNLOCKDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL    m_lpDD;
    PORTABLE_DDRAWSURFACE_LCL* m_lpDDSurface;
    HRESULT                    m_ddRVal;
    LPDDHALSURFCB_UNLOCK       m_Unlock;

public:
    LPDDRAWI_DIRECTDRAW_GBL&    lpDD()
    { return m_lpDD; }
    PORTABLE_DDRAWSURFACE_LCL*& lpDDSurface()
    { return m_lpDDSurface; }
    HRESULT&                    ddRVal()
    { return m_ddRVal; }
    LPDDHALSURFCB_UNLOCK&       Unlock()
    { return m_Unlock; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSurfaceLocker
//
// This class safely locks a surface upon construction and unlocks the surface
// upon destruction. 
//
////////////////////////////////////////////////////////////////////////////////
template< class TSurfacePtr>
class CSurfaceLocker
{
protected: // Variables
    TSurfacePtr m_pSurface;
    void* m_pSData;

public: // Functions
    explicit CSurfaceLocker( const TSurfacePtr& S, DWORD dwLockFlags,
        const RECTL* pRect) : m_pSurface( S)
    { m_pSData= m_pSurface->Lock( dwLockFlags, pRect); }
    ~CSurfaceLocker() 
    { m_pSurface->Unlock(); }
    void* const& GetData() const 
    { return m_pSData; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CEnsureFPUModeForC
//
// This class converts the FPU mode for x86 chips back into the mode compatable
// for C operations. The mode that D3D sets up for rasterizers is single
// precision, for more speed. But, sometimes, the rasterizer needs to do
// double operations and get double precision accuracy. This class sets up the
// mode for as long as the class is in scope.
//
////////////////////////////////////////////////////////////////////////////////
class CEnsureFPUModeForC
{
protected: // Variables
    WORD m_wSaveFP;

public:
    CEnsureFPUModeForC() 
    {
#if defined(_X86_)
        // save floating point mode and set to double precision mode
        // which is compatable with C/ C++
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSave
            mov ax, wSave
            or ax, 0200h
            mov wTemp, ax
            fldcw   wTemp
        }
        m_wSaveFP= wSave;
#endif
    }
    ~CEnsureFPUModeForC() 
    {
#if defined(_X86_)
        WORD wSave( m_wSaveFP);
        __asm fldcw wSave
#endif
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// SDP2NextCmd
//
// A unary_function which can return the pointer to the next
// DrawPrimitive2 command in a contiguous buffer given a pointer to a valid
// DrawPrimitive2 command in the same buffer, as is a common situation for
// processing DrawPrimitive2 commands within the DrawPrimitive2 function call.
// This class is naturally useful for DrawPrimitive2 command iterators.
// It contains all the possible commands that could be encountered for a DX8SDDI
// driver.
//
////////////////////////////////////////////////////////////////////////////////
struct SDP2NextCmd:
    public unary_function< const D3DHAL_DP2COMMAND*, D3DHAL_DP2COMMAND*>
{
    // This function allows iteration from one D3DHAL_DP2COMMAND* to the next.
    // This operation can be optimized quite a bit if many of the more advanced
    // features aren't supported (as tough to process D3DDP2_OPs might not be
    // encountered).
    D3DHAL_DP2COMMAND* operator()( const D3DHAL_DP2COMMAND* pCur) const 
    {
        const UINT8* pBRet= reinterpret_cast< const UINT8*>(pCur)+
            sizeof( D3DHAL_DP2COMMAND);
        switch( pCur->bCommand)
        {
        //case( D3DDP2OP_POINTS): // <DX8
        //case( D3DDP2OP_INDEXEDLINELIST): // <DX8
        //case( D3DDP2OP_INDEXEDTRIANGLELIST): // <DX8
        //case( D3DDP2OP_RESERVED0): 
        case( D3DDP2OP_RENDERSTATE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2RENDERSTATE)* pCur->wStateCount;
            break;
        //case( D3DDP2OP_LINELIST): // <DX8
        //case( D3DDP2OP_LINESTRIP): // <DX8
        //case( D3DDP2OP_INDEXEDLINESTRIP): // <DX8
        //case( D3DDP2OP_TRIANGLELIST): // <DX8
        //case( D3DDP2OP_TRIANGLESTRIP): // <DX8
        //case( D3DDP2OP_INDEXEDTRIANGLESTRIP): // <DX8
        //case( D3DDP2OP_TRIANGLEFAN): // <DX8
        //case( D3DDP2OP_INDEXEDTRIANGLEFAN): // <DX8
        //case( D3DDP2OP_TRIANGLEFAN_IMM): // <DX8
        //case( D3DDP2OP_LINELIST_IMM): // <DX8
        case( D3DDP2OP_TEXTURESTAGESTATE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2TEXTURESTAGESTATE)* pCur->wStateCount;
            break;
        //case( D3DDP2OP_INDEXEDTRIANGLELIST2): // <DX8
        //case( D3DDP2OP_INDEXEDLINELIST2): // <DX8
        case( D3DDP2OP_VIEWPORTINFO): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2VIEWPORTINFO)* pCur->wStateCount;
            break;
        case( D3DDP2OP_WINFO): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2WINFO)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPALETTE): // DX8 (if support palettized surf/tex)
            pBRet+= sizeof( D3DHAL_DP2SETPALETTE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_UPDATEPALETTE): // DX8 (if support palettized surf/tex)
            assert( pCur->wStateCount== 1);
            pBRet= pBRet+ sizeof( D3DHAL_DP2UPDATEPALETTE)+
                reinterpret_cast< const D3DHAL_DP2UPDATEPALETTE*>(
                pBRet)->wNumEntries* sizeof( DWORD);
            break;
        case( D3DDP2OP_ZRANGE): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2ZRANGE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETMATERIAL): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2SETMATERIAL)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETLIGHT): // DX8 (if support TnL)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2SETLIGHT* pSL=
                    reinterpret_cast< const D3DHAL_DP2SETLIGHT*>( pBRet);

                if( D3DHAL_SETLIGHT_DATA== pSL->dwDataType)
                    pBRet+= sizeof( D3DLIGHT8);
                pBRet+= sizeof( D3DHAL_DP2SETLIGHT);
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_CREATELIGHT): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2CREATELIGHT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETTRANSFORM): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2SETTRANSFORM)* pCur->wStateCount;
            break;
        case( D3DDP2OP_EXT): // DX8 (if work seemlessly with TnL extensions)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                pBRet+= reinterpret_cast< const D3DHAL_DP2EXT*>(pBRet)->dwSize;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_TEXBLT): // DX8 (if support vidmem texture)
            pBRet+= sizeof( D3DHAL_DP2TEXBLT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_STATESET): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2STATESET)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPRIORITY): // DX8 (if manage textures)
            pBRet+= sizeof( D3DHAL_DP2SETPRIORITY)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETRENDERTARGET): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2SETRENDERTARGET)* pCur->wStateCount;
            break;
        case( D3DDP2OP_CLEAR): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2CLEAR)- sizeof( RECT)+ sizeof( RECT)*
                pCur->wStateCount;
            break;
        case( D3DDP2OP_SETTEXLOD): // DX8 (if manage textures)
            pBRet+= sizeof( D3DHAL_DP2SETTEXLOD)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETCLIPPLANE): // DX8 (if support user clip planes)
            pBRet+= sizeof( D3DHAL_DP2SETCLIPPLANE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_CREATEVERTEXSHADER): // DX8 (if support vshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2CREATEVERTEXSHADER* pCVS=
                    reinterpret_cast< const D3DHAL_DP2CREATEVERTEXSHADER*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2CREATEVERTEXSHADER)+
                    pCVS->dwDeclSize+ pCVS->dwCodeSize;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_DELETEVERTEXSHADER): // DX8 (if support vshaders)
            pBRet+= sizeof( D3DHAL_DP2VERTEXSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETVERTEXSHADER): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2VERTEXSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETVERTEXSHADERCONST): // DX8 (if support vshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2SETVERTEXSHADERCONST* pSVSC=
                    reinterpret_cast< const D3DHAL_DP2SETVERTEXSHADERCONST*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2SETVERTEXSHADERCONST)+
                    4* sizeof( D3DVALUE)* pSVSC->dwCount;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_SETSTREAMSOURCE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2SETSTREAMSOURCE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETSTREAMSOURCEUM): // DX8 All (unless no DrawPrimUP calls)
            pBRet+= sizeof( D3DHAL_DP2SETSTREAMSOURCEUM)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETINDICES): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2SETINDICES)* pCur->wStateCount;
            break;
        case( D3DDP2OP_DRAWPRIMITIVE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWPRIMITIVE)* pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWINDEXEDPRIMITIVE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWINDEXEDPRIMITIVE)*
                pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_CREATEPIXELSHADER): // DX8 (if support pshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2CREATEPIXELSHADER* pCPS=
                    reinterpret_cast< const D3DHAL_DP2CREATEPIXELSHADER*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2CREATEPIXELSHADER)+
                    pCPS->dwCodeSize;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_DELETEPIXELSHADER): // DX8 (if support pshaders)
            pBRet+= sizeof( D3DHAL_DP2PIXELSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPIXELSHADER): // DX8 (if support pshaders)
            pBRet+= sizeof( D3DHAL_DP2PIXELSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPIXELSHADERCONST): // DX8 (if support pshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2SETPIXELSHADERCONST* pSPSC=
                    reinterpret_cast< const D3DHAL_DP2SETPIXELSHADERCONST*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2SETPIXELSHADERCONST)+
                    4* sizeof( D3DVALUE)* pSPSC->dwCount;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_CLIPPEDTRIANGLEFAN): // DX8 All
            pBRet+= sizeof( D3DHAL_CLIPPEDTRIANGLEFAN)* pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWPRIMITIVE2): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWPRIMITIVE2)* pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWINDEXEDPRIMITIVE2): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWINDEXEDPRIMITIVE2)*
                pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWRECTPATCH): // DX8 (if support higher order prims)
            { WORD wPrimitiveCount( pCur->wPrimitiveCount);
            if( wPrimitiveCount!= 0) do
            {
                const D3DHAL_DP2DRAWRECTPATCH* pDRP= 
                    reinterpret_cast< const D3DHAL_DP2DRAWRECTPATCH*>(pBRet);

                pBRet+= sizeof( D3DHAL_DP2DRAWRECTPATCH);

                if((pDRP->Flags& RTPATCHFLAG_HASSEGS)!= 0)
                    pBRet+= 4* sizeof( D3DVALUE);

                if((pDRP->Flags& RTPATCHFLAG_HASINFO)!= 0)
                    pBRet+= sizeof( D3DRECTPATCH_INFO);
            } while( --wPrimitiveCount); }
            break;
        case( D3DDP2OP_DRAWTRIPATCH): // DX8 (if support higher order prims)
            { WORD wPrimitiveCount( pCur->wPrimitiveCount);
            if( wPrimitiveCount!= 0) do
            {
                const D3DHAL_DP2DRAWTRIPATCH* pDTP= 
                    reinterpret_cast< const D3DHAL_DP2DRAWTRIPATCH*>(pBRet);

                pBRet+= sizeof( D3DHAL_DP2DRAWTRIPATCH);

                if((pDTP->Flags& RTPATCHFLAG_HASSEGS)!= 0)
                    pBRet+= 3* sizeof( D3DVALUE);

                if((pDTP->Flags& RTPATCHFLAG_HASINFO)!= 0)
                    pBRet+= sizeof( D3DTRIPATCH_INFO);
            } while( --wPrimitiveCount); }
            break;
        case( D3DDP2OP_VOLUMEBLT): // DX8 (if support vidmem volume texture)
            pBRet+= sizeof( D3DHAL_DP2VOLUMEBLT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_BUFFERBLT): // DX8 (if support vidmem vrtx/indx buffer)
            pBRet+= sizeof( D3DHAL_DP2BUFFERBLT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_MULTIPLYTRANSFORM): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2MULTIPLYTRANSFORM)* pCur->wStateCount;
            break;
        default: {
            const bool Unable_To_Parse_Unrecognized_D3DDP2OP( false);
            assert( Unable_To_Parse_Unrecognized_D3DDP2OP);
            } break;
        }
        return const_cast<D3DHAL_DP2COMMAND*>
            (reinterpret_cast<const D3DHAL_DP2COMMAND*>(pBRet));
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CDP2CmdIterator & CDP2ConstCmdIterator
//
// These iterators are provided as a convenience to iterate DrawPrimitive2
// commands which are packed in a contiguous chunk of memory, as is typical
// of execute/ command buffers which need to be processed within the
// DrawPrimitive2 function call. The actual iteration logic is encapsulated in
// the template parameter, so that it can be easily extended, if certain
// commands aren't exepected and a better iteration scheme could be used.
//
// Be careful, these iterators are only useful for iterating. They do not
// directly know the size of the data they point to. For completeness, which
// would allow seperate storage of commands, another class would need to be
// created and assigned as the value_type. Dereferencing the iterator only
// returns a D3DHAL_DP2COMMAND without any extra data. Something like:
//
// CDP2Cmd DP2Cmd= *itDP2Cmd; 
//
// is possible; but requires more work and definition of CDP2Cmd.
//
////////////////////////////////////////////////////////////////////////////////
template< class TNextCmd= SDP2NextCmd>
class CDP2CmdIterator
{
public: // Types
    typedef forward_iterator_tag iterator_category;
    typedef D3DHAL_DP2COMMAND    value_type;
    typedef ptrdiff_t            difference_type;
    typedef D3DHAL_DP2COMMAND*   pointer;
    typedef D3DHAL_DP2COMMAND&   reference;

protected: // Variables
    pointer m_pRawCmd;
    TNextCmd m_NextCmd;

public: // Functions
    CDP2CmdIterator( pointer pRaw= NULL) 
        :m_pRawCmd( pRaw) { }
    CDP2CmdIterator( pointer pRaw, const TNextCmd& NextCmd) 
        :m_NextCmd( NextCmd), m_pRawCmd( pRaw) { }
    CDP2CmdIterator( const CDP2CmdIterator< TNextCmd>& Other) 
        :m_NextCmd( Other.m_NextCmd), m_pRawCmd( Other.m_pRawCmd) { }

    reference operator*() const 
    { return *m_pRawCmd; }
    pointer operator->() const 
    { return m_pRawCmd; }
    operator pointer() const 
    { return m_pRawCmd; }

    CDP2CmdIterator< TNextCmd>& operator++() 
    { m_pRawCmd= m_NextCmd( m_pRawCmd); return *this; }
    CDP2CmdIterator< TNextCmd> operator++(int) 
    {
        CDP2CmdIterator< TNextCmd> tmp= *this;
        m_pRawCmd= m_NextCmd( m_pRawCmd);
        return tmp;
    }
    bool operator==( CDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd== x.m_pRawCmd; }
    bool operator!=( CDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd!= x.m_pRawCmd; }
};

template< class TNextCmd= SDP2NextCmd>
class CConstDP2CmdIterator
{
public: // Types
    typedef forward_iterator_tag     iterator_category;
    typedef const D3DHAL_DP2COMMAND  value_type;
    typedef ptrdiff_t                difference_type;
    typedef const D3DHAL_DP2COMMAND* pointer;
    typedef const D3DHAL_DP2COMMAND& reference;

protected: // Variables
    pointer m_pRawCmd;
    TNextCmd m_NextCmd;

public: // Functions
    CConstDP2CmdIterator( pointer pRaw= NULL) 
        :m_pRawCmd( pRaw) { }
    CConstDP2CmdIterator( pointer pRaw, const TNextCmd& NextCmd) 
        :m_NextCmd( NextCmd), m_pRawCmd( pRaw) { }
    CConstDP2CmdIterator( const CDP2CmdIterator< TNextCmd>& Other) 
        :m_NextCmd( Other.m_NextCmd), m_pRawCmd( Other.m_pRawCmd) { }
    CConstDP2CmdIterator( const CConstDP2CmdIterator< TNextCmd>& Other) 
        :m_NextCmd( Other.m_NextCmd), m_pRawCmd( Other.m_pRawCmd) { }

    reference operator*() const 
    { return *m_pRawCmd; }
    pointer operator->() const 
    { return m_pRawCmd; }
    operator pointer() const 
    { return m_pRawCmd; }

    CConstDP2CmdIterator< TNextCmd>& operator++() 
    { m_pRawCmd= m_NextCmd( m_pRawCmd); return *this; }
    CConstDP2CmdIterator< TNextCmd> operator++(int) 
    {
        CConstDP2CmdIterator< TNextCmd> tmp= *this;
        m_pRawCmd= m_NextCmd( m_pRawCmd);
        return tmp;
    }
    bool operator==( CConstDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd== x.m_pRawCmd; }
    bool operator!=( CConstDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd!= x.m_pRawCmd; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CDP2DataWrap
//
// This class is provided as a convenience to expose the
// PORTABLE_DRAWPRIMITIVES2DATA as a more friendly class. Mostly, it wraps the
// execute/ command buffer with an STL Sequence Container, so that the commands
// can be iterated over without copying and pre-parsing the command data.
//
// <Template Parameters>
// TNextCmd: a unary_function which takes a const D3DHAL_DP2COMMAND* in and
//     returns a D3DHAL_DP2COMMAND* which points to the next command. In
//     essence, a unary_function which enables a forward iterator on a
//     contiguous command buffer.
//
// <Exposed Types>
// TCmds: The Sequence Container type which exposed the commands.
//
// <Exposed Functions>
// CDP2DataWrap( PORTABLE_DRAWPRIMITIVES2DATA& DP2Data): Constructor to wrap the
//     PORTABLE_DRAWPRIMITIVES2DATA.
// const TCmds& GetCommands() const: Accessor function to get at the Sequence
//     Container.
//     
////////////////////////////////////////////////////////////////////////////////
template< class TNextCmd= SDP2NextCmd>
class CDP2DataWrap:
    public PORTABLE_DRAWPRIMITIVES2DATA
{
public: // Types
    class CDP2Cmds
    {
    public: // Types
        typedef CConstDP2CmdIterator< TNextCmd>          const_iterator;
        typedef typename const_iterator::value_type      value_type;
        typedef typename const_iterator::reference       const_reference;
        typedef typename const_iterator::pointer         const_pointer;
        typedef typename const_iterator::difference_type difference_type;
        typedef size_t                                   size_type;

    protected: // Variables
        CDP2DataWrap< TNextCmd>* m_pDP2Data;

    protected: // Functions
        // Allow to call constructor and set member variable.
        friend class CDP2DataWrap< TNextCmd>;

        CDP2Cmds( ) 
            :m_pDP2Data( NULL) { }

    public: // Functions
        const_iterator begin( void) const 
        {
            return const_iterator( reinterpret_cast<D3DHAL_DP2COMMAND*>(
                reinterpret_cast<UINT8*>(m_pDP2Data->lpDDCommands()->lpGbl()->fpVidMem)
                + m_pDP2Data->dwCommandOffset()));
        }
        const_iterator end( void) const 
        {
            return const_iterator( reinterpret_cast<D3DHAL_DP2COMMAND*>(
                reinterpret_cast<UINT8*>(m_pDP2Data->lpDDCommands()->lpGbl()->fpVidMem)
                + m_pDP2Data->dwCommandOffset()+ m_pDP2Data->dwCommandLength()));
        }
        size_type size( void) const 
        {
            size_type N( 0);
            const_iterator itS( begin());
            const_iterator itE( end());
            while( itS!= itE)
            { ++itS; ++N; }
            return N;
        }
        size_type max_size( void) const 
        { return size(); }
        bool empty( void) const 
        { return begin()== end(); }
    };
    typedef CDP2Cmds TCmds;

protected: // Variables
    TCmds m_Cmds;

public: // Functions
    explicit CDP2DataWrap( PORTABLE_DRAWPRIMITIVES2DATA& DP2Data) 
        : PORTABLE_DRAWPRIMITIVES2DATA( DP2Data)
    { m_Cmds.m_pDP2Data= this; }
    const TCmds& GetCommands( void) const 
    { return m_Cmds; }
};

////////////////////////////////////////////////////////////////////////////////
//
// SDP2MFnParser
//
// This class is a functional class, with many too many paramters to squeeze
// into the standard functional classes. It automates the parsing, member fn
// lookup, and dispatching for DrawPrimitive2 commands. This parser uses the
// command number to lookup a member function from a container to call.
//
////////////////////////////////////////////////////////////////////////////////
struct SDP2MFnParser
{
    // <Parameters>
    // MFnCaller: A binary_function type with TDP2CmdFnCtr::value_type,
    //     typically a member function pointer, as the first argument;
    //     TIter, typically a smart DP2 command iterator, as the second
    //     argument; and returns an HRESULT. This function type should call
    //     the member function to process the DP2 command, with the iterator
    //     used to determine the DP2 Cmd data.
    // DP2CmdFnCtr: This can be any Unique, Pair Associative Container,
    //     typically a map, which associates a D3DHAL_DP2OPERATION with a
    //     member function.
    // [itStart, itEnd): These iterators define a standard range of
    //     D3DHAL_DP2COMMAND. The iterators need only be forward iterators,
    //     and be convertable to raw D3DHAL_DP2COMMAND*. Note: itStart is
    //     a reference, so that the caller can determine the current iterator
    //     position upon return of function (when HRESULT!= DD_OK).
    template< class TMFnCaller, class TDP2CmdFnCtr, class TIter>
    HRESULT ParseDP2( TMFnCaller& MFnCaller, TDP2CmdFnCtr& DP2CmdFnCtr,
        TIter& itStart, TIter itEnd) const 
    {
        HRESULT hr( DD_OK);
        while( itStart!= itEnd)
        {
            try
            {
                hr= MFnCaller( DP2CmdFnCtr[ itStart->bCommand], itStart);
            } catch( HRESULT hrEx) {
                hr= hrEx;
#if !defined( DX8SDDIFW_NOCATCHALL)
            } catch ( ... ) {
                const bool Unrecognized_Exception_In_A_DP2_Op_Function( false);
                assert( Unrecognized_Exception_In_A_DP2_Op_Function);
                hr= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
            }

            // Only move on to next command if DD_OK. Otherwise return out
            // to caller. They can always call us back if caller determines
            // error code is a SUCCESS.
            if( DD_OK== hr)
                ++itStart;
            else
                break;
        }
        return hr;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSubStateSet & CMinimalStateSet
//
// This class contains a default implementation of a stateset. It copies/ packs
// a contiguous DP2 command buffer into a memory buffer. To capture, it asks
// the context to record the command buffer with the Context's current state.
// To execute, it fixes up a Fake DrawPrimitives2 point parameter
// and calls the context's DrawPrimitives2 entry point. The context
// needs to be able to handle recursive DrawPrimitives2 calls in order to use
// this default stateset. CStdDrawPrimitives2's DrawPrimitives2 handler
// does this by storing whether it is executing a stateset.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyStateSet type.
// TC: The Context type, typically, CMyContext.
//
// <Exposed Types>
// TContext: The Context type passed in as a template parameter.
//
// <Exposed Functions>
// CSubStateSet( TContext&, const D3DHAL_DP2COMMAND*, const D3DHAL_DP2COMMAND*):
//     The constructor which builds a stateset for a Context, from a range of
//     a command buffer. The default implementation will just copy this range.
// CSubStateSet( const CSubStateSet& Other): Standard copy constructor.
// void Capture( TContext&): The state set is instructed to capture the
//     necessary data from the Context, in order to perform an Execute later,
//     which will restore the data fields or state that the state set was
//     constructed with.
// void Execute( TContext&): Restore or rebuild the Context with the data/
//     state that was saved during the Capture operation.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper, class TC>
class CSubStateSet
{
public: // Types
    typedef TC TContext;

protected: // Variables
    TContext& m_Context;
    D3DHAL_DP2COMMAND* m_pBeginSS;
    size_t m_uiSSBufferSize;

protected: // Functions
    CSubStateSet( const CSubStateSet< TSuper, TC>& Other)
        :m_Context( Other.m_Context), m_pBeginSS( NULL),
        m_uiSSBufferSize( Other.m_uiSSBufferSize)
    {
        try {
            m_pBeginSS= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                operator new( m_uiSSBufferSize));
        } catch( ... ) {
        }
        if( NULL== m_pBeginSS)
            throw bad_alloc( "Not enough room to copy state set command "
                "buffer.");
        memcpy( m_pBeginSS, Other.m_pBeginSS, m_uiSSBufferSize);
    }
    CSubStateSet( TContext& C, const D3DHAL_DP2COMMAND* pBeginSS, const
        D3DHAL_DP2COMMAND* pEndSS) : m_Context( C), m_pBeginSS( NULL),
        m_uiSSBufferSize( 0)
    {
        // Convert the contiguous command pointers to byte pointers, to
        // calculate the size of buffer needed to copy the data.
        const UINT8* pSBytePtr= reinterpret_cast< const UINT8*>( pBeginSS);
        const UINT8* pEBytePtr= reinterpret_cast< const UINT8*>( pEndSS);
        m_uiSSBufferSize= static_cast< size_t>( pEBytePtr- pSBytePtr);
        try {
            m_pBeginSS= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                operator new( m_uiSSBufferSize));
        } catch( ... ) {
        }
        if( NULL== m_pBeginSS)
            throw bad_alloc( "Not enough room to allocate state set command "
                "buffer.");
        memcpy( m_pBeginSS, pBeginSS, m_uiSSBufferSize);
    }
    ~CSubStateSet()
    {
        operator delete( static_cast< void*>( m_pBeginSS));
    }

public: // Functions
    CSubStateSet< TSuper, TC>& operator=( const CSubStateSet< TSuper, TC>& Oth)
    {
        assert( &m_Context== &Oth.m_Context);
        if( m_uiSSBufferSize<= Oth.m_uiSSBufferSize)
        {
            m_uiSSBufferSize= Oth.m_uiSSBufferSize;
            memcpy( m_pBeginSS, Oth.m_pBeginSS, m_uiSSBufferSize);
        }
        else
        {
            void* pNewBuffer= NULL;
            try {
                pNewBuffer= operator new( Oth.m_uiSSBufferSize);
            } catch( ... ) {
            }
            if( NULL== pNewBuffer)
                throw bad_alloc( "Not enough room to copy state set command "
                    "buffer.");

            operator delete( static_cast< void*>( m_pBeginSS));
            m_pBeginSS= reinterpret_cast< D3DHAL_DP2COMMAND*>( pNewBuffer);
            m_uiSSBufferSize= Oth.m_uiSSBufferSize;
            memcpy( m_pBeginSS, Other.m_pBeginSS, m_uiSSBufferSize);
        }
        return *this;
    }
    void Capture( TContext& Ctx) 
    {
        assert( &m_Context== &Ctx);

        UINT8* pBytePtr= reinterpret_cast< UINT8*>( m_pBeginSS);
        D3DHAL_DP2COMMAND* pEndSS= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pBytePtr+ m_uiSSBufferSize);

        // Ask Context to record it's current state into the stored command
        // buffer. CStdDrawPrimitives2 can provide an implementation of
        // RecordCommandBuffer for the Context.
        Ctx.RecordCommandBuffer( m_pBeginSS, pEndSS);
    }
    void Execute( TContext& Ctx) 
    {
        assert( &m_Context== &Ctx);

        // Build up a fake PORTABLE_DRAWPRIMITIVES2DATA environment.
        PORTABLE_DDRAWSURFACE_LCL DDSLcl;
        PORTABLE_DDRAWSURFACE_MORE DDSMore;
        DDRAWI_DDRAWSURFACE_GBL DDSGbl;
        memset( &DDSLcl, 0, sizeof( DDSLcl));
        memset( &DDSMore, 0, sizeof( DDSMore));
        memset( &DDSGbl, 0, sizeof( DDSGbl));

        PORTABLE_DRAWPRIMITIVES2DATA FakeDPD;

        FakeDPD.dwhContext()= reinterpret_cast< ULONG_PTR>( &Ctx);
        FakeDPD.dwFlags()= D3DHALDP2_USERMEMVERTICES;
        FakeDPD.dwVertexType()= 0;
        FakeDPD.lpDDCommands()= &DDSLcl;
        FakeDPD.dwCommandOffset()= 0;
        FakeDPD.dwCommandLength()= m_uiSSBufferSize;
        FakeDPD.lpVertices()= NULL;
        FakeDPD.dwVertexOffset()= 0;
        FakeDPD.dwVertexLength()= 0;
        FakeDPD.dwReqVertexBufSize()= 0;
        FakeDPD.dwReqCommandBufSize()= 0;
        FakeDPD.lpdwRStates()= NULL;
        FakeDPD.dwVertexSize()= 0;

        // If the data is not 0, then a union can't be used, as we're
        // writing over valid data.
        DDSLcl.lpGbl()= &DDSGbl;
        DDSLcl.ddsCaps().dwCaps= DDSCAPS2_COMMANDBUFFER| DDSCAPS_SYSTEMMEMORY;
        DDSLcl.lpSurfMore()= &DDSMore;
        DDSGbl.fpVidMem= reinterpret_cast<FLATPTR>( m_pBeginSS);

        // Now call Context's DrawPrimitives2 entry point. CStdDrawPrimitives2
        // can provide an implementation of DrawPrimitives2 for the Context.
        HRESULT hr( Ctx.DrawPrimitives2( FakeDPD));
        assert( SUCCEEDED( hr));
    }
};

//
// <Template Parameters>
// TC: The Context type, typically, CMyContext.
//
template< class TC>
class CMinimalStateSet: public CSubStateSet< CMinimalStateSet, TC>
{
public: // Types
    typedef TC TContext;

public: // Functions
    CMinimalStateSet( const CMinimalStateSet< TC>& Other)
        :CSubStateSet< CMinimalStateSet, TC>( Other)
    { }
    CMinimalStateSet( TContext& C, const D3DHAL_DP2COMMAND* pBeginSS, const
        D3DHAL_DP2COMMAND* pEndSS) :
        CSubStateSet< CMinimalStateSet, TC>( C, pBeginSS, pEndSS) { }
    ~CMinimalStateSet()  { }
};

////////////////////////////////////////////////////////////////////////////////
//
// CStdDrawPrimitives2
//
// This class contains a default implementation of responding to the
// DrawPrimitives2 function call, as well as a function to record state back
// into a command buffer. Upon constuction, it will use the provided ranges
// to bind DP2 operations to both processing and recording member functions.
// In order to process the DrawPrimitives2 function call, it must wrap the
// PORTABLE_DRAWPRIMITIVES2DATA with a convience type which allows commands to
// be walked through with iterators. It will then use the DP2MFnParser to
// parse the DP2 commands and call the member functions.
//
// This class also provides a member function for processing the DP2 StateSet
// operation, and uses it to build up, manage, and execute state sets. In
// order to handle pure device state sets, it creates the appropriate command
// buffer for the Device (based off of caps), constructs a new state set
// on this command buffer, and asks the state set to Capture the current state.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TSS: The StateSet type, typically, CMyStateSet or CMinimalStateSet. The
//     StateSet class should be able to be constructed from a command buffer,
//     and then be able to Capture and Execute.
// TSSDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD state set handle to a StateSet type. 
// TDP2D: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA.
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, along with exposing an STL conforming
//     container which provides iterators which ease iterating over the command
//     buffer. This is typically CDP2DataWrap<>.
// TDP2MFC: A map container, which associates a D3DHAL_DP2OPERATION with a
//     member function. A standard array is acceptable, as the number of
//     entries is not variable at runtime. The member function is used to
//     process the command.
// TDP2RMFC: A map container, which associates a D3DHAL_DP2OPERATION with a
//     member function. A standard array is acceptable, as the number of
//     entries is not variable at runtime. The member function is used to
//     record or fill in the command with the current state.
//
// <Exposed Types>
// TDP2Data: The wrapper class type for PORTABLE_DRAWPRIMITIVES2DATA, which is
//     the passed in TDP2D template parameter.
// TDP2DataCmds: The Sequence Container of DP2 commands provided by the
//     TDP2Data wrapper class, which is relied upon to provide iteration over
//     the command buffer. (TDP2Data::TCmds)
// TStateSet: The StateSet type, which was passed in as the TSS template
//     parameter.
// TMFn: The member function type, which all DP2 command processing member
//     functions should conform to. This is mostly exposed as a convience to
//     Context implementors.
// TMFnCaller: An Adaptable Binary Function class which is used to call
//     a TMFn, only being passed the TMFn and DP2 command pointer.
// TDP2CmdBind: A simple type, exposed as a convience to Context implementors,
//     to provide a type that can be passed into the constructor, associating
//     D3DHAL_DP2OPERATIONs with member functions/ TMFn.
// TRMFn: The member function type, which all DP2 command recording member
//     functions should conform to. This is mostly exposed as a convience to
//     Context implementors.
// TRMFnCaller: An Adaptable Binary Function class which is used to call
//     a TRMFn, only being passed the TRMFn and DP2 command pointer.
// TRecDP2CmdBind: A simple type, exposed as a convience to Context implementors,
//     to provide a type that can be passed into the constructor, associating
//     D3DHAL_DP2OPERATIONs with member functions/ TRMFn.
//
// <Exposed Functions>
// CStdDrawPrimitives2(): Default constructor.
// template< class TIter1, class TIter2>
// CStdDrawPrimitives2( TIter1, const TIter1, TIter2, const TIter2): Standard
//     constructor which receives two ranges of D3DHAL_DP2OPERATION bindings.
//     The first range is a range of DP2 command processing bindings. The
//     second range is a range of DP2 command recording bindings.
// void OnBeginDrawPrimitives2( TDP2Data&): A notification function called
//     at the beginning of processing a DrawPrimitives2 entry point.
// void OnEndDrawPrimitives2( TDP2Data&): A notification function called at
//     the end of processing a DrawPrimitives2 entry point.
// void CreateAndCaptureAllState( DWORD): The request to capture all state,
//     which should only be received by pure devices.
// void CreateAndCapturePixelState( DWORD): The request to capture pixel state,
//     which should only be received by pure devices.
// void CreateAndCaptureVertexState( DWORD): The request to capture vertex
//     state, which should only be received by pure devices.
// HRESULT DP2StateSet( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*): The
//     default DP2 command processing member function for D3DDP2OP_STATESET.
// void RecordCommandBuffer( D3DHAL_DP2COMMAND*, D3DHAL_DP2COMMAND*): The
//     request to save or fill in the blanks of the passed in range of command
//     buffer, by using the DP2 command recording functions.
// HRESULT DrawPrimitives2( PORTABLE_DRAWPRIMITIVES2DATA&): The function,
//     typically called by the Driver class to process the DrawPrimitives2
//     entry point.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper, 
    class TSS= CMinimalStateSet< TSuper>, class TSSDB= map< DWORD, TSS>,
    class TDP2D= CDP2DataWrap<>,
    class TDP2MFC= block<
        HRESULT(TSuper::*)( TDP2D&, const D3DHAL_DP2COMMAND*, const void*), 66>,
    class TDP2RMFC= block<
        HRESULT(TSuper::*)( const D3DHAL_DP2COMMAND*, void*), 66> >
class CStdDrawPrimitives2
{
public: // Types
    typedef TDP2D TDP2Data;
    typedef typename TDP2Data::TCmds TDP2DataCmds;
    typedef TSS TStateSet;
    typedef HRESULT (TSuper::* TMFn)(TDP2Data&,const D3DHAL_DP2COMMAND*,
        const void*);
    struct TMFnCaller: // Used in conjunction 
        public binary_function< TMFn, const D3DHAL_DP2COMMAND*, HRESULT>
    {
        TSuper& m_Context;
        TDP2Data& m_DP2Data;

        TMFnCaller( TSuper& Context, TDP2Data& DP2Data)
            : m_Context( Context), m_DP2Data( DP2Data)
        { }

        result_type operator()( first_argument_type MFn,
            second_argument_type pDP2Cmd) const
        {
#if defined(DBG) || defined(_DEBUG)
            const D3DHAL_DP2OPERATION Op(
                static_cast< D3DHAL_DP2OPERATION>( pDP2Cmd->bCommand));
#endif
            return (m_Context.*MFn)( m_DP2Data, pDP2Cmd, pDP2Cmd+ 1);
        }
    };
    struct TDP2CmdBind
    {
        D3DHAL_DP2OPERATION m_DP2Op;
        TMFn m_MFn;

        operator D3DHAL_DP2OPERATION() const 
        { return m_DP2Op; }
        operator TMFn() const 
        { return m_MFn; }
    };
    typedef HRESULT (TSuper::* TRMFn)( const D3DHAL_DP2COMMAND*, void*);
    struct TRMFnCaller:
        public binary_function< TRMFn, D3DHAL_DP2COMMAND*, HRESULT>
    {
        TSuper& m_Context;

        TRMFnCaller( TSuper& Context)
            : m_Context( Context)
        { }

        result_type operator()( first_argument_type RMFn,
            second_argument_type pDP2Cmd) const
        {
#if defined(DBG) || defined(_DEBUG)
            const D3DHAL_DP2OPERATION Op(
                static_cast< D3DHAL_DP2OPERATION>( pDP2Cmd->bCommand));
#endif
            return (m_Context.*RMFn)( pDP2Cmd, pDP2Cmd+ 1);
        }
    };
    struct TRecDP2CmdBind
    {
        D3DHAL_DP2OPERATION m_DP2Op;
        TRMFn m_RMFn;

        operator D3DHAL_DP2OPERATION() const 
        { return m_DP2Op; }
        operator TRMFn() const 
        { return m_RMFn; }
    };


protected: // Types
    typedef TSSDB TSSDB;
    typedef TDP2MFC TDP2MFnCtr;
    typedef TDP2RMFC TDP2RecMFnCtr;

protected: // Variables
    static const HRESULT c_hrStateSetBegin;
    static const HRESULT c_hrStateSetEnd;
    TSSDB m_StateSetDB;
    TDP2MFnCtr m_DefFnCtr;
    TDP2RecMFnCtr m_RecFnCtr;
    const D3DHAL_DP2COMMAND* m_pEndStateSet;
    DWORD m_dwStateSetId;
    bool m_bRecordingStateSet;
    bool m_bExecutingStateSet;

protected: // Functions
    // This function is used as a filler. If the assert is hit, step one
    // level up/down in the call stack and check which DP2 Operation has
    // no support, but the app indirectly needs it.
    HRESULT DP2Empty( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*) 
    {
        const bool A_DP2_Op_Requires_A_Supporting_Function( false);
        assert( A_DP2_Op_Requires_A_Supporting_Function);
        return D3DERR_COMMAND_UNPARSED;
    }

    // This function is used as a fake, to prevent actual processing of
    // DP2 Operations while recording a StateSet.
    HRESULT DP2Fake( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*) 
    { return DD_OK; }

    // Notification functions. Overriding is optional.
    void OnBeginDrawPrimitives2( TDP2Data& DP2Data) const 
    { }
    void OnEndDrawPrimitives2( TDP2Data& DP2Data) const 
    { }

    CStdDrawPrimitives2() 
        :m_bRecordingStateSet( false), m_bExecutingStateSet( false),
        m_pEndStateSet( NULL)
    {
        typename TDP2MFnCtr::iterator itCur( m_DefFnCtr.begin());
        while( itCur!= m_DefFnCtr.end())
        {
            *itCur= DP2Empty;
            ++itCur;
        }
        itCur= m_RecFnCtr.begin();
        while( itCur!= m_RecFnCtr.end())
        {
            *itCur= NULL;
            ++itCur;
        }
        m_DefFnCtr[ D3DDP2OP_STATESET]= DP2StateSet;
    }

    // [itSetStart, itSetEnd): A valid range of bindings, which associate
    //     a D3DHAL_DP2OPERATION with a processing member function.
    // [itRecStart, itRecEnd): A valid range of bindings, which associate
    //     a D3DHAL_DP2OPERATION with a recording member function.
    template< class TIter1, class TIter2> // TDP2CmdBind*, TRecDP2CmdBind*
    CStdDrawPrimitives2( TIter1 itSetStart, const TIter1 itSetEnd,
        TIter2 itRecStart, const TIter2 itRecEnd) 
        :m_bRecordingStateSet( false), m_bExecutingStateSet( false),
        m_pEndStateSet( NULL)
    {
        typename TDP2MFnCtr::iterator itCur( m_DefFnCtr.begin());
        while( itCur!= m_DefFnCtr.end())
        {
            *itCur= DP2Empty;
            ++itCur;
        }
        typename TDP2RecMFnCtr::iterator itRCur= m_RecFnCtr.begin();
        while( itRCur!= m_RecFnCtr.end())
        {
            *itRCur= NULL;
            ++itRCur;
        }
        while( itSetStart!= itSetEnd)
        {
            const D3DHAL_DP2OPERATION DP2Op(
                static_cast<D3DHAL_DP2OPERATION>(*itSetStart));

            // This assert will fire if there are duplicate entries for the
            // same DP2OPERATION.
            assert( DP2Empty== m_DefFnCtr[ DP2Op]);
            m_DefFnCtr[ DP2Op]= static_cast<TMFn>(*itSetStart);
            ++itSetStart;
        }
        while( itRecStart!= itRecEnd)
        {
            const D3DHAL_DP2OPERATION DP2Op(
                static_cast<D3DHAL_DP2OPERATION>(*itRecStart));

            // This assert will fire if there are duplicate entries for the
            // same DP2OPERATION.
            assert( NULL== m_RecFnCtr[ DP2Op]);
            m_RecFnCtr[ DP2Op]= static_cast<TRMFn>(*itRecStart);
            ++itRecStart;
        }
        if( DP2Empty== m_DefFnCtr[ D3DDP2OP_STATESET])
            m_DefFnCtr[ D3DDP2OP_STATESET]= DP2StateSet;

        // Supporting these operations is considered the "safe minimal"
        // support necessary to function. It is strongly recommended that
        // these functions are supported, unless you know you can live without.
        assert( m_DefFnCtr[ D3DDP2OP_VIEWPORTINFO]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_WINFO]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_CLEAR]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETRENDERTARGET]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETSTREAMSOURCE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETSTREAMSOURCEUM]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETINDICES]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWPRIMITIVE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWPRIMITIVE2]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWINDEXEDPRIMITIVE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWINDEXEDPRIMITIVE2]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_CLIPPEDTRIANGLEFAN]!= DP2Empty);
        assert( m_RecFnCtr[ D3DDP2OP_VIEWPORTINFO]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_WINFO]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_SETSTREAMSOURCE]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_SETINDICES]!= NULL);
        // To remove this asserting, bind these functions to a different stub,
        // most likely a member function of TSuper, which does nothing; so that
        // they will not be equal to DP2Empty. Or use the default constructor.
    }
    ~CStdDrawPrimitives2() 
    { }

    // To determine number of const registers available to pixel shader.
    static DWORD GetNumPixelShaderConstReg( const DWORD dwPixelShaderVer)
    {
        switch(dwPixelShaderVer)
        {
        case( 0): return 0;
        case( D3DPS_VERSION(1,0)): return 8;
        case( D3DPS_VERSION(1,1)): return 8;
        case( D3DPS_VERSION(254,254)): return 2;
        case( D3DPS_VERSION(255,255)): return 16;
        default: {
                const bool Unrecognizable_Pixel_Shader_Version( false);
                assert( Unrecognizable_Pixel_Shader_Version);
            } break;
        }
        return 0;
    }

public: // Functions
    // Default implementataions for Capturing amounts of state, DX8 
    // pure device style.
    void CreateAndCaptureAllState( DWORD dwStateSetId)
    {
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 78> TAllRSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 75> TAllRSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DRENDERSTATETYPE, 73> TAllRSToCapture;
#endif// !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TAllRSToCapture AllRSToCapture=
        {
            D3DRENDERSTATE_SPECULARENABLE,
            D3DRENDERSTATE_ZENABLE,
            D3DRENDERSTATE_FILLMODE,
            D3DRENDERSTATE_SHADEMODE,
            D3DRENDERSTATE_LINEPATTERN,
            D3DRENDERSTATE_ZWRITEENABLE,
            D3DRENDERSTATE_ALPHATESTENABLE,
            D3DRENDERSTATE_LASTPIXEL,
            D3DRENDERSTATE_SRCBLEND,
            D3DRENDERSTATE_DESTBLEND,
            D3DRENDERSTATE_CULLMODE,
            D3DRENDERSTATE_ZFUNC,
            D3DRENDERSTATE_ALPHAREF,
            D3DRENDERSTATE_ALPHAFUNC,
            D3DRENDERSTATE_DITHERENABLE,
            D3DRENDERSTATE_FOGENABLE,
            D3DRENDERSTATE_STIPPLEDALPHA,
            D3DRENDERSTATE_FOGCOLOR,
            D3DRENDERSTATE_FOGTABLEMODE,
            D3DRENDERSTATE_FOGSTART,
            D3DRENDERSTATE_FOGEND,
            D3DRENDERSTATE_FOGDENSITY,
            D3DRENDERSTATE_EDGEANTIALIAS,
            D3DRENDERSTATE_ALPHABLENDENABLE,
            D3DRENDERSTATE_ZBIAS,
            D3DRENDERSTATE_RANGEFOGENABLE,
            D3DRENDERSTATE_STENCILENABLE,
            D3DRENDERSTATE_STENCILFAIL,
            D3DRENDERSTATE_STENCILZFAIL,
            D3DRENDERSTATE_STENCILPASS,
            D3DRENDERSTATE_STENCILFUNC,
            D3DRENDERSTATE_STENCILREF,
            D3DRENDERSTATE_STENCILMASK,
            D3DRENDERSTATE_STENCILWRITEMASK,
            D3DRENDERSTATE_TEXTUREFACTOR,
            D3DRENDERSTATE_WRAP0,
            D3DRENDERSTATE_WRAP1,
            D3DRENDERSTATE_WRAP2,
            D3DRENDERSTATE_WRAP3,
            D3DRENDERSTATE_WRAP4,
            D3DRENDERSTATE_WRAP5,
            D3DRENDERSTATE_WRAP6,
            D3DRENDERSTATE_WRAP7,
            D3DRENDERSTATE_AMBIENT,
            D3DRENDERSTATE_COLORVERTEX,
            D3DRENDERSTATE_FOGVERTEXMODE,
            D3DRENDERSTATE_CLIPPING,
            D3DRENDERSTATE_LIGHTING,
            D3DRENDERSTATE_NORMALIZENORMALS,
            D3DRENDERSTATE_LOCALVIEWER,
            D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
            D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
            D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
            D3DRENDERSTATE_SPECULARMATERIALSOURCE,
            D3DRENDERSTATE_VERTEXBLEND,
            D3DRENDERSTATE_CLIPPLANEENABLE,
            D3DRS_SOFTWAREVERTEXPROCESSING,
            D3DRS_POINTSIZE,
            D3DRS_POINTSIZE_MIN,
            D3DRS_POINTSPRITEENABLE,
            D3DRS_POINTSCALEENABLE,
            D3DRS_POINTSCALE_A,
            D3DRS_POINTSCALE_B,
            D3DRS_POINTSCALE_C,
            D3DRS_MULTISAMPLEANTIALIAS,
            D3DRS_MULTISAMPLEMASK,
            D3DRS_PATCHEDGESTYLE,
            D3DRS_PATCHSEGMENTS,
            D3DRS_POINTSIZE_MAX,
            D3DRS_INDEXEDVERTEXBLENDENABLE,
            D3DRS_COLORWRITEENABLE,
            D3DRS_TWEENFACTOR,
            D3DRS_BLENDOP,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DRS_ZSLOPESCALE,
            D3DRS_ZCLAMP,
#if defined( D3D_ENABLE_SHADOW_JITTER)
            D3DRS_JITZBIASMIN,
            D3DRS_JITZBIASMAX,
            D3DRS_JITSHADOWSIZE,
#endif // defined( D3D_ENABLE_SHADOW_JITTER)
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_JITSHADOWSIZE== *AllRSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_ZCLAMP== *AllRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DRS_BLENDOP== *AllRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

#if defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 30> TAllTSSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 27> TAllTSSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TAllTSSToCapture AllTSSToCapture=
        {
            D3DTSS_COLOROP,
            D3DTSS_COLORARG1,
            D3DTSS_COLORARG2,
            D3DTSS_ALPHAOP,
            D3DTSS_ALPHAARG1,
            D3DTSS_ALPHAARG2,
            D3DTSS_BUMPENVMAT00,
            D3DTSS_BUMPENVMAT01,
            D3DTSS_BUMPENVMAT10,
            D3DTSS_BUMPENVMAT11,
            D3DTSS_TEXCOORDINDEX,
            D3DTSS_ADDRESSU,
            D3DTSS_ADDRESSV,
            D3DTSS_BORDERCOLOR,
            D3DTSS_MAGFILTER,
            D3DTSS_MINFILTER,
            D3DTSS_MIPFILTER,
            D3DTSS_MIPMAPLODBIAS,
            D3DTSS_MAXMIPLEVEL,
            D3DTSS_MAXANISOTROPY,
            D3DTSS_BUMPENVLSCALE,
            D3DTSS_BUMPENVLOFFSET,
            D3DTSS_TEXTURETRANSFORMFLAGS,
            D3DTSS_ADDRESSW,
            D3DTSS_COLORARG0,
            D3DTSS_ALPHAARG0,
            D3DTSS_RESULTARG,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DTSS_SHADOWNEARW,
            D3DTSS_SHADOWFARW,
            D3DTSS_SHADOWBUFFERENABLE,
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_SHADOWBUFFERENABLE== *AllTSSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_RESULTARG== *AllTSSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef TSuper::TPerDDrawData TPerDDrawData;
        typedef TPerDDrawData::TDriver TDriver;
        const DWORD dwTextureStages( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwTextureMatrices( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwClipPlanes( TDriver::GetCaps().MaxUserClipPlanes);
        const DWORD dwVertexShaderConsts( TDriver::GetCaps().MaxVertexShaderConst);
        const DWORD dwPixelShaderConsts( GetNumPixelShaderConstReg(
            TDriver::GetCaps().PixelShaderVersion));

        // Algorithm to determine maximum SetTransform Index to support.
        DWORD dwWorldMatrices( TDriver::GetCaps().MaxVertexBlendMatrixIndex+ 1);
        if( TDriver::GetCaps().MaxVertexBlendMatrices> dwWorldMatrices)
            dwWorldMatrices= TDriver::GetCaps().MaxVertexBlendMatrices;

        DWORD dwActiveLights( 0);
        size_t uiRecDP2BufferSize( 0);

        // Pass 1: Calculate size of DP2 buffer required.

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                AllRSToCapture.size()* sizeof( D3DHAL_DP2RENDERSTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]== DP2Empty); }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwTextureStages*
                AllTSSToCapture.size()* sizeof( D3DHAL_DP2TEXTURESTAGESTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]== DP2Empty); }

        // Viewport
        if( m_RecFnCtr[ D3DDP2OP_VIEWPORTINFO]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_VIEWPORTINFO]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2VIEWPORTINFO);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_VIEWPORTINFO]== DP2Empty); }

        // Transforms
        if( m_RecFnCtr[ D3DDP2OP_SETTRANSFORM]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETTRANSFORM]!= DP2Empty);

            // World, Texture, View, & Projection
            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETTRANSFORM)* (dwWorldMatrices+
                dwTextureMatrices+ 2);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETTRANSFORM]== DP2Empty); }

        // Clipplanes
        if( m_RecFnCtr[ D3DDP2OP_SETCLIPPLANE]!= NULL&& dwClipPlanes!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETCLIPPLANE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETCLIPPLANE)* dwClipPlanes;
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETCLIPPLANE]== DP2Empty); }

        // Material
        if( m_RecFnCtr[ D3DDP2OP_SETMATERIAL]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETMATERIAL]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETMATERIAL);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETMATERIAL]== DP2Empty); }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]!= DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]!= DP2Empty);

            // Special exception here. First, ask how many active lights there
            // are. We'll then prepare a buffer that the RecFnCtr function
            // will have to know what to do with (as this is the only case
            // that is not obvious how to handle). RecFnCtr will key off
            // bCommand== 0.

            const D3DHAL_DP2COMMAND DP2Cmd= {
                static_cast< D3DHAL_DP2OPERATION>( 0), 0 };
            
            // Ask for how many active lights in DP2ActiveLights.dwIndex;
            D3DHAL_DP2CREATELIGHT DP2ActiveLights= { 0 };
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                &DP2Cmd, &DP2ActiveLights);
            dwActiveLights= DP2ActiveLights.dwIndex;
            
            if( dwActiveLights!= 0)
            {
                // Create structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    sizeof( D3DHAL_DP2CREATELIGHT);
                // Set structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    (2* sizeof( D3DHAL_DP2SETLIGHT)+ sizeof( D3DLIGHT8));
            }
        }
        else {
            assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]== DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]== DP2Empty);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2VERTEXSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]== DP2Empty); }
        
        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2PIXELSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]== DP2Empty); }

        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETVERTEXSHADERCONST)+
                dwVertexShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]== DP2Empty); }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETPIXELSHADERCONST)+
                dwPixelShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]== DP2Empty); }

        // Pass 2: Build command buffer for states.
        UINT8* pTempBuffer= NULL;
        try {
            pTempBuffer= reinterpret_cast< UINT8*>( 
                operator new ( uiRecDP2BufferSize));
        } catch ( ... ) {
        }
        if( NULL== pTempBuffer)
            throw bad_alloc( "Not enough room for StateSet");

        D3DHAL_DP2COMMAND* pStartSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer);
        D3DHAL_DP2COMMAND* pCur= pStartSSet;
        D3DHAL_DP2COMMAND* pEndSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer+ uiRecDP2BufferSize);

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_RENDERSTATE;
            pCur->wStateCount= static_cast< WORD>( AllRSToCapture.size());

            D3DHAL_DP2RENDERSTATE* pParam=
                reinterpret_cast< D3DHAL_DP2RENDERSTATE*>( pCur+ 1);

            TAllRSToCapture::const_iterator itRS( AllRSToCapture.begin());
            while( itRS!= AllRSToCapture.end())
            {
                pParam->RenderState= *itRS;
                ++itRS;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {
            pCur->bCommand= D3DDP2OP_TEXTURESTAGESTATE;
            pCur->wStateCount= static_cast< WORD>( dwTextureStages*
                AllTSSToCapture.size());

            D3DHAL_DP2TEXTURESTAGESTATE* pParam=
                reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>( pCur+ 1);

            for( WORD wStage( 0); wStage< dwTextureStages; ++wStage)
            {
                TAllTSSToCapture::const_iterator itTSS( AllTSSToCapture.begin());
                while( itTSS!= AllTSSToCapture.end())
                {
                    pParam->wStage= wStage;
                    pParam->TSState= *itTSS;
                    ++itTSS;
                    ++pParam;
                }
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Viewport
        if( m_RecFnCtr[ D3DDP2OP_VIEWPORTINFO]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_VIEWPORTINFO;
            pCur->wStateCount= 1;

            D3DHAL_DP2VIEWPORTINFO* pParam=
                reinterpret_cast< D3DHAL_DP2VIEWPORTINFO*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Transforms
        if( m_RecFnCtr[ D3DDP2OP_SETTRANSFORM]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETTRANSFORM;
            pCur->wStateCount= static_cast< WORD>( dwWorldMatrices+
                dwTextureMatrices+ 2);

            D3DHAL_DP2SETTRANSFORM* pParam=
                reinterpret_cast< D3DHAL_DP2SETTRANSFORM*>( pCur+ 1);

            pParam->xfrmType= D3DTRANSFORMSTATE_PROJECTION;
            ++pParam;

            pParam->xfrmType= D3DTRANSFORMSTATE_VIEW;
            ++pParam;

            for( DWORD dwTM( 0); dwTM< dwTextureMatrices; ++dwTM)
            {
                pParam->xfrmType= static_cast< D3DTRANSFORMSTATETYPE>(
                    D3DTRANSFORMSTATE_TEXTURE0+ dwTM);
                ++pParam;
            }

            for( DWORD dwWM( 0); dwWM< dwWorldMatrices; ++dwWM)
            {
                pParam->xfrmType= D3DTS_WORLDMATRIX( dwWM);
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Clipplanes
        if( m_RecFnCtr[ D3DDP2OP_SETCLIPPLANE]!= NULL&& dwClipPlanes!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETCLIPPLANE;
            pCur->wStateCount= static_cast< WORD>( dwClipPlanes);

            D3DHAL_DP2SETCLIPPLANE* pParam=
                reinterpret_cast< D3DHAL_DP2SETCLIPPLANE*>( pCur+ 1);

            for( DWORD dwCP( 0); dwCP< dwClipPlanes; ++dwCP)
            {
                pParam->dwIndex= dwCP;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Material
        if( m_RecFnCtr[ D3DDP2OP_SETMATERIAL]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETMATERIAL;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETMATERIAL* pParam=
                reinterpret_cast< D3DHAL_DP2SETMATERIAL*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL&& dwActiveLights!= 0)
        {
            // Special exception here. First, we asked how many active lights
            // there were. The RecFnCtr function will have to know what to do
            // with this buffer. We now give it a chance to fill in the
            // light ids. RecFnCtr will key off bCommand== 0.
            pCur->bCommand= static_cast< D3DHAL_DP2OPERATION>( 0);
            pCur->wStateCount= static_cast< WORD>( dwActiveLights);

            D3DHAL_DP2CREATELIGHT* pParam=
                reinterpret_cast< D3DHAL_DP2CREATELIGHT*>( pCur+ 1);
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                pCur, pParam);

            // Change back the bCommand for proper usage later.
            pCur->bCommand= D3DDP2OP_CREATELIGHT;
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ dwActiveLights);

            // Now, with the light ids in the CREATELIGHT structures, we can
            // fill out SETLIGHT structures with ids correctly.
            pCur->bCommand= D3DDP2OP_SETLIGHT;
            pCur->wStateCount= static_cast< WORD>( 2* dwActiveLights);

            D3DHAL_DP2SETLIGHT* pSParam=
                reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pCur+ 1);

            for( DWORD dwL( 0); dwL< dwActiveLights; ++dwL)
            {
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DATA;
                D3DLIGHT8* pLight= reinterpret_cast< D3DLIGHT8*>( pSParam+ 1);

                pSParam= reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pLight+ 1);
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DISABLE;
                ++pParam;
                ++pSParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pSParam);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2VERTEXSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2VERTEXSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }
        
        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2PIXELSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2PIXELSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETVERTEXSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETVERTEXSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwVertexShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwVertexShaderConsts);
        }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETPIXELSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETPIXELSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwPixelShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwPixelShaderConsts);
        }

        assert( reinterpret_cast< D3DHAL_DP2COMMAND*>( pCur)== pEndSSet);

        // Finally, build stateset.
        pair< TSSDB::iterator, bool> Ret;
        try {
            Ret= m_StateSetDB.insert( TSSDB::value_type(
                dwStateSetId, TStateSet( *pSThis, pStartSSet, pEndSSet)));
            assert( Ret.second);
        } catch ( ... ) {
            operator delete ( static_cast< void*>( pTempBuffer));
            throw;
        }

        // Now, capture it.
        Ret.first->second.Capture( *pSThis);
    }

    void CreateAndCapturePixelState( DWORD dwStateSetId)
    {
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 44> TPixRSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 41> TPixRSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DRENDERSTATETYPE, 39> TPixRSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TPixRSToCapture PixRSToCapture=
        {
            D3DRENDERSTATE_ZENABLE,
            D3DRENDERSTATE_FILLMODE,
            D3DRENDERSTATE_SHADEMODE,
            D3DRENDERSTATE_LINEPATTERN,
            D3DRENDERSTATE_ZWRITEENABLE,
            D3DRENDERSTATE_ALPHATESTENABLE,
            D3DRENDERSTATE_LASTPIXEL,
            D3DRENDERSTATE_SRCBLEND,
            D3DRENDERSTATE_DESTBLEND,
            D3DRENDERSTATE_ZFUNC,
            D3DRENDERSTATE_ALPHAREF,
            D3DRENDERSTATE_ALPHAFUNC,
            D3DRENDERSTATE_DITHERENABLE,
            D3DRENDERSTATE_STIPPLEDALPHA,
            D3DRENDERSTATE_FOGSTART,
            D3DRENDERSTATE_FOGEND,
            D3DRENDERSTATE_FOGDENSITY,
            D3DRENDERSTATE_EDGEANTIALIAS,
            D3DRENDERSTATE_ALPHABLENDENABLE,
            D3DRENDERSTATE_ZBIAS,
            D3DRENDERSTATE_STENCILENABLE,
            D3DRENDERSTATE_STENCILFAIL,
            D3DRENDERSTATE_STENCILZFAIL,
            D3DRENDERSTATE_STENCILPASS,
            D3DRENDERSTATE_STENCILFUNC,
            D3DRENDERSTATE_STENCILREF,
            D3DRENDERSTATE_STENCILMASK,
            D3DRENDERSTATE_STENCILWRITEMASK,
            D3DRENDERSTATE_TEXTUREFACTOR,
            D3DRENDERSTATE_WRAP0,
            D3DRENDERSTATE_WRAP1,
            D3DRENDERSTATE_WRAP2,
            D3DRENDERSTATE_WRAP3,
            D3DRENDERSTATE_WRAP4,
            D3DRENDERSTATE_WRAP5,
            D3DRENDERSTATE_WRAP6,
            D3DRENDERSTATE_WRAP7,
            D3DRS_COLORWRITEENABLE,
            D3DRS_BLENDOP,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DRS_ZSLOPESCALE,
            D3DRS_ZCLAMP,
#if defined( D3D_ENABLE_SHADOW_JITTER)
            D3DRS_JITZBIASMIN,
            D3DRS_JITZBIASMAX,
            D3DRS_JITSHADOWSIZE,
#endif // defined( D3D_ENABLE_SHADOW_JITTER)
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_JITSHADOWSIZE== *PixRSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_ZCLAMP== *PixRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DRS_BLENDOP== *PixRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

#if defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 30> TPixTSSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 27> TPixTSSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TPixTSSToCapture PixTSSToCapture=
        {
            D3DTSS_COLOROP,
            D3DTSS_COLORARG1,
            D3DTSS_COLORARG2,
            D3DTSS_ALPHAOP,
            D3DTSS_ALPHAARG1,
            D3DTSS_ALPHAARG2,
            D3DTSS_BUMPENVMAT00,
            D3DTSS_BUMPENVMAT01,
            D3DTSS_BUMPENVMAT10,
            D3DTSS_BUMPENVMAT11,
            D3DTSS_TEXCOORDINDEX,
            D3DTSS_ADDRESSU,
            D3DTSS_ADDRESSV,
            D3DTSS_BORDERCOLOR,
            D3DTSS_MAGFILTER,
            D3DTSS_MINFILTER,
            D3DTSS_MIPFILTER,
            D3DTSS_MIPMAPLODBIAS,
            D3DTSS_MAXMIPLEVEL,
            D3DTSS_MAXANISOTROPY,
            D3DTSS_BUMPENVLSCALE,
            D3DTSS_BUMPENVLOFFSET,
            D3DTSS_TEXTURETRANSFORMFLAGS,
            D3DTSS_ADDRESSW,
            D3DTSS_COLORARG0,
            D3DTSS_ALPHAARG0,
            D3DTSS_RESULTARG,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DTSS_SHADOWNEARW,
            D3DTSS_SHADOWFARW,
            D3DTSS_SHADOWBUFFERENABLE,
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_SHADOWBUFFERENABLE== *PixTSSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_RESULTARG== *PixTSSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef TSuper::TPerDDrawData TPerDDrawData;
        typedef TPerDDrawData::TDriver TDriver;
        const DWORD dwTextureStages( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwPixelShaderConsts( GetNumPixelShaderConstReg(
            TDriver::GetCaps().PixelShaderVersion));

        size_t uiRecDP2BufferSize( 0);

        // Pass 1: Calculate size of DP2 buffer required.

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                PixRSToCapture.size()* sizeof( D3DHAL_DP2RENDERSTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]== DP2Empty); }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwTextureStages*
                PixTSSToCapture.size()* sizeof( D3DHAL_DP2TEXTURESTAGESTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]== DP2Empty); }

        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2PIXELSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]== DP2Empty); }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETPIXELSHADERCONST)+
                dwPixelShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]== DP2Empty); }

        // Pass 2: Build command buffer for states.
        UINT8* pTempBuffer= NULL;
        try {
            pTempBuffer= reinterpret_cast< UINT8*>( 
                operator new ( uiRecDP2BufferSize));
        } catch ( ... ) {
        }
        if( NULL== pTempBuffer)
            throw bad_alloc( "Not enough room for StateSet");

        D3DHAL_DP2COMMAND* pStartSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer);
        D3DHAL_DP2COMMAND* pCur= pStartSSet;
        D3DHAL_DP2COMMAND* pEndSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer+ uiRecDP2BufferSize);

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_RENDERSTATE;
            pCur->wStateCount= static_cast< WORD>( PixRSToCapture.size());

            D3DHAL_DP2RENDERSTATE* pParam=
                reinterpret_cast< D3DHAL_DP2RENDERSTATE*>( pCur+ 1);

            TPixRSToCapture::const_iterator itRS( PixRSToCapture.begin());
            while( itRS!= PixRSToCapture.end())
            {
                pParam->RenderState= *itRS;
                ++itRS;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {
            pCur->bCommand= D3DDP2OP_TEXTURESTAGESTATE;
            pCur->wStateCount= static_cast< WORD>( dwTextureStages*
                PixTSSToCapture.size());

            D3DHAL_DP2TEXTURESTAGESTATE* pParam=
                reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>( pCur+ 1);

            for( WORD wStage( 0); wStage< dwTextureStages; ++wStage)
            {
                TPixTSSToCapture::const_iterator itTSS( PixTSSToCapture.begin());
                while( itTSS!= PixTSSToCapture.end())
                {
                    pParam->wStage= wStage;
                    pParam->TSState= *itTSS;
                    ++itTSS;
                    ++pParam;
                }
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2PIXELSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2PIXELSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETPIXELSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETPIXELSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwPixelShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwPixelShaderConsts);
        }

        assert( reinterpret_cast< D3DHAL_DP2COMMAND*>( pCur)== pEndSSet);

        // Finally, build stateset.
        pair< TSSDB::iterator, bool> Ret;
        try {
            Ret= m_StateSetDB.insert( TSSDB::value_type(
                dwStateSetId, TStateSet( *pSThis, pStartSSet, pEndSSet)));
            assert( Ret.second);
        } catch ( ... ) {
            operator delete ( static_cast< void*>( pTempBuffer));
            throw;
        }

        // Now, capture it.
        Ret.first->second.Capture( *pSThis);
    }

    void CreateAndCaptureVertexState( DWORD dwStateSetId)
    {
        typedef block< D3DRENDERSTATETYPE, 38> TVtxRSToCapture;
        const TVtxRSToCapture VtxRSToCapture=
        {
            D3DRENDERSTATE_SPECULARENABLE,
            D3DRENDERSTATE_SHADEMODE,
            D3DRENDERSTATE_CULLMODE,
            D3DRENDERSTATE_FOGENABLE,
            D3DRENDERSTATE_FOGCOLOR,
            D3DRENDERSTATE_FOGTABLEMODE,
            D3DRENDERSTATE_FOGSTART,
            D3DRENDERSTATE_FOGEND,
            D3DRENDERSTATE_FOGDENSITY,
            D3DRENDERSTATE_RANGEFOGENABLE,
            D3DRENDERSTATE_AMBIENT,
            D3DRENDERSTATE_COLORVERTEX,
            D3DRENDERSTATE_FOGVERTEXMODE,
            D3DRENDERSTATE_CLIPPING,
            D3DRENDERSTATE_LIGHTING,
            D3DRENDERSTATE_NORMALIZENORMALS,
            D3DRENDERSTATE_LOCALVIEWER,
            D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
            D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
            D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
            D3DRENDERSTATE_SPECULARMATERIALSOURCE,
            D3DRENDERSTATE_VERTEXBLEND,
            D3DRENDERSTATE_CLIPPLANEENABLE,
            D3DRS_SOFTWAREVERTEXPROCESSING,
            D3DRS_POINTSIZE,
            D3DRS_POINTSIZE_MIN,
            D3DRS_POINTSPRITEENABLE,
            D3DRS_POINTSCALEENABLE,
            D3DRS_POINTSCALE_A,
            D3DRS_POINTSCALE_B,
            D3DRS_POINTSCALE_C,
            D3DRS_MULTISAMPLEANTIALIAS,
            D3DRS_MULTISAMPLEMASK,
            D3DRS_PATCHEDGESTYLE,
            D3DRS_PATCHSEGMENTS,
            D3DRS_POINTSIZE_MAX,
            D3DRS_INDEXEDVERTEXBLENDENABLE,
            D3DRS_TWEENFACTOR
        };
        assert( D3DRS_TWEENFACTOR== *VtxRSToCapture.rbegin());
        typedef block< D3DTEXTURESTAGESTATETYPE, 2> TVtxTSSToCapture;
        const TVtxTSSToCapture VtxTSSToCapture=
        {
            D3DTSS_TEXCOORDINDEX,
            D3DTSS_TEXTURETRANSFORMFLAGS
        };
        assert( D3DTSS_TEXTURETRANSFORMFLAGS== *VtxTSSToCapture.rbegin());

        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef TSuper::TPerDDrawData TPerDDrawData;
        typedef TPerDDrawData::TDriver TDriver;
        const DWORD dwTextureStages( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwVertexShaderConsts( TDriver::GetCaps().MaxVertexShaderConst);
        DWORD dwActiveLights( 0);

        size_t uiRecDP2BufferSize( 0);

        // Pass 1: Calculate size of DP2 buffer required.

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                VtxRSToCapture.size()* sizeof( D3DHAL_DP2RENDERSTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]== DP2Empty); }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwTextureStages*
                VtxTSSToCapture.size()* sizeof( D3DHAL_DP2TEXTURESTAGESTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]== DP2Empty); }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]!= DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]!= DP2Empty);

            // Special exception here. First, ask how many active lights there
            // are. We'll then prepare a buffer that the RecFnCtr function
            // will have to know what to do with (as this is the only case
            // that is not obvious how to handle). RecFnCtr will key off
            // bCommand== 0.

            const D3DHAL_DP2COMMAND DP2Cmd= {
                static_cast< D3DHAL_DP2OPERATION>( 0), 0 };
            
            // Ask for how many active lights in DP2ActiveLights.dwIndex;
            D3DHAL_DP2CREATELIGHT DP2ActiveLights= { 0 };
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                &DP2Cmd, &DP2ActiveLights);
            dwActiveLights= DP2ActiveLights.dwIndex;
            
            if( dwActiveLights!= 0)
            {
                // Create structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    sizeof( D3DHAL_DP2CREATELIGHT);
                // Set structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    (2* sizeof( D3DHAL_DP2SETLIGHT)+ sizeof( D3DLIGHT8));
            }
        }
        else {
            assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]== DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]== DP2Empty);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2VERTEXSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]== DP2Empty); }
        
        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETVERTEXSHADERCONST)+
                dwVertexShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]== DP2Empty); }

        // Pass 2: Build command buffer for states.
        UINT8* pTempBuffer= NULL;
        try {
            pTempBuffer= reinterpret_cast< UINT8*>( 
                operator new ( uiRecDP2BufferSize));
        } catch ( ... ) {
        }
        if( NULL== pTempBuffer)
            throw bad_alloc( "Not enough room for StateSet");

        D3DHAL_DP2COMMAND* pStartSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer);
        D3DHAL_DP2COMMAND* pCur= pStartSSet;
        D3DHAL_DP2COMMAND* pEndSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer+ uiRecDP2BufferSize);

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_RENDERSTATE;
            pCur->wStateCount= static_cast< WORD>( VtxRSToCapture.size());

            D3DHAL_DP2RENDERSTATE* pParam=
                reinterpret_cast< D3DHAL_DP2RENDERSTATE*>( pCur+ 1);

            TVtxRSToCapture::const_iterator itRS( VtxRSToCapture.begin());
            while( itRS!= VtxRSToCapture.end())
            {
                pParam->RenderState= *itRS;
                ++itRS;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {
            pCur->bCommand= D3DDP2OP_TEXTURESTAGESTATE;
            pCur->wStateCount= static_cast< WORD>( dwTextureStages*
                VtxTSSToCapture.size());

            D3DHAL_DP2TEXTURESTAGESTATE* pParam=
                reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>( pCur+ 1);

            for( WORD wStage( 0); wStage< dwTextureStages; ++wStage)
            {
                TVtxTSSToCapture::const_iterator itTSS( VtxTSSToCapture.begin());
                while( itTSS!= VtxTSSToCapture.end())
                {
                    pParam->wStage= wStage;
                    pParam->TSState= *itTSS;
                    ++itTSS;
                    ++pParam;
                }
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL&& dwActiveLights!= 0)
        {
            // Special exception here. First, we asked how many active lights
            // there were. The RecFnCtr function will have to know what to do
            // with this buffer. We now give it a chance to fill in the
            // light ids. RecFnCtr will key off bCommand== 0.
            pCur->bCommand= static_cast< D3DHAL_DP2OPERATION>( 0);
            pCur->wStateCount= static_cast< WORD>( dwActiveLights);

            D3DHAL_DP2CREATELIGHT* pParam=
                reinterpret_cast< D3DHAL_DP2CREATELIGHT*>( pCur+ 1);
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                pCur, pParam);

            // Change back the bCommand for proper usage later.
            pCur->bCommand= D3DDP2OP_CREATELIGHT;
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ dwActiveLights);

            // Now, with the light ids in the CREATELIGHT structures, we can
            // fill out SETLIGHT structures with ids correctly.
            pCur->bCommand= D3DDP2OP_SETLIGHT;
            pCur->wStateCount= static_cast< WORD>( 2* dwActiveLights);

            D3DHAL_DP2SETLIGHT* pSParam=
                reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pCur+ 1);

            for( DWORD dwL( 0); dwL< dwActiveLights; ++dwL)
            {
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DATA;
                D3DLIGHT8* pLight= reinterpret_cast< D3DLIGHT8*>( pSParam+ 1);

                pSParam= reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pLight+ 1);
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DISABLE;
                ++pParam;
                ++pSParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pSParam);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2VERTEXSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2VERTEXSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }
        
        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETVERTEXSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETVERTEXSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwVertexShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwVertexShaderConsts);
        }

        assert( reinterpret_cast< D3DHAL_DP2COMMAND*>( pCur)== pEndSSet);

        // Finally, build stateset.
        pair< TSSDB::iterator, bool> Ret;
        try {
            Ret= m_StateSetDB.insert( TSSDB::value_type(
                dwStateSetId, TStateSet( *pSThis, pStartSSet, pEndSSet)));
            assert( Ret.second);
        } catch ( ... ) {
            operator delete ( static_cast< void*>( pTempBuffer));
            throw;
        }

        // Now, capture it.
        Ret.first->second.Capture( *pSThis);
    }

    // This member function handles the DP2OP_STATESET, which communicates back
    // to the DrawPrimitives2 entry point handler to implement state sets.
    HRESULT DP2StateSet( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        const D3DHAL_DP2STATESET* pParam=
            reinterpret_cast<const D3DHAL_DP2STATESET*>(pP);
        HRESULT hr( DD_OK);
        WORD wStateCount( pCmd->wStateCount);

        TSuper* pSThis= static_cast<TSuper*>(this);
        if( wStateCount!= 0) do
        {
            switch( pParam->dwOperation)
            {
            case( D3DHAL_STATESETCREATE):
                assert( !m_bRecordingStateSet);
                typedef TSuper::TPerDDrawData TPerDDrawData;
                typedef TPerDDrawData::TDriver TDriver;
                assert((TDriver::GetCaps().DevCaps& D3DDEVCAPS_PUREDEVICE)!= 0);

                try {
                    switch( pParam->sbType)
                    {
                    case( D3DSBT_ALL):
                        pSThis->CreateAndCaptureAllState( pParam->dwParam);
                        break;

                    case( D3DSBT_PIXELSTATE):
                        pSThis->CreateAndCapturePixelState( pParam->dwParam);
                        break;

                    case( D3DSBT_VERTEXSTATE):
                        pSThis->CreateAndCaptureVertexState( pParam->dwParam);
                        break;

                    default: {
                        const bool Unrecognized_StateSetCreate_Operation( false);
                        assert( Unrecognized_StateSetCreate_Operation);
                        } break;
                    }
                } catch( bad_alloc ba) {
                    return DDERR_OUTOFMEMORY;
                }
                break;

            case( D3DHAL_STATESETBEGIN):
                assert( 1== wStateCount);
                assert( !m_bRecordingStateSet);

                m_bRecordingStateSet= true;
                hr= c_hrStateSetBegin;
                // Returning this constant will break out of the parsing and
                // notify DrawPrimitive2 entry point handler to create a state
                // set.
                break;

            case( D3DHAL_STATESETCAPTURE):
                if( !m_bRecordingStateSet)
                {
                    // First, find the StateSet to capture.
                    typename TSSDB::iterator itSS(
                        m_StateSetDB.find( pParam->dwParam));
                    assert( itSS!= m_StateSetDB.end());

                    // Capture it.
                    itSS->second.Capture( *pSThis);
                }
                break;

            case( D3DHAL_STATESETDELETE):
                if( !m_bRecordingStateSet)
                {
                    m_StateSetDB.erase( pParam->dwParam);
                }
                break;

            case( D3DHAL_STATESETEND):
                assert( 1== wStateCount);
                assert( m_bRecordingStateSet);
                m_bRecordingStateSet= false;
                m_dwStateSetId= pParam->dwParam;
                m_pEndStateSet= pCmd;
                hr= c_hrStateSetEnd;
                break;

            case( D3DHAL_STATESETEXECUTE):
                if( !m_bRecordingStateSet)
                {
                    // First, find the StateSet to execute.
                    typename TSSDB::iterator itSS(
                        m_StateSetDB.find( pParam->dwParam));
                    assert( itSS!= m_StateSetDB.end());

                    // "Push" value of m_bExecutingStateSet, then set to true.
                    // "Pop" will occur at destruction.
                    CPushValue< bool> m_PushExecutingBit(
                        m_bExecutingStateSet, true);

                    // Execute it.
                    itSS->second.Execute( *pSThis);
                }
                break;

            default: {
                const bool Unrecognized_StateSet_Operation( false);
                assert( Unrecognized_StateSet_Operation);
                } break;
            }

            ++pParam;
        } while( SUCCEEDED( hr) && --wStateCount);

        return hr;
    }

    // This function is used to record the current state of the context/ device
    // into the command buffer.
    void RecordCommandBuffer( D3DHAL_DP2COMMAND* pBeginSS,
        D3DHAL_DP2COMMAND* pEndSS)
    {
        TSuper* pSThis= static_cast<TSuper*>(this);

        CDP2CmdIterator<> itCur( pBeginSS);
        const CDP2CmdIterator<> itEnd( pEndSS);
        SDP2MFnParser DP2Parser;
        TRMFnCaller RMFnCaller( *pSThis);

        HRESULT hr( DD_OK);
        while( itCur!= itEnd)
        {
            hr= DP2Parser.ParseDP2( RMFnCaller, m_RecFnCtr, itCur, itEnd);
            assert( SUCCEEDED( hr));

            // Ignore recording errors, except for debugging. Hopefully
            // the processing of this DP2 command (when appling the state set)
            // won't fault later.
            if( FAILED( hr))
                ++itCur;
        }
    }

    // Primary reason for class, handling of this function for the context.
    HRESULT DrawPrimitives2( PORTABLE_DRAWPRIMITIVES2DATA& dpd) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        TDP2Data DP2Data( dpd);

        // If not currently executing a stateset (which might recursively call
        // this function) notify start of DP2 entry point.
        if( !m_bExecutingStateSet)
            pSThis->OnBeginDrawPrimitives2( DP2Data);

        typename TDP2DataCmds::const_iterator itCur(
            DP2Data.GetCommands().begin() );
        const typename TDP2DataCmds::const_iterator itEnd(
            DP2Data.GetCommands().end() );
        SDP2MFnParser DP2Parser;
        TMFnCaller MFnCaller( *pSThis, DP2Data);

        HRESULT hr( DD_OK);
        do
        {
            hr= DP2Parser.ParseDP2( MFnCaller, m_DefFnCtr,
                itCur, itEnd);

            if( c_hrStateSetBegin== hr)
            {
                typename TDP2DataCmds::const_iterator itStartSSet( ++itCur);

                {
                    TDP2MFnCtr FakeFnCtr;
                    typename TDP2MFnCtr::iterator itCurFake( FakeFnCtr.begin());
                    while( itCurFake!= FakeFnCtr.end())
                        *itCurFake++ = DP2Fake;
                    FakeFnCtr[ D3DDP2OP_STATESET]= DP2StateSet;

                    hr= DP2Parser.ParseDP2( MFnCaller, FakeFnCtr,
                        itCur, itEnd);

                    assert( c_hrStateSetEnd== hr);
                    itCur++;
                }

                try
                {
                    pair< TSSDB::iterator, bool> Ret;
                    Ret= m_StateSetDB.insert( TSSDB::value_type( m_dwStateSetId,
                        TStateSet( *pSThis, itStartSSet, m_pEndStateSet)));

                    // There shouldn't be two statesets with the same Id.
                    assert( Ret.second);
                    hr= S_OK;
                } catch( bad_alloc e) {
                    hr= DDERR_OUTOFMEMORY;
                }
            }
            assert( c_hrStateSetEnd!= hr);
        } while( SUCCEEDED(hr)&& itCur!= itEnd);

        if( FAILED( hr))
        {
            const D3DHAL_DP2COMMAND* pS= itCur;
            const D3DHAL_DP2COMMAND* pE= itEnd;
            dpd.dwErrorOffset()= reinterpret_cast<const UINT8*>(pE)-
                reinterpret_cast<const UINT8*>(pS);
        }

        // If not currently executing a stateset (which might recursively call
        // this function) notify end of DP2 entry point.
        if( !m_bExecutingStateSet)
            pSThis->OnEndDrawPrimitives2( DP2Data);
        return hr;
    }
};

template< class TSuper, class TSS, class TSSDB, class TDP2D, class TDP2MFC,
    class TDP2RMFC>
const HRESULT CStdDrawPrimitives2< TSuper, TSS, TSSDB, TDP2D, TDP2MFC,
    TDP2RMFC>::c_hrStateSetBegin= S_FALSE+ 556;

template< class TSuper, class TSS, class TSSDB, class TDP2D, class TDP2MFC,
    class TDP2RMFC>
const HRESULT CStdDrawPrimitives2< TSuper, TSS, TSSDB, TDP2D, TDP2MFC,
    TDP2RMFC>::c_hrStateSetEnd= S_FALSE+ 557;

////////////////////////////////////////////////////////////////////////////////
//
// CStdDP2ViewportInfoStore,
// CStdDP2WInfoStore,
// CStdDP2SetTransformStore,
// etc: CStdDP2xxxxxStore...
//
// These classes provide default DP2 operation support, typically just storing
// state. They have support for a notification mechanism, which delegates to
// the parent Context.
//
////////////////////////////////////////////////////////////////////////////////

// MSVC doesn't support partial specialization or we could've had something
// elegant like:
//
// template< class TSuper, class TParam>
// class CStdDP2ParamStore {};
//
// for typical support like:
// CStdDP2ParamStore< ..., D3DHAL_DP2VIEWPORTINFO>
// CStdDP2ParamStore< ..., D3DHAL_DP2WINFO>
//
// with partial specializations for exceptions like:
//
// template< class TSuper>
// class CStdDP2ParamStore< TSuper, D3DHAL_DP2RENDERSTATE> {};
// template< class TSuper>
// class CStdDP2ParamStore< TSuper, D3DHAL_DP2TEXTURESTAGESTATE> {};
//
// So, without this support, it'll be easier for each class to have a unique
// name; as MSVC is currently buggy about inheriting from the same named class
// multiple times, even WITH a different template parameter.

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2ViewportInfoStore
{
protected: // Variables
    D3DHAL_DP2VIEWPORTINFO m_Param;

protected: // Functions
    CStdDP2ViewportInfoStore() 
    { }
    explicit CStdDP2ViewportInfoStore( const D3DHAL_DP2VIEWPORTINFO& P) 
        :m_Param( P)
    { }
    ~CStdDP2ViewportInfoStore() 
    { }

    D3DHAL_DP2VIEWPORTINFO NewDP2ViewportInfo( const D3DHAL_DP2VIEWPORTINFO&
        CurParam, const D3DHAL_DP2VIEWPORTINFO& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2ViewportInfo( D3DHAL_DP2VIEWPORTINFO& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2VIEWPORTINFO() const 
    { return m_Param; }
    HRESULT DP2ViewportInfo( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2VIEWPORTINFO* pParam=
            reinterpret_cast< const D3DHAL_DP2VIEWPORTINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2ViewportInfo( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2ViewportInfo( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2VIEWPORTINFO* pParam=
            reinterpret_cast< D3DHAL_DP2VIEWPORTINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2ViewportInfo( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2WInfoStore
{
protected: // Variables
    D3DHAL_DP2WINFO m_Param;

protected: // Functions
    CStdDP2WInfoStore() 
    { }
    explicit CStdDP2WInfoStore( const D3DHAL_DP2WINFO& P) 
        :m_Param( P)
    { }
    ~CStdDP2WInfoStore() 
    { }

    D3DHAL_DP2WINFO NewDP2WInfo( const D3DHAL_DP2WINFO& CurParam,
        const D3DHAL_DP2WINFO& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2WInfo( D3DHAL_DP2WINFO& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2WINFO() const 
    { return m_Param; }
    HRESULT DP2WInfo( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2WINFO* pParam=
            reinterpret_cast< const D3DHAL_DP2WINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2WInfo( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2WInfo( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2WINFO* pParam=
            reinterpret_cast< D3DHAL_DP2WINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2WInfo( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2ZRangeStore
{
protected: // Variables
    D3DHAL_DP2ZRANGE m_Param;

protected: // Functions
    CStdDP2ZRangeStore() 
    { }
    explicit CStdDP2ZRangeStore( const D3DHAL_DP2ZRANGE& P) 
        :m_Param( P)
    { }
    ~CStdDP2ZRangeStore() 
    { }

    D3DHAL_DP2ZRANGE NewDP2ZRange( const D3DHAL_DP2ZRANGE& CurParam,
        const D3DHAL_DP2ZRANGE& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2ZRange( D3DHAL_DP2ZRANGE& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2ZRANGE() const 
    { return m_Param; }
    HRESULT DP2ZRange( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2ZRANGE* pParam=
            reinterpret_cast< const D3DHAL_DP2ZRANGE*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2ZRange( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2ZRange( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2ZRANGE* pParam=
            reinterpret_cast< D3DHAL_DP2ZRANGE*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2ZRange( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetMaterialStore
{
protected: // Variables
    D3DHAL_DP2SETMATERIAL m_Param;

protected: // Functions
    CStdDP2SetMaterialStore() 
    { }
    explicit CStdDP2SetMaterialStore( const D3DHAL_DP2SETMATERIAL& P) 
        :m_Param( P)
    { }
    ~CStdDP2SetMaterialStore() 
    { }

    D3DHAL_DP2SETMATERIAL NewDP2SetMaterial( const D3DHAL_DP2SETMATERIAL& CurParam,
        const D3DHAL_DP2SETMATERIAL& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2SetMaterial( D3DHAL_DP2SETMATERIAL& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2SETMATERIAL() const 
    { return m_Param; }
    HRESULT DP2SetMaterial( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETMATERIAL* pParam=
            reinterpret_cast< const D3DHAL_DP2SETMATERIAL*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2SetMaterial( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetMaterial( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETMATERIAL* pParam=
            reinterpret_cast< D3DHAL_DP2SETMATERIAL*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2SetMaterial( *pParam);
            ++pParam;
        } while( --wStateCount);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetVertexShaderStore
{
protected: // Variables
    D3DHAL_DP2VERTEXSHADER m_Param;

protected: // Functions
    CStdDP2SetVertexShaderStore() 
    { }
    explicit CStdDP2SetVertexShaderStore( const D3DHAL_DP2VERTEXSHADER& P)
        : m_Param( P)
    { }
    ~CStdDP2SetVertexShaderStore() 
    { }

    D3DHAL_DP2VERTEXSHADER NewDP2SetVertexShader( const D3DHAL_DP2VERTEXSHADER&
        CurParam, const D3DHAL_DP2VERTEXSHADER& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2SetVertexShader( D3DHAL_DP2VERTEXSHADER& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2VERTEXSHADER() const 
    { return m_Param; }
    HRESULT DP2SetVertexShader( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2VERTEXSHADER* pParam=
            reinterpret_cast< const D3DHAL_DP2VERTEXSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2SetVertexShader( m_Param, *pParam);

            // If the handle is 0, the Device/ Context needs to invalidate all
            // streams.
            if( 0== m_Param.dwHandle)
            {
                // The CStdDP2VStreamManager provides a default implementation
                // for InvalidateAllVStreams()
                pSThis->InvalidateAllVStreams();
                // The CStdDP2IStreamManager provides a default implementation
                // for InvalidateAllIStreams()
                pSThis->InvalidateAllIStreams();
            }
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetVertexShader( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2VERTEXSHADER* pParam=
            reinterpret_cast< D3DHAL_DP2VERTEXSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2SetVertexShader( *pParam);
            ++pParam;
        } while( wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetPixelShaderStore
{
protected: // Variables
    D3DHAL_DP2PIXELSHADER m_Param;

protected: // Functions
    CStdDP2SetPixelShaderStore() 
    { }
    explicit CStdDP2SetPixelShaderStore( const D3DHAL_DP2PIXELSHADER& P)
        : m_Param( P)
    { }
    ~CStdDP2SetPixelShaderStore() 
    { }

    D3DHAL_DP2PIXELSHADER NewDP2SetPixelShader( const D3DHAL_DP2PIXELSHADER&
        CurParam, const D3DHAL_DP2PIXELSHADER& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2SetPixelShader( D3DHAL_DP2PIXELSHADER& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2PIXELSHADER() const 
    { return m_Param; }
    HRESULT DP2SetPixelShader( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2PIXELSHADER* pParam=
            reinterpret_cast< const D3DHAL_DP2PIXELSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2SetPixelShader( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetPixelShader( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2PIXELSHADER* pParam=
            reinterpret_cast< D3DHAL_DP2PIXELSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2SetPixelShader( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// c_uiWorldMatrices: The number of world transform matrices that should be
//     stored.
// c_uiTextureMatrices: The number of texture transform matrices that should
//     be stored.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, const size_t c_uiWorldMatrices= 256,
    const size_t c_uiTextureMatrices= D3DHAL_TSS_MAXSTAGES,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetTransformStore
{
protected: // Types
    typedef block< D3DMATRIX, 2+ c_uiTextureMatrices+ c_uiWorldMatrices>
        TMatrices;

protected: // Variables
    TMatrices m_Matrices;

private: // Functions
    static bool IsValidTransformType( D3DTRANSFORMSTATETYPE Type)
    {
        // We might not be storing this transform matrix, so we shouldn't
        // record it in a state set and ignore any SET requests.
        if( (Type>= D3DTS_VIEW&& Type<= D3DTS_PROJECTION)||
            (Type>= D3DTS_TEXTURE0&& Type< static_cast< D3DTRANSFORMSTATETYPE>( 
            D3DTS_TEXTURE0+ c_uiTextureMatrices))||
            (Type>= D3DTS_WORLD&& Type< static_cast< D3DTRANSFORMSTATETYPE>(
            D3DTS_WORLDMATRIX( c_uiWorldMatrices))))
            return true;
        return false;
    }
    static size_t TransformTypeToIndex( D3DTRANSFORMSTATETYPE Type)
    {
        assert( Type>= D3DTS_VIEW);
        if( Type< D3DTS_TEXTURE0)
        {
            assert( Type<= D3DTS_PROJECTION);
            return static_cast< size_t>( Type- D3DTS_VIEW);
        }
        else if( Type< D3DTS_WORLD)
        {
            assert( Type< static_cast< D3DTRANSFORMSTATETYPE>( \
                D3DTS_TEXTURE0+ c_uiTextureMatrices));
            return static_cast< size_t>( Type- D3DTS_TEXTURE0+ 2);
        }
        else
        {
            assert( Type< static_cast< D3DTRANSFORMSTATETYPE>( \
                D3DTS_WORLDMATRIX( c_uiWorldMatrices)));
            return static_cast< size_t>( Type- D3DTS_WORLD+
                c_uiTextureMatrices+ 2);
        }
    }

protected: // Functions
    CStdDP2SetTransformStore()
    { }
    template< class TIter> // D3DHAL_DP2SETTRANSFORM*
    CStdDP2SetTransformStore( TIter itStart, const TIter itEnd)
    {
        while( itStart!= itEnd)
        {
            m_Matrices[ TransformTypeToIndex( itStart->xfrmType)]=
                itStart->matrix;
            ++itStart;
        }
    }
    ~CStdDP2SetTransformStore()
    { }

    D3DHAL_DP2SETTRANSFORM NewDP2SetTransform( const D3DHAL_DP2SETTRANSFORM&
        CurParam, const D3DHAL_DP2SETTRANSFORM& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    D3DMATRIX GetTransform( D3DTRANSFORMSTATETYPE Type) const
    { return m_Matrices[ TransformTypeToIndex( Type)]; }
    void GetDP2SetTransform( D3DHAL_DP2SETTRANSFORM& GetParam) const 
    { GetParam.matrix= GetTransform( GetParam.xfrmType); }
    HRESULT DP2SetTransform( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETTRANSFORM* pParam=
            reinterpret_cast<const D3DHAL_DP2SETTRANSFORM*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( IsValidTransformType( pParam->xfrmType))
            {
                D3DHAL_DP2SETTRANSFORM CurWrap;
                CurWrap.xfrmType= pParam->xfrmType;
                GetDP2SetTransform( CurWrap);

                D3DHAL_DP2SETTRANSFORM NewState(
                    pSThis->NewDP2SetTransform( CurWrap, *pParam));

                m_Matrices[ TransformTypeToIndex( NewState.xfrmType)]=
                    NewState.matrix;
            }
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetTransform( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETTRANSFORM* pParam=
            reinterpret_cast< D3DHAL_DP2SETTRANSFORM*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( IsValidTransformType( pParam->xfrmType))
                GetDP2SetTransform( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// c_uiClipPlanes: The number of user clip planes that should be stored. This
//     should be consistent with the driver cap.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, const size_t c_uiClipPlanes,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetClipPlaneStore
{
protected: // Types
    typedef block< block< D3DVALUE, 4>, c_uiClipPlanes> TClipPlanes;

protected: // Variables
    TClipPlanes m_ClipPlanes;

protected: // Functions
    CStdDP2SetClipPlaneStore()
    { }
    template< class TIter> // D3DHAL_DP2SETCLIPPLANE*
    CStdDP2SetClipPlaneStore( TIter itStart, const TIter itEnd)
    {
        while( itStart!= itEnd)
        {
            m_ClipPlanes[ itStart->dwIndex]= itStart->plane;
            ++itStart;
        }
    }
    ~CStdDP2SetClipPlaneStore()
    { }

    D3DHAL_DP2SETCLIPPLANE NewDP2SetClipPlane( const D3DHAL_DP2SETCLIPPLANE&
        CurParam, const D3DHAL_DP2SETCLIPPLANE& NewParam) const
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Functions
    block< D3DVALUE, 4> GetClipPlane( DWORD dwIndex) const
    { return m_ClipPlanes[ dwIndex]; }
    void GetDP2SetClipPlane( D3DHAL_DP2SETCLIPPLANE& GetParam) const
    { 
        block< D3DVALUE, 4> CP( GetClipPlane( GetParam.dwIndex));
        copy( CP.begin(), CP.end(), &GetParam.plane[ 0]);
    }
    HRESULT DP2SetClipPlane( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETCLIPPLANE* pParam=
            reinterpret_cast<const D3DHAL_DP2SETCLIPPLANE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwIndex< m_ClipPlanes.size())
            {
                D3DHAL_DP2SETCLIPPLANE CurWrap;
                CurWrap.dwIndex= pParam->dwIndex;
                GetDP2SetClipPlane( CurWrap);

                D3DHAL_DP2SETCLIPPLANE NewState( 
                    pSThis->NewDP2SetClipPlane( CurWrap, *pParam));

                copy( &NewState.plane[ 0], &NewState.plane[ 4],
                    m_ClipPlanes[ NewState.dwIndex].begin());
            }
            ++pParam;
        } while( --wStateCount);
        return DD_OK;
    }
    HRESULT RecDP2SetClipPlane( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETCLIPPLANE* pParam=
            reinterpret_cast< D3DHAL_DP2SETCLIPPLANE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwIndex< m_ClipPlanes.size())
                GetDP2SetClipPlane( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2RenderStateStore
{
protected: // Variables
    block< DWORD, D3DHAL_MAX_RSTATES> m_Param;

protected: // Functions
    CStdDP2RenderStateStore() 
    { m_Param[ D3DRENDERSTATE_SCENECAPTURE]= FALSE; }
    template< class TIter> // D3DHAL_DP2RENDERSTATE*
    CStdDP2RenderStateStore( TIter itStart, const TIter itEnd)
    {
        m_Param[ D3DRENDERSTATE_SCENECAPTURE]= FALSE; 
        while( itStart!= itEnd)
        {
            m_Param[ itStart->RenderState]= itStart->dwState;
            itStart++;
        }
    }
    ~CStdDP2RenderStateStore() 
    { }

    D3DHAL_DP2RENDERSTATE NewDP2RenderState( const D3DHAL_DP2RENDERSTATE&
        CurParam, const D3DHAL_DP2RENDERSTATE& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

    void OnSceneCaptureStart( void) 
    { }
    void OnSceneCaptureEnd( void) 
    { }

public: // Functions
    DWORD GetRenderStateDW( D3DRENDERSTATETYPE RS) const 
    { return m_Param[ RS]; }
    D3DVALUE GetRenderStateDV( D3DRENDERSTATETYPE RS) const 
    { return *(reinterpret_cast< const D3DVALUE*>( &m_Param[ RS])); }
    void GetDP2RenderState( D3DHAL_DP2RENDERSTATE& GetParam) const 
    { GetParam.dwState= GetRenderStateDW( GetParam.RenderState); }
    HRESULT DP2RenderState( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2RENDERSTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2RENDERSTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        D3DHAL_DP2RENDERSTATE SCap;
        SCap.RenderState= static_cast< D3DRENDERSTATETYPE>(
            D3DRENDERSTATE_SCENECAPTURE);
        GetDP2RenderState( SCap);
        const DWORD dwOldSC( SCap.dwState);

        if((DP2Data.dwFlags()& D3DHALDP2_EXECUTEBUFFER)!= 0)
        {
            // DP2Data.lpdwRStates should be valid.

            if( wStateCount!= 0) do
            {
                if( pParam->RenderState< D3DHAL_MAX_RSTATES)
                {
                    D3DHAL_DP2RENDERSTATE CurWrap;
                    CurWrap.RenderState= pParam->RenderState;
                    GetDP2RenderState( CurWrap);

                    D3DHAL_DP2RENDERSTATE NewState(
                        pSThis->NewDP2RenderState( CurWrap, *pParam));
                    
                    m_Param[ NewState.RenderState]= NewState.dwState;
                    DP2Data.lpdwRStates()[ NewState.RenderState]= NewState.dwState;
                }
                ++pParam;
            } while( --wStateCount!= 0);
            
        }
        else
        {
            if( wStateCount!= 0) do
            {
                if( pParam->RenderState< D3DHAL_MAX_RSTATES)
                {
                    D3DHAL_DP2RENDERSTATE CurWrap;
                    CurWrap.RenderState= pParam->RenderState;
                    GetDP2RenderState( CurWrap);

                    D3DHAL_DP2RENDERSTATE NewState(
                        pSThis->NewDP2RenderState( CurWrap, *pParam));

                    m_Param[ NewState.RenderState]= NewState.dwState;
                }
                ++pParam;
            } while( --wStateCount!= 0);
        }

        GetDP2RenderState( SCap);
        if( FALSE== dwOldSC && TRUE== SCap.dwState)
            OnSceneCaptureStart();
        else if( TRUE== dwOldSC && FALSE== SCap.dwState)
            OnSceneCaptureEnd();

        return DD_OK;
    }
    HRESULT RecDP2RenderState( const D3DHAL_DP2COMMAND* pCmd, void* pP) 
    {
        D3DHAL_DP2RENDERSTATE* pParam=
            reinterpret_cast< D3DHAL_DP2RENDERSTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount) do
        {
            if( pParam->RenderState< D3DHAL_MAX_RSTATES)
                GetDP2RenderState( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);

        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2TextureStageStateStore
{
protected: // Variables
    block< block< DWORD, D3DTSS_MAX>, D3DHAL_TSS_MAXSTAGES> m_Param;

protected: // Functions
    CStdDP2TextureStageStateStore() 
    { }
    template< class TIter> // D3DHAL_DP2TEXTURESTAGESTATE*
    CStdDP2TextureStageStateStore( TIter itStart, const TIter itEnd)
    {   
        while( itStart!= itEnd)
        {
            m_Param[ itStart->wStage][ itStart->TSState]= itStart->dwValue();
            ++itStart;
        }
    }
    ~CStdDP2TextureStageStateStore() 
    { }

    D3DHAL_DP2TEXTURESTAGESTATE NewDP2TextureStageState( const 
        D3DHAL_DP2TEXTURESTAGESTATE& CurParam, const
        D3DHAL_DP2TEXTURESTAGESTATE& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Functions
    DWORD GetTextureStageStateDW( WORD wStage, WORD wTSState) const 
    { return m_Param[ wStage][ wTSState]; }
    D3DVALUE GetTextureStageStateDV( WORD wStage, WORD wTSState) const 
    { return *(reinterpret_cast< const D3DVALUE*>( &m_Param[ wStage][ wTSState])); }
    void GetDP2TextureStageState( D3DHAL_DP2TEXTURESTAGESTATE& GetParam) const
    { GetParam.dwValue= GetTextureStageStateDW( GetParam.wStage, GetParam.TSState); }
    HRESULT DP2TextureStageState( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2TEXTURESTAGESTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2TEXTURESTAGESTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->wStage< D3DHAL_TSS_MAXSTAGES&& pParam->TSState< D3DTSS_MAX)
            {
                D3DHAL_DP2TEXTURESTAGESTATE CurWrap;
                CurWrap.wStage= pParam->wStage;
                CurWrap.TSState= pParam->TSState;
                GetDP2TextureStageState( CurWrap);

                D3DHAL_DP2TEXTURESTAGESTATE NewState( 
                    pSThis->NewDP2TextureStageState( CurWrap, *pParam));

                m_Param[ NewState.wStage][ NewState.TSState]= NewState.dwValue;
            }
            ++pParam;
        } while( --wStateCount);

        return DD_OK;
    }
    HRESULT RecDP2TextureStageState( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2TEXTURESTAGESTATE* pParam=
            reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->wStage< D3DHAL_TSS_MAXSTAGES&& pParam->TSState< D3DTSS_MAX)
                GetDP2TextureStageState( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// The more complex manager classes:
//

////////////////////////////////////////////////////////////////////////////////
//
// CVStream
//
// This class stores everything associated with a vertex stream. This
// implementation allows 4 representations (video, system, user, and none).
// This class is used by a VStream manager class.
//
// <Template Parameters>
// TS: Video memory surface object, typically either CMySurface or
//     IVidMemSurface, etc. A valid pointer to this object is stored, when the
//     stream source is from a video memory surface.
// TSDBE: The SurfDBEntry type, typically, CMySurfDBEntry or CSurfDBEntry. A
//     valid pointer to this object is stored, when the stream source is from
//     a video memory or system memory surface.
//
////////////////////////////////////////////////////////////////////////////////
template< class TS, class TSDBE>
class CVStream
{
public: // Types
    typedef TS TSurface;
    typedef TSDBE TSurfDBEntry;
    enum EMemLocation
    {
        None,
        User,
        System,
        Video
    };

protected: // Variables
    DWORD m_dwHandle;
    TSurface m_Surface;
    TSurfDBEntry m_SurfDBEntry;
    void* m_pUserMemData;
    DWORD m_dwStride;
    DWORD m_dwFVF;
    EMemLocation m_eMemLocation;

public: // Functions
    CVStream()
        : m_dwHandle( 0), m_pUserMemData( NULL), m_dwStride( 0), m_dwFVF( 0),
        m_eMemLocation( None)
    { }
    // Video Memory representation constructor.
    CVStream( DWORD dwHandle, const TSurface& Surface,
        const TSurfDBEntry& SurfDBEntry, DWORD dwStride): m_dwHandle( dwHandle),
        m_Surface( Surface), m_SurfDBEntry( SurfDBEntry), m_pUserMemData( NULL),
        m_dwStride( dwStride), m_dwFVF( 0), m_eMemLocation( Video)
    { }
    // System Memory representation constructor.
    CVStream( DWORD dwHandle, const TSurfDBEntry& SurfDBEntry, DWORD dwStride):
        m_dwHandle( dwHandle), m_SurfDBEntry( SurfDBEntry),
        m_pUserMemData( NULL), m_dwStride( dwStride), m_dwFVF( 0),
        m_eMemLocation( System)
    { }
    // User Memory representation constructor.
    CVStream( void* pUserMem, DWORD dwStride):
        m_dwHandle( 0), m_pUserMemData( pUserMem), m_dwStride( dwStride),
        m_dwFVF( 0), m_eMemLocation( User)
    { }

    EMemLocation GetMemLocation() const
    { return m_eMemLocation; }
    void SetFVF( DWORD dwFVF)
    { m_dwFVF= dwFVF; }
    DWORD GetFVF() const
    { return m_dwFVF; }
    DWORD GetHandle() const
    {
        assert( GetMemLocation()== System|| GetMemLocation()== Video);
        return m_dwHandle;
    }
    DWORD GetStride() const
    {
        assert( GetMemLocation()!= None);
        return m_dwStride;
    }
    TSurface& GetVidMemRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    const TSurface& GetVidMemRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    TSurfDBEntry& GetSurfDBRepresentation()
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
    const TSurfDBEntry& GetSurfDBRepresentation() const
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
    void* GetUserMemPtr() const
    {
        assert( GetMemLocation()== User);
        return m_pUserMemData;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CStdDP2VStreamManager
//
// This class contains DP2 member functions to correctly process 
// D3DDP2OP_SETSTREAMSOURCE & D3DDP2OP_SETSTREAMSOURCEUM. It can also correctly
// record a command buffer operation for D3DDP2OP_SETSTREAMSOURCE. To do this,
// however, it must maintain information for vertex stream, or "manage"
// VStream objects.
//
// This class also contains a function, InvalidateAllStreams, which is needed
// to be called when a D3DDP2OP_SETVERTEXSHADER operation is processed with a
// zero value VERTEXSHADER.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TVS: The vertex stream type which represents data associated with a vertex
//     stream. This is typically, CVStream<> or something derived from it.
// c_uiStreams: The number of vertex streams to support. Typically, non-TnL
//     drivers only support 1. This should be consistent with the cap in the
//     driver.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper,
    class TVS= CVStream< TSuper::TPerDDrawData::TDriver::TSurface*, TSuper::TPerDDrawData::TSurfDBEntry*>,
    const size_t c_uiStreams= 1, class TDP2Data= CDP2DataWrap<> >
class CStdDP2VStreamManager
{
public: // Types
    typedef TVS TVStream;
    typedef block< TVStream, c_uiStreams> TVStreamDB;

protected: // Variables
    TVStreamDB m_VStreamDB;

protected: // Functions
    CStdDP2VStreamManager() 
    { }
    ~CStdDP2VStreamManager() 
    { }

public: // Fuctions
    TVStream& GetVStream( TVStreamDB::size_type uiStream)
    { return m_VStreamDB[ uiStream]; }
    const TVStream& GetVStream( TVStreamDB::size_type uiStream) const
    { return m_VStreamDB[ uiStream]; }
    HRESULT DP2SetStreamSource( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2SETSTREAMSOURCE* pParam=
            reinterpret_cast< const D3DHAL_DP2SETSTREAMSOURCE*>( pP);
        TSuper* pSThis= static_cast<TSuper*>(this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwStream< m_VStreamDB.size())
            {
                if( 0== pParam->dwVBHandle)
                    m_VStreamDB[ pParam->dwStream]= TVStream();
                else
                {
                    typename TSuper::TPerDDrawData::TSurfDBEntry* pDBEntry=
                        pSThis->GetPerDDrawData().GetSurfDBEntry(
                        pParam->dwVBHandle);
                    if( pDBEntry!= NULL)
                    {
                        if((pDBEntry->GetLCLddsCaps().dwCaps&
                            DDSCAPS_VIDEOMEMORY)!= 0)
                        {
                            // Assign in a video memory representation.
                            m_VStreamDB[ pParam->dwStream]=
                                TVStream( pParam->dwVBHandle, pSThis->
                                GetPerDDrawData().GetDriver().GetSurface(
                                *pDBEntry), pDBEntry, pParam->dwStride);
                        }
                        else
                        {
                            // Assign in a system memory representation.
                            m_VStreamDB[ pParam->dwStream]=
                                TVStream( pParam->dwVBHandle,
                                pDBEntry, pParam->dwStride);
                        }
                    }
                    else
                    {
                        // Handle invalid, reset stream.
                        m_VStreamDB[ pParam->dwStream]= TVStream();
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT DP2SetStreamSourceUM( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2SETSTREAMSOURCEUM* pParam=
            reinterpret_cast< const D3DHAL_DP2SETSTREAMSOURCEUM*>( pP);
        TSuper* pSThis= static_cast<TSuper*>(this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwStream< m_VStreamDB.size())
            {
                if( DP2Data.lpVertices()!= NULL)
                {
                    // Assign in a user memory representation.
                    m_VStreamDB[ pParam->dwStream]=
                        TVStream( DP2Data.lpVertices(), pParam->dwStride);
                }
                else
                {
                    // Reset stream.
                    m_VStreamDB[ pParam->dwStream]= TVStream();
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetStreamSource( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETSTREAMSOURCE* pParam=
            reinterpret_cast< D3DHAL_DP2SETSTREAMSOURCE*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            const DWORD dwStream( pParam->dwStream);
            if( dwStream< m_VStreamDB.size())
            {
                const TVStream& VStream( m_VStreamDB[ dwStream]);
                switch( VStream.GetMemLocation())
                {
                case( TVStream::EMemLocation::None): ;
                case( TVStream::EMemLocation::User): ;
                    pParam->dwVBHandle= 0;
                    pParam->dwStride= 0;
                    break;

                case( TVStream::EMemLocation::System): ;
                case( TVStream::EMemLocation::Video): ;
                    pParam->dwVBHandle= VStream.GetHandle();
                    pParam->dwStride= VStream.GetStride();
                    break;

                default: {
                    const bool Unrecognized_VStream_enum( false);
                    assert( Unrecognized_VStream_enum);
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    void InvalidateAllVStreams()
    {
        fill( m_VStreamDB.begin(), m_VStreamDB.end(), TVStream());
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CIStream
//
// This class stores everything associated with a index stream. This
// implementation allows 3 representations (video, system, and none).
// This class is used by a IStream manager class.
//
// <Template Parameters>
// TS: Video memory surface object, typically either CMySurface or
//     IVidMemSurface, etc. A valid pointer to this object is stored, when the
//     stream source is from a video memory surface.
// TSDBE: The SurfDBEntry type, typically, CMySurfDBEntry or CSurfDBEntry. A
//     valid pointer to this object is stored, when the stream source is from
//     a video memory or system memory surface.
//
////////////////////////////////////////////////////////////////////////////////
template< class TS, class TSDBE>
class CIStream
{
public: // Types
    typedef TS TSurface;
    typedef TSDBE TSurfDBEntry;
    enum EMemLocation
    {
        None,
        System,
        Video
    };

protected: // Variables
    DWORD m_dwHandle;
    TSurface m_Surface;
    TSurfDBEntry m_SurfDBEntry;
    DWORD m_dwStride;
    EMemLocation m_eMemLocation;

public: // Functions
    CIStream():
        m_dwHandle( 0), m_dwStride( 0), m_eMemLocation( None)
    { }
    // Video Memory representation constructor.
    CIStream( DWORD dwHandle, const TSurface& Surface,
        const TSurfDBEntry& SurfDBEntry, DWORD dwStride): m_dwHandle( dwHandle),
        m_Surface( Surface), m_SurfDBEntry( SurfDBEntry), m_dwStride( dwStride),
        m_eMemLocation( Video)
    { }
    // System Memory representation constructor.
    CIStream( DWORD dwHandle, const TSurfDBEntry& SurfDBEntry, DWORD dwStride):
        m_dwHandle( dwHandle), m_SurfDBEntry( SurfDBEntry),
        m_dwStride( dwStride), m_eMemLocation( System)
    { }

    EMemLocation GetMemLocation() const
    { return m_eMemLocation; }
    DWORD GetHandle() const
    {
        assert( GetMemLocation()== System|| GetMemLocation()== Video);
        return m_dwHandle;
    }
    DWORD GetStride() const
    {
        assert( GetMemLocation()!= None);
        return m_dwStride;
    }
    const TSurface& GetVidMemRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    TSurface& GetVidMemRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    const TSurfDBEntry& GetSurfDBRepresentation() const
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
    TSurfDBEntry& GetSurfDBRepresentation()
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CStdDP2IStreamManager
//
// This class contains DP2 member functions to correctly process 
// D3DDP2OP_SETINDICES. It can also correctly record a command buffer operation
// for D3DDP2OP_SETINDICES. To do this, however, it must maintain information
// for index streams, or "manage" IStream objects.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TIS: The index stream type which represents data associated with a index
//     stream. This is typically, CIStream<> or something derived from it.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper,
    class TIS= CIStream< TSuper::TPerDDrawData::TDriver::TSurface*, TSuper::TPerDDrawData::TSurfDBEntry*>,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2IStreamManager
{
public: // Types
    typedef TIS TIStream;
    typedef block< TIStream, 1> TIStreamDB;

protected: // Variables
    TIStreamDB m_IStreamDB;

protected: // Functions
    CStdDP2IStreamManager() 
    { }
    ~CStdDP2IStreamManager() 
    { }

public: // Fuctions
    TIStream& GetIStream( TIStreamDB::size_type uiStream)
    { return m_IStreamDB[ uiStream]; }
    const TIStream& GetIStream( TIStreamDB::size_type uiStream) const
    { return m_IStreamDB[ uiStream]; }
    HRESULT DP2SetIndices( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2SETINDICES* pParam=
            reinterpret_cast< const D3DHAL_DP2SETINDICES*>( pP);
        TSuper* pSThis= static_cast<TSuper*>(this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            // For ease of extension in case multiple IStreams are supported
            // later.
            const DWORD dwStream( 0);

            if( dwStream< m_IStreamDB.size())
            {
                if( 0== pParam->dwVBHandle)
                    m_IStreamDB[ dwStream]= TIStream();
                else
                {
                    typename TSuper::TPerDDrawData::TSurfDBEntry* pDBEntry=
                        pSThis->GetPerDDrawData().GetSurfDBEntry(
                        pParam->dwVBHandle);
                    if( pDBEntry!= NULL)
                    {
                        if((pDBEntry->GetLCLddsCaps().dwCaps&
                            DDSCAPS_VIDEOMEMORY)!= 0)
                        {
                            // Assign in a video memory representation.
                            m_IStreamDB[ dwStream]=
                                TIStream( pParam->dwVBHandle, pSThis->
                                GetPerDDrawData().GetDriver().GetSurface(
                                *pDBEntry), pDBEntry, pParam->dwStride);
                        }
                        else
                        {
                            // Assign in a system memory representation.
                            m_IStreamDB[ dwStream]=
                                TIStream( pParam->dwVBHandle,
                                pDBEntry, pParam->dwStride);
                        }
                    }
                    else
                    {
                        // Handle invalid, reset stream.
                        m_IStreamDB[ dwStream]= TIStream();
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetIndices( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETINDICES* pParam=
            reinterpret_cast< D3DHAL_DP2SETINDICES*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            const DWORD dwStream( 0);
            if( dwStream< m_IStreamDB.size())
            {
                const TIStream& IStream( m_IStreamDB[ dwStream]);
                switch( IStream.GetMemLocation())
                {
                case( TIStream::EMemLocation::None): ;
                    pParam->dwVBHandle= 0;
                    pParam->dwStride= 0;
                    break;

                case( TIStream::EMemLocation::System): ;
                case( TIStream::EMemLocation::Video): ;
                    pParam->dwVBHandle= IStream.GetHandle();
                    pParam->dwStride= IStream.GetStride();
                    break;

                default: {
                    const bool Unrecognized_IStream_enum( false);
                    assert( Unrecognized_IStream_enum);
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    void InvalidateAllIStreams()
    {
        fill( m_IStreamDB.begin(), m_IStreamDB.end(), TIStream());
    }
};

class CPalDBEntry
{
protected: // Types
    typedef block< DWORD, 256> TPalEntries;

protected: // Variables
    DWORD m_dwFlags;
    TPalEntries m_PalEntries;

public: // Functions
    CPalDBEntry() : m_dwFlags( 0)
    { fill( m_PalEntries.begin(), m_PalEntries.end(), 0); }
    ~CPalDBEntry() 
    { }
    void SetFlags( DWORD dwFlags) 
    { m_dwFlags= dwFlags; }
    DWORD GetFlags() 
    { return m_dwFlags; }
    DWORD* GetEntries() 
    { return m_PalEntries.begin(); }
    template< class ForwardIterator>
    void Update( TPalEntries::size_type uiStart, ForwardIterator f,
        ForwardIterator l) 
    { copy( f, l, m_PalEntries.begin()+ uiStart); }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TPDBE: This is the palette database entry type, or whatever is associated
//     with a palette. This type is typically, CPalDBEntry or something
//     derived from it.
// TPDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD palette handle to a palette type.
// TSPDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD surface handle to a DWORD palette handle.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TPDBE= CPalDBEntry, class TPDB= map< DWORD, TPDBE>,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2PaletteManager
{
public: // Types
    typedef TPDBE TPalDBEntry;
    typedef TPDB TPalDB;

protected: // Variables
    TPalDB m_PalDB;

protected: // Functions
    CStdDP2PaletteManager() 
    { }
    ~CStdDP2PaletteManager() 
    { }

public: // Functions
    void UpdatePalette( const D3DHAL_DP2UPDATEPALETTE* pParam)
    {
        typename TPalDB::iterator itPal( 
            m_PalDB.find( pParam->dwPaletteHandle));

        if( m_PalDB.end()== itPal)
            itPal= m_PalDB.insert( TPalDB::value_type( pParam->dwPaletteHandle,
                TPalDBEntry())).first;

        const DWORD* pEStart= reinterpret_cast< const DWORD*>( pParam+ 1);
        itPal->second.Update( pParam->wStartIndex, pEStart,
            pEStart+ pParam->wNumEntries);
    }
    void SetPalette( const D3DHAL_DP2SETPALETTE* pParam)
    {
        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef typename TSuper::TPerDDrawData TPerDDrawData;
        typename TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
            pSThis->GetPerDDrawData().GetSurfDBEntry( pParam->dwSurfaceHandle);
        assert( NULL!= pSurfDBEntry);

        if( 0== pParam->dwPaletteHandle)
        {
            // Disassociate the surface with any palette.
            pSurfDBEntry->SetPalette( NULL);
        }
        else
        {
            typename TPalDB::iterator itPal( 
                m_PalDB.find( pParam->dwPaletteHandle));

            if( m_PalDB.end()== itPal)
                itPal= m_PalDB.insert( TPalDB::value_type( pParam->dwPaletteHandle,
                    TPalDBEntry())).first;

            itPal->second.SetFlags( pParam->dwPaletteFlags);
            pSurfDBEntry->SetPalette( &itPal->second);
        }
    }
    HRESULT DP2SetPalette( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETPALETTE* pParam=
            reinterpret_cast<const D3DHAL_DP2SETPALETTE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0) do
            {
                pSThis->SetPalette( pParam);
                ++pParam;
            } while( --wStateCount);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return DD_OK;
    }
    HRESULT DP2UpdatePalette( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2UPDATEPALETTE* pParam=
            reinterpret_cast<const D3DHAL_DP2UPDATEPALETTE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0)
                pSThis->UpdatePalette( pParam);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return DD_OK;
    }
};

class CLightDBEntry:
    public D3DLIGHT8
{
protected: // Variables
    bool m_bEnabled;

public: // Functions
    CLightDBEntry()
        : m_bEnabled( false)
    {
        // Default light settings:
        Type= D3DLIGHT_DIRECTIONAL;
        Diffuse.r= 1.0f; Diffuse.g= 1.0f; Diffuse.b= 1.0f; Diffuse.a= 0.0f;
        Specular.r= 0.0f; Specular.g= 0.0f; Specular.b= 0.0f; Specular.a= 0.0f;
        Ambient.r= 0.0f; Ambient.g= 0.0f; Ambient.b= 0.0f; Ambient.a= 0.0f;
        Position.x= 0.0f; Position.y= 0.0f; Position.z= 0.0f;
        Direction.x= 0.0f; Direction.y= 0.0f; Direction.z= 1.0f;
        Range= 0.0f;
        Falloff= 0.0f;
        Attenuation0= 0.0f;
        Attenuation1= 0.0f;
        Attenuation2= 0.0f;
        Theta= 0.0f;
        Phi= 0.0f;
    }
    operator const D3DLIGHT8&() const
    { return *static_cast< const D3DLIGHT8*>( this); }
    CLightDBEntry& operator=( const D3DLIGHT8& Other)
    {
        *static_cast< D3DLIGHT8*>( this)= Other;
        return *this;
    }
    void SetEnabled( bool bEn)
    { m_bEnabled= bEn; }
    bool GetEnabled() const
    { return m_bEnabled; }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TLDBE: This is the light database entry type, or whatever is associated
//     with a light. This type is typically, CLightDBEntry or something
//     derived from it or convertable to D3DLIGHT8, at least.
// TLDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD light id to a light type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TLDBE= CLightDBEntry,
    class TLDB= map< DWORD, TLDBE>, class TDP2Data= CDP2DataWrap<> >
class CStdDP2LightManager
{
public: // Types
    typedef TLDBE TLightDBEntry;
    typedef TLDB TLightDB;

protected: // Variables
    TLightDB m_LightDB;

protected: // Functions
    CStdDP2LightManager() 
    { }
    ~CStdDP2LightManager() 
    { }

public: // Functions
    void CreateLight( DWORD dwId)
    {
        pair< typename TLightDB::iterator, bool> Ret= m_LightDB.insert( 
            typename TLightDB::value_type( dwId, TLightDBEntry()));
    }
    void EnableLight( DWORD dwId, bool bEnable)
    {
        typename TLightDB::iterator itLight( m_LightDB.find( dwId));
        assert( itLight!= m_LightDB.end());

        itLight->second.SetEnabled( bEnable);
    }
    void UpdateLight( DWORD dwId, const D3DLIGHT8& LightValue)
    {
        typename TLightDB::iterator itLight( m_LightDB.find( dwId));
        assert( itLight!= m_LightDB.end());

        itLight->second= LightValue;
    }
    HRESULT DP2CreateLight( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast< TSuper*>( this);
        const D3DHAL_DP2CREATELIGHT* pParam=
            reinterpret_cast< const D3DHAL_DP2CREATELIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0) do
            {
                pSThis->CreateLight( pParam->dwIndex);
                ++pParam;
            } while( --wStateCount);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return D3D_OK;
    }
    HRESULT DP2SetLight( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast< TSuper*>( this);
        const D3DHAL_DP2SETLIGHT* pParam=
            reinterpret_cast< const D3DHAL_DP2SETLIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0) do
            {
                if( m_LightDB.end()== m_LightDB.find( pParam->dwIndex))
                {
                    const bool SetLight_without_succeeded_CreateLight( false);
                    assert( SetLight_without_succeeded_CreateLight);
                    return DDERR_INVALIDPARAMS;
                }

                bool bEnable( false);
                switch( pParam->dwDataType)
                {
                case( D3DHAL_SETLIGHT_DATA):
                    const D3DLIGHT8* pL= reinterpret_cast< const D3DLIGHT8*>(
                        pParam+ 1);
                    pSThis->UpdateLight( pParam->dwIndex, *pL);
                    pParam= reinterpret_cast< const D3DHAL_DP2SETLIGHT*>(
                        pL+ 1);
                    break;

                case( D3DHAL_SETLIGHT_ENABLE):
                    bEnable= true; // Fall-through.
                case( D3DHAL_SETLIGHT_DISABLE):
                    pSThis->EnableLight( pParam->dwIndex, bEnable);
                    ++pParam;
                    break;

                default: {
                        const bool Unrecognized_D3DHAL_SETLIGHT_data_type( false);
                        assert( Unrecognized_D3DHAL_SETLIGHT_data_type);
                        return DDERR_INVALIDPARAMS;
                    }
                }
            } while( --wStateCount);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return D3D_OK;
    }
    HRESULT RecDP2CreateLight( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2CREATELIGHT* pParam=
            reinterpret_cast< D3DHAL_DP2CREATELIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        // Special case here, the default state set capturing, will ask how
        // many active lights are needed to be recorded, and their id's. In
        // order to support the default state set, we must process this
        // specially.
        if( 0== pCmd->bCommand)
        {
            // Now, we're either being asked how many lights or what their
            // id's are.
            if( 0== wStateCount)
                pParam->dwIndex= m_LightDB.size();
            else
            {
                assert( m_LightDB.size()== wStateCount);
                typename TLightDB::const_iterator itCur( m_LightDB.begin());
                do
                {
                    pParam->dwIndex= itCur.first;
                    ++pParam;
                    ++itCur;
                } while( --wStateCount!= 0);
            }
            return D3D_OK;
        }

        // Otherwise, recording creation is easy,
        // leave the command buffer as is.
        return D3D_OK;
    }
    HRESULT RecDP2SetLight( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETLIGHT* pParam=
            reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        const typename TLightDB::const_iterator itEnd( m_LightDB.end());
        typename TLightDB::const_iterator itLight( itEnd);
        if( wStateCount!= 0) do
        {
            if( itLight!= itEnd&& itLight->first!= pParam->dwIndex)
                itLight= m_LightDB.find( pParam->dwIndex);
            assert( itLight!= itEnd);

            switch( pParam->dwDataType)
            {
            case( D3DHAL_SETLIGHT_DATA):
                D3DLIGHT8* pL= reinterpret_cast< D3DLIGHT8*>( pParam+ 1);
                *pL= itLight->second;
                pParam= reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pL+ 1);
                break;

            case( D3DHAL_SETLIGHT_ENABLE):
            case( D3DHAL_SETLIGHT_DISABLE):
                pParam->dwDataType= ( itLight->second.GetEnabled()? 
                    D3DHAL_SETLIGHT_ENABLE: D3DHAL_SETLIGHT_DISABLE);
                ++pParam;
                break;

            default: {
                    const bool Unrecognized_D3DHAL_SETLIGHT_data_type( false);
                    assert( Unrecognized_D3DHAL_SETLIGHT_data_type);
                    return DDERR_INVALIDPARAMS;
                }
            }
        } while( --wStateCount!= 0);

        return D3D_OK;
    }
};

template< class TS, class TSDBE>
class CRTarget
{
public: // Types
    typedef TS TSurface;
    typedef TSDBE TSurfDBEntry;
    enum EMemLocation
    {
        None,
        Video
    };

protected: // Variables
    DWORD m_dwHandle;
    TSurface m_Surface;
    TSurfDBEntry m_SurfDBEntry;
    EMemLocation m_eMemLocation;

public: // Functions
    CRTarget(): m_eMemLocation( None)
    { }
    // Video Memory representation constructor.
    CRTarget( DWORD dwHandle, const TSurface& Surface,
        const TSurfDBEntry& SurfDBEntry): m_dwHandle( dwHandle),
        m_Surface( Surface), m_SurfDBEntry( SurfDBEntry), m_eMemLocation( Video)
    { }
    ~CRTarget()
    { }

    bool operator==( const CRTarget& Other) const
    {
        const EMemLocation MemLocation( GetMemLocation());
        return MemLocation== Other.GetMemLocation()&&
            (None== MemLocation|| GetHandle()== Other.GetHandle());
    }
    bool operator!=( const CRTarget& Other) const
    { return !(*this== Other); }

    DWORD GetHandle() const
    {
        assert( GetMemLocation()!= None);
        return m_dwHandle;
    }
    TSurface& GetVidMemRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    const TSurface& GetVidMemRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    TSurfDBEntry& GetSurfDBRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_SurfDBEntry;
    }
    const TSurfDBEntry& GetSurfDBRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_SurfDBEntry;
    }
    EMemLocation GetMemLocation() const
    { return m_eMemLocation; }
    void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& Rect)
    {
        if( GetMemLocation()!= None)
            GetVidMemRepresentation()->Clear( DP2Clear, Rect);
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSubContext
//
// This provides a base implementation for a context. It provides
// implementations for dealing with the SetRenderTarget and Clear
// DrawPrimitive2 commands; and also a minimal implementation for
// GetDriverState.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TPDDD: The PerDDrawData type, typically CMyPerDDrawData or
//     CMinimalPerDDrawData<>.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
// <Exposed Types>
// TPerDDrawData: The PerDDrawData type, passed in as the template parameter,
//     TPDDD.
// TDriver: This is equal to TPerDDrawData::TDriver. This type is exposed
//     only as a convience to the implementation to get at TDriver::TSurface.
// TSurface: This is equal to TDriver::TSurface. This type is exposed only
//     as a convience to the implementation.
//
// <Exposed Functions>
// CSubContext( TPerDDrawData&, TSurface*, TSurface*, DWORD): Constructor,
//     a typical SDDI Context isnt' expected to be created without this data.
// ~CSubContext(): Standard destructor.
// TPerDDrawData& GetPerDDrawData() const: Trivial accessor function to get at
//     the PerDDrawData.
// TSurface* GetRTarget() const: Trivial accessor function to get at the
//     current render target.
// TSurface* GetZBuffer() const: Trivial accessor function to get at the
//     current z/ stencil buffer.
// HRESULT DP2SetRenderTarget( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*):
//     The default DP2 command processing member function for
//     D3DDP2OP_SETRENDERTARGET.
// void NewRenderTarget( TSurface*, TSurface*) const: Notification mechanism
//     called just before new render targets are saved into the member
//     variables. This notification mechanism is called by DP2SetRenderTarget.
// HRESULT DP2Clear( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*):
//     The default DP2 command processing member function for D3DDP2OP_CLEAR.
//     This function relies on TSurface having a member function Clear.
// HRESULT GetDriverState( DDHAL_GETDRIVERSTATEDATA&): A minimal implementation
//     of GetDriverState, which should return S_FALSE if the id isn't
//     understood. This function should be overriden to add understanding for
//     custom ids.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper, class TPDDD,
    class TRT= CRTarget< TPDDD::TDriver::TSurface*, TPDDD::TSurfDBEntry*>,
    class TDP2Data= CDP2DataWrap<> >
class CSubContext
{
public: // Types
    typedef TPDDD TPerDDrawData;
    typedef TRT TRTarget;

protected: // Variables
    TPerDDrawData& m_PerDDrawData;
    TRTarget m_ColorBuffer;
    TRTarget m_DepthBuffer;

protected: // Functions
    void NewColorBuffer() const 
    {
        // Override this notification mechanism to provide color buffer
        // state managing.
    }
    void NewDepthBuffer() const
    {
        // Override this notification mechanism to provide depth buffer
        // state managing.
    }

    CSubContext( TPerDDrawData& PerDDrawData, PORTABLE_CONTEXTCREATEDATA& ccd):
        m_PerDDrawData( PerDDrawData)
    {
        // To set the render targets, we must convert the structures to our
        // SurfDBEntry representation.
        typename TPerDDrawData::TDriver& Driver= PerDDrawData.GetDriver();

        if( ccd.lpDDSLcl()!= NULL)
        {
            typename TPerDDrawData::TDriver::TSurface* pSurface=
                Driver.GetSurface( *ccd.lpDDSLcl());
            if( pSurface!= NULL)
            {
                const DWORD dwHandle(
                    ccd.lpDDSLcl()->lpSurfMore()->dwSurfaceHandle());

                m_ColorBuffer= TRTarget( dwHandle, pSurface,
                    PerDDrawData.GetSurfDBEntry( dwHandle));
            }
        }
        if( ccd.lpDDSZLcl()!= NULL)
        {
            typename TPerDDrawData::TDriver::TSurface* pSurface=
                Driver.GetSurface( *ccd.lpDDSZLcl());
            if( pSurface!= NULL)
            {
                const DWORD dwHandle(
                    ccd.lpDDSZLcl()->lpSurfMore()->dwSurfaceHandle());

                m_DepthBuffer= TRTarget( dwHandle, pSurface,
                    PerDDrawData.GetSurfDBEntry( dwHandle));
            }
        }
    }
    ~CSubContext() 
    { }

public: // Functions
    TPerDDrawData& GetPerDDrawData() const  { return m_PerDDrawData; }
    const TRTarget& GetColorBuffer() const { return m_ColorBuffer; }
    TRTarget& GetColorBuffer() { return m_ColorBuffer; }
    const TRTarget& GetDepthBuffer() const { return m_DepthBuffer; }
    TRTarget& GetDepthBuffer() { return m_DepthBuffer; }

    HRESULT DP2SetRenderTarget( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND*
        pCmd, const void* pP) 
    {
        const D3DHAL_DP2SETRENDERTARGET* pParam=
            reinterpret_cast< const D3DHAL_DP2SETRENDERTARGET*>( pP);
        TSuper* pSThis= static_cast< TSuper*>( this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0)
        {
            TPerDDrawData& PerDDrawData= GetPerDDrawData();
            typename TPerDDrawData::TDriver& Driver= PerDDrawData.GetDriver();

            do
            {
                // To set the render targets, we must convert the handles to our
                // SurfDBEntry representation.
                typename TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                    PerDDrawData.GetSurfDBEntry( pParam->hRenderTarget);
                if( pSurfDBEntry!= NULL)
                {
                    // We can immediately convert the SurfDBEntry representation to our
                    // Video Memory object, because Render Targets MUST be VM.
                    typename TPerDDrawData::TDriver::TSurface* pSurface=
                        Driver.GetSurface( *pSurfDBEntry);
                    if( pSurface!= NULL)
                    {
                        m_ColorBuffer= TRTarget( pParam->hRenderTarget,
                            pSurface, pSurfDBEntry);
                        pSThis->NewColorBuffer();
                    }
                }

                pSurfDBEntry= PerDDrawData.GetSurfDBEntry( pParam->hZBuffer);
                if( pSurfDBEntry!= NULL)
                {
                    // We can immediately convert the SurfDBEntry representation to our
                    // Video Memory object, because Render Targets MUST be VM.
                    typename TPerDDrawData::TDriver::TSurface* pSurface=
                        Driver.GetSurface( *pSurfDBEntry);
                    if( pSurface!= NULL)
                    {
                        m_DepthBuffer= TRTarget( pParam->hZBuffer,
                            pSurface, pSurfDBEntry);
                        pSThis->NewDepthBuffer();
                    }
                }
            } while( --wStateCount!= 0);
        }
        return DD_OK;
    }
    HRESULT DP2Clear( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2CLEAR* pParam= reinterpret_cast< const D3DHAL_DP2CLEAR*>
            ( pP);

        TSuper* pSThis= static_cast< TSuper*>( this);
        const D3DHAL_DP2VIEWPORTINFO CurViewport( *pSThis);
        RECT ViewportRect;
        ViewportRect.left= CurViewport.dwX;
        ViewportRect.top= CurViewport.dwY;
        ViewportRect.right= CurViewport.dwX+ CurViewport.dwWidth;
        ViewportRect.bottom= CurViewport.dwY+ CurViewport.dwHeight;

        TRTarget& ColorBuffer= GetColorBuffer();
        TRTarget& DepthBuffer= GetDepthBuffer();
        const bool bClearBoth(!(ColorBuffer== DepthBuffer));

        if( 0== pCmd->wStateCount)
        {
            if( TRTarget::EMemLocation::None!= ColorBuffer.GetMemLocation())
                ColorBuffer.Clear( *pParam, ViewportRect);
            if( TRTarget::EMemLocation::None!= DepthBuffer.GetMemLocation()&&
                bClearBoth)
                DepthBuffer.Clear( *pParam, ViewportRect);
        }
        else
        {
            WORD wStateCount( pCmd->wStateCount);
            const RECT* pRect= pParam->Rects;

            if((pParam->dwFlags& D3DCLEAR_COMPUTERECTS)!= 0)
            {
                // Clip rect to viewport.
                RECT rcClipped( *pRect);
                do
                {
                    clamp_min( rcClipped.left, ViewportRect.left);
                    clamp_min( rcClipped.top, ViewportRect.top);
                    clamp( rcClipped.right, rcClipped.left, ViewportRect.right);
                    clamp( rcClipped.bottom, rcClipped.top, ViewportRect.bottom);

                    if( TRTarget::EMemLocation::None!=
                        ColorBuffer.GetMemLocation())
                        ColorBuffer.Clear( *pParam, rcClipped);
                    if( TRTarget::EMemLocation::None!=
                        DepthBuffer.GetMemLocation()&& bClearBoth)
                        DepthBuffer.Clear( *pParam, rcClipped);
                    pRect++;
                } while( --wStateCount);
            }
            else
            {
                do
                {
                    if( TRTarget::EMemLocation::None!=
                        ColorBuffer.GetMemLocation())
                        ColorBuffer.Clear( *pParam, *pRect);
                    if( TRTarget::EMemLocation::None!=
                        DepthBuffer.GetMemLocation()&& bClearBoth)
                        DepthBuffer.Clear( *pParam, *pRect);
                    pRect++;
                }  while( --wStateCount);
            }
        }
        return DD_OK;
    }

    // A minimal implementation of GetDriverState, which should return S_FALSE
    // if the id isn't understood. Override this function to add understanding.
    HRESULT GetDriverState( DDHAL_GETDRIVERSTATEDATA& gdsd)
    { return S_FALSE; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CMinimalContext
//
// This class contains a minimal implementation of a Context for a driver,
// which supports only one stream, no TnL, and legacy pixel shading. This
// Context still needs an implementation of the primitive drawing functions,
// which it uses a Rasterizer class for. CMinimalContext takes care of most
// of the responsibilities of a SDDI driver, except rasterization. 
//
// <Template Parameters>
// TPDDD: The PerDDrawData type, typically CMyPerDDrawData or
//     CMinimalPerDDrawData<>.
// TR: The Rasterizer type, typically CMyRasterizer.
//
////////////////////////////////////////////////////////////////////////////////
template< class TPDDD, class TR>
class CMinimalContext:
    public CSubContext< CMinimalContext< TPDDD, TR>, TPDDD>,
    public CStdDrawPrimitives2< CMinimalContext< TPDDD, TR> >,
    public CStdDP2ViewportInfoStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2WInfoStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2RenderStateStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2TextureStageStateStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2SetVertexShaderStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2VStreamManager< CMinimalContext< TPDDD, TR> >,
    public CStdDP2IStreamManager< CMinimalContext< TPDDD, TR> >
{
public: // Types
    typedef TPDDD TPerDDrawData;
    typedef TR TRasterizer;
    typedef block< TDP2CmdBind, 15> TDP2Bindings;
    typedef block< TRecDP2CmdBind, 7> TRecDP2Bindings;

protected: // Variables
    TRasterizer m_Rasterizer;
    static const TDP2Bindings c_DP2Bindings;
    static const TRecDP2Bindings c_RecDP2Bindings;

public: // Functions
    CMinimalContext( TPerDDrawData& PDDD, PORTABLE_CONTEXTCREATEDATA& ccd)
        : CSubContext< CMinimalContext< TPDDD, TR>, TPDDD>( PDDD, ccd),
        CStdDrawPrimitives2< CMinimalContext< TPDDD, TR>>(
            c_DP2Bindings.begin(), c_DP2Bindings.end(),
            c_RecDP2Bindings.begin(), c_RecDP2Bindings.end())
    {
        // These keep the arrays in sync with their typedef.
        assert( D3DDP2OP_CLIPPEDTRIANGLEFAN== *c_DP2Bindings.rbegin());
        assert( D3DDP2OP_SETINDICES== *c_RecDP2Bindings.rbegin());
    }
    ~CMinimalContext()  { }

    // Provide this function to ease minimal implementations.
    HRESULT ValidateTextureStageState( const D3DHAL_VALIDATETEXTURESTAGESTATEDATA&
        vsssd) const
    { return DD_OK; }

    HRESULT DP2DrawPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE*>(pP);
        return m_Rasterizer.DrawPrimitive( *this, *pCmd, pParam);
    }
    HRESULT DP2DrawPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE2*>(pP);
        return m_Rasterizer.DrawPrimitive2( *this, *pCmd, pParam);
    }
    HRESULT DP2DrawIndexedPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE*>(pP);
        return m_Rasterizer.DrawIndexedPrimitive( *this, *pCmd, pParam);
    }
    HRESULT DP2DrawIndexedPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2*>(pP);
        return m_Rasterizer.DrawIndexedPrimitive2( *this, *pCmd, pParam);
    }
    HRESULT DP2ClippedTriangleFan( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_CLIPPEDTRIANGLEFAN* pParam= reinterpret_cast<
            const D3DHAL_CLIPPEDTRIANGLEFAN*>(pP);
        return m_Rasterizer.ClippedTriangleFan( *this, *pCmd, pParam);
    }
};

// These tables require TConstDP2Bindings to be changed also, with the number
// of bindings.
template< class TPDDD, class TR>
const CMinimalContext< TPDDD, TR>::TDP2Bindings
    CMinimalContext< TPDDD, TR>::c_DP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          DP2ViewportInfo,
    D3DDP2OP_WINFO,                 DP2WInfo,
    D3DDP2OP_RENDERSTATE,           DP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     DP2TextureStageState,
    D3DDP2OP_CLEAR,                 DP2Clear,
    D3DDP2OP_SETRENDERTARGET,       DP2SetRenderTarget,
    D3DDP2OP_SETVERTEXSHADER,       DP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       DP2SetStreamSource,
    D3DDP2OP_SETSTREAMSOURCEUM,     DP2SetStreamSourceUM,
    D3DDP2OP_SETINDICES,            DP2SetIndices,
    D3DDP2OP_DRAWPRIMITIVE,         DP2DrawPrimitive,
    D3DDP2OP_DRAWPRIMITIVE2,        DP2DrawPrimitive2,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE,  DP2DrawIndexedPrimitive,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2, DP2DrawIndexedPrimitive2,
    D3DDP2OP_CLIPPEDTRIANGLEFAN,    DP2ClippedTriangleFan
};

// These tables require TConstRecDP2Bindings to be changed also, with the number
// of bindings.
template< class TPDDD, class TR>
const CMinimalContext< TPDDD, TR>::TRecDP2Bindings
    CMinimalContext< TPDDD, TR>::c_RecDP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          RecDP2ViewportInfo,
    D3DDP2OP_WINFO,                 RecDP2WInfo,
    D3DDP2OP_RENDERSTATE,           RecDP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     RecDP2TextureStageState,
    D3DDP2OP_SETVERTEXSHADER,       RecDP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       RecDP2SetStreamSource,
    D3DDP2OP_SETINDICES,            RecDP2SetIndices
};

class IVidMemSurface
{
protected: // Variables
    DWORD m_dwHandle;

protected: // Functions
    IVidMemSurface( DWORD dwHandle) : m_dwHandle( dwHandle) { }

public: // Functions
    DWORD GetHandle() const 
    { return m_dwHandle; }
    virtual ~IVidMemSurface() 
    { }
    virtual void* Lock( DWORD dwFlags, const RECTL* pRect)= 0;
    virtual void Unlock( void)= 0;
    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC)= 0;
};

struct SD3DDataConv
{
    // A( 0), R( 1), G( 2), B( 3), Z( 4), S( 5)
    typedef block< DWORD, 6> TMasks;
    // A( 0), R( 1), G( 2), B( 3), Z( 4), ZBits( 5), S( 6), SBits( 7)
    typedef block< signed char, 8> TD3DBitShftRgt;
    TMasks m_ToSurfMasks;
    TD3DBitShftRgt m_D3DBitShftRgt;

    SD3DDataConv()
    {
        fill( m_ToSurfMasks.begin(), m_ToSurfMasks.end(),
            static_cast< TMasks::value_type>( 0));
        fill( m_D3DBitShftRgt.begin(), m_D3DBitShftRgt.end(),
            static_cast< TD3DBitShftRgt::value_type>( 0));
    }
    SD3DDataConv( const DDPIXELFORMAT& PF) 
    { (*this)= PF; }
    SD3DDataConv& operator=( const DDPIXELFORMAT& PF) 
    {
        const block< signed char, 4> D3DHighBitPos= {31,23,15,7};

        fill( m_ToSurfMasks.begin(), m_ToSurfMasks.end(),
            static_cast< TMasks::value_type>( 0));
        fill( m_D3DBitShftRgt.begin(), m_D3DBitShftRgt.end(),
            static_cast< TD3DBitShftRgt::value_type>( 0));

        // Alpha
        if((PF.dwFlags& DDPF_ALPHA)!= 0)
        {
            assert( PF.dwAlphaBitDepth< 32);
            m_ToSurfMasks[ 0]= (0x1<< PF.dwAlphaBitDepth)- 1;
        }
        else if((PF.dwFlags& DDPF_ALPHAPIXELS)!= 0)
            m_ToSurfMasks[ 0]= PF.dwRGBAlphaBitMask;

        // RGB Color
        if((PF.dwFlags& DDPF_RGB)!= 0)
        {
            m_ToSurfMasks[ 1]= PF.dwRBitMask;
            m_ToSurfMasks[ 2]= PF.dwGBitMask;
            m_ToSurfMasks[ 3]= PF.dwBBitMask;
        }

        // Z
        if((PF.dwFlags& DDPF_ZBUFFER)!= 0)
        {
            m_D3DBitShftRgt[ 5]= PF.dwZBufferBitDepth;
            if( 32== PF.dwZBufferBitDepth)
                m_ToSurfMasks[ 4]= 0xFFFFFFFF;
            else
                m_ToSurfMasks[ 4]= (0x1<< PF.dwZBufferBitDepth)- 1;
        }
        else if((PF.dwFlags& DDPF_ZPIXELS)!= 0)
        {
            DWORD dwZBitMask( PF.dwRGBZBitMask);
            m_ToSurfMasks[ 5]= PF.dwRGBZBitMask;

            while((dwZBitMask& 1)== 0)
            {
                m_D3DBitShftRgt[ 4]--;
                dwZBitMask>>= 1;
            }

            while((dwZBitMask& 1)!= 0)
            {
                dwZBitMask>>= 1;
                m_D3DBitShftRgt[ 5]++;
            }
        }

        // Stensil
        if((PF.dwFlags& DDPF_STENCILBUFFER)!= 0)
        {
            DWORD dwSBitMask( PF.dwStencilBitMask);
            m_ToSurfMasks[ 6]= PF.dwStencilBitMask;

            while((dwSBitMask& 1)== 0)
            {
                m_D3DBitShftRgt[ 6]--;
                dwSBitMask>>= 1;
            }

            while((dwSBitMask& 1)!= 0)
            {
                dwSBitMask>>= 1;
                m_D3DBitShftRgt[ 7]++;
            }
        }

        block< signed char, 4>::const_iterator itD3DBitPos( D3DHighBitPos.begin());
        TD3DBitShftRgt::iterator itBitShftRgt( m_D3DBitShftRgt.begin());
        TMasks::const_iterator itToSurfMask( m_ToSurfMasks.begin());

        while( itD3DBitPos!= D3DHighBitPos.end())
        {
            signed char iBitPos( 31);
            TMasks::value_type dwMask( 0x80000000);

            while((dwMask& *itToSurfMask)== 0 && iBitPos>= 0)
            {
                dwMask>>= 1;
                iBitPos--;
            }

            *itBitShftRgt= ( iBitPos>= 0? *itD3DBitPos- iBitPos: 0);

            ++itD3DBitPos;
            ++itToSurfMask;
            ++itBitShftRgt;
        }
        return *this;
    }
    // SurfData, ValidMask
    pair< UINT32, UINT32> ConvColor( D3DCOLOR D3DColor) const 
    {
        pair< UINT32, UINT32> RetVal( 0, 0);

        const block< DWORD, 4> FromD3DMasks= {0xFF000000,0xFF0000,0xFF00,0xFF};

        TD3DBitShftRgt::const_iterator itBitShftRgt( m_D3DBitShftRgt.begin());
        block< DWORD, 4>::const_iterator itFromMask( FromD3DMasks.begin());
        TMasks::const_iterator itToMask( m_ToSurfMasks.begin());
        while( itFromMask!= FromD3DMasks.end())
        {
            const UINT32 uiTmp( D3DColor& *itFromMask);
            
            RetVal.first|= *itToMask& (*itBitShftRgt>= 0?
                uiTmp>> *itBitShftRgt: uiTmp<< *itBitShftRgt);
            RetVal.second|= *itToMask;

            ++itBitShftRgt;
            ++itToMask;
            ++itFromMask;
        }
        return RetVal;
    }
    // SurfData, ValidMask
    pair< UINT32, UINT32> ConvZ( D3DVALUE D3DZ) const 
    {
        CEnsureFPUModeForC FPUMode;

        if( D3DZ> 1.0f)
            D3DZ= 1.0f;
        else if( D3DZ< 0.0f)
            D3DZ= 0.0f;

        pair< UINT32, UINT32> RetVal( 0, 0);

        const UINT32 uiMaxZ( m_D3DBitShftRgt[ 5]== 32? 0xFFFFFFFF:
            (0x1<< m_D3DBitShftRgt[ 5])- 1);

        const UINT32 uiZVal( static_cast<UINT32>( 
            static_cast< DOUBLE>(D3DZ)* static_cast< DOUBLE>(uiMaxZ)+ 0.5));

        RetVal.first|= m_ToSurfMasks[ 4]& (m_D3DBitShftRgt[ 4]>= 0?
            uiZVal>> m_D3DBitShftRgt[ 4]: uiZVal<< m_D3DBitShftRgt[ 4]);
        RetVal.second|= m_ToSurfMasks[ 4];
        return RetVal;
    }
    // SurfData, ValidMask
    pair< UINT32, UINT32> ConvS( DWORD D3DStensil) const 
    {
        pair< UINT32, UINT32> RetVal( 0, 0);

        RetVal.first|= m_ToSurfMasks[ 5]& (m_D3DBitShftRgt[ 6]>= 0?
            D3DStensil>> m_D3DBitShftRgt[ 6]: D3DStensil<< m_D3DBitShftRgt[ 6]);
        RetVal.second|= m_ToSurfMasks[ 5];
        return RetVal;
    }
};

class CGenSurface:
    public IVidMemSurface
{
public: // Types
    typedef unsigned int TLocks;

protected: // Variables
    SD3DDataConv m_D3DDataConv;
    DWORD m_dwCaps;
    TLocks m_uiLocks;

    // Regular data
    void* m_pData;
    LONG m_lPitch;
    size_t m_uiBytes;
    WORD m_wWidth;
    WORD m_wHeight;

    unsigned char m_ucBPP;

public: // Functions
    CGenSurface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf)
        :IVidMemSurface( DDSurf.lpSurfMore()->dwSurfaceHandle()),
        m_dwCaps( SDesc.ddsCaps.dwCaps), m_uiLocks( 0), m_pData( NULL),
        m_lPitch( 0), m_uiBytes( 0), m_wWidth( DDSurf.lpGbl()->wWidth),
        m_wHeight( DDSurf.lpGbl()->wHeight), m_ucBPP( 0)
    {
        size_t uiBytesPerPixel( 0);

        // Certain data needs to be written into the DDSurf description,
        // so that the DXG runtime and the app will know characteristics
        // about the surface. (fpVidMem, lPitch, etc.)

        // DO NOT STORE &DDSurf! This is considered illegal. The typical
        // implementation contains a surfaceDB which contains copies of the
        // DDRAWI_ structures.

        if((SDesc.dwFlags& DDSD_PIXELFORMAT)!= 0)
        {
            // CGenSurface can only be used for byte-aligned pixels.
            assert( 8== SDesc.ddpfPixelFormat.dwRGBBitCount ||
                16== SDesc.ddpfPixelFormat.dwRGBBitCount ||
                24== SDesc.ddpfPixelFormat.dwRGBBitCount ||
                32== SDesc.ddpfPixelFormat.dwRGBBitCount);

            m_D3DDataConv= SDesc.ddpfPixelFormat;
            m_ucBPP= static_cast<unsigned char>(
                SDesc.ddpfPixelFormat.dwRGBBitCount>> 3);

            // Align the Pitch/ Width.
            DDSurf.lpGbl()->lPitch= m_lPitch= ((m_ucBPP* m_wWidth+ 7)& ~7);
            m_uiBytes= m_lPitch* m_wHeight;
        }
        else if((m_dwCaps& DDSCAPS_EXECUTEBUFFER)!= 0)
        {
            // Execute buffers are considered linear and byte-sized.
            m_lPitch= DDSurf.lpGbl()->lPitch;
            m_uiBytes= m_lPitch* m_wHeight;
        }
        else
        {
            const bool Unsupported_Surface_In_Allocation_Routine2( false);
            assert( Unsupported_Surface_In_Allocation_Routine2);
        }

        // It would've been nice to have the initial proctection NOACCESS, but
        // it seems the HAL needs to read to the region, initially.
        m_pData= VirtualAlloc( NULL, m_uiBytes, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if( m_pData== NULL)
            throw bad_alloc( "Not enough memory to allocate Surface data");
        DDSurf.lpGbl()->fpVidMem= reinterpret_cast<FLATPTR>(m_pData);
    }
    virtual ~CGenSurface() 
    {
        // Warning: m_uiLocks doesn't have to be 0. The run-time will destroy
        // a surface without un-locking it.
        assert( m_pData!= NULL);
        VirtualFree( m_pData, 0, MEM_DECOMMIT| MEM_RELEASE);
    }
    virtual void* Lock( DWORD dwFlags, const RECTL* pRect) 
    {
        // Typically, m_uiLocks!= 0 equals bad design or bug. But, it is valid.
        // Second Dummy removes vc6 unrefd variable warning.
        numeric_limits< TLocks> Dummy; Dummy;
        assert( Dummy.max()!= m_uiLocks);
        ++m_uiLocks;

        if( pRect!= NULL)
        {
            // If it is either a 1) VB, 2) IB or 3) CB then the rect has a
            // special meaning. rect.top - rect.bottom gives the range of
            // memory desired, because of being linear.
            if((m_dwCaps& DDSCAPS_EXECUTEBUFFER)!= 0)
            {
                return static_cast<void*>( reinterpret_cast<UINT8*>(
                    m_pData)+ pRect->top);
            }
            else
            {
                return static_cast<void*>( reinterpret_cast<UINT8*>(
                    m_pData)+ pRect->top* m_lPitch+ pRect->left* m_ucBPP);
            }
        }
        else
            return m_pData;
    }
    virtual void Unlock( void) 
    {
        assert( 0!= m_uiLocks);
        --m_uiLocks;
    }
    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) 
    {
        // A VB, IB, or CB should never be asked to 'Clear'. Only
        // RenderTargets and ZBuffers, etc.
        assert((m_dwCaps& DDSCAPS_EXECUTEBUFFER)== 0);

        // Check for empty RECT.
        if((RC.left>= RC.right) || (RC.top>= RC.bottom))
            return;

        assert( 1<= m_ucBPP && 4>= m_ucBPP);
        UINT32 ui32BitFill( 0), ui32BitValidMask( 0);
        UINT32 ui32BitSMask( 4== m_ucBPP? 0xFFFFFFFF: (1<< (m_ucBPP* 8))- 1);

        pair< UINT32, UINT32> RetVal;
        if((DP2Clear.dwFlags& D3DCLEAR_TARGET)!= 0)
        {
            RetVal= m_D3DDataConv.ConvColor( DP2Clear.dwFillColor);
            ui32BitFill|= RetVal.first;
            ui32BitValidMask|= RetVal.second;
        }
        if((DP2Clear.dwFlags& D3DCLEAR_ZBUFFER)!= 0)
        {
            RetVal= m_D3DDataConv.ConvZ( DP2Clear.dvFillDepth);
            ui32BitFill|= RetVal.first;
            ui32BitValidMask|= RetVal.second;
        }
        if((DP2Clear.dwFlags& D3DCLEAR_STENCIL)!= 0)
        {
            RetVal= m_D3DDataConv.ConvS( DP2Clear.dwFillStencil);
            ui32BitFill|= RetVal.first;
            ui32BitValidMask|= RetVal.second;
        }

        RECTL RectL;
        RectL.top= RC.top;
        RectL.left= RC.left;
        RectL.bottom= RC.bottom;
        RectL.right= RC.right;
        unsigned int iRow( RC.bottom- RC.top);
        const unsigned int iCols( RC.right- RC.left);

        // New scope for SurfaceLocker.
        { 
            CSurfaceLocker< CGenSurface*> MySLocker( this, 0, &RectL);
            UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

            if( 3== m_ucBPP)
            {
                UINT32 ui32FillData[3];
                ui32FillData[0]= ((ui32BitFill& 0xFFFFFF)<< 8)|
                    ((ui32BitFill& 0xFF0000)>> 16);
                ui32FillData[1]= ((ui32BitFill& 0x00FFFF)<< 16)|
                    ((ui32BitFill& 0xFFFF00)>> 8);
                ui32FillData[2]= ((ui32BitFill& 0x0000FF)<< 24)|
                    ((ui32BitFill& 0xFFFFFF)>> 0);

                // Little-endian implementation.
                UINT8 ui8FillData[3];
                ui8FillData[0]= (0xFF& ui32BitFill);
                ui8FillData[1]= (0xFF00& ui32BitFill)>> 8;
                ui8FillData[2]= (0xFF0000& ui32BitFill)>> 16;

                if( ui32BitSMask== ui32BitValidMask)
                {
                    // Only fill, no need to read, modify, write.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed 4 pixels of data in 3 UINT32.
                        unsigned int iCol( iCols>> 2); // (>> 2) == (/ 4)

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= ui32FillData[0];
                            p32Data[ 1]= ui32FillData[1];
                            p32Data[ 2]= ui32FillData[2];
                            p32Data[ 3]= ui32FillData[0];
                            p32Data[ 4]= ui32FillData[1];
                            p32Data[ 5]= ui32FillData[2];
                            p32Data[ 6]= ui32FillData[0];
                            p32Data[ 7]= ui32FillData[1];
                            p32Data[ 8]= ui32FillData[2];
                            p32Data[ 9]= ui32FillData[0];
                            p32Data[10]= ui32FillData[1];
                            p32Data[11]= ui32FillData[2];
                            p32Data+= 12;
                        } while( --iCol);

                        iCol= iCols& 0x3; // (% 4) == (& 0x3)
                        if( iCol!= 0) {
                            UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                            do
                            {
                                p8Data[0]= ui8FillData[0];
                                p8Data[1]= ui8FillData[1];
                                p8Data[2]= ui8FillData[2];
                                p8Data+= 3;
                            } while( --iCol);
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
                else
                {
                    const UINT32 ui32BitMask= ~ui32BitValidMask;
                    UINT32 ui32MaskData[3];
                    ui32MaskData[0]= ((ui32BitMask& 0xFFFFFF)<< 8)|
                        ((ui32BitMask& 0xFF0000)>> 16);
                    ui32MaskData[1]= ((ui32BitMask& 0x00FFFF)<< 16)|
                        ((ui32BitMask& 0xFFFF00)>> 8);
                    ui32MaskData[2]= ((ui32BitMask& 0x0000FF)<< 24)|
                        ((ui32BitMask& 0xFFFFFF)>> 0);

                    UINT8 ui8MaskData[3];
                    ui8MaskData[0]= (0xFF& ui32BitMask);
                    ui8MaskData[1]= (0xFF00& ui32BitMask)>> 8;
                    ui8MaskData[2]= (0xFF0000& ui32BitMask)>> 16;

                    // Need to mask in the data.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed 4 pixels of data in 3 UINT32.
                        int iCol( iCols>> 2); // (>> 2) == (/ 4)

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= (p32Data[ 0]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[ 1]= (p32Data[ 1]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[ 2]= (p32Data[ 2]& ui32MaskData[2])| ui32FillData[2];
                            p32Data[ 3]= (p32Data[ 3]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[ 4]= (p32Data[ 4]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[ 5]= (p32Data[ 5]& ui32MaskData[2])| ui32FillData[2];
                            p32Data[ 6]= (p32Data[ 6]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[ 7]= (p32Data[ 7]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[ 8]= (p32Data[ 8]& ui32MaskData[2])| ui32FillData[2];
                            p32Data[ 9]= (p32Data[ 9]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[10]= (p32Data[10]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[11]= (p32Data[11]& ui32MaskData[2])| ui32FillData[2];
                            p32Data+= 12;
                        } while( --iCol);

                        iCol= iCols& 0x3; // (% 4) == (& 0x3)
                        if( iCol!= 0) {
                            UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                            do
                            {
                                p8Data[0]= (p8Data[0]& ui8MaskData[0])| ui8FillData[0];
                                p8Data[1]= (p8Data[1]& ui8MaskData[1])| ui8FillData[1];
                                p8Data[2]= (p8Data[2]& ui8MaskData[2])| ui8FillData[2];
                                p8Data+= 3;
                            } while( --iCol);
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
            }
            else
            {
                unsigned int uiPakedPixels;
                unsigned int uiPixelsLeft;
                UINT32 ui32FillData;
                UINT32 ui32MaskData;
                if( 1== m_ucBPP)
                {
                    uiPakedPixels= iCols>> 6;
                    uiPixelsLeft= iCols& 0x3F;
                    ui32FillData= (ui32BitFill& 0xFF)|
                        ((ui32BitFill& 0xFF)<< 8)|
                        ((ui32BitFill& 0xFF)<< 16)|
                        ((ui32BitFill& 0xFF)<< 24);
                    ui32MaskData= (~ui32BitValidMask& 0xFF)|
                        ((~ui32BitValidMask& 0xFF)<< 8)|
                        ((~ui32BitValidMask& 0xFF)<< 16)|
                        ((~ui32BitValidMask& 0xFF)<< 24);
                }
                else if( 2== m_ucBPP)
                {
                    uiPakedPixels= iCols>> 5;
                    uiPixelsLeft= iCols& 0x1F;
                    ui32FillData= (ui32BitFill& 0xFFFF)|
                        ((ui32BitFill& 0xFFFF)<< 16);
                    ui32MaskData= (~ui32BitValidMask& 0xFFFF)|
                        ((~ui32BitValidMask& 0xFFFF)<< 16);
                }
                else if( 4== m_ucBPP)
                {
                    uiPakedPixels= iCols>> 4;
                    uiPixelsLeft= iCols& 0xF;
                    ui32FillData= ui32BitFill;
                    ui32MaskData= ~ui32BitValidMask;
                }

                if( ui32BitSMask== ui32BitValidMask)
                {
                    // Only fill, no need to read, modify, write.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed pixels of data in a UINT32.
                        unsigned int iCol( uiPakedPixels);

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= ui32FillData;
                            p32Data[ 1]= ui32FillData;
                            p32Data[ 2]= ui32FillData;
                            p32Data[ 3]= ui32FillData;
                            p32Data[ 4]= ui32FillData;
                            p32Data[ 5]= ui32FillData;
                            p32Data[ 6]= ui32FillData;
                            p32Data[ 7]= ui32FillData;
                            p32Data[ 8]= ui32FillData;
                            p32Data[ 9]= ui32FillData;
                            p32Data[10]= ui32FillData;
                            p32Data[11]= ui32FillData;
                            p32Data[12]= ui32FillData;
                            p32Data[13]= ui32FillData;
                            p32Data[14]= ui32FillData;
                            p32Data[15]= ui32FillData;
                            p32Data+= 16;
                        } while( --iCol);

                        iCol= uiPixelsLeft;
                        if( iCol!= 0) {
                            if( 1== m_ucBPP)
                            {
                                UINT8 ui8FillData= ui32FillData& 0xFF;
                                UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                                do
                                {
                                    p8Data[0]= ui8FillData;
                                    p8Data++;
                                } while( --iCol);
                            }
                            else if( 2== m_ucBPP)
                            {
                                UINT16 ui16FillData= ui32FillData& 0xFFFF;
                                UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
                                do
                                {
                                    p16Data[0]= ui16FillData;
                                    p16Data++;
                                } while( --iCol);
                            }
                            else if( 4== m_ucBPP)
                            {
                                do
                                {
                                    p32Data[0]= ui32FillData;
                                    p32Data++;
                                } while( --iCol);
                            }
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
                else
                {
                    // Need to mask in the data.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed pixels of data in a UINT32.
                        unsigned int iCol( uiPakedPixels);

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= (p32Data[ 0]& ui32MaskData)| ui32FillData;
                            p32Data[ 1]= (p32Data[ 1]& ui32MaskData)| ui32FillData;
                            p32Data[ 2]= (p32Data[ 2]& ui32MaskData)| ui32FillData;
                            p32Data[ 3]= (p32Data[ 3]& ui32MaskData)| ui32FillData;
                            p32Data[ 4]= (p32Data[ 4]& ui32MaskData)| ui32FillData;
                            p32Data[ 5]= (p32Data[ 5]& ui32MaskData)| ui32FillData;
                            p32Data[ 6]= (p32Data[ 6]& ui32MaskData)| ui32FillData;
                            p32Data[ 7]= (p32Data[ 7]& ui32MaskData)| ui32FillData;
                            p32Data[ 8]= (p32Data[ 8]& ui32MaskData)| ui32FillData;
                            p32Data[ 9]= (p32Data[ 9]& ui32MaskData)| ui32FillData;
                            p32Data[10]= (p32Data[10]& ui32MaskData)| ui32FillData;
                            p32Data[11]= (p32Data[11]& ui32MaskData)| ui32FillData;
                            p32Data[12]= (p32Data[12]& ui32MaskData)| ui32FillData;
                            p32Data[13]= (p32Data[13]& ui32MaskData)| ui32FillData;
                            p32Data[14]= (p32Data[14]& ui32MaskData)| ui32FillData;
                            p32Data[15]= (p32Data[15]& ui32MaskData)| ui32FillData;
                            p32Data+= 16;
                        } while( --iCol);

                        iCol= uiPixelsLeft;
                        if( iCol!= 0) {
                            if( 1== m_ucBPP)
                            {
                                UINT8 ui8FillData= ui32FillData& 0xFF;
                                UINT8 ui8MaskData= ui32MaskData& 0xFF;
                                UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                                do
                                {
                                    p8Data[0]= (p8Data[0]& ui8MaskData)| ui8FillData;
                                    p8Data++;
                                } while( --iCol);
                            }
                            else if( 2== m_ucBPP)
                            {
                                UINT16 ui16FillData= ui32FillData& 0xFFFF;
                                UINT16 ui16MaskData= ui32MaskData& 0xFFFF;
                                UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
                                do
                                {
                                    p16Data[0]= (p16Data[0]& ui16MaskData)| ui16FillData;
                                    p16Data++;
                                } while( --iCol);
                            }
                            else if( 4== m_ucBPP)
                            {
                                do
                                {
                                    p32Data[0]= (p32Data[0]& ui32MaskData)| ui32FillData;
                                    p32Data++;
                                } while( --iCol);
                            }
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
            }
        }
    }

    static IVidMemSurface* CreateSurf( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    {
        return new CGenSurface( SDesc, DDSurf);
    }
};

struct SPixelFormat: public DDPIXELFORMAT
{
    SPixelFormat( D3DFORMAT D3DFmt) 
    {
        ZeroMemory( static_cast< DDPIXELFORMAT*>(this),
            sizeof(DDPIXELFORMAT));
        dwSize= sizeof(DDPIXELFORMAT);

        // Convert away
        if( HIWORD( static_cast< DWORD>(D3DFmt))!= 0)
        {
            dwFlags= DDPF_FOURCC;
            dwFourCC= static_cast< DWORD>(D3DFmt);
        }
        else switch( D3DFmt)
        {
        case( D3DFMT_R8G8B8):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00ff0000;
            dwGBitMask        = 0x0000ff00;
            dwBBitMask        = 0x000000ff;
            dwRGBBitCount     = 24;
            break;

        case( D3DFMT_A8R8G8B8):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0xFF000000;
            dwRBitMask        = 0x00ff0000;
            dwGBitMask        = 0x0000ff00;
            dwBBitMask        = 0x000000ff;
            dwRGBBitCount     = 32;
            break;

        case( D3DFMT_X8R8G8B8):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00ff0000;
            dwGBitMask        = 0x0000ff00;
            dwBBitMask        = 0x000000ff;
            dwRGBBitCount     = 32;
            break;

        case( D3DFMT_R5G6B5):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x0000f800;
            dwGBitMask        = 0x000007e0;
            dwBBitMask        = 0x0000001f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_X1R5G5B5):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00007c00;
            dwGBitMask        = 0x000003e0;
            dwBBitMask        = 0x0000001f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_A1R5G5B5):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0x00008000;
            dwRBitMask        = 0x00007c00;
            dwGBitMask        = 0x000003e0;
            dwBBitMask        = 0x0000001f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_A4R4G4B4):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0x0000f000;
            dwRBitMask        = 0x00000f00;
            dwGBitMask        = 0x000000f0;
            dwBBitMask        = 0x0000000f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_X4R4G4B4):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00000f00;
            dwGBitMask        = 0x000000f0;
            dwBBitMask        = 0x0000000f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_R3G3B2):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x000000e0;
            dwGBitMask        = 0x0000001c;
            dwBBitMask        = 0x00000003;
            dwRGBBitCount     = 8;
            break;

        case( D3DFMT_A8R3G3B2):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0x0000FF00;
            dwRBitMask        = 0x000000e0;
            dwGBitMask        = 0x0000001c;
            dwBBitMask        = 0x00000003;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_A8P8):
            dwFlags            = DDPF_RGB| DDPF_ALPHAPIXELS| DDPF_PALETTEINDEXED8;
            dwRGBAlphaBitMask  = 0x0000FF00;
            dwRGBBitCount      = 16;
            break;

        case( D3DFMT_P8):
            dwFlags            = DDPF_RGB| DDPF_PALETTEINDEXED8;
            dwRGBBitCount      = 8;
            break;

        case( D3DFMT_L8):
            dwFlags             = DDPF_LUMINANCE;
            dwLuminanceBitMask  = 0x000000FF;
            dwLuminanceBitCount = 8;
            break;

        case( D3DFMT_A8L8):
            dwFlags                 = DDPF_LUMINANCE| DDPF_ALPHAPIXELS;
            dwLuminanceAlphaBitMask = 0x0000FF00;
            dwLuminanceBitMask      = 0x000000FF;
            dwLuminanceBitCount     = 16;
            break;

        case( D3DFMT_A4L4):
            dwFlags                 = DDPF_LUMINANCE| DDPF_ALPHAPIXELS;
            dwLuminanceAlphaBitMask = 0x000000F0;
            dwLuminanceBitMask      = 0x0000000F;
            dwLuminanceBitCount     = 8;
            break;

        case( D3DFMT_V8U8):
            dwFlags                = DDPF_BUMPDUDV;
            dwBumpDvBitMask        = 0x0000FF00;
            dwBumpDuBitMask        = 0x000000FF;
            dwBumpBitCount         = 16;
            break;

        case( D3DFMT_L6V5U5):
            dwFlags                = DDPF_BUMPDUDV| DDPF_BUMPLUMINANCE;
            dwBumpLuminanceBitMask = 0x0000FC00;
            dwBumpDvBitMask        = 0x000003E0;
            dwBumpDuBitMask        = 0x0000001F;
            dwBumpBitCount         = 16;
            break;

        case( D3DFMT_X8L8V8U8):
            dwFlags                = DDPF_BUMPDUDV| DDPF_BUMPLUMINANCE;
            dwBumpLuminanceBitMask = 0x00FF0000;
            dwBumpDvBitMask        = 0x0000FF00;
            dwBumpDuBitMask        = 0x000000FF;
            dwBumpBitCount         = 32;
            break;

        case( D3DFMT_A8):
            dwFlags                = DDPF_ALPHA;
            dwAlphaBitDepth        = 8;
            break;

        case( D3DFMT_D16):
        case( D3DFMT_D16_LOCKABLE):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 16;
            dwZBitMask             = 0xFFFF;
            break;

        case( D3DFMT_D32):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFFFF;
            break;

        case( D3DFMT_D15S1):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 16;
            dwZBitMask             = 0xFFFE;
            dwStencilBitDepth      = 1;
            dwStencilBitMask       = 0x0001;
            break;

        case( D3DFMT_D24S8):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFF00;
            dwStencilBitDepth      = 8;
            dwStencilBitMask       = 0xFF;
            break;

        case( D3DFMT_S1D15):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 16;
            dwZBitMask             = 0x7FFF;
            dwStencilBitDepth      = 1;
            dwStencilBitMask       = 0x8000;
            break;

        case( D3DFMT_S8D24):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0x00FFFFFF;
            dwStencilBitDepth      = 8;
            dwStencilBitMask       = 0xFF000000;
            break;

        case( D3DFMT_X8D24):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0x00FFFFFF;
            break;

        case( D3DFMT_D24X8):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFF00;
            break;

        case( D3DFMT_D24X4S4):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFF00;
            dwStencilBitDepth      = 4;
            dwStencilBitMask       = 0x0000000F;
            break;

        case( D3DFMT_X4S4D24):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0x00FFFFFF;
            dwStencilBitDepth      = 4;
            dwStencilBitMask       = 0x0F000000;
            break;

        default:
            const bool Unrecognized_D3DFmt( false);
            assert( Unrecognized_D3DFmt);
            dwFlags= DDPF_FOURCC;
            dwFourCC= static_cast< DWORD>(D3DFmt);
            break;
        }
    }
};

struct SMatchSDesc:
    public unary_function< const DDSURFACEDESC&, bool>
{
    const DDSURFACEDESC& m_SDesc;

    SMatchSDesc( const DDSURFACEDESC& SDesc) : m_SDesc( SDesc) { }

    result_type operator()( argument_type Arg) const 
    {
        if((Arg.dwFlags& DDSD_CAPS)!= 0&& ((m_SDesc.dwFlags& DDSD_CAPS)== 0 ||
            (m_SDesc.ddsCaps.dwCaps& Arg.ddsCaps.dwCaps)!= Arg.ddsCaps.dwCaps))
                return false;
        if((Arg.dwFlags& DDSD_PIXELFORMAT)!= 0&&
            ((m_SDesc.dwFlags& DDSD_PIXELFORMAT)== 0 ||
            m_SDesc.ddpfPixelFormat.dwFlags!= Arg.ddpfPixelFormat.dwFlags ||
            m_SDesc.ddpfPixelFormat.dwFourCC!= Arg.ddpfPixelFormat.dwFourCC ||
            m_SDesc.ddpfPixelFormat.dwRGBBitCount!= Arg.ddpfPixelFormat.dwRGBBitCount ||
            m_SDesc.ddpfPixelFormat.dwRBitMask!= Arg.ddpfPixelFormat.dwRBitMask ||
            m_SDesc.ddpfPixelFormat.dwGBitMask!= Arg.ddpfPixelFormat.dwGBitMask ||
            m_SDesc.ddpfPixelFormat.dwBBitMask!= Arg.ddpfPixelFormat.dwBBitMask ||
            m_SDesc.ddpfPixelFormat.dwRGBZBitMask!= Arg.ddpfPixelFormat.dwRGBZBitMask))
                return false;

        return true;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSurfaceAllocator
//
////////////////////////////////////////////////////////////////////////////////
template< class TMatchFn= SMatchSDesc>
class CIVidMemAllocator
{
public: // Types
    typedef IVidMemSurface TSurface;
    typedef TSurface* (*TCreateSurfFn)( const DDSURFACEDESC&,
        PORTABLE_DDRAWSURFACE_LCL&);
    typedef vector< pair< DDSURFACEDESC, TCreateSurfFn> > TCreateSurfFns;

protected: // Types
    TCreateSurfFns m_CreateSurfFns;
    struct SAdaptedMatchFn: public TMatchFn
    {
        typedef typename TCreateSurfFns::value_type argument_type;
        using typename TMatchFn::result_type;

        SAdaptedMatchFn( const DDSURFACEDESC& SDesc) : TMatchFn( SDesc) {}

        result_type operator()( argument_type Arg) const 
        { return (*static_cast< const TMatchFn*>(this))( Arg.first); }
    };

public: // Functions
    CIVidMemAllocator()  { }
    template< class TIter>
    CIVidMemAllocator( TIter itStart, const TIter itEnd)
    {
        while( itStart!= itEnd)
        {
            m_CreateSurfFns.push_back(
                typename TCreateSurfFns::value_type( *itStart, *itStart));
            itStart++;
        }
    }
    ~CIVidMemAllocator()  { }

    TSurface* CreateSurf( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& Surf) const
    {
        if( m_CreateSurfFns.empty())
            return new CGenSurface( SDesc, Surf);

        typename TCreateSurfFns::const_iterator itFound( 
            find_if( m_CreateSurfFns.begin(), m_CreateSurfFns.end(),
            SAdaptedMatchFn( SDesc) ) );

        if( itFound!= m_CreateSurfFns.end())
            return (itFound->second)( SDesc, Surf);

        // Warning, no specifications matched. If creation functions were
        // provided, there should also be a "default" specification or
        // DDSURFACEDESC with empty flags?, in order to "match rest".
        const bool No_Default_CreateSurface_Function_Found( false);
        assert( No_Default_CreateSurface_Function_Found);
        return new CGenSurface( SDesc, Surf);
    }

};

////////////////////////////////////////////////////////////////////////////////
//
// CPerDDrawData
//
////////////////////////////////////////////////////////////////////////////////
template< class THV= vector< DWORD> >
class CSurfDBEntry
{
public: // Types
    typedef THV THandleVector;

protected: // Variables
    DWORD m_LCLdwFlags;
    DDSCAPS m_LCLddsCaps;
    DWORD m_LCLdwBackBufferCount;
    DWORD m_MOREdwMipMapCount;
    DDSCAPSEX m_MOREddsCapsEx;
    DWORD m_MOREdwSurfaceHandle;
    DWORD m_MOREdwFVF;
    DWORD m_GBLdwGlobalFlags;
    ULONG_PTR m_GBLfpVidMem;
    LONG m_GBLlPitch;
    WORD m_GBLwHeight;
    WORD m_GBLwWidth;
    ULONG_PTR m_GBLdwReserved1;
    DDPIXELFORMAT m_GBLddpfSurface;
    THandleVector m_AttachedTo;
    THandleVector m_AttachedFrom;

public: // Functions
    CSurfDBEntry()  { }
    explicit CSurfDBEntry( PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    { 
        try{
            (*this)= DDSurf;
        } catch( ... ) {
            m_AttachedTo.clear();
            m_AttachedFrom.clear();
            throw;
        }
    }
    ~CSurfDBEntry()  { }
    CSurfDBEntry< THV>& operator=( PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    {
        // DO NOT STORE &DDSurf. This is considered illegal.
        m_LCLdwFlags= DDSurf.dwFlags();
        m_LCLddsCaps= DDSurf.ddsCaps();
        m_LCLdwBackBufferCount= DDSurf.dwBackBufferCount();
        m_MOREdwMipMapCount= DDSurf.lpSurfMore()->dwMipMapCount();
        m_MOREddsCapsEx= DDSurf.lpSurfMore()->ddsCapsEx();
        m_MOREdwSurfaceHandle= DDSurf.lpSurfMore()->dwSurfaceHandle();
        m_MOREdwFVF= DDSurf.lpSurfMore()->dwFVF();
        m_GBLdwGlobalFlags= DDSurf.lpGbl()->dwGlobalFlags;
        m_GBLfpVidMem= DDSurf.lpGbl()->fpVidMem;
        m_GBLlPitch= DDSurf.lpGbl()->lPitch;
        m_GBLwHeight= DDSurf.lpGbl()->wHeight;
        m_GBLwWidth= DDSurf.lpGbl()->wWidth;
        m_GBLdwReserved1= DDSurf.lpGbl()->dwReserved1;
        m_GBLddpfSurface= DDSurf.lpGbl()->ddpfSurface;
 
        const DWORD dwMyHandle( DDSurf.lpSurfMore()->dwSurfaceHandle());
        m_AttachedTo.clear();
        m_AttachedFrom.clear();

        PORTABLE_ATTACHLIST* pAl, *pNextAl;
        if((pAl= DDSurf.lpAttachList())!= NULL)
        {
            pNextAl= pAl;
            do
            {
                if( pNextAl->lpAttached!= NULL&& dwMyHandle!=
                    pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle())
                {
                    m_AttachedTo.push_back(
                        pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle());
                }
                pNextAl= pNextAl->lpLink;
            } while( pNextAl!= pAl && pNextAl!= NULL);
        }
        if((pAl= DDSurf.lpAttachListFrom())!= NULL)
        {
            pNextAl= pAl;
            do
            {
                if( pNextAl->lpAttached!= NULL&& dwMyHandle!=
                    pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle())
                {
                    m_AttachedFrom.push_back(
                        pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle());
                }
                pNextAl= pNextAl->lpLink;
            } while( pNextAl!= pAl && pNextAl!= NULL);
        }
        return *this;
    }
    DWORD GetLCLdwFlags( void) const 
    { return m_LCLdwFlags; }
    const DDSCAPS& GetLCLddsCaps( void) const 
    { return m_LCLddsCaps; }
    DWORD GetLCLdwBackBufferCount( void) const 
    { return m_LCLdwBackBufferCount; }
    DWORD GetMOREdwMipMapCount( void) const 
    { return m_MOREdwMipMapCount; }
    const DDSCAPSEX& GetMOREddsCapsEx( void) const 
    { return m_MOREddsCapsEx; }
    DWORD GetMOREdwSurfaceHandle( void) const 
    { return m_MOREdwSurfaceHandle; }
    DWORD GetMOREdwFVF( void) const 
    { return m_MOREdwFVF; }
    DWORD GetGBLdwGlobalFlags( void) const 
    { return m_GBLdwGlobalFlags; }
    ULONG_PTR GetGBLfpVidMem( void) const 
    { return m_GBLfpVidMem; }
    LONG GetGBLlPitch( void) const 
    { return m_GBLlPitch; }
    WORD GetGBLwHeight( void) const 
    { return m_GBLwHeight; }
    WORD GetGBLwWidth( void) const 
    { return m_GBLwWidth; }
    ULONG_PTR GetGBLdwReserved1( void) const 
    { return m_GBLdwReserved1; }
    const DDPIXELFORMAT& GetGBLddpfSurface( void) const 
    { return m_GBLddpfSurface; }
    const THandleVector& GetAttachedTo( void) const 
    { return m_AttachedTo; }
    const THandleVector& GetAttachedFrom( void) const 
    { return m_AttachedFrom; }
};

template< class TPDBE= CPalDBEntry, class THV= vector< DWORD> >
class CSurfDBEntryWPal:
    public CSurfDBEntry< THV>
{
public: // Types
    typedef TPDBE TPalDBEntry;

protected: // Variables
    TPalDBEntry* m_pPalDBEntry;

public: // Functions
    CSurfDBEntryWPal():
        m_pPalDBEntry( NULL)
    { }
    explicit CSurfDBEntryWPal( PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CSurfDBEntry< THV>( DDSurf), m_pPalDBEntry( NULL)
    { }
    ~CSurfDBEntryWPal()
    { }
    CSurfDBEntryWPal< TPDBE, THV>& operator=( PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    {
        CSurfDBEntry< THV>* pSub= static_cast< CSurfDBEntry< THV>*>( this);
        // DO NOT STORE &DDSurf. This is considered illegal.
        *pSub= DDSurf;
        return *this;
    }
    void SetPalette( TPalDBEntry* pPalDBEntry)
    { m_pPalDBEntry= pPalDBEntry; }
    TPalDBEntry* GetPalette() const
    { return m_pPalDBEntry; }
};

template< class TSuper, class TD, class TSDBE= CSurfDBEntry<>,
    class TSDB= map< DWORD, TSDBE>,
    class TFS= set< PORTABLE_DDRAWSURFACE_LCL*> >
class CSubPerDDrawData
{
public: // Types
    typedef TD TDriver;
    typedef TSDBE TSurfDBEntry;
    typedef TSDB TSurfDB;

protected: // Variables
    TDriver& m_Driver;
    TSurfDB m_SurfDB;

protected: // Functions
    CSubPerDDrawData( TDriver& Driver, const DDRAWI_DIRECTDRAW_LCL& DDLcl) 
        :m_Driver( Driver)
    { }
    ~CSubPerDDrawData()  { }

public: // Functions
    TDriver& GetDriver( void) const  { return m_Driver; }
    TSurfDBEntry* GetSurfDBEntry( DWORD dwH) 
    {
        typename TSurfDB::iterator itSurf( m_SurfDB.find( dwH));
        if( itSurf!= m_SurfDB.end())
            return &itSurf->second;
        else
            return NULL;
    }
    const TSurfDBEntry* GetSurfDBEntry( DWORD dwH) const 
    {
        typename TSurfDB::const_iterator itSurf( m_SurfDB.find( dwH));
        if( itSurf!= m_SurfDB.end())
            return &itSurf->second;
        else
            return NULL;
    }

    bool PreProcessFullSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl) const 
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        return false;
    }
    bool PreProcessIndividualSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl) const
        
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        return false;
    }
    void ProcessIndividualSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl)
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        pair< TSurfDB::iterator, bool> Ret= m_SurfDB.insert( 
            TSurfDB::value_type( DDSLcl.lpSurfMore()->dwSurfaceHandle(),
            TSurfDBEntry( DDSLcl)));

        // If not added, update data.
        if( !Ret.second) Ret.first->second= DDSLcl;
    }
    void ProcessFullSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl)
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        TSuper* pSThis= static_cast<TSuper*>(this);
        typedef TFS TFoundSet;
        TFoundSet FoundSet;
        typename TFoundSet::size_type OldSetSize( FoundSet.size());

        // First traverse all over the attach lists looking for new surfaces.
        PORTABLE_ATTACHLIST* pAl, *pNextAl;
        FoundSet.insert( &DDSLcl);
        typename TFoundSet::size_type NewSetSize( FoundSet.size());
        while( OldSetSize!= NewSetSize)
        {
            OldSetSize= NewSetSize;

            typename TFoundSet::iterator itSurf( FoundSet.begin());
            while( itSurf!= FoundSet.end())
            {
                if((pAl= (*itSurf)->lpAttachList())!= NULL)
                {
                    pNextAl= pAl;
                    do
                    {
                        if( pNextAl->lpAttached!= NULL)
                            FoundSet.insert( pNextAl->lpAttached);

                        pNextAl= pNextAl->lpLink;
                    } while( pNextAl!= pAl && pNextAl!= NULL);
                }
                if((pAl= (*itSurf)->lpAttachListFrom())!= NULL)
                {
                    pNextAl= pAl;
                    do
                    {
                        if( pNextAl->lpAttached!= NULL)
                            FoundSet.insert( pNextAl->lpAttached);

                        pNextAl= pNextAl->lpLink;
                    } while( pNextAl!= pAl && pNextAl!= NULL);
                }
                itSurf++;                
            }
            NewSetSize= FoundSet.size();
        }

        // After all surfaces have been found, add them to the DB.
        typename TFoundSet::iterator itSurf( FoundSet.begin());
        while( itSurf!= FoundSet.end())
        {
            if( !pSThis->PreProcessIndividualSurface( *(*itSurf)))
                ProcessIndividualSurface( *(*itSurf));

            itSurf++;
        }
    }

    // Notification that a system or video memory surface was created. At the
    // least, we have to keep track of the surface handles.
    void SurfaceCreated( PORTABLE_DDRAWSURFACE_LCL& DDSLcl)
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        TSuper* pSThis= static_cast<TSuper*>(this);

        // If true is returned, then a super structure was recognized and
        // processed. Otherwise, false indicates no recognition, and all
        // surfaces will be scoured.
        if( !pSThis->PreProcessFullSurface( DDSLcl))
            pSThis->ProcessFullSurface( DDSLcl);
    }
    bool SurfaceDestroyed( PORTABLE_DDRAWSURFACE_LCL& DDSLcl) 
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.

        // No need to assert removal, as we might not be tracking this type
        // of surface. Someone could override and filter out surfaces.
        m_SurfDB.erase( DDSLcl.lpSurfMore()->dwSurfaceHandle());

        // Return true to tell driver to delete this object. So,
        // if DB is empty, odds are good to delete this.
        return m_SurfDB.empty();
    }
};

template< class TD>
class CMinimalPerDDrawData:
    public CSubPerDDrawData< CMinimalPerDDrawData< TD>, TD>
{
public:
    CMinimalPerDDrawData( TDriver& Driver, DDRAWI_DIRECTDRAW_LCL& DDLcl) 
        :CSubPerDDrawData< CMinimalPerDDrawData< TD>, TD>( Driver, DDLcl)
    { }
    ~CMinimalPerDDrawData()  { }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSubDriver
//
////////////////////////////////////////////////////////////////////////////////
template< class T>
struct SFakeEntryPointHook
{
    SFakeEntryPointHook( T& t, const char* szEntryPoint)  { }
    ~SFakeEntryPointHook()  { }
};

template< class TD, class TC, class TSA= CIVidMemAllocator<>,
    class TPDDD= CMinimalPerDDrawData< TD>,
    class TCs= set< TC*>,
    class TPDDDs= map< LPDDRAWI_DIRECTDRAW_LCL, TPDDD>,
    class TSs= set< TSA::TSurface*>,
    class TEntryPointHook= SFakeEntryPointHook< TD> >
class CSubDriver
{
public: // Types
    typedef TD TDriver;
    typedef TC TContext;
    typedef TCs TContexts;
    typedef TPDDD TPerDDrawData;
    typedef TPDDDs TPerDDrawDatas;
    typedef TSA TSurfAlloc;
    typedef typename TSurfAlloc::TSurface TSurface;
    typedef TSs TSurfaces;

    class CSurfaceCapWrap
    {
    protected:
        DDSURFACEDESC m_SDesc;
    public:
        CSurfaceCapWrap()  { }
        CSurfaceCapWrap( const D3DFORMAT D3DFmt, const DWORD dwSupportedOps,
            const DWORD dwPrivateFmtBitCount= 0,
            const WORD wFlipMSTypes= 0, const WORD wBltMSTypes= 0) 
        {
            ZeroMemory( &m_SDesc, sizeof( m_SDesc));
            m_SDesc.dwSize= sizeof( m_SDesc);

            m_SDesc.ddpfPixelFormat.dwFlags= DDPF_D3DFORMAT;
            m_SDesc.ddpfPixelFormat.dwFourCC= static_cast<DWORD>(D3DFmt);
            m_SDesc.ddpfPixelFormat.dwOperations= dwSupportedOps;
            m_SDesc.ddpfPixelFormat.dwPrivateFormatBitCount= dwPrivateFmtBitCount;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes= wFlipMSTypes;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wBltMSTypes= wBltMSTypes;
        }
        CSurfaceCapWrap( const D3DFORMAT D3DFmt, const bool bTexture,
            const bool bVolTexture, const bool bCubeTexture,
            const bool bOffScreenTarget, const bool bSameFmtTarget,
            const bool bZStencil, const bool bZStencilWithColor,
            const bool bSameFmtUpToAlpha, const bool b3DAccel,
            const DWORD dwPrivateFmtBitCount= 0,
            const WORD wFlipMSTypes= 0, const WORD wBltMSTypes= 0) 
        {
            ZeroMemory( &m_SDesc, sizeof( m_SDesc));
            m_SDesc.dwSize= sizeof( m_SDesc);

            DWORD dwOps( 0);
            if( bTexture) dwOps|= D3DFORMAT_OP_TEXTURE;
            if( bVolTexture) dwOps|= D3DFORMAT_OP_VOLUMETEXTURE;
            if( bCubeTexture) dwOps|= D3DFORMAT_OP_CUBETEXTURE;
            if( bOffScreenTarget) dwOps|= D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
            if( bSameFmtTarget) dwOps|= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
            if( bZStencil) dwOps|= D3DFORMAT_OP_ZSTENCIL;
            if( bZStencilWithColor) dwOps|= D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH;
            if( bSameFmtUpToAlpha) dwOps|= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
            if( b3DAccel) dwOps|= D3DFORMAT_OP_3DACCELERATION;

            m_SDesc.ddpfPixelFormat.dwFlags= DDPF_D3DFORMAT;
            m_SDesc.ddpfPixelFormat.dwFourCC= static_cast<DWORD>(D3DFmt);
            m_SDesc.ddpfPixelFormat.dwOperations= dwOps;
            m_SDesc.ddpfPixelFormat.dwPrivateFormatBitCount= dwPrivateFmtBitCount;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes= wFlipMSTypes;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wBltMSTypes= wBltMSTypes;
        }
        ~CSurfaceCapWrap()  { }
        operator DDSURFACEDESC() const 
        { return m_SDesc; }
    };

private:
    // Stubs for secondary entry points.
    DWORD static APIENTRY ContextCreateStub( LPD3DHAL_CONTEXTCREATEDATA pccd) 
    {
        return sm_pGlobalDriver->ContextCreate(
            *reinterpret_cast< PORTABLE_CONTEXTCREATEDATA*>( pccd));
    }
    DWORD static APIENTRY ContextDestroyStub( LPD3DHAL_CONTEXTDESTROYDATA pcdd) 
    { return sm_pGlobalDriver->ContextDestroy( *pcdd); }
    DWORD static APIENTRY ContextDestroyAllStub( LPD3DHAL_CONTEXTDESTROYALLDATA pcdad) 
    { return sm_pGlobalDriver->ContextDestroyAll( *pcdad); }
    DWORD static APIENTRY SceneCaptureStub( LPD3DHAL_SCENECAPTUREDATA pscd) 
    { return sm_pGlobalDriver->SceneCapture( *pscd); }
    DWORD static APIENTRY RenderStateStub( LPD3DHAL_RENDERSTATEDATA prsd) 
    { return sm_pGlobalDriver->RenderState( *prsd); }
    DWORD static APIENTRY RenderPrimitiveStub( LPD3DHAL_RENDERPRIMITIVEDATA prpd) 
    { return sm_pGlobalDriver->RenderPrimitive( *prpd); }
    DWORD static APIENTRY TextureCreateStub( LPD3DHAL_TEXTURECREATEDATA ptcd) 
    { return sm_pGlobalDriver->TextureCreate( *ptcd); }
    DWORD static APIENTRY TextureDestroyStub( LPD3DHAL_TEXTUREDESTROYDATA ptdd) 
    { return sm_pGlobalDriver->TextureDestroy( *ptdd); }
    DWORD static APIENTRY TextureSwapStub( LPD3DHAL_TEXTURESWAPDATA ptsd) 
    { return sm_pGlobalDriver->TextureSwap( *ptsd); }
    DWORD static APIENTRY TextureGetSurfStub( LPD3DHAL_TEXTUREGETSURFDATA ptgsd) 
    { return sm_pGlobalDriver->TextureGetSurf( *ptgsd); }
    DWORD static APIENTRY GetStateStub( LPD3DHAL_GETSTATEDATA pgsd) 
    { return sm_pGlobalDriver->GetState( *pgsd); }
    DWORD static APIENTRY SetRenderTargetStub( LPD3DHAL_SETRENDERTARGETDATA psrtd) 
    {
        return sm_pGlobalDriver->SetRenderTarget(
            *reinterpret_cast< PORTABLE_SETRENDERTARGETDATA*>( psrtd));
    }
    DWORD static APIENTRY ClearStub( LPD3DHAL_CLEARDATA pcd) 
    { return sm_pGlobalDriver->Clear( *pcd); }
    DWORD static APIENTRY DrawOnePrimitiveStub( LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd) 
    { return sm_pGlobalDriver->DrawOnePrimitive( *pdopd); }
    DWORD static APIENTRY DrawOneIndexedPrimitiveStub( LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd) 
    { return sm_pGlobalDriver->DrawOneIndexedPrimitive( *pdoipd); }
    DWORD static APIENTRY DrawPrimitivesStub( LPD3DHAL_DRAWPRIMITIVESDATA pdpd) 
    { return sm_pGlobalDriver->DrawPrimitives( *pdpd); }
    DWORD static APIENTRY Clear2Stub( LPD3DHAL_CLEAR2DATA pc2d) 
    { return sm_pGlobalDriver->Clear2( *pc2d); }
    DWORD static APIENTRY ValidateTextureStageStateStub( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd) 
    { return sm_pGlobalDriver->ValidateTextureStageState( *pvtssd); }
    DWORD static APIENTRY DrawPrimitives2Stub( LPD3DHAL_DRAWPRIMITIVES2DATA pdpd) 
    {
        return sm_pGlobalDriver->DrawPrimitives2(
            *reinterpret_cast< PORTABLE_DRAWPRIMITIVES2DATA*>( pdpd));
    }
    DWORD static APIENTRY GetDriverStateStub( LPDDHAL_GETDRIVERSTATEDATA pgdsd) 
    { return sm_pGlobalDriver->GetDriverState( *pgdsd); }
    DWORD static APIENTRY CreateSurfaceExStub( LPDDHAL_CREATESURFACEEXDATA pcsxd) 
    {
        return sm_pGlobalDriver->CreateSurfaceEx(
            *reinterpret_cast< PORTABLE_CREATESURFACEEXDATA*>( pcsxd));
    }
    DWORD static APIENTRY CreateSurfaceStub( LPDDHAL_CREATESURFACEDATA pcsd) 
    {
        return sm_pGlobalDriver->CreateSurface(
            *reinterpret_cast< PORTABLE_CREATESURFACEDATA*>( pcsd));
    }
    DWORD static APIENTRY DestroySurfaceStub( LPDDHAL_DESTROYSURFACEDATA pdsd) 
    {
        return sm_pGlobalDriver->DestroySurface(
            *reinterpret_cast< PORTABLE_DESTROYSURFACEDATA*>( pdsd));
    }
    DWORD static APIENTRY LockStub( LPDDHAL_LOCKDATA pld) 
    {
        return sm_pGlobalDriver->Lock(
            *reinterpret_cast< PORTABLE_LOCKDATA*>( pld));
    }
    DWORD static APIENTRY UnlockStub( LPDDHAL_UNLOCKDATA pud) 
    {
        return sm_pGlobalDriver->Unlock(
            *reinterpret_cast< PORTABLE_UNLOCKDATA*>( pud));
    }

protected:
    TSurfAlloc m_SurfAlloc;
    TContexts m_Contexts;
    TPerDDrawDatas m_PerDDrawDatas;
    TSurfaces m_Surfaces;
    typedef vector< DDSURFACEDESC> TSupportedSurfaces;
    TSupportedSurfaces m_SupportedSurfaces;

    template< class TIter> // DDSURFACEDESC*
    CSubDriver( TIter itStart, const TIter itEnd, TSurfAlloc SA= TSurfAlloc()):
        m_SurfAlloc( SA)
    {
        // Copy supported surfaces formats into a guarenteed contiguous storage
        // for passing to D3D.
        while( itStart!= itEnd)
            m_SupportedSurfaces.push_back( *itStart++);
    }
    ~CSubDriver()  { }
    // Binds a VidMem DDRAWI object together with an internal driver surface object.
    void static AssociateSurface( PORTABLE_DDRAWSURFACE_LCL& DDSurf,
        TSurface* pSurf) 
    {
        assert((DDSurf.ddsCaps().dwCaps& DDSCAPS_VIDEOMEMORY)!= 0);
        DDSurf.lpGbl()->dwReserved1= reinterpret_cast< ULONG_PTR>(pSurf);
    }

public:
    // The global driver static member pointer. Only one Driver object, and
    // this points to it.
    static TDriver* sm_pGlobalDriver;

    TSurface* GetSurface( PORTABLE_DDRAWSURFACE_LCL& DDSurf,
        bool bCheck= true) const 
    {
        TSurface* pSurface= reinterpret_cast< TSurface*>(
            DDSurf.lpGbl()->dwReserved1);
        assert( bCheck&& m_Surfaces.find( pSurface)!= m_Surfaces.end());
        return pSurface;
    }
    TSurface* GetSurface( const typename TPerDDrawData::TSurfDBEntry& DBEntry,
        bool bCheck= true) const 
    {
        TSurface* pSurface= reinterpret_cast< TSurface*>(
            DBEntry.GetGBLdwReserved1());
        assert( bCheck&& m_Surfaces.find( pSurface)!= m_Surfaces.end());
        return pSurface;
    }

    // Secondary entry points with C++ friendly parameters.
    DWORD ContextCreate( PORTABLE_CONTEXTCREATEDATA& ccd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ContextCreate");

            ccd.ddrval()= DD_OK;
            TDriver* pSThis= static_cast<TDriver*>(this);

            // We should already have a PerDDrawData at this point, as the
            // surfaces to initialize the context had to be created already,
            // and the PerDDrawData should've been created there.
            typename TPerDDrawDatas::iterator itPerDDrawData(
                m_PerDDrawDatas.find( ccd.lpDDLcl()));
            assert( itPerDDrawData!= m_PerDDrawDatas.end());

            // Create the new context, passing in a ref to the PerDDrawData object.
            auto_ptr< TContext> pNewContext( new TContext(
                itPerDDrawData->second, ccd));

            // Keep track of our new context.
            pair< TContexts::iterator, bool> RetVal( m_Contexts.insert(
                pNewContext.get()));
            assert( RetVal.second); // Assure that there wasn't a duplicate.

            // Ownership now has been transfered to m_Contexts & D3D.
            ccd.dwhContext()= reinterpret_cast<ULONG_PTR>( pNewContext.release());
        } catch( bad_alloc e) {
            ccd.ddrval()= D3DHAL_OUTOFCONTEXTS;
        } catch( HRESULT hr) {
            ccd.ddrval()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool ContextCreate_Unrecognized_Exception( false);
            assert( ContextCreate_Unrecognized_Exception);
            ccd.ddrval()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD ContextDestroy( D3DHAL_CONTEXTDESTROYDATA& cdd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ContextDestroy");

            cdd.ddrval= DD_OK;

            // Ownership now has been transfered to local auto_ptr.
            auto_ptr< TContext> pContext(
                reinterpret_cast<TContext*>(cdd.dwhContext));

            // Remove tracking of this context.
            typename TContexts::size_type Ret( m_Contexts.erase( pContext.get()));
            assert( Ret!= 0);
        } catch( HRESULT hr) {
            cdd.ddrval= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool ContextDestroy_Unrecognized_Exception( false);
            assert( ContextDestroy_Unrecognized_Exception);
            cdd.ddrval= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD ContextDestroyAll( D3DHAL_CONTEXTDESTROYALLDATA& cdad) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ContextDestroyAll");
        const bool ContextDestroyAll_thought_to_be_depreciated_entry_point( false);
        assert( ContextDestroyAll_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD SceneCapture( D3DHAL_SCENECAPTUREDATA& scd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "SceneCapture");
        const bool SceneCapture_thought_to_be_depreciated_entry_point( false);
        assert( SceneCapture_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD RenderState( D3DHAL_RENDERSTATEDATA& rsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "RenderState");
        const bool RenderState_thought_to_be_depreciated_entry_point( false);
        assert( RenderState_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD RenderPrimitive( D3DHAL_RENDERPRIMITIVEDATA& rpd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "RenderPrimitive");
        const bool RenderPrimitive_thought_to_be_depreciated_entry_point( false);
        assert( RenderPrimitive_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureCreate( D3DHAL_TEXTURECREATEDATA& tcd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureCreate");
        const bool TextureCreate_thought_to_be_depreciated_entry_point( false);
        assert( TextureCreate_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureDestroy( D3DHAL_TEXTUREDESTROYDATA& tdd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureDestroy");
        const bool TextureDestroy_thought_to_be_depreciated_entry_point( false);
        assert( TextureDestroy_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureSwap( D3DHAL_TEXTURESWAPDATA& tsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureSwap");
        const bool TextureSwap_thought_to_be_depreciated_entry_point( false);
        assert( TextureSwap_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureGetSurf( D3DHAL_TEXTUREGETSURFDATA& tgsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureGetSurf");
        const bool TextureGetSurf_thought_to_be_depreciated_entry_point( false);
        assert( TextureGetSurf_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD GetState( D3DHAL_GETSTATEDATA& gsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "GetState");
        const bool GetState_thought_to_be_depreciated_entry_point( false);
        assert( GetState_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD SetRenderTarget( PORTABLE_SETRENDERTARGETDATA& srtd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "SetRenderTarget");
        const bool SetRenderTarget_thought_to_be_depreciated_entry_point( false);
        assert( SetRenderTarget_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD Clear( D3DHAL_CLEARDATA& cd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Clear");
        const bool Clear_thought_to_be_depreciated_entry_point( false);
        assert( Clear_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD DrawOnePrimitive( D3DHAL_DRAWONEPRIMITIVEDATA& dopd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawOnePrimitive");
        const bool DrawOnePrimitive_thought_to_be_depreciated_entry_point( false);
        assert( DrawOnePrimitive_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD DrawOneIndexedPrimitive( D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA& doipd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawOneIndexedPrimitive");
        const bool DrawOneIndexedPrimitive_thought_to_be_depreciated_entry_point( false);
        assert( DrawOneIndexedPrimitive_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD DrawPrimitives( D3DHAL_DRAWPRIMITIVESDATA& dpd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawPrimitives");
        const bool DrawPrimitives_thought_to_be_depreciated_entry_point( false);
        assert( DrawPrimitives_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD Clear2( D3DHAL_CLEAR2DATA& c2d) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Clear2");
        const bool Clear2_thought_to_be_depreciated_entry_point( false);
        assert( Clear2_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD ValidateTextureStageState( D3DHAL_VALIDATETEXTURESTAGESTATEDATA& vtssd) const throw()
    { 
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ValidateTextureStageState");

            vtssd.ddrval= DD_OK;
            TContext* pContext= reinterpret_cast<TContext*>(vtssd.dwhContext);

            // Make sure we've created this context.
            assert( m_Contexts.find( pContext)!= m_Contexts.end());

            // Pass entry point to context.
            vtssd.ddrval= pContext->ValidateTextureStageState( vtssd);
        } catch( HRESULT hr) {
            vtssd.ddrval= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool ValidateTextureStageState_Unrecognized_Exception( false);
            assert( ValidateTextureStageState_Unrecognized_Exception);
            vtssd.ddrval= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD DrawPrimitives2( PORTABLE_DRAWPRIMITIVES2DATA& dpd) const throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawPrimitives2");

            dpd.ddrval()= DD_OK;
            TContext* pContext= reinterpret_cast<TContext*>(dpd.dwhContext());

            // Make sure we've created this context.
            assert( m_Contexts.find( pContext)!= m_Contexts.end());

            // Pass entry point to context.
            dpd.ddrval()= pContext->DrawPrimitives2( dpd);
        } catch( HRESULT hr) {
            dpd.ddrval()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool DrawPrimitives2_Unrecognized_Exception( false);
            assert( DrawPrimitives2_Unrecognized_Exception);
            dpd.ddrval()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD GetDriverState( DDHAL_GETDRIVERSTATEDATA& gdsd) const throw()
    {
        // This entry point is hooked up to IDirect3DDevice8::GetInfo(
        //   DWORD DevInfoId, VOID* pDevInfoStruct, DWORD DevInfoStructSize).
        // gdsd.dwFlags= DevInfoId
        // gdsd.lpdwStates= pDevInfoStruct
        // gdsd.dwLength= DevInfoStructSize
        //
        // This entry point can be used for driver defined/ extended state
        // passing. Currently no DevInfoIds are pre-defined. S_FALSE should
        // be returned if nothing is done or the Id is not understood.
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "GetDriverState");

            gdsd.ddRVal= DD_OK;
            TContext* pContext= reinterpret_cast< TContext*>( gdsd.dwhContext);

            // Make sure we've created this context.
            assert( m_Contexts.find( pContext)!= m_Contexts.end());

            // Pass entry point to context.
            gdsd.ddRVal= pContext->GetDriverState( gdsd);
        } catch( HRESULT hr) {
            gdsd.ddRVal= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool GetDriverState_Unrecognized_Exception( false);
            assert( GetDriverState_Unrecognized_Exception);
            gdsd.ddRVal= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD CreateSurfaceEx( PORTABLE_CREATESURFACEEXDATA& csxd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "CreateSurfaceEx");

            TDriver* pSThis= static_cast<TDriver*>(this);
            csxd.ddRVal()= DD_OK;
            
            // Upon CreateSurfaceEx, we must detect whether this is a creation
            // or destruction notification and pass it to the associated
            // PerDDrawData.

            // Get PerDDrawData for this DDraw object.
            typename TPerDDrawDatas::iterator itPerDDrawData( m_PerDDrawDatas.find(
                csxd.lpDDLcl()));

            if( 0== csxd.lpDDSLcl()->lpGbl()->fpVidMem)
            {   // System Memory Surface Destruction,
                // Pass notification to PerDDrawData, if exists. PerDDraw data
                // will return bool indicating whether to delete it or not.
                if( itPerDDrawData!= m_PerDDrawDatas.end() &&
                    itPerDDrawData->second.SurfaceDestroyed( *csxd.lpDDSLcl()))
                    m_PerDDrawDatas.erase( itPerDDrawData);
            }
            else
            {   // Video or System Memory Surface Creation
                // If we don't have PerDDrawData for this DDraw object yet,
                // we must create it.
                if( itPerDDrawData== m_PerDDrawDatas.end())
                {
                    // Typically, storing pointers to DDRAWI objects is illegal,
                    // but this case has been deemed okay. Otherwise, we
                    // couldn't have the concept of "per DDraw" data, as
                    // "per DDraw" would be hard to figure out; as nothing
                    // guarentees uniqueness between the DDRAWI objects, besides
                    // the pointers.
                    itPerDDrawData= m_PerDDrawDatas.insert( 
                        TPerDDrawDatas::value_type( csxd.lpDDLcl(),
                        TPerDDrawData( *pSThis, *csxd.lpDDLcl())) ).first;
                }

                // Now pass notification to PerDDrawData.
                // DO NOT STORE csxd.lpDDSLcl. This is considered illegal.
                // It is only valid for the duration of the call.
                itPerDDrawData->second.SurfaceCreated( *csxd.lpDDSLcl());
            }
        } catch( bad_alloc e) {
            csxd.ddRVal()= DDERR_OUTOFMEMORY;
        } catch( HRESULT hr) {
            csxd.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool CreateSurfaceEx_Unrecognized_Exception( false);
            assert( CreateSurfaceEx_Unrecognized_Exception);
            csxd.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD CreateSurface( PORTABLE_CREATESURFACEDATA& csd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "CreateSurface");

            TDriver* pSThis= static_cast<TDriver*>(this);
            csd.ddRVal()= DD_OK;

            // Upon CreateSurface, we must allocate memory for the "video"
            // memory surface and also associate our internal representation
            // with the surface.

            DWORD dwS( 0);
            try
            {
                // For each surface we're asked to create...
                while( dwS< csd.dwSCnt())
                {
                    // Get PerDDrawData for this DDraw object.
                    const LPDDRAWI_DIRECTDRAW_LCL pDDLcl(
                        csd.lplpSList()[ dwS]->lpSurfMore()->lpDD_lcl());
                    typename TPerDDrawDatas::iterator itPerDDrawData(
                        m_PerDDrawDatas.find( pDDLcl));

                    // If we don't have PerDDrawData for this DDraw object yet,
                    // we must create it.
                    if( itPerDDrawData== m_PerDDrawDatas.end())
                    {
                        // Typically, storing pointers to DDRAWI objects is
                        // illegal, but this case has been deemed okay.
                        // Otherwise, we couldn't have the concept of
                        // "per DDraw" data, as "per DDraw" would be hard to
                        // figure out; as nothing guarentees uniqueness
                        // between the DDRAWI objects, besides the pointers.
                        itPerDDrawData= m_PerDDrawDatas.insert( 
                            TPerDDrawDatas::value_type( pDDLcl,
                            TPerDDrawData( *pSThis, *pDDLcl)) ).first;
                    }

                    // Create the new surface, by using the surface allocator.
                    // DO NOT STORE csd.lplpSList[ dwS]. This is considered
                    // illegal. It is only valid for the duration of the call.
                    auto_ptr< TSurface> pNewSurf(
                        m_SurfAlloc.CreateSurf( *csd.lpDDSurfaceDesc(),
                        *csd.lplpSList()[ dwS]));

                    // Add the pointer to our set of VM surfaces for tracking.
                    m_Surfaces.insert( pNewSurf.get());

                    // Bind the internal representation to the DDRAWI object.
                    AssociateSurface( *csd.lplpSList()[ dwS], pNewSurf.get());

                    pNewSurf.release();
                    dwS++;
                }
            } catch( ... ) {
                // dwS will point to failed alloc, then deallocate the
                // succeeded allocations.

                // Bind NULL to the DDRAWI object and blank out fpVidMem, just
                // in case.
                AssociateSurface( *csd.lplpSList()[ dwS], NULL);
                csd.lplpSList()[ dwS]->lpGbl()->fpVidMem= NULL;
                if( dwS!= 0) do
                {
                    --dwS;

                    TSurface* pSurface= GetSurface( *csd.lplpSList()[ dwS]);
                    m_Surfaces.erase( pSurface);
                    delete pSurface;

                    // Bind NULL to the DDRAWI object and blank out fpVidMem,
                    // to avoid DDraw in thinking the surface was allocated.
                    AssociateSurface( *csd.lplpSList()[ dwS], NULL);
                    csd.lplpSList()[ dwS]->lpGbl()->fpVidMem= NULL;
                } while( dwS!= 0);

                throw; // Re-throw the exception.
            }

            // We wait till CreateSurfaceEx to make the handle association.
        } catch( bad_alloc e) {
            csd.ddRVal()= DDERR_OUTOFMEMORY;
        } catch( HRESULT hr) {
            csd.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool CreateSurface_Unrecognized_Exception( false);
            assert( CreateSurface_Unrecognized_Exception);
            csd.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD DestroySurface( PORTABLE_DESTROYSURFACEDATA& dsd) throw()
    { 
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DestroySurface");

            dsd.ddRVal()= DD_OK;

            // Retrieve 
            TSurface* pSurface= GetSurface( *dsd.lpDDSurface());

            // Surface object must be destroyed before the DB entry. This is
            // a requirement so that a link (pointer) can safely be
            // established between the DB entry and the object.
            m_Surfaces.erase( pSurface);
            delete pSurface;

            // Pass destruction notice to PerDDrawData. If it returns true,
            // then PerDDrawData indicates that it should be destroyed.
            typename TPerDDrawDatas::iterator itPerDDrawData( m_PerDDrawDatas.find(
                dsd.lpDDSurface()->lpSurfMore()->lpDD_lcl()));
            if( itPerDDrawData!= m_PerDDrawDatas.end() &&
                itPerDDrawData->second.SurfaceDestroyed( *dsd.lpDDSurface()))
                m_PerDDrawDatas.erase( itPerDDrawData);
        } catch( HRESULT hr) {
            dsd.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool DestroySurface_Unrecognized_Exception( false);
            assert( DestroySurface_Unrecognized_Exception);
            dsd.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD Lock( PORTABLE_LOCKDATA& ld) const throw()
    { 
        // Typically, an application requesting a "Lock" of a multisampled
        // surface is not allowed. It would require a MSLock or a new version
        // of Lock to get access to the multisampled bits. However, these
        // surfaces still need to be able to "Present" the bits or "Blt" the
        // bits to the Primary, typically. This requires a workaround:
        // The runtime WILL lock the surface (not for the app), expecting the
        // rasterizer to subsample the multisampled bits into an equivalent
        // non-multisampled area and return this smaller area out of Lock,
        // so that the runtime can "Present" the bits, or whatever.

        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Lock");

            ld.ddRVal()= DD_OK;

            // First, retrieve surface object bound to this structure.
            TSurface* pSurface= GetSurface( *ld.lpDDSurface());

            // Pass control to object's Lock function.
            ld.lpSurfData()= pSurface->Lock( ld.dwFlags(), (ld.bHasRect()?
                &ld.rArea(): NULL));
        } catch( HRESULT hr) {
            ld.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool Lock_Unrecognized_Exception( false);
            assert( Lock_Unrecognized_Exception);
            ld.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD Unlock( PORTABLE_UNLOCKDATA& ud) const throw()
    { 
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Unlock");

            ud.ddRVal()= DD_OK;

            // First, retrieve surface object bound to this structure.
            TSurface* pSurface= GetSurface( *ud.lpDDSurface());

            // Pass control to object's Unlock function.
            pSurface->Unlock();
        } catch( HRESULT hr) {
            ud.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool Unlock_Unrecognized_Exception( false);
            assert( Unlock_Unrecognized_Exception);
            ud.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }

    // Main entry point of driver.
    // Should be called by a bridge function, only.
    HRESULT GetSWInfo( D3DCAPS8& Caps8, D3D8_SWCALLBACKS& Callbacks,
        DWORD& dwNumTextures, DDSURFACEDESC*& pTexList) throw()
    {
        // This static member variable should be initialized to be NULL or
        // point it to the global class.
        assert( NULL== sm_pGlobalDriver|| \
            static_cast< TDriver*>( this)== sm_pGlobalDriver);
        sm_pGlobalDriver= static_cast< TDriver*>( this);

        Callbacks.CreateContext            = ContextCreateStub; // Needed.
        Callbacks.ContextDestroy           = ContextDestroyStub; // Needed.
        Callbacks.ContextDestroyAll        = ContextDestroyAllStub; // Unused in DX8DDI?
        Callbacks.SceneCapture             = SceneCaptureStub; // Unused in DX8DDI, now a render state.
        Callbacks.RenderState              = RenderStateStub; // Unused in DX8DDI?
        Callbacks.RenderPrimitive          = RenderPrimitiveStub; // Unused in DX8DDI?
        Callbacks.TextureCreate            = TextureCreateStub; // Unused in DX8DDI?
        Callbacks.TextureDestroy           = TextureDestroyStub; // Unused in DX8DDI?
        Callbacks.TextureSwap              = TextureSwapStub; // Unused in DX8DDI?
        Callbacks.TextureGetSurf           = TextureGetSurfStub; // Unused in DX8DDI?
        Callbacks.GetState                 = GetStateStub; // Unused in DX8DDI?
        Callbacks.SetRenderTarget          = SetRenderTargetStub; // Unused in DX8DDI?
        Callbacks.Clear                    = ClearStub; // Unused in DX8DDI?
        Callbacks.DrawOnePrimitive         = DrawOnePrimitiveStub; // Unused in DX8DDI?
        Callbacks.DrawOneIndexedPrimitive  = DrawOneIndexedPrimitiveStub; // Unused in DX8DDI?
        Callbacks.DrawPrimitives           = DrawPrimitivesStub; // Unused in DX8DDI?
        Callbacks.Clear2                   = Clear2Stub; // Unused in DX8DDI?
        Callbacks.ValidateTextureStageState= ValidateTextureStageStateStub; // Optional?
        Callbacks.DrawPrimitives2          = DrawPrimitives2Stub; // Needed.
        Callbacks.GetDriverState           = GetDriverStateStub; // Optional?
        Callbacks.CreateSurfaceEx          = CreateSurfaceExStub; // Needed.
        Callbacks.CreateSurface            = CreateSurfaceStub; // Needed.
        Callbacks.DestroySurface           = DestroySurfaceStub; // Needed.
        Callbacks.Lock                     = LockStub; // Needed.
        Callbacks.Unlock                   = UnlockStub; // Needed.

        try {
            Caps8= sm_pGlobalDriver->GetCaps();

            // There needs to be support for some surfaces, at least.
            assert( !m_SupportedSurfaces.empty());

            dwNumTextures= m_SupportedSurfaces.size();
            pTexList= &(*m_SupportedSurfaces.begin());
        } catch( bad_alloc ba) {
            return E_OUTOFMEMORY;
        } catch( HRESULT hr) {
            return hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            return E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return S_OK;
    }
};

template< class TD, class TR>
class CMinimalDriver:
    public CSubDriver< TD, CMinimalContext< CMinimalPerDDrawData< TD>, TR> >
{
public: // Types
    typedef TR TRasterizer;

protected:
    template< class TIter> // DDSURFACEDESC*
    CMinimalDriver( TIter itStart, const TIter itEnd) :
        CSubDriver< TD, TContext>( itStart, itEnd)
    { /* TODO: Check caps? */ }
    ~CMinimalDriver() 
    { }
};

#if !defined( DX8SDDIFW_NONAMESPACE)
}
#endif // !defined( DX8SDDIFW_NONAMESPACE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\map.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class T, class Compare= less<Key>,
    class Allocator= allocator<pair<const Key,T> > >
class map:
    public RBTree< Key, pair<const Key,T>, select1st<pair<const Key,T> >,
        Compare, Allocator>
{
public: // Types
    typedef map< Key, T, Compare, Allocator> map_type;
    typedef RBTree< Key, pair<const Key,T>, select1st<pair<const Key,T> >,
        Compare, Allocator> tree_type;

    typedef tree_type::key_type key_type;
    typedef Allocator::rebind< T>::other mapped_type;
    typedef tree_type::value_type value_type;
    typedef tree_type::key_compare key_compare;
    struct value_compare:
        public binary_function< value_type, value_type, bool>
    {
        key_compare m_key_compare;
        explicit value_compare( const key_compare& KC): m_key_compare( KC)
        { }

        result_type operator()( const first_argument_type& Arg1,
            const second_argument_type& Arg2) const
        {
            return m_key_compare( Arg1.first, Arg2.first);
        }
    };
    typedef tree_type::pointer pointer;
    typedef tree_type::const_pointer const_pointer;
    typedef tree_type::reference reference;
    typedef tree_type::const_reference const_reference;
    typedef tree_type::size_type size_type;
    typedef tree_type::difference_type difference_type;
    typedef tree_type::iterator iterator;
    typedef tree_type::const_iterator const_iterator;
    typedef tree_type::reverse_iterator reverse_iterator;
    typedef tree_type::const_reverse_iterator const_reverse_iterator;
    typedef tree_type::allocator_type allocator_type;

public: // Functions
    using tree_type::begin;
    using tree_type::end;
    using tree_type::rbegin;
    using tree_type::rend;
    using tree_type::size;
    using tree_type::max_size;
    using tree_type::empty;
    using tree_type::key_comp;
    value_compare value_comp() const
    { return value_compare( key_comp()); }
    explicit map( const Compare& comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp,
        select1st<pair<const Key,T> >(), A)
    { }
    template< class InputIterator>
    map( InputIterator f, InputIterator l, const Compare comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp,
        select1st<pair<const Key,T> >(), A)
    {
        insert_unique( f, l);
    }
    map( const map_type& Other): tree_type( Other)
    { }
    ~map()
    { }
    map_type& operator=( const map_type& Other)
    {
        tree_type::operator=( Other);
        return *this;
    }
    using tree_type::get_allocator;
    void swap( const map_type& Other)
    { tree_type::swap( Other); }
    pair< iterator, bool> insert( const value_type& x)
    { return insert_unique( x); }
    iterator insert( iterator pos, const value_type& x)
    { return insert_unique( x); }
    template< class InputIterator>
    void insert( InputIterator f, InputIterator l)
    { insert_unique( f, l); }
    using tree_type::erase;
    using tree_type::find;
    using tree_type::count;
    using tree_type::lower_bound;
    using tree_type::upper_bound;
    using tree_type::equal_range;
    mapped_type& operator[]( const key_type& k)
    {
        iterator itEntry( insert( value_type( k, mapped_type())));
        return itEntry->second;
    }
};

template< class Key, class T, class Compare, class Allocator> inline
bool operator==( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return x.size()== y.size()&& equal( x.begin(), x.end(), y.begin());
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator!=( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return !(x== y);
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator<( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return lexicographical_compare( x.begin(), x.end(), y.begin(), y.end());
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator>( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return y< x;
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator<=( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return !(y< x);
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator>=( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return !(x< y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\tree.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class T, class ExtractKey, class CompareKey, class Allocator>
class RBTree
{
public: // Types
    typedef RBTree< Key, T, ExtractKey, CompareKey, Allocator> tree_type;
    typedef Allocator allocator_type;

    typedef Key key_type;
    typedef typename allocator_type::value_type value_type;
    typedef CompareKey key_compare;
    typedef ExtractKey key_extract;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;

protected: // Types
    struct tree_node;
    typedef typename Allocator::rebind< tree_node>::other
        tree_node_allocator_type;
    typedef typename tree_node_allocator_type::pointer tree_node_pointer;
    typedef typename tree_node_allocator_type::const_pointer
        tree_node_const_pointer;
    struct tree_node
    {
        tree_node_pointer m_pLeft;
        tree_node_pointer m_pParent;
        tree_node_pointer m_pRight;
        value_type m_Value;
        bool m_bRed;

        tree_node( const tree_node_pointer& pP, const value_type& v, bool bRed)
            :m_pLeft( NULL), m_pParent( pP), m_pRight( NULL), m_Value( v),
            m_bRed( bRed)
        { }
        ~tree_node()
        { }
    };
    template< class TPointer>
    struct NextInOrderNode:
        public unary_function< TPointer, TPointer>
    {
        result_type operator()( argument_type Arg, const bool bCouldBeEnd) const
        {
            if( bCouldBeEnd&& Arg->m_bRed&& Arg->m_pParent->m_pParent== Arg)
                Arg= Arg->m_pLeft;
            else if( Arg->m_pRight!= NULL)
            {
                Arg= Arg->m_pRight;
                while( Arg->m_pLeft!= NULL)
                    Arg= Arg->m_pLeft;
            }
            else
            {
                TPointer pP;
                while( Arg== (pP= Arg->m_pParent)->m_pRight)
                    Arg= pP;
                if( bCouldBeEnd|| Arg->m_pRight!= pP)
                    Arg= pP;
            }
            return Arg;
        }
    };
    template< class TPointer>
    struct PrevInOrderNode:
        public unary_function< TPointer, TPointer>
    {
        result_type operator()( argument_type Arg, const bool bCouldBeEnd) const
        {
            if( bCouldBeEnd&& Arg->m_bRed&& Arg->m_pParent->m_pParent== Arg)
                Arg= Arg->m_pRight;
            else if( Arg->m_pLeft!= NULL)
            {
                Arg= Arg->m_pLeft;
                while( Arg->m_pRight!= NULL)
                    Arg= Arg->m_pRight;
            }
            else
            {
                TPointer pP;
                while( Arg== (pP= Arg->m_pParent)->m_pLeft)
                    Arg= pP;
                if( bCouldBeEnd|| Arg->m_pLeft!= pP)
                    Arg= pP;
            }
            return Arg;
        }
    };

public: // Types
    class iterator;
    class const_iterator;
    class reverse_iterator;
    class const_reverse_iterator;
    friend class iterator;
    class iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class const_iterator;
        friend class reverse_iterator;
        friend class const_reverse_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_pointer m_pNode;
        NextInOrderNode< tree_node_pointer> m_fnNext;
        PrevInOrderNode< tree_node_pointer> m_fnPrev;

    public:
        iterator()
        { }
        explicit iterator( const tree_node_pointer& pN)
            :m_pNode( pN)
        { }
        iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        iterator& operator++()
        {
            // end()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        iterator& operator--()
        {
            // end()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };
    friend class const_iterator;
    class const_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_reverse_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_const_pointer m_pNode;
        NextInOrderNode< tree_node_const_pointer> m_fnNext;
        PrevInOrderNode< tree_node_const_pointer> m_fnPrev;

    public:
        const_iterator()
        { }
        explicit const_iterator( const tree_node_const_pointer& pN)
            :m_pNode( pN)
        { }
        const_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        const_iterator& operator++()
        {
            // end()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        const_iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        const_iterator& operator--()
        {
            // end()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        const_iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const const_iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const const_iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };
    friend class reverse_iterator;
    class reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class iterator;
        friend class const_iterator;
        friend class const_reverse_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_pointer m_pNode;
        PrevInOrderNode< tree_node_pointer> m_fnNext;
        NextInOrderNode< tree_node_pointer> m_fnPrev;

    public:
        reverse_iterator()
        { }
        explicit reverse_iterator( const tree_node_pointer& pN)
            :m_pNode( pN)
        { }
        reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        reverse_iterator& operator++()
        {
            // rend()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        reverse_iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        reverse_iterator& operator--()
        {
            // rend()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        reverse_iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const reverse_iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const reverse_iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };
    friend class const_reverse_iterator;
    class const_reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_const_pointer m_pNode;
        PrevInOrderNode< tree_node_const_pointer> m_fnNext;
        NextInOrderNode< tree_node_const_pointer> m_fnPrev;

    public:
        const_reverse_iterator()
        { }
        explicit const_reverse_iterator( const tree_node_const_pointer& pN)
            :m_pNode( pN)
        { }
        const_reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        const_reverse_iterator& operator++()
        {
            // rend()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        const_reverse_iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        const_reverse_iterator& operator--()
        {
            // rend()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        const_reverse_iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const const_reverse_iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const const_reverse_iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };

protected: // Variables
    tree_node_pointer m_pHead;
    size_type m_uiNodes;
    key_compare m_key_compare;
    key_extract m_key_extract;
    tree_node_allocator_type m_allocator;

protected: // Functions
    void BuildHeadNode()
    {
        m_pHead= m_allocator.allocate( 1);
        new (&m_pHead->m_pLeft) tree_node_pointer( m_pHead);
        new (&m_pHead->m_pParent) tree_node_pointer( NULL);
        new (&m_pHead->m_pRight) tree_node_pointer( m_pHead);
        new (&m_pHead->m_bRed) bool( true);
    }
    void DestroyHeadNode()
    {
        m_pHead->m_pLeft.~list_node_pointer();
        m_pHead->m_pParent.~list_node_pointer();
        m_pHead->m_pRight.~list_node_pointer();
        m_pHead->m_bRed.~bool();
        m_allocator.deallocate( m_pHead, 1);
    }
    void RotateLeft( tree_node_pointer pX)
    {
        tree_node_pointer pY( pX->m_pRight);
        pX->m_pRight= pY->m_pLeft;
        if( pY->m_pLeft!= NULL)
            pY->m_pLeft->m_pParent= pX;
        pY->m_pParent= pX->m_pParent;
        if( pX== m_pHead->m_pParent)
            m_pHead->m_pParent= pY;
        else if( pX== pX->m_pParent->m_pLeft)
            pX->m_pParent->m_pLeft= pY;
        else
            pX->m_pParent->m_pRight= pY;
        pY->m_pLeft= pX;
        pX->m_pParent= pY;
    }
    void RotateRight( tree_node_pointer pX)
    {
        tree_node_pointer pY( pX->m_pLeft);
        pX->m_pLeft= pY->m_pRight;
        if( pY->m_pRight!= NULL)
            pY->m_pRight->m_pParent= pX;
        pY->m_pParent= pX->m_pParent;
        if( pX== m_pHead->m_pParent)
            m_pHead->m_pParent= pY;
        else if( pX== pX->m_pParent->m_pRight)
            pX->m_pParent->m_pRight= pY;
        else
            pX->m_pParent->m_pLeft= pY;
        pY->m_pRight= pX;
        pX->m_pParent= pY;
    }
    void RecDelete( tree_node_pointer pX)
    {
        for( tree_node_pointer pY( pX); pY!= NULL; pX= pY)
        {
            RecDelete( pY->m_pRight);
            pY= pY->m_pLeft;
            m_allocator.destroy( pX);
            m_allocator.deallocate( pX, 1);
        }
    }
    tree_node_pointer lowerbound( const key_type& k) const
    {
        tree_node_pointer pX( m_pHead->m_pParent);
        tree_node_pointer pY( m_pHead);
        while( pX!= NULL)
        {
            if( m_key_compare( m_key_extract( pX->m_Value), k))
                pX= pX->m_pRight;
            else
            {
                pY= pX;
                pX= pX->m_pLeft;
            }
        }
        return pY;
    }
    tree_node_pointer upperbound( const key_type& k) const
    {
        tree_node_pointer pX( m_pHead->m_pParent);
        tree_node_pointer pY( m_pHead);
        while( pX!= NULL)
        {
            if( m_key_compare( k, m_key_extract( pX->m_Value)))
            {
                pY= pX;
                pX= pX->m_pLeft;
            }
            else
                pX= pX->m_pRight;
        }
        return pY;
    }
    iterator Insert( tree_node_pointer pX,
        tree_node_pointer pY, const value_type& V)
    {
        tree_node_pointer pZ( m_allocator.allocate( 1));
        m_allocator.construct( pZ, tree_node( pY, V, true));
        ++m_uiNodes;

        if( pY== m_pHead|| pX!= NULL||
            m_key_compare( m_key_extract( V), m_key_extract( pY->m_Value)))
        {
            pY->m_pLeft= pZ;
            if( pY== m_pHead)
            {
                m_pHead->m_pParent= pZ;
                m_pHead->m_pRight= pZ;
            }
            else if( pY== m_pHead->m_pLeft)
                m_pHead->m_pLeft= pZ;
        }
        else
        {
            pY->m_pRight= pZ;
            if( pY== m_pHead->m_pRight)
                m_pHead->m_pRight= pZ;
        }

        for( pX= pZ; pX!= m_pHead->m_pParent&& pX->m_pParent->m_bRed; )
        {
            if( pX->m_pParent== pX->m_pParent->m_pParent->m_pLeft)
            {
                pY= pX->m_pParent->m_pParent->m_pRight;
                if( pY!= NULL&& pY->m_bRed)
                {
                    pX->m_pParent->m_bRed= false;
                    pY->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    pX= pX->m_pParent->m_pParent;
                }
                else
                {
                    if( pX== pX->m_pParent->m_pRight)
                    {
                        pX= pX->m_pParent;
                        RotateLeft( pX);
                    }
                    pX->m_pParent->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    RotateRight( pX->m_pParent->m_pParent);
                }
            }
            else
            {
                pY= pX->m_pParent->m_pParent->m_pLeft;
                if( pY!= NULL&& pY->m_bRed)
                {
                    pX->m_pParent->m_bRed= false;
                    pY->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    pX= pX->m_pParent->m_pParent;
                }
                else
                {
                    if( pX== pX->m_pParent->m_pLeft)
                    {
                        pX= pX->m_pParent;
                        RotateRight( pX);
                    }
                    pX->m_pParent->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    RotateLeft( pX->m_pParent->m_pParent);
                }
            }
        }
        m_pHead->m_pParent->m_bRed= false;
        return iterator( pZ);
    }

public: // Functions
    iterator begin()
    { return iterator( m_pHead->m_pLeft); }
    const_iterator begin() const
    { return const_iterator( m_pHead->m_pLeft); }
    iterator end()
    { return iterator( m_pHead); }
    const_iterator end() const
    { return const_iterator( m_pHead); }
    reverse_iterator rbegin()
    { return reverse_iterator( m_pHead->m_pRight); }
    const_reverse_iterator rbegin() const
    { return const_reverse_iterator( m_pHead->m_pRight); }
    reverse_iterator rend()
    { return reverse_iterator( m_pHead); }
    const_reverse_iterator rend() const
    { return const_reverse_iterator( m_pHead); }
    size_type size() const
    { return m_uiNodes; }
    size_type max_size() const
    { return m_allocator.max_size(); }
    bool empty() const
    { return 0== size(); }
    key_compare key_comp() const
    { return m_key_compare; }
    explicit RBTree( const CompareKey& CmpKey= CompareKey(), const ExtractKey&
        ExKey= ExtractKey(), const Allocator& A= Allocator()): m_pHead( NULL),
        m_uiNodes( 0), m_key_compare( CmpKey), m_key_extract( ExKey),
        m_allocator( A)
    {
        BuildHeadNode();
    }
    RBTree( const tree_type& Other): m_pHead( NULL), m_uiNodes( 0),
        m_key_compare( Other.m_key_compare), m_key_extract( Other.m_key_extract),
        m_allocator( Other.m_allocator)
    {
        BuildHeadNode();
        try {
            *this= Other;
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    ~RBTree()
    {
        clear();
        DestroyHeadNode();
    }
    tree_type& operator=( const tree_type& x)
    {
        if( this!= &x)
        {
            erase( begin(), end());
            m_key_compare= x.m_key_compare;
            m_key_extract= x.m_key_extract;
            insert_equal( x.begin(), x.end());
        }
        return (*this);
    }
    allocator_type get_allocator() const
    { return m_allocator; }
    void swap( const tree_type& x)
    {
        swap( m_key_compare, x.m_key_compare);
        swap( m_key_extract, x.m_key_extract);
        if( m_allocator== x.m_allocator)
        {
            swap( m_pHead, x.m_pHead);
            swap( m_uiNodes, x.m_uiNodes);
        }
        else
        {
            tree_type Temp( *this);
            *this= x;
            x= Temp;
        }
    }
    friend void swap( tree_type& x, tree_type& y)
    { x.swap( y); }
    pair< iterator, bool> insert_unique( const value_type& x)
    {
        tree_node_pointer pA( m_pHead->m_pParent);
        tree_node_pointer pB( m_pHead);

        const key_type XKey( m_key_extract( x));
        bool bCmp( true);
        while( pA!= NULL)
        {
            pB= pA;
            bCmp= m_key_compare( XKey, m_key_extract( pA->m_Value));
            pA= (bCmp? pA->m_pLeft: pA->m_pRight);
        }

        iterator itP( pB);
        if( bCmp)
        {
            if( itP== begin())
                return pair< iterator, bool>( Insert( pA, pB, x), true);
            else
                --itP;
        }
        if( m_key_compare( m_key_extract( itP.m_pNode->m_Value), XKey))
            return pair< iterator, bool>( Insert( pA, pB, x), true);
        return pair< iterator, bool>( itP, false);
    }
    iterator insert_unique( iterator pP, const value_type& x)
    {
        return insert_unique( x).first;
    }
    template< class ForwardIterator>
    void insert_unique( ForwardIterator f, ForwardIterator l)
    {
        while( f!= l)
        {
            insert_unique( *f);
            ++f;
        }
    }
    iterator insert_equal( const value_type& x)
    {
        tree_node_pointer pA( m_pHead->m_pParent);
        tree_node_pointer pB( m_pHead);

        const key_type XKey( m_key_extract( x));
        bool bCmp( true);
        while( pA!= NULL)
        {
            pB= pA;
            bCmp= m_key_compare( XKey, m_key_extract( pA->m_Value));
            pA= (bCmp? pA->m_pLeft: pA->m_pRight);
        }

        return iterator( Insert( pA, pB, x));
    }
    iterator insert_equal( iterator pP, const value_type& x)
    {
        return insert_equal( x);
    }
    template< class ForwardIterator>
    void insert_equal( ForwardIterator f, ForwardIterator l)
    {
        while( f!= l)
        {
            insert_equal( *f);
            ++f;
        }
    }
    iterator erase( iterator itDel)
    {
        tree_node_pointer pW;
        tree_node_pointer pX;
        tree_node_pointer pY( itDel.m_pNode);
        tree_node_pointer pZ( pY);
        ++itDel;
        if( pY->m_pLeft== NULL)
            pX= pY->m_pRight;
        else if( pY->m_pRight== NULL)
            pX= pY->m_pLeft;
        else
        {
            pY= pY->m_pRight;
            while( pY->m_pLeft!= NULL)
                pY= pY->m_pLeft;
            pX= pY->m_pRight;
        }
        tree_node_pointer pXParent( pY);
        if( pY!= pZ)
        {
            pZ->m_pLeft->m_pParent= pY;
            pY->m_pLeft= pZ->m_pLeft;

            if( pY== pZ->m_pRight)
                (pX!= NULL? pX->m_pParent= pXParent= pY: pXParent= pY);
            else
            {
                (pX!= NULL? pX->m_pParent= pXParent= pY->m_pParent: pXParent= pY->m_pParent);
                pY->m_pParent->m_pLeft= pX;
                pY->m_pRight= pZ->m_pRight;
                pZ->m_pRight->m_pParent= pY;
            }
            
            if( m_pHead->m_pParent== pZ)
                m_pHead->m_pParent= pY;
            else if( pZ->m_pParent->m_pLeft== pZ)
                pZ->m_pParent->m_pLeft= pY;
            else
                pZ->m_pParent->m_pRight= pY;

            pY->m_pParent= pZ->m_pParent;
            const bool bTmp( pY->m_bRed);
            pY->m_bRed= pZ->m_bRed;
            pZ->m_bRed= bTmp;
            pY= pZ;
        }
        else
        {
            (pX!= NULL? pX->m_pParent= pXParent= pY->m_pParent: pXParent= pY->m_pParent);
            if( m_pHead->m_pParent== pZ)
                m_pHead->m_pParent= pX;
            else if( pZ->m_pParent->m_pLeft== pZ)
                pZ->m_pParent->m_pLeft= pX;
            else
                pZ->m_pParent->m_pRight= pX;

            if( m_pHead->m_pLeft== pZ)
            {
                if( pZ->m_pRight== NULL)
                    m_pHead->m_pLeft= pZ->m_pParent;
                else
                {
                    m_pHead->m_pLeft= pX;
                    while( m_pHead->m_pLeft->m_pLeft!= NULL)
                        m_pHead->m_pLeft= m_pHead->m_pLeft->m_pLeft;
                }
            }
            if( m_pHead->m_pRight== pZ)
            {
                if( pZ->m_pLeft== NULL)
                    m_pHead->m_pRight= pZ->m_pParent;
                else
                {
                    m_pHead->m_pRight= pX;
                    while( m_pHead->m_pRight->m_pRight!= NULL)
                        m_pHead->m_pRight= m_pHead->m_pRight->m_pRight;
                }
            }
        }
        if( !pY->m_bRed)
        {
            while( pX!= m_pHead->m_pParent&& (pX== NULL|| !pX->m_bRed))
            {
                if( pX== pXParent->m_pLeft)
                {
                    pW= pXParent->m_pRight;
                    if( pW->m_bRed)
                    {
                        pW->m_bRed= false;
                        pXParent->m_bRed= true;
                        RotateLeft( pXParent);
                        pW= pXParent->m_pRight;
                    }
                    if( (pW->m_pLeft== NULL|| !pW->m_pLeft->m_bRed)&&
                        (pW->m_pRight== NULL|| !pW->m_pRight->m_bRed) )
                    {
                        pW->m_bRed= true;
                        pX= pXParent;
                        pXParent= pXParent->m_pParent;
                    }
                    else
                    {
                        if( pW->m_pRight== NULL|| !pW->m_pRight->m_bRed)
                        {
                            pW->m_pLeft->m_bRed= false;
                            pW->m_bRed= true;
                            RotateRight( pW);
                            pW= pXParent->m_pRight;
                        }
                        pW->m_bRed= pXParent->m_bRed;
                        pXParent->m_bRed= false;
                        pW->m_pRight->m_bRed= false;
                        RotateLeft( pXParent);
                        break;
                    }
                }
                else
                {
                    pW= pXParent->m_pLeft;
                    if( pW->m_bRed)
                    {
                        pW->m_bRed= false;
                        pXParent->m_bRed= true;
                        RotateRight( pXParent);
                        pW= pXParent->m_pLeft;
                    }
                    if( (pW->m_pLeft== NULL|| !pW->m_pLeft->m_bRed)&&
                        (pW->m_pRight== NULL|| !pW->m_pRight->m_bRed) )
                    {
                        pW->m_bRed= true;
                        pX= pXParent;
                        pXParent= pXParent->m_pParent;
                    }
                    else
                    {
                        if( pW->m_pLeft== NULL|| !pW->m_pLeft->m_bRed)
                        {
                            pW->m_pRight->m_bRed= false;
                            pW->m_bRed= true;
                            RotateLeft( pW);
                            pW= pXParent->m_pLeft;
                        }
                        pW->m_bRed= pXParent->m_bRed;
                        pXParent->m_bRed= false;
                        pW->m_pLeft->m_bRed= false;
                        RotateRight( pXParent);
                        break;
                    }
                }
            }
            if( pX!= NULL)
                pX->m_bRed= false;
        }
        m_allocator.destroy( pY);
        m_allocator.deallocate( pY, 1);
        --m_uiNodes;
        return itDel;
    }
    iterator erase( iterator f, iterator l)
    {
        if( 0== size()|| f!= begin() || l!= end())
        {
            while( f!= l)
                f= erase( f);
            return f;
        }
        clear();
        return begin();
    }
    size_type erase( const key_type& k)
    {
        const pair< iterator, iterator> EqRng( equal_range( k));
        size_type n( 0);
        iterator itCur( EqRng.first);
        while( itCur!= EqRng.second)
        {
            ++itCur;
            ++n;
        }
        erase( EqRng.first, EqRng.second);
        return n;
    }
    void clear()
    {
        RecDelete( m_pHead->m_pParent);
        m_uiNodes= 0;
        m_pHead->m_pParent= NULL;
        m_pHead->m_pRight= m_pHead->m_pLeft= m_pHead;
    }
    iterator find( const key_type& k)
    {
        iterator itLB( lower_bound( k));
        return( itLB== end()|| m_key_compare( k, m_key_extract(
            itLB.m_pNode->m_Value))? end(): itLB);
    }
    const_iterator find( const key_type& k) const
    {
        const_iterator itLB( lower_bound( k));
        return( itLB== end()|| m_key_compare( k, m_key_extract(
            itLB.m_pNode->m_Value))? end(): itLB);
    }
    size_type count( const key_type& k) const
    {
        const pair< const_iterator, const_iterator> EqRng( equal_range( k));
        size_type n( 0);
        const_iterator itCur( EqRng.first);
        while( itCur!= EqRng.second)
        {
            ++itCur;
            ++n;
        }
        return n;
    }
    iterator lower_bound( const key_type& k)
    { return iterator( lowerbound( k)); }
    const_iterator lower_bound( const key_type& k) const
    { return const_iterator( lowerbound( k)); }
    iterator upper_bound( const key_type& k)
    { return iterator( upperbound( k)); }
    const_iterator upper_bound( const key_type& k) const
    { return const_iterator( upperbound( k)); }
    pair< iterator, iterator> equal_range( const key_type& k)
    { return pair< iterator, iterator>( lower_bound( k), upper_bound( k)); }
    pair< const_iterator, const_iterator> equal_range( const key_type& k) const
    { return pair< const_iterator, const_iterator>( lower_bound( k), upper_bound( k)); }
#if 0
    pair< bool, int> InValid( tree_node_pointer pNode, tree_node_pointer pParent, bool bParentRed)
    {
        pair< bool, int> RightRet( false, 1);
        if( pNode->m_pRight!= NULL)
            RightRet= InValid( pNode->m_pRight, pNode, pNode->m_bRed);

        pair< bool, int> LeftRet( false, 1);
        if( pNode->m_pLeft!= NULL)
            LeftRet= InValid( pNode->m_pLeft, pNode, pNode->m_bRed);

        return pair< bool, int>( pNode->m_pParent!= pParent|| RightRet.first|| LeftRet.first||
            RightRet.second!= LeftRet.second|| (bParentRed&& pNode->m_bRed),
            RightRet.second+ (pNode->m_bRed? 0: 1));
    }
    bool valid()
    {
        if( m_pHead->m_pParent!= NULL)
        {
            bool bInvalid( InValid( m_pHead->m_pParent, m_pHead, m_pHead->m_bRed).first);

            tree_node_pointer pChk= m_pHead->m_pParent;
            while( pChk->m_pLeft!= NULL)
                pChk= pChk->m_pLeft;
            bInvalid|= (pChk!= m_pHead->m_pLeft);

            pChk= m_pHead->m_pParent;
            while( pChk->m_pRight!= NULL)
                pChk= pChk->m_pRight;
            bInvalid|= (pChk!= m_pHead->m_pRight);

            return !bInvalid;
        }
        else
            return true;
    }
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\inc\set.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class Compare= less<Key>, class Allocator= allocator<Key> >
class set:
    public RBTree< Key, Key, identity<Key>, Compare, Allocator>
{
public: // Types
    typedef set< Key, Compare, Allocator> set_type;
    typedef RBTree< Key, Key, identity<Key>, Compare, Allocator> tree_type;

    typedef tree_type::value_type value_type;
    typedef tree_type::key_type key_type;
    typedef tree_type::key_compare key_compare;
    typedef tree_type::key_compare value_compare;
    typedef tree_type::pointer pointer;
    typedef tree_type::const_pointer const_pointer;
    typedef tree_type::reference reference;
    typedef tree_type::const_reference const_reference;
    typedef tree_type::size_type size_type;
    typedef tree_type::difference_type difference_type;
    typedef tree_type::iterator iterator;
    typedef tree_type::const_iterator const_iterator;
    typedef tree_type::reverse_iterator reverse_iterator;
    typedef tree_type::const_reverse_iterator const_reverse_iterator;
    typedef tree_type::allocator_type allocator_type;

public: // Functions
    using tree_type::begin;
    using tree_type::end;
    using tree_type::rbegin;
    using tree_type::rend;
    using tree_type::size;
    using tree_type::max_size;
    using tree_type::empty;
    using tree_type::key_comp;
    value_compare value_comp() const
    { return key_comp(); }
    explicit set( const Compare& comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp, identity<Key>(), A)
    { }
    template< class InputIterator>
    set( InputIterator f, InputIterator l, const Compare comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp, identity<Key>(), A)
    {
        insert_unique( f, l);
    }
    set( const set_type& Other): tree_type( Other)
    { }
    ~set()
    { }
    set_type& operator=( const set_type& Other)
    {
        tree_type::operator=( Other);
        return *this;
    }
    using tree_type::get_allocator;
    void swap( const set_type& Other)
    { tree_type::swap( Other); }
    pair< iterator, bool> insert( const value_type& x)
    { return insert_unique( x); }
    iterator insert( iterator pos, const value_type& x)
    { return insert_unique( x); }
    template< class InputIterator>
    void insert( InputIterator f, InputIterator l)
    { insert_unique( f, l); }
    using tree_type::erase;
    using tree_type::find;
    using tree_type::count;
    using tree_type::lower_bound;
    using tree_type::upper_bound;
    using tree_type::equal_range;
};

template< class Key, class Compare, class Allocator>
bool operator==( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return x.size()== y.size()&& equal( x.begin(), x.end(), y.begin());
}
template< class Key, class Compare, class Allocator>
bool operator!=( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return !(x== y);
}
template< class Key, class Compare, class Allocator>
bool operator<( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return lexicographical_compare( x.begin(), x.end(), y.begin(), y.end());
}
template< class Key, class Compare, class Allocator>
bool operator>( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return y< x;
}
template< class Key, class Compare, class Allocator>
bool operator<=( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return !(y< x);
}
template< class Key, class Compare, class Allocator>
bool operator>=( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return !(x< y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnpars.h ===
//----------------------------------------------------------------------------
//
// cspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "cbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min< UINT16>(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min< UINT16>(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC)<<8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnutil.h ===
//----------------------------------------------------------------------------
//
// cspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\rgb.inc ===
RGBRASTROOT = $(SWRASTROOT)\rgb

MAJORCOMP = d3d
MINORCOMP = rgbrast

INCLUDES = $(RGBRASTROOT)\pch\$(_OBJ_DIR)\$(TARGET_DIRECTORY);$(RGBRASTROOT)\pch;$(INCLUDES)

# RGB needs __cdecl default.
386_STDCALL=0

# The framework, and hence RGB require these.
USE_NATIVE_EH=1
USE_STL=1

# Uncomment out if would like to use CRT debugging.
#
#!IF "$(NTDEBUG)" == "ntsd"
#DEBUG_CRTS=1
#!ENDIF

# Disable MASM 5.x compatibility
NOMASMCOMPATIBILITY = 1

# Use MASM 6.11d for assembly since 6.11a doesn't handle the MMX
# macros properly.
386_ASSEMBLER_NAME = ml611d
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "cbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits)
{
    INT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\ctexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "cbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];
//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0x00);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min< UINT16>((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min< UINT16>((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min< UINT16>((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min< UINT16>((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min< UINT16>((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min< UINT16>((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min< UINT16>((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min< UINT16>((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min< UINT16>((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// C_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnutil.cpp ===
//----------------------------------------------------------------------------
//
// cspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\ctexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "ctexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\dll\main.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{
auto_ptr< CRGBDriver> g_pRGBDriver;
}

CRGBDriver* CRGBDriver::sm_pGlobalDriver= NULL;

DX8SDDIFW::COSDetector DX8SDDIFW::g_OSDetector;

HRESULT APIENTRY
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
    DWORD* pNumTextures, DDSURFACEDESC** ppTexList)
{
    return g_pRGBDriver->GetSWInfo( *pCaps, *pCallbacks, *pNumTextures, *ppTexList);
}

BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            try {
                CRGBDriver::InitSupportedSurfaceArray();
                g_pRGBDriver= auto_ptr< CRGBDriver>( new CRGBDriver);
            } catch( ...) {
            }
            if( g_pRGBDriver.get()== NULL)
                return FALSE;
            break;

        // DLL_PROCESS_DETACH will be called if ATTACH returned FALSE.
        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\lib\main.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

// #include <d3d8rgbrast.h>
// Need to share some kind of header which has:
// #ifndef __D3D8RGBRAST_H__
// #define __D3D8RGBRAST_H__
//
// #ifdef __cplusplus
// extern "C" {
// #endif //__cplusplus
//
// extern void* D3D8RGBRasterizer;
//
// #ifdef __cplusplus
// }
// #endif //__cplusplus
//
// #endif //__D3D8RGBRAST_H__

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

extern void* D3D8RGBRasterizer;

#ifdef __cplusplus
}
#endif //__cplusplus

namespace RGB_RAST_LIB_NAMESPACE
{
auto_ptr< CRGBDriver> g_pRGBDriver;

HRESULT APIENTRY
GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
    DWORD* pNumTextures, DDSURFACEDESC** ppTexList)
{
    if( g_pRGBDriver.get()!= NULL)
        return g_pRGBDriver->GetSWInfo( *pCaps, *pCallbacks, *pNumTextures, *ppTexList);
    else
    {
        try {
            CRGBDriver::InitSupportedSurfaceArray();
            g_pRGBDriver= auto_ptr< CRGBDriver>( new CRGBDriver);
        } catch( ... )
        { }
        if( g_pRGBDriver.get()!= NULL)
            return g_pRGBDriver->GetSWInfo( *pCaps, *pCallbacks, *pNumTextures, *ppTexList);
        else
            return E_OUTOFMEMORY;
    }
}
}

CRGBDriver* CRGBDriver::sm_pGlobalDriver= NULL;

DX8SDDIFW::COSDetector DX8SDDIFW::g_OSDetector;

void* D3D8RGBRasterizer= reinterpret_cast<void*>(RGB_RAST_LIB_NAMESPACE::GetSWInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\main\assert.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{
bool Assert(LPCSTR szFile, int nLine, LPCSTR szCondition)
{
    typedef BOOL (*PFNBV)(VOID);

    static bool bInit( false);
    static PFNBV pIsDebuggerPresent= NULL;

    LONG err;
    char str[256];

    // Initialize stuff
    if(!bInit)
    {
        HINSTANCE hinst;
        bInit= true;

        // Get IsDebuggerPresent entry point
        if((hinst = (HINSTANCE) GetModuleHandle("kernel32.dll")) ||
           (hinst = (HINSTANCE) LoadLibrary("kernel32.dll")))
        {
            pIsDebuggerPresent = (PFNBV) GetProcAddress(hinst, "IsDebuggerPresent");
        }
    }

    // Display a message box if no debugger is present
    if(pIsDebuggerPresent && !pIsDebuggerPresent())
    {
        _snprintf(str, sizeof(str), "File:\t %s\nLine:\t %d\nAssertion:\t%s\n\nDo you want to invoke the debugger?", szFile, nLine, szCondition);
	    err = MessageBox(NULL, str, "RGBRast Assertion Failure", MB_SYSTEMMODAL | MB_YESNOCANCEL);

        switch(err)
        {
        case IDYES:     return true;
        case IDNO:      return false;
        case IDCANCEL:  FatalAppExit(0, "RGBRast Assertion Failure.. Application terminated"); return true;
        }
    }

	return true;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\cspan\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\ccrbd_mh.h: ccrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ccrgn_mh.h: ccrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctest_mh.h: ctest_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxa_mh.h: ctxa_mh.mh ctexaddr.mh $(RAST_STD_M4)


$(GENTGT)\ctxbd_mh.h: ctxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxrd_mh.h: ctxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctstf_mh.h: ctstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\catest_mh.h: catest_mh.mh $(RAST_STD_M4)

$(GENTGT)\cbeadtbl.cpp: cbeadtbl.mcp $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)

$(GENTGT)\cclrbld.cpp: cclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\cclrgen.cpp: cclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\cloop.cpp: cloop.mcp ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctest.cpp: ctest.mcp $(RAST_STD_M4)

$(GENTGT)\ctxaddr.cpp: ctxaddr.mcp ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxblend.cpp: ctxblend.mcp $(RAST_STD_M4)

$(GENTGT)\ctexread.cpp: ctexread.mcp $(RAST_STD_M4)

$(GENTGT)\catest.cpp: catest.mcp $(RAST_STD_M4)

$(GENTGT)\ctstfail.cpp: ctstfail.mcp ctexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\main\context.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

// Streaming SIMD2 Extensions (aka Willamete) CPU
#define D3DCPU_WLMT         0x000000040L

//---------------------------------------------------------------------
BOOL
IsWin95(void)
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            return FALSE;
        }
        else
        {
            // is Win95
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        return FALSE;
    }
    return TRUE;
}

#if defined(_X86_)
// --------------------------------------------------------------------------
// Detect 3D extensions
// --------------------------------------------------------------------------
static BOOL _asm_isX3D()
{
    DWORD retval = 0;
    _asm
        {
            pushad                      ; CPUID trashes lots - save everything
            mov     eax,80000000h       ; Check for extended CPUID support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            cmp     eax,80000001h       ; Jump if no extended CPUID
            jb      short done          ;

            mov     eax,80000001h       ; Check for feature
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            xor     eax,eax             ;
            test    edx,80000000h       ;
            setnz   al                  ;
            mov     retval,eax          ;

done:
            popad               ; Restore everything
        };
    return retval;
}

static BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            test    edx,00800000h   ; Set flags before restoring registers

            popad               ; Restore everything

            setnz    al             ; Set return value
            mov     retval, eax
        };
    return retval;
}

static BOOL isX3Dprocessor(void)
{
    __try
    {
            if( _asm_isX3D() )
            {
            return TRUE;
            }
    }
    __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
    }
    return FALSE;
}
//---------------------------------------------------------------------
// Detects Intel SSE processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

#define SSE_PRESENT 0x02000000                  // bit number 25
#define WNI_PRESENT 0x04000000                  // bit number 26

static BOOL isMMXprocessor(void)
{
    __try
        {
            if( _asm_isMMX() )
            {

                // Emit an emms instruction.
                // This file needs to compile for non-Pentium
                // processors
                // so we can't use use inline asm since we're in the
                // wrong
                // processor mode.
                __asm __emit 0xf;
                __asm __emit 0x77;
                return TRUE;
            }
        }
    __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
        {
        }
    return FALSE;
}

DWORD IsIntelSSEProcessor(void)
{
        DWORD retval = 0;
        DWORD RegisterEAX;
        DWORD RegisterEDX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return retval;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return retval;

        // this CPUID can't fail if the above test passed
        __asm {
                mov eax,1
                CPUID
                mov RegisterEAX,eax
                mov RegisterEDX,edx
        }

        if (RegisterEDX  & SSE_PRESENT) {
                retval |= D3DCPU_SSE;
        }

        if (RegisterEDX  & WNI_PRESENT) {
                retval |= D3DCPU_WLMT;
        }

        return retval;
}
#pragma optimize("", on)

#ifndef PF_XMMI_INSTRUCTIONS_AVAILABLE
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6
#endif

#ifndef PF_3DNOW_INSTRUCTIONS_AVAILABLE
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7
#endif

#ifndef PF_XMMI64_INSTRUCTIONS_AVAILABLE
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10
#endif

static BOOL D3DIsProcessorFeaturePresent(UINT feature)
{
    switch (feature)
    {
    case PF_MMX_INSTRUCTIONS_AVAILABLE:
        {
            return isMMXprocessor();
        }
    case PF_XMMI_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_SSE;
        }
    case PF_3DNOW_INSTRUCTIONS_AVAILABLE: return isX3Dprocessor();
    case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_WLMT;
        }
    default: return FALSE;
    }
}
#endif // _X86_

const UINT CRGBContext::c_uiBegan( 1);

DWORD CRGBContext::DetectBeadSet( void) throw()
{
#if defined(_X86_)
    if( D3DIsProcessorFeaturePresent( PF_MMX_INSTRUCTIONS_AVAILABLE))
        return D3DIBS_MMXASRGB;
#endif
    return D3DIBS_C;
}

// TConstDP2Bindings type MUST be updated with size of this array,
// unfortunately.
const CRGBContext::TDP2Bindings CRGBContext::c_DP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          DP2ViewportInfo,
    D3DDP2OP_WINFO,                 DP2WInfo,
    D3DDP2OP_RENDERSTATE,           DP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     DP2TextureStageState,
    D3DDP2OP_CLEAR,                 DP2Clear,
    D3DDP2OP_SETRENDERTARGET,       DP2SetRenderTarget,
    D3DDP2OP_SETVERTEXSHADER,       DP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       DP2SetStreamSource,
    D3DDP2OP_SETSTREAMSOURCEUM,     DP2SetStreamSourceUM,
    D3DDP2OP_SETINDICES,            DP2SetIndices,
    D3DDP2OP_DRAWPRIMITIVE,         DP2DrawPrimitive,
    D3DDP2OP_DRAWPRIMITIVE2,        DP2DrawPrimitive2,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE,  DP2DrawIndexedPrimitive,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2, DP2DrawIndexedPrimitive2,
    D3DDP2OP_CLIPPEDTRIANGLEFAN,    DP2ClippedTriangleFan,
    D3DDP2OP_SETPALETTE,            DP2SetPalette,
    D3DDP2OP_UPDATEPALETTE,         DP2UpdatePalette
};

// TConstRecDP2Bindings type MUST be updated with size of this array,
// unfortunately.
const CRGBContext::TRecDP2Bindings CRGBContext::c_RecDP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          RecDP2ViewportInfo,
    D3DDP2OP_WINFO,                 RecDP2WInfo,
    D3DDP2OP_RENDERSTATE,           RecDP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     RecDP2TextureStageState,
    D3DDP2OP_SETVERTEXSHADER,       RecDP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       RecDP2SetStreamSource,
    D3DDP2OP_SETINDICES,            RecDP2SetIndices
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxemul\mmxemul.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains routines that emulate MMX instructions in ordinary C
// for algorithm development.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "d3dtypesp.h"
#include "d3ditype.h"
#include "mmxemul.h"

UINT16 MMX_addsw(INT16 x, INT16 y)
{
    INT32 z = x + y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

INT16  MMX_addusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x + (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}

UINT16 MMX_cmpeqw(INT16 x, INT16 y)
{
    if (x == y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

UINT16 MMX_cmpgtw(INT16 x, INT16 y)
{
    if (x > y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

// Emulate 16 bit MMX style multiplies
// Note that MULHW only works with signed operands, but MULLW works for
// signed and unsigned operands.
INT16 MMX_mulhw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = (INT16)(z>>16);
    return r;
}

INT16 MMX_mullw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = z & 0xffff;
    return r;
}

INT16 MMX_subsw(INT16 x, INT16 y)
{
    INT32 z = x - y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

UINT16 MMX_subusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x - (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\bldfuncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void MMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\main\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\bufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR MMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR MMX_BufRead_Palette8(PUINT8 pBits);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\bufwrite.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void MMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\loop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\main\driver.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace D3D8RGBRast
{

const D3DCAPS8 CRGBDriver::c_D3DCaps=
{
    // Indicates this is software rasterizer.
    /*D3DDEVTYPE_HAL|| D3DDEVTYPE_REF||*/ D3DDEVTYPE_SW,

    // Adapter ordinal (isn't used to report anything).
    0,

    // Caps (See ddraw.h & d3d8caps.h for details of each CAP).
    /*DDCAPS_3D| DDCAPS_ALIGNBOUNDARYDEST| DDCAPS_ALIGNSIZEDEST|
    DDCAPS_ALIGNBOUNDARYSRC| DDCAPS_ALIGNSIZESRC| DDCAPS_ALIGNSTRIDE|
    DDCAPS_BLT| DDCAPS_BLTQUEUE| DDCAPS_BLTFOURCC| DDCAPS_BLTSTRETCH|
    DDCAPS_GDI| DDCAPS_OVERLAY| DDCAPS_OVERLAYCANTCLIP| DDCAPS_OVERLAYFOURCC|
    DDCAPS_OVERLAYSTRETCH|*/ DDCAPS_PALETTE| /*DDCAPS_PALETTEVSYNC| 
    DDCAPS_READSCANLINE| DDCAPS_VBI| DDCAPS_ZBLTS| DDCAPS_ZOVERLAYS|
    DDCAPS_COLORKEY| DDCAPS_ALPHA| DDCAPS_COLORKEYHWASSIST| DDCAPS_NOHARDWARE|
    DDCAPS_BLTCOLORFILL| DDCAPS_BANKSWITCHED| DDCAPS_BLTDEPTHFILL|
    DDCAPS_CANCLIP| DDCAPS_CANCLIPSTRETCHED| DDCAPS_CANBLTSYSMEM|
    D3DCAPS_READ_SCANLINE|*/ 0,

    // Caps2
    /*DDCAPS2_CERTIFIED| DDCAPS2_NO2DDURING3DSCENE| DDCAPS2_VIDEOPORT|
    DDCAPS2_AUTOFLIPOVERLAY| DDCAPS2_CANBOBINTERLEAVED| 
    DDCAPS2_CANBOBNONINTERLEAVED| DDCAPS2_COLORCONTROLOVERLAY| 
    DDCAPS2_COLORCONTROLPRIMARY|*/ DDCAPS2_CANDROPZ16BIT| 
    /*DDCAPS2_NONLOCALVIDMEM| DDCAPS2_NONLOCALVIDMEMCAPS| 
    DDCAPS2_NOPAGELOCKREQUIRED|*/ DDCAPS2_WIDESURFACES|
    /*DDCAPS2_CANFLIPODDEVEN| DDCAPS2_CANBOBHARDWARE| DDCAPS2_COPYFOURCC|
    DDCAPS2_PRIMARYGAMMA|*/ DDCAPS2_CANRENDERWINDOWED| 
    /*DDCAPS2_CANCALIBRATEGAMMA| DDCAPS2_FLIPINTERVAL|
    DDCAPS2_FLIPNOVSYNC| DDCAPS2_CANMANAGETEXTURE|
    DDCAPS2_TEXMANINNONLOCALVIDMEM| DDCAPS2_STEREO|
    DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL| D3DCAPS2_NO2DDURING3DSCENE| 
    D3DCAPS2_FULLSCREENGAMMA|*/ D3DCAPS2_CANRENDERWINDOWED|
    /*D3DCAPS2_CANCALIBRATEGAMMA|*/ 0,

    // Caps3
    0,
    // Presentation Intervals
    0,
    // Cursor Caps
    0,

    // DevCaps (See d3d8caps.h & d3dhal.h)
    // The SDDI driver should keep D3DDEVCAPS_TEXTUREVIDEOMEMORY enabled. The
    // runtime does not behave correctly if the driver does not enable and
    // support this cap. In other words, all textures must be able to be
    // vid mem (driver allocated) textures, at least.
    D3DDEVCAPS_EXECUTESYSTEMMEMORY| /*D3DDEVCAPS_EXECUTEVIDEOMEMORY|*/
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY| /*D3DDEVCAPS_TLVERTEXVIDEOMEMORY|*/
    D3DDEVCAPS_TEXTURESYSTEMMEMORY| D3DDEVCAPS_TEXTUREVIDEOMEMORY|
    D3DDEVCAPS_DRAWPRIMTLVERTEX| /*D3DDEVCAPS_CANRENDERAFTERFLIP|
    D3DDEVCAPS_TEXTURENONLOCALVIDMEM|*/ D3DDEVCAPS_DRAWPRIMITIVES2|
    /*D3DDEVCAPS_SEPARATETEXTUREMEMORIES|*/ D3DDEVCAPS_DRAWPRIMITIVES2EX|
    /*D3DDEVCAPS_HWTRANSFORMANDLIGHT| D3DDEVCAPS_CANBLTSYSTONONLOCAL|
    D3DDEVCAPS_HWRASTERIZATION| D3DDEVCAPS_PUREDEVICE| 
    D3DDEVCAPS_QUINTICRTPATCHES| D3DDEVCAPS_RTPATCHES|
    D3DDEVCAPS_RTPATCHHANDLEZERO| D3DDEVCAPS_NPATCHES|
	D3DDEVCAPS_HWVERTEXBUFFER| D3DDEVCAPS_HWINDEXBUFFER|*/ 0,

    // Primitive Misc Caps
    /*D3DPMISCCAPS_MASKZ| D3DPMISCCAPS_LINEPATTERNREP|*/ D3DPMISCCAPS_CULLNONE|
    D3DPMISCCAPS_CULLCW| D3DPMISCCAPS_CULLCCW| /*D3DPMISCCAPS_COLORWRITEENABLE|
    D3DPMISCCAPS_CLIPPLANESCALEDPOINTS| D3DPMISCCAPS_CLIPTLVERTS|
    D3DPMISCCAPS_TSSARGTEMP| D3DPMISCCAPS_BLENDOP|*/ 0,

    // Raster Caps
    D3DPRASTERCAPS_DITHER| D3DPRASTERCAPS_ROP2| D3DPRASTERCAPS_XOR| 
    /*D3DPRASTERCAPS_PAT|*/ D3DPRASTERCAPS_ZTEST| D3DPRASTERCAPS_FOGVERTEX|
    D3DPRASTERCAPS_FOGTABLE| /*D3DPRASTERCAPS_ANTIALIASEDGES|*/
    D3DPRASTERCAPS_MIPMAPLODBIAS| /*D3DPRASTERCAPS_ZBIAS|
    D3DPRASTERCAPS_ZBUFFERLESSHSR|*/ D3DPRASTERCAPS_FOGRANGE|
    /*D3DPRASTERCAPS_ANISOTROPY| D3DPRASTERCAPS_WBUFFER| 
    D3DPRASTERCAPS_WFOG| D3DPRASTERCAPS_ZFOG| 
    D3DPRASTERCAPS_COLORPERSPECTIVE| D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE|
    */ 0,

    // Z Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Src Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 
    D3DPBLENDCAPS_BOTHINVSRCALPHA| 0,

    // Dest Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 0,

    // Alpha Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Shade Caps 
    D3DPSHADECAPS_COLORGOURAUDRGB| D3DPSHADECAPS_SPECULARGOURAUDRGB| 
    D3DPSHADECAPS_ALPHAGOURAUDBLEND| D3DPSHADECAPS_FOGGOURAUD| 0,

    // Texture Caps
    D3DPTEXTURECAPS_PERSPECTIVE| D3DPTEXTURECAPS_POW2|
    D3DPTEXTURECAPS_ALPHA| /*D3DPTEXTURECAPS_SQUAREONLY|*/
    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE| D3DPTEXTURECAPS_ALPHAPALETTE|
    /*D3DPTEXTURECAPS_NONPOW2CONDITIONAL| D3DPTEXTURECAPS_PROJECTED| 
    D3DPTEXTURECAPS_CUBEMAP| D3DPTEXTURECAPS_VOLUMEMAP|*/ 
    D3DPTEXTURECAPS_MIPMAP| /*D3DPTEXTURECAPS_MIPVOLUMEMAP| 
    D3DPTEXTURECAPS_MIPCUBEMAP| D3DPTEXTURECAPS_CUBEMAP_POW2| 
    D3DPTEXTURECAPS_VOLUMEMAP_POW2|*/ 0,

    // Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    /*D3DPTFILTERCAPS_MINFANISOTROPIC|*/ D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| /*D3DPTFILTERCAPS_MAGFANISOTROPIC|*/
    /*D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC|*/ 0,

    // Cube Texture Filter Caps
    /*D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC|*/ 0,

    // Volume Texture Filter Caps
    /*D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC|*/ 0,

    // Texture Address Caps
    D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| /*D3DPTADDRESSCAPS_MIRRORONCE|*/ 0,

    // Volume Texture Address Caps
    /*D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| D3DPTADDRESSCAPS_MIRRORONCE|*/ 0,

    // Line Caps
    D3DLINECAPS_TEXTURE| D3DLINECAPS_ZTEST| D3DLINECAPS_BLEND| 
    D3DLINECAPS_ALPHACMP| D3DLINECAPS_FOG| 0,

    // Max Texture Width, Height, Volume Extent
    1024, 1024, 0,
    
    // Max Texture Repeat, Texture Aspect Ratio, Anisotropy
    256, 0, 1,

    // Max VertexW
    10000.0,

    // Guard Band left, top, right, bottom
    -4096.0f, -4096.0f, 4095.0f, 4095.0f,

    // Extents Adjust
    0.0f,

    // Stencil Caps
    D3DSTENCILCAPS_KEEP| D3DSTENCILCAPS_ZERO| D3DSTENCILCAPS_REPLACE|
    D3DSTENCILCAPS_INCRSAT| D3DSTENCILCAPS_DECRSAT| D3DSTENCILCAPS_INVERT|
    D3DSTENCILCAPS_INCR| D3DSTENCILCAPS_DECR| 0,

    // FVF Caps
    (8& D3DFVFCAPS_TEXCOORDCOUNTMASK)| D3DFVFCAPS_DONOTSTRIPELEMENTS|
    D3DFVFCAPS_PSIZE| 0,

    // TextureOpCaps
    D3DTEXOPCAPS_DISABLE| D3DTEXOPCAPS_SELECTARG1| D3DTEXOPCAPS_SELECTARG2|
    D3DTEXOPCAPS_MODULATE| D3DTEXOPCAPS_MODULATE2X| 
    D3DTEXOPCAPS_MODULATE4X| D3DTEXOPCAPS_ADD| D3DTEXOPCAPS_ADDSIGNED| 
    /*D3DTEXOPCAPS_ADDSIGNED2X| D3DTEXOPCAPS_SUBTRACT|
    D3DTEXOPCAPS_ADDSMOOTH|*/ D3DTEXOPCAPS_BLENDDIFFUSEALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHA| D3DTEXOPCAPS_BLENDFACTORALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHAPM| /*D3DTEXOPCAPS_BLENDCURRENTALPHA|
    D3DTEXOPCAPS_PREMODULATE| D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA|
    D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA| D3DTEXOPCAPS_BUMPENVMAP|
    D3DTEXOPCAPS_BUMPENVMAPLUMINANCE| D3DTEXOPCAPS_DOTPRODUCT3|
    D3DTEXOPCAPS_MULTIPLYADD| D3DTEXOPCAPS_LERP|*/ 0,
    
    // Max Texture Blend Stages, Simulatenous Textures
    D3DHAL_TSS_MAXSTAGES, D3DHAL_TSS_MAXSTAGES,

    // Vertex Processing Caps
    /*D3DVTXPCAPS_TEXGEN| D3DVTXPCAPS_MATERIALSOURCE7|
    D3DVTXPCAPS_DIRECTIONALLIGHTS| D3DVTXPCAPS_POSITIONALLIGHTS|
    D3DVTXPCAPS_LOCALVIEWER| D3DVTXPCAPS_TWEENING|*/ 0,

    // Max Active Lights, User Clip Planes, Vertex Blend Matrices
    0, 0, 0, 

    // Max Vertex Blend Matrix Index, Point Size, Primitive Count
    0, 128.0f, 0x0000FFFF,

    // Max Vertex Index, Streams, Stream Stride,
    0x0000FFFF, 1, 256,

    // Vertex Shader version, Max Vertex Shader Const
    D3DVS_VERSION(0,0), 0,

    // Pixel Shader version, Max Pixel Shader Value
    D3DPS_VERSION(0,0), 16.0f,
};

CSupportedSurface CRGBDriver::c_aSurfaces[11];

void InitSupportedSurface( CSupportedSurface& SS, const D3DFORMAT D3DFmt,
    CRGBSurfAllocator::TCreateSurfFn CFn,
    const bool bTexture, const bool bVolTexture, const bool bCubeTexture,
    const bool bOffScreenTarget, const bool bSameFmtTarget,
    const bool bZStencil, const bool bZStencilWithColor,
    const bool bSameFmtUpToAlpha, const bool b3DAccel,
    const DWORD dwPrivateFmtBitCount= 0, const WORD wFlipMSTypes= 0,
    const WORD wBltMSTypes= 0) 
{
    DDSURFACEDESC SDesc;
    ZeroMemory( &SDesc, sizeof( SDesc));
    SDesc.dwSize= sizeof( SDesc);

    DWORD dwOps( 0);
    if( bTexture) dwOps|= D3DFORMAT_OP_TEXTURE;
    if( bVolTexture) dwOps|= D3DFORMAT_OP_VOLUMETEXTURE;
    if( bCubeTexture) dwOps|= D3DFORMAT_OP_CUBETEXTURE;
    if( bOffScreenTarget) dwOps|= D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    if( bSameFmtTarget) dwOps|= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
    if( bZStencil) dwOps|= D3DFORMAT_OP_ZSTENCIL;
    if( bZStencilWithColor) dwOps|= D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH;
    if( bSameFmtUpToAlpha) dwOps|= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
    if( b3DAccel) dwOps|= D3DFORMAT_OP_3DACCELERATION;

    SDesc.ddpfPixelFormat.dwFlags= DDPF_D3DFORMAT;
    SDesc.ddpfPixelFormat.dwFourCC= static_cast<DWORD>(D3DFmt);
    SDesc.ddpfPixelFormat.dwOperations= dwOps;
    SDesc.ddpfPixelFormat.dwPrivateFormatBitCount= dwPrivateFmtBitCount;
    SDesc.ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes= wFlipMSTypes;
    SDesc.ddpfPixelFormat.MultiSampleCaps.wBltMSTypes= wBltMSTypes;

    SS= CSupportedSurface( SDesc, CFn);
}

void CRGBDriver::InitSupportedSurfaceArray( void)
{
    // Tex, VTex, CTex, OffSTarg, SameFmtTarg, Z/S, Z/SWColor, SameFmtToA, 3D
    InitSupportedSurface( c_aSurfaces[ 0], D3DFMT_X1R5G5B5, CX1R5G5B5Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 1], D3DFMT_A1R5G5B5, CA1R5G5B5Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 2], D3DFMT_P8, CP8Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 3], D3DFMT_L8, CL8Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 4], D3DFMT_A8L8, CA8L8Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 5], D3DFMT_A4R4G4B4, CA4R4G4B4Surface::Create,
        true, false, false, false, false, false, false, false, false);
    InitSupportedSurface( c_aSurfaces[ 6], D3DFMT_R5G6B5, CR5G6B5Surface::Create,
        true, false, false, true, true, false, false, false, true);
    InitSupportedSurface( c_aSurfaces[ 7], D3DFMT_A8R8G8B8, CA8R8G8B8Surface::Create,
        true, false, false, true, true, false, false, true, true);
    InitSupportedSurface( c_aSurfaces[ 8], D3DFMT_X8R8G8B8, CX8R8G8B8Surface::Create,
        true, false, false, true, true, false, false, false, true);
    InitSupportedSurface( c_aSurfaces[ 9], D3DFMT_D16_LOCKABLE, CD16Surface::Create,
        false, false, false, false, false, true, true, false, false);
    InitSupportedSurface( c_aSurfaces[10], D3DFMT_D24S8, CD24S8Surface::Create,
        false, false, false, false, false, true, true, false, false);
};

CRGBDriver::CRGBDriver() throw()
    :TSubDriver( c_aSurfaces,
        c_aSurfaces+ sizeof(c_aSurfaces)/ sizeof(c_aSurfaces[0]),
        TSurfAlloc( c_aSurfaces,
        c_aSurfaces+ sizeof(c_aSurfaces)/ sizeof(c_aSurfaces[0])) )
{ }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\main\surfaces.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{

void CR5G6B5Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_TARGET)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CR5G6B5Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        UINT32 uiRColor( DP2Clear.dwFillColor& 0xF80000);
        UINT32 uiGColor( DP2Clear.dwFillColor& 0xFC00);
        UINT32 uiBColor( DP2Clear.dwFillColor& 0xF8);
        uiRColor>>= 8;
        uiGColor>>= 5;
        uiBColor>>= 3;

        UINT32 uiColor= uiRColor| uiGColor| uiBColor;
        uiColor|= (uiColor<< 16);
        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( uiColor, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( uiColor, pSData, iCols* sizeof(UINT16));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CA8R8G8B8Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_TARGET)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CA8R8G8B8Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( DP2Clear.dwFillColor, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( DP2Clear.dwFillColor, pSData, iCols* sizeof(UINT32));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CX8R8G8B8Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_TARGET)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CX8R8G8B8Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( DP2Clear.dwFillColor, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( DP2Clear.dwFillColor, pSData, iCols* sizeof(UINT32));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CD16Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& D3DCLEAR_ZBUFFER)== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    { 
        CSurfaceLocker< CD16Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        // Warning, this operation is happening with the FPU mode set to
        // single precision, which is acceptable for 16 bit.
        D3DVALUE Z( DP2Clear.dvFillDepth);
		clamp( Z, 0.0f, 1.0f);
		Z= Z* 0xFFFF+ 0.5f;
        UINT32 uiZVal= static_cast<UINT32>( Z);
        uiZVal|= (uiZVal<< 16);

        if( RC.left== 0 && RC.right== m_wWidth)
            MemFill( uiZVal, pSData, iRow* m_lPitch);
        else do
        {
            MemFill( uiZVal, pSData, iCols* sizeof(UINT16));
            pSData+= m_lPitch;
        } while( --iRow);
    }
}

void CD24S8Surface::Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
{
    // Check for empty RECT.
    if((RC.left>= RC.right) || (RC.top>= RC.bottom))
        return;

    if((DP2Clear.dwFlags& (D3DCLEAR_ZBUFFER| D3DCLEAR_STENCIL))== 0)
        return;

    RECTL RectL;
    RectL.top= RC.top;
    RectL.left= RC.left;
    RectL.bottom= RC.bottom;
    RectL.right= RC.right;
    unsigned int iRow( RC.bottom- RC.top);
    const unsigned int iCols( RC.right- RC.left);

    // New scope for SurfaceLocker.
    {
        CSurfaceLocker< CD24S8Surface*> MySLocker( this, 0, &RectL);
        UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

        UINT32 uiMask( 0);
        UINT32 uiVal( 0);
        if((DP2Clear.dwFlags& D3DCLEAR_ZBUFFER)!= 0)
        {
            // Need C compatable FPU Mode here.
            CEnsureFPUModeForC FPUMode;

            double Z( DP2Clear.dvFillDepth);
			clamp( Z, 0.0, 1.0);
			Z= Z* 0xFFFFFF+ 0.5;
            uiVal= static_cast<UINT32>( Z);
			uiVal<<= 8;
            uiMask= 0xFFFFFF00;
        }
        if((DP2Clear.dwFlags& D3DCLEAR_STENCIL)!= 0)
        {
            uiVal|= (DP2Clear.dwFillStencil& 0xFF);
            uiMask|= 0xFF;
        }


        if( 0xFFFFFFFF== uiMask)
        {
            if( RC.left== 0 && RC.right== m_wWidth)
                MemFill( uiVal, pSData, iRow* m_lPitch);
            else do
            {
                MemFill( uiVal, pSData, iCols* sizeof(UINT32));
                pSData+= m_lPitch;
            } while( --iRow);
        }
        else
        {
            if( RC.left== 0 && RC.right== m_wWidth)
                MemMask( uiVal, uiMask, pSData, iRow* m_lPitch);
            else do
            {
                MemMask( uiVal, uiMask, pSData, iCols* sizeof(UINT32));
                pSData+= m_lPitch;
            } while( --iRow);
        }
    }
}

void MemFill( UINT32 uiData, void* pData, UINT32 uiBytes) throw()
{
    unsigned int uiBytesLeft( uiBytes);
    UINT32* p32Data= reinterpret_cast<UINT32*>(pData);

    // Unroll.
    unsigned int uiSpans( uiBytesLeft>> 6);
    uiBytesLeft= uiBytesLeft& 0x3F;
    if( uiSpans!= 0) do
    {
        p32Data[ 0]= uiData;
        p32Data[ 1]= uiData;
        p32Data[ 2]= uiData;
        p32Data[ 3]= uiData;
        p32Data[ 4]= uiData;
        p32Data[ 5]= uiData;
        p32Data[ 6]= uiData;
        p32Data[ 7]= uiData;
        p32Data[ 8]= uiData;
        p32Data[ 9]= uiData;
        p32Data[10]= uiData;
        p32Data[11]= uiData;
        p32Data[12]= uiData;
        p32Data[13]= uiData;
        p32Data[14]= uiData;
        p32Data[15]= uiData;
        p32Data+= 16;
    } while( --uiSpans!= 0);

    uiSpans= uiBytesLeft>> 2;
    uiBytesLeft= uiBytesLeft& 0x3;
    if( uiSpans!= 0) do
    {
        p32Data[0]= uiData;
        p32Data++;
    } while( --uiSpans!= 0);

    if( uiBytesLeft!= 0)
    {
        assert( 2== uiBytesLeft);
        UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
        p16Data[0]= static_cast<UINT16>( uiData& 0xFFFF);
    }
}

void MemMask( UINT32 uiData, UINT32 uiMask, void* pData, UINT32 uiBytes) throw()
{
	uiMask= ~uiMask;
    unsigned int uiBytesLeft( uiBytes);
    UINT32* p32Data= reinterpret_cast<UINT32*>(pData);

    // Unroll.
    unsigned int uiSpans( uiBytesLeft>> 6);
    uiBytesLeft= uiBytesLeft& 0x3F;
    if( uiSpans!= 0) do
    {
        p32Data[ 0]= (p32Data[ 0]& uiMask)| uiData;
        p32Data[ 1]= (p32Data[ 1]& uiMask)| uiData;
        p32Data[ 2]= (p32Data[ 2]& uiMask)| uiData;
        p32Data[ 3]= (p32Data[ 3]& uiMask)| uiData;
        p32Data[ 4]= (p32Data[ 4]& uiMask)| uiData;
        p32Data[ 5]= (p32Data[ 5]& uiMask)| uiData;
        p32Data[ 6]= (p32Data[ 6]& uiMask)| uiData;
        p32Data[ 7]= (p32Data[ 7]& uiMask)| uiData;
        p32Data[ 8]= (p32Data[ 8]& uiMask)| uiData;
        p32Data[ 9]= (p32Data[ 9]& uiMask)| uiData;
        p32Data[10]= (p32Data[10]& uiMask)| uiData;
        p32Data[11]= (p32Data[11]& uiMask)| uiData;
        p32Data[12]= (p32Data[12]& uiMask)| uiData;
        p32Data[13]= (p32Data[13]& uiMask)| uiData;
        p32Data[14]= (p32Data[14]& uiMask)| uiData;
        p32Data[15]= (p32Data[15]& uiMask)| uiData;
        p32Data+= 16;
    } while( --uiSpans!= 0);

    uiSpans= uiBytesLeft>> 2;
    uiBytesLeft= uiBytesLeft& 0x3;
    if( uiSpans!= 0) do
    {
        p32Data[0]= (p32Data[0]& uiMask)| uiData;
        p32Data++;
    } while( --uiSpans!= 0);

    if( uiBytesLeft!= 0)
    {
        assert( 2== uiBytesLeft);
        UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
        p16Data[0]= (p16Data[0]& static_cast<UINT16>( uiMask& 0xFFFF))|
            static_cast<UINT16>( uiData& 0xFFFF);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mlspan\cmlrast.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains C span loops.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

HRESULT
CMLRast_1(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    *(PUINT16)pS->pSurface =
                        ((pCtx->SI.uBR >>  1) & 0x7c00) |
                        ((pCtx->SI.uBG >>  6) & 0x03e0) |
                        ((pCtx->SI.uBB >> 11) & 0x001f) |
                        0x8000;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRS_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRS_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return DD_OK;
}

HRESULT
CMLRast_2(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min< UINT32>((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                                             pCtx->SI.uBB>>8, 0xff);
                    PUINT32 pSurface = (PUINT32)pS->pSurface;
                    *pSurface = uARGB;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRS_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRS_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\nommxsrc.inc ===
NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\atest_mh.h\
        $O\tstf_mh.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mlspan\nothing.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch_mlspan.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// Does nothing and is only used as a test to see if bead selector can get here.
//
//-----------------------------------------------------------------------------
HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            //pCtx->pfnBegin(pCtx, pP, pS);
            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\spanpars.h ===
//----------------------------------------------------------------------------
//
// spanpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

#ifdef __cplusplus
  extern "C" {
#endif


HRESULT MMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif


#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\spanutil.h ===
//----------------------------------------------------------------------------
//
// spanutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
// ATTENTION - It may be better to use RASTSPAN.  RASTSPAN has some extra
// space that'd go unused but then it'd be possible to memcpy ATTRSETs
// to RASTSPANs during fixed-point edge walking.
typedef struct tagATTRSET
{
    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };
    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };
    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
    };
    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS, fFog;
        };
        struct
        {
            INT32 iBS, iGS, iRS, iFog;
        };
        struct
        {
            UINT32 uBS, uGS, uRS, uFog;
        };
    };
    union
    {
        struct
        {  
            PUINT8 pSurface, pZ;
        };
        struct
        {  
            INT32 ipSurface, ipZ;
        };
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef void (FASTCALL *PFN_ADDATTRS)(PATTRSET pAttrs, PATTRSET pDelta);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, int iScale, FLOAT fNextOoW);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     struct tagSETUPCTX *pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsPwlTable[];

// Edge walkers.
typedef HRESULT (FASTCALL *PFN_WALKSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     struct tagSETUPCTX *pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKSPANS g_pfnWalkFloatSpansClipTable[];
extern PFN_WALKSPANS g_pfnWalkFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKSPANS g_pfnWalkFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

// Setup flags.
#define TRIP_DIFF_USED                  0x00000001
#define TRIP_SPEC_USED                  0x00000002
#define TRIP_TEX1_USED                  0x00000004
#define TRIP_TEX2_USED                  0x00000008
#define TRIP_Z_USED                     0x00000010
#define TRIP_LOD_USED                   0x00000020
#define TRIP_FOG_USED                   0x00000040
#define TRIP_TRIVIAL_ACCEPT_Y           0x00000080
#define TRIP_TRIVIAL_ACCEPT_X           0x00000100
#define TRIP_X_DEC                      0x00000200
#define TRIP_RASTPRIM_OVERFLOW          0x00000400
#define TRIP_FIXED_OVERFLOW             0x00000800
#define TRIP_IN_BEGIN                   0x00001000

#define TRIP_COLORS_USED                (TRIP_DIFF_USED | TRIP_SPEC_USED)
#define TRIP_TEX_USED                   (TRIP_TEX1_USED | TRIP_TEX2_USED)

// These flags are set and reset per-triangle, while the other flags are
// set per triangle set.
#define TRIP_PER_TRIANGLE_FLAGS \
    (TRIP_TRIVIAL_ACCEPT_Y | TRIP_TRIVIAL_ACCEPT_X | TRIP_X_DEC | \
     TRIP_RASTPRIM_OVERFLOW | TRIP_FIXED_OVERFLOW)
#define TRIP_PER_TRIANGLE_SET_FLAGS \
    (TRIP_DIFF_USED | TRIP_SPEC_USED | TRIP_TEX1_USED | TRIP_TEX2_USED | \
     TRIP_Z_USED | TRIP_LOD_USED | TRIP_FOG_USED)
    
// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current TriProcessor for span allocator calls.
    PVOID TriProcessor;
    
    // Current primitive.
    PD3DI_RASTPRIM pPrim;
    
    // Per-triangle flags.
    UINT uFlags;

    // Maximum span length allowed.
    INT cMaxSpan;
    
    // Piecewise-linear support for LOD.
    BOOL bNextValid;
    FLOAT fNextW;
    FLOAT fNextOoW;
    INT iNextLOD;

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrsPwl;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKSPANS pfnWalkSpans;
    
    // Current Y value.
    INT iY;
    
    // Edge X walkers.
    INTCARRYVAL X20, X10, X21;
    
    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;
    
    // Long edge attribute values.
    ATTRSET Attr;
    
    // Attribute X deltas.
    ATTRSET DAttrDX;
    
    // Attribute Y deltas.
    ATTRSET DAttrDY;
    
    // Attribute span-to-span deltas when X carries a pixel.
    ATTRSET DAttrCY;

    // Attribute span-to-span deltas when X doesn't carry a pixel.
    ATTRSET DAttrNC;

    // One over determinant.
    FLOAT fOoDet;
    
    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;
    
    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;
    
    // Subpixel correction amounts.
    FLOAT fDX, fDY;
} SETUPCTX, *PSETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\dxshad.h ===
/*--

$Revision: 1 $

Copyright (c) 1995, Microsoft Corporation

--*/
#ifndef _DXSHAD_H_
#define _DXSHAD_H_

//////////////////////////////////////////////////////////////////////////
//
//  Needed extensions to D3D to support hardware, per pixel style shadows
//
//////////////////////////////////////////////////////////////////////////

typedef struct _D3DSHADOWDATA {
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    LPDIRECTDRAWSURFACE lpDDSZBuffer;      /* Shadow z-buffer surface */
    D3DMATRIX*          lpD3DMatrixEye;    /* Eye space transform matrix */
    D3DMATRIX*          lpD3DMatrixLight;  /* Light space transform matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasMax;        /* Maximum z bias */
    D3DVALUE            dvUJitter;         /* Shadow sample jitter in u */
    D3DVALUE            dvVJitter;         /* Shadow sample jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
} D3DSHADOWDATA, *LPD3DSHADOWDATA;

// D3DSHADOWDATA dwFlags
#define D3DSZBUF_ZBIAS      1
#define D3DSZBUF_UVJITTER   2
#define D3DSZBUF_TRIANGLEFILTER   4         /* for experimental purposes */

// This structure is how shadow information is communicated
// to the HAL
typedef struct _D3DI_SHADOWDATA{
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    DDSURFACEDESC       ddsdShadZ;         /* Shadow z-buffer surface */
    DWORD               dwShadZMaskU;      /* ~(ddsdShadZ.dwWidth-1) */
    DWORD               dwShadZMaskV;      /* ~(ddsdShadZ.dwHeight-1) */
    D3DMATRIX           MatrixShad;        /* Embedded Concatenated screen to light space matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasRange;      /* Maximum z bias - Minimum z bias */
    D3DVALUE            dvUJitter;         /* 4.4 integer jitter in u */
    D3DVALUE            dvVJitter;         /* 4.4 integer jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
    DWORD               dwFilterArea;      /* dwFilterSize*dwFilterSize */
} D3DI_SHADOWDATA, *LPD3DI_SHADOWDATA;

// Additional D3DI_SHADOWDATA dwFlags
#define D3DSHAD_ENABLE  0x80000000          // set to enable shadowing

typedef enum _D3DSHADOWFILTERSIZE {
    D3DSHADOWFILTERSIZE_1x1 = 1,
    D3DSHADOWFILTERSIZE_2x2,
    D3DSHADOWFILTERSIZE_3x3,
    D3DSHADOWFILTERSIZE_4x4,
    D3DSHADOWFILTERSIZE_5x5,
    D3DSHADOWFILTERSIZE_6x6,
    D3DSHADOWFILTERSIZE_7x7,
    D3DSHADOWFILTERSIZE_8x8,
} D3DSHADOWFILTERSIZE;

#endif  // _DXSHAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\clrbd_mh.h: clrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\clrgn_mh.h: clrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\test_mh.h: test_mh.mh $(RAST_STD_M4)

$(GENTGT)\texa_mh.h: texa_mh.mh texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texbd_mh.h: texbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\texrd_mh.h: texrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstf_mh.h: tstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\atest_mh.h: atest_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): offs_acp.acp $(RGBRASTROOT)\pch\span.h $(RGBRASTROOT)\pch\stp_base.h

$(GENTGT)\beadtbl.cpp: beadtbl.mcp $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)

$(GENTGT)\atest.asm: atest.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\bldfuncs.asm: bldfuncs.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufread.asm: bufread.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufwrite.asm: bufwrite.mas bufwrite.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorbld.asm: colorbld.mas cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorgen.asm: colorgen.mas colorgen.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\test.asm: test.mas test.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\texaddr.asm: texaddr.mas cvars.mh texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texblend.asm: texblend.mas texblend.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\texread.asm: texread.mas texread.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\tstfail.asm: tstfail.mas tstfail.mh cvars.mh $(RAST_STD_M4)

$(GENTGT)\spanpars.asm: spanpars.mas cvars.mh $(RAST_STD_M4)

$(GENGT)\ml1.asm: ml1.mas $(RAST_STD_M4)
$(GENGT)\ml2.asm: ml2.mas $(RAST_STD_M4)
$(GENGT)\ml3.asm: ml3.mas $(RAST_STD_M4)
$(GENGT)\ml4.asm: ml4.mas $(RAST_STD_M4)
$(GENGT)\ml5.asm: ml5.mas $(RAST_STD_M4)
$(GENGT)\ml6.asm: ml6.mas $(RAST_STD_M4)
$(GENGT)\ml7.asm: ml7.mas $(RAST_STD_M4)
$(GENGT)\ml8.asm: ml8.mas $(RAST_STD_M4)
$(GENGT)\ml9.asm: ml9.mas $(RAST_STD_M4)
$(GENGT)\ml10.asm: ml10.mas $(RAST_STD_M4)
$(GENGT)\ml11.asm: ml11.mas $(RAST_STD_M4)
$(GENGT)\ml12.asm: ml12.mas $(RAST_STD_M4)
$(GENGT)\ml13.asm: ml13.mas $(RAST_STD_M4)
$(GENGT)\ml14.asm: ml14.mas $(RAST_STD_M4)
$(GENGT)\ml15.asm: ml15.mas $(RAST_STD_M4)
$(GENGT)\ml16.asm: ml16.mas $(RAST_STD_M4)
$(GENGT)\ml17.asm: ml17.mas $(RAST_STD_M4)
$(GENGT)\ml18.asm: ml18.mas $(RAST_STD_M4)
$(GENGT)\ml19.asm: ml19.mas $(RAST_STD_M4)
$(GENGT)\ml20.asm: ml20.mas $(RAST_STD_M4)
$(GENGT)\ml21.asm: ml21.mas $(RAST_STD_M4)
$(GENGT)\ml22.asm: ml22.mas $(RAST_STD_M4)
$(GENGT)\ml23.asm: ml23.mas $(RAST_STD_M4)
$(GENGT)\ml24.asm: ml24.mas $(RAST_STD_M4)
$(GENGT)\ml25.asm: ml25.mas $(RAST_STD_M4)
$(GENGT)\ml26.asm: ml26.mas $(RAST_STD_M4)
$(GENGT)\ml27.asm: ml27.mas $(RAST_STD_M4)
$(GENGT)\ml28.asm: ml28.mas $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\i386src.inc ===
i386_SOURCES = \
        $O\atest.asm\
        $O\bldfuncs.asm\
        $O\bufread.asm\
        $O\bufwrite.asm\
        $O\colorbld.asm\
        $O\colorgen.asm\
        $O\spanpars.asm\
        spanutil.cpp\
        $O\test.asm\
        $O\texaddr.asm\
        $O\texblend.asm\
        $O\texread.asm\
        $O\tstfail.asm\
        $O\ml1.asm\
        $O\ml2.asm\
        $O\ml3.asm\
        $O\ml4.asm\
        $O\ml5.asm\
        $O\ml6.asm\
        $O\ml7.asm\
        $O\ml8.asm\
        $O\ml9.asm\
        $O\ml10.asm\
        $O\ml11.asm\
        $O\ml12.asm\
        $O\ml13.asm\
        $O\ml14.asm\
        $O\ml15.asm\
        $O\ml16.asm\
        $O\ml17.asm\
        $O\ml18.asm\
        $O\ml19.asm\
        $O\ml20.asm\
        $O\ml21.asm\
        $O\ml22.asm\
        $O\ml23.asm\
        $O\ml24.asm\
        $O\ml25.asm\
        $O\ml26.asm\
        $O\ml27.asm\
        $O\ml28.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\tstf_mh.h\
        $O\atest_mh.h\
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\spanutil.cpp ===
//----------------------------------------------------------------------------
//
// spanutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\mmxspan\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\mlrfns.h ===
#ifndef _CMLRFNS_H_
#define _CMLRFNS_H_

#ifdef __cplusplus
  extern "C" {
#endif

HRESULT MMXMLRast_1(PD3DI_RASTCTX);
HRESULT MMXMLRast_2(PD3DI_RASTCTX);
HRESULT MMXMLRast_3(PD3DI_RASTCTX);
HRESULT MMXMLRast_4(PD3DI_RASTCTX);
HRESULT MMXMLRast_5(PD3DI_RASTCTX);
HRESULT MMXMLRast_6(PD3DI_RASTCTX);
HRESULT MMXMLRast_7(PD3DI_RASTCTX);
HRESULT MMXMLRast_8(PD3DI_RASTCTX);
HRESULT MMXMLRast_9(PD3DI_RASTCTX);
HRESULT MMXMLRast_10(PD3DI_RASTCTX);
HRESULT MMXMLRast_11(PD3DI_RASTCTX);
HRESULT MMXMLRast_12(PD3DI_RASTCTX);
HRESULT MMXMLRast_13(PD3DI_RASTCTX);
HRESULT MMXMLRast_14(PD3DI_RASTCTX);
HRESULT MMXMLRast_15(PD3DI_RASTCTX);
HRESULT MMXMLRast_16(PD3DI_RASTCTX);
HRESULT MMXMLRast_17(PD3DI_RASTCTX);
HRESULT MMXMLRast_18(PD3DI_RASTCTX);
HRESULT MMXMLRast_19(PD3DI_RASTCTX);
HRESULT MMXMLRast_20(PD3DI_RASTCTX);
HRESULT MMXMLRast_21(PD3DI_RASTCTX);
HRESULT MMXMLRast_22(PD3DI_RASTCTX);
HRESULT MMXMLRast_23(PD3DI_RASTCTX);
HRESULT MMXMLRast_24(PD3DI_RASTCTX);
HRESULT MMXMLRast_25(PD3DI_RASTCTX);
HRESULT MMXMLRast_26(PD3DI_RASTCTX);
HRESULT MMXMLRast_27(PD3DI_RASTCTX);
HRESULT MMXMLRast_28(PD3DI_RASTCTX);

#ifdef __cplusplus
}
#endif


HRESULT CMLRast_1(PD3DI_RASTCTX);
HRESULT CMLRast_2(PD3DI_RASTCTX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\mlspan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Monolithic Rasterizer Functions - Public Header File
//
///////////////////////////////////////////////////////////////////////////////


#ifndef _MONOSPAN_H
#define _MONOSPAN_H

#include "span.h"

DllExport HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\mmxemul.h ===
//-----------------------------------------------------------------------------
//
// This file contains headers for routines that emulate MMX instructions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// union for playing with 16 bit multiplies
typedef union tagVAL32 {
    INT32 i;
    struct {
        INT16 l;
        INT16 h;
    } i16;
} VAL32;

UINT16 MMX_addsw(INT16 x, INT16 y);
INT16  MMX_addusw(UINT16 x, UINT16 y);
UINT16 MMX_cmpeqw(INT16 x, INT16 y);
UINT16 MMX_cmpgtw(INT16 x, INT16 y);
INT16  MMX_mulhw(INT16 x, INT16 y);
INT16  MMX_mullw(INT16 x, INT16 y);
INT16  MMX_subsw(INT16 x, INT16 y);
UINT16 MMX_subusw(UINT16 x, UINT16 y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\context.h ===
namespace RGB_RAST_LIB_NAMESPACE
{
// TODO: Clean-up
inline D3DI_SPANTEX_FORMAT ConvPixelFormat( const DDPIXELFORMAT& DDPixFmt)
{
    if((DDPixFmt.dwFlags& DDPF_ZBUFFER)!= 0)
    {
        switch(DDPixFmt.dwZBitMask)
        {
        case( 0x0000FFFF): return D3DI_SPTFMT_Z16S0;
        case( 0xFFFFFF00): return D3DI_SPTFMT_Z24S8;
        case( 0x0000FFFE): return D3DI_SPTFMT_Z15S1;
        case( 0xFFFFFFFF): return D3DI_SPTFMT_Z32S0;
        default: return D3DI_SPTFMT_NULL;
        }
    }
    else if((DDPixFmt.dwFlags& DDPF_BUMPDUDV)!= 0)
    {
        switch( DDPixFmt.dwBumpDvBitMask)
        {
        case( 0x0000ff00):
            switch( DDPixFmt.dwRGBBitCount)
            {
            case( 24): return D3DI_SPTFMT_U8V8L8;
            case( 16): return D3DI_SPTFMT_U8V8;
            default: return D3DI_SPTFMT_NULL;
            }
            break;

        case( 0x000003e0): return D3DI_SPTFMT_U5V5L6;
        default: return D3DI_SPTFMT_NULL;
        }
    }
    else if((DDPixFmt.dwFlags& DDPF_PALETTEINDEXED8)!= 0)
        return D3DI_SPTFMT_PALETTE8;
    else if((DDPixFmt.dwFlags& DDPF_PALETTEINDEXED4)!= 0)
        return D3DI_SPTFMT_PALETTE4;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('U', 'Y', 'V', 'Y'))
        return D3DI_SPTFMT_UYVY;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('Y', 'U', 'Y', '2'))
        return D3DI_SPTFMT_YUY2;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '1'))
        return D3DI_SPTFMT_DXT1;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '2'))
        return D3DI_SPTFMT_DXT2;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '3'))
        return D3DI_SPTFMT_DXT3;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '4'))
        return D3DI_SPTFMT_DXT4;
    else if( DDPixFmt.dwFourCC== MAKEFOURCC('D', 'X', 'T', '5'))
        return D3DI_SPTFMT_DXT5;
    else
    {
        UINT uFmt = DDPixFmt.dwGBitMask | DDPixFmt.dwRBitMask;

        if (DDPixFmt.dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= DDPixFmt.dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (DDPixFmt.dwRGBBitCount)
            {
            case 32: return D3DI_SPTFMT_B8G8R8X8;
            case 24: return D3DI_SPTFMT_B8G8R8;
            default: return D3DI_SPTFMT_NULL;
            }
            break;
        case 0xffffff00:
            return D3DI_SPTFMT_B8G8R8A8;
        case 0xffe0:
            if (DDPixFmt.dwFlags & DDPF_ALPHAPIXELS)
                return D3DI_SPTFMT_B5G5R5A1;
            else
                return D3DI_SPTFMT_B5G6R5;
        case 0x07fe0: return D3DI_SPTFMT_B5G5R5;
        case 0xff0: return D3DI_SPTFMT_B4G4R4;
        case 0xfff0: return D3DI_SPTFMT_B4G4R4A4;
        case 0xff: return D3DI_SPTFMT_L8;
        case 0xffff: return D3DI_SPTFMT_L8A8;
        case 0xfc: return D3DI_SPTFMT_B2G3R3;
        default: return D3DI_SPTFMT_NULL;
        }
    }
    return D3DI_SPTFMT_NULL;
}

// Records the stride and the member offsets of the current FVF vertex type
// Used to pack a FVF vertex into one known by the rasterizer, such as
// RAST_GENERIC_VERTEX
typedef struct _FVFDATA
{
    // 0 means no according field
    INT16 offsetRHW;
    INT16 offsetPSize;
    INT16 offsetDiff;
    INT16 offsetSpec;
    INT16 offsetTex[D3DHAL_TSS_MAXSTAGES];

    UINT16 stride;

    RAST_VERTEX_TYPE vtxType;

    DWORD preFVF;
    INT TexIdx[D3DHAL_TSS_MAXSTAGES];
    UINT cActTex;
}FVFDATA;

class CRGBStateSet:
    public CSubStateSet< CRGBStateSet, CRGBContext>
{
public:
    CRGBStateSet( CRGBContext& C, const D3DHAL_DP2COMMAND* pBeginSS, const
        D3DHAL_DP2COMMAND* pEndSS): CSubStateSet< CRGBStateSet, CRGBContext>(
            C, pBeginSS, pEndSS)
    { }
    ~CRGBStateSet()
    { }
};

typedef CStdDrawPrimitives2< CRGBContext, CRGBStateSet,
    static_hash_map< DWORD, CRGBStateSet, 32> > TDrawPrimitives2;
typedef CSubContext< CRGBContext, CRGBDriver::TPerDDrawData,
    CRTarget< CRGBDriver::TSurface*, CRGBDriver::TPerDDrawData::TSurfDBEntry*> >
    TSubContext;

class CRGBContext:
    public TSubContext,
    public TDrawPrimitives2,
    public CStdDP2SetVertexShaderStore< CRGBContext>,
    public CStdDP2WInfoStore< CRGBContext>,
    public CStdDP2RenderStateStore< CRGBContext>,
    public CStdDP2TextureStageStateStore< CRGBContext>,
    public CStdDP2VStreamManager< CRGBContext, CVStream< CRGBDriver::TSurface*,
        CRGBDriver::TPerDDrawData::TSurfDBEntry*> >,
    public CStdDP2IStreamManager< CRGBContext, CIStream< CRGBDriver::TSurface*,
        CRGBDriver::TPerDDrawData::TSurfDBEntry*> >,
    public CStdDP2PaletteManager< CRGBContext, CPalDBEntry,
        static_hash_map< DWORD, CPalDBEntry, 4> >
{
public: // Types
    typedef TPerDDrawData::TDriver::TSurface TSurface;

protected: // Types
    typedef block< TDP2CmdBind, 17> TDP2Bindings;
    typedef block< TRecDP2CmdBind, 7> TRecDP2Bindings;
    struct SHandleHasCaps: public unary_function< DWORD, bool>
    {
        const TPerDDrawData& m_PDDD;
        DWORD m_dwCaps;

        explicit SHandleHasCaps( const TPerDDrawData& PDDD, const DWORD dwCaps)
            throw(): m_PDDD( PDDD), m_dwCaps( dwCaps) { }
        result_type operator()( const argument_type Arg) const
        {
            const TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                m_PDDD.GetSurfDBEntry( Arg);
            assert( pSurfDBEntry!= NULL);
            return((pSurfDBEntry->GetLCLddsCaps().dwCaps& m_dwCaps)== m_dwCaps);
        }
    };

protected:
    static const TDP2Bindings c_DP2Bindings;
    static const TRecDP2Bindings c_RecDP2Bindings;
    D3DI_RASTCTX m_RastCtx;
    PrimProcessor m_PrimProc;
    D3DI_SPANTEX m_aSpanTex[8];

    // FVF stuff
    FVFDATA m_fvfData;

    // Used to store the old last pixel setting when drawing line strips.
    UINT m_uFlags;

    static DWORD DetectBeadSet( void) throw();
    static const UINT c_uiBegan;

public:
    CRGBContext( TPerDDrawData& PDDD, PORTABLE_CONTEXTCREATEDATA& ccd):
        TSubContext( PDDD, ccd),
        TDrawPrimitives2( c_DP2Bindings.begin(), c_DP2Bindings.end(),
            c_RecDP2Bindings.begin(), c_RecDP2Bindings.end()),
        m_uFlags( 0)
    { 
        HRESULT hr= m_PrimProc.Initialize();
        assert( SUCCEEDED( hr)); // TODO: Can fail?

        // TODO: Remove this unextendable stuff?
        memset(&m_RastCtx, 0, sizeof(m_RastCtx));
        m_RastCtx.dwSize = sizeof(D3DI_RASTCTX);

        m_RastCtx.pdwRenderState[ D3DRENDERSTATE_SCENECAPTURE]= FALSE;

        // Hit our notification scheme here.
        NewColorBuffer();
        NewDepthBuffer();

        m_PrimProc.SetCtx(&m_RastCtx);

        // Initialize bead table enum
        m_RastCtx.BeadSet = (D3DI_BEADSET)DetectBeadSet();
        m_RastCtx.uDevVer = 0;

        // All render and texture stage state is initialized by
        // DIRECT3DDEVICEI::stateInitialize

        // Enable MMX Fast Paths (Monolithics) if a registry key for it is not 0
        m_RastCtx.dwMMXFPDisableMask[0] = 0x0;       // enable MMX FP's by default
    }
    ~CRGBContext() throw() { }

    void NewColorBuffer()
    {
        End();

        TRTarget& ColorBuffer= GetColorBuffer();
        if( ColorBuffer.GetMemLocation()!= TRTarget::EMemLocation::None)
        {
            IRGBSurface* pVMSurface= ColorBuffer.GetVidMemRepresentation();
            m_RastCtx.iSurfaceStride= pVMSurface->GetGBLlPitch();
            m_RastCtx.iSurfaceStep= pVMSurface->GetBytesPerPixel();
            m_RastCtx.iSurfaceBitCount= m_RastCtx.iSurfaceStep* 8;
            m_RastCtx.iSurfaceType= pVMSurface->GetSpanTexFormat();

            m_RastCtx.Clip.left= m_RastCtx.Clip.top= 0;
            m_RastCtx.Clip.bottom= pVMSurface->GetGBLwHeight();
            m_RastCtx.Clip.right= pVMSurface->GetGBLwWidth();
            m_RastCtx.pDDS= reinterpret_cast<LPDIRECTDRAWSURFACE>(pVMSurface);
        }
        else
        {
            m_RastCtx.iSurfaceStride= 0;
            m_RastCtx.iSurfaceStep= 0;
            m_RastCtx.iSurfaceBitCount= 0;
            m_RastCtx.iSurfaceType= D3DI_SPTFMT_NULL;

            m_RastCtx.Clip.left= m_RastCtx.Clip.top= 0;
            m_RastCtx.Clip.right= m_RastCtx.Clip.bottom= 0;
            m_RastCtx.pDDS= NULL;
        }

        TSubContext::NewColorBuffer();
    }
    void NewDepthBuffer()
    {
        End();

        TRTarget& DepthBuffer= GetDepthBuffer();
        if( DepthBuffer.GetMemLocation()!= TRTarget::EMemLocation::None)
        {
            IRGBSurface* pVMSurface= DepthBuffer.GetVidMemRepresentation();
            m_RastCtx.pZBits= NULL;
            m_RastCtx.iZStride= pVMSurface->GetGBLlPitch();
            m_RastCtx.iZStep= pVMSurface->GetBytesPerPixel();
            m_RastCtx.iZBitCount= m_RastCtx.iZStep* 8;
            m_RastCtx.pDDSZ= reinterpret_cast<LPDIRECTDRAWSURFACE>(pVMSurface);
        }
        else
        {
            m_RastCtx.pZBits= NULL;
            m_RastCtx.iZStride= 0;
            m_RastCtx.iZBitCount= 0;
            m_RastCtx.iZStep= 0;
            m_RastCtx.pDDSZ= NULL;
        }

        TSubContext::NewDepthBuffer();
    }

    HRESULT DP2ViewportInfo( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) throw()
    {
        const D3DHAL_DP2VIEWPORTINFO* pParam= reinterpret_cast<
            const D3DHAL_DP2VIEWPORTINFO*>(pP);
        // TODO: Roll into RGBContext (This particularly into DX8SDDIFW).
        m_RastCtx.Clip.left = pParam->dwX;
        m_RastCtx.Clip.top = pParam->dwY;
        m_RastCtx.Clip.bottom = pParam->dwY + pParam->dwHeight;
        m_RastCtx.Clip.right = pParam->dwX + pParam->dwWidth;
        return DD_OK;
    }
    operator D3DHAL_DP2VIEWPORTINFO() const throw()
    {
        D3DHAL_DP2VIEWPORTINFO Ret;
        Ret.dwX= m_RastCtx.Clip.left;
        Ret.dwY= m_RastCtx.Clip.top;
        Ret.dwWidth= m_RastCtx.Clip.right- Ret.dwX;
        Ret.dwHeight= m_RastCtx.Clip.bottom- Ret.dwY;
        return Ret;
    }
    void GetDP2ViewportInfo( D3DHAL_DP2VIEWPORTINFO& Param) const throw()
    { Param= (*this); }
    HRESULT RecDP2ViewportInfo( const D3DHAL_DP2COMMAND* pCmd, void* pP) throw()
    {
        D3DHAL_DP2VIEWPORTINFO* pParam= reinterpret_cast<
            D3DHAL_DP2VIEWPORTINFO*>(pP);
        pParam->dwX= m_RastCtx.Clip.left;
        pParam->dwY= m_RastCtx.Clip.top;
        pParam->dwWidth= m_RastCtx.Clip.right- m_RastCtx.Clip.left;
        pParam->dwHeight= m_RastCtx.Clip.bottom- m_RastCtx.Clip.top;
        return DD_OK;
    }

    HRESULT SetRenderState( UINT32 uState, UINT32 uStateVal)
    {
        m_RastCtx.pdwRenderState[uState] = uStateVal;

        switch(uState)
        {
        case D3DRS_CULLMODE:
            // Set face culling sign from state.
            switch(uStateVal)
            {
            case D3DCULL_CCW:
                m_RastCtx.uCullFaceSign= 1;
                break;
            case D3DCULL_CW:
                m_RastCtx.uCullFaceSign= 0;
                break;
            case D3DCULL_NONE:
                m_RastCtx.uCullFaceSign= 2;
                break;
            }
            break;

        case D3DRS_LASTPIXEL:
            // Set last-pixel flag from state.
            if (uStateVal)
            {
                m_PrimProc.SetFlags(PPF_DRAW_LAST_LINE_PIXEL);
            }
            else
            {
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
            }
            break;

        default:
            break;
        }

        return DD_OK;
    }
    HRESULT DP2RenderState( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP)
    {
        const D3DHAL_DP2RENDERSTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2RENDERSTATE*>(pP);

        WORD wStateCount( pCmd->wStateCount);

        HRESULT hr( DD_OK);

        End();

        D3DHAL_DP2RENDERSTATE SCap;
        SCap.RenderState= static_cast< D3DRENDERSTATETYPE>(
            D3DRENDERSTATE_SCENECAPTURE);
        GetDP2RenderState( SCap);
        const DWORD dwOldSC( SCap.dwState);

        if((DP2Data.dwFlags()& D3DHALDP2_EXECUTEBUFFER)!= 0)
        {
            // dp2d.lpdwRStates should be valid.

            if( wStateCount) do
            {
                assert( pParam->RenderState< D3DHAL_MAX_RSTATES);

                hr= SetRenderState( pParam->RenderState, pParam->dwState);
                if( SUCCEEDED(hr))
                    DP2Data.lpdwRStates()[ pParam->RenderState]= pParam->dwState;
                ++pParam;
            } while( SUCCEEDED(hr)&& --wStateCount);
            
        }
        else
        {
            if( wStateCount) do
            {
                assert( pParam->RenderState< D3DHAL_MAX_RSTATES);

                hr= SetRenderState( pParam->RenderState, pParam->dwState);
                ++pParam;
            } while( SUCCEEDED(hr)&& --wStateCount);
        }

        GetDP2RenderState( SCap);
        if( FALSE== dwOldSC && TRUE== SCap.dwState)
            OnSceneCaptureStart();
        else if( TRUE== dwOldSC && FALSE== SCap.dwState)
            OnSceneCaptureEnd();

        return hr;
    }
    DWORD GetRenderStateDW( D3DRENDERSTATETYPE RS) const throw()
    { assert( RS< D3DHAL_MAX_RSTATES); return m_RastCtx.pdwRenderState[ RS]; }
    D3DVALUE GetRenderStateDV( D3DRENDERSTATETYPE RS) const throw()
    {
        assert( RS< D3DHAL_MAX_RSTATES);
        return *(reinterpret_cast< const D3DVALUE*>( &m_RastCtx.pfRenderState[ RS]));
    }
    void GetDP2RenderState( D3DHAL_DP2RENDERSTATE& GetParam) const throw()
    { GetParam.dwState= GetRenderStateDW( GetParam.RenderState); }

    void OnSceneCaptureStart( void) throw()
    {
#if defined(USE_ICECAP4)
        static bool bStarted( true);
        if( bStarted)
            StopProfile( PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        else
            StartProfile( PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        bStarted= !bStarted;
        CommentMarkProfile( 1, "SceneCaptureStart");
#endif
    }
    void OnSceneCaptureEnd( void) throw()
    {
#if defined(USE_ICECAP4)
        CommentMarkProfile( 2, "SceneCaptureEnd");
//        StopProfile( PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif
        End();
    }

    void OnEndDrawPrimitives2( TDP2Data& )
    {
        End();
    }

    HRESULT SetTextureStageState( DWORD dwStage, DWORD dwState, DWORD uStateVal)
    {
        UINT cNewActTex = 0;

        m_RastCtx.pdwTextureStageState[dwStage][dwState] = uStateVal;
        switch (dwState)
        {
        case D3DTSS_TEXTUREMAP:
            {
            const TPerDDrawData::TSurfDBEntry* pTexDBEntry=
                GetPerDDrawData().GetSurfDBEntry( uStateVal);

            if( pTexDBEntry!= NULL)
            {
                assert((pTexDBEntry->GetLCLddsCaps().dwCaps& DDSCAPS_TEXTURE)!= 0);

                memset( &m_aSpanTex[ dwStage], 0, sizeof(m_aSpanTex[0]));
                m_aSpanTex[ dwStage].dwSize= sizeof(m_aSpanTex[0]);
                m_RastCtx.pTexture[ dwStage]= &m_aSpanTex[ dwStage];

                // Appears that a unique num is needed, but looks like
                // field isn't used anywhere. Using handle...
                m_aSpanTex[ dwStage].iGeneration= uStateVal;

                assert((pTexDBEntry->GetLCLdwFlags()& DDRAWISURF_HASCKEYSRCBLT)== 0);
                m_aSpanTex[ dwStage].uFlags&= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                m_aSpanTex[ dwStage].Format= ConvPixelFormat( pTexDBEntry->GetGBLddpfSurface());
                if( m_aSpanTex[ dwStage].Format== D3DI_SPTFMT_PALETTE8 ||
                    m_aSpanTex[ dwStage].Format== D3DI_SPTFMT_PALETTE4)
                {
                    TPalDBEntry* pPalDBEntry= pTexDBEntry->GetPalette();
                    assert( pPalDBEntry!= NULL);

                    if((pPalDBEntry->GetFlags()& DDRAWIPAL_ALPHA)!= 0)
                        m_aSpanTex[ dwStage].uFlags|= D3DI_SPANTEX_ALPHAPALETTE;
                    
                    m_aSpanTex[ dwStage].pPalette= reinterpret_cast<PUINT32>(
                        pPalDBEntry->GetEntries());

                    if( m_aSpanTex[ dwStage].Format== D3DI_SPTFMT_PALETTE8)
                        m_aSpanTex[ dwStage].iPaletteSize = 256;
                    else
                    {
                        // PALETTE4
                        m_aSpanTex[ dwStage].iPaletteSize = 16;
                    }
                }
                m_aSpanTex[ dwStage].TexAddrU= D3DTADDRESS_WRAP;
                m_aSpanTex[ dwStage].TexAddrV= D3DTADDRESS_WRAP;
                m_aSpanTex[ dwStage].BorderColor= RGBA_MAKE(0xff, 0x00, 0xff, 0xff);

                // assign first pSurf here (mipmap chain gets assigned below)
                m_aSpanTex[ dwStage].pSurf[0]= (LPDIRECTDRAWSURFACE)(pTexDBEntry);

                // Check for mipmap if any.
                const TPerDDrawData::TSurfDBEntry* pLcl= pTexDBEntry;

                // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
                // mipmap. They are init'ed with the first texture size.
                INT16 iPreSizeU = m_aSpanTex[ dwStage].iSizeU, iPreSizeV = m_aSpanTex[ dwStage].iSizeV;
                for (;;)
                {
                    TPerDDrawData::TSurfDBEntry::THandleVector::const_iterator
                        itNextTexHandle;
                    
                    itNextTexHandle= find_if( pLcl->GetAttachedTo().begin(),
                        pLcl->GetAttachedTo().end(),
                        SHandleHasCaps( GetPerDDrawData(), DDSCAPS_TEXTURE));
                    if( pLcl->GetAttachedTo().end()== itNextTexHandle)
                        break;

                    pLcl= GetPerDDrawData().GetSurfDBEntry( *itNextTexHandle);
                    assert( pLcl!= NULL);

                    m_aSpanTex[ dwStage].cLODTex++;
                    m_aSpanTex[ dwStage].pSurf[m_aSpanTex[ dwStage].cLODTex]= (LPDIRECTDRAWSURFACE)pLcl;
                }

                SetSizesSpanTexture( &m_aSpanTex[ dwStage]);
            }
            else
                m_RastCtx.pTexture[ dwStage]= NULL;

            if( m_RastCtx.pTexture[dwStage]!= NULL)
            {
                m_RastCtx.pTexture[dwStage]->TexAddrU=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU]);
                m_RastCtx.pTexture[dwStage]->TexAddrV=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV]);
                m_RastCtx.pTexture[dwStage]->BorderColor=
                    (D3DCOLOR)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_BORDERCOLOR]);
                m_RastCtx.pTexture[dwStage]->uMagFilter=
                    (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAGFILTER]);
                m_RastCtx.pTexture[dwStage]->uMinFilter=
                    (D3DTEXTUREMINFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MINFILTER]);
                m_RastCtx.pTexture[dwStage]->uMipFilter=
                    (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MIPFILTER]);
                m_RastCtx.pTexture[dwStage]->fLODBias=
                    m_RastCtx.pfTextureStageState[dwStage][D3DTSS_MIPMAPLODBIAS];

                if( m_RastCtx.pTexture[dwStage]->iMaxMipLevel!=
                    (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL])
                {
                    m_RastCtx.pTexture[dwStage]->iMaxMipLevel=
                        (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL];
                    m_RastCtx.pTexture[dwStage]->uFlags|= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
                }
            }

            // conservative but correct
            D3DHAL_VALIDATETEXTURESTAGESTATEDATA FakeVTSSD;
            FakeVTSSD.dwhContext= reinterpret_cast< ULONG_PTR>(this);
            FakeVTSSD.dwFlags= 0;
            FakeVTSSD.dwReserved= 0;
            FakeVTSSD.dwNumPasses= 0;
            FakeVTSSD.ddrval= DD_OK;
            if((FakeVTSSD.ddrval= ValidateTextureStageState( FakeVTSSD))== DD_OK)
            {
                // count number of contiguous-from-zero active texture blend stages
                for( INT iStage=0; iStage< D3DHAL_TSS_MAXSTAGES; iStage++)
                {
                    // check for disabled stage (subsequent are thus inactive)
                    // also conservatively checks for incorrectly enabled stage (might be legacy)
                    if((m_RastCtx.pdwTextureStageState[iStage][D3DTSS_COLOROP]==
                        D3DTOP_DISABLE) || (m_RastCtx.pTexture[iStage]== NULL))
                    {
                        break;
                    }

                    // stage is active
                    cNewActTex++;
                }
            }
            if( m_RastCtx.cActTex!= cNewActTex)
            {
                m_RastCtx.StatesDirtyBits[D3DRENDERSTATE_TEXTUREHANDLE>>3]|=
                    (1<<(D3DRENDERSTATE_TEXTUREHANDLE& 7));
                m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3]|=
                    (1<<(D3DHAL_MAX_RSTATES_AND_STAGES& 7));
                m_RastCtx.cActTex= cNewActTex;
            }
            break;
            }

        case D3DTSS_ADDRESSU:
        case D3DTSS_ADDRESSV:
        case D3DTSS_MIPMAPLODBIAS:
        case D3DTSS_MAXMIPLEVEL:
        case D3DTSS_BORDERCOLOR:
        case D3DTSS_MAGFILTER:
        case D3DTSS_MINFILTER:
        case D3DTSS_MIPFILTER:
            if( m_RastCtx.pTexture[dwStage]!= NULL)
            {
                m_RastCtx.pTexture[dwStage]->TexAddrU=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU]);
                m_RastCtx.pTexture[dwStage]->TexAddrV=
                    (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV]);
                m_RastCtx.pTexture[dwStage]->BorderColor=
                    (D3DCOLOR)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_BORDERCOLOR]);
                m_RastCtx.pTexture[dwStage]->uMagFilter=
                    (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAGFILTER]);
                m_RastCtx.pTexture[dwStage]->uMinFilter=
                    (D3DTEXTUREMINFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MINFILTER]);
                m_RastCtx.pTexture[dwStage]->uMipFilter=
                    (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MIPFILTER]);
                m_RastCtx.pTexture[dwStage]->fLODBias=
                    m_RastCtx.pfTextureStageState[dwStage][D3DTSS_MIPMAPLODBIAS];

                if( m_RastCtx.pTexture[dwStage]->iMaxMipLevel!=
                    (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL])
                {
                    m_RastCtx.pTexture[dwStage]->iMaxMipLevel=
                        (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL];
                    m_RastCtx.pTexture[dwStage]->uFlags|= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
                }
            }
            break;

        case D3DTSS_COLOROP:
        case D3DTSS_COLORARG1:
        case D3DTSS_COLORARG2:
        case D3DTSS_ALPHAOP:
        case D3DTSS_ALPHAARG1:
        case D3DTSS_ALPHAARG2:
            {
            // anything that effects the validity of the texture blending
            // could change the number of active texture stages

            // conservative but correct
            D3DHAL_VALIDATETEXTURESTAGESTATEDATA FakeVTSSD;
            FakeVTSSD.dwhContext= reinterpret_cast< ULONG_PTR>(this);
            FakeVTSSD.dwFlags= 0;
            FakeVTSSD.dwReserved= 0;
            FakeVTSSD.dwNumPasses= 0;
            FakeVTSSD.ddrval= DD_OK;
            if((FakeVTSSD.ddrval= ValidateTextureStageState( FakeVTSSD))== DD_OK)
            {
                // count number of contiguous-from-zero active texture blend stages
                for( INT iStage=0; iStage< D3DHAL_TSS_MAXSTAGES; iStage++)
                {
                    // check for disabled stage (subsequent are thus inactive)
                    // also conservatively checks for incorrectly enabled stage (might be legacy)
                    if((m_RastCtx.pdwTextureStageState[iStage][D3DTSS_COLOROP]==
                        D3DTOP_DISABLE) || (m_RastCtx.pTexture[iStage]== NULL))
                    {
                        break;
                    }

                    // stage is active
                    cNewActTex++;
                }
            }
            m_RastCtx.cActTex= cNewActTex;
            break;
            }
        }

        return DD_OK;
    }
    HRESULT DP2TextureStageState( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2TEXTURESTAGESTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2TEXTURESTAGESTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        HRESULT hr( DD_OK);

        End();

        if( wStateCount) do
        {
            assert( pParam->TSState< D3DTSS_MAX);

            hr= SetTextureStageState( pParam->wStage, pParam->TSState, pParam->dwValue);
            ++pParam;
        } while( SUCCEEDED(hr)&& --wStateCount);

        return hr;
    }
    DWORD GetTextureStageStateDW( WORD wStage, WORD wTSState) const throw()
    { return m_RastCtx.pdwTextureStageState[ wStage][ wTSState]; }
    D3DVALUE GetTextureStageStateDV( WORD wStage, WORD wTSState) const throw()
    {
        return *(reinterpret_cast< const D3DVALUE*>(
            &m_RastCtx.pdwTextureStageState[ wStage][ wTSState]));
    }
    void GetDP2TextureStageState( D3DHAL_DP2TEXTURESTAGESTATE& GetParam) const
        throw()
    { GetParam.dwValue= GetTextureStageStateDW( GetParam.wStage, GetParam.TSState); }

    HRESULT ValidateTextureStageState( D3DHAL_VALIDATETEXTURESTAGESTATEDATA&
        vtssd) const throw()
    {
        vtssd.dwNumPasses= 1;
        if ((m_RastCtx.pTexture[0] == m_RastCtx.pTexture[1]) &&
            (m_RastCtx.pTexture[0] != NULL) )
        {
            // except under very special circumstances, this will not work in RGB/MMX
            // since we keep a lot of stage state in the D3DI_SPANTEX structure
            return D3DERR_TOOMANYOPERATIONS;
        }
        for (INT i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
        {
            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLOROP])
            {
            default:
                return D3DERR_UNSUPPORTEDCOLOROPERATION;
            case D3DTOP_DISABLE:
                return DD_OK;  // don't have to validate further if the stage is disabled
            case D3DTOP_SELECTARG1:
            case D3DTOP_SELECTARG2:
            case D3DTOP_MODULATE:
            case D3DTOP_MODULATE2X:
            case D3DTOP_MODULATE4X:
            case D3DTOP_ADD:
            case D3DTOP_ADDSIGNED:
            case D3DTOP_BLENDDIFFUSEALPHA:
            case D3DTOP_BLENDTEXTUREALPHA:
            case D3DTOP_BLENDFACTORALPHA:
            case D3DTOP_BLENDTEXTUREALPHAPM:
            case D3DTOP_ADDSIGNED2X:
            case D3DTOP_SUBTRACT:
            case D3DTOP_ADDSMOOTH:
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG1] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDCOLORARG;
            case (D3DTA_TEXTURE):
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG2] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDCOLORARG;
            case (D3DTA_TFACTOR):
            case (D3DTA_CURRENT):
            case (D3DTA_DIFFUSE):
            case (D3DTA_SPECULAR):
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAOP])
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAOPERATION;
            case D3DTOP_DISABLE:
                break;
            case D3DTOP_SELECTARG1:
            case D3DTOP_SELECTARG2:
            case D3DTOP_MODULATE:
            case D3DTOP_MODULATE2X:
            case D3DTOP_MODULATE4X:
            case D3DTOP_ADD:
            case D3DTOP_ADDSIGNED:
            case D3DTOP_BLENDDIFFUSEALPHA:
            case D3DTOP_BLENDTEXTUREALPHA:
            case D3DTOP_BLENDFACTORALPHA:
            case D3DTOP_BLENDTEXTUREALPHAPM:
            case D3DTOP_ADDSIGNED2X:
            case D3DTOP_SUBTRACT:
            case D3DTOP_ADDSMOOTH:
                // only validate alpha args if alpha op is not disable
                switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG1] &
                        ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
                {
                default:
                    return D3DERR_UNSUPPORTEDALPHAARG;
                case (D3DTA_TEXTURE):
                    break;
                }

                switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG2] &
                        ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
                {
                default:
                    return D3DERR_UNSUPPORTEDALPHAARG;
                case (D3DTA_TFACTOR):
                case (D3DTA_CURRENT):
                case (D3DTA_DIFFUSE):
                case (D3DTA_SPECULAR):
                    break;
                }
                break;
            }
        }
        return DD_OK;
    }

    HRESULT DP2Clear( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        End();
        return TSubContext::DP2Clear( DP2Data, pCmd, pP);
    }
    HRESULT CheckFVF(DWORD dwFVF)
    {
        // check if FVF controls have changed
        if ( (m_fvfData.preFVF == dwFVF) &&
             (m_fvfData.TexIdx[0] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[0][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[1] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[1][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[2] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[2][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[3] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[3][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[4] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[4][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[5] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[5][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[6] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[6][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.TexIdx[7] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[7][D3DTSS_TEXCOORDINDEX])) &&
             (m_fvfData.cActTex == m_RastCtx.cActTex) )
        {
            return D3D_OK;
        }

        memset(&m_fvfData, 0, sizeof(FVFDATA));
        m_fvfData.preFVF = dwFVF;
        INT32 i;
        for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
        {
            m_fvfData.TexIdx[i] = 0xffff&m_RastCtx.pdwTextureStageState[i][D3DTSS_TEXCOORDINDEX];
        }
        m_fvfData.cActTex = m_RastCtx.cActTex;

        // XYZ
        if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2 |
             D3DFVF_NORMAL)) ||
             ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
        {
            // can't set reserved bits, shouldn't have normals in
            // output to rasterizers, and must have coordinates
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            m_fvfData.offsetRHW = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_PSIZE)
        {
            m_fvfData.offsetPSize = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            m_fvfData.offsetDiff = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            m_fvfData.offsetSpec = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        if (iTexCount > 0)
        {
            // set offset for Textures
            for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i ++)
            {
                m_fvfData.offsetTex[i] = (SHORT)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[i]);
            }
            // update stride
            m_fvfData.stride += (USHORT)(iTexCount * (sizeof(D3DVALUE) * 2));
        }

        if( D3DFVF_TLVERTEX== dwFVF)
            m_fvfData.vtxType = RAST_TLVERTEX;
        else
            m_fvfData.vtxType = RAST_GENVERTEX;

        return D3D_OK;
    }
    void PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx)
    {
        pGenVtx->sx = *((D3DVALUE *)pFvfVtx);
        pGenVtx->sy = *((D3DVALUE *)pFvfVtx + 1);
        pGenVtx->sz = *((D3DVALUE *)pFvfVtx + 2);
        if (m_fvfData.offsetRHW)
        {
            pGenVtx->rhw = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetRHW));
        }
        else
        {
            pGenVtx->rhw = 1.0f;
        }
        if (m_fvfData.offsetDiff)
        {
            pGenVtx->color = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetDiff));
        }
        else
        {
            pGenVtx->color = 0xFFFFFFFF; //__DEFAULT_DIFFUSE;
        }
        if (m_fvfData.offsetSpec)
        {
            pGenVtx->specular = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetSpec));
        }
        else
        {
            pGenVtx->specular = 0; //__DEFAULT_SPECULAR;
        }
        for (INT32 i = 0; i < (INT32)m_fvfData.cActTex; i++)
        {
           if (m_fvfData.offsetTex[i])
           {
               pGenVtx->texCoord[i].tu = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]));
               pGenVtx->texCoord[i].tv = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]) + 1);
           }
           else
           {
               pGenVtx->texCoord[i].tu = 0.0f;
               pGenVtx->texCoord[i].tv = 0.0f;
           }
        }
    }
    HRESULT DP2DrawPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE*>(pP);
        HRESULT hr( DD_OK);
		
        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->VStart* dwVStride;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
		            DoDrawOneGenPrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
                else                
		            DoDrawOnePrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2DrawPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE2*>(pP);
        HRESULT hr( DD_OK);

        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
    		        DoDrawOneGenPrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
                else
    		        DoDrawOnePrimitive( dwVStride, pVData,
                    pParam->primType, pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2DrawIndexedPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE*>(pP);
        HRESULT hr( DD_OK);
			
        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data for rasterization.
        UINT8* pStartVData= NULL;
        UINT8* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        const TIStream& IStream= GetIStream( 0);
        if( IStream.GetMemLocation()== TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TIStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT8*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

        if( pStartVData!= NULL&& pStartIData!= NULL&& sizeof(WORD)== dwIStride)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->BaseVertexIndex* dwVStride;
                UINT8* pIData= pStartIData+ pParam->StartIndex* dwIStride;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
    		        DoDrawOneGenIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
                else
    		        DoDrawOneIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2DrawIndexedPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2*>(pP);
        HRESULT hr( DD_OK);

        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data for rasterization.
        UINT8* pStartVData= NULL;
        UINT8* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        const TIStream& IStream= GetIStream( 0);
        if( IStream.GetMemLocation()== TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TIStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT8*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

        if( pStartVData!= NULL&& pStartIData!= NULL&& sizeof(WORD)== dwIStride)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->BaseVertexOffset;
                UINT8* pIData= pStartIData+ pParam->StartIndexOffset;

                m_PrimProc.BeginPrimSet( pParam->primType, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
    		        DoDrawOneGenIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
                else
    		        DoDrawOneIndexedPrimitive( dwVStride, pVData,
                    reinterpret_cast<WORD*>(pIData), pParam->primType,
                    pParam->PrimitiveCount);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    HRESULT DP2ClippedTriangleFan( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_CLIPPEDTRIANGLEFAN* pParam= reinterpret_cast<
            const D3DHAL_CLIPPEDTRIANGLEFAN*>(pP);
        HRESULT hr( DD_OK);
		
        const D3DHAL_DP2VERTEXSHADER VertexShader(*this);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since RGB is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since RGB only supports one stream, our data source should be
        // from stream 0.
        TVStream& VStream0( m_VStreamDB[ 0]);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TVStream::EMemLocation::Video)
        {
            // RGB can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            Begin();

		    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
            hr= CheckFVF( dwFVF);
            assert( SUCCEEDED( hr));
            if( FAILED( hr)) wPrimitiveCount= 0;
		    if( wPrimitiveCount) do
		    {
                UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                m_PrimProc.BeginPrimSet( D3DPT_TRIANGLEFAN, m_fvfData.vtxType);
                if( RAST_GENVERTEX== m_fvfData.vtxType)
		            DoDrawOneGenEdgeFlagTriangleFan( dwVStride, pVData,
                    pParam->PrimitiveCount, pParam->dwEdgeFlags);
                else
		            DoDrawOneEdgeFlagTriangleFan( dwVStride, pVData,
                    pParam->PrimitiveCount, pParam->dwEdgeFlags);
		    } while( SUCCEEDED(hr) && --wPrimitiveCount);
        }
        return hr;
    }
    void Begin()
    {
        HRESULT hr( DD_OK);

        if((m_uFlags& c_uiBegan)!= 0)
            return;

        // TODO: call this less often?
        UpdateColorKeyAndPalette();

        // Check for state changes
        BOOL bMaxMipLevelsDirty = FALSE;
        for (INT j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            PD3DI_SPANTEX pSpanTex = m_RastCtx.pTexture[j];
            if (pSpanTex)
            {
                bMaxMipLevelsDirty = bMaxMipLevelsDirty || (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY);
            }
        }
        RastLockSpanTexture();

        // Notify primitive Processor of state change.
        m_PrimProc.StateChanged();

        // Must call SpanInit AFTER texture is locked, since this
        // sets various flags and fields that are needed for bead choosing
        // Call SpanInit to setup the beads
        hr= SpanInit(&m_RastCtx);

        // Lock rendering target (must be VM Surfaces).
        m_RastCtx.pSurfaceBits= reinterpret_cast<UINT8*>(
            reinterpret_cast< TSurface*>(m_RastCtx.pDDS)->Lock( 0, NULL));
        if( m_RastCtx.pDDSZ!= NULL)
        {
            m_RastCtx.pZBits= reinterpret_cast<UINT8*>(
                reinterpret_cast< TSurface*>(m_RastCtx.pDDSZ)->Lock( 0, NULL));
        }
        else
        {
            m_RastCtx.pZBits = NULL;
        }

        // Prepare the primitive processor
        m_PrimProc.Begin();
        m_uFlags|= c_uiBegan;
    }
    void End( void)
    {
        if((m_uFlags& c_uiBegan)!= 0)
        {
            HRESULT hr = m_PrimProc.End();
            assert( SUCCEEDED( hr));

            // Unlock texture if this is not called in the middle of drawPrims to
            // flush for possible state changes. In the 2nd case, let
            // SetRenderState to handle it.
            RastUnlockSpanTexture();

            // Unlock surfaces
            reinterpret_cast<TSurface*>(m_RastCtx.pDDS)->Unlock();
            if( m_RastCtx.pDDSZ!= NULL)
                reinterpret_cast<TSurface*>(m_RastCtx.pDDSZ)->Unlock();

            m_uFlags&= ~c_uiBegan;
        }
    }
    bool IsTextureOff(void)
    {
        return
            (m_RastCtx.cActTex == 0 ||
            (m_RastCtx.cActTex == 1 && m_RastCtx.pTexture[0] == NULL) ||
            (m_RastCtx.cActTex == 2 &&
             (m_RastCtx.pTexture[0] == NULL ||
              m_RastCtx.pTexture[1] == NULL)));
    }
    void RastUnlockSpanTexture(void)
    {
        INT i, j;
        PD3DI_SPANTEX pSpanTex;;

        if (IsTextureOff())
        {
            return;
        }

        for (j = 0;
            j < (INT)m_RastCtx.cActTex;
            j++)
        {
            pSpanTex = m_RastCtx.pTexture[j];

            INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
            // RastUnlock is used for cleanup in RastLock so it needs to
            // be able to handle partially locked mipmap chains.
            if((pSpanTex->uFlags& D3DI_SPANTEX_SURFACES_LOCKED)!= 0)
            {
                for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
                {
                    const TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                        reinterpret_cast<const TPerDDrawData::TSurfDBEntry*>(
                        pSpanTex->pSurf[i]);

                    if((pSurfDBEntry->GetLCLddsCaps().dwCaps& DDSCAPS_VIDEOMEMORY)!= 0)
                    {
                        TSurface* pSurf= GetPerDDrawData().GetDriver().GetSurface( *pSurfDBEntry);
                        pSurf->Unlock();
                        pSpanTex->pBits[i-iFirstSurf]= NULL;
                    }
                }

                pSpanTex->uFlags&= ~D3DI_SPANTEX_SURFACES_LOCKED;
            }
        }
    }
    UINT32 static IntLog2(UINT32 x)
    {
        UINT32 y = 0;

        x >>= 1;
        while(x != 0)
        {
            x >>= 1;
            y++;
        }

        return y;
    }
    static HRESULT SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex)
    {
        const TPerDDrawData::TSurfDBEntry* pLcl;
        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
        LPDIRECTDRAWSURFACE pDDS = pSpanTex->pSurf[iFirstSurf];
        INT i;

        // Init
        pLcl = (const TPerDDrawData::TSurfDBEntry*)pDDS;

        pSpanTex->iSizeU = (INT16)pLcl->GetGBLwWidth();
        pSpanTex->iSizeV = (INT16)pLcl->GetGBLwHeight();
        pSpanTex->uMaskU = (INT16)(pSpanTex->iSizeU - 1);
        pSpanTex->uMaskV = (INT16)(pSpanTex->iSizeV - 1);
        pSpanTex->iShiftU = (INT16)IntLog2(pSpanTex->iSizeU);
        if (0 != pLcl->GetGBLddpfSurface().dwRGBBitCount)
        {
            pSpanTex->iShiftPitch[0] =
                    (INT16)IntLog2((UINT32)(pLcl->GetGBLlPitch()* 8)/
                    pLcl->GetGBLddpfSurface().dwRGBBitCount);
        }
        else
        {
            pSpanTex->iShiftPitch[0] =
                    (INT16)IntLog2(((UINT32)pLcl->GetGBLwWidth()* 8));
        }
        pSpanTex->iShiftV = (INT16)IntLog2(pSpanTex->iSizeV);
        pSpanTex->uMaskV = pSpanTex->uMaskV;

        // Check if the texture size is power of 2
/*        if (!ValidTextureSize(pSpanTex->iSizeU, pSpanTex->iShiftU,
                              pSpanTex->iSizeV, pSpanTex->iShiftV))
        {
            return DDERR_INVALIDPARAMS;
        }*/

        // Check for mipmap if any.
        // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
        // mipmap. They are init'ed with the first texture size.
        INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
        for ( i = iFirstSurf + 1; i <= pSpanTex->cLODTex; i++)
        {
            pDDS = pSpanTex->pSurf[i];
            // Check for invalid mipmap texture size
            pLcl = (const TPerDDrawData::TSurfDBEntry*)pDDS;
/*            if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
            {
                return DDERR_INVALIDPARAMS;
            }*/
            if (0 != pLcl->GetGBLddpfSurface().dwRGBBitCount)
            {
                pSpanTex->iShiftPitch[i - iFirstSurf] =
                    (INT16)IntLog2(((UINT32)pLcl->GetGBLlPitch()* 8)/
                    pLcl->GetGBLddpfSurface().dwRGBBitCount);
            }
            else
            {
                pSpanTex->iShiftPitch[i - iFirstSurf] =
                    (INT16)IntLog2(((UINT32)pLcl->GetGBLwWidth()*8));
            }
            iPreSizeU = (INT16)pLcl->GetGBLwWidth();
            iPreSizeV = (INT16)pLcl->GetGBLwHeight();
        }
        pSpanTex->cLOD = pSpanTex->cLODTex - iFirstSurf;
        pSpanTex->iMaxScaledLOD = ((pSpanTex->cLOD + 1) << LOD_SHIFT) - 1;
        pSpanTex->uFlags &= ~D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;

        return DD_OK;
    }
    void RastLockSpanTexture(void)
    {
        INT i, j;
        PD3DI_SPANTEX pSpanTex;
        HRESULT hr;

        if (IsTextureOff())
            return;

        for( j= 0; j< (INT)m_RastCtx.cActTex; j++)
        {
            pSpanTex= m_RastCtx.pTexture[j];
            if((pSpanTex->uFlags& D3DI_SPANTEX_MAXMIPLEVELS_DIRTY)!= 0)
            {
                hr= SetSizesSpanTexture(pSpanTex);
                if( hr!= D3D_OK)
                {
                    RastUnlockSpanTexture();
                    return;
                }
            }
            INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);

            for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
            {
                const TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                    reinterpret_cast<const TPerDDrawData::TSurfDBEntry*>(
                    pSpanTex->pSurf[i]);

                if((pSurfDBEntry->GetLCLddsCaps().dwCaps& DDSCAPS_VIDEOMEMORY)!= 0)
                {
                    TSurface* pSurf= GetPerDDrawData().GetDriver().GetSurface( *pSurfDBEntry);
                    pSpanTex->pBits[i-iFirstSurf]= reinterpret_cast<UINT8*>(
                        pSurf->Lock( 0, NULL));
                }
            }

            pSpanTex->uFlags|= D3DI_SPANTEX_SURFACES_LOCKED;
        }
    }
    void UpdateColorKeyAndPalette()
    {
        // TODO: Palette
        INT j;
        PD3DI_SPANTEX pSpanTex;

        // Set the transparent bit and the transparent color with pSurf[0]
        const TPerDDrawData::TSurfDBEntry* pLcl;
        for (j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            pSpanTex = m_RastCtx.pTexture[j];
            if ((pSpanTex != NULL) && (pSpanTex->pSurf[0] != NULL))
            {
                pLcl= (const TPerDDrawData::TSurfDBEntry*)(pSpanTex->pSurf[0]);

                // Palette might be changed
                if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
                        pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
                {
                    TPalDBEntry* pPalDBEntry= pLcl->GetPalette();
                    assert( pPalDBEntry!= NULL);

                    if((pPalDBEntry->GetFlags()& DDRAWIPAL_ALPHA)!= 0)
                        pSpanTex->uFlags|= D3DI_SPANTEX_ALPHAPALETTE;
                    pSpanTex->pPalette= reinterpret_cast< PUINT32>(
                        pPalDBEntry->GetEntries());
                }

                // texture does not have a ColorKey value
                if (pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT)
                {
                    pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                    // TODO:
                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    // StateChanged(RAST_TSS_DIRTYBIT(j, D3DTSS_TEXTUREMAP));
                }
            }
        }
    }
    bool NotCulled(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2)
    {
        if (m_RastCtx.pdwRenderState[D3DRS_CULLMODE] == D3DCULL_NONE)
            return true;

        FLOAT x1, y1, x2x1, x3x1, y2y1, y3y1, fDet;
        x1 = pV0->sx;
        y1 = pV0->sy;
        x2x1 = pV1->sx - x1;
        y2y1 = pV1->sy - y1;
        x3x1 = pV2->sx - x1;
        y3y1 = pV2->sy - y1;

        fDet = x2x1 * y3y1 - x3x1 * y2y1;

        if (0. == fDet)
            return false;
        switch ( m_RastCtx.pdwRenderState[D3DRS_CULLMODE] )
        {
        case D3DCULL_CW:
            if ( fDet > 0.f )
            {
                return false;
            }
            break;
        case D3DCULL_CCW:
            if ( fDet < 0.f )
            {
                return false;
            }
            break;
        }
        return true;
    }
    void DoDrawOnePrimitive( UINT16 FvfStride, PUINT8 pVtx,
        D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch (PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {                    
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV0, GV1, GV2, GV3;

                        PackGenVertex( pVtx, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(pVtx),
                            reinterpret_cast<D3DTLVERTEX*>(pVtx));
                        pVtx += FvfStride;
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(pV0),
                    reinterpret_cast<D3DTLVERTEX*>(pV1),
                    reinterpret_cast<D3DTLVERTEX*>(pV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                pV1 = pVtx;

                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV0.
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    pVtx += FvfStride;
                    pV1 = pVtx;
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0));
                }

                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride;
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                for (i = (INT)cPrims; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx;
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx;
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx;
                pVtx += FvfStride;
                // Preload initial pV0.
                pV1 = pVtx;
                pVtx += FvfStride;
                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    pV1 = pVtx;
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;

        default:
            assert( false);
        }
    }
    void DoDrawOneGenPrimitive( UINT16 FvfStride, PUINT8 pVtx,
        D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        
        RAST_GENERIC_VERTEX GV0, GV1, GV2;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch (PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV3;

                        PackGenVertex( pVtx, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        PackGenVertex( pVtx, &GV0);
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV0));
                       pVtx += FvfStride;
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                PackGenVertex( pV0, &GV0);
                PackGenVertex( pV1, &GV1);
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(&GV0),
                    reinterpret_cast<D3DTLVERTEX*>(&GV1),
                    reinterpret_cast<D3DTLVERTEX*>(&GV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                pV1 = pVtx;
                PackGenVertex( pV1, &GV1);

                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV0.
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    GV0= GV1;
                    pVtx += FvfStride;
                    pV1 = pVtx;
                    PackGenVertex( pV1, &GV1);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0));
                }

                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride;
                    PackGenVertex( pV0, &GV0);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx;
                pVtx += FvfStride;
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                PackGenVertex( pV0, &GV0);
                PackGenVertex( pV1, &GV1);
                PackGenVertex( pV2, &GV2);

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx;
                pVtx += FvfStride;
                pV2 = pVtx;
                pVtx += FvfStride;

                PackGenVertex( pV1, &GV1);
                PackGenVertex( pV2, &GV2);

                for (i = (INT)cPrims; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx;
                    PackGenVertex( pV2, &GV2);
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }

                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx;
                    PackGenVertex( pV2, &GV2);
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx;
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx;
                PackGenVertex( pV2, &GV2);

                pVtx += FvfStride;
                // Preload initial pV0.
                pV1 = pVtx;
                PackGenVertex( pV1, &GV1);
                pVtx += FvfStride;

                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pVtx;
                    PackGenVertex( pV1, &GV1);
                    pVtx += FvfStride;

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;

        default:
            assert( false);
        }
    }

    void DoDrawOneIndexedPrimitive( UINT16 FvfStride, PUINT8 pVtx,
        LPWORD puIndices, D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch(PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV0, GV1, GV2, GV3;

                        pV0 = pVtx + FvfStride * (*puIndices++);
                        PackGenVertex( pV0, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        pV0 = pVtx + FvfStride * (*puIndices++);
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(pV0),
                            reinterpret_cast<D3DTLVERTEX*>(pV0));
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                pV1 = pVtx + FvfStride * (*puIndices++);
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(pV0),
                    reinterpret_cast<D3DTLVERTEX*>(pV1),
                    reinterpret_cast<D3DTLVERTEX*>(pV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV1.
                pV1 = pVtx + FvfStride * (*puIndices++);
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0));
                }
                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride * (*puIndices);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(pV1),
                        reinterpret_cast<D3DTLVERTEX*>(pV0),
                        reinterpret_cast<D3DTLVERTEX*>(pV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                pV1 = pVtx + FvfStride * (*puIndices++);
                pV2 = pVtx + FvfStride * (*puIndices++);

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx + FvfStride * (*puIndices++);
                pV2 = pVtx + FvfStride * (*puIndices++);

                for (i = (INT)cPrims; i > 1; i-= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx + FvfStride * (*puIndices++);
                // Preload initial pV0.
                pV1 = pVtx + FvfStride * (*puIndices++);
                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                        break;
                    }
                }
            }
            break;
        }
    }
    void DoDrawOneGenIndexedPrimitive( UINT16 FvfStride, PUINT8 pVtx,
        LPWORD puIndices, D3DPRIMITIVETYPE PrimType, UINT cPrims)
    {
        INT i;
        RAST_GENERIC_VERTEX GV0, GV1, GV2;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        switch(PrimType)
        {
        case D3DPT_POINTLIST:
            {
                D3DVALUE fPointSize( GetRenderStateDV( D3DRS_POINTSIZE));
                DWORD dwPScaleEn( GetRenderStateDW( D3DRS_POINTSCALEENABLE));
                if( m_fvfData.offsetPSize!= 0 || fPointSize!= 1.0f ||
                    dwPScaleEn!= 0)
                {
					DWORD dwOldFill( GetRenderStateDW( D3DRS_FILLMODE));
					DWORD dwOldShade( GetRenderStateDW( D3DRS_SHADEMODE));
                    DWORD dwOldCull( GetRenderStateDW( D3DRS_CULLMODE));

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
                        SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT);
                        SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW);

                        Begin();
                    }
					m_PrimProc.BeginPrimSet( D3DPT_TRIANGLELIST, m_fvfData.vtxType);

                    D3DHAL_DP2VIEWPORTINFO VInfo;
                    GetDP2ViewportInfo( VInfo);
                    D3DVALUE fPScaleA( GetRenderStateDV( D3DRS_POINTSCALE_A));
                    D3DVALUE fPScaleB( GetRenderStateDV( D3DRS_POINTSCALE_B));
                    D3DVALUE fPScaleC( GetRenderStateDV( D3DRS_POINTSCALE_C));
                    D3DVALUE fPSizeMax( GetRenderStateDV( D3DRS_POINTSIZE_MAX));
                    D3DVALUE fPSizeMin( GetRenderStateDV( D3DRS_POINTSIZE_MIN));

                    clamp( fPSizeMax, 0.0f,
                        CRGBDriver::GetCaps().MaxPointSize);
                    clamp( fPSizeMin, 0.0f, fPSizeMax);

                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        if( m_fvfData.offsetPSize!= 0)
                            fPointSize= *reinterpret_cast<D3DVALUE*>
                            (pVtx+ m_fvfData.offsetPSize);
                        else
                            fPointSize= GetRenderStateDV( D3DRS_POINTSIZE);

                        if( dwPScaleEn)
                        {
                            D3DVALUE* pXYZ= reinterpret_cast< D3DVALUE*>(pVtx);
                            D3DVALUE De( sqrtf( pXYZ[0]* pXYZ[0]+
                                pXYZ[1]* pXYZ[1]+ pXYZ[2]* pXYZ[2]));

                            fPointSize*= VInfo.dwHeight* sqrtf( 1.0f/(
                                fPScaleA+ fPScaleB* De+ fPScaleC* De* De));
                        }
                        clamp( fPointSize, fPSizeMin, fPSizeMax);
                        fPointSize*= 0.5f;
                        
                        RAST_GENERIC_VERTEX GV3;

                        pV0 = pVtx + FvfStride * (*puIndices++);
                        PackGenVertex( pV0, &GV0);
                        GV3= GV2= GV1= GV0;
                        GV0.sx-= fPointSize;
                        GV0.sy-= fPointSize;
                        GV1.sx+= fPointSize;
                        GV1.sy-= fPointSize;
                        GV2.sx+= fPointSize;
                        GV2.sy+= fPointSize;
                        GV3.sx-= fPointSize;
                        GV3.sy+= fPointSize;
                        if( GetRenderStateDV( D3DRS_POINTSPRITEENABLE)!= 0)
                        {
                            for( INT iT( 0); iT< m_fvfData.cActTex; iT++)
                            {
                                GV0.texCoord[iT].tu= 0.0f;
                                GV0.texCoord[iT].tv= 0.0f;
                                GV1.texCoord[iT].tu= 1.0f;
                                GV1.texCoord[iT].tv= 0.0f;
                                GV2.texCoord[iT].tu= 1.0f;
                                GV2.texCoord[iT].tv= 1.0f;
                                GV3.texCoord[iT].tu= 0.0f;
                                GV3.texCoord[iT].tv= 1.0f;
                            }
                        }

                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2));
                        m_PrimProc.Tri(
                            reinterpret_cast<D3DTLVERTEX*>(&GV1),
                            reinterpret_cast<D3DTLVERTEX*>(&GV2),
                            reinterpret_cast<D3DTLVERTEX*>(&GV3));

                        pVtx += FvfStride;
                    }

                    if( dwOldFill!= D3DFILL_SOLID || dwOldShade!= D3DSHADE_FLAT ||
                        dwOldCull!= D3DCULL_CCW)
                    {
                        End();
                        SetRenderState( D3DRS_FILLMODE, dwOldFill);
                        SetRenderState( D3DRS_SHADEMODE, dwOldShade);
                        SetRenderState( D3DRS_CULLMODE, dwOldCull);
                    }
                }
                else
                {
                    for (i = (INT)cPrims; i > 0; i--)
                    {
                        pV0 = pVtx + FvfStride * (*puIndices++);
                        PackGenVertex( pV0, &GV0);
                        m_PrimProc.Point( 
                            reinterpret_cast<D3DTLVERTEX*>(&GV0),
                            reinterpret_cast<D3DTLVERTEX*>(&GV0));
                    }
                }
            } break;

        case D3DPT_LINELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV0, &GV0);
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                m_PrimProc.Line( 
                    reinterpret_cast<D3DTLVERTEX*>(&GV0),
                    reinterpret_cast<D3DTLVERTEX*>(&GV1),
                    reinterpret_cast<D3DTLVERTEX*>(&GV0));
            }
            break;

        case D3DPT_LINESTRIP:
            {
                // Disable last-pixel setting for shared verties and store prestate.
                UINT uOldFlags= m_PrimProc.GetFlags();
                m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);

                // Initial pV1.
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                for (i = (INT)cPrims; i > 1; i--)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV1, &GV1);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0));
                }
                // Restore last-pixel setting.
                m_PrimProc.SetFlags(uOldFlags& PPF_DRAW_LAST_LINE_PIXEL);

                // Draw last line with last-pixel setting from state.
                if (i == 1)
                {
                    pV0 = pVtx + FvfStride * (*puIndices);
                    PackGenVertex( pV0, &GV0);
                    m_PrimProc.Line( 
                        reinterpret_cast<D3DTLVERTEX*>(&GV1),
                        reinterpret_cast<D3DTLVERTEX*>(&GV0),
                        reinterpret_cast<D3DTLVERTEX*>(&GV1));
                }
            }
            break;

        case D3DPT_TRIANGLELIST:
            for (i = (INT)cPrims; i > 0; i--)
            {
                pV0 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV0, &GV0);
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                pV2 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV2, &GV2);

                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            {
                // Get initial vertex values.
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                pV2 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV2, &GV2);

                for (i = (INT)cPrims; i > 1; i-= 2)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }

                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV1);
                        break;
                    }
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pV2;
                    GV1 = GV2;
                    pV2 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV2, &GV2);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;

        case D3DPT_TRIANGLEFAN:
            {
                pV2 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV2, &GV2);
                // Preload initial pV0.
                pV1 = pVtx + FvfStride * (*puIndices++);
                PackGenVertex( pV1, &GV1);
                for (i = (INT)cPrims; i > 0; i--)
                {
                    pV0 = pV1;
                    GV0 = GV1;
                    pV1 = pVtx + FvfStride * (*puIndices++);
                    PackGenVertex( pV1, &GV1);

                    // TODO: Move into PrimProc.
                    switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                    {
                    case D3DFILL_POINT:
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                       m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                       break;
                    case D3DFILL_WIREFRAME:
                        if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                        {
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                            m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                        }
                        break;
                    case D3DFILL_SOLID:
                        m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                        break;
                    }
                }
            }
            break;
        }
    }

    void DoDrawOneEdgeFlagTriangleFan( UINT16 FvfStride, PUINT8 pVtx,
        UINT cPrims, UINT32 dwEdgeFlags)
    {
        INT i;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        pV2 = pVtx;
        pVtx += FvfStride;
        pV0 = pVtx;
        pVtx += FvfStride;
        pV1 = pVtx;
        pVtx += FvfStride;
        WORD wFlags = 0;
        if(dwEdgeFlags & 0x2)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        if(dwEdgeFlags & 0x1)
            wFlags |= D3DTRIFLAG_EDGEENABLE3;
        if(cPrims == 1) {
            if(dwEdgeFlags & 0x4)
                wFlags |= D3DTRIFLAG_EDGEENABLE2;

            // TODO: Move into PrimProc.
            switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
            {
            case D3DFILL_POINT:
               m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
               m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
               m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
               break;
            case D3DFILL_WIREFRAME:
                if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                {
                    if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                        m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                        m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                }
                break;
            case D3DFILL_SOLID:
                m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                break;
            }
            return;
        }

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
            break;
        }
        UINT32 dwMask = 0x4;
        for (i = (INT)cPrims - 2; i > 0; i--)
        {
            pV0 = pV1;
            pV1 = pVtx;
            pVtx += FvfStride;
            if(true|| (dwEdgeFlags & dwMask)!= 0)
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            else
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                   break;
                case D3DFILL_WIREFRAME:
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
                    break;
                }
            }
            dwMask <<= 1;
        }
        pV0 = pV1;
        pV1 = pVtx;
        wFlags = 0;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        dwMask <<= 1;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
           m_PrimProc.Point((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)pV2, (LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)pV0, (LPD3DTLVERTEX)pV1, (LPD3DTLVERTEX)pV2);
            break;
        }
    }
    void DoDrawOneGenEdgeFlagTriangleFan( UINT16 FvfStride, PUINT8 pVtx,
        UINT cPrims, UINT32 dwEdgeFlags)
    {
        INT i;
        RAST_GENERIC_VERTEX GV0, GV1, GV2;
        PUINT8 pV0, pV1, pV2;
        HRESULT hr;

        pV2 = pVtx;
        PackGenVertex( pV2, &GV2);
        pVtx += FvfStride;
        pV0 = pVtx;
        PackGenVertex( pV0, &GV0);
        pVtx += FvfStride;
        pV1 = pVtx;
        PackGenVertex( pV1, &GV1);
        pVtx += FvfStride;
        WORD wFlags = 0;
        if(dwEdgeFlags & 0x2)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        if(dwEdgeFlags & 0x1)
            wFlags |= D3DTRIFLAG_EDGEENABLE3;
        if(cPrims == 1) {
            if(dwEdgeFlags & 0x4)
                wFlags |= D3DTRIFLAG_EDGEENABLE2;

            // TODO: Move into PrimProc.
            switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
            {
            case D3DFILL_POINT:
               m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
               m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
               m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
               break;
            case D3DFILL_WIREFRAME:
                if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                {
                    if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                    if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                }
                break;
            case D3DFILL_SOLID:
                m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                break;
            }
            return;
        }

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
            break;
        }
        UINT32 dwMask = 0x4;
        for (i = (INT)cPrims - 2; i > 0; i--)
        {
            pV0 = pV1;
            GV0 = GV1;
            pV1 = pVtx;
            PackGenVertex( pV1, &GV1);
            pVtx += FvfStride;
            if(true || (dwEdgeFlags & dwMask)!= 0)
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
                    {
                        m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                    }
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            else
            {
                // TODO: Move into PrimProc.
                switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
                {
                case D3DFILL_POINT:
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                   m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                   break;
                case D3DFILL_WIREFRAME:
                    break;
                case D3DFILL_SOLID:
                    m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
                    break;
                }
            }
            dwMask <<= 1;
        }
        pV0 = pV1;
        GV0 = GV1;
        pV1 = pVtx;
        PackGenVertex( pV1, &GV1);
        wFlags = 0;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE1;
        dwMask <<= 1;
        if(dwEdgeFlags & dwMask)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;

        // TODO: Move into PrimProc.
        switch (m_RastCtx.pdwRenderState[D3DRS_FILLMODE])
        {
        case D3DFILL_POINT:
           m_PrimProc.Point((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
           m_PrimProc.Point((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
           break;
        case D3DFILL_WIREFRAME:
            if(NotCulled((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2))
            {
                if( wFlags& D3DTRIFLAG_EDGEENABLE1)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE2)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0);
                if( wFlags& D3DTRIFLAG_EDGEENABLE3)
                    m_PrimProc.Line((LPD3DTLVERTEX)&GV2, (LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV0);
            }
            break;
        case D3DFILL_SOLID:
            m_PrimProc.Tri((LPD3DTLVERTEX)&GV0, (LPD3DTLVERTEX)&GV1, (LPD3DTLVERTEX)&GV2);
            break;
        }
    }
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\makefile.inc ===
!include ..\rgbrule.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\driver.h ===
namespace RGB_RAST_LIB_NAMESPACE
{
class _multiple_inheritance CRGBContext;
class _single_inheritance CRGBDriver;
class _single_inheritance CRGBPerDDrawData;

typedef CSurfDBEntryWPal<> TSurfDBEntry;
typedef CSubPerDDrawData< CRGBPerDDrawData, CRGBDriver, TSurfDBEntry,
    static_hash_map< DWORD, TSurfDBEntry, 64> >
    TSubPerDDrawData;

class CRGBPerDDrawData:
    public TSubPerDDrawData
{
public:
    CRGBPerDDrawData( TDriver& Driver, DDRAWI_DIRECTDRAW_LCL& DDLcl) throw()
        :TSubPerDDrawData( Driver, DDLcl)
    { }
    ~CRGBPerDDrawData() throw() { }
};

typedef CSubDriver< CRGBDriver, CRGBContext, CRGBSurfAllocator, CRGBPerDDrawData>
    TSubDriver;

class CSupportedSurface
{
protected:
    DDSURFACEDESC m_SDesc;
    CRGBSurfAllocator::TCreateSurfFn m_CreateFn;

public:
    CSupportedSurface() { }
    CSupportedSurface( DDSURFACEDESC SDesc, CRGBSurfAllocator::TCreateSurfFn CFn)
        : m_SDesc( SDesc), m_CreateFn( CFn)
    { }
    operator DDSURFACEDESC() const
    { return m_SDesc; }
    DDSURFACEDESC GetMatch() const
    {
        SPixelFormat PFmt(
            static_cast< D3DFORMAT>(m_SDesc.ddpfPixelFormat.dwFourCC));

        DDSURFACEDESC RetSDesc;
        ZeroMemory( &RetSDesc, sizeof(RetSDesc));
        RetSDesc.dwFlags= DDSD_PIXELFORMAT;
        RetSDesc.ddpfPixelFormat= PFmt;
        return RetSDesc;
    }
    operator CRGBSurfAllocator::TCreateSurfFn() const
    { return m_CreateFn; }
};

class CRGBDriver:
    public TSubDriver
{
private:
    static CSupportedSurface c_aSurfaces[];
    static const D3DCAPS8 c_D3DCaps;

public:
    CRGBDriver();
    ~CRGBDriver()
    { }

    static const D3DCAPS8& GetCaps()
    { return c_D3DCaps; }
    static void InitSupportedSurfaceArray();
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern double g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if 0 || DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\rast.h ===
//----------------------------------------------------------------------------
//
// rast.h
//
// Umbrella header file for the rasterizers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAST_H_
#define _RAST_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

//#include <d3ditype.h>
#include <d3dflt.h>
#include <span.h>

typedef enum _RASTSurfaceType
{
    RAST_STYPE_NULL     = 0,
    RAST_STYPE_B8G8R8   = 1,
    RAST_STYPE_B8G8R8A8 = 2,
    RAST_STYPE_B8G8R8X8 = 3,
    RAST_STYPE_B5G6R5   = 4,
    RAST_STYPE_B5G5R5   = 5,
    RAST_STYPE_PALETTE4 = 6,
    RAST_STYPE_PALETTE8 = 7,
    RAST_STYPE_B5G5R5A1 = 8,
    RAST_STYPE_B4G4R4   = 9,
    RAST_STYPE_B4G4R4A4 =10,
    RAST_STYPE_L8       =11,          // 8 bit luminance-only
    RAST_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RAST_STYPE_U8V8     =13,          // 16 bit bump map format
    RAST_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RAST_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RAST_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RAST_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RAST_STYPE_DXT1    =18,          // S3 texture compression technique 1
    RAST_STYPE_DXT2    =19,          // S3 texture compression technique 2
    RAST_STYPE_DXT3    =20,          // S3 texture compression technique 3
    RAST_STYPE_DXT4    =21,          // S3 texture compression technique 4
    RAST_STYPE_DXT5    =22,          // S3 texture compression technique 5
    RAST_STYPE_B2G3R3   =23,          // 8 bit RGB texture format

    RAST_STYPE_Z16S0    =32,
    RAST_STYPE_Z24S8    =33,
    RAST_STYPE_Z15S1    =34,
    RAST_STYPE_Z32S0    =35,

} RASTSurfaceType;


#endif // #ifndef _RAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\rgb_pch_cpp.cpp ===
#include "rgb_pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\cppsrc.inc ===
O_FILES = $O\attrscpp.cpp $O\tstpcpp.cpp
$(TARGET_DIRECTORY)_SOURCES = $(O_FILES) ..\walkcpp.cpp
NTTARGETFILE0 = $(NTTARGETFILE0) $(O_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\rgb_pch.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define RGB_RAST_LIB_NAMESPACE D3D8RGBRast

#if defined(DBG) || defined(_DEBUG)
#define assert(condition) \
    do { if(!(condition) && RGB_RAST_LIB_NAMESPACE::Assert(__FILE__, __LINE__, #condition)) DebugBreak(); } while( false)
#else
#define assert(condition) (0)
#endif

// #include <ddrawpr.h>

// Windows
#include <windows.h>

#if !defined(DBG) && !defined(_DEBUG)
#pragma inline_depth( 255)
#endif

#if defined(USE_ICECAP4)
#include <icecap.h>
#endif

#undef max
#undef min

// STL & standard headers.
#include <functional>
#include <algorithm>
#include <iterator>
#include <memory>
#include <limits>
#include <new>

// D3DRGBRast namespace provides shelter from clashing with any customer's
// symbols in their .libs, including any CRT stuff they include. Here, CRT
// pieces can be brought in one by one, assuring there isn't a problem. The
// primary problem found is with bad_alloc. If you look at this CRT header,
// it currently has the class either an inline or a dllimport based on a
// #define. This PCH will pick it up as inline.
// In Debug, or if the compiler chooses not to inline the function, a
// symbol will become present for std::bad_alloc::bad_alloc() in
// d3d8rgb.lib. If someone else links with us and a CRT .lib, which has
// std::bad_alloc::bad_alloc() also as a dllimport, then a conflict occurs.
// Here we can isolate each CRT/ STL piece and provide name mangling
// as neccessary by providing our own namespace.
// We also have to provide private map and set implementations, as CRT has
// a dllimport dependency on _lock. We don't want a thread-safe version
// anyway.
namespace RGB_RAST_LIB_NAMESPACE
{
    using std::numeric_limits;
    using std::unary_function;
    using std::binary_function;
    using std::input_iterator_tag;
    using std::output_iterator_tag;
    using std::forward_iterator_tag;
    using std::bidirectional_iterator_tag;
    using std::random_access_iterator_tag;
    using std::pair;
    using std::fill;
    using std::copy;
    using std::find_if;
    using std::auto_ptr;
    using std::fill;
    using std::less;
    using std::bind2nd;
    using std::not_equal_to;
    using std::equal;
    using std::logical_not;
    using std::equal_to;
    using std::next_permutation;
    template< class T>
    const T& min( const T& x, const T& y)
    { return ( x< y? x: y); }
    template< class T>
    const T& max( const T& x, const T& y)
    { return ( x> y? x: y); }
    template< class T>
    struct identity:
        unary_function< T, T>
    {
        const result_type& operator()( const argument_type& Arg) const
        { return Arg; }
    };
    template< class Pair>
    struct select1st:
        unary_function< Pair, typename Pair::first_type>
    {
        const result_type& operator()( const Pair& p) const
        { return p.first; }
    };
    class exception
    {
    private:
        const char* m_szWhat;
    public:
        exception() throw()
        { m_szWhat= "exception"; }
        exception(const char* const& szWhat) throw()
        { m_szWhat= szWhat; }
        exception(const exception& ex) throw()
        { (*this)= ex; }
        exception& operator= (const exception& ex) throw()
        { m_szWhat= ex.m_szWhat; return *this; }
        virtual ~exception() throw()
        { }
        virtual const char* what() const throw()
        { return m_szWhat; }
    };
    class bad_alloc: public exception
    {
    public:
    	bad_alloc(const char *_S = "bad allocation") throw()
            : exception(_S) {}
    	virtual ~bad_alloc() throw()
        { }
    };
    bool Assert(LPCSTR szFile, int nLine, LPCSTR szCondition);
#include "block.h"
#include "allocator.h"
}
using namespace RGB_RAST_LIB_NAMESPACE;

#include <vector>
namespace RGB_RAST_LIB_NAMESPACE
{
    // Override the standard vector, in order to provide a change in default
    // allocator. std::vector defaults to std::allocator. Should've been able
    // to name this "vector", but MSVC seems to have another bug. Keep getting
    // errors about std::vector not being defined. So, name it vector2 (which
    // compiles fine) and #define vector vector2.
    template< class T, class Allocator= allocator< T> >
    class vector2:
        public std::vector< T, Allocator>
    {
    public:
        typedef std::vector< T, Allocator> std_vector;
        explicit vector2( const Allocator& A= Allocator()): std_vector( A)
        { }
        explicit vector2( std_vector::size_type n, const T& x= T(),
            const Allocator& A= Allocator()): std_vector( n, x, A)
        { }
        vector2( const vector2< T, Allocator>& v): std_vector( v)
        { }
        template< class InputIterator>
        vector2( InputIterator f, InputIterator l, const Allocator& A=
            Allocator()): std_vector( f, l, A)
        { }
        ~vector2()
        { }
    };
#define vector vector2
#include "tree.h"
#include "map.h"
#include "set.h"
#include "list.h"
#include "hash_table.h"
#include "hash_map.h"
}

// DX
// Including d3d8ddi & d3d8sddi makes the pluggable software rasterizer
// a "private" feature as these headers aren't publically available.

#include <ddraw.h>
#include <ddrawi.h>
#include <d3dhal.h>
#include <d3d8p.h>

#include <d3d8ddi.h>
#include <d3d8sddi.h>
#include <DX8SDDIFW.h>

namespace RGB_RAST_LIB_NAMESPACE
{
    using namespace DX8SDDIFW;
}

#include "rast.h"
#include "span.h"
#include "setup.hpp"

#include "Surfaces.h"
#include "Driver.h"
#include "Context.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\setup.hpp ===
//----------------------------------------------------------------------------
//
// setup.hpp
//
// Setup declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SETUP_HPP_
#define _SETUP_HPP_

#pragma warning(disable:4786)

#include "stp_base.h"

// PrimProcessor flags.
#define PPF_IN_BEGIN                    0x00000001
#define PPF_STATE_CHANGED               0x00000002
#define PPF_NORMALIZE_RHW               0x00000004
#define PPF_DRAW_LAST_LINE_PIXEL        0x00000008

// Bounds for normalized RHWs.  These are not quite the ideal bounds to
// avoid over- and underflow after normalization when at least one RHW is
// guaranteed to be at the bounds.  There is no reason it
// has to be normalized to [0,1] anway, other than to try and spread
// the values across the desired range.
#define NORMALIZED_RHW_MIN g_fZero
#define NORMALIZED_RHW_MAX g_fp95

//----------------------------------------------------------------------------
//
// PrimProcessor
//
// Accepts primitives to be rasterized.  Primitive and span descriptions
// are put into a buffer for later processing by the span-level code.
//
//----------------------------------------------------------------------------

class DllExport PrimProcessor
{
public:
    PrimProcessor(void);
    HRESULT Initialize(void);
    ~PrimProcessor(void);

    inline UINT GetFlags(void);
    inline void SetFlags(UINT uFlags);
    inline void ClrFlags(UINT uFlags);

    inline void StateChanged();

    void SetCtx(PD3DI_RASTCTX pCtx);

    void BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                      RAST_VERTEX_TYPE VertType);

    HRESULT Point(LPD3DTLVERTEX pV0,
                  LPD3DTLVERTEX pFlatVtx);
    HRESULT Line(LPD3DTLVERTEX pV0,
                 LPD3DTLVERTEX pV1,
                 LPD3DTLVERTEX pFlatVtx);
    HRESULT Tri(LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1,
                LPD3DTLVERTEX pV2);

    void Begin(void);
    HRESULT End(void);

    HRESULT AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan);
    void FreeSpans(UINT cSpans);

private:
    // Original FP control word.
    UINT16 m_uFpCtrl;

    // Buffer space and current pointer.
    PUINT8 m_pBuffer;
    PUINT8 m_pBufferStart;
    PUINT8 m_pBufferEnd;
    PUINT8 m_pCur;

    // Flags.
    UINT m_uPpFlags;

    //
    // Intermediate results shared between methods.
    //

    SETUPCTX m_StpCtx;

    // Previous primitive, for primitive chaining.
    PD3DI_RASTPRIM m_pOldPrim;

    // Attribute function table index.
    INT m_iAttrFnIdx;

    // Old primitive and vertex types.
    D3DPRIMITIVETYPE m_PrimType;
    RAST_VERTEX_TYPE m_VertType;

    //
    // Triangle values.
    //

    // Y values and trapezoid heights.
    INT m_iY1, m_iY2;
    UINT m_uHeight10, m_uHeight21, m_uHeight20;

    // Triangle X extent.
    INT m_iXWidth;

    // Original RHW saved during RHW normalization.
    D3DVALUE m_dvV0RHW;
    D3DVALUE m_dvV1RHW;
    D3DVALUE m_dvV2RHW;

    //
    // Point methods.
    //
    void NormalizePointRHW(LPD3DTLVERTEX pV0);
    void FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan);

    //
    // Line methods.
    //
    void NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);
    BOOL PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                           BOOL bSlopeIsOne, BOOL bSlopeIsPosOne);
    BOOL LineSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);

    //
    // Triangle methods.
    //
    void NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                         LPD3DTLVERTEX pV2);
    BOOL TriSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2);
    inline void SetTriFunctions(void);

    //
    // Buffer management methods.
    //
    inline void ResetBuffer(void);
    HRESULT Flush(void);
    HRESULT FlushPartial(void);
    HRESULT AppendPrim(void);

#if DBG
    //
    // Debug methods.  Only callable within DBG builds.
    //
    inline HRESULT ValidateVertex(LPD3DTLVERTEX pV);
#endif
};

//----------------------------------------------------------------------------
//
// PrimProcessor::GetFlags
//
// Returns the current PrimProcessor flags.
//
//----------------------------------------------------------------------------

inline UINT
PrimProcessor::GetFlags(void)
{
    return m_uPpFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetFlags
//
// Sets the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetFlags(UINT uFlags)
{
    m_uPpFlags |= uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ClrFlags
//
// Clears the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ClrFlags(UINT uFlags)
{
    m_uPpFlags &= ~uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::StateChanged
//
// Notifies the PrimProcessor that state has changed.
// Could be done through SetFlags but this hides the actual implementation.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::StateChanged(void)
{
    m_uPpFlags |= PPF_STATE_CHANGED;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ComputeIntCarry
//
// Takes an FP coordinate value and span delta and computes integer form
// for int/carry arithmetic.
//
// NOTE: Assumes iV already computed.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

// Prototype is:
// inline void
// PrimProcessor::ComputeIntCarry(FLOAT fV, FLOAT fDVDS, PINTCARRYVAL pICY)
//
// Fraction is biased by one to handle exactly-integer coordinate
// values properly.

#define ComputeIntCarry(fV, fDVDS, pICY)                                      \
    ((pICY)->iFrac = (SCALED_FRACTION((fV) - FLOORF(fV)) - 1) & 0x7fffffff,   \
     (pICY)->iNC = FTOI(fDVDS),                                               \
     (pICY)->iDFrac = SCALED_FRACTION((fDVDS) - (pICY)->iNC),                 \
     (pICY)->iCY = FLOAT_LTZ(fDVDS) ? (pICY)->iNC - 1 : (pICY)->iNC + 1)

//----------------------------------------------------------------------------
//
// PrimProcessor::GetPrim
//
// Moves prim pointer to the next position in the buffer, flushing
// to make space if necessary.  Checks to see if there's space for
// at least one span also since it doesn't make much sense to not
// flush if there's exactly enough space for just the prim structure.
//
// Does not update m_pCur until CommitPrim.  m_pCur == pPrim
// indicates pPrim is not fully valid.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define GET_PRIM()                                                            \
{                                                                             \
    if (m_pCur + (sizeof(D3DI_RASTPRIM) + sizeof(D3DI_RASTSPAN)) >            \
        m_pBufferEnd)                                                         \
    {                                                                         \
        HRESULT hr;                                                           \
                                                                              \
        RSHRRET(Flush());                                                     \
    }                                                                         \
                                                                              \
    m_StpCtx.pPrim = (PD3DI_RASTPRIM)m_pCur;                                  \
}

//----------------------------------------------------------------------------
//
// PrimProcessor::CommitPrim
//
// Commits the current primitive space so that spans may be added.
// The primitive data can be partly or fulled cleared as part of
// the commit.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define COMMIT_PRIM(bClearAll)                                                \
{                                                                             \
    m_pCur = (PUINT8)(m_StpCtx.pPrim + 1);                                    \
                                                                              \
    if (m_pOldPrim != NULL)                                                   \
    {                                                                         \
        m_pOldPrim->pNext = m_StpCtx.pPrim;                                   \
    }                                                                         \
    m_pOldPrim = m_StpCtx.pPrim;                                              \
                                                                              \
    if (bClearAll)                                                            \
    {                                                                         \
        memset(m_StpCtx.pPrim, 0, sizeof(*m_StpCtx.pPrim));                   \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        m_StpCtx.pPrim->uSpans = 0;                                           \
        m_StpCtx.pPrim->pNext = NULL;                                         \
    }                                                                         \
}

#define ALLOC_SPANS(pStpCtx, pcSpans, ppSpan) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->AllocSpans(pcSpans, ppSpan)
#define FREE_SPANS(pStpCtx, cSpans) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->FreeSpans(cSpans)

// Compute texture difference times 1/W.
#define PERSP_TEXTURE_DELTA(fTb, fRb, fTa, fTRa, iWrap)                       \
    ((TextureDiff((fTb), (fTa), (iWrap)) + (fTa)) * (fRb) - (fTRa))

// Extract components from a packed color.
#define SPLIT_COLOR(uPacked, uB, uG, uR, uA)                                  \
    ((uB) = (UINT)RGBA_GETBLUE(uPacked),                                      \
     (uG) = (UINT)RGBA_GETGREEN(uPacked),                                     \
     (uR) = (UINT)RGBA_GETRED(uPacked),                                       \
     (uA) = (UINT)RGBA_GETALPHA(uPacked))

// Compute FP deltas from the difference of the given packed color
// and the given components.
#define COLOR_DELTA(uPacked, uB, uG, uR, uA, fDB, fDG, fDR, fDA)              \
    ((fDB) = (FLOAT)((INT)((UINT)RGBA_GETBLUE(uPacked)-(uB)) << COLOR_SHIFT), \
     (fDG) = (FLOAT)((INT)((UINT)RGBA_GETGREEN(uPacked)-(uG)) << COLOR_SHIFT),\
     (fDR) = (FLOAT)((INT)((UINT)RGBA_GETRED(uPacked)-(uR)) << COLOR_SHIFT),  \
     (fDA) = (FLOAT)((INT)((UINT)RGBA_GETALPHA(uPacked)-(uA)) << COLOR_SHIFT))

// Extract components from a packed index color.
// Applies a .5F offset to the color index to effect rounding
// when the color index is truncated.
#define SPLIT_IDX_COLOR(uPacked, iIdx, iA)                                    \
    ((iIdx) = (INT32)CI_MASKALPHA(uPacked) + (1<<(INDEX_COLOR_VERTEX_SHIFT-1)),                                   \
     (iA) = (INT32)CI_GETALPHA(uPacked))

#define IDX_COLOR_DELTA(uPacked, iIdx, iA, fDIdx, fDA)                        \
    ((fDIdx) = (FLOAT)((((INT32)CI_MASKALPHA(uPacked) +                       \
                    (1<<(INDEX_COLOR_VERTEX_SHIFT-1))) - (iIdx)) <<           \
                       INDEX_COLOR_FIXED_SHIFT),                              \
     (fDA) = (FLOAT)(((INT32)CI_GETALPHA(uPacked) - (iA)) <<                  \
                     INDEX_COLOR_SHIFT))

#endif // #ifndef _SETUP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\i386src.inc ===
i386_SOURCES = $O\attrsx86.asm $O\tstpx86.asm $O\walkx86.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
typedef struct tagATTRSET
{
    union
    {
        struct
        {
            PUINT8 pSurface, pZ;
        };
        struct
        {
            INT32 ipSurface, ipZ;
        };
    };

    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };

    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };


    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
        struct
        {
            FLOAT fDIdx, fDIdxA;
        };
        struct
        {
            INT32 iDIdx, iDIdxA;
        };
        struct
        {
            UINT32 uDIdx, uDIdxA;
        };
    };

    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS;
        };
        struct
        {
            INT32 iBS, iGS, iRS;
        };
        struct
        {
            UINT32 uBS, uGS, uRS;
        };
    };
    union
    {
        FLOAT fFog;
        INT32 iFog;
        UINT32 uFog;
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef struct tagSETUPCTX *PSETUPCTX;

typedef void (FASTCALL *PFN_ADDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, PSETUPCTX pStpCtx);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta,
     PSETUPCTX pStpCtx, int iScale);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     PSETUPCTX pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[];

// Triangle trapezoid walkers.
typedef HRESULT (FASTCALL *PFN_WALKTRAPSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     PSETUPCTX pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[];
extern PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs, PSETUPCTX pStpCtx);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

typedef void (FASTCALL *PFN_SETUPTRIATTR)
    (PSETUPCTX pStpCtx, LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
     LPD3DTLVERTEX pV2);

//
// Setup flags.
//

// Per primitive set.
#define PRIMSF_DIFF_USED                0x00000001
#define PRIMSF_SPEC_USED                0x00000002
#define PRIMSF_TEX1_USED                0x00000004
#define PRIMSF_TEX2_USED                0x00000008
#define PRIMSF_DIDX_USED                0x00000010
#define PRIMSF_LOCAL_FOG_USED           0x00000020
#define PRIMSF_GLOBAL_FOG_USED          0x00000040
#define PRIMSF_Z_USED                   0x00000080
#define PRIMSF_LOD_USED                 0x00000100
#define PRIMSF_PERSP_USED               0x00000200
#define PRIMSF_FLAT_SHADED              0x00000400

#define PRIMSF_COLORS_USED              (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED)
#define PRIMSF_TEX_USED                 (PRIMSF_TEX1_USED | PRIMSF_TEX2_USED)
#define PRIMSF_ALL_USED \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_PERSP_USED | \
     PRIMSF_DIDX_USED)

#define PRIMSF_SLOW_USED \
    (PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_TEX2_USED)

#define PRIMSF_ALL \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_DIDX_USED  | PRIMSF_LOCAL_FOG_USED |\
     PRIMSF_GLOBAL_FOG_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_PERSP_USED | PRIMSF_FLAT_SHADED)

// Per primitive.
#define PRIMF_FIXED_OVERFLOW            0x00001000
#define PRIMF_TRIVIAL_ACCEPT_Y          0x00002000
#define PRIMF_TRIVIAL_ACCEPT_X          0x00004000

#define PRIMF_ALL \
    (PRIMF_TRIVIAL_ACCEPT_Y | PRIMF_TRIVIAL_ACCEPT_X | PRIMF_FIXED_OVERFLOW)

// No point flags right now.
#define PTF_ALL 0

// Per line.
#define LNF_X_MAJOR                     0x00008000

#define LNF_ALL \
    (LNF_X_MAJOR)

// Per triangle.
#define TRIF_X_DEC                      0x00008000
#define TRIF_RASTPRIM_OVERFLOW          0x00010000

#define TRIF_ALL \
    (TRIF_X_DEC | TRIF_RASTPRIM_OVERFLOW)

// PWL support flags.
#define PWL_NEXT_LOD                    0x00000001

#ifdef PWL_FOG
#define PWL_NEXT_FOG                    0x00000002
// Suppress computation of next fog for lines.
// No equivalent flag for LOD since lines don't support LOD.
#define PWL_NO_NEXT_FOG                 0x00000004
#endif

// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current PrimProcessor for span allocator calls.
    PVOID PrimProcessor;

    // Current primitive.
    PD3DI_RASTPRIM pPrim;

    // Per-primitive flags.
    UINT uFlags;

    // Flat shading vertex pointer.
    LPD3DTLVERTEX pFlatVtx;

    // Maximum span length allowed.
    INT cMaxSpan;

    //
    // Piecewise-linear support for LOD and global fog.
    //
    UINT uPwlFlags;

    // LOD.
    FLOAT fNextW;
    FLOAT fNextOoW;
    FLOAT fNextUoW1, fNextVoW1;
    INT iNextLOD;

    // Local fog X delta.  Fog deltas are always sent through RASTSPAN
    // instead of RASTPRIM to make the local and global cases the same.
    // For the local fog case where the delta doesn't change convert
    // it once and keep it here.
    INT iDLocalFogDX;
#ifdef PWL_FOG
    // Global fog.
    FLOAT fNextZ;
    UINT uNextFog;
#endif

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKTRAPSPANS pfnWalkTrapSpans;

    // Triangle attribute setup beads.
    PFN_SETUPTRIATTR pfnTriSetupFirstAttr;
    PFN_SETUPTRIATTR pfnTriSetupZEnd;
    PFN_SETUPTRIATTR pfnTriSetupTexEnd;
    PFN_SETUPTRIATTR pfnTriSetupDiffEnd;
    PFN_SETUPTRIATTR pfnTriSetupSpecEnd;
    PFN_SETUPTRIATTR pfnTriSetupFogEnd;

    // Current X and Y values.
    INT iX, iY;

    union
    {
        // Edge fraction and delta for lines.
        struct
        {
            INT iLineFrac, iDLineFrac;
        };

        // Edge X walkers for triangles.
        struct
        {
            INTCARRYVAL X20, X10, X21;
        };
    };

    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;

    // Long edge attribute values.
    ATTRSET Attr;

    union
    {
        // Attribute major axis deltas for lines.
        ATTRSET DAttrDMajor;

        // Attribute X deltas for triangles.
        ATTRSET DAttrDX;
    };

    // Attribute Y deltas.
    ATTRSET DAttrDY;

    // Span-to-span deltas when attribute edge carries a pixel.
    INT iDXCY, iDYCY;
    ATTRSET DAttrCY;

    // Span-to-span deltas when attribute edge doesn't carry a pixel.
    INT iDXNC, iDYNC;
    ATTRSET DAttrNC;

    union
    {
        // One over length for lines.
        FLOAT fOoLen;

        // One over determinant for triangles.
        FLOAT fOoDet;
    };

    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;

    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;

    // Subpixel correction amounts.
    union
    {
        // Lines.
        FLOAT fDMajor;

        // Triangles.
        struct
        {
            FLOAT fDX, fDY;
        };
    };

    // Pixel length of line.
    INT cLinePix;
} SETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\attrs.cpp ===
//----------------------------------------------------------------------------
//
// attrs.cpp
//
// Cross-platform attribute handling functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

//----------------------------------------------------------------------------
//
// AddFloatAttrs_Any
//
// Adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
//
//----------------------------------------------------------------------------

void FASTCALL
AddFloatAttrs_Any(PATTRSET pAttr, PATTRSET pDelta, PSETUPCTX pStpCtx)
{
    pAttr->pSurface += pDelta->ipSurface;
    pAttr->pZ += pDelta->ipZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pAttr->fZ += pDelta->fZ;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        pAttr->fOoW += pDelta->fOoW;
    
        pAttr->fUoW[0] += pDelta->fUoW[0];
        pAttr->fVoW[0] += pDelta->fVoW[0];
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i];
            pAttr->fVoW[i] += pDelta->fVoW[i];
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB;
        pAttr->fG += pDelta->fG;
        pAttr->fR += pDelta->fR;
        pAttr->fA += pDelta->fA;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx;
        pAttr->fDIdxA += pDelta->fDIdxA;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS;
        pAttr->fGS += pDelta->fGS;
        pAttr->fRS += pDelta->fRS;
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog;
    }
}

//----------------------------------------------------------------------------
//
// AddScaledFloatAttrs_Any_Either
//
// Scales and adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
// Uses PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
AddScaledFloatAttrs_Any_Either(PATTRSET pAttr, PATTRSET pDelta,
                               PSETUPCTX pStpCtx, INT iScale)
{
    FLOAT fScale = (FLOAT)iScale;

    pAttr->pSurface += pDelta->ipSurface * iScale;
    pAttr->pZ += pDelta->ipZ * iScale;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
#ifdef PWL_FOG
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pAttr->fZ = pStpCtx->fNextZ;
        }
        else
#endif
        {
            pAttr->fZ += pDelta->fZ * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            pAttr->fOoW = pStpCtx->fNextOoW;
            pAttr->fUoW[0] = pStpCtx->fNextUoW1;
            pAttr->fVoW[0] = pStpCtx->fNextVoW1;
        }
        else
        {
            pAttr->fOoW += pDelta->fOoW * fScale;
            pAttr->fUoW[0] += pDelta->fUoW[0] * fScale;
            pAttr->fVoW[0] += pDelta->fVoW[0] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i] * fScale;
            pAttr->fVoW[i] += pDelta->fVoW[i] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB * fScale;
        pAttr->fG += pDelta->fG * fScale;
        pAttr->fR += pDelta->fR * fScale;
        pAttr->fA += pDelta->fA * fScale;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx * fScale;
        pAttr->fDIdxA += pDelta->fDIdxA * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS * fScale;
        pAttr->fGS += pDelta->fGS * fScale;
        pAttr->fRS += pDelta->fRS * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog * fScale;
    }
}

//----------------------------------------------------------------------------
//
// FillSpanFloatAttrs_Any_Either
//
// Fills in a span structure with the given attributes.
// Handles any set of attributes via USED flags.
// Uses and updates PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
FillSpanFloatAttrs_Any_Either(PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
                              PSETUPCTX pStpCtx, INT cPix)
{
    FLOAT fPix = (FLOAT)cPix;
    pSpan->pSurface = pAttr->pSurface;
    pSpan->pZ = pAttr->pZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pSpan->uZ = FTOI(pAttr->fZ);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
    
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            fW = pStpCtx->fNextW;
        }
        else if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pAttr->fOoW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = OOW_SCALE / pAttr->fOoW;
            }
        }
        else
        {
            fW = g_fOne;
        }
        
        pSpan->iW = FTOI(fW * W_SCALE);

        if (pStpCtx->uFlags & PRIMSF_LOD_USED)
        {
            // Mipmapping is enabled so compute texture LOD.
            // The span code can do linear LOD interpolation
            // so that we can do piecewise-linear approximations
            // instead of true per-pixel LOD.  In order to make this
            // work we need to compute the next LOD and a delta
            // value.  All of these values can be reused if this
            // loop goes around so keep them available for the next
            // iteration and set a flag to indicate that they've
            // been computed.

            if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
            {
                pSpan->iLOD = (INT16)pStpCtx->iNextLOD;
            }
            else
            {
                pSpan->iLOD =
                    (INT16)ComputeLOD(pStpCtx->pCtx,
                               (pAttr->fUoW[0] * OO_TEX_SCALE) * fW,
                               (pAttr->fVoW[0] * OO_TEX_SCALE) * fW,
                               fW,
                               (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                               (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            }
        
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                pStpCtx->fNextOoW = pAttr->fOoW + pStpCtx->DAttrDX.fOoW * fPix;
            
                if (FLOAT_EQZ(pStpCtx->fNextOoW))
                {
                    fW = g_fZero;
                }
                else
                {
                    fW = OOW_SCALE / pStpCtx->fNextOoW;
                }
            }
            else
            {
                pStpCtx->fNextOoW = OOW_SCALE;
                fW = g_fOne;
            }
                
            pStpCtx->fNextW = fW;
            pStpCtx->fNextUoW1 = pAttr->fUoW[0] + pStpCtx->DAttrDX.fUoW[0] * fPix;
            pStpCtx->fNextVoW1 = pAttr->fVoW[0] + pStpCtx->DAttrDX.fVoW[0] * fPix;
            pStpCtx->iNextLOD =
                ComputeLOD(pStpCtx->pCtx,
                           (pStpCtx->fNextUoW1 * OO_TEX_SCALE) * fW,
                           (pStpCtx->fNextVoW1 * OO_TEX_SCALE) * fW,
                           fW,
                           (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                           (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            pStpCtx->uPwlFlags |= PWL_NEXT_LOD;
                
            pSpan->iDLOD =
                (INT16)(FTOI((FLOAT)(pStpCtx->iNextLOD - pSpan->iLOD) / fPix));
        }
        else
        {
            pSpan->iLOD = 0;
            pSpan->iDLOD = 0;
        }
            
        pSpan->iOoW = FTOI(pAttr->fOoW);
    
        pSpan->UVoW[0].iUoW = FTOI(pAttr->fUoW[0]);
        pSpan->UVoW[0].iVoW = FTOI(pAttr->fVoW[0]);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pSpan->UVoW[i].iUoW = FTOI(pAttr->fUoW[i]);
            pSpan->UVoW[i].iVoW = FTOI(pAttr->fVoW[i]);
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT16)(FTOI(pAttr->fB));
        pSpan->uG = (UINT16)(FTOI(pAttr->fG));
        pSpan->uR = (UINT16)(FTOI(pAttr->fR));
        pSpan->uA = (UINT16)(FTOI(pAttr->fA));
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = FTOI(pAttr->fDIdx);
        pSpan->iIdxA = FTOI(pAttr->fDIdxA);
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT16)(FTOI(pAttr->fBS));
        pSpan->uGS = (UINT16)(FTOI(pAttr->fGS));
        pSpan->uRS = (UINT16)(FTOI(pAttr->fRS));
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pSpan->uFog = (UINT16)(FTOI(pAttr->fFog));
        pSpan->iDFog = (INT16)(pStpCtx->iDLocalFogDX);
    }
#ifdef PWL_FOG
    else if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
    {
        FLOAT fOoZScale;
        
        // The span code doesn't have direct global fog support.
        // It's faked by setup doing PWL approximations here
        // similarly to how LOD is handled.
        
        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fOoZScale = OO_Z16_SCALE;
        }
        else
        {
            fOoZScale = OO_Z32_SCALE;
        }
        
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pSpan->uFog = pStpCtx->uNextFog;
        }
        else
        {
            pSpan->uFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                          pAttr->fZ * fOoZScale);
        }

        if ((pStpCtx->uPwlFlags & PWL_NO_NEXT_FOG) == 0)
        {
            pStpCtx->fNextZ = pAttr->fZ + pStpCtx->DAttrDX.fZ * fPix;
            pStpCtx->uNextFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                                pStpCtx->fNextZ * fOoZScale);
            pStpCtx->uPwlFlags |= PWL_NEXT_FOG;
                
            pSpan->iDFog =
                FTOI((FLOAT)((INT)pStpCtx->uNextFog -
                             (INT)pSpan->uFog) / fPix);
        }
        else
        {
            pSpan->iDFog = 0;
        }
    }
#endif
}

//
// Tables of attribute handlers.
// Indexing is with the low four PRIMSF_*_USED bits.
//

// Attribute adders.
PFN_ADDATTRS g_pfnAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFloatAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFloatAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFloatAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFloatAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFloatAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_ADDATTRS g_pfnAddFixedAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFixedAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFixedAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFixedAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFixedAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFixedAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#endif

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -2 -1 -S -D */
    AddScaledFloatAttrs_Z_Diff,                         /* 1: -2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 2: -2 -1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec,                    /* 3: -2 -1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 4: -2 +1 -S -D */
    AddScaledFloatAttrs_Z_Diff_Tex,                    /* 5: -2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 6: -2 +1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec_Tex,               /* 7: -2 +1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 8: +2 -1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 9: +2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* A: +2 -1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* B: +2 -1 +S +D */
    AddScaledFloatAttrs_Z_Tex,                    /* C: +2 +1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* D: +2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* E: +2 +1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* F: +2 +1 +S +D */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFloatAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFloatAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFloatAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFixedAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFixedAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFixedAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Float-to-fixed attribute converters.
#ifdef STEP_FIXED
PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[] =
{
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 0: -2 -1 -S -D */
    FloatAttrsToFixed_Z_Diff,                           /* 1: -2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 2: -2 -1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec,                      /* 3: -2 -1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 4: -2 +1 -S -D */
    FloatAttrsToFixed_Z_Diff_Tex,                      /* 5: -2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 6: -2 +1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec_Tex,                 /* 7: -2 +1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 8: +2 -1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 9: +2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* A: +2 -1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* B: +2 -1 +S +D */
    FloatAttrsToFixed_Z_Tex,                      /* C: +2 +1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* D: +2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* E: +2 +1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* F: +2 +1 +S +D */
};
#endif

//
// Tables of ramp mode attribute handlers.
// Indexing is with PRIMSF_TEX1_USED and PRIMSF_DIDX_USED.
//

// Attribute adders.
PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -I -1 */
    AddFloatAttrs_Z_Tex,                               /* 1: -I +1 */
    AddFloatAttrs_Z_DIdx,                               /* 2: +I -1 */
    AddFloatAttrs_Z_DIdx_Tex,                          /* 3: +I +1 */
};

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -I -1 */
    AddScaledFloatAttrs_Z_Tex,                         /* 1: -I +1 */
    AddScaledFloatAttrs_Z_DIdx,                         /* 2: +I -1 */
    AddScaledFloatAttrs_Z_DIdx_Tex,                    /* 3: +I +1 */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -I -1 */
    FillSpanFloatAttrs_Z_Tex,                          /* 1: -I +1 */
    FillSpanFloatAttrs_Z_DIdx,                          /* 2: +I -1 */
    FillSpanFloatAttrs_Z_DIdx_Tex,                     /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhalp.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     (((D3D_MAXRENDERSTATES + (D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)) >> 3) + 2)
#define RAST_TSS_DIRTYBIT( _Stage, _State ) \
    ((UINT32)(D3D_MAXRENDERSTATES + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

typedef struct _UV_UNION {
    union {
        D3DVALUE    tu;
        D3DVALUE    dvTU;

        INT32 iU;
        FLOAT fU;

        INT32 iUoW;        // 1.11.20 texture coordinates
        FLOAT fUoW;

        INT32 iDUoWDX;         // 1.11.20
        FLOAT fDUoWDX;

        INT32 iDUoWDY; // 1.11.20
        FLOAT fDUoWDY;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;

        INT32 iV;
        FLOAT fV;

        INT32 iVoW;        // 1.11.20 texture coordinates
        FLOAT fVoW;

        INT32 iDVoWDX;         // 1.11.20
        FLOAT fDVoWDX;

        INT32 iDVoWDY; // 1.11.20
        FLOAT fDVoWDY;
    };
}UV_UNION;

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    UV_UNION UVoW[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value


    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

    UINT8 pPad[16];

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    UV_UNION DUVoWDX[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    UV_UNION DUVoWDY[D3DHAL_TSS_MAXSTAGES];


    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    UINT8 uPad[72];

    // Anything else needed

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE          (0x00000008L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,
    D3DI_SPTFMT_S1Z15    =36,
    D3DI_SPTFMT_S8Z24    =37,

    // NOTE: this must be changed in conjunction with RR_STYPE in ref\inc\refrast.hpp

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write

    UV_UNION TexUV[D3DHAL_TSS_MAXSTAGES];
    D3DCOLOR    TexCol[D3DHAL_TSS_MAXSTAGES];  // [Texture]

    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);
typedef void (CDECL *PFNTEXADDRESS)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS, INT32 iTex);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3D_MAXRENDERSTATES];
        FLOAT pfRenderState[D3D_MAXRENDERSTATES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    union
    {
    DWORD pdwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    FLOAT pfTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    };

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[D3DHAL_TSS_MAXSTAGES];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;
    // Number of active texture stages for blending. It's set in spaninit()
    // and used in TexBlend_TexM_Gen.
    UINT cActBldStage;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNTEXADDRESS   pfnTexAddr[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexAddrEnd;
    PFNTEXREAD      pfnTexRead[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[D3DHAL_TSS_MAXSTAGES];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTexAddr[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexRead[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    UV_UNION  texCoord[D3DHAL_TSS_MAXSTAGES]; /* Texture coordinates */
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

extern "C" {
//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    DebugBreak();
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif
#define MAX_LEN 1
#ifdef MAX_LEN
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and take the max of each length
    // like classic OpenGL and the current RefRast implementation
    fCoverage = max(OctagonNorm(fDUDX, fDVDX), OctagonNorm(fDUDY, fDVDY));
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGSTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    return 0;
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_PSIZE)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        for (INT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(dwFVF, i))
            {
            case D3DFVF_TEXTUREFORMAT2: dwStride += sizeof(D3DVALUE) * 2; break;
            case D3DFVF_TEXTUREFORMAT1: dwStride += sizeof(D3DVALUE) * 1; break;
            case D3DFVF_TEXTUREFORMAT3: dwStride += sizeof(D3DVALUE) * 3; break;
            case D3DFVF_TEXTUREFORMAT4: dwStride += sizeof(D3DVALUE) * 4; break;
            }
        }
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return DD_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\buffer.cpp ===
//----------------------------------------------------------------------------
//
// buffer.cpp
//
// PrimProcessor buffering methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

// Define to use new/delete instead of VirtualAlloc/VirtualFree.
#if 0
#define USE_CPP_HEAP
#endif

// Define to show FP exceptions.
#if 0
#define UNMASK_EXCEPTIONS
#endif

//----------------------------------------------------------------------------
//
// PrimProcessor::PrimProcessor
//
// Initializes a triangle processor to an invalid state.
//
//----------------------------------------------------------------------------

PrimProcessor::PrimProcessor(void)
{
    // Zero everything to NULL initial pointers and eliminate FP garbage.
    memset(this, 0, sizeof(PrimProcessor)); // TODO: Fix this unextendable stuff.

    m_StpCtx.PrimProcessor = (PVOID)this;

    // Initialize to values that will force a validation.
    // ATTENTION - Default to normalizing RHW.  This is a performance hit
    // and should be removed if possible.
    m_uPpFlags = PPF_STATE_CHANGED | PPF_NORMALIZE_RHW;
    m_PrimType = D3DPT_FORCE_DWORD;
    m_VertType = RAST_FORCE_DWORD;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Initialize
//
// Initializes the triangle processor to an active state.
//
//----------------------------------------------------------------------------

#define CACHE_LINE 32
#define BUFFER_SIZE 4096
// Uncomment to force a flush every span for debug purposes
//#define BUFFER_SIZE ((8 * sizeof(D3DI_RASTSPAN)) + sizeof(D3DI_RASTPRIM))

// TODO: Move into constructor? How many places called?
HRESULT
PrimProcessor::Initialize(void)
{
    HRESULT hr;

    INT32 uSize = sizeof(D3DI_RASTPRIM);

    // Assert that both RASTPRIM and RASTSPAN are multiples of the cache
    // line size so that everything in the buffer stays cache aligned.
    RSASSERT((uSize & (CACHE_LINE - 1)) == 0 &&
             (uSize & (CACHE_LINE - 1)) == 0);

#ifdef USE_CPP_HEAP
    m_pBuffer = new UINT8[BUFFER_SIZE];
#else
    // Get a page-aligned buffer.
    m_pBuffer = (PUINT8)
        VirtualAlloc(NULL, BUFFER_SIZE,
                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#endif
    if (m_pBuffer == NULL)
    {
        return RSHRCHK(E_OUTOFMEMORY);
    }

    m_pBufferEnd = m_pBuffer+BUFFER_SIZE;

#ifdef USE_CPP_HEAP
    // Compute cache-line aligned start in the buffer.  Formulated
    // somewhat oddly to avoid casting a complete pointer to a DWORD and
    // back.
    m_pBufferStart = m_pBuffer +
        ((CACHE_LINE - ((UINT)m_pBuffer & (CACHE_LINE - 1))) &
         (CACHE_LINE - 1));
#else
    // Page aligned memory should be cache aligned.
    RSASSERT(((UINT_PTR)m_pBuffer & (CACHE_LINE - 1)) == 0);
    m_pBufferStart = m_pBuffer;
#endif

    m_pCur = m_pBufferStart;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::~PrimProcessor
//
//----------------------------------------------------------------------------

PrimProcessor::~PrimProcessor(void)
{
#ifdef USE_CPP_HEAP
    delete m_pBuffer;
#else
    if (m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
    }
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ResetBuffer
//
// Initialize buffer pointers to an empty state.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ResetBuffer(void)
{
    m_pCur = m_pBufferStart;
    m_StpCtx.pPrim = NULL;
    m_pOldPrim = NULL;
}

//----------------------------------------------------------------------------
//
// DumpPrims
//
// Debugging function to dump primitives sent to the span renderer.
//
//----------------------------------------------------------------------------

#if DBG
void
DumpPrims(PSETUPCTX pStpCtx)
{
    PD3DI_RASTPRIM pPrim;
    UINT uOldFlags;

    uOldFlags = RSGETFLAGS(DBG_OUTPUT_FLAGS);
    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags | DBG_OUTPUT_ALL_MATCH);

    for (pPrim = pStpCtx->pCtx->pPrim; pPrim != NULL; pPrim = pPrim->pNext)
    {
        RSDPFM((RSM_BUFPRIM, "Prim at %p, %d spans at %p\n",
                pPrim, pPrim->uSpans, pPrim+1));
        RSDPFM((RSM_BUFPRIM | RSM_OOW, "  DOoWDX %X (%f)\n",
                pPrim->iDOoWDX, (FLOAT)pPrim->iDOoWDX / OOW_SCALE));

        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & RSM_BUFSPAN) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            PD3DI_RASTSPAN pSpan;
            UINT16 i;

            pSpan = (PD3DI_RASTSPAN)(pPrim+1);
            for (i = 0; i < pPrim->uSpans; i++)
            {
                RSDPFM((RSM_BUFSPAN,
                        "  Span at (%d,%d), pix %c%d, S %p Z %p\n",
                        pSpan->uX, pSpan->uY,
                        (pPrim->uFlags & D3DI_RASTPRIM_X_DEC) ? '-' : '+',
                        pSpan->uPix, pSpan->pSurface, pSpan->pZ));

                if (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                                  RSU_CHECK_SPAN_EDGES))
                {
                    PUINT16 pPix;

                    pPix = (PUINT16)pSpan->pSurface;
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                    {
                        if (*pPix != 0)
                        {
                            RSDPF(("  Overwrite at %p: %X\n", pPix, *pPix));
                        }
                    }
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                    {
                        *pPix = 0xffff;
                    }

                    if (pSpan->uPix > 1)
                    {
                        if (pPrim->uFlags & D3DI_RASTPRIM_X_DEC)
                        {
                            pPix = (PUINT16)pSpan->pSurface -
                                (pSpan->uPix - 1);
                        }
                        else
                        {
                            pPix = (PUINT16)pSpan->pSurface +
                                (pSpan->uPix - 1);
                        }

                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                        {
                            if (*pPix != 0)
                            {
                                RSDPF(("  Overwrite at %p: %X\n",
                                       pPix, *pPix));
                            }
                        }
                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                        {
                            *pPix = 0xffff;
                        }
                    }
                }

                FLOAT fZScale;
                if (pStpCtx->pCtx->iZBitCount == 16)
                {
                    fZScale = Z16_SCALE;
                }
                else
                {
                    fZScale = Z32_SCALE;
                }
                RSDPFM((RSM_BUFSPAN | RSM_Z,
                        "    Z %X (%f)\n",
                        pSpan->uZ, (FLOAT)pSpan->uZ / fZScale));

                RSDPFM((RSM_BUFSPAN | RSM_DIFF,
                        "    D %X,%X,%X,%X (%f,%f,%f,%f)\n",
                        pSpan->uB, pSpan->uG, pSpan->uR, pSpan->uA,
                        (FLOAT)pSpan->uB / COLOR_SCALE,
                        (FLOAT)pSpan->uG / COLOR_SCALE,
                        (FLOAT)pSpan->uR / COLOR_SCALE,
                        (FLOAT)pSpan->uA / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_SPEC,
                        "    S %X,%X,%X (%f,%f,%f)\n",
                        pSpan->uBS, pSpan->uGS, pSpan->uRS,
                        (FLOAT)pSpan->uBS / COLOR_SCALE,
                        (FLOAT)pSpan->uGS / COLOR_SCALE,
                        (FLOAT)pSpan->uRS / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_DIDX,
                        "    I %X,%X (%f,%f)\n",
                        pSpan->iIdx, pSpan->iIdxA,
                        (FLOAT)pSpan->iIdx / INDEX_COLOR_SCALE,
                        (FLOAT)pSpan->iIdxA / INDEX_COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_OOW,
                        "    OoW %X (%f), W %X (%f)\n",
                        pSpan->iOoW, (FLOAT)pSpan->iOoW / OOW_SCALE,
                        pSpan->iW, (FLOAT)pSpan->iW / W_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_LOD,
                        "    LOD %X (%f), DLOD %X (%f)\n",
                        pSpan->iLOD, (FLOAT)pSpan->iLOD / LOD_SCALE,
                        pSpan->iDLOD, (FLOAT)pSpan->iDLOD / LOD_SCALE));

                if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    PTex1 %X,%X (%f,%f) (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE,
                            ((FLOAT)pSpan->UVoW[0].iUoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW),
                            ((FLOAT)pSpan->UVoW[0].iVoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW)));
                }
                else
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    ATex1 %X,%X (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE));
                }

                RSDPFM((RSM_BUFSPAN | RSM_FOG,
                        "    Fog %X (%f), DFog %X (%f)\n",
                        pSpan->uFog, (FLOAT)pSpan->uFog / FOG_SCALE,
                        pSpan->iDFog, (FLOAT)pSpan->iDFog / FOG_SCALE));

                pSpan++;
            }
        }
    }

    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags);
}
#endif // DBG

//----------------------------------------------------------------------------
//
// PrimProcessor::Flush
//
// Flushes any remaining data from the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Flush(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        // Process data.
        m_StpCtx.pCtx->pPrim = (PD3DI_RASTPRIM)m_pBufferStart;
        m_StpCtx.pCtx->pNext = NULL;

#if DBG
        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & (RSM_BUFPRIM | RSM_BUFSPAN)) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            DumpPrims(&m_StpCtx);
        }

        if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_NO_RENDER_SPANS) == 0)
        {
            if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_BREAK_ON_RENDER_SPANS)
            {
                DebugBreak();
            }

            RSHRCHK(m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx));
        }
        else
        {
            hr = DD_OK;
        }
#else
        hr = m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx);
#endif

        ResetBuffer();
    }
    else
    {
        hr = DD_OK;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FlushPartial
//
// Flushes the buffer in the middle of a primitive.  Preserves last
// partial primitive and replaces it in the buffer after the flush.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::FlushPartial(void)
{
    D3DI_RASTPRIM SavedPrim;
    HRESULT hr;

    RSDPFM((RSM_BUFFER, "FlushPartial, saving prim at %p, Y %d\n",
            m_StpCtx.pPrim, m_StpCtx.iY));

    // Not enough space.  Flush current buffer.  We need to
    // save the current prim and put it back in the buffer after the
    // flush since it's being extended.
    SavedPrim = *m_StpCtx.pPrim;

    RSHRRET(Flush());

    GET_PRIM();

    *m_StpCtx.pPrim = SavedPrim;
    COMMIT_PRIM(FALSE);

    return DD_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AppendPrim
//
// Ensures that some primitive is active in the buffer for spans to
// be added to.  If no valid primitive is available to append to,
// a zeroed primitive is committed into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::AppendPrim(void)
{
    // If there's no primitive or the current primitive has not
    // been committed, commit a clean primitive into the buffer.
    if (m_StpCtx.pPrim == NULL ||
        (PUINT8)m_StpCtx.pPrim == m_pCur)
    {
        GET_PRIM();
        COMMIT_PRIM(TRUE);
    }

    return DD_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Begin
//
// Resets the buffer to an empty state in preparation for incoming
// triangles.
//
//----------------------------------------------------------------------------

void
PrimProcessor::Begin(void)
{
    UINT16 uFpCtrl;
    FPU_GET_MODE(uFpCtrl);
    m_uFpCtrl = uFpCtrl;
    uFpCtrl =
        FPU_MODE_CHOP_ROUND(
                FPU_MODE_LOW_PRECISION(
                        FPU_MODE_MASK_EXCEPTIONS(m_uFpCtrl)));
#if defined(_X86_) && defined(UNMASK_EXCEPTIONS)
    // Unmask some exceptions so that we can eliminate them.
    // This requires a safe set to clear any exceptions that
    // are currently asserted.
    //
    // Exceptions left masked:
    //   Precision, denormal.
    // Exceptions unmasked:
    //   Underflow, overflow, divzero, invalid op.
    uFpCtrl &= ~0x1d;
    FPU_SAFE_SET_MODE(uFpCtrl);
#else
    FPU_SET_MODE(uFpCtrl);
#endif

    m_uPpFlags |= PPF_IN_BEGIN;
    ResetBuffer();
}

//----------------------------------------------------------------------------
//
// PrimProcessor::End
//
// Flushes if necessary and cleans up.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::End(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        RSHRCHK(Flush());
    }
    else
    {
        hr = DD_OK;
    }

    UINT16 uFpCtrl = m_uFpCtrl;
    FPU_SAFE_SET_MODE(uFpCtrl);

    m_uPpFlags &= ~PPF_IN_BEGIN;

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetCtx
//
// Sets the rasterization context to operate in.
//
//----------------------------------------------------------------------------

void
PrimProcessor::SetCtx(PD3DI_RASTCTX pCtx)
{
    // This function can't be called inside a Begin/End pair.  This
    // is enforced so that we don't have to worry about the span
    // rendering function changing in the middle of a batch.
    RSASSERT((m_uPpFlags & PPF_IN_BEGIN) == 0);

    m_StpCtx.pCtx = pCtx;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AllocSpans
//
// Checks to see if there's room in the buffer for the requested number
// of spans.  If so the buffer pointer is updated and a pointer is returned.
// If the requested number is not available but some reasonable number is,
// return that many.  Otherwise the buffer is flushed and the process starts
// over.  The "reasonable" number must therefore be no more than what
// can fit in the buffer at once.
//
//----------------------------------------------------------------------------

// Space for enough spans to avoid a flush.
#define AVOID_FLUSH_SPACE (8 * sizeof(D3DI_RASTSPAN))

HRESULT
PrimProcessor::AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    UINT uSpanSize;

    RSASSERT(AVOID_FLUSH_SPACE <= (BUFFER_SIZE - sizeof(D3DI_RASTPRIM)));
    // The multiplies and divides here will be really bad unless
    // RASTPRIM is a nice power-of-two in size.
    RSASSERT((sizeof(D3DI_RASTSPAN) & (sizeof(D3DI_RASTSPAN) - 1)) == 0);

    uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);

    for (;;)
    {
        // First check for space for all requested spans.
        if (m_pCur + uSpanSize > m_pBufferEnd)
        {
            // Not enough space for everything, so see if we have
            // enough space to avoid a flush.
            if (m_pCur + AVOID_FLUSH_SPACE > m_pBufferEnd)
            {
                // Not enough space, so flush.
                RSHRCHK(FlushPartial());
                if (hr != DD_OK)
                {
                    *pcSpans = 0;
                    return hr;
                }

                // Loop around.  Flush is guaranteed to at least produce
                // AVOID_FLUSH_SPACE so the loop will always exit.
            }
            else
            {
                // Not enough space for everything but enough space
                // to return some.  Set new span count.
                *pcSpans = (UINT)((m_pBufferEnd - m_pCur) / sizeof(D3DI_RASTSPAN));
                uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);
                break;
            }
        }
        else
        {
            break;
        }
    }

    pSpan = (PD3DI_RASTSPAN)m_pCur;
    m_pCur += uSpanSize;
    *ppSpan = pSpan;

    RSDPFM((RSM_BUFFER, "Alloc %d spans at %p, cur %p\n",
            *pcSpans, pSpan, m_pCur));

    return DD_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FreeSpans and FreeSpans
//
// Returns space given out by AllocSpans.
//
//----------------------------------------------------------------------------

void
PrimProcessor::FreeSpans(UINT cSpans)
{
    m_pCur -= cSpans * sizeof(D3DI_RASTSPAN);

    RSDPFM((RSM_BUFFER, "Free  %d spans at %p, cur %p\n", cSpans,
            m_pCur + cSpans * sizeof(D3DI_RASTSPAN), m_pCur));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef D3DVECTOR* LPD3DVECTOR;

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by transposed 4x4 matrix, producing a
// homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4HT(D3DVECTORH *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
//  4 by 4 matrix product
//
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\pch\surfaces.h ===
namespace RGB_RAST_LIB_NAMESPACE
{
void MemFill( UINT32 uiData, void* pData, UINT32 uiBytes) throw();
void MemMask( UINT32 uiData, UINT32 uiMask, void* pData, UINT32 uiBytes) throw();

class IRGBSurface: public IVidMemSurface
{
protected:
    LONG m_lPitch;
    WORD m_wWidth;
    WORD m_wHeight;
    unsigned char m_ucBPP;

    IRGBSurface( DWORD dwHandle, LONG P, WORD W, WORD H, unsigned char BPP)
        throw(): IVidMemSurface( dwHandle), m_lPitch( P), m_wWidth( W),
        m_wHeight( H), m_ucBPP( BPP)
    { }

public:
    LONG GetGBLlPitch( void) const throw()
    { return m_lPitch; }
    WORD GetGBLwWidth( void) const throw()
    { return m_wWidth; }
    WORD GetGBLwHeight( void) const throw()
    { return m_wHeight; }
    unsigned char GetBytesPerPixel( void) const throw()
    { return m_ucBPP; }
    virtual ~IRGBSurface() throw()
    { }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()= 0;
};

class CRGBSurfAllocator
{
public: // Types
    typedef IRGBSurface TSurface;
    typedef TSurface* (*TCreateSurfFn)( const DDSURFACEDESC&,
        PORTABLE_DDRAWSURFACE_LCL&);

protected: // Types
    typedef vector< std::pair< DDSURFACEDESC, TCreateSurfFn> > TCreateSurfFns;
    TCreateSurfFns m_CreateSurfFns;
    struct SAdaptedMatchFn: public SMatchSDesc
    {
        typedef TCreateSurfFns::value_type argument_type;
        using SMatchSDesc::result_type;

        SAdaptedMatchFn( const DDSURFACEDESC& SDesc) throw(): SMatchSDesc( SDesc) {}

        result_type operator()( argument_type Arg) const throw()
        { return (*static_cast< const SMatchSDesc*>(this))( Arg.first); }
    };

public:
    template< class TIter>
    CRGBSurfAllocator( TIter itStart, const TIter itEnd) throw(bad_alloc)
    {
        while( itStart!= itEnd)
        {
            m_CreateSurfFns.push_back(
                TCreateSurfFns::value_type( itStart->GetMatch(), *itStart));
            ++itStart;
        }
    }

    TSurface* CreateSurf( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& Surf) const
    {
        TCreateSurfFns::const_iterator itFound( 
            find_if( m_CreateSurfFns.begin(), m_CreateSurfFns.end(),
            SAdaptedMatchFn( SDesc) ) );

        // Hey, if we don't support a VM of this surface type,
        // but how did we get asked to allocate one, then?
        if( itFound== m_CreateSurfFns.end())
            throw HRESULT( DDERR_UNSUPPORTED);

        return (itFound->second)( SDesc, Surf);
    }
};

class CRGBSurface: public IRGBSurface
{
public: // Types
    typedef unsigned int TLocks;

protected: // Variables
    void* m_pData;
    size_t m_uiBytes;
    TLocks m_uiLocks;

public: // Functions
    CRGBSurface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf)
        throw(bad_alloc): IRGBSurface( DDSurf.lpSurfMore()->dwSurfaceHandle(), 
        0, DDSurf.lpGbl()->wWidth, DDSurf.lpGbl()->wHeight, 0),
        m_pData( NULL), m_uiBytes( 0), m_uiLocks( 0)
    {
        // We must allocate this surface. Since we are specified as a SW driver,
        // DDraw will not allocate for us.
        assert((SDesc.dwFlags& DDSD_PIXELFORMAT)!= 0);

        m_ucBPP= static_cast< unsigned char>(
            SDesc.ddpfPixelFormat.dwRGBBitCount>> 3);

        // TODO: Align pitch to 128-bit bit boundary, instead?
        DDSurf.lpGbl()->lPitch= m_lPitch= ((m_ucBPP* m_wWidth+ 7)& ~7);

        m_uiBytes= m_lPitch* m_wHeight;

        // It would've been nice to have the initial proctection NOACCESS, but
        // it seems the HAL needs to read to the region, initially.
        m_pData= VirtualAlloc( NULL, m_uiBytes, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if( m_pData== NULL)
            throw bad_alloc( "Not enough memory to allocate Surface data");
        DDSurf.lpGbl()->fpVidMem= reinterpret_cast<FLATPTR>( m_pData);
    }
    virtual ~CRGBSurface() throw()
    {
        // Warning: m_uiLocks doesn't have to be 0. The run-time will destroy
        // a surface without un-locking it.
        assert( m_pData!= NULL);
        VirtualFree( m_pData, 0, MEM_DECOMMIT| MEM_RELEASE);
    }
    virtual void* Lock( DWORD dwFlags, const RECTL* pRect) throw()
    {
        numeric_limits< TLocks> Dummy;
        assert( Dummy.max()!= m_uiLocks);
#if 0   // defined(DBG) || defined(_DEBUG)
        // This code can't be enabled. Currently, run-time knows that this is
        // really a system memory surface, and thus doesn't tell us to lock it
        // into memory before using the bits. Known areas that could be fixed:
        // (surface creation needs valid pointer & Present uses pointer).
        if( 0== m_uiLocks)
        {
            DWORD dwProtect( PAGE_EXECUTE_READWRITE);
            if( dwFlags& DDLOCK_READONLY)
                dwProtect= PAGE_READONLY;
            else if( dwFlags& DDLOCK_WRITEONLY)
                dwProtect= PAGE_READWRITE;

            DWORD dwOldP;
            VirtualProtect( m_pData, m_uiBytes, dwProtect, &dwOldP);
        }
#endif
        ++m_uiLocks;

        if( pRect!= NULL)
        {
            return static_cast<void*>( reinterpret_cast<UINT8*>(
                m_pData)+ pRect->top* m_lPitch+ pRect->left* m_ucBPP);
        }
        else
            return m_pData;
    }
    virtual void Unlock( void) throw()
    {
        assert( 0!= m_uiLocks);
#if 0 // defined(DBG) || defined(_DEBUG)
        if( 0== --m_uiLocks)
        {
            DWORD dwOldP;
            VirtualProtect( m_pData, m_uiBytes, PAGE_NOACCESS, &dwOldP);
        }
#else
        --m_uiLocks;
#endif
    }
};

class CR5G6B5Surface: public CRGBSurface
{
public:
    CR5G6B5Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B5G6R5; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CR5G6B5Surface( SDesc, DDSurf);
    }
};

class CA8R8G8B8Surface: public CRGBSurface
{
public:
    CA8R8G8B8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B8G8R8A8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA8R8G8B8Surface( SDesc, DDSurf);
    }
};

class CX8R8G8B8Surface: public CRGBSurface
{
public:
    CX8R8G8B8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B8G8R8X8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CX8R8G8B8Surface( SDesc, DDSurf);
    }
};

class CD16Surface: public CRGBSurface
{
public:
    CD16Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_Z16S0; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CD16Surface( SDesc, DDSurf);
    }
};

class CD24S8Surface: public CRGBSurface
{
public:
    CD24S8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw();
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_Z24S8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CD24S8Surface( SDesc, DDSurf);
    }
};

class CX1R5G5B5Surface: public CRGBSurface
{
public:
    CX1R5G5B5Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CX1R5G5B5Surface_being_asked_to_Clear( false);
        assert( CX1R5G5B5Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B5G5R5; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CX1R5G5B5Surface( SDesc, DDSurf);
    }
};

class CA1R5G5B5Surface: public CRGBSurface
{
public:
    CA1R5G5B5Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CA1R5G5B5Surface_being_asked_to_Clear( false);
        assert( CA1R5G5B5Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B5G5R5A1; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA1R5G5B5Surface( SDesc, DDSurf);
    }
};

class CP8Surface: public CRGBSurface
{
public:
    CP8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CP8Surface_being_asked_to_Clear( false);
        assert( CP8Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_PALETTE8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CP8Surface( SDesc, DDSurf);
    }
};

class CA8L8Surface: public CRGBSurface
{
public:
    CA8L8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CA8L8Surface_being_asked_to_Clear( false);
        assert( CA8L8Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_L8A8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA8L8Surface( SDesc, DDSurf);
    }
};

class CL8Surface: public CRGBSurface
{
public:
    CL8Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CL8Surface_being_asked_to_Clear( false);
        assert( CL8Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_L8; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CL8Surface( SDesc, DDSurf);
    }
};

class CA4R4G4B4Surface: public CRGBSurface
{
public:
    CA4R4G4B4Surface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CRGBSurface( SDesc, DDSurf) { }

    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) throw()
    {
        const bool CA4R4G4B4Surface_being_asked_to_Clear( false);
        assert( CA4R4G4B4Surface_being_asked_to_Clear);
    }
    virtual D3DI_SPANTEX_FORMAT GetSpanTexFormat( void) const throw()
    { return D3DI_SPTFMT_B4G4R4A4; }

    static IRGBSurface* Create( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf) throw(bad_alloc)
    {
        return new CA4R4G4B4Surface( SDesc, DDSurf);
    }
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\attrs_mh.h: attrs_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstp_mh.h: tstp_mh.mh $(RAST_STD_M4)

$(GENTGT)\walk_mh.h: walk_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): offs_acp.acp $(RGBRASTROOT)\pch\span.h $(RGBRASTROOT)\pch\stp_base.h

$(GENTGT)\attrsx86.asm: attrsx86.mas attrsx86.mh $(RAST_STD_M4)

$(GENTGT)\attrscpp.cpp: attrscpp.mcp $(RAST_STD_M4)

$(GENTGT)\tstpx86.asm: tstpx86.mas $(RAST_STD_M4)

$(GENTGT)\tstpcpp.cpp: tstpcpp.mcp $(RAST_STD_M4)

$(GENTGT)\walkx86.asm: walkx86.mas attrsx86.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\lstp.cpp ===
//----------------------------------------------------------------------------
//
// lstp.cpp
//
// Line setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LineSetup_Start
//
// Starts setup of line attributes.
//
//----------------------------------------------------------------------------

void FASTCALL
LineSetup_Start(PSETUPCTX pStpCtx,
                LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1)
{
    FLOAT fZ0;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        FLOAT fZScale;

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        pStpCtx->DAttrDMajor.fZ =
            (pV1->dvSZ - pV0->dvSZ) * fZScale * pStpCtx->fOoLen;

        // fZ0 may be used later so set if from the vertex Z.
        fZ0 = pV0->dvSZ;
        pStpCtx->Attr.fZ = fZ0 * fZScale +
            pStpCtx->DAttrDMajor.fZ * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fUoW, fVoW;

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            pStpCtx->DAttrDMajor.fOoW =
                (pV1->dvRHW - pV0->dvRHW) * OOW_SCALE * pStpCtx->fOoLen;
            pStpCtx->Attr.fOoW = pV0->dvRHW * OOW_SCALE +
                pStpCtx->DAttrDMajor.fOoW * pStpCtx->fDMajor;

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTU, pV1->dvRHW, pV0->dvTU, fUoW,
                                    pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTV, pV1->dvRHW, pV0->dvTV, fVoW,
                                    pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            pStpCtx->DAttrDMajor.fOoW = g_fZero;
            pStpCtx->Attr.fOoW = OOW_SCALE;

            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;

            pStpCtx->DAttrDMajor.fUoW[0] =
                TextureDiff(pV1->dvTU, fUoW,
                            pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                TextureDiff(pV1->dvTV, fVoW,
                            pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW[0] = TEX_SCALE * fUoW +
            pStpCtx->DAttrDMajor.fUoW[0] * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW[0] = TEX_SCALE * fVoW +
            pStpCtx->DAttrDMajor.fVoW[0] * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        PRAST_GENERIC_VERTEX pVM0 = (PRAST_GENERIC_VERTEX)pV0;
        PRAST_GENERIC_VERTEX pVM1 = (PRAST_GENERIC_VERTEX)pV1;
        FLOAT fUoW, fVoW;

        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                fUoW = pVM0->texCoord[i].dvTU * pVM0->dvRHW;
                fVoW = pVM0->texCoord[i].dvTV * pVM0->dvRHW;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTU, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTU, fUoW,
                                        pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_U) *
                                        TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTV, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTV, fVoW,
                                        pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_V) *
                                        TEX_SCALE * pStpCtx->fOoLen;
            }
            else
            {
                fUoW = pVM0->texCoord[i].dvTU;
                fVoW = pVM0->texCoord[i].dvTV;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTU, fUoW,
                                pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_U) *
                                TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTV, fVoW,
                                pStpCtx->pCtx->pdwRenderState[D3DRS_WRAP0+i] & D3DWRAP_V) *
                                TEX_SCALE * pStpCtx->fOoLen;
            }

            pStpCtx->Attr.fUoW[i] = TEX_SCALE * fUoW +
                pStpCtx->DAttrDMajor.fUoW[i] * pStpCtx->fDMajor;
            pStpCtx->Attr.fVoW[i] = TEX_SCALE * fVoW +
                pStpCtx->DAttrDMajor.fVoW[i] * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_FLAT_SHADED)
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcColor, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fB = g_fZero;
            pStpCtx->DAttrDMajor.fG = g_fZero;
            pStpCtx->DAttrDMajor.fR = g_fZero;
            pStpCtx->DAttrDMajor.fA = g_fZero;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT);
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT);
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            pStpCtx->DAttrDMajor.fDIdx = g_fZero;
            pStpCtx->DAttrDMajor.fDIdxA = g_fZero;

            pStpCtx->Attr.fDIdx =
                (FLOAT)(CI_MASKALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_FIXED_SHIFT);
            pStpCtx->Attr.fDIdxA =
                (FLOAT)(CI_GETALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_SHIFT);
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcSpecular, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fBS = g_fZero;
            pStpCtx->DAttrDMajor.fGS = g_fZero;
            pStpCtx->DAttrDMajor.fRS = g_fZero;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT);
        }
    }
    else
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcColor, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcColor, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fB = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fG = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fR = fDR * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fB * pStpCtx->fDMajor;
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fG * pStpCtx->fDMajor;
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fR * pStpCtx->fDMajor;
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fA * pStpCtx->fDMajor;
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            INT32 iIdx, iA;
            FLOAT fDIdx, fDA;

            SPLIT_IDX_COLOR(pV0->dcColor, iIdx, iA);
            IDX_COLOR_DELTA(pV1->dcColor, iIdx, iA, fDIdx, fDA);

            pStpCtx->DAttrDMajor.fDIdx = fDIdx * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fDIdxA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fDIdx = (FLOAT)(iIdx << INDEX_COLOR_FIXED_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdx * pStpCtx->fDMajor;
            pStpCtx->Attr.fDIdxA = (FLOAT)(iA << INDEX_COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdxA * pStpCtx->fDMajor;
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcSpecular, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcSpecular, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fBS = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fGS = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fRS = fDR * pStpCtx->fOoLen;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fBS * pStpCtx->fDMajor;
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fGS * pStpCtx->fDMajor;
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fRS * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        UINT uFog0, uFog1;

#ifndef PWL_FOG
        // Check for global-into-local fog.  If global fog is on,
        // compute the local fog values from table fog rather than
        // from the vertex.
        if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure Z information is valid.
            RSASSERT(pStpCtx->uFlags & PRIMSF_Z_USED);

            uFog0 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState, fZ0);
            uFog1 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                    pV1->dvSZ);
        }
        else
#endif
        {
            uFog0 = (UINT)RGBA_GETALPHA(pV0->dcSpecular) << FOG_SHIFT;
            uFog1 = (UINT)RGBA_GETALPHA(pV1->dcSpecular) << FOG_SHIFT;
        }

        pStpCtx->DAttrDMajor.fFog =
            (FLOAT)((INT)uFog1 - (INT)uFog0) * pStpCtx->fOoLen;
        pStpCtx->Attr.fFog = (FLOAT)uFog0 +
            pStpCtx->DAttrDMajor.fFog * pStpCtx->fDMajor;
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE2(fV0, fV1) \
    ((ASUINT32(fV0) | ASUINT32(fV1)) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeLineRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || FLOAT_LTZ(pV1->dvRHW))
    {
        RSDPF(("Line RHW out of range %f,%f\n",
               pV0->dvRHW, pV1->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        fMax = pV1->dvRHW;
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
}

//-----------------------------------------------------------------------------
//
// PrimProcessor::PointDiamondCheck
//
// Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is
// pixel-relative test - this corresponds to an upper-left test for
// a vertex-relative position.
//
//-----------------------------------------------------------------------------

BOOL
PrimProcessor::PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                                 BOOL bSlopeIsOne, BOOL bSlopeIsPosOne)
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf )
    {
        return TRUE;
    }

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
    {
        return TRUE;
    }

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
    {
        return TRUE;
    }

    // return true if slope is one, vertex is on edge,
    // and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::LineSetup
//
// Does attribute setup computations.
//
//----------------------------------------------------------------------------

// Line computations are done in n.4 fixed-point to reduce vertex jitter,
// move more computation to integer and to more easily match the GDI
// line computations.
#define LINE_FIX 4
#define LINE_SNAP FLOAT_TWOPOW4
#define OO_LINE_SNAP (1.0f / FLOAT_TWOPOW4)
#define LINE_FIX_HALF (1 << (LINE_FIX - 1))
#define LINE_FIX_NEAR_HALF (LINE_FIX_HALF - 1)

BOOL
PrimProcessor::LineSetup(LPD3DTLVERTEX pV0,
                         LPD3DTLVERTEX pV1)
{
    // compute fixed point vertex values, with cheap
    // rounding for better accuracy
    INT32 iX0 = FTOI(pV0->dvSX * LINE_SNAP + .5F);
    INT32 iX1 = FTOI(pV1->dvSX * LINE_SNAP + .5F);
    INT32 iY0 = FTOI(pV0->dvSY * LINE_SNAP + .5F);
    INT32 iY1 = FTOI(pV1->dvSY * LINE_SNAP + .5F);

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // ignore zero length lines
    if ( iXSize == 0 && iYSize == 0 )
    {
        return FALSE;
    }

    INT32 iAbsXSize;
    INT32 iAbsYSize;

    if ( iXSize < 0 )
    {
        m_StpCtx.iDXCY = -1;
        iAbsXSize = -iXSize;
    }
    else
    {
        m_StpCtx.iDXCY = 1;
        iAbsXSize = iXSize;
    }

    if ( iYSize < 0 )
    {
        m_StpCtx.iDYCY = -1;
        iAbsYSize = -iYSize;
    }
    else
    {
        m_StpCtx.iDYCY = 1;
        iAbsYSize = iYSize;
    }

    BOOL bSlopeIsOne = iAbsXSize == iAbsYSize;
    BOOL bSlopeIsPosOne =
        bSlopeIsOne && ((iXSize ^ iYSize) & 0x80000000) == 0;

    // compute closest pixel for vertices
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for
    // exception (slope == +1) case else use nearest ceiling
    //
    INT32 iXAdjust;
    if (bSlopeIsPosOne)
    {
        iXAdjust = LINE_FIX_HALF;
    }
    else
    {
        iXAdjust = LINE_FIX_NEAR_HALF;
    }
    INT32 iPixX0 = ( iX0 + iXAdjust ) >> LINE_FIX;
    INT32 iPixX1 = ( iX1 + iXAdjust ) >> LINE_FIX;
    INT32 iPixY0 = ( iY0 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;
    INT32 iPixY1 = ( iY1 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;

    // determine major axis and compute step values

    // sign of extent from V0 to V1 in major direction
    BOOL bLineMajorNeg;

    INT32 iLineMajor0;
    INT32 iLineMajor1;
    INT32 iLinePix0;
    INT32 iLinePix1;
    INT32 iLinePixStep;

    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( iAbsXSize >= iAbsYSize )
    {
        // here for X major
        m_StpCtx.uFlags |= LNF_X_MAJOR;
        iLineMajor0 = iX0;
        iLineMajor1 = iX1;
        iLinePix0 = iPixX0;
        iLinePix1 = iPixX1;
        iLinePixStep = m_StpCtx.iDXCY;
        bLineMajorNeg = iXSize & 0x80000000;
        m_StpCtx.iDXNC = m_StpCtx.iDXCY;
        m_StpCtx.iDYNC = 0;
    }
    else
    {
        // here for Y major
        iLineMajor0 = iY0;
        iLineMajor1 = iY1;
        iLinePix0 = iPixY0;
        iLinePix1 = iPixY1;
        iLinePixStep = m_StpCtx.iDYCY;
        bLineMajorNeg = iYSize & 0x80000000;
        m_StpCtx.iDXNC = 0;
        m_StpCtx.iDYNC = m_StpCtx.iDYCY;
    }

    // The multiplies here could be traded for sign tests but there'd
    // be four cases.  On a PII the multiplies will be faster than
    // the branches.
    m_StpCtx.DAttrCY.ipSurface =
        m_StpCtx.iDYCY * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXCY * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipSurface =
        m_StpCtx.iDYNC * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXNC * m_StpCtx.pCtx->iSurfaceStep;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        m_StpCtx.DAttrCY.ipZ =
            m_StpCtx.iDYCY * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXCY * m_StpCtx.pCtx->iZStep;
        m_StpCtx.DAttrNC.ipZ =
            m_StpCtx.iDYNC * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXNC * m_StpCtx.pCtx->iZStep;
    }

    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0 << LINE_FIX),
                                           iY0 - (iPixY0 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1 << LINE_FIX),
                                           iY1 - (iPixY1 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );

#define LINEDIR_CMP( _A, _B ) \
    ( bLineMajorNeg ? ( (_A) > (_B) ) : ( (_A) < (_B) ) )

    // do first pixel handling - not in or behind diamond
    if ( !( bV0InDiamond ||
            LINEDIR_CMP( iLineMajor0, iLinePix0 << LINE_FIX ) ) )
    {
        iLinePix0 += iLinePixStep;
    }

    // do last-pixel handling - don't pull in extent if past diamond
    // (in which case the pixel is always filled) or if in diamond
    // and rendering last pixel
    if ( !( ( !bV1InDiamond &&
              LINEDIR_CMP( iLinePix1 << LINE_FIX, iLineMajor1 ) ||
            ( bV1InDiamond &&
              m_StpCtx.pCtx->pdwRenderState[D3DRS_LASTPIXEL] ) ) ) )
    {
        iLinePix1 -= iLinePixStep;
    }

    // compute extent along major axis
    m_StpCtx.cLinePix =
        bLineMajorNeg ? iLinePix0 - iLinePix1 + 1 : iLinePix1 - iLinePix0 + 1;

    // return if no major extent
    if ( m_StpCtx.cLinePix <= 0 )
    {
        return FALSE;
    }

    FLOAT fSlope;
    FLOAT fMinor0;

    // compute final axis-specific line values
    if ( iAbsXSize >= iAbsYSize )
    {
        m_StpCtx.iX = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iX0 - (m_StpCtx.iX << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX0 - iX1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iX << LINE_FIX) - iX0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX1 - iX0);
        }

        fSlope = m_StpCtx.fOoLen * (iY1 - iY0) * OO_LINE_SNAP;

        fMinor0 = (iY0 + LINE_FIX_NEAR_HALF) * OO_LINE_SNAP +
            m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iY = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iY);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }
    else
    {
        m_StpCtx.iY = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iY0 - (m_StpCtx.iY << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY0 - iY1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iY << LINE_FIX) - iY0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY1 - iY0);
        }

        fSlope = m_StpCtx.fOoLen * (iX1 - iX0) * OO_LINE_SNAP;

        fMinor0 = (iX0 + iXAdjust) * OO_LINE_SNAP + m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iX = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iX);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }

#ifdef LINE_CORRECTION_BIAS
    // A fudge factor of one-half is thrown into the correction
    // to avoid undershoot due to negative corrections.
    // This shifts all the attributes along the line,
    // introducing error, but it's better than clamping
    // them.  This is not done to the coordinates to avoid
    // perturbing them.
    m_StpCtx.fDMajor += g_fHalf;
#else
    // The correction factor is clamped to positive numbers to
    // avoid undershooting with attribute values.  This won't
    // cause overshooting issues because it moves attributes by
    // at most one-half.
    if (FLOAT_LTZ(m_StpCtx.fDMajor))
    {
        m_StpCtx.fDMajor = 0;
    }
#endif

    RSDPFM((RSM_LINES, "Line %.2f,%.2f - %.2f,%.2f\n",
            pV0->dvSX, pV0->dvSY, pV1->dvSX, pV1->dvSY));
    RSDPFM((RSM_LINES, "  %c major, %d,%d, %d pix\n",
            (m_StpCtx.uFlags & LNF_X_MAJOR) ? 'X' : 'Y',
            m_StpCtx.iX, m_StpCtx.iY, m_StpCtx.cLinePix));
    RSDPFM((RSM_LINES, "  slope %f, dmajor %f, minor0 %f\n",
            fSlope, m_StpCtx.fDMajor, fMinor0));
    RSDPFM((RSM_LINES, "  frac %d, dfrac %d\n",
            m_StpCtx.iLineFrac, m_StpCtx.iDLineFrac));

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE2(pV0->dvRHW, pV1->dvRHW))
    {
        NormalizeLineRHW(pV0, pV1);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    LineSetup_Start(&m_StpCtx, pV0, pV1);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\line.cpp ===
//----------------------------------------------------------------------------
//
// line.cpp
//
// Line processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.
//
//----------------------------------------------------------------------------

static inline BOOL LinePatternStateMachine(WORD wRepeatFactor, WORD wLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    if (wRepeatFactor == 0)
    {
        return TRUE;
    }
    WORD wBit = (wLinePattern >> wPatterni) & 1;
    if (++wRepeati >= wRepeatFactor)
    {
        wRepeati = 0;
        wPatterni = (wPatterni+1) & 0xf;
    }
    return (BOOL)wBit;
}

#define CLAMP_COLOR(fVal, uVal) \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \
    else                        \
    {                           \
        if (uVal > 0xffff)      \
        {                       \
            uVal = 0xffff;      \
        }                       \
    }                           \

#define CLAMP_Z(fVal, uVal)     \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \

//----------------------------------------------------------------------------
//
// ClampPixel
//
// Clamp color, specular and z(if any) of a pixel. Right now, it's done for 
// first and last pixel of a line only.
//
//----------------------------------------------------------------------------
inline void
ClampPixel(PATTRSET pAttrs, PD3DI_RASTSPAN pSpan)
{
    CLAMP_COLOR(pAttrs->fB, pSpan->uB);
    CLAMP_COLOR(pAttrs->fG, pSpan->uG);
    CLAMP_COLOR(pAttrs->fR, pSpan->uR);
    CLAMP_COLOR(pAttrs->fA, pSpan->uA);
    CLAMP_COLOR(pAttrs->fBS, pSpan->uBS);
    CLAMP_COLOR(pAttrs->fGS, pSpan->uGS);
    CLAMP_COLOR(pAttrs->fRS, pSpan->uRS);
    CLAMP_Z(pAttrs->fZ, pSpan->uZ);
}

//----------------------------------------------------------------------------
//
// WalkLinePattern
//
// Walks a line and generates the pixels touched according to the pattern.
// If wRepeatFactor >= 1, we are patterning, otherwise, we are not
//
//----------------------------------------------------------------------------

HRESULT
WalkLinePattern(PSETUPCTX pStpCtx, WORD wRepeatFactor, WORD wLinePattern)
{
    HRESULT hr;
    UINT uSpansAvail;
    PD3DI_RASTSPAN pSpan;
    WORD wRepeati = 0;
    WORD wPatterni = 0;
    BOOL bFirst = TRUE;

    RSASSERT(pStpCtx->cLinePix > 0);

    hr = DD_OK;
    uSpansAvail = 0;

    RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);
#ifdef PWL_FOG
    pStpCtx->uPwlFlags = PWL_NO_NEXT_FOG;
#endif

    for (;;)
    {
        if (pStpCtx->iX >= pStpCtx->pCtx->Clip.left &&
            pStpCtx->iX < pStpCtx->pCtx->Clip.right &&
            pStpCtx->iY >= pStpCtx->pCtx->Clip.top &&
            pStpCtx->iY < pStpCtx->pCtx->Clip.bottom)
        {
            if (LinePatternStateMachine(wRepeatFactor, wLinePattern, wRepeati, wPatterni))
            {
                if (uSpansAvail == 0)
                {
                    uSpansAvail = pStpCtx->cLinePix;
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != DD_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                pSpan->uPix = 1;
                pSpan->uX = (UINT16)pStpCtx->iX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
                // Clamp first/last pixel
                if (bFirst || pStpCtx->cLinePix == 1)
                {
                    bFirst = FALSE;
                    ClampPixel(&pStpCtx->Attr, pSpan);
                }
            }
        }

        if (--pStpCtx->cLinePix == 0)
        {
            break;
        }

#ifdef VERBOSE_LINES
        RSDPF(("  %4d,%4d: %10d %11d => ",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac, pStpCtx->iLineFrac + pStpCtx->iDLineFrac));
#endif

        pStpCtx->iLineFrac += pStpCtx->iDLineFrac;
        if (pStpCtx->iLineFrac < 0)
        {
            pStpCtx->iLineFrac &= 0x7fffffff;

            pStpCtx->iX += pStpCtx->iDXCY;
            pStpCtx->iY += pStpCtx->iDYCY;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrCY.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrCY.ipZ;
        }
        else
        {
            pStpCtx->iX += pStpCtx->iDXNC;
            pStpCtx->iY += pStpCtx->iDYNC;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrNC.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrNC.ipZ;
        }

#ifdef VERBOSE_LINES
        RSDPFM((DBG_MASK_FORCE | DBG_MASK_NO_PREFIX, "%4d,%4d: %10d\n",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac));
#endif

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDMajor, pStpCtx);
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Line
//
// Provides a line for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Line(LPD3DTLVERTEX pV0,
                    LPD3DTLVERTEX pV1,
                    LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = DD_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != DD_OK)
    {
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != DD_OK)
    {
        return hr;
    }
#endif

    // Clear per-line flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | LNF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_LINES, "Line\n"));
    RSDPFM((RSM_LINES, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_LINES, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    if (LineSetup(pV0, pV1))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // Line walking only generates single-pixel spans so
        // the prim deltas are unused.  Therefore, line spans
        // are simply added to whatever primitive happens to
        // be sitting in the buffer.

        hr = AppendPrim();
        if (hr != DD_OK)
        {
            return hr;
        }

        union
        {
            D3DLINEPATTERN LPat;
            DWORD dwLPat;
        } LinePat;
        LinePat.dwLPat = m_StpCtx.pCtx->pdwRenderState[D3DRS_LINEPATTERN];
        hr = WalkLinePattern(&m_StpCtx, LinePat.LPat.wRepeatFactor, LinePat.LPat.wLinePattern);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\point.cpp ===
//----------------------------------------------------------------------------
//
// point.cpp
//
// Point processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

void
PrimProcessor::FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan)
{
    FLOAT fZ;
    FLOAT fZScale;

    pSpan->uPix = 1;
    pSpan->uX = (UINT16)m_StpCtx.iX;
    pSpan->uY = (UINT16)m_StpCtx.iY;

    pSpan->pSurface = m_StpCtx.pCtx->pSurfaceBits +
        m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
        m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;

    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        pSpan->pZ = m_StpCtx.pCtx->pZBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iZStride;

        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        // fZ may be used later so set if from the vertex Z.
        fZ = pV0->dvSZ;
        pSpan->uZ = FTOI(fZ * fZScale);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
        FLOAT fUoW, fVoW;

        // Mipmapping doesn't have any meaning.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_LOD_USED) == 0);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pV0->dvRHW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = g_fOne / pV0->dvRHW;
            }

            pSpan->iW = FTOI(fW * W_SCALE);

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pSpan->iOoW = FTOI(pV0->dvRHW * OOW_SCALE);
        }
        else
        {
            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;
        }

        pSpan->iLOD = 0;
        pSpan->iDLOD = 0;

        pSpan->UVoW[0].iUoW = FTOI(fUoW * TEX_SCALE);
        pSpan->UVoW[0].iVoW = FTOI(fVoW * TEX_SCALE);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)m_StpCtx.pCtx->cActTex; i++)
        {
            if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU *
                         pV0->dvRHW * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV *
                         pV0->dvRHW * TEX_SCALE);
            }
            else
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV * TEX_SCALE);
            }
        }
    }

    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uG = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uR = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uA = (UINT)RGBA_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = (INT32)CI_MASKALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_FIXED_SHIFT;
        pSpan->iIdxA = (INT32)CI_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uGS = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uRS = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure that fZ has been set.
            RSASSERT(m_StpCtx.uFlags & PRIMSF_Z_USED);

            pSpan->uFog = (UINT16)ComputeTableFog(m_StpCtx.pCtx->pdwRenderState, fZ);
        }
        else
        {
            pSpan->uFog = (UINT16)(
                FTOI((FLOAT)RGBA_GETALPHA(pV0->dcSpecular) *
                     FOG_255_SCALE));
        }
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE1(fV0) \
    (ASUINT32(fV0) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizePointRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function clamps
// the RHW to the proper range.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizePointRHW(LPD3DTLVERTEX pV0)
{
    // Save original value.
    m_dvV0RHW = pV0->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW))
    {
        RSDPF(("Point RHW out of range %f,%f",
               pV0->dvRHW));
    }
#endif

    if (pV0->dvRHW < NORMALIZED_RHW_MIN)
    {
        pV0->dvRHW = NORMALIZED_RHW_MIN;
    }
    else if (pV0->dvRHW > NORMALIZED_RHW_MAX)
    {
        pV0->dvRHW = NORMALIZED_RHW_MAX;
    }
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Point
//
// Provides a point for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Point(LPD3DTLVERTEX pV0,
                     LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = DD_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != DD_OK)
    {
        return hr;
    }
#endif

    // Clear per-point flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | PTF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X",
            m_uPpFlags, m_StpCtx.uFlags));

    // Round coordinates to integer.
    m_StpCtx.iX = IFLOORF(pV0->dvSX + g_fHalf);
    m_StpCtx.iY = IFLOORF(pV0->dvSY + g_fHalf);

    RSDPFM((RSM_POINTS, "Point\n"));
    RSDPFM((RSM_POINTS, "    V0 (%f,%f,%f) (%d,%d)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ,
            m_StpCtx.iX, m_StpCtx.iY));

    // Clip test.
    if (m_StpCtx.iX < m_StpCtx.pCtx->Clip.left ||
        m_StpCtx.iX >= m_StpCtx.pCtx->Clip.right ||
        m_StpCtx.iY < m_StpCtx.pCtx->Clip.top ||
        m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom)
    {
        return DD_OK;
    }

    //
    // Fill out a one-pixel span for the point.
    // Since the prim deltas are irrelevant for the span,
    // the span is appended to whatever primitive happens
    // to be available in the buffer.
    //

    PD3DI_RASTSPAN pSpan;
    UINT cSpans = 1;

    hr = AppendPrim();
    if (hr != DD_OK)
    {
        return hr;
    }

    hr = AllocSpans(&cSpans, &pSpan);
    if (hr != DD_OK)
    {
        return hr;
    }

    m_StpCtx.pPrim->uSpans++;

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE1(pV0->dvRHW))
    {
        NormalizePointRHW(pV0);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    // Remember flat color controlling vertex for setup, if flat shaded.
    if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
    {
        m_StpCtx.pFlatVtx = pFlatVtx;
    }
    else
    {
        m_StpCtx.pFlatVtx = pV0;
    }


    FillPointSpan(pV0, pSpan);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
    }

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\primproc.cpp ===
//----------------------------------------------------------------------------
//
// primproc.cpp
//
// Miscellaneous PrimProcessor methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// PrimProcessor::BeginPrimSet
//
// Marks the start of a set of primitives that have the same vertex type.
// Computes attributes used from the current state and the vertex type.
//
//----------------------------------------------------------------------------

void
PrimProcessor::BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                            RAST_VERTEX_TYPE VertType)
{
    // If state hasn't changed and the primitive and vertex types match the
    // ones we're already set up for there's no work to do.
    if ((m_uPpFlags & PPF_STATE_CHANGED) == 0 &&
        VertType == m_VertType &&
        PrimType == m_PrimType)
    {
        return;
    }

    m_StpCtx.uFlags &= ~PRIMSF_ALL;

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRS_ZWRITEENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRS_STENCILENABLE])
    {
        m_StpCtx.uFlags |= PRIMSF_Z_USED;
    }

    /*if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Index is unused during copy mode texturing.
        if (m_StpCtx.pCtx->pdwRenderState
            [D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_COPY ||
            m_StpCtx.pCtx->cActTex == 0)
        {
            m_StpCtx.uFlags |= PRIMSF_DIDX_USED;
        }
    }
    else */
    {
        // ATTENTION - Don't set these for copy mode texture?  Is
        // copy mode texture meaningful in RGB?
        m_StpCtx.uFlags |= PRIMSF_DIFF_USED;
        if (m_StpCtx.pCtx->pdwRenderState[D3DRS_SPECULARENABLE])
        {
            m_StpCtx.uFlags |= PRIMSF_SPEC_USED;
        }
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_SHADEMODE] ==
        D3DSHADE_FLAT)
    {
        m_StpCtx.uFlags |= PRIMSF_FLAT_SHADED;
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        m_StpCtx.uFlags |= PRIMSF_TEX1_USED;

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            m_StpCtx.uFlags |= PRIMSF_TEX2_USED;
        }
    }

    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (true || m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]))
    {
        m_StpCtx.uFlags |= PRIMSF_PERSP_USED;
    }

    // Currently only tex1 can be mipmapped.
    if (((m_StpCtx.uFlags & PRIMSF_TEX1_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRS_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[0]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[0]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[0]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[0]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    // select between min and mag filters for TEX2
    if (((m_StpCtx.uFlags & PRIMSF_TEX2_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRS_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[1]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[1]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[1]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[1]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_FOGENABLE])
    {
        // Note, if PWL_FOG is ever brought back to life, enabling
        // PRIMSF_GLOBAL_FOG_USED with no Z buffer will not trivially work
        // if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            switch (m_StpCtx.pCtx->pdwRenderState[D3DRS_FOGTABLEMODE])
            {
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                m_StpCtx.uFlags |= PRIMSF_GLOBAL_FOG_USED;
#ifndef PWL_FOG
                // The span routines don't support table fog directly.
                // Instead table fog is computed per vertex and used to
                // set up local fog.
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
#endif
                break;
            default:
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
                break;
            }
        }
    }

    PFN_ADDATTRS *ppfnAddAttrsTable;
    PFN_ADDSCALEDATTRS *ppfnAddScaledAttrsTable;
    PFN_FILLSPANATTRS *ppfnFillSpanAttrsTable;

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Ramp does not support multitexture.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_TEX2_USED) == 0);

        RSASSERT((PRIMSF_TEX1_USED | PRIMSF_DIDX_USED) == 0x14);

        // Derive a function table index from bits 2 and 4 of usage
        // information.
        // An alternative method would be to use bits 0-4 and have the
        // ramp information in the top 16 entries, but splitting the
        // ramp and RGB tables is cleaner and decouples the table sizes.
        // Decoupling is useful since the ramp possibilities are much
        // more limited so its table can be smaller.

        m_iAttrFnIdx =
            ((m_StpCtx.uFlags & PRIMSF_TEX1_USED) >> 2) |
            ((m_StpCtx.uFlags & PRIMSF_DIDX_USED) >> 3);

        ppfnAddAttrsTable = g_pfnRampAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnRampAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnRampFillSpanFloatAttrsTable;
    }
    else
    {
        RSASSERT((PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED |
                  PRIMSF_TEX2_USED) == 0xf);

        // Derive a function table index from the lower four bits of
        // usage information.  The lower bits are deliberately chosen
        // to represent the more performance-sensitive cases while
        // the upper bits generally represent cases handled by generic
        // code.
        //
        // Even restricted to only four bits the index contains unimportant
        // and unreachable cases, such as specular without diffuse or
        // tex2 without tex1.  Tables indexed must account for this.

        m_iAttrFnIdx = m_StpCtx.uFlags & (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED |
                                          PRIMSF_TEX1_USED | PRIMSF_TEX2_USED);

        ppfnAddAttrsTable = g_pfnAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnFillSpanFloatAttrsTable;
    }

    //
    // These functions only depend on the index and so can be set here.
    // Other functions depend on per-triangle information and are set
    // later.
    //

    if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
    {
        // If any slow attrs are on or Z is off use the general functions.
        m_StpCtx.pfnAddScaledAttrs = AddScaledFloatAttrs_Any_Either;
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
        m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
#endif
    }
    else
    {
        m_StpCtx.pfnAddScaledAttrs =
            ppfnAddScaledAttrsTable[m_iAttrFnIdx];
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = ppfnAddAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs = ppfnFillSpanAttrsTable[m_iAttrFnIdx];
#endif
    }

    // Attribute beads can be set here.
    PFN_SETUPTRIATTR *ppfnSlot;

    ppfnSlot = &m_StpCtx.pfnTriSetupFirstAttr;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            *ppfnSlot = TriSetup_Z16;
        }
        else
        {
            *ppfnSlot = TriSetup_Z32;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupZEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX1_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTexEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DiffFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Diff;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DIdxFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_DIdx;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_SpecFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Spec;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupSpecEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        *ppfnSlot = TriSetup_Fog;
        ppfnSlot = &m_StpCtx.pfnTriSetupFogEnd;
    }
    *ppfnSlot = TriSetup_End;

    // Remember the primitive and vertex type and clear the state change bit.
    m_PrimType = PrimType;
    m_VertType = VertType;
    m_uPpFlags &= ~PPF_STATE_CHANGED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\rsdbg.hpp ===
//----------------------------------------------------------------------------
//
// rsdbg.hpp
//
// Setup debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RSDBG_HPP_
#define _RSDBG_HPP_

// #include <cppdbg.hpp>

// DBG_DECLARE_HEADER(RS);

#if 0
#define RSDPF(Args)             DBG_DECLARE_DPF(RS, Args)
#define RSDPFM(Args)            DBG_DECLARE_DPFM(RS, Args)
#define RSASSERT(Exp)           DBG_DECLARE_ASSERT(RS, Exp)
#define RSASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(RS, Exp, Args)
#define RSVERIFY(Exp)           DBG_DECLARE_VERIFY(RS, Exp)
#define RSVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(RS, Exp, Args)
#define RSPROMPT(Args)          DBG_DECLARE_PROMPT(RS, Args)
#define RSGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(RS, Idx)
#define RSSETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(RS, Idx, Value)
#define RSHRCHK(Exp)            DBG_DECLARE_HRCHK(RS, Exp)
#define RSHRGO(Exp, Label)      DBG_DECLARE_HRGO(RS, Exp, Label)
#define RSHRERR(Exp)            DBG_DECLARE_HRERR(RS, Exp)
#define RSHRRET(Exp)            DBG_DECLARE_HRRET(RS, Exp)
#else
#define RSDPF(Args)
#define RSDPFM(Args)
#define RSASSERT(Exp)
#define RSASSERTMSG(Exp, Args)
#define RSVERIFY(Exp)           (Exp)
#define RSVERIFYMSG(Exp)        (Exp)
#define RSPROMPT(Args)
#define RSGETFLAGS(Idx)         (0)
#define RSSETFLAGS(Idx, Value)
#define RSHRCHK(Exp)            (hr= (Exp))
#define RSHRGO(Exp, Label)      if(RSHRCHK(Exp)!= S_OK) { goto Label; } else hr
#define RSHRERR(Exp)            RSHGO(Exp, HR_Err)
#define RSHRRET(Exp)            if(RSHRCHK(Exp)!= S_OK) { return hr; } else hr
#endif

#define RSM_TRIS                0x00000001
#define RSM_LINES               0x00000002
#define RSM_POINTS              0x00000004
#define RSM_Z                   0x00000008
#define RSM_DIFF                0x00000010
#define RSM_SPEC                0x00000020
#define RSM_OOW                 0x00000040
#define RSM_LOD                 0x00000080
#define RSM_TEX1                0x00000100
#define RSM_TEX2                0x00000200
#define RSM_FOG                 0x00000400
#define RSM_XCLIP               0x00000800
#define RSM_YCLIP               0x00001000
#define RSM_BUFFER              0x00002000
#define RSM_BUFPRIM             0x00004000
#define RSM_BUFSPAN             0x00008000
#define RSM_FLAGS               0x00010000
#define RSM_WALK                0x00020000
#define RSM_DIDX                0x00040000

#define RSU_BREAK_ON_RENDER_SPANS       0x00000001
#define RSU_MARK_SPAN_EDGES             0x00000002
#define RSU_CHECK_SPAN_EDGES            0x00000004
#define RSU_NO_RENDER_SPANS             0x00000008
#define RSU_FORCE_GENERAL_WALK          0x00000010
#define RSU_FORCE_PIXEL_SPANS           0x00000020
#define RSU_FLUSH_AFTER_PRIM            0x00000040

#endif // #ifndef _RSDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\tstp.cpp ===
//----------------------------------------------------------------------------
//
// setup.cpp
//
// PrimProcessor setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// MINMAX3
//
// Computes the min and max of three integer values.
//
//----------------------------------------------------------------------------

#define MINMAX3(iV0, iV1, iV2, iMin, iMax)                                    \
    if ((iV0) <= (iV1))                                                       \
    {                                                                         \
        if ((iV1) <= (iV2))                                                   \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else if ((iV0) <= (iV2))                                              \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMin) = (iV2);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
    }                                                                         \
    else if ((iV1) <= (iV2))                                                  \
    {                                                                         \
        (iMin) = (iV1);                                                       \
        if ((iV0) <= (iV2))                                                   \
        {                                                                     \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMax) = (iV0);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        (iMin) = (iV2);                                                       \
        (iMax) = (iV0);                                                       \
    }

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
//
// ATTENTION Just wipe this out for now.  Need a test for W too close to
// zero to avoid numerical problems.
//#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
//    ((ASUINT32(fV0) | ASUINT32(fV1) | ASUINT32(fV2)) > INT32_FLOAT_ONE)

#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
    (1)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeTriRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                               LPD3DTLVERTEX pV2)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;
    m_dvV2RHW = pV2->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || 
        FLOAT_LTZ(pV1->dvRHW) || 
        FLOAT_LTZ(pV2->dvRHW))
    {
        RSDPF(("Triangle RHW out of range %f,%f,%f\n",
               pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        if (pV1->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV1->dvRHW;
        }
        else
        {
            fMax = pV1->dvRHW;
        }
    }
    else if (pV1->dvRHW < pV2->dvRHW)
    {
        if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else
        {
            fMax = pV0->dvRHW;
        }
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale;

    fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
    pV2->dvRHW = pV2->dvRHW * fRHWScale;

#ifdef DBG_RHW_NORM
    RSDPF(("%f,%f,%f - %f,%f,%f\n",
           m_dvV0RHW, m_dvV1RHW, m_dvV2RHW,
           pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::TriSetup
//
// Takes three vertices and does triangle setup, filling in both a
// primitive structure for the triangle and a span structure for the first
// span.  All internal intermediates and DY values are computed.
//
// Uses the current D3DI_RASTPRIM and D3DI_RASTSPAN so these pointers must
// be valid before calling this routine.
//
// Returns whether the triangle was kept or not.  Culled triangles return
// FALSE.
//
//----------------------------------------------------------------------------

BOOL
PrimProcessor::TriSetup(LPD3DTLVERTEX pV0,
                        LPD3DTLVERTEX pV1,
                        LPD3DTLVERTEX pV2)
{
    // Preserve original first vertex for flat shading reference.
    m_StpCtx.pFlatVtx = pV0;

    //
    // Sort vertices in Y.
    // This can cause ordering changes from the original vertex set
    // so track reversals.
    //
    // Determinant computation and culling could be done before this.
    // Doing so causes headaches with computing deltas up front, though,
    // because the edges may change during sorting.
    //

    LPD3DTLVERTEX pVTmp;
    UINT uReversed;

    uReversed = 0;
    if (pV0->dvSY <= pV1->dvSY)
    {
        if (pV1->dvSY <= pV2->dvSY)
        {
            // Sorted.
        }
        else if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 0 2 1.
            pVTmp = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 2 0 1.
            pVTmp = pV0;
            pV0 = pV2;
            pV2 = pV1;
            pV1 = pVTmp;
        }
    }
    else if (pV1->dvSY < pV2->dvSY)
    {
        if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 1 0 2.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 1 2 0.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
        }
    }
    else
    {
        // Sorted order is 2 1 0.
        pVTmp = pV0;
        pV0 = pV2;
        pV2 = pVTmp;
        uReversed = 1;
    }

    FLOAT fX0 = pV0->dvSX;
    FLOAT fX1 = pV1->dvSX;
    FLOAT fX2 = pV2->dvSX;
    FLOAT fY0 = pV0->dvSY;
    FLOAT fY1 = pV1->dvSY;
    FLOAT fY2 = pV2->dvSY;

    //
    // Compute x,y deltas.
    //
    m_StpCtx.fDX10 = fX1 - fX0;
    m_StpCtx.fDX20 = fX2 - fX0;
    m_StpCtx.fDY10 = fY1 - fY0;
    m_StpCtx.fDY20 = fY2 - fY0;

    //
    // Compute determinant and do culling.
    //
    FLOAT fDet;

    fDet = m_StpCtx.fDX20 * m_StpCtx.fDY10 - m_StpCtx.fDX10 * m_StpCtx.fDY20;
    if (FLOAT_EQZ(fDet))
    {
        // No area, so bail out
        return FALSE;
    }

    // Get sign of determinant.
    UINT uDetCcw = FLOAT_GTZ(fDet) ? 1 : 0;

    // If culling is off the cull sign to check against is set to a
    // value that can't be matched so this single check is sufficient
    // for all three culling cases.
    //
    // Fold in sign reversal here rather than in uDetCcw because
    // we need the true sign later to determine whether the long edge is
    // to the left or the right.
    if ((uDetCcw ^ uReversed) == m_StpCtx.pCtx->uCullFaceSign)
    {
        return FALSE;
    }

    // Snap bounding vertex Y's to pixel centers and check for trivial reject.

    m_StpCtx.iY = ICEILF(fY0);
    m_iY2 = ICEILF(fY2);

    if (m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom ||
        m_iY2 <= m_StpCtx.pCtx->Clip.top)
    {
        return FALSE;
    }

    INT iX0 = ICEILF(fX0);
    INT iX1 = ICEILF(fX1);
    INT iX2 = ICEILF(fX2);

    // Start 2 - 0 edge DXDY divide so that it's overlapped with the
    // integer processing done during X clip checking.  The assumption
    // is that it's nearly zero cost when overlapped so it's worth
    // it to start it even when the clip check rejects the triangle.
    FLOAT fDX20, fDY20, fDXDY20;

    // Need to use stack variables so the assembly can understand the
    // address.
    fDX20 = m_StpCtx.fDX20;
    fDY20 = m_StpCtx.fDY20;
    FLD_BEGIN_DIVIDE(fDX20, fDY20, fDXDY20);

    // Computing the X triangle bounds involves quite a few operations,
    // but it allows for both trivial rejection and trivial acceptance.
    // Given that guard band clipping can lead to a lot of trivial rejections
    // and that there will usually be a lot of trivial acceptance cases,
    // the work is worth it.

    INT iMinX, iMaxX;
    BOOL bXAccept;

    MINMAX3(iX0, iX1, iX2, iMinX, iMaxX);

    m_iXWidth = iMaxX - iMinX;

    // Use X bounds for trivial reject and accept.
    if (iMinX >= m_StpCtx.pCtx->Clip.right ||
        iMaxX <= m_StpCtx.pCtx->Clip.left ||
        m_iXWidth <= 0)
    {
        bXAccept = FALSE;
    }
    else
    {
        if (iMinX >= m_StpCtx.pCtx->Clip.left &&
            iMaxX <= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.uFlags |= PRIMF_TRIVIAL_ACCEPT_X;
        }
        else
        {
            RSDPFM((RSM_XCLIP, "XClip bounds %5d - %5d, %5d\n",
                    iMinX, iMaxX, m_iXWidth));
        }

        bXAccept = TRUE;
    }

    // Complete divide.
    FSTP_END_DIVIDE(fDXDY20);

    if (!bXAccept)
    {
        return FALSE;
    }

    // Clamp triangle Y's to clip rect.

    m_iY1 = ICEILF(fY1);

    if (m_StpCtx.iY < m_StpCtx.pCtx->Clip.top)
    {
        RSDPFM((RSM_YCLIP, "YClip iY %d to %d\n",
                m_StpCtx.iY, m_StpCtx.pCtx->Clip.top));

        m_StpCtx.iY = m_StpCtx.pCtx->Clip.top;

        if (m_iY1 < m_StpCtx.pCtx->Clip.top)
        {
            RSDPFM((RSM_YCLIP, "YClip iY1 %d to %d\n",
                    m_iY1, m_StpCtx.pCtx->Clip.top));

            m_iY1 = m_StpCtx.pCtx->Clip.top;
        }
    }

    if (m_iY1 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY1 %d, iY2 %d to %d\n",
                m_iY1, m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY1 = m_StpCtx.pCtx->Clip.bottom;
        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }
    else if (m_iY2 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY2 %d to %d\n",
                m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }

    // Compute Y subpixel correction.  This will include any Y
    // offset due to clamping.
    m_StpCtx.fDY = m_StpCtx.iY - fY0;

    // Compute trapzeoid heights.  These will be restricted to
    // lie in the clip rect.

    RSASSERT(m_iY1 >= m_StpCtx.iY && m_iY2 >= m_iY1);

    m_uHeight10 = m_iY1 - m_StpCtx.iY;
    m_uHeight21 = m_iY2 - m_iY1;

    m_uHeight20 = m_uHeight10 + m_uHeight21;
    if (m_uHeight20 == 0)
    {
        // Triangle doesn't cover any pixels.
        return FALSE;
    }

    RSDPFM((RSM_TRIS, "Tstp (%.4f,%.4f) (%.4f,%.4f) (%.4f,%.4f)\n",
            fX0, fY0, fX1, fY1, fX2, fY2));
    RSDPFM((RSM_TRIS, "    (%.4f,%.4f : %.4f,%.4f) %d:%d det %.4f\n",
            m_StpCtx.fDX10, m_StpCtx.fDY10,
            m_StpCtx.fDX20, m_StpCtx.fDY20,
            m_uHeight10, m_uHeight21, fDet));
    RSDPFM((RSM_Z, "    Z (%f) (%f) (%f)\n",
        pV0->dvSZ, pV1->dvSZ, pV2->dvSZ));
    RSDPFM((RSM_DIFF, "    diff (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_DIDX, "    didx (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_SPEC, "    spec (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcSpecular & 0xffffff, pV1->dcSpecular & 0xffffff,
            pV2->dcSpecular & 0xffffff));
    RSDPFM((RSM_OOW, "    OoW (%f) (%f) (%f)\n",
            pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    RSDPFM((RSM_TEX1, "    Tex1 (%f,%f) (%f,%f) (%f,%f)\n",
            pV0->dvTU, pV0->dvTV, pV1->dvTU, pV1->dvTV,
            pV2->dvTU, pV2->dvTV));
    RSDPFM((RSM_FOG, "    Fog (0x%02X) (0x%02X) (0x%02X)\n",
            RGBA_GETALPHA(pV0->dcSpecular),
            RGBA_GETALPHA(pV1->dcSpecular),
            RGBA_GETALPHA(pV2->dcSpecular)));

    // Compute dx/dy for edges and initial X's.

    m_StpCtx.fDX = m_StpCtx.fDY * fDXDY20;
    FLOAT fX20 = fX0 + m_StpCtx.fDX;

    ComputeIntCarry(fX20, fDXDY20, &m_StpCtx.X20);
    m_StpCtx.fX20NC = (FLOAT)m_StpCtx.X20.iNC;
    m_StpCtx.fX20CY = (FLOAT)m_StpCtx.X20.iCY;

    RSDPFM((RSM_TRIS, "    edge20  %f dxdy %f\n", fX20, fDXDY20));
    RSDPFM((RSM_TRIS, "            (?.%d d %d nc %d cy %d)\n",
            m_StpCtx.X20.iFrac,
            m_StpCtx.X20.iDFrac, m_StpCtx.X20.iNC, m_StpCtx.X20.iCY));

    if (m_uHeight10 > 0)
    {
        FLOAT fDXDY10;
        FLOAT fX10;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_EQZ(m_StpCtx.fDX10))
        {
            fDXDY10 = g_fZero;
            fX10 = fX0;
        }
        else
#endif
        {
            fDXDY10 = m_StpCtx.fDX10 / m_StpCtx.fDY10;
            fX10 = fX0 + m_StpCtx.fDY * fDXDY10;
        }

        m_StpCtx.X10.iV = ICEILF(fX10);
        ComputeIntCarry(fX10, fDXDY10, &m_StpCtx.X10);

        RSDPFM((RSM_TRIS, "    edge10  %f dxdy %f\n", fX10, fDXDY10));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X10.iV, m_StpCtx.X10.iFrac,
                m_StpCtx.X10.iDFrac, m_StpCtx.X10.iNC, m_StpCtx.X10.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X10, 0, sizeof(m_StpCtx.X10));
    }
#endif

    if (m_uHeight21 > 0)
    {
        FLOAT fDXDY21;
        FLOAT fX21;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_COMPARE(fX1, ==, fX2))
        {
            fDXDY21 = g_fZero;
            fX21 = fX1;
        }
        else
#endif
        {
            fDXDY21 = (fX2 - fX1) / (fY2 - fY1);
            fX21 = fX1 + (m_iY1 - fY1) * fDXDY21;
        }

        m_StpCtx.X21.iV = ICEILF(fX21);
        ComputeIntCarry(fX21, fDXDY21, &m_StpCtx.X21);

        RSDPFM((RSM_TRIS, "    edge21  %f dxdy %f\n", fX21, fDXDY21));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X21.iV, m_StpCtx.X21.iFrac,
                m_StpCtx.X21.iDFrac, m_StpCtx.X21.iNC, m_StpCtx.X21.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X21, 0, sizeof(m_StpCtx.X21));
    }
#endif

    // The edge walker always walks the long edge so it may either
    // be a left or a right edge.  Determine what side the long edge
    // is and perform appropriate snapping and subpixel adjustment
    // computations.
    //
    // The clip-clamped initial X pixel position is also computed and
    // any necessary offset added into the subpixel correction delta.

    if (uDetCcw)
    {
        // Long edge (0-2) is to the right.

        m_StpCtx.uFlags |= TRIF_X_DEC;
        m_StpCtx.pPrim->uFlags = D3DI_RASTPRIM_X_DEC;

        m_StpCtx.X20.iV = ICEILF(fX20) - 1;

        // Other edges are left edges.  Bias them back by one
        // so that the span width computation can do R - L
        // rather than R - L + 1.
        m_StpCtx.X10.iV--;
        m_StpCtx.X21.iV--;

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV >= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.right - 1;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }
    else
    {
        // Long edge (0-2) is to the left.

        m_StpCtx.pPrim->uFlags = 0;

        m_StpCtx.X20.iV = ICEILF(fX20);

        // Other edges are right edges.  The ICEILF snapping done
        // already leaves them off by one so that R - L works.

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV < m_StpCtx.pCtx->Clip.left)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.left;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }

    // Update X subpixel correction.  This delta includes any
    // offseting due to clamping of the initial pixel position.
    m_StpCtx.fDX += m_StpCtx.iX - fX20;

    RSDPFM((RSM_TRIS, "    subp    %f,%f\n", m_StpCtx.fDX, m_StpCtx.fDY));

    // Compute span-to-span steps for buffer pointers.
    m_StpCtx.DAttrNC.ipSurface = m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipZ = m_StpCtx.pCtx->iZStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iZStep;

    // Start one over determinant divide.  Done after the multiplies
    // since integer multiplies require some of the FP unit.

    FLOAT fOoDet;

    FLD_BEGIN_DIVIDE(g_fOne, fDet, fOoDet);

    if (m_StpCtx.X20.iCY > m_StpCtx.X20.iNC)
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface +
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ + m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface -
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ - m_StpCtx.pCtx->iZStep;
    }

    //
    // Compute attribute functions.
    //

    // Set pure X/Y step deltas for surface and Z so that DX, DY, CY and NC all
    // have complete information and can be used interchangeably.
    if (m_StpCtx.uFlags & TRIF_X_DEC)
    {
        m_StpCtx.DAttrDX.ipSurface = -m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = -m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrDX.ipSurface = m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = m_StpCtx.pCtx->iZStep;
    }
    m_StpCtx.DAttrDY.ipSurface = m_StpCtx.pCtx->iSurfaceStride;
    m_StpCtx.DAttrDY.ipZ = m_StpCtx.pCtx->iZStride;

    // Finish overlapped divide.
    FSTP_END_DIVIDE(fOoDet);

    m_StpCtx.fOoDet = fOoDet;

    // The PrimProcessor is created zeroed out so the initial
    // state is FP clean.  Later uses may put FP values in slots but
    // they should still be valid, so the optional computations here
    // should never result in FP garbage.  It should therefore be
    // OK to use any mixture of attribute handlers since there should
    // never be any case where FP garbage will creep in.

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE3(pV0->dvRHW, pV1->dvRHW, pV2->dvRHW))
    {
        NormalizeTriRHW(pV0, pV1, pV2);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    TriSetup_Start(&m_StpCtx, pV0, pV1, pV2);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
        pV2->dvRHW = m_dvV2RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\rsdbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#if 0 && DBG

static DebugModuleFlags g_RastSetupOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(RSM, TRIS),
    DBG_DECLARE_MODFLAG(RSM, LINES),
    DBG_DECLARE_MODFLAG(RSM, POINTS),
    DBG_DECLARE_MODFLAG(RSM, Z),
    DBG_DECLARE_MODFLAG(RSM, DIFF),
    DBG_DECLARE_MODFLAG(RSM, SPEC),
    DBG_DECLARE_MODFLAG(RSM, OOW),
    DBG_DECLARE_MODFLAG(RSM, LOD),
    DBG_DECLARE_MODFLAG(RSM, TEX1),
    DBG_DECLARE_MODFLAG(RSM, TEX2),
    DBG_DECLARE_MODFLAG(RSM, XCLIP),
    DBG_DECLARE_MODFLAG(RSM, YCLIP),
    DBG_DECLARE_MODFLAG(RSM, BUFFER),
    DBG_DECLARE_MODFLAG(RSM, BUFPRIM),
    DBG_DECLARE_MODFLAG(RSM, BUFSPAN),
    DBG_DECLARE_MODFLAG(RSM, FLAGS),
    DBG_DECLARE_MODFLAG(RSM, WALK),
    DBG_DECLARE_MODFLAG(RSM, DIDX),
    0, NULL,
};
static DebugModuleFlags g_RastSetupUserFlags[] =
{
    DBG_DECLARE_MODFLAG(RSU, BREAK_ON_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, MARK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, CHECK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, NO_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, FORCE_GENERAL_WALK),
    DBG_DECLARE_MODFLAG(RSU, FORCE_PIXEL_SPANS),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSetup, RS,
                 g_RastSetupOutputFlags, 0,
                 g_RastSetupUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\tri.cpp ===
//----------------------------------------------------------------------------
//
// tri.cpp
//
// PrimProcessor top-level triangle methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

// Disallow fixed-point edge walkers to be chosen or not.
#if 0
#define DISALLOW_FIXED
#endif

// Maximum length of a PWL span.  Short to make piecewise-linear
// approximation more accurate.
#define MAX_PWL_SPAN_LEN        16
// Maximum normal span length.
#define MAX_SPAN_LEN            256

//----------------------------------------------------------------------------
//
// PrimProcessor::SetTriFunctions
//
// Set up function pointers for triangle processing.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetTriFunctions(void)
{
#if DBG
    if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_PIXEL_SPANS) == 0)
#else
    if ((m_StpCtx.uFlags & TRIF_RASTPRIM_OVERFLOW) == 0)
#endif
    {
        // Valid deltas.  If mipmapping or global fog is on then
        // only allow short subspans so that they can be done
        // reasonably accurately via piecewise linear interpolation.
#ifdef PWL_FOG
        if (m_StpCtx.uFlags & (PRIMSF_LOD_USED | PRIMSF_GLOBAL_FOG_USED))
#else
        if (m_StpCtx.uFlags & PRIMSF_LOD_USED)
#endif
        {
            m_StpCtx.cMaxSpan = MAX_PWL_SPAN_LEN;
        }
        else
        {
            // No mipmapping so we can handle much larger spans.
            // Color values only have 8 bits of fraction so
            // we still need to worry about error accumulation.
            // Cut long spans to cap accumulated error.
            m_StpCtx.cMaxSpan = MAX_SPAN_LEN;
        }
    }
    else
    {
        // Invalid deltas.  There's no way to communicate deltas to
        // the span routines so chop spans into pixels.
        // This case can only occur with very narrow triangles so
        // this isn't as expensive as it might seem at first.
        m_StpCtx.cMaxSpan = 1;
    }

    BOOL bFixed = FALSE;

#ifdef STEP_FIXED
    // No ramp support.
    RSASSERT(m_StpCtx.pCtx->BeadSet != D3DIBS_RAMP);
#endif

    if ((m_StpCtx.uFlags & PRIMF_TRIVIAL_ACCEPT_X) &&
#if DBG
        (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_GENERAL_WALK) == 0 &&
#endif
        m_iXWidth <= m_StpCtx.cMaxSpan)
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general
            // function.
            m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_NoClip;
        }
#if defined(STEP_FIXED) && !defined(DISALLOW_FIXED)
        // Attribute conversion can be a dominant cost for
        // triangles with very few spans, so avoid using fixed point
        // edge walking for them.
        else if ((m_StpCtx.uFlags & PRIMF_FIXED_OVERFLOW) == 0 &&
                 m_uHeight20 > 3)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFixedSpansNoClipTable[m_iAttrFnIdx];
            bFixed = TRUE;
        }
#endif
        else if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnRampWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
        else
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
    }
    else
    {
        // No special cases, just a general function.
        m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_Clip;
    }

#ifdef STEP_FIXED
    if (bFixed)
    {
        RSASSERT((m_StpCtx.uFlags & PRIMSF_SLOW_USED) == PRIMSF_Z_USED);

        m_StpCtx.pfnAddAttrs = g_pfnAddFixedAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs =
            g_pfnFillSpanFixedAttrsTable[m_iAttrFnIdx];

        PFN_FLOATATTRSTOFIXED pfnFloatAttrsToFixed;

        pfnFloatAttrsToFixed = g_pfnFloatAttrsToFixedTable[m_iAttrFnIdx];
        pfnFloatAttrsToFixed(&m_StpCtx.Attr, &m_StpCtx.Attr);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrNC, &m_StpCtx.DAttrNC);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrCY, &m_StpCtx.DAttrCY);
    }
    else
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general functions.
            m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
            m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
        }
        else
        {
            m_StpCtx.pfnAddAttrs = g_pfnAddFloatAttrsTable[m_iAttrFnIdx];
            m_StpCtx.pfnFillSpanAttrs =
                g_pfnFillSpanFloatAttrsTable[m_iAttrFnIdx];
        }
    }

    // Scaled attr functions already set since they only depend on
    // m_iAttrFnIdx.
#else // STEP_FIXED
    // All attr functions already set since they only depend on
    // m_iAttrFnIdx.
#endif // STEP_FIXED
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Tri
//
// Calls triangle setup.  If a triangle is produced by setup
// this routine walks edges, generating spans into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Tri(LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;

    hr = DD_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != DD_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V0\n"));
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != DD_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V1\n"));
        return hr;
    }
    hr = ValidateVertex(pV2);
    if (hr != DD_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V2\n"));
        return hr;
    }
#endif

    // Clear per-triangle flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | TRIF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_TRIS, "Tri\n"));
    RSDPFM((RSM_TRIS, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_TRIS, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));
    RSDPFM((RSM_TRIS, "  V2 (%f,%f,%f)\n",
            pV2->dvSX, pV2->dvSY, pV2->dvSZ));

    GET_PRIM();

    // Set up the triangle and see if anything was produced.
    // Triangles may not be produced due to:
    //   Face culling.
    //   Trivial rejection against the clip rect.
    //   Zero pixel coverage.
    if (TriSetup(pV0, pV1, pV2))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // uSpans and pNext have already been initialized.

        SetTriFunctions();
        COMMIT_PRIM(FALSE);

        if (m_uHeight10 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight10, &m_StpCtx.X10,
                                           &m_StpCtx, m_uHeight21 > 0);
            if (hr != DD_OK)
            {
                return hr;
            }
        }

        if (m_uHeight21 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight21, &m_StpCtx.X21,
                                           &m_StpCtx, FALSE);
            if (hr != DD_OK)
            {
                return hr;
            }
        }

#if DBG
        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FLUSH_AFTER_PRIM)
        {
            Flush();
        }
#endif
    }

    return hr;
}

#if DBG
//----------------------------------------------------------------------------
//
// PrimProcessor::ValidateVertex
//
// Checks the ranges of verifiable contents of vertex, to avoid setting up
// garbage.
//
//----------------------------------------------------------------------------
inline HRESULT PrimProcessor::ValidateVertex(LPD3DTLVERTEX pV)
{
    // from the OptSwExtCaps.dvGuardBand caps.
    if ((pV->sx < -32768.f) || (pV->sx > 32767.f) ||
        (pV->sy < -32768.f) || (pV->sy > 32767.f))
    {
        RSDPF(("ValidateVertex: x,y out of guardband range (%f,%f)\n",pV->sx,pV->sy));
        return DDERR_INVALIDPARAMS;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRS_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRS_ZWRITEENABLE])
    {

        // Allow a little slack for those generating triangles exactly on the
        // depth limit.  Needed for Quake.
        if ((pV->sz < -0.00015f) || (pV->sz > 1.00015f))
        {
            RSDPF(("ValidateVertex: z out of range (%f)\n",pV->sz));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        if (true ||m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
        {
            if (pV->rhw <= 0 )
            {
                RSDPF(("ValidateVertex: rhw out of range (%f)\n",pV->rhw));
                return DDERR_INVALIDPARAMS;
            }
        }

        // from OptSwExtCaps.dwMaxTextureRepeat cap.
        if ((pV->tu > 256.0F) || (pV->tu < -256.0F) ||
            (pV->tv > 256.0F) || (pV->tv < -256.0F))
        {
            RSDPF(("ValidateVertex: tu,tv out of range (%f,%f)\n",pV->tu,pV->tv));
            return DDERR_INVALIDPARAMS;
        }

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            PRAST_GENERIC_VERTEX pGV = (PRAST_GENERIC_VERTEX)pV;
            if ((pGV->texCoord[1].tu > 256.0F) || (pGV->texCoord[1].tu < -256.0F) ||
                (pGV->texCoord[1].tv > 256.0F) || (pGV->texCoord[1].tv < -256.0F))
            {
                RSDPF(("ValidateVertex: texCoord[1].tu,texCoord[1].tv out of range (%f,%f)\n",pGV->texCoord[1].tu,pGV->texCoord[1].tv));
                return DDERR_INVALIDPARAMS;
            }
        }
    }

    return DD_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\walkcpp.cpp ===
//----------------------------------------------------------------------------
//
// walkcpp.cpp
//
// C++ trapezoid edge walking functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#include "walk_mh.h"
#pragma hdrstop

// Currently empty.
//
// Could use m4 to generate specialized versions of everything,
// but the only overhead is two function calls per span.  I don't
// think it's important enough to justify the extra code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\setup\walk.cpp ===
//----------------------------------------------------------------------------
//
// walk.cpp
//
// TriProcessor edge walking methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#include "d3dutil.h"
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_Clip
//
// Walks the given number of spans, using edge 0 - 2 as the attribute
// edge and the given X and DXDY for the other edge.
// Spans are clipped in X against the current clip rect.
//
// The spans can be split into subspans if required.  cPixSplit indicates
// the maximum length span that should be recorded.  Any longer spans will
// be cut into multiple span segments.
//
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_Clip(UINT uSpans, PINTCARRYVAL pXOther,
                             PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    INT cTotalPix;
    INT cPix;
    INT uX, uXO;
    BOOL b20Valid;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = DD_OK;
    uSpansAvail = 0;
    
    for (;;)
    {
        //
        // Clip span and compute length.  No attributes need to be
        // updated here because attributes have already been moved
        // inside the clip boundary.
        //

        uX = pStpCtx->X20.iV;
        uXO = pXOther->iV;
        b20Valid = TRUE;

        RSDPFM((RSM_WALK, "Full span at Y %d, %d - %d\n",
                pStpCtx->iY, uX,
                (pStpCtx->uFlags & TRIF_X_DEC) ? uXO + 1 : uXO - 1));
        
        if (pStpCtx->uFlags & TRIF_X_DEC)
        {
            if (uX >= pStpCtx->pCtx->Clip.right)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.right - 1;
            }
            else if (uX < pStpCtx->pCtx->Clip.left &&
                     pStpCtx->X20.iCY <= 0)
            {
                // Right edge has crossed the left clip boundary
                // travelling left so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }


            // -1 because this edge is displaced by one.
            if (uXO < pStpCtx->pCtx->Clip.left - 1)
            {
                uXO = pStpCtx->pCtx->Clip.left - 1;
            }

            cTotalPix = uX - uXO;
        }
        else
        {
            if (uX < pStpCtx->pCtx->Clip.left)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.left;
            }
            else if (uX >= pStpCtx->pCtx->Clip.right &&
                     pStpCtx->X20.iCY >= 0)
            {
                // Left edge has crossed the right clip boundary
                // travelling right so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }

            if (uXO > pStpCtx->pCtx->Clip.right)
            {
                uXO = pStpCtx->pCtx->Clip.right;
            }

            cTotalPix = uXO - uX;
        }

        if (cTotalPix > 0)
        {
            ATTRSET Attr;
            PATTRSET pAttr;

            // Start without PWL support since the first iteration doesn't
            // have precomputed values.
            pStpCtx->uPwlFlags = 0;
            
            pAttr = &pStpCtx->Attr;
        
            for (;;)
            {
                if (uSpansAvail == 0)
                {
                    // We don't really have a good number to request
                    // since uSpans could result in any number of span
                    // fragments after dicing.  Using uSpans is OK
                    // as long as uSpans is relatively large, but if
                    // uSpans gets small and there's a lot of dicing then
                    // it would result in excessive AllocSpans calls.
                    // Try to avoid this problem by lower-bounding the
                    // request.  Any excess spans will be given back
                    // at the end.
                    uSpansAvail = min< UINT>(8, uSpans);
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != DD_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                // Split up remaining pixels if necessary.
                cPix = min(cTotalPix, pStpCtx->cMaxSpan);

                pSpan->uPix = (UINT16)cPix;
                pSpan->uX = (UINT16)uX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                RSDPFM((RSM_WALK, "  Seg at Y %d, X %d, %c%d pix (%d, %d)\n",
                        pStpCtx->iY, uX,
                        (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                        cPix, cTotalPix, pStpCtx->cMaxSpan));

                pStpCtx->pfnFillSpanAttrs(pAttr, pSpan, pStpCtx, cPix);

                cTotalPix -= cPix;
                if (cTotalPix <= 0)
                {
                    break;
                }

                // There are still pixels left in the span so the loop's
                // going to go around again.  Update all the attribute
                // values by cPix dX steps.
                //
                // We don't want to update the real edge attributes so we
                // need to work with a copy.  We do this lazily to
                // avoid the data movement for the normal case where
                // the span isn't split.
                if (pAttr == &pStpCtx->Attr)
                {
                    Attr = pStpCtx->Attr;
                    pAttr = &Attr;
                }

                if (pStpCtx->uFlags & TRIF_X_DEC)
                {
                    uX -= cPix;
                }
                else
                {
                    uX += cPix;
                }
                pStpCtx->pfnAddScaledAttrs(pAttr, &pStpCtx->DAttrDX,
                                           pStpCtx, cPix);
            }
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        // See if the edge has crossed a clip boundary.
        cPix = 0;
        if (b20Valid)
        {
            // Always take a normal step.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

            // See if the edge crossed out of the clip rect and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV >= pStpCtx->pCtx->Clip.right)
                {
                    cPix = pStpCtx->X20.iV - (pStpCtx->pCtx->Clip.right - 1);
                }
            }
            else
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->pCtx->Clip.left - pStpCtx->X20.iV;
                }
            }
        }
        else
        {
            // Always step in Y.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDY, pStpCtx);

            // See if the edge crossed into validity and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.right - 1)
                {
                    cPix = (pStpCtx->pCtx->Clip.right - 1) - pStpCtx->X20.iV;
                }
            }
            else
            {
                if (pStpCtx->X20.iV > pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->X20.iV - pStpCtx->pCtx->Clip.left;
                }
            }
        }

        if (cPix > 0)
        {
            // The edge made a validity transition.  Either the
            // attributes are sitting back at the edge of validity and
            // need to move forward or they've left the clip rect and
            // need to move back.  Either way, cPix has the
            // number of pixels to move in X.
            
            // No precomputed values.
            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnAddScaledAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDX,
                                       pStpCtx, cPix);
        }

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_NoClip
//
// WalkTrapSpans specialized for the trivial-accept clipping case.
// Span dicing is also unsupported.
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_NoClip(UINT uSpans, PINTCARRYVAL pXOther,
                               PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    PINTCARRYVAL pXLeft, pXRight;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = DD_OK;

    if (pStpCtx->uFlags & TRIF_X_DEC)
    {
        pXLeft = pXOther;
        pXRight = &pStpCtx->X20;
    }
    else
    {
        pXLeft = &pStpCtx->X20;
        pXRight = pXOther;
    }

    uSpansAvail = 0;

    for (;;)
    {
        if (pXRight->iV > pXLeft->iV)
        {
            if (uSpansAvail == 0)
            {
                uSpansAvail = uSpans;
                hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                if (hr != DD_OK)
                {
                    // uSpansAvail is set to zero on failure.
                    goto EH_Exit;
                }
            }
            else
            {
                pSpan++;
            }
            uSpansAvail--;
            pStpCtx->pPrim->uSpans++;

            pSpan->uPix = (UINT16)(pXRight->iV - pXLeft->iV);
            pSpan->uX = (UINT16)pStpCtx->X20.iV;
            pSpan->uY = (UINT16)pStpCtx->iY;

            RSDPFM((RSM_WALK, "Span at Y %d, X %d, %c%d pix\n",
                    pStpCtx->iY, pSpan->uX,
                    (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                    pSpan->uPix));

            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//
// Tables of edge walkers.
// Indexing is with the low four TRISF_*_USED bits.
//

#if !defined(_X86_) || defined(X86_CPP_WALKTRAPSPANS)
#define WalkTrapFloatSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#endif

// Trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFloatSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFloatSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFloatSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFixedSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFixedSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFixedSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Ramp mode trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -I -1 */
    WalkTrapFloatSpans_Z_Tex_NoClip,                   /* 1: -I +1 */
    WalkTrapFloatSpans_Z_DIdx_NoClip,                   /* 2: +I -1 */
    WalkTrapFloatSpans_Z_DIdx_Tex_NoClip,              /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\spaninit\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\bdstr_mh.h: bdstr_mh.mh $(RAST_STD_M4)

$(GENTGT)\beadstr.cpp: beadstr.mcp bdstr_mh.mh $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)

$(GENTGT)\spaninit.cpp: spaninit.mcp bdstr_mh.mh $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\spaninit\rastcoll.h ===
// RastColl.h - declaration of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCOLL_H_
#define _RASTCOLL_H_

typedef struct _RASTFNREC {
    DWORD           rgdwRastCap[RASTCAPRECORD_SIZE];
    PFNRENDERSPANS  pfnRastFunc;
    int             iIndex;             // index for disable mask
    char            pszRastDesc[128];   // brief human description of monolith
} RASTFNREC;

class CRastCollection {

private:

    RASTFNREC* RastFnLookup(CRastCapRecord*,RASTFNREC*,int);

public:

    RASTFNREC*  Search(PD3DI_RASTCTX,CRastCapRecord*);

};

#endif  // _RASTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\spaninit\rastcoll.cpp ===
// rastcoll.cpp - implementation of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#include "rgb_pch.h"
#pragma hdrstop

#include "RastCap.h"
#include "rastcoll.h"
#include "mlrfns.h"

// MMX monolithic rasterizers are for X86 only
#ifdef _X86_
// table containing rasterzer capability bit vectors and
// pointers to functions implementing MMX monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//

static RASTFNREC s_RastListMMX[] = {
    {{ 0x00000000, 0x00000000, 0x00000100 }, MMXMLRast_22, 21, "MMX ml22" },
    {{ 0x00000000, 0x00000000, 0x00000102 }, MMXMLRast_8,   7, "MMX ml8 " },
    {{ 0x00000000, 0x00001100, 0x00000100 }, MMXMLRast_23, 22, "MMX ml23" },
    {{ 0x00000000, 0x00001102, 0x00000102 }, MMXMLRast_9,   8, "MMX ml9 " },
    {{ 0x00000000, 0x00003100, 0x00000100 }, MMXMLRast_26, 25, "MMX ml26" },
    {{ 0x00000000, 0x00003102, 0x00000102 }, MMXMLRast_12, 11, "MMX ml12" },
    {{ 0x00000000, 0x00101200, 0x00000100 }, MMXMLRast_24, 23, "MMX ml24" },
    {{ 0x00000000, 0x00101202, 0x00000102 }, MMXMLRast_10,  9, "MMX ml10" },
    {{ 0x00000000, 0x00103200, 0x00000100 }, MMXMLRast_27, 26, "MMX ml27" },
    {{ 0x00000000, 0x00103202, 0x00000102 }, MMXMLRast_13, 12, "MMX ml13" },
    {{ 0x00000000, 0x00111200, 0x00000100 }, MMXMLRast_25, 24, "MMX ml25" },
    {{ 0x00000000, 0x00111202, 0x00000102 }, MMXMLRast_11, 10, "MMX ml11" },
    {{ 0x00000000, 0x00113200, 0x00000100 }, MMXMLRast_28, 27, "MMX ml28" },
    {{ 0x00000000, 0x00113202, 0x00000102 }, MMXMLRast_14, 13, "MMX ml14" },
    {{ 0x00003003, 0x00000000, 0x00000100 }, MMXMLRast_15, 14, "MMX ml15" },
    {{ 0x00003003, 0x00000000, 0x00000102 }, MMXMLRast_1,   0, "MMX ml1 " },
    {{ 0x00003003, 0x00001100, 0x00000100 }, MMXMLRast_16, 15, "MMX ml16" },
    {{ 0x00003003, 0x00001102, 0x00000102 }, MMXMLRast_2,   1, "MMX ml2 " },
    {{ 0x00003003, 0x00003100, 0x00000100 }, MMXMLRast_19, 18, "MMX ml19" },
    {{ 0x00003003, 0x00003102, 0x00000102 }, MMXMLRast_5,   4, "MMX ml5 " },
    {{ 0x00003003, 0x00101200, 0x00000100 }, MMXMLRast_17, 16, "MMX ml17" },
    {{ 0x00003003, 0x00101202, 0x00000102 }, MMXMLRast_3,   2, "MMX ml3 " },
    {{ 0x00003003, 0x00103200, 0x00000100 }, MMXMLRast_20, 19, "MMX ml20" },
    {{ 0x00003003, 0x00103202, 0x00000102 }, MMXMLRast_6,   5, "MMX ml6 " },
    {{ 0x00003003, 0x00111200, 0x00000100 }, MMXMLRast_18, 17, "MMX ml18" },
    {{ 0x00003003, 0x00111202, 0x00000102 }, MMXMLRast_4,   3, "MMX ml4 " },
    {{ 0x00003003, 0x00113200, 0x00000100 }, MMXMLRast_21, 20, "MMX ml21" },
    {{ 0x00003003, 0x00113202, 0x00000102 }, MMXMLRast_7,   6, "MMX ml7 " },


};
#endif // _X86_

// table containing rasterizer capability bit vectors and
// pointers to functions implementing monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//
static RASTFNREC s_RastListNormal[] = {
    // Don't select these until we are sure they work
//    {{ 0x00113003, 0x00000000, 0x00000100 }, CMLRast_1, 0, "CML 1" },
//    {{ 0x00113003, 0x00000000, 0x00000103 }, CMLRast_2, 1, "CML 2" }
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_1, 0, "CML 1" },
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_2, 1, "CML 2" }
};


int RastCapCompare(DWORD* pdwCap1, DWORD* pdwCap2)
{
    for (int i = 0; i < RASTCAPRECORD_SIZE; i++) {
        if (pdwCap1[i] < pdwCap2[i]) {
            return -1;
        } else if (pdwCap1[i] > pdwCap2[i]) {
            return 1;
        }
    }

    return 0;
}


RASTFNREC*
CRastCollection::RastFnLookup(
    CRastCapRecord* pRastCapRec,
    RASTFNREC* pRastFnTbl,
    int iSize)
{
    int iLow = 0,
        iHigh = iSize - 1,
    iMid;
    RASTFNREC* pfnRastFnRec = NULL;

    // all MMX monolithics can handle either shade mode
    pRastCapRec->m_rgdwData[SHADEMODE_POS/32] &= ~(((1<<SHADEMODE_LEN)-1)<<SHADEMODE_POS);

    do
    {
        iMid = (iLow + iHigh) / 2;
        switch (RastCapCompare(pRastCapRec->
                m_rgdwData,pRastFnTbl[iMid].rgdwRastCap))
        {
        case -1 :
            iHigh = iMid - 1;
            break;
        case 0 :
            // found match
            pfnRastFnRec = &pRastFnTbl[iMid];
            iLow = iHigh + 1;       // exits while loop
            break;
        case 1 :
            iLow = iMid + 1;
            break;
        }
    } while (iLow <= iHigh);

    return pfnRastFnRec;
}


RASTFNREC*
CRastCollection::Search(PD3DI_RASTCTX pCtx,
    CRastCapRecord* pRastCapRec)
{
    RASTFNREC* pfnRastFnRec = NULL;

#ifdef _X86_
    // if we're on an MMX machine, is there an MMX rasterizer to use?
    if ((pCtx->BeadSet == D3DIBS_MMX)||(pCtx->BeadSet == D3DIBS_MMXASRGB)) {
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListMMX,
                             sizeof(s_RastListMMX) /
                             sizeof(s_RastListMMX[0]));
        if (pfnRastFnRec)
        {
            // only code up looking at one mask, for now
            // DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);
            int iIndex = pfnRastFnRec->iIndex;
            // DDASSERT((iIndex < 32) && (iIndex >= 0));
            if ((pCtx->dwMMXFPDisableMask[0]>>iIndex) & 1)
            {
                // oops, don't choose this one, it is on the disable list
                pfnRastFnRec = NULL;
            }
        }
    } else {
#endif //_X86_
        // no MMX or on ALPHA, so look in the normal list
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListNormal,
                                 sizeof(s_RastListNormal) /
                                 sizeof(s_RastListNormal[0]));
#ifdef _X86_
    }
#endif //_X86_

    return pfnRastFnRec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\spaninit\spindbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

#if 0 && DBG

static DebugModuleFlags g_RastSpanInitOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIM, INVALID),
    DBG_DECLARE_MODFLAG(SPIM, REPORT),
    0, NULL,
};
static DebugModuleFlags g_RastSpanInitUserFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIU, BREAK_ON_SPANINIT),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSpanInit, SPI,
                 g_RastSpanInitOutputFlags, 0,
                 g_RastSpanInitUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\sample\pch.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Windows
#include <windows.h>

#undef min
#undef max

// STL & standard headers.
#include <functional>
#include <algorithm>
#include <iterator>
#include <assert.h>
#include <memory>
#include <vector>
#include <limits>
#include <map>
#include <set>
#include <new.h>

using namespace std;

// DX (as should be included if on Win9x)
// Instead of these 4, just <ddrawpr.h> before <windows.h> could be used,
// as it includes D3DERRs. But, this is even more internal (depends on more).
#include <ddraw.h>
#include <ddrawi.h>
#include <d3dhal.h>
#include <d3d8.h>

// Including d3d8ddi & d3d8sddi makes the pluggable software rasterizer
// a "private" feature as these headers aren't publically available.
#include <d3d8ddi.h>
#include <d3d8sddi.h>

// This header contains the framework to get rasterizers up and running ASAP.
#include <DX8SDDIFW.h>

// Local project
using namespace DX8SDDIFW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\spaninit\rastcap.h ===
// rastcap.h - declaration of the CRastCapRecord class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCAP_H_
#define _RASTCAP_H_

// the current size of the rasterizer capability bit vector, in DWORDs.
#define RASTCAPRECORD_SIZE  3

// sets bits in the rasterizer capability bit vector
#define SET_VAL(pos, len, val)  ((m_rgdwData[(pos) / 32]) |= \
                                 (((val) & ~(0xFFFFFFFF << (len))) << \
                                  ((pos) % 32)))

// the positions and lengths of fields in the rasterizer capability bit vector
// note: make sure fields do not straddle DWORD boundaries!  SET_VAL cannot
//       currently handle that
#define ZFUNC_POS               0
#define ZFUNC_LEN               8
#define ZFORMAT_POS             8
#define ZFORMAT_LEN             4
#define ZTEST_POS               12
#define ZTEST_LEN               1
#define ZWRITE_POS              13
#define ZWRITE_LEN              1

#define SHADEMODE_POS           16
#define SHADEMODE_LEN           4
#define SPECULAR_POS            20
#define SPECULAR_LEN            1
#define VERTEXFOG_POS           21
#define VERTEXFOG_LEN           1
#define MONO_POS                22
#define MONO_LEN                1

#define TEXTUREFORMAT_POS       32
#define TEXTUREFORMAT_LEN       8
#define TEXTURE_POS             40
#define TEXTURE_LEN             4
#define TEXTUREBLEND_POS        44
#define TEXTUREBLEND_LEN        4
#define TEXTUREFILTER_POS       48
#define TEXTUREFILTER_LEN       4
#define TEXTUREPERSP_POS        52
#define TEXTUREPERSP_LEN        1
#define TEXTUERBORDER_POS       53
#define TEXTUREBORDER_LEN       1
#define TEXTUREADDR_POS         54
#define TEXTUREADDR_LEN         1
#define TEXTUREMIP_POS          55
#define TEXTUREMIP_LEN          1
#define TEXTURELOD_POS          56
#define TEXTURELOD_LEN          1
#define TEXTURECOLORKEY_POS     57
#define TEXTURECOLORKEY_LEN     1
#define TEXTUREALPHAOVERRIDE_POS 58
#define TEXTUREALPHAOVERRIDE_LEN 1

#define TARGETPIXELFORMAT_POS   64
#define TARGETPIXELFORMAT_LEN   8
#define SRCBLEND_POS            72
#define SRCBLEND_LEN            4
#define DESTBLEND_POS           76
#define DESTBLEND_LEN           4
#define STIPPLE_POS             80
#define STIPPLE_LEN             1
#define DITHER_POS              81
#define DITHER_LEN              1
#define ROP_POS                 82
#define ROP_LEN                 1
#define BLEND_POS               83
#define BLEND_LEN               1
#define ALPHATEST_POS           84
#define ALPHATEST_LEN           1
#define ALPHABLEND_POS          85
#define ALPHABLEND_LEN          1
#define STENCIL_POS             86
#define STENCIL_LEN             1

class CRastCapRecord {

    friend class CRastCollection;

private:

    DWORD   m_rgdwData[RASTCAPRECORD_SIZE];

public:

    CRastCapRecord(void)
    {
        memset(m_rgdwData,0,RASTCAPRECORD_SIZE * sizeof(DWORD));
        return;
    }

    void Set_ZTest(int iZTest)
    {
        SET_VAL(ZTEST_POS,ZTEST_LEN,iZTest);
        return;
    }

    void Set_ZFormat(int iZFormat)
    {
        SET_VAL(ZFORMAT_POS,ZFORMAT_LEN,iZFormat);
        return;
    }

    void Set_ZWrite(int iZWrite)
    {
        SET_VAL(ZWRITE_POS,ZWRITE_LEN,iZWrite);
        return;
    }

    void Set_ZFunc(int iZFunc)
    {
        SET_VAL(ZFUNC_POS,ZFUNC_LEN,iZFunc);
        return;
    }

    void Set_Stipple(int iStipple)
    {
        SET_VAL(STIPPLE_POS,STIPPLE_LEN,iStipple);
        return;
    }

    void Set_AlphaTest(int iAlphaTest)
    {
        SET_VAL(ALPHATEST_POS,ALPHATEST_LEN,iAlphaTest);
        return;
    }

    void Set_ShadeMode(int iShadeMode)
    {
        SET_VAL(SHADEMODE_POS,SHADEMODE_LEN,iShadeMode);
        return;
    }

    void Set_Specular(int iSpecular)
    {
        SET_VAL(SPECULAR_POS,SPECULAR_LEN,iSpecular);
        return;
    }

    void Set_VertexFog(int iVertexFog)
    {
        SET_VAL(VERTEXFOG_POS,VERTEXFOG_LEN,iVertexFog);
        return;
    }

    void Set_Texture(int iTexture)
    {
        SET_VAL(TEXTURE_POS,TEXTURE_LEN,iTexture);
        return;
    }

    void Set_TexturePersp(int iTexturePersp)
    {
        SET_VAL(TEXTUREPERSP_POS,TEXTUREPERSP_LEN,iTexturePersp);
        return;
    }

    void Set_TextureBlend(int iTextureBlend)
    {
        SET_VAL(TEXTUREBLEND_POS,TEXTUREBLEND_LEN,iTextureBlend);
        return;
    }

    // for now, just capture texture state for the first texture
    // and assume monolithics are single textured.
    void Set_TextureBorder(int i, int iTextureBorder)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUERBORDER_POS,TEXTUREBORDER_LEN,iTextureBorder);
        }
        return;
    }

    void Set_TextureAddr(int i, int iTextureAddr)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREADDR_POS,TEXTUREADDR_LEN,iTextureAddr);
        }
        return;
    }

    void Set_TextureFilter(int i, int iTextureFilter)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFILTER_POS,TEXTUREFILTER_LEN,iTextureFilter);
        }
        return;
    }

    void Set_TextureMip(int i, int iTextureMip)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREMIP_POS,TEXTUREMIP_LEN,iTextureMip);
        }
        return;
    }

    void Set_TextureLOD(int i, int iTextureLOD)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURELOD_POS,TEXTURELOD_LEN,iTextureLOD);
        }
        return;
    }

    void Set_TextureFormat(int i, int iTextureFormat)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFORMAT_POS,TEXTUREFORMAT_LEN,iTextureFormat);
        }
        return;
    }

    void Set_TextureColorKey(int i, int iTextureColorKey)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURECOLORKEY_POS,TEXTURECOLORKEY_LEN,iTextureColorKey);
        }
        return;
    }

    void Set_TextureAlphaOverride(int i, int iTextureAlphaOverride)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREALPHAOVERRIDE_POS,TEXTUREALPHAOVERRIDE_LEN,iTextureAlphaOverride);
        }
        return;
    }

    void Set_Mono(int iMono)
    {
        SET_VAL(MONO_POS,MONO_LEN,iMono);
        return;
    }

    void Set_AlphaBlend(int iAlphaBlend)
    {
        SET_VAL(ALPHABLEND_POS,ALPHABLEND_LEN,iAlphaBlend);
        return;
    }

    void Set_Blend(int iBlend)
    {
        SET_VAL(BLEND_POS,BLEND_LEN,iBlend);
        return;
    }

    void Set_ROP(int iROP)
    {
        SET_VAL(ROP_POS,ROP_LEN,iROP);
        return;
    }

    void Set_SrcBlend(int iSrcBlend)
    {
        SET_VAL(SRCBLEND_POS,SRCBLEND_LEN,iSrcBlend);
        return;
    }

    void Set_DestBlend(int iDestBlend)
    {
        SET_VAL(DESTBLEND_POS,DESTBLEND_LEN,iDestBlend);
        return;
    }

    void Set_TargetPixelFormat(int iTargetPixelFormat)
    {
        SET_VAL(TARGETPIXELFORMAT_POS,TARGETPIXELFORMAT_LEN,iTargetPixelFormat);
        return;
    }

    void Set_Dither(int iDither)
    {
        SET_VAL(DITHER_POS,DITHER_LEN,iDither);
        return;
    }

    void Set_Stencil(int iStencil)
    {
        SET_VAL(STENCIL_POS,STENCIL_LEN,iStencil);
        return;
    }

#if DBG
    DWORD GetCapDWord(int iNum)
    {
        return m_rgdwData[iNum];
    }
#endif
};

#endif  // _RASTCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\sample\main.cpp ===
#include "pch.h"
#include "SampleSW.h"
#pragma hdrstop

// Needed as MSVC doesn't throw bad_alloc upon failed new(), unless
// we specifically make it do.
_PNH g_OldNewHandler= NULL;

int _cdecl NewHandlerThatThrows( size_t size )
{
    throw std::bad_alloc();

    // Tell new to stop allocation attempts.
    return 0;
}

CMyDriver* CMyDriver::sm_pGlobalDriver= NULL;

DX8SDDIFW::COSDetector DX8SDDIFW::g_OSDetector;

BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_OldNewHandler = _set_new_handler( NewHandlerThatThrows);
            CMyDriver::sm_pGlobalDriver= new CMyDriver;
            break;

        // DLL_PROCESS_DETACH will be called if ATTACH returned FALSE.
        case DLL_PROCESS_DETACH:
            delete CMyDriver::sm_pGlobalDriver;
            CMyDriver::sm_pGlobalDriver= NULL;
            _set_new_handler( g_OldNewHandler);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

HRESULT APIENTRY
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
    DWORD* pNumTextures, DDSURFACEDESC** ppTexList)
{
    return CMyDriver::sm_pGlobalDriver->GetSWInfo( *pCaps, *pCallbacks,
        *pNumTextures, *ppTexList );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\sample\samplesw.cpp ===
#include "pch.h"
#include "SampleSW.h"
#pragma hdrstop

const D3DCAPS8 CMyDriver::c_D3DCaps=
{
    // Indicates this is software rasterizer.
    /*D3DDEVTYPE_HAL|| D3DDEVTYPE_REF||*/ D3DDEVTYPE_SW,

    // Adapter ordinal (isn't used to report anything).
    0,

    // Caps (See ddraw.h & d3d8caps.h for details of each CAP).
    /*DDCAPS_3D| DDCAPS_ALIGNBOUNDARYDEST| DDCAPS_ALIGNSIZEDEST|
    DDCAPS_ALIGNBOUNDARYSRC| DDCAPS_ALIGNSIZESRC| DDCAPS_ALIGNSTRIDE|
    DDCAPS_BLT| DDCAPS_BLTQUEUE| DDCAPS_BLTFOURCC| DDCAPS_BLTSTRETCH|
    DDCAPS_GDI| DDCAPS_OVERLAY| DDCAPS_OVERLAYCANTCLIP| DDCAPS_OVERLAYFOURCC|
    DDCAPS_OVERLAYSTRETCH| DDCAPS_PALETTE| DDCAPS_PALETTEVSYNC| 
    DDCAPS_READSCANLINE| DDCAPS_VBI| DDCAPS_ZBLTS| DDCAPS_ZOVERLAYS|
    DDCAPS_COLORKEY| DDCAPS_ALPHA| DDCAPS_COLORKEYHWASSIST| DDCAPS_NOHARDWARE|
    DDCAPS_BLTCOLORFILL| DDCAPS_BANKSWITCHED| DDCAPS_BLTDEPTHFILL|
    DDCAPS_CANCLIP| DDCAPS_CANCLIPSTRETCHED| DDCAPS_CANBLTSYSMEM|
    D3DCAPS_READ_SCANLINE|*/ 0,

    // Caps2
    /*DDCAPS2_CERTIFIED| DDCAPS2_NO2DDURING3DSCENE| DDCAPS2_VIDEOPORT|
    DDCAPS2_AUTOFLIPOVERLAY| DDCAPS2_CANBOBINTERLEAVED| 
    DDCAPS2_CANBOBNONINTERLEAVED| DDCAPS2_COLORCONTROLOVERLAY| 
    DDCAPS2_COLORCONTROLPRIMARY|*/ DDCAPS2_CANDROPZ16BIT| 
    /*DDCAPS2_NONLOCALVIDMEM| DDCAPS2_NONLOCALVIDMEMCAPS| 
    DDCAPS2_NOPAGELOCKREQUIRED|*/ DDCAPS2_WIDESURFACES|
    /*DDCAPS2_CANFLIPODDEVEN| DDCAPS2_CANBOBHARDWARE| DDCAPS2_COPYFOURCC|
    DDCAPS2_PRIMARYGAMMA|*/ DDCAPS2_CANRENDERWINDOWED| 
    /*DDCAPS2_CANCALIBRATEGAMMA| DDCAPS2_FLIPINTERVAL|
    DDCAPS2_FLIPNOVSYNC| DDCAPS2_CANMANAGETEXTURE|
    DDCAPS2_TEXMANINNONLOCALVIDMEM| DDCAPS2_STEREO|
    DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL| D3DCAPS2_NO2DDURING3DSCENE| 
    D3DCAPS2_FULLSCREENGAMMA|*/ D3DCAPS2_CANRENDERWINDOWED|
    /*D3DCAPS2_CANCALIBRATEGAMMA|*/ 0,

    // Caps3
    0,
    // Presentation Intervals
    0,
    // Cursor Caps
    0,

    // DevCaps (See d3d8caps.h & d3dhal.h)
    // The SDDI driver should keep D3DDEVCAPS_TEXTUREVIDEOMEMORY enabled. The
    // runtime does not behave correctly if the driver does not enable and
    // support this cap. In other words, all textures must be able to be
    // vid mem (driver allocated) textures, at least.
    D3DDEVCAPS_EXECUTESYSTEMMEMORY| /*D3DDEVCAPS_EXECUTEVIDEOMEMORY|*/
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY| /*D3DDEVCAPS_TLVERTEXVIDEOMEMORY|*/
    D3DDEVCAPS_TEXTURESYSTEMMEMORY| D3DDEVCAPS_TEXTUREVIDEOMEMORY|
    D3DDEVCAPS_DRAWPRIMTLVERTEX| /*D3DDEVCAPS_CANRENDERAFTERFLIP|
    D3DDEVCAPS_TEXTURENONLOCALVIDMEM| D3DDEVCAPS_DRAWPRIMITIVES2|*/
    /*D3DDEVCAPS_SEPARATETEXTUREMEMORIES|*/ D3DDEVCAPS_DRAWPRIMITIVES2EX|
    /*D3DDEVCAPS_HWTRANSFORMANDLIGHT| D3DDEVCAPS_CANBLTSYSTONONLOCAL|*/
    D3DDEVCAPS_HWRASTERIZATION| /*D3DDEVCAPS_PUREDEVICE| 
    D3DDEVCAPS_QUINTICRTPATCHES| D3DDEVCAPS_RTPATCHES|
    D3DDEVCAPS_RTPATCHHANDLEZERO| D3DDEVCAPS_NPATCHES|
	D3DDEVCAPS_HWVERTEXBUFFER| D3DDEVCAPS_HWINDEXBUFFER|*/ 0,

    // Primitive Misc Caps
    D3DPMISCCAPS_MASKZ| D3DPMISCCAPS_LINEPATTERNREP| D3DPMISCCAPS_CULLNONE|
    D3DPMISCCAPS_CULLCW| D3DPMISCCAPS_CULLCCW| D3DPMISCCAPS_COLORWRITEENABLE|
    /*D3DPMISCCAPS_CLIPPLANESCALEDPOINTS| D3DPMISCCAPS_CLIPTLVERTS|*/
    D3DPMISCCAPS_TSSARGTEMP| D3DPMISCCAPS_BLENDOP| 0,

    // Raster Caps
    /*D3DPRASTERCAPS_DITHER| D3DPRASTERCAPS_ROP2| D3DPRASTERCAPS_XOR| 
    D3DPRASTERCAPS_PAT|*/ D3DPRASTERCAPS_ZTEST| /*D3DPRASTERCAPS_FOGVERTEX|
    D3DPRASTERCAPS_FOGTABLE| D3DPRASTERCAPS_ANTIALIASEDGES|
    D3DPRASTERCAPS_MIPMAPLODBIAS| D3DPRASTERCAPS_ZBIAS|
    D3DPRASTERCAPS_ZBUFFERLESSHSR| D3DPRASTERCAPS_FOGRANGE|
    D3DPRASTERCAPS_ANISOTROPY| D3DPRASTERCAPS_WBUFFER| 
    D3DPRASTERCAPS_WFOG| D3DPRASTERCAPS_ZFOG| 
    D3DPRASTERCAPS_COLORPERSPECTIVE| D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE|
    */ 0,

    // Z Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Src Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 
    D3DPBLENDCAPS_BOTHSRCALPHA| D3DPBLENDCAPS_BOTHINVSRCALPHA| 0,

    // Dest Blend Caps
    D3DPBLENDCAPS_ZERO| D3DPBLENDCAPS_ONE| D3DPBLENDCAPS_SRCCOLOR|
    D3DPBLENDCAPS_INVSRCCOLOR| D3DPBLENDCAPS_SRCALPHA| 
    D3DPBLENDCAPS_INVSRCALPHA| D3DPBLENDCAPS_DESTALPHA| 
    D3DPBLENDCAPS_INVDESTALPHA| D3DPBLENDCAPS_DESTCOLOR| 
    D3DPBLENDCAPS_INVDESTCOLOR| D3DPBLENDCAPS_SRCALPHASAT| 0,

    // Alpha Compare Caps
    D3DPCMPCAPS_NEVER| D3DPCMPCAPS_LESS| D3DPCMPCAPS_EQUAL| 
    D3DPCMPCAPS_LESSEQUAL| D3DPCMPCAPS_GREATER| D3DPCMPCAPS_NOTEQUAL| 
    D3DPCMPCAPS_GREATEREQUAL| D3DPCMPCAPS_ALWAYS| 0,

    // Shade Caps 
    D3DPSHADECAPS_COLORGOURAUDRGB| D3DPSHADECAPS_SPECULARGOURAUDRGB| 
    D3DPSHADECAPS_ALPHAGOURAUDBLEND| D3DPSHADECAPS_FOGGOURAUD| 0,

    // Texture Caps
    D3DPTEXTURECAPS_PERSPECTIVE| /*D3DPTEXTURECAPS_POW2|*/ 
    D3DPTEXTURECAPS_ALPHA| /*D3DPTEXTURECAPS_SQUAREONLY|*/
    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE| D3DPTEXTURECAPS_ALPHAPALETTE|
    /*D3DPTEXTURECAPS_NONPOW2CONDITIONAL|*/ D3DPTEXTURECAPS_PROJECTED| 
    D3DPTEXTURECAPS_CUBEMAP| D3DPTEXTURECAPS_VOLUMEMAP| 
    D3DPTEXTURECAPS_MIPMAP| D3DPTEXTURECAPS_MIPVOLUMEMAP| 
    D3DPTEXTURECAPS_MIPCUBEMAP| /*D3DPTEXTURECAPS_CUBEMAP_POW2| 
    D3DPTEXTURECAPS_VOLUMEMAP_POW2|*/ 0,

    // Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC| 0,

    // Cube Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC| 0,

    // Volume Texture Filter Caps
    D3DPTFILTERCAPS_MINFPOINT| D3DPTFILTERCAPS_MINFLINEAR| 
    D3DPTFILTERCAPS_MINFANISOTROPIC| D3DPTFILTERCAPS_MIPFPOINT| 
    D3DPTFILTERCAPS_MIPFLINEAR| D3DPTFILTERCAPS_MAGFPOINT| 
    D3DPTFILTERCAPS_MAGFLINEAR| D3DPTFILTERCAPS_MAGFANISOTROPIC|
    D3DPTFILTERCAPS_MAGFAFLATCUBIC| D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC| 0,

    // Texture Address Caps
    D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| D3DPTADDRESSCAPS_MIRRORONCE| 0,

    // Volume Texture Address Caps
    D3DPTADDRESSCAPS_WRAP| D3DPTADDRESSCAPS_MIRROR| 
    D3DPTADDRESSCAPS_CLAMP| D3DPTADDRESSCAPS_BORDER| 
    D3DPTADDRESSCAPS_INDEPENDENTUV| D3DPTADDRESSCAPS_MIRRORONCE| 0,

    // Line Caps
    D3DLINECAPS_TEXTURE| D3DLINECAPS_ZTEST| D3DLINECAPS_BLEND| 
    D3DLINECAPS_ALPHACMP| D3DLINECAPS_FOG| 0,

    // Max Texture Width, Height, Volume Extent
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFF,
    
    // Max Texture Repeat, Texture Aspect Ratio, Anisotropy
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFF,

    // Max VertexW
    1.0e10f,

    // Guard Band left, top, right, bottom
    -32768.0f, -32768.0f, 32767.0f, 32767.0f,

    // Extents Adjust
    0.0f,

    // Stencil Caps
    D3DSTENCILCAPS_KEEP| D3DSTENCILCAPS_ZERO| D3DSTENCILCAPS_REPLACE|
    D3DSTENCILCAPS_INCRSAT| D3DSTENCILCAPS_DECRSAT| D3DSTENCILCAPS_INVERT|
    D3DSTENCILCAPS_INCR| D3DSTENCILCAPS_DECR| 0,

    // FVF Caps
    (8& D3DFVFCAPS_TEXCOORDCOUNTMASK)| D3DFVFCAPS_DONOTSTRIPELEMENTS|
    D3DFVFCAPS_PSIZE| 0,

    // TextureOpCaps
    D3DTEXOPCAPS_DISABLE| D3DTEXOPCAPS_SELECTARG1| D3DTEXOPCAPS_SELECTARG2|
    D3DTEXOPCAPS_MODULATE| D3DTEXOPCAPS_MODULATE2X| 
    D3DTEXOPCAPS_MODULATE4X| D3DTEXOPCAPS_ADD| D3DTEXOPCAPS_ADDSIGNED| 
    D3DTEXOPCAPS_ADDSIGNED2X| D3DTEXOPCAPS_SUBTRACT|
    D3DTEXOPCAPS_ADDSMOOTH| D3DTEXOPCAPS_BLENDDIFFUSEALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHA| D3DTEXOPCAPS_BLENDFACTORALPHA| 
    D3DTEXOPCAPS_BLENDTEXTUREALPHAPM| D3DTEXOPCAPS_BLENDCURRENTALPHA|
    D3DTEXOPCAPS_PREMODULATE| D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA|
    D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR| 
    D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA| D3DTEXOPCAPS_BUMPENVMAP|
    D3DTEXOPCAPS_BUMPENVMAPLUMINANCE| D3DTEXOPCAPS_DOTPRODUCT3|
    D3DTEXOPCAPS_MULTIPLYADD| D3DTEXOPCAPS_LERP| 0,
    
    // Max Texture Blend Stages, Simulatenous Textures
    D3DHAL_TSS_MAXSTAGES, D3DHAL_TSS_MAXSTAGES,

    // Vertex Processing Caps
    /*D3DVTXPCAPS_TEXGEN| D3DVTXPCAPS_MATERIALSOURCE7|
    D3DVTXPCAPS_DIRECTIONALLIGHTS| D3DVTXPCAPS_POSITIONALLIGHTS|
    D3DVTXPCAPS_LOCALVIEWER| D3DVTXPCAPS_TWEENING|*/ 0,

    // Max Active Lights, User Clip Planes, Vertex Blend Matrices
    0, 0, 0, 

    // Max Vertex Blend Matrix Index, Point Size, Primitive Count
    0, 1.0f, 0xFFFFFFFF,

    // Max Vertex Index, Streams, Stream Stride,
    0xFFFFFFFF, 1, 256,

    // Vertex Shader version, Max Vertex Shader Const
    D3DVS_VERSION(0,0), 0,

    // Pixel Shader version, Max Pixel Shader Value
    D3DPS_VERSION(1,0), 16.0f,
};

const CMyDriver::CSurfaceCapWrap CMyDriver::c_aSurfaces[]=
{
    // Tex, VTex, CTex, OffSTarg, SameFmtTarg, Z/S, Z/SWColor, SameFmtToA, 3D
    CSurfaceCapWrap( D3DFMT_A4R4G4B4,
        true, false, false, false, false, false, false, false, false),
    CSurfaceCapWrap( D3DFMT_R5G6B5,
        true, false, false, false, false, false, false, false, false),
    CSurfaceCapWrap( D3DFMT_A8R8G8B8,
        true, false, false, true, true, false, false, false, true),
    CSurfaceCapWrap( D3DFMT_X8R8G8B8,
        true, false, false, true, true, false, false, false, true),
    CSurfaceCapWrap( D3DFMT_D16_LOCKABLE,
        false, false, false, false, false, true, true, false, false),
/*    CSurfaceCapWrap( D3DFMT_D32,
        false, false, false, false, false, true, true, false, false),*/
};

CMyDriver::CMyDriver():
    CMinimalDriver< CMyDriver, CMyRasterizer>( c_aSurfaces,
        c_aSurfaces+ sizeof(c_aSurfaces)/ sizeof(c_aSurfaces[0]))
{
}
/*
const CMyContext::TDP2CmdBind CMyContext::c_aDP2Bindings[]=
{
    TDP2CmdBind( D3DDP2OP_VIEWPORTINFO,      DP2ViewportInfo),
    TDP2CmdBind( D3DDP2OP_WINFO,             DP2WInfo),
    TDP2CmdBind( D3DDP2OP_RENDERSTATE,       DP2RenderState),
    TDP2CmdBind( D3DDP2OP_TEXTURESTAGESTATE, DP2TextureStageState),
    TDP2CmdBind( D3DDP2OP_CLEAR,             DP2Clear),
    TDP2CmdBind( D3DDP2OP_SETVERTEXSHADER,   DP2SetVertexShader),
    TDP2CmdBind( D3DDP2OP_SETSTREAMSOURCE,   DP2SetStreamSource),
    TDP2CmdBind( D3DDP2OP_SETINDICES,        DP2SetIndices),
    TDP2CmdBind( D3DDP2OP_DRAWPRIMITIVE2,    DP2DrawPrimitive2),
    TDP2CmdBind( D3DDP2OP_DRAWPRIMITIVE,     DP2DrawPrimitive),
    TDP2CmdBind( D3DDP2OP_SETRENDERTARGET,   DP2SetRenderTarget)
};

const CMyContext::TDP2CmdBind* CMyContext::GetDP2Bindings( unsigned int& iBindings)
{
    iBindings= sizeof(c_aDP2Bindings)/ sizeof(c_aDP2Bindings[0]);
    return c_aDP2Bindings;
}

HRESULT CMyContext::DP2DrawPrimitive( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
    const void* pP)
{
    const D3DHAL_DP2DRAWPRIMITIVE* pParam=
        reinterpret_cast< const D3DHAL_DP2DRAWPRIMITIVE*>(pP);

    const D3DHAL_DP2VIEWPORTINFO& ViewportInfo= (*this);
    const D3DHAL_DP2VERTEXSHADER& VertexShader= (*this);
    const D3DHAL_DP2SETSTREAMSOURCE& StreamSource= (*this);
    const D3DHAL_DP2SETINDICES& Indices= (*this);

    LPDDRAWI_DDRAWSURFACE_LCL pVBuffer= m_pGblDriver->SurfaceDBFind(
        m_pAssociatedDDraw, StreamSource.dwVBHandle);
    assert( pVBuffer!= NULL);

    if((VertexShader.dwHandle& D3DFVF_POSITION_MASK)!= D3DFVF_XYZRHW)
        return D3DERR_COMMAND_UNPARSED;

    const UINT8* pData= reinterpret_cast< const UINT8*>(
        pVBuffer->lpGbl->fpVidMem);
    pData+= pParam->VStart* StreamSource.dwStride;

    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
    if( wPrimitiveCount) do
    {
        assert( pParam->primType== D3DPT_TRIANGLELIST);

        DWORD dwPrimCount( pParam->PrimitiveCount);
        if( dwPrimCount) do
        {
            const float* pfXYZ= reinterpret_cast<const float*>(pData);
            int iX( pfXYZ[0]);
            int iY( pfXYZ[1]);

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

        } while( --dwPrimCount);

        pParam++;
    } while( --wPrimitiveCount);

    return DD_OK;
}

HRESULT CMyContext::DP2DrawPrimitive2( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
    const void* pP)
{
    const D3DHAL_DP2DRAWPRIMITIVE2* pParam=
        reinterpret_cast< const D3DHAL_DP2DRAWPRIMITIVE2*>(pP);

    const D3DHAL_DP2VIEWPORTINFO& ViewportInfo= (*this);
    const D3DHAL_DP2VERTEXSHADER& VertexShader= (*this);
    const D3DHAL_DP2SETSTREAMSOURCE& StreamSource= (*this);
    const D3DHAL_DP2SETINDICES& Indices= (*this);

    LPDDRAWI_DDRAWSURFACE_LCL pVBuffer= m_pGblDriver->SurfaceDBFind(
        m_pAssociatedDDraw, StreamSource.dwVBHandle);
    assert( pVBuffer!= NULL);

    assert((VertexShader.dwHandle& D3DFVF_POSITION_MASK)== D3DFVF_XYZRHW);

    const UINT8* pData= reinterpret_cast< const UINT8*>(
        pVBuffer->lpGbl->fpVidMem);
    pData+= pParam->FirstVertexOffset;

    WORD wPrimitiveCount( pCmd->wPrimitiveCount);
    if( wPrimitiveCount) do
    {
        assert( pParam->primType== D3DPT_TRIANGLELIST);

        DWORD dwPrimCount( pParam->PrimitiveCount);
        if( dwPrimCount) do
        {
            const float* pfXYZ= reinterpret_cast<const float*>(pData);
            int iX( pfXYZ[0]);
            int iY( pfXYZ[1]);

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

            pfXYZ= reinterpret_cast<const float*>(pData);
            iX= pfXYZ[0];
            iY= pfXYZ[1];

            // TODO: Fix.
            if( iX>= 0 && iX< ViewportInfo.dwWidth &&
                iY>= 0 && iY< ViewportInfo.dwHeight)
            {
                DWORD* pPixel= reinterpret_cast<DWORD*>(
                    reinterpret_cast<UINT8*>(m_pDDSLcl->lpGbl->fpVidMem)+
                    (m_pDDSLcl->lpGbl->lPitch)* iY+ sizeof( DWORD)* iX);

                *pPixel= 0xFFFFFFFF;
            }

            pData+= StreamSource.dwStride;

        } while( --dwPrimCount);

        pParam++;
    } while( --wPrimitiveCount);

    return DD_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\rgb\spaninit\spindbg.hpp ===
//----------------------------------------------------------------------------
//
// spindbg.hpp
//
// Span Init debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPINDBG_HPP_
#define _SPINDBG_HPP_

// #include <cppdbg.hpp>

// DBG_DECLARE_HEADER(SPI);

#if 0
#define SPIDPF(Args)             DBG_DECLARE_DPF(SPI, Args)
#define SPIDPFM(Args)            DBG_DECLARE_DPFM(SPI, Args)
#define SPIASSERT(Exp)           DBG_DECLARE_ASSERT(SPI, Exp)
#define SPIASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(SPI, Exp, Args)
#define SPIVERIFY(Exp)           DBG_DECLARE_VERIFY(SPI, Exp)
#define SPIVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(SPI, Exp, Args)
#define SPIPROMPT(Args)          DBG_DECLARE_PROMPT(SPI, Args)
#define SPIGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(SPI, Idx)
#define SPISETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(SPI, Idx, Value)
#define SPIHRCHK(Exp)            DBG_DECLARE_HRCHK(SPI, Exp)
#define SPIHRGO(Exp, Label)      DBG_DECLARE_HRGO(SPI, Exp, Label)
#define SPIHRERR(Exp)            DBG_DECLARE_HRERR(SPI, Exp)
#define SPIHRRET(Exp)            DBG_DECLARE_HRRET(SPI, Exp)
#else
#define SPIDPF(Args)
#define SPIDPFM(Args)
#define SPIASSERT(Exp)
#define SPIASSERTMSG(Exp, Args)
#define SPIVERIFY(Exp)           (Exp)
#define SPIVERIFYMSG(Exp)        (Exp)
#define SPIPROMPT(Args)
#define SPIGETFLAGS(Idx)         (0)
#define SPISETFLAGS(Idx, Value)
#define SPIHRCHK(Exp)            (hr= (Exp))
#define SPIHRGO(Exp, Label)      if(SPIHRCHK(Exp)!= S_OK) { goto Label; } else hr
#define SPIHRERR(Exp)            SPIHGO(Exp, HR_Err)
#define SPIHRRET(Exp)            if(SPIHRCHK(Exp)!= S_OK) { return hr; } else hr
#endif


#define SPIM_INVALID             0x00000001
#define SPIM_REPORT              0x00000002

#define SPIU_BREAK_ON_SPANINIT   0x00000001

#endif // #ifndef _SPINDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\sample\samplesw.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// forward declaration
class CMyRasterizer;

////////////////////////////////////////////////////////////////////////////////
//
// CMyDriver
//
////////////////////////////////////////////////////////////////////////////////
class CMyDriver:
    public CMinimalDriver< CMyDriver, CMyRasterizer>
{
private:
    static const CSurfaceCapWrap c_aSurfaces[];
    static const D3DCAPS8 c_D3DCaps;

protected:

public:
    CMyDriver();
    ~CMyDriver()
    { }

    static const D3DCAPS8 GetCaps( void)
    { return c_D3DCaps; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CMyRasterizer
//
////////////////////////////////////////////////////////////////////////////////
class CMyRasterizer
{
public: // Types
    typedef CMyDriver::TContext TContext;

protected:
    int m_iVal;

public:
    CMyRasterizer() { }
    ~CMyRasterizer() { }

    HRESULT DrawPrimitive( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWPRIMITIVE* aDP2Param)
    {
        // Context can be converted to this structure.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            const D3DHAL_DP2DRAWPRIMITIVE* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->VStart* dwVStride;

                DrawOnePrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT DrawPrimitive2( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWPRIMITIVE2* aDP2Param)
    {
        // Context can be converted to this structure.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            const D3DHAL_DP2DRAWPRIMITIVE2* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                DrawOnePrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT DrawIndexedPrimitive( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* aDP2Param)
    {
        // Context can be converted to these structures.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        UINT16* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0= Context.GetVStream( 0);
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        TContext::TIStream& IStream= Context.GetIStream( 0);
        if( IStream.GetMemLocation()== TContext::TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TContext::TIStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT16*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

		if( pStartVData!= NULL&& pStartIData!= NULL)
        {
            // Sample should've marked caps as only supporting 16-bit indices.
            assert( sizeof(UINT16)== dwIStride);

            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->BaseVertexIndex* dwVStride;
                const UINT16* pIData= pStartIData+ pParam->StartIndex; //* dwIStride;

                DrawOneIPrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF, pIData);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT DrawIndexedPrimitive2( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* aDP2Param)
    {
        // Context can be converted to these structures.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        UINT16* pStartIData= NULL;
        DWORD dwVStride( 0);
        DWORD dwIStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

        // Find Indices information.
        TContext::TIStream& IStream= Context.GetIStream( 0);
        if( IStream.GetMemLocation()== TContext::TIStream::EMemLocation::System||
            IStream.GetMemLocation()== TContext::TIStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartIData= reinterpret_cast< UINT16*>(
                IStream.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwIStride= IStream.GetStride();
        }

		if( pStartVData!= NULL&& pStartIData!= NULL)
        {
            // Sample should've marked caps as only supporting 16-bit indices.
            assert( sizeof(UINT16)== dwIStride);

            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->BaseVertexOffset;
                const UINT16* pIData= reinterpret_cast< const UINT16*>(
                    pStartIData+ pParam->StartIndexOffset);

                DrawOneIPrimitive( Context, pParam->primType,
                    pParam->PrimitiveCount, pVData, dwVStride, dwFVF, pIData);
                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }
    HRESULT ClippedTriangleFan( TContext& Context, const D3DHAL_DP2COMMAND& DP2Cmd,
        const D3DHAL_CLIPPEDTRIANGLEFAN* aDP2Param)
    {
        // Context can be converted to this structure.
        const D3DHAL_DP2VERTEXSHADER VertexShader( Context);

        // We need this data.
        UINT8* pStartVData= NULL;
        DWORD dwVStride( 0);

        // Since Sample is a non TnL device, the vertex shader handle should
        // always be a fixed function FVF.
        const DWORD dwFVF( VertexShader.dwHandle);

        // Since Sample only supports one stream, our data source should be
        // from stream 0.
        TContext::TVStream& VStream0( Context.GetVStream( 0));
        VStream0.SetFVF( dwFVF);

        // Find vertex information.
        if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::User)
        {
            pStartVData= reinterpret_cast< UINT8*>( VStream0.GetUserMemPtr());
            dwVStride= VStream0.GetStride();
        }
        else if( VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::System||
            VStream0.GetMemLocation()== TContext::TVStream::EMemLocation::Video)
        {
            // Sample can pretend system mem and video mem surfaces are the same.
            pStartVData= reinterpret_cast< UINT8*>(
                VStream0.GetSurfDBRepresentation()->GetGBLfpVidMem());
            dwVStride= VStream0.GetStride();
        }

		if( pStartVData!= NULL)
        {
            const D3DHAL_CLIPPEDTRIANGLEFAN* pParam= aDP2Param;
            WORD wPrimitiveCount( DP2Cmd.wPrimitiveCount);
            if( wPrimitiveCount) do
            {
                const UINT8* pVData= pStartVData+ pParam->FirstVertexOffset;

                // Must use pParam->dwEdgeFlags for correct drawing of wireframe.
                if( Context.GetRenderStateDW( D3DRS_FILLMODE)!= D3DFILL_WIREFRAME)
                    DrawOnePrimitive( Context, D3DPT_TRIANGLEFAN,
                        pParam->PrimitiveCount, pVData, dwVStride, dwFVF);
                else
                    assert( false); // NYI

                pParam++;
            } while( --wPrimitiveCount);
        }
        return DD_OK;
    }

    void DrawOnePrimitive( TContext& Context, D3DPRIMITIVETYPE primType,
        WORD wPrims, const UINT8* pVData, DWORD dwVStride, DWORD dwFVF)
    { }
    void DrawOneIPrimitive( TContext& Context, D3DPRIMITIVETYPE primType,
        WORD wPrims, const UINT8* pVData, DWORD dwVStride, DWORD dwFVF,
        const UINT16* pIData)
    { }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\swrast\sample\sources.inc ===
!INCLUDE ..\..\swrast.inc

# Standard sources.inc stuff
MAJORCOMP=d3d
MINORCOMP=d3d8
TARGETNAME=samplesw
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup

# .def (Exports) file built from .src file
DLLDEF=$O\samplesw.def

# Do we need this? On for Multi-processor build safety.
# SYNCHRONIZE_DRAIN=1

# Use C++ exception handling for now, so we can rapidly build with STL
USE_NATIVE_EH=1

# Shell Team indicates MSVCRT should be used.
USE_MSVCRT=1

!IF "$(NTDEBUG)" == "ntsd"
DEBUG_CRTS=1
!ENDIF

# We need notably <ddraw.h>, <ddrawi.h>, <d3dhal.h>, & <d3d8ddi.h>
# This could be cleaned up. The interface is not available to the public,
# so the files needed shouldn't be in public, but some directories seem too "private".
# See the precompiled header for concrete listing of files.
INCLUDES = ..\;$(INCLUDES)

PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_CXX=1

TARGETLIBS = \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\winmm.lib \
	$(SDK_LIB_PATH)\msvcprt.lib \
	$(SDK_LIB_PATH)\kernel32.lib


SOURCES = \
	..\SampleSW.cpp \
	..\Main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\choosecolorobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       choosecolorobj.h
//
//--------------------------------------------------------------------------

// ChooseColorObj.h : Declaration of the CChooseColorObject


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CChooseColorObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IChooseColor, &IID_IChooseColor, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IChooseColor,
#endif
	public CComObjectBase<&CLSID_ChooseColor>
{
public:
	CChooseColorObject() ;
BEGIN_COM_MAP(CChooseColorObject)
	COM_INTERFACE_ENTRY(IChooseColor)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CChooseColorObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CChooseColorObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// IChooseColor
public:
	STDMETHOD(setOwner)(long hwnd);
	STDMETHOD(setInitialColor)(COLORREF c);
	STDMETHOD(setFlags)(long flags);
	STDMETHOD(show)(int *selected);
	STDMETHOD(getColor)(COLORREF *c);
private:
	HWND m_hwnd;
	COLORREF m_color;
	DWORD m_flags;
	BOOL m_completed;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3ddevice7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.h
//
//--------------------------------------------------------------------------

// d3dDeviceObj.h : Declaration of the C_dxj_Direct3dDeviceObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dDevice7 LPDIRECT3DDEVICE7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't
//          like references as template arguments.

class C_dxj_Direct3dDevice7Object : 
        public I_dxj_Direct3dDevice7,
		//public CComCoClass<C_dxj_Direct3dDevice7Object, &CLSID__dxj_Direct3dDevice7>,
		public CComObjectRoot
{
public:
        C_dxj_Direct3dDevice7Object();
        virtual ~C_dxj_Direct3dDevice7Object();
		DWORD InternalAddRef();
		DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3dDevice7Object)
        COM_INTERFACE_ENTRY(I_dxj_Direct3dDevice7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dDevice7,			"DIRECT.Direct3dDevice7.3",          "DIRECT.Direct3dDevice7.3",			IDS_D3DDEVICE_DESC,			THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dDevice7Object)

// I_dxj_Direct3dDevice
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
          HRESULT STDMETHODCALLTYPE applyStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE beginScene( void);
        
          HRESULT STDMETHODCALLTYPE beginStateBlock( void);
        
          HRESULT STDMETHODCALLTYPE captureStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE clear( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *recs,
            /* [in] */ long flags,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long stencil);
        
          HRESULT STDMETHODCALLTYPE computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radius,
            /* [retval][out] */ long __RPC_FAR *returnVal);
        
          HRESULT STDMETHODCALLTYPE deleteStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indices,
            /* [in] */ long IndicesCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags);
                  
          HRESULT STDMETHODCALLTYPE endScene( void);
        
          HRESULT STDMETHODCALLTYPE endStateBlock( 
            /* [in] */ long __RPC_FAR *blockHandle);
        
          HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *desc);
        
          HRESULT STDMETHODCALLTYPE getClipStatus( 
            /* [out][in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d7 __RPC_FAR *__RPC_FAR *dev);
        
          HRESULT STDMETHODCALLTYPE getLight( 
            /* [in] */ long LightIndex,
            /* [out][in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE getLightEnable( 
            /* [in] */ long LightIndex,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
          HRESULT STDMETHODCALLTYPE getMaterial( 
            /* [out][in] */ D3dMaterial7 __RPC_FAR *Material);
        
          HRESULT STDMETHODCALLTYPE getRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [retval][out] */ long __RPC_FAR *renderstate);
        
          HRESULT STDMETHODCALLTYPE getRenderTarget( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppval);
        
          HRESULT STDMETHODCALLTYPE getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
          HRESULT STDMETHODCALLTYPE getTextureFormatsEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval);
        
          HRESULT STDMETHODCALLTYPE getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *val);
        
          HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE getViewport( 
            /* [out][in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE lightEnable( 
            /* [in] */ long LightIndex,
            /* [in] */ VARIANT_BOOL b);
        
          HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *DestTex,
            /* [in] */ long xDest,
            /* [in] */ long yDest,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *SrcTex,
            /* [in] */ Rect __RPC_FAR *rcSrcRect,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE multiplyTransform( 
            /* [in] */ long dstTransfromStateType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
        
          HRESULT STDMETHODCALLTYPE preLoad( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surf);
        
          HRESULT STDMETHODCALLTYPE setClipStatus( 
            /* [in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE setLight( 
            /* [in] */ long LightIndex,
            /* [in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ D3dMaterial7 __RPC_FAR *mat);
        
          HRESULT STDMETHODCALLTYPE setRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ long renderstate);
        
          HRESULT STDMETHODCALLTYPE setRenderTarget( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surface);
        
          HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ long stage,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *texture);
        
          HRESULT STDMETHODCALLTYPE setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long value);
        
          HRESULT STDMETHODCALLTYPE setTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE setViewport( 
            /* [in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes);
   

          HRESULT STDMETHODCALLTYPE setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float value);
        
          HRESULT STDMETHODCALLTYPE getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *value);



		HRESULT STDMETHODCALLTYPE getInfo (             
            /* [in] */		long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */		long lSize);


        HRESULT STDMETHODCALLTYPE setRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float renderstate);

        HRESULT STDMETHODCALLTYPE getRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float *renderstate);



		HRESULT STDMETHODCALLTYPE	getDeviceGuid( 
			/* [out,retval] */	BSTR *ret);


		HRESULT STDMETHODCALLTYPE createStateBlock( long flags, long *retv);

        HRESULT STDMETHODCALLTYPE setClipPlane( long index, float A, float B, float C, float D);

        HRESULT STDMETHODCALLTYPE getClipPlane( long index, float *A, float *B, float *C, float *D);


////////////////////////////////////////////////////////////////////////////////////
private:
    DECL_VARIABLE(_dxj_Direct3dDevice7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dDevice7)
	void *parent2; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3d7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.cpp
//
//--------------------------------------------------------------------------

// d3dObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "d3dEnumDevices7Obj.h"
#include "ddSurface7Obj.h"
#include "D3DEnumPixelFormats7Obj.h"
#include "d3dVertexBuffer7Obj.h"
#include "dDraw7Obj.h"

typedef HRESULT (__stdcall *DDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT D3DBSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID);


C_dxj_Direct3d7Object::C_dxj_Direct3d7Object(){
	m__dxj_Direct3d7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3d3[%d] \n ",g_creationcount);
	
	nextobj =  g_dxj_Direct3d7;
	g_dxj_Direct3d7 = (void *)this;
}


C_dxj_Direct3d7Object::~C_dxj_Direct3d7Object()
{
    C_dxj_Direct3d7Object *prev=NULL; 
	for(C_dxj_Direct3d7Object *ptr=(C_dxj_Direct3d7Object *)g_dxj_Direct3d7; ptr; ptr=(C_dxj_Direct3d7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3d7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3d7){
		int count = IUNK(m__dxj_Direct3d7)->Release();
		
		DPF1(1,"DirectX IDirect3d7 Ref count [%d] \n",count);
		

		if(count==0) m__dxj_Direct3d7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
}



DWORD C_dxj_Direct3d7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();	
	DPF2(1,"Direct3d3[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3d7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3d7 [%d] Release %d \n",creationid,i);
	return i;
}


GETSET_OBJECT(_dxj_Direct3d7);

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::findDevice(D3dFindDeviceSearch *ds, D3dFindDeviceResult7 *dr )
{
	HRESULT hr;
	
	


	//Fixup FindDeviceSearch
	ds->lSize  = sizeof(D3DFINDDEVICESEARCH);
	ds->dpcPrimCaps.lSize =sizeof(D3DPRIMCAPS);		
	ZeroMemory((LPGUID)&(ds->guidStruct),sizeof(GUID));
	hr=BSTRtoGUID((LPGUID)&(ds->guidStruct), ds->strGuid);

	//if FAILED(hr) return E_INVALIDARG;
	
	//Fixup FindDeviceResult
	memset(dr,0,sizeof(D3DFINDDEVICERESULT7));
	dr->lSize = sizeof(D3DFINDDEVICERESULT7);
	dr->ddHwDesc.lSize=sizeof(D3DDEVICEDESC7);
	dr->ddSwDesc.lSize=sizeof(D3DDEVICEDESC7);
	


	// NOTE THE TOP PORTIONS OF D3dFindDeviceSearch and D3dFindDeviceResult
	// are the same As D3DFINDEVICSEARCH and D3DFINDRESULT
	// 
	hr = m__dxj_Direct3d7->FindDevice((D3DFINDDEVICESEARCH*)ds, (D3DFINDDEVICERESULT7*)dr);

	dr->strGuid=D3DGUIDtoBSTR((LPGUID) &(dr->guidStruct));
		
	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDevicesEnum(I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr=E_FAIL;
	hr=C_dxj_Direct3DEnumDevices7Object::create(m__dxj_Direct3d7,ppRet);

	return hr;
}

//TODO tighter code produced if made into an inline function
//and use a for loop to compare byte by byte
#define GUIDISEQUAL(a,b) \
	((((DxGuid *)a)->data1==((DxGuid *)b)->data1) && \
	(((DxGuid *)a)->data2==((DxGuid *)b)->data2) && \
	(((DxGuid *)a)->data3==((DxGuid *)b)->data3) && \
	(((DxGuid *)a)->data4[0]==((DxGuid *)b)->data4[0]) && \
	(((DxGuid *)a)->data4[1]==((DxGuid *)b)->data4[1]) && \
	(((DxGuid *)a)->data4[2]==((DxGuid *)b)->data4[2]) && \
	(((DxGuid *)a)->data4[3]==((DxGuid *)b)->data4[3]) && \
	(((DxGuid *)a)->data4[4]==((DxGuid *)b)->data4[4]) && \
	(((DxGuid *)a)->data4[5]==((DxGuid *)b)->data4[5]) && \
	(((DxGuid *)a)->data4[6]==((DxGuid *)b)->data4[6]) && \
	(((DxGuid *)a)->data4[7]==((DxGuid *)b)->data4[7])) 




		
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::createDevice(BSTR strClsid, I_dxj_DirectDrawSurface7 *surf,I_dxj_Direct3dDevice7 **retv)
{
	LPDIRECT3DDEVICE7 lpNew=NULL;
	HRESULT hr;

	GUID clsid;

	hr=D3DBSTRtoGUID(&clsid,strClsid);
	if FAILED(hr) return E_INVALIDARG;

	
	//CreateDevice wants a DirectDrawSurface as opposed to 
	//a DirectDrawSurface3 . we implement as cast
	//cause DX allows us to.
	//Consider - Is the cost of a QI call really to much?
	//AK

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpSurf, surf);
	

	hr=m__dxj_Direct3d7->CreateDevice(clsid,  lpSurf,  &lpNew);

	if FAILED(hr) return hr;
 
	//INTERNAL_CREATE(_dxj_Direct3dDevice3, lpNew, retv);
	INTERNAL_CREATE_2REFS(_dxj_Direct3dDevice7,_dxj_DirectDrawSurface7,surf, lpNew,retv) 
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDirectDraw(I_dxj_DirectDraw7 **retv)
{
	IDirectDraw7 *pdd7;
	HRESULT hr;
	hr=m__dxj_Direct3d7->QueryInterface(IID_IDirectDraw7,(void**)&pdd7);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_DirectDraw7, pdd7, retv);
        
	return hr; 
}


STDMETHODIMP C_dxj_Direct3d7Object::createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f)
{
 
	LPDIRECT3DVERTEXBUFFER7 pBuff=NULL;
	HRESULT hr;
	
	if (!desc) return E_INVALIDARG;
	desc->lSize=sizeof(D3DVERTEXBUFFERDESC);

	hr=m__dxj_Direct3d7->CreateVertexBuffer((LPD3DVERTEXBUFFERDESC) desc,
				&pBuff,
				(DWORD)flags
				);

	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dVertexBuffer7, pBuff, f);


	DWORD fvf=(DWORD)desc->lFVF;
	long  n=0;

	if (fvf == D3DFVF_VERTEX)  n=sizeof(D3DVERTEX);
	else if (fvf == D3DFVF_LVERTEX)  n=sizeof(D3DLVERTEX);
	else if (fvf == D3DFVF_TLVERTEX)  n=sizeof(D3DLVERTEX);
	else 
	{
	 	if (fvf & D3DFVF_DIFFUSE ) n=n+sizeof(DWORD);
		if (fvf & D3DFVF_SPECULAR ) n=n+sizeof(DWORD);	
		if (fvf & D3DFVF_NORMAL  ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZ   ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZRHW    ) n=n+sizeof(float)*4;
		if (fvf & D3DFVF_TEX0 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX1 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX2 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX3 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX4 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX5 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX6 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX7 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX8 	    ) n=n+sizeof(float)*2;
	}

	(*f)->setVertexSize(n);

	return S_OK;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval)
{
		
	HRESULT  hr=C_dxj_Direct3DEnumPixelFormats7Object::create2(m__dxj_Direct3d7, guid, retval);
	return hr;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::evictManagedTextures( void)
{
	HRESULT hr;
	hr=m__dxj_Direct3d7->EvictManagedTextures();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3d7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.h
//
//--------------------------------------------------------------------------

// d3dObj.h : Declaration of the C_dxj_Direct3dObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3d7 LPDIRECT3D7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3d7Object : 
	public I_dxj_Direct3d7,
	//public CComCoClass<C_dxj_Direct3d7Object, &CLSID__dxj_Direct3d7>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3d7Object() ;
	virtual ~C_dxj_Direct3d7Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3d7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3d7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3d7,				"DIRECT.Direct3d.3",                "DIRECT.Direct3d7.3",				IDS_D3D_DESC,				THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3d7Object)

// I_dxj_Direct3d
public:
		 //UPDATED
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            I_dxj_DirectDrawSurface7 __RPC_FAR *surf,
            /* [retval][out] */ I_dxj_Direct3dDevice7 __RPC_FAR *__RPC_FAR *ret);
        
     //   HRESULT STDMETHODCALLTYPE createTexture( 
     //       /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
     //       /* [retval][out] */ I_dxj_Direct3dTexture7 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE evictManagedTextures( void);
        
       // HRESULT STDMETHODCALLTYPE findDevice( 
       //     /* [in] */ D3dFindDeviceSearch __RPC_FAR *ds,
       //     /* [out][in] */ D3dFindDeviceResult7 __RPC_FAR *findresult);
        
        HRESULT STDMETHODCALLTYPE getDevicesEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumDevices __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retv);       
			

private:
    DECL_VARIABLE(_dxj_Direct3d7);


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3d7 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3denumdevices7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_Direct3DEnumDevices7Object : 
	public I_dxj_Direct3DEnumDevices,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumDevices7Object() ;
	virtual ~C_dxj_Direct3DEnumDevices7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumDevices7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumDevices)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumDevices7Object)

public:
	    HRESULT STDMETHODCALLTYPE getDesc( 
            /* [in] */ long index,
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *hwDesc);
        
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);

		static HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D7,I_dxj_Direct3DEnumDevices **ppRet);
		
	
public:
		DxDriverInfo	*m_pList;
		D3DDEVICEDESC7	*m_pListHW;
		
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformats7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormats7obj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");



	
	C_dxj_Direct3DEnumPixelFormats7Object *pObj=(C_dxj_Direct3DEnumPixelFormats7Object*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_Direct3DEnumPixelFormats7Object::C_dxj_Direct3DEnumPixelFormats7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumPixelFormats7Object::~C_dxj_Direct3DEnumPixelFormats7Object()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3ddevice7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.cpp
//
//--------------------------------------------------------------------------

// d3dDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "ddSurface7Obj.h"
#include "d3dEnumPixelFormats7Obj.h"

extern BSTR D3DGUIDtoBSTR(LPGUID);


//////////////////////////////////////////////////////////////////
// C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::C_dxj_Direct3dDevice7Object(){
	m__dxj_Direct3dDevice7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;
	DPF1(1,"Constructor Creation  Direct3dDevice7[%d] \n",g_creationcount);
	

	nextobj =  g_dxj_Direct3dDevice7;
	g_dxj_Direct3dDevice7 = (void *)this;
}

//////////////////////////////////////////////////////////////////
// ~C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::~C_dxj_Direct3dDevice7Object()
{
    C_dxj_Direct3dDevice7Object *prev=NULL; 
	for(C_dxj_Direct3dDevice7Object *ptr=(C_dxj_Direct3dDevice7Object *)g_dxj_Direct3dDevice7; ptr; ptr=(C_dxj_Direct3dDevice7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dDevice7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dDevice7){
		int count = IUNK(m__dxj_Direct3dDevice7)->Release();
		
		DPF1(1, "DirectX IDirect3dDevice7 Ref count [%d] \n",count);

		if(count==0) m__dxj_Direct3dDevice7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
	if(parent2) IUNK(parent2)->Release();
	
	parent=NULL;
	parent2=NULL;
}


///////////////// /////////////////////////////////////////////////
// InternalAddRef
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dDevice7[%d] AddRef %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalRelease
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(szBuf,"Direct3dDevice7 [%d] Release %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
//////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_Direct3dDevice7);

//////////////////////////////////////////////////////////////////
// beginScene
// endScene
// setClipStatus
// setLightState
// setRenderState
// getClipStatus
// getLightState
// getRenderState
//////////////////////////////////////////////////////////////////
PASS_THROUGH_R(_dxj_Direct3dDevice7, beginScene, BeginScene);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, setClipStatus, SetClipStatus, D3dClipStatus*,(D3DCLIPSTATUS*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, getClipStatus, GetClipStatus, D3dClipStatus*, (D3DCLIPSTATUS *));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, getRenderState, GetRenderState, long ,(D3DRENDERSTATETYPE), long*,(DWORD*));

//////////////////////////////////////////////////////////////////
// endScene
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::endScene()
{

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->EndScene();


	#ifdef _X86_
		_asm FINIT
	#endif
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderTarget
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderTarget(I_dxj_DirectDrawSurface7 **ppsurf)
{	

	LPDIRECTDRAWSURFACE7	lpSurf=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetRenderTarget(&lpSurf);
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpSurf, ppsurf);
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// getTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->GetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX)m);
}

//////////////////////////////////////////////////////////////////
// multiplyTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::multiplyTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->MultiplyTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// setTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTransform(long transtype,
								D3dMatrix  *m){	
	return m__dxj_Direct3dDevice7->SetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}


//////////////////////////////////////////////////////////////////
// setRenderTarget
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderTarget(I_dxj_DirectDrawSurface7 *surf)
{		
	HRESULT hr;	
	if (!surf) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpref, surf);
	hr= m__dxj_Direct3dDevice7->SetRenderTarget(lpref,0);
	return hr;
}
		




//////////////////////////////////////////////////////////////////
// getTextureFormatsEnum
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureFormatsEnum(I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	hr=C_dxj_Direct3DEnumPixelFormats7Object::create1(m__dxj_Direct3dDevice7,ppRet);
	return hr;
}





//////////////////////////////////////////////////////////////////
// validateDevice
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes)
{
	HRESULT hr=m__dxj_Direct3dDevice7->ValidateDevice((DWORD*)passes);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getTexture
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv)
{
	LPDIRECTDRAWSURFACE7 lpNew=NULL;
	HRESULT hr;

	*retv=NULL;
	hr=m__dxj_Direct3dDevice7->GetTexture((DWORD)stage,&lpNew);
	
	//null is valid
	if (lpNew==NULL) return S_OK;

	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpNew, retv);	
	if (*retv==NULL) return E_OUTOFMEMORY;

	return hr;
}

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)retv);
	return hr;
}

//////////////////////////////////////////////////////////////////
// setTexture
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTexture( 
             long stage,
             I_dxj_DirectDrawSurface7  *tex)
{
	
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpTex, tex);	
	hr=m__dxj_Direct3dDevice7->SetTexture((DWORD)stage,lpTex);

	return hr;
}


//////////////////////////////////////////////////////////////////
// setTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getCaps
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getCaps( 
            D3dDeviceDesc7 *a)
{
	//if (a) a->lSize=sizeof(D3DDEVICEDESC7);
	

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetCaps((D3DDEVICEDESC7*)a);
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDirect3D
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDirect3D( I_dxj_Direct3d7 **ret)
{

	HRESULT hr;
	LPDIRECT3D7 lpD3D=NULL;
	hr=m__dxj_Direct3dDevice7->GetDirect3D(&lpD3D);
	if FAILED(hr) return hr;
	if (!lpD3D) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3d7,lpD3D,ret);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// setMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}



//////////////////////////////////////////////////////////////////
// setLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}


//////////////////////////////////////////////////////////////////
// beginStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::beginStateBlock()
{

	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->BeginStateBlock();		
	return hr;

}

//////////////////////////////////////////////////////////////////
// endStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::endStateBlock( long *retv)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->EndStateBlock((DWORD*)retv);		
	return hr;
}


//////////////////////////////////////////////////////////////////
// deleteStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::deleteStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->DeleteStateBlock((DWORD)m);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// ApplyStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::applyStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->ApplyStateBlock((DWORD)m);		
	return hr;
}

//////////////////////////////////////////////////////////////////
// createStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::createStateBlock(long type, long *retval)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CreateStateBlock((D3DSTATEBLOCKTYPE)type,(DWORD*)retval);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// captureStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::captureStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CaptureStateBlock((DWORD)m);		
	return hr;
}
    


//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::lightEnable( long index,  VARIANT_BOOL b){
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->LightEnable((DWORD)index,(b!=VARIANT_FALSE));
	return hr;
}

//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLightEnable( long index,  VARIANT_BOOL *bOut){
	HRESULT hr;
	BOOL	b;
	hr=m__dxj_Direct3dDevice7->GetLightEnable((DWORD)index,&b);
	if (b){
		*bOut=VARIANT_TRUE;
	}
	else {
		*bOut=VARIANT_FALSE;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// drawIndexedPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitive(
								d3dPrimitiveType  d3dpt,	
								long d3dvt,
								void *Verts,
								long vertexCount,
								SAFEARRAY **ppsaIndex,
								long indexArraySize,
								long flags){

	HRESULT hr;

	__try {
		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(unsigned short*) ((SAFEARRAY*)*ppsaIndex)->pvData,
			(DWORD)indexArraySize,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitive(
								d3dPrimitiveType  d3dpt,
								long d3dvt,								
								void* Verts,
								long vertexCount,
								long flags){
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dDevice7->DrawPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear(long count,SAFEARRAY **psa, long flags, long color, float z, long stencil )
{		 	
	if (!ISSAFEARRAY1D(psa,(DWORD)count)) return E_INVALIDARG;		
	return m__dxj_Direct3dDevice7->Clear( (DWORD)count,(D3DRECT*)((SAFEARRAY*)*psa)->pvData, flags ,color,z,stencil); 
}


//////////////////////////////////////////////////////////////////
// computeSphereVisibility
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal)
{
		HRESULT hr=m__dxj_Direct3dDevice7->ComputeSphereVisibility((LPD3DVECTOR)center,radi,1,0,(DWORD*)returnVal);
		return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
					   long startIndex,
					   long numIndex,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags)
{
	HRESULT hr;

	if (!indexArray) return E_FAIL;

	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startIndex,
			(DWORD) numIndex,
			(WORD*) ((SAFEARRAY*)*indexArray)->pvData,					
			(DWORD)indexcount,
			(DWORD)flags);

	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// drawPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,            
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags)
{
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startVertex,
			(DWORD) numVertices,
			(DWORD)flags);

	}
	__except(1,1){

		return DDERR_EXCEPTION;
	}
	return hr;
}


STDMETHODIMP C_dxj_Direct3dDevice7Object::preLoad( I_dxj_DirectDrawSurface7 *surf)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(  LPDIRECTDRAWSURFACE7 , lpSurf, surf);
	hr= m__dxj_Direct3dDevice7->PreLoad(lpSurf);
	return hr;
}



//////////////////////////////////////////////////////////////////
// load
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex1,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex2,
            /* [in] */ Rect __RPC_FAR *rc,
            /* [in] */ long flags)
{
	HRESULT hr;	
	
	if (!tex1) return E_INVALIDARG;
	if (!tex2) return E_INVALIDARG;
	if (!rc) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex1,tex1);
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex2,tex2);

	//dont allow this as it gpfs some drivers and is invalid anyway
	if (lpTex1==lpTex2) return E_INVALIDARG;

	POINT p;
	p.x=x;
	p.y=y;

	hr=m__dxj_Direct3dDevice7->Load(lpTex1,&p,lpTex2,(LPRECT)rc,(DWORD)flags);

	return hr;
}


//PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));


//////////////////////////////////////////////////////////////////
// setRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->SetRenderState((D3DRENDERSTATETYPE) renderstate, *((DWORD*)&val));
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float *val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->GetRenderState((D3DRENDERSTATETYPE) renderstate, (DWORD*)val);
	return hr;
}



//////////////////////////////////////////////////////////////////
// setTextureStageStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float val)
{
	HRESULT hr;
	 
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, *((DWORD*)&val));
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getInfo
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getInfo( 
            /* [in] */ long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */ long lSize)
{
	HRESULT hr;
	__try 
	{
		hr=m__dxj_Direct3dDevice7->GetInfo((DWORD)lDevInfoID,DevInfoType, (DWORD)lSize);
	}
	__except(1,1)
	{
		return E_FAIL;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDeviceGuid
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDeviceGuid( BSTR *ret)
{
	HRESULT hr;
	D3DDEVICEDESC7 desc;
	
	if (!ret) return E_INVALIDARG;

	//desc.dwSize=sizeof(D3DDEVICEDESC7);
		
	hr=m__dxj_Direct3dDevice7->GetCaps(&desc);
	if FAILED(hr) return hr;


	*ret=D3DGUIDtoBSTR(&desc.deviceGUID);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::setClipPlane(long index,float A, float B, float C, float D)
{
    HRESULT hr;		
    float floats[4];
    
    floats[0]=A;
    floats[1]=B;
    floats[2]=C;
    floats[3]=D;

	hr=m__dxj_Direct3dDevice7->SetClipPlane((DWORD)index, floats);

	return hr;

}

//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getClipPlane(long index,float *A, float *B, float *C, float *D)
{
    HRESULT hr;		
    float floats[4];
    
	hr=m__dxj_Direct3dDevice7->GetClipPlane((DWORD)index, floats);
    if FAILED(hr) return hr;
    
    *A=floats[0];
    *B=floats[1];
    *C=floats[2];
    *D=floats[3];

	return hr;

}


        
#if 0 
//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear( 
            /* [in] */ long l1,
            /* [in] */ D3dRect __RPC_FAR *rc,
            /* [in] */ long l2,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long l3)
{
	HRESULT hr;
	if (!rc) return E_INVALIDARG;
	__try{
		hr=m__dxj_Direct3dDevice7->Clear((DWORD)l1,(D3DRECT*)rc,(DWORD)l2,(DWORD)color,(float)z,(DWORD)l3);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}

//////////////////////////////////////////////////////////////////
// setVertexComponent
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setVertexComponent(  
  		    /* [in] */ long __RPC_FAR component,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vb,
            /* [in] */ long l1,
            /* [in] */ long l2)
{
	HRESULT hr;
	if (!vb) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVERTEXBUFFER7,pVB,vb);

	hr=m__dxj_Direct3dDevice7->SetVertexComponent((D3DVERTEXCOMPONENT)component, pVB,(DWORD)l1,(DWORD)l2);
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3denumdevices7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.cpp
//
//--------------------------------------------------------------------------

 
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumDevices7Obj.h"

extern  BSTR D3DGUIDtoBSTR(LPGUID pGuid);




/////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT PASCAL objEnumDevices7Callback(
						LPSTR DevDesc,
						LPSTR DevName, 
						LPD3DDEVICEDESC7 lpD3DDevDesc,
						void *lpArg)
{

	C_dxj_Direct3DEnumDevices7Object *pObj=(C_dxj_Direct3DEnumDevices7Object*)lpArg;
	if (pObj==NULL) return D3DENUMRET_OK;
	

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
			pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);


		if (pObj->m_pListHW)
			pObj->m_pListHW=(D3DDEVICEDESC7*)realloc(pObj->m_pListHW,sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		else
			pObj->m_pListHW=(D3DDEVICEDESC7*)malloc(sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		

	}

	//Fix for Whistler 45161
	//NOTE no way to get out of memory error back to user.
	//so we just return what we can.
	if (!pObj->m_pList) 	return D3DENUMRET_CANCEL;
	if (!pObj->m_pListHW)
	{
		free(pObj->m_pList);
		return D3DENUMRET_CANCEL;
	}
	
	
	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=D3DGUIDtoBSTR(&(lpD3DDevDesc->deviceGUID));
	
	if (DevDesc!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(DevDesc);
	}
	if (DevName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(DevName);
	}

	ZeroMemory(&(pObj->m_pListHW[pObj->m_nCount]),sizeof(D3DDEVICEDESC7));
	
	
	if (lpD3DDevDesc){
		memcpy(&(pObj->m_pListHW[pObj->m_nCount]),lpD3DDevDesc,sizeof(D3DDEVICEDESC7));
	}
	

	pObj->m_nCount++;
	
	return D3DENUMRET_OK;
}


C_dxj_Direct3DEnumDevices7Object::C_dxj_Direct3DEnumDevices7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_pListHW=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumDevices7Object::~C_dxj_Direct3DEnumDevices7Object()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D,I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumDevices7Object *pNew=NULL;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_Direct3DEnumDevices7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pD3D->EnumDevices(objEnumDevices7Callback, (void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		if (pNew->m_pListHW) free(pNew->m_pListHW);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumDevices,(void**)ppRet);
	return hr;
}


        
HRESULT C_dxj_Direct3DEnumDevices7Object::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_Direct3DEnumDevices7Object::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        

HRESULT C_dxj_Direct3DEnumDevices7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getDesc(long index, D3dDeviceDesc7 *desc)
{
	if (m_pListHW==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(desc,&(m_pListHW[index-1]),sizeof(D3dDeviceDesc7));
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformats7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_Direct3DEnumPixelFormats7Object : 
	public I_dxj_Direct3DEnumPixelFormats,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumPixelFormats7Object() ;
	virtual ~C_dxj_Direct3DEnumPixelFormats7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumPixelFormats7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumPixelFormats7Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformatsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormatsobj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");

	
	C_dxj_D3DEnumPixelFormatsObject *pObj=(C_dxj_D3DEnumPixelFormatsObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_D3DEnumPixelFormatsObject::C_dxj_D3DEnumPixelFormatsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_D3DEnumPixelFormatsObject::~C_dxj_D3DEnumPixelFormatsObject()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}



#if 0
HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}
#endif


HRESULT C_dxj_D3DEnumPixelFormatsObject::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_D3DEnumPixelFormatsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drm3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drm3obj.h
//
//--------------------------------------------------------------------------

// d3drmObj.h : Declaration of the C_dxj_Direct3dRMObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRM3 LPDIRECT3DRM3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRM3Object : 
	public I_dxj_Direct3dRM3,
	public CComObjectRoot
//	public CComCoClass<C_dxj_Direct3dRM3Object, &CLSID__dxj_Direct3dRM3>, public CComObjectRoot
{
public:
	void doCreateObj();
	void doDeleteObj();

	C_dxj_Direct3dRM3Object();
	virtual ~C_dxj_Direct3dRM3Object();

BEGIN_COM_MAP(C_dxj_Direct3dRM3Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRM3)
END_COM_MAP()


DECLARE_AGGREGATABLE(C_dxj_Direct3dRM3Object)

// I_dxj_Direct3dRM
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE createDeviceFromClipper( 
            /* [in] */ I_dxj_DirectDrawClipper __RPC_FAR *lpDDClipper,
            /* [in] */ BSTR guid,
            /* [in] */ int width,
            /* [in] */ int height,
            /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *parent,
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createLightRGB( 
            /* [in] */ d3drmLightType lt,
            /* [in] */ float vred,
            /* [in] */ float vgreen,
            /* [in] */ float vblue,
            /* [retval][out] */ I_dxj_Direct3dRMLight __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createLight( 
            /* [in] */ d3drmLightType lt,
            /* [in] */ long color,
            /* [retval][out] */ I_dxj_Direct3dRMLight __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createMeshBuilder( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createMaterial( 
            /* [in] */ float d,
            /* [retval][out] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE loadTexture( 
            /* [in] */ BSTR name,
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE createViewport( 
            /* [in] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *dev,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *fr,
            /* [in] */ long l,
            /* [in] */ long t,
            /* [in] */ long w,
            /* [in] */ long h,
            /* [retval][out] */ I_dxj_Direct3dRMViewport2 __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE setDefaultTextureColors( 
            /* [in] */ long ds);
        
         HRESULT STDMETHODCALLTYPE setDefaultTextureShades( 
            /* [in] */ long ds);
        
         HRESULT STDMETHODCALLTYPE createAnimationSet( 
            /* [retval][out] */ I_dxj_Direct3dRMAnimationSet2 __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createFace( 
            /* [retval][out] */ I_dxj_Direct3dRMFace2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createAnimation( 
            /* [retval][out] */ I_dxj_Direct3dRMAnimation2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE tick( 
            /* [in] */ float tic);
        
         
       //  HRESULT STDMETHODCALLTYPE createDevice( 
       //     /* [in] */ long v1,
       //     /* [in] */ long v2,
       //     /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createDeviceFromSurface( 
            /* [in] */ BSTR g,
            /* [in] */ I_dxj_DirectDraw4 __RPC_FAR *dd,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
			/* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *retval);
        
        //HRESULT STDMETHODCALLTYPE createDeviceFromD3D( 
        //    /* [in] */ I_dxj_Direct3d3 __RPC_FAR *D3D,
        //    /* [in] */ I_dxj_Direct3dDevice3 __RPC_FAR *dev,
        //    /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createTextureFromSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createWrap( 
            /* [in] */ d3drmWrapType t,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f,
            /* [in] */ float ox,
            /* [in] */ float oy,
            /* [in] */ float oz,
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz,
            /* [in] */ float ou,
            /* [in] */ float ov,
            /* [in] */ float su,
            /* [in] */ float sv,
            /* [retval][out] */ I_dxj_Direct3dRMWrap __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSearchPath( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getDevices( 
            /* [retval][out] */ I_dxj_Direct3dRMDeviceArray __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getNamedObject( 
            /* [in] */ BSTR name,
            /* [retval][out] */ I_dxj_Direct3dRMObject __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE setSearchPath( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE addSearchPath( 
            /* [in] */ BSTR name);
        
//         HRESULT STDMETHODCALLTYPE createUserVisual( 
//            /* [in] */ I_dxj_Direct3dRMUserVisualCallback __RPC_FAR *fn,
//            /* [in] */ IUnknown __RPC_FAR *arg,
//            /* [retval][out] */ I_dxj_Direct3dRMUserVisual __RPC_FAR *__RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE enumerateObjects( 
            /* [in] */ I_dxj_Direct3dRMEnumerateObjectsCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *pargs);
        

         HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *guidArray,
            /* [in] */ long cnt,
            /* [in] */ d3drmLoadFlags options,
            /* [in] */ I_dxj_Direct3dRMLoadCallback __RPC_FAR *fn1,
            /* [in] */ IUnknown __RPC_FAR *arg1,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *fn2,
            /* [in] */ IUnknown __RPC_FAR *arg2,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE createShadow( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *visual,
            /* [in] */ I_dxj_Direct3dRMLight __RPC_FAR *light,
            /* [in] */ float px,
            /* [in] */ float py,
            /* [in] */ float pz,
            /* [in] */ float nx,
            /* [in] */ float ny,
            /* [in] */ float nz,
            /* [retval][out] */ I_dxj_Direct3dRMShadow2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createProgressiveMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMProgressiveMesh __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createClippedVisual( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *vis,
            /* [retval][out] */ I_dxj_Direct3dRMClippedVisual __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getOptions( 
            /* [retval][out] */ long __RPC_FAR *options);
        
         HRESULT STDMETHODCALLTYPE setOptions( 
            /* [in] */ long options);

//         HRESULT STDMETHODCALLTYPE createInterpolator( 
//            /* [retval][out] */ I_dxj_Direct3dRMInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTextureInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorMaterial( 
            /* [retval][out] */ I_dxj_Direct3dRMMaterialInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorFrame( 
            /* [retval][out] */ I_dxj_Direct3dRMFrameInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorViewport( 
            /* [retval][out] */ I_dxj_Direct3dRMViewportInterpolator __RPC_FAR *__RPC_FAR *retv);

         HRESULT STDMETHODCALLTYPE createInterpolatorLight( 
            /* [retval][out] */ I_dxj_Direct3dRMLightInterpolator __RPC_FAR *__RPC_FAR *retv);

////////////////////////////////////////////////////////////////////////////////////


	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRM3);

private:
	HINSTANCE hinstLib;


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRM3)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drm3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drm3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drm3Obj.h"

#include "d3drmDeviceArrayObj.h"
#include "d3drmLightObj.h"
#include "d3drmMeshObj.h"
#include "d3drmWrapObj.h"
#include "d3drmVisualObj.h"
#include "d3drmUserVisualObj.h"
#include "d3drmClippedVisualObj.h"
#include "d3drmDevice3Obj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmViewport2Obj.h"
#include "d3drmAnimationSet2Obj.h"
#include "d3drmFace2Obj.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmProgressiveMeshObj.h"

#include "d3drmFrameInterObj.h"
#include "d3drmLightInterObj.h"
#include "d3drmViewportInterObj.h"
#include "d3drmTextureInterObj.h"
#include "d3drmMaterialInterObj.h"
#include "d3drmMeshInterObj.h"

#include "ddSurface7Obj.h"

extern void *g_dxj_Direct3dRMMeshInterpolator;
extern void *g_dxj_Direct3dRMViewportInterpolator;
extern void *g_dxj_Direct3dRMLightInterpolator;
extern void *g_dxj_Direct3dRMFrameInterpolator;
extern void *g_dxj_Direct3dRMMaterialInterpolator;
extern void *g_dxj_Direct3dRMTextureInterpolator;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

#define DO_GETOBJECT_NOTNULL_VISUAL_ADDREF(v,i) LPDIRECT3DRMVISUAL v=NULL; \
	{ IUnknown *pIUnk=NULL; \
	if(i) i->InternalGetObject((IUnknown **)&pIUnk); \
	if (pIUnk) pIUnk->QueryInterface(IID_IDirect3DRMVisual,(void**)&v); \
	}

extern BOOL is4Bit;
extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR); 
extern HRESULT BSTRtoGUID(LPGUID,BSTR); 
extern HRESULT D3DBSTRtoGUID(LPGUID,BSTR); 
			

C_dxj_Direct3dRM3Object::C_dxj_Direct3dRM3Object(){
	m__dxj_Direct3dRM3=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRM2[%d] \n ",g_creationcount);
	nextobj =  g_dxj_Direct3dRM3;
	g_dxj_Direct3dRM3 = (void *)this;
}




C_dxj_Direct3dRM3Object::~C_dxj_Direct3dRM3Object(){

	DPF1(1,"Destructor  Direct3dRM2 [%d] \n",creationid); 
	
	C_dxj_Direct3dRM3Object *prev=NULL; 

	for(C_dxj_Direct3dRM3Object *ptr=(C_dxj_Direct3dRM3Object *)g_dxj_Direct3dRM3;
		ptr;
		ptr=(C_dxj_Direct3dRM3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRM3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRM3){ 
		int count = IUNK(m__dxj_Direct3dRM3)->Release(); 
		DPF1(1,"DirectX real IDirect3dRM2 Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRM3 = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
}


#if 0

DWORD C_dxj_Direct3dRM3Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"D3DRM3 [%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRM3Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();

	DPF1(1,"D3DRM2 [%d] Release %d \n",creationid,i);
	return i;
}

#endif

	GETSET_OBJECT(_dxj_Direct3dRM3);

	PASS_THROUGH1_R(_dxj_Direct3dRM3, setDefaultTextureColors, SetDefaultTextureColors, long)
	PASS_THROUGH1_R(_dxj_Direct3dRM3, setDefaultTextureShades, SetDefaultTextureShades, long)
	PASS_THROUGH1_R(_dxj_Direct3dRM3, tick, Tick, d3dvalue);
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createAnimationSet, CreateAnimationSet, _dxj_Direct3dRMAnimationSet2) ;
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createMesh, CreateMesh, _dxj_Direct3dRMMesh);
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createFace, CreateFace, _dxj_Direct3dRMFace2);

	//TODO - do we need a new type of device array
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createAnimation, CreateAnimation, _dxj_Direct3dRMAnimation2);
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, createMeshBuilder, CreateMeshBuilder, _dxj_Direct3dRMMeshBuilder3);
	RETURN_NEW_ITEM1_R(_dxj_Direct3dRM3,createMaterial,CreateMaterial,_dxj_Direct3dRMMaterial2,d3dvalue);
	RETURN_NEW_ITEM_CAST_2_R(_dxj_Direct3dRM3, createLight,CreateLight,_dxj_Direct3dRMLight, d3drmLightType, (enum _D3DRMLIGHTTYPE), d3dcolor, (d3dcolor));




	//TOEXPAND
	RETURN_NEW_ITEM_R(_dxj_Direct3dRM3, getDevices, GetDevices, _dxj_Direct3dRMDeviceArray);	



STDMETHODIMP C_dxj_Direct3dRM3Object::createTextureFromSurface(I_dxj_DirectDrawSurface4 *dds, I_dxj_Direct3dRMTexture3 **retval)
{
	HRESULT hretval;
	LPDIRECT3DRMTEXTURE3 lpTex;
	LPDIRECTDRAWSURFACE lpDDS=NULL;
	if ( is4Bit )
		return E_FAIL;

	if ( dds == NULL )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpDDS4, dds);
	hretval= lpDDS4->QueryInterface(IID_IDirectDrawSurface,(void**)&lpDDS);
	if FAILED(hretval) return hretval;
	

	hretval = m__dxj_Direct3dRM3->CreateTextureFromSurface(lpDDS, &lpTex);
	if (lpDDS) lpDDS->Release();
	if FAILED(hretval) 	return hretval;
	

	INTERNAL_CREATE(_dxj_Direct3dRMTexture3, lpTex, retval);
	return S_OK;
}

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createDeviceFromD3D(I_dxj_Direct3d3 *d3d, I_dxj_Direct3dDevice3* d3dDev, I_dxj_Direct3dRMDevice3 **retval)
{
	HRESULT hretval;
	LPDIRECT3DRMDEVICE3 lpDev;
	LPDIRECT3D2 lpD3D2;
	LPDIRECT3DDEVICE2 lpD3DDev2;

	if ( is4Bit )
		return E_FAIL;

	if ( d3d == NULL || d3dDev == NULL )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECT3D3, lpD3D3, d3d);
	DO_GETOBJECT_NOTNULL(LPDIRECT3DDEVICE3, lpD3DDev3, d3dDev);
	
	hretval=lpD3D3->QueryInterface(IID_IDirect3D2,(void**)&lpD3D2);
	if FAILED(hretval) return hretval;

	hretval=lpD3DDev3->QueryInterface(IID_IDirect3DDevice2,(void**)&lpD3DDev2);
	if FAILED(hretval) return hretval;


	hretval = m__dxj_Direct3dRM3->CreateDeviceFromD3D(lpD3D2, lpD3DDev2, &lpDev);
	
	lpD3DDev2->Release();
	lpD3D2->Release();

	if FAILED(hretval)	return hretval;			
		

	//we need to parent the dev to the d3ddevice object.

	//INTERNAL_CREATE(_dxj_Direct3dRMDevice3, lpDev, retval);
	INTERNAL_CREATE_1REFS(_dxj_Direct3dRMDevice3, _dxj_Direct3dDevice3, d3dDev,lpDev, retval);
	
	return S_OK;
}

#endif 
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createDeviceFromSurface(BSTR guid, I_dxj_DirectDraw4 *dd,  I_dxj_DirectDrawSurface4 *dds,long flags,I_dxj_Direct3dRMDevice3 **retval)
{
	HRESULT hretval;
	LPDIRECT3DRMDEVICE3 lpDev=NULL;
	
	LPDIRECTDRAW lpDD=NULL;
	LPDIRECTDRAWSURFACE lpDDS=NULL;
	GUID	g;
	LPGUID pg=&g;
	
	#pragma message ("need new device to be parented to the surface?")

	ZeroMemory(&g,sizeof(GUID));
	
	if ((!guid)||(guid[0]==0)){
		pg=NULL;
	}
	else {
		hretval=D3DBSTRtoGUID(&g,guid);
		if FAILED(hretval) return E_INVALIDARG;
	}

	
	if ( dd == NULL || dds == NULL )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAW4, lpDD4, dd);
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpDDS4, dds);

	if (!lpDD4) return E_INVALIDARG;
	if (!lpDDS4) return E_INVALIDARG;


	hretval = lpDD4->QueryInterface(IID_IDirectDraw,(void**)&lpDD);
	if FAILED(hretval)	return hretval;

	hretval = lpDDS4->QueryInterface(IID_IDirectDrawSurface,(void**)&lpDDS);
	if FAILED(hretval)	return hretval;

	hretval = m__dxj_Direct3dRM3->CreateDeviceFromSurface( pg, lpDD, lpDDS, (DWORD) flags, &lpDev);

	lpDD->Release();
	lpDDS->Release();

	if FAILED(hretval)	return hretval;

	INTERNAL_CREATE(_dxj_Direct3dRMDevice3, lpDev, retval);
	return S_OK;
}




//////////////////////////////////////////////////////////////////////////
// A call to EnumerateObjects envokes the user's callback for each 
// d3drmObject object in the list. In addition all enumerate calls will
// generate their full complement of enumerations. Hence there are 2 
// lists: a) the list of objects, b) the list of enumeration calls.
STDMETHODIMP C_dxj_Direct3dRM3Object::enumerateObjects( 
					  I_dxj_Direct3dRMEnumerateObjectsCallback *enumC, IUnknown *args)
{
	EnumerateObjectsCallback *enumcb; 

	if ( is4Bit )
		return E_FAIL;

	enumcb = (EnumerateObjectsCallback*)AddCallbackLink((void**)&EnumCallbacks,
										(I_dxj_Direct3dRMCallback*)enumC, (void*) args);
	if( !enumcb )	{

		DPF(1,"Callback EnumerateObjects creation failed!\r\n");

		return E_FAIL;
	} 
	m__dxj_Direct3dRM3->EnumerateObjects(myEnumerateObjectsCallback, enumcb);

	// Remove ourselves in a thread-safe manner.
	UndoCallbackLink((GeneralCallback*)enumcb, 
										(GeneralCallback**)&EnumCallbacks);
	return S_OK;
}
	
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::loadFromFile(BSTR filename, VARIANT  id, 
	SAFEARRAY **psa, long cnt, d3drmLoadFlags options, I_dxj_Direct3dRMLoadCallback *fn1, 
		IUnknown *arg1, I_dxj_Direct3dRMLoadTextureCallback3 *fn2, IUnknown *arg2, I_dxj_Direct3dRMFrame3 *f)
{
	HRESULT	hr;	
	GUID aGuids[100];
	int i=0;

	ZeroMemory(&(aGuids[0]),sizeof(GUID)*100);

	//check args
	if (cnt>100) return E_INVALIDARG;
	if (cnt<0) return E_INVALIDARG;
	if (!ISSAFEARRAY1D(psa,(DWORD)cnt)) return E_FAIL;
	
	
	for (i =0;i<cnt;i++)
	{
		hr=BSTRtoGUID(&(aGuids[i]),((BSTR*)((SAFEARRAY *)*psa)->pvData)[i]);
		if FAILED(hr) return hr;
	}


	TextureCallback3 *tcb = NULL;
	LoadCallback    *lcb = NULL;
	

	if ( is4Bit )
		return E_FAIL;


	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	D3DRMLOADCALLBACK		 d3dlcb = NULL;
	LPVOID pArgs1 = NULL;
	LPVOID pArgs2 = NULL;

	if (arg1) arg1->AddRef();
	if (arg2) arg2->AddRef();

	if( fn2 ) {
		if ((tcb = (TextureCallback3*)AddCallbackLink((void**)&TextureCallbacks3,
											(I_dxj_Direct3dRMCallback*)fn2, (void*) arg2)) == NULL) {
			
			DPF(1,"Callback object creation failed!\r\n");


			if (arg1) arg1->Release();
			if (arg2) arg2->Release();

			return E_FAIL;
		}
		d3dtcb = myLoadTextureCallback3;
		pArgs1 = (void *)tcb;
	}
	if( fn1 ) {
		if ((lcb = (LoadCallback*)AddCallbackLink((void**)&LoadCallbacks,
											(I_dxj_Direct3dRMCallback*)fn1, (void*) arg1)) == NULL) {
			DPF(1,"Callback object creation failed!\r\n");


			if (arg1) arg1->Release();
			if (arg2) arg2->Release();

			return E_FAIL;
		}
		d3dlcb = myd3drmLoadCallback;
		pArgs2 = (void *)lcb;
	}
	USES_CONVERSION;
	LPSTR pszNam = W2T(filename);				// Now convert to ANSI
	LPDIRECT3DRMFRAME3 lpff = NULL;
	if(f)
	{
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpF, f);
		lpff = lpF;
	}


	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((options & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & options)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		args=(void*)W2T(V_BSTR(&id));
	}
	else if(options & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(options & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);

	if (options &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszNam;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRM3->Load(&res,(void*) args, (LPGUID*)aGuids, (DWORD)cnt, (DWORD)options, 
									d3dlcb, pArgs2, d3dtcb, pArgs1, lpff);

	}
	else {
		hr = m__dxj_Direct3dRM3->Load(pszNam,(void*) args, (LPGUID*)aGuids, (DWORD)cnt, (DWORD)options, 
									d3dlcb, pArgs2, d3dtcb, pArgs1, lpff);
	}

	// Remove ourselves in a thread-safe manner.
	if (tcb)	UndoCallbackLink((GeneralCallback*)tcb, (GeneralCallback**)&TextureCallbacks3);
	if (lcb)	UndoCallbackLink((GeneralCallback*)lcb, (GeneralCallback**)&LoadCallbacks);

	if (arg1) arg1->Release();
	if (arg2) arg2->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::getSearchPath(BSTR *Name)
{	
	DWORD cnt = 0;

	if ( is4Bit )
		return E_FAIL;

	if((m__dxj_Direct3dRM3->GetSearchPath(&cnt,(char*)NULL)) != D3DRM_OK) // size
		return E_FAIL;

	LPSTR str = (LPSTR)alloca(cnt);		// ANSI buffer on stack;

	if((m__dxj_Direct3dRM3->GetSearchPath(&cnt, str)) != D3DRM_OK)	return E_FAIL;

	PassBackUnicode(str, Name, cnt);
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::getNamedObject(BSTR Name, I_dxj_Direct3dRMObject **f)
{
	LPDIRECT3DRMOBJECT lp;				// DirectX object pointer
    HRESULT             hr;
	
    if (!f) return E_INVALIDARG;

	*f=NULL;
	
	USES_CONVERSION;
	LPCTSTR pszName = W2T(Name);		// Now convert to ANSI

	hr=m__dxj_Direct3dRM3->GetNamedObject(pszName,&lp);
    if FAILED(hr) return hr;		
	if (lp==NULL) return S_OK;	
    
    hr=CreateCoverObject(lp,f);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::setSearchPath(BSTR Name)
{


	USES_CONVERSION;
	LPCTSTR pszName = W2T(Name);				// Now convert to ANSI
	if((m__dxj_Direct3dRM3->SetSearchPath(pszName)) != D3DRM_OK)	return E_FAIL;
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::addSearchPath(BSTR Name)
{

	USES_CONVERSION;
	LPCTSTR pszName = W2T(Name);				// Now convert to ANSI
	if((m__dxj_Direct3dRM3->AddSearchPath(pszName)) != D3DRM_OK) 	return E_FAIL;
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createWrap(d3drmWrapType type, I_dxj_Direct3dRMFrame3 *fr, 
										d3dvalue ox, d3dvalue oy, d3dvalue oz, 
										d3dvalue dx, d3dvalue dy, d3dvalue dz,
										d3dvalue ux, d3dvalue uy, d3dvalue uz, 
										d3dvalue ou, d3dvalue ov, 
										d3dvalue su, d3dvalue sv,I_dxj_Direct3dRMWrap **retv)
{
	LPDIRECT3DRMWRAP lp;

	if ( is4Bit )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpF, fr);

	if ((m__dxj_Direct3dRM3->CreateWrap((enum _D3DRMWRAPTYPE)type, lpF, ox, oy, oz,
					dx, dy, dz, ux, uy, uz,ou, ov, su, sv, &lp)) != S_OK)
	{
		*retv = NULL;
		return E_FAIL;
	}

	INTERNAL_CREATE(_dxj_Direct3dRMWrap, lp, retv);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createShadow(I_dxj_Direct3dRMVisual *visual, 
			I_dxj_Direct3dRMLight *light,
			d3dvalue px, d3dvalue py, d3dvalue pz, 
			d3dvalue nx, d3dvalue ny, d3dvalue nz,
			I_dxj_Direct3dRMShadow2 **retv)
{
	LPDIRECT3DRMSHADOW2 lp;
	HRESULT hr;


	DO_GETOBJECT_NOTNULL_VISUAL_ADDREF(lpV, visual);
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMLIGHT, lpL, light);

	

	hr=m__dxj_Direct3dRM3->CreateShadow(lpV, lpL,
		px, py, pz,	nx, ny, nz,&lp);
	if (lpV) IUNK(lpV)->Release();
	
	if (FAILED(hr))
	{
		*retv = NULL;		
		return hr;
	}

	INTERNAL_CREATE(_dxj_Direct3dRMShadow2, lp, retv);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createViewport(I_dxj_Direct3dRMDevice3 *dev, I_dxj_Direct3dRMFrame3 *fr,
						long l,long t,long w,long h,I_dxj_Direct3dRMViewport2 **retval)
{
	LPDIRECT3DRMVIEWPORT2 lp;
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMDEVICE3, lpD, dev);
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpF, fr);

	hr = m__dxj_Direct3dRM3->CreateViewport(lpD, lpF, l, t, w, h, &lp);
	if( hr != S_OK )
		return hr;

	//INTERNAL_CREATE(_dxj_Direct3dRMViewport2, lp, retval);
	C_dxj_Direct3dRMViewport2Object *c=new CComObject<C_dxj_Direct3dRMViewport2Object>;
	if( c == NULL ) 
	{ 
		lp->Release(); 
		return E_FAIL;
	} 
	c->parent = dev;
	dev->AddRef(); 
	c->InternalSetObject(lp);
	if (FAILED(IUNK(c)->QueryInterface(IID_I_dxj_Direct3dRMViewport2, (void **)retval))) 
		return E_FAIL; 
	c->pinterface = *retval; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// real important that the return value is set correctly regardless, callbacks
// use this!
//
STDMETHODIMP C_dxj_Direct3dRM3Object::loadTexture(BSTR name, I_dxj_Direct3dRMTexture3 **retval)
{
	LPDIRECT3DRMTEXTURE3 lpT;

	USES_CONVERSION;
	LPCTSTR pszName = W2T(name);				// Now convert to ANSI

	if( m__dxj_Direct3dRM3->LoadTexture(pszName, &lpT ) != S_OK )
	{
		*retval = NULL;
		return S_OK;	// Reture ok so that we don't thro execeptionn if it fails 
	}

	INTERNAL_CREATE(_dxj_Direct3dRMTexture3, lpT, retval);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createDeviceFromClipper(I_dxj_DirectDrawClipper *lpDDClipper, BSTR strGuid, int width, int height, I_dxj_Direct3dRMDevice3 **retv)
{
	LPDIRECT3DRMDEVICE3 lpd3drmDev;
	GUID g;
	LPGUID pguid=NULL;
	HRESULT hr;

	//hr =BSTRtoPPGUID(&pguid,strGuid);
	if ((strGuid) && (strGuid[0]!=0)){
		hr=D3DBSTRtoGUID(&g,strGuid);
		if FAILED(hr) return hr;
		pguid=&g;
	}

	if ( is4Bit )
		return E_FAIL;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWCLIPPER, lpddc, lpDDClipper);


	if( m__dxj_Direct3dRM3->CreateDeviceFromClipper(lpddc, (LPGUID)pguid, width, height, &lpd3drmDev) != DD_OK)
		return E_FAIL;

	INTERNAL_CREATE_2REFS(_dxj_Direct3dRMDevice3, _dxj_DirectDrawClipper, lpDDClipper, lpd3drmDev, retv);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createFrame(I_dxj_Direct3dRMFrame3 *parent,I_dxj_Direct3dRMFrame3 **retv)
{
	LPDIRECT3DRMFRAME3 lpFrame;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, lpFrameParent, parent)

	if( m__dxj_Direct3dRM3->CreateFrame(lpFrameParent, &lpFrame) != DD_OK )
		return E_FAIL;

	INTERNAL_CREATE(_dxj_Direct3dRMFrame3, lpFrame, retv);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createLightRGB(d3drmLightType lt, d3dvalue vred,
								d3dvalue vgreen,d3dvalue vblue,I_dxj_Direct3dRMLight **retv)
{
	LPDIRECT3DRMLIGHT lpNew;

	if ( is4Bit )
		return E_FAIL;

	if( m__dxj_Direct3dRM3->CreateLightRGB((enum _D3DRMLIGHTTYPE)lt, vred, vgreen, vblue, &lpNew) != DD_OK )
		return E_FAIL;

	INTERNAL_CREATE(_dxj_Direct3dRMLight, lpNew, retv);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::setOptions(long opt){
	return m__dxj_Direct3dRM3->SetOptions((DWORD)opt);

}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRM3Object::getOptions(long *opt){
	return m__dxj_Direct3dRM3->GetOptions((DWORD*)opt);

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createClippedVisual(I_dxj_Direct3dRMVisual *vis, I_dxj_Direct3dRMClippedVisual**clipvis)
{
	//LPDIRECT3DRMVISUAL lpVisual=NULL;
	LPDIRECT3DRMCLIPPEDVISUAL lpClippedVisual=NULL;
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMVISUAL, lpVisual, vis)

	hr=m__dxj_Direct3dRM3->CreateClippedVisual(lpVisual,&lpClippedVisual);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMClippedVisual, lpClippedVisual, clipvis);

	return hr;
}
 
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRM3Object::createProgressiveMesh( I_dxj_Direct3dRMProgressiveMesh **retv)
{
	LPDIRECT3DRMPROGRESSIVEMESH lpPMesh=NULL;


	if( m__dxj_Direct3dRM3->CreateProgressiveMesh(&lpPMesh) != DD_OK )
		return E_FAIL;

	INTERNAL_CREATE(_dxj_Direct3dRMProgressiveMesh, lpPMesh, retv);

	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolator( 
//            /* [retval][out] */ I_dxj_Direct3dRMInterpolator __RPC_FAR *__RPC_FAR *retv)
//{
//	return E_NOTIMPL;
//}

STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMMeshInterpolator, 0, IID_IDirect3DRMInterpolator,(void**) &lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMMeshInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTextureInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMTextureInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMTextureInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorMaterial( 
            /* [retval][out] */ I_dxj_Direct3dRMMaterialInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMMaterialInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMMaterialInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorFrame( 
            /* [retval][out] */ I_dxj_Direct3dRMFrameInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMFrameInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMFrameInterpolator, lpInterpolator, retv);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorViewport( 
            /* [retval][out] */ I_dxj_Direct3dRMViewportInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMViewportInterpolator, 0, IID_IDirect3DRMInterpolator,(void**) &lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMViewportInterpolator, lpInterpolator, retv);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRM3Object::createInterpolatorLight( 
            /* [retval][out] */ I_dxj_Direct3dRMLightInterpolator __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMINTERPOLATOR lpInterpolator=NULL;
	hr=m__dxj_Direct3dRM3->CreateObject(CLSID_CDirect3DRMLightInterpolator, 0, IID_IDirect3DRMInterpolator, (void**)&lpInterpolator);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMLightInterpolator, lpInterpolator, retv);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmanimation2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimation2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmAnimationObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmFrame3Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMAnimation2, {});
DESTRUCTOR(_dxj_Direct3dRMAnimation2, {});
GETSET_OBJECT(_dxj_Direct3dRMAnimation2);

CLONE_R(_dxj_Direct3dRMAnimation2,,Direct3DRMAnimation2);
SETNAME_R(_dxj_Direct3dRMAnimation2);
GETNAME_R(_dxj_Direct3dRMAnimation2);
GETCLASSNAME_R(_dxj_Direct3dRMAnimation2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMAnimation2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMAnimation2);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMAnimation2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMAnimation2, setOptions, SetOptions, d3drmAnimationOptions,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMAnimation2, deleteKey, DeleteKey,  d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMAnimation2, setTime, SetTime, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMAnimation2, addPositionKey, AddPositionKey, d3dvalue, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMAnimation2, addScaleKey, AddScaleKey, d3dvalue, d3dvalue, d3dvalue, d3dvalue);

GET_DIRECT_R(_dxj_Direct3dRMAnimation2, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMAnimation2, getOptions, GetOptions, long);



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::addRotateKey(D3DVALUE rvtime, D3dRMQuaternion *rqQuat)
{
	return m__dxj_Direct3dRMAnimation2->AddRotateKey(rvtime,(_D3DRMQUATERNION*) rqQuat);
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::setFrame(I_dxj_Direct3dRMFrame3 *frame)
{
	IDirect3DRMFrame3 *realframe=NULL;

	frame->InternalGetObject((IUnknown**) &realframe);
	
	return m__dxj_Direct3dRMAnimation2->SetFrame(realframe);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::getFrame(I_dxj_Direct3dRMFrame3 **frame)
{
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
    *frame=NULL;		
	hr=m__dxj_Direct3dRMAnimation2->GetFrame((IDirect3DRMFrame3**)&realframe);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMFrame3,realframe,frame);
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::addKey(D3DRMANIMATIONKEY_CDESC *key)
{
	HRESULT hr;
	LPD3DRMANIMATIONKEY pKey=(LPD3DRMANIMATIONKEY)key;
	D3DRMANIMATIONKEY realkey;
	pKey->dwSize=sizeof(D3DRMANIMATIONKEY);
	if (!key) return E_INVALIDARG;

	if (pKey->dwKeyType==D3DRMANIMATION_ROTATEKEY )
	{
		realkey.dwSize=sizeof(D3DRMANIMATIONKEY);
		realkey.dwKeyType=D3DRMANIMATION_ROTATEKEY;
		realkey.dvTime=pKey->dvTime;
		realkey.dqRotateKey.v.x=key->dvX;
		realkey.dqRotateKey.v.y=key->dvY;
		realkey.dqRotateKey.v.z=key->dvZ;
		realkey.dqRotateKey.s=key->dvS;
		hr= m__dxj_Direct3dRMAnimation2->AddKey(&realkey);
		key->lID = realkey.dwID;
	}
	else {
		hr= m__dxj_Direct3dRMAnimation2->AddKey((LPD3DRMANIMATIONKEY)key);
	}
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::deleteKeyById(long id)
{		
	return m__dxj_Direct3dRMAnimation2->DeleteKeyByID((DWORD)id);
}

STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::getKeys( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *keyArray) 
{
	
	
	DWORD nKeys;
	HRESULT hr;

	//if (!ISSAFEARRAY1D(keyArray,count)) return E_INVALIDARG;
	if (!keyArray) return E_INVALIDARG;

	nKeys= (*keyArray)->cbElements;

	hr=m__dxj_Direct3dRMAnimation2->GetKeys(timeMin,timeMax,&nKeys,(D3DRMANIMATIONKEY*)((SAFEARRAY*)*keyArray)->pvData);
	if FAILED(hr) return hr;

	for (DWORD i=0;i<nKeys;i++)
	{
		D3DRMANIMATIONKEY_CDESC *pKey=&((D3DRMANIMATIONKEY_CDESC*)((SAFEARRAY*)*keyArray)->pvData)[i];
		if (pKey->lKeyType==D3DRMANIMATION_ROTATEKEY)
		{
			D3DRMANIMATIONKEY realkey;
			memcpy(&realkey,pKey,sizeof(D3DRMANIMATIONKEY));
						
			pKey->dvX=realkey.dqRotateKey.v.x;
			pKey->dvY=realkey.dqRotateKey.v.y;
			pKey->dvZ=realkey.dqRotateKey.v.z;
			pKey->dvS=realkey.dqRotateKey.s;		
		}
	}

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::getKeysCount( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,
            /* [out,retval]*/ long *count)            
{
	
	HRESULT hr;
	hr=m__dxj_Direct3dRMAnimation2->GetKeys(timeMin,timeMax,(DWORD*)count,NULL);
	return hr;
}
        



STDMETHODIMP C_dxj_Direct3dRMAnimation2Object::modifyKey(D3DRMANIMATIONKEY_CDESC *key)
{
		
	return m__dxj_Direct3dRMAnimation2->ModifyKey((LPD3DRMANIMATIONKEY)key);
}
        
        



DWORD C_dxj_Direct3dRMAnimation2Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();	
	DPF2(1,"Direct3dRMAnimation2[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMAnimation2Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMAnimation2 [%d] Release %d \n",creationid,i);
	return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3denumpixelformatsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_D3DEnumPixelFormatsObject : 
	public I_dxj_Direct3DEnumPixelFormats7,
	public CComObjectRoot
{
public:
	C_dxj_D3DEnumPixelFormatsObject() ;
	virtual ~C_dxj_D3DEnumPixelFormatsObject() ;

BEGIN_COM_MAP(C_dxj_D3DEnumPixelFormatsObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats7)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_D3DEnumPixelFormatsObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmanimation2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimation2obj.h
//
//--------------------------------------------------------------------------

// d3drmAnimationObj.h : Declaration of the C_dxj_Direct3dRMAnimationObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMAnimation2 LPDIRECT3DRMANIMATION2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMAnimation2Object : 
	public I_dxj_Direct3dRMAnimation2,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMAnimation2Object() ;
	~C_dxj_Direct3dRMAnimation2Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMAnimation2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMAnimation2)
	END_COM_MAP()


DECLARE_AGGREGATABLE(C_dxj_Direct3dRMAnimation2Object)

// I_dxj_Direct3dRMAnimation
public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg) ;
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args) ;
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data) ;
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data) ;
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE setOptions( 
            /* [in] */ d3drmAnimationOptions flags) ;
        
        HRESULT STDMETHODCALLTYPE addRotateKey( 
            /* [in] */ float time,
            /* [in] */ D3dRMQuaternion __RPC_FAR *q) ;
        
        HRESULT STDMETHODCALLTYPE addPositionKey( 
            /* [in] */ float time,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z) ;
        
        HRESULT STDMETHODCALLTYPE addScaleKey( 
            /* [in] */ float time,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z) ;
        
        HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ float time) ;
        
        HRESULT STDMETHODCALLTYPE setFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *frame) ;

        HRESULT STDMETHODCALLTYPE getFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR **frame) ;

        HRESULT STDMETHODCALLTYPE setTime( 
            /* [in] */ float time) ;
        
        HRESULT STDMETHODCALLTYPE getOptions( 
            /* [retval][out] */ d3drmAnimationOptions __RPC_FAR *options) ;
        
        HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ D3DRMANIMATIONKEY_CDESC __RPC_FAR *key) ;
        
        HRESULT STDMETHODCALLTYPE deleteKeyById( 
            /* [in] */ long id) ;
        
        HRESULT STDMETHODCALLTYPE getKeys( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,
            ///* [in] */ long count,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *keyArray) ;
        
        HRESULT STDMETHODCALLTYPE getKeysCount( 
            /* [in] */ float timeMin,
            /* [in] */ float timeMax,
            /* [retval][out] */ long __RPC_FAR *count) ;
        
        
        HRESULT STDMETHODCALLTYPE modifyKey( 
            /* [in] */ D3DRMANIMATIONKEY_CDESC __RPC_FAR *key) ;
        
////////////////////////////////////////////////////////////////////////////////////
//

private:
    DECL_VARIABLE(_dxj_Direct3dRMAnimation2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMAnimation2)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmanimationarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmAnimationArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmAnimationArrayObj.h"
#include "d3drmAnimation2Obj.h"

extern void *g_dxj_Direct3dRMAnimationArray;

CONSTRUCTOR(_dxj_Direct3dRMAnimationArray, {});
DESTRUCTOR(_dxj_Direct3dRMAnimationArray, {});
GETSET_OBJECT(_dxj_Direct3dRMAnimationArray);

GET_DIRECT_R(_dxj_Direct3dRMAnimationArray,getSize, GetSize, long)


HRESULT C_dxj_Direct3dRMAnimationArrayObject::getElement(long i, I_dxj_Direct3dRMAnimation2 **Animation){
	HRESULT hr;
	IDirect3DRMAnimation2 *realAnimation2=NULL;

	hr=m__dxj_Direct3dRMAnimationArray->GetElement((DWORD)i,&realAnimation2);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMAnimation2,(IDirect3DRMAnimation2*)realAnimation2,Animation);


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationset2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimationset2obj.h
//
//--------------------------------------------------------------------------

// d3drmAnimationSet2Obj.h : Declaration of the C_dxj_Direct3dRMAnimationSet2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMAnimationSet2 LPDIRECT3DRMANIMATIONSET2
/////////////////////////////////////////////////////////////////////////////
// Direct
//
//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMAnimationSet2Object : 
	public I_dxj_Direct3dRMAnimationSet2,
	//public CComCoClass<C_dxj_Direct3dRMAnimationSet2Object, &CLSID__dxj_Direct3dRMAnimationSet2>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMAnimationSet2Object() ;
	virtual ~C_dxj_Direct3dRMAnimationSet2Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMAnimationSet2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMAnimationSet2)
	END_COM_MAP()

	// 	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMAnimationSet2, "DIRECT.Direct3dRMAnimationSet2.3",	"DIRECT.Direct3dRMAnimationSet2.3", IDS_D3DRMAnimationSet2_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMAnimationSet2Object)

// I_dxj_Direct3dRMAnimationSet2
public:
	// MUST BE FIRST TWO!
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

	STDMETHOD(loadFromFile)(BSTR filename, VARIANT id,long flags,
			I_dxj_Direct3dRMLoadTextureCallback3 *c,IUnknown *pUser, I_dxj_Direct3dRMFrame3 *frame);
	STDMETHOD(setTime)(d3dvalue time);

	STDMETHOD(addAnimation)(I_dxj_Direct3dRMAnimation2 *aid);
	STDMETHOD(deleteAnimation)(I_dxj_Direct3dRMAnimation2 *aid);
	STDMETHOD(getAnimations)(I_dxj_Direct3dRMAnimationArray **ppret);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMAnimationSet2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMAnimationSet2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmArrayObj.h"

CONSTRUCTOR( _dxj_Direct3dRMObjectArray, {} );
DESTRUCTOR ( _dxj_Direct3dRMObjectArray, {} );
GETSET_OBJECT ( _dxj_Direct3dRMObjectArray );
	
GET_DIRECT_R(_dxj_Direct3dRMObjectArray, getSize, GetSize, long);


#pragma message ("TODO D3DRMObjectArray")


HRESULT C_dxj_Direct3dRMObjectArrayObject::getElement(long i, I_dxj_Direct3dRMObject **obj){
	//HRESULT hr;		
	//hr=m__dxj_Direct3dRMObjectArray->GetElement((DWORD)i,&realobj);
	//if FAILED(hr) return hr;
	//INTERNAL_CREATE(_dxj_Direct3dRMObject,(IDirect3DRMObject)realobj,obj);
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmanimationarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmAnimationArrayObj.h : Declaration of the C_dxj_Direct3dRMAnimationArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMAnimationArray LPDIRECT3DRMANIMATIONARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMAnimationArrayObject : 
	
	//public CComDualImpl<I_dxj_Direct3dRMAnimationArray, &IID_I_dxj_Direct3dRMAnimationArray, &LIBID_DIRECTLib>, 
	//public ISupportErrorInfo,
	public I_dxj_Direct3dRMAnimationArray,
	//public CComCoClass<C_dxj_Direct3dRMAnimationArrayObject, &CLSID__dxj_Direct3dRMAnimationArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMAnimationArrayObject() ;
	virtual ~C_dxj_Direct3dRMAnimationArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMAnimationArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMAnimationArray)
		//COM_INTERFACE_ENTRY(IDispatch)
		//COM_INTERFACE_ENTRY(ISupportErrorInfo)

	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMAnimationArray,	"DIRECT.Direct3dRMAnimationArray.3",	"DIRECT.Direct3dRMAnimationArray.3",   IDS_D3DRMAnimationARRAY_DESC,   THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMAnimationArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMAnimationArrayObject)
	

	//STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// I_dxj_Direct3dRMAnimationArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)(long *retval);
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMAnimation2 **lplpD3DRMAnimation);

private:
    DECL_VARIABLE(_dxj_Direct3dRMAnimationArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMAnimationArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmanimationset2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmanimationset2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmAnimationSet2Obj.cpp : Implementation of CDirectApp and DLL registration.


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmAnimationSet2Obj.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmAnimationArrayObj.h"

extern void *g_dxj_Direct3dRMAnimationArray;
extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR( _dxj_Direct3dRMAnimationSet2,{});
DESTRUCTOR( _dxj_Direct3dRMAnimationSet2,{});
GETSET_OBJECT(_dxj_Direct3dRMAnimationSet2);

CLONE_R(_dxj_Direct3dRMAnimationSet2,Direct3DRMAnimationSet2);
SETNAME_R(_dxj_Direct3dRMAnimationSet2);
GETNAME_R(_dxj_Direct3dRMAnimationSet2);
GETCLASSNAME_R(_dxj_Direct3dRMAnimationSet2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMAnimationSet2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMAnimationSet2);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMAnimationSet2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R( _dxj_Direct3dRMAnimationSet2, setTime, SetTime, d3dvalue);

GET_DIRECT_R(_dxj_Direct3dRMAnimationSet2, getAppData, GetAppData, long);

DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMAnimationSet2, addAnimation,    AddAnimation,    _dxj_Direct3dRMAnimation2); 
//DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMAnimationSet2, deleteAnimation, DeleteAnimation, _dxj_Direct3dRMAnimation2);


STDMETHODIMP C_dxj_Direct3dRMAnimationSet2Object::deleteAnimation(I_dxj_Direct3dRMAnimation2 *anim)
{
	HRESULT hr;
	UINT i;

	if (!anim) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMANIMATION2,pRealAnim,anim);
	
	i=pRealAnim->AddRef();
	i=pRealAnim->Release();

	hr=m__dxj_Direct3dRMAnimationSet2->DeleteAnimation(pRealAnim);

	i=pRealAnim->AddRef();
	i=pRealAnim->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP C_dxj_Direct3dRMAnimationSet2Object::loadFromFile(BSTR filename, 
				VARIANT id, long flags, I_dxj_Direct3dRMLoadTextureCallback3 *callme, 
										IUnknown *useMe, I_dxj_Direct3dRMFrame3 *frame)
{
	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback3 *tcb = NULL;

	HRESULT hr;

	if( callme )  {
		tcb = (TextureCallback3*)AddCallbackLink((void**)&TextureCallbacks3,
										(I_dxj_Direct3dRMCallback*)callme, (void*)useMe);
		if( tcb ) 	{
			d3dtcb = myLoadTextureCallback3;
			pArgs = (void *)tcb;

		} else 	{
			DPF(1,"Callback object creation failed!\r\n");
			return E_FAIL;
		}
	}
	USES_CONVERSION;
	LPCTSTR pszName = W2T(filename);			// Now convert to ANSI

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, frame);


	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		args=(void*)W2T(V_BSTR(&id));
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);



	if (flags &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszName;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRMAnimationSet2->Load((void *)&res, (DWORD*)args, (DWORD)flags, 
															d3dtcb, pArgs, (IDirect3DRMFrame3*)f);

	}
	else {
		hr = m__dxj_Direct3dRMAnimationSet2->Load((void *)pszName, (DWORD*)args, (DWORD)flags, 
															d3dtcb, pArgs, (IDirect3DRMFrame3*)f);
	}

	//We are done with the callback so remove the linked entry
	if (tcb)
		UndoCallbackLink( (GeneralCallback*)tcb,
									(GeneralCallback**)&TextureCallbacks3 );
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMAnimationSet2Object::getAnimations(I_dxj_Direct3dRMAnimationArray **ppret)
{	
	HRESULT hr;
	LPDIRECT3DRMANIMATIONARRAY lpArray=NULL;

	hr=m__dxj_Direct3dRMAnimationSet2->GetAnimations(&lpArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMAnimationArray, lpArray, ppret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmarrayobj.h
//
//--------------------------------------------------------------------------

// d3dRMObjectArrayObj.h : Declaration of the C_dxj_Direct3dRMObjectArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMObjectArray LPDIRECT3DRMOBJECTARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

class C_dxj_Direct3dRMObjectArrayObject : 
	public I_dxj_Direct3dRMObjectArray,
	//public CComCoClass<C_dxj_Direct3dRMObjectArrayObject, &CLSID__dxj_Direct3dRMObjectArray>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMObjectArrayObject();
	virtual ~C_dxj_Direct3dRMObjectArrayObject();

	BEGIN_COM_MAP(C_dxj_Direct3dRMObjectArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObjectArray)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMObjectArrayObject)

// I_dxj_Direct3dRMObjectArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
	STDMETHOD(getElement)( long index, I_dxj_Direct3dRMObject **ret);
	
private:
    DECL_VARIABLE(_dxj_Direct3dRMObjectArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMObjectArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmclippedvisualobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmclippedvisualobj.cpp
//
//--------------------------------------------------------------------------

// d3dRMClippedVisualObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dRMClippedVisualObj.h"

CONSTRUCTOR(_dxj_Direct3dRMClippedVisual, {});
DESTRUCTOR(_dxj_Direct3dRMClippedVisual, {});
GETSET_OBJECT(_dxj_Direct3dRMClippedVisual);

CLONE_R(_dxj_Direct3dRMClippedVisual,Direct3DRMClippedVisual);
GETNAME_R(_dxj_Direct3dRMClippedVisual);
SETNAME_R(_dxj_Direct3dRMClippedVisual);
GETCLASSNAME_R(_dxj_Direct3dRMClippedVisual);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMClippedVisual);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMClippedVisual);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMClippedVisual, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMClippedVisual, getAppData, GetAppData, long);


//PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMClippedVisual, deletePlane, DeletePlane, long,(DWORD),long,(DWORD));



STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::deletePlane( long id) {
	HRESULT hr;
	hr = m__dxj_Direct3dRMClippedVisual->DeletePlane(id,0);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::addPlane( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal,
            ///* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;
	if (!point) return E_INVALIDARG;
	if (!normal) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,ref);

	hr = m__dxj_Direct3dRMClippedVisual->AddPlane(
			lpFrame,
			(D3DVECTOR*) point,
			(D3DVECTOR*) normal,
			(DWORD) 0,
			(DWORD*)ret);

	return hr;			
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::getPlane( 
			/* [in] */ long id,											
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
            ///* [in] */ long flags
			)
{
	HRESULT hr;
	if (!point) return E_INVALIDARG;
	if (!normal) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,ref);

	hr = m__dxj_Direct3dRMClippedVisual->GetPlane(
			(DWORD)id,
			lpFrame,
			(D3DVECTOR*) point,
			(D3DVECTOR*) normal,
			(DWORD) 0);	

	return hr;			
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::setPlane( 
			/* [in] */ long id,											
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
            ///* [in] */ long flags
			)
{
	HRESULT hr;
	if (!point) return E_INVALIDARG;
	if (!normal) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,ref);

	hr = m__dxj_Direct3dRMClippedVisual->SetPlane(
			(DWORD)id,
			lpFrame,
			(D3DVECTOR*) point,
			(D3DVECTOR*) normal,
			(DWORD) 0);	

	return hr;			
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::getPlaneIdsCount( 
			/* [in] */ long *count)	
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMClippedVisual->GetPlaneIDs((DWORD*)count,NULL,0);

	return hr;			
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMClippedVisualObject::getPlaneIds( 
            /* [in] */ long count,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *arrayOfIds) \
{
	HRESULT hr;
	if (!ISSAFEARRAY1D(arrayOfIds,(DWORD)count)) return E_INVALIDARG;

	hr = m__dxj_Direct3dRMClippedVisual->GetPlaneIDs((DWORD*)&count,
			(DWORD*)(((SAFEARRAY *)*arrayOfIds)->pvData),0);

	return hr;			
	//getDibits
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmclippervisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmclippervisualobj.h
//
//--------------------------------------------------------------------------

// d3dRMClippedVisualObj.h : Declaration of the C_dxj_Direct3dRMClippedVisualObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMClippedVisual LPDIRECT3DRMCLIPPEDVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMClippedVisualObject : 
	public I_dxj_Direct3dRMClippedVisual,
	public I_dxj_Direct3dRMVisual,
	public I_dxj_Direct3dRMObject,
	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMClippedVisualObject() ;
	virtual ~C_dxj_Direct3dRMClippedVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMClippedVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMClippedVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMClippedVisualObject)

// I_dxj_Direct3dRMClippedVisual
public:
	// MUST BE FIRST
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_D3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_D3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

	STDMETHOD(setPower)(d3dvalue power);
	STDMETHOD(setSpecular)(d3dvalue r, d3dvalue g, d3dvalue b);
	STDMETHOD(setEmissive)(d3dvalue r, d3dvalue g, d3dvalue b);
	STDMETHOD(getPower)(d3dvalue *power);
	STDMETHOD(getSpecular)(d3dvalue *r, d3dvalue *g, d3dvalue *b);
	STDMETHOD(getEmissive)(d3dvalue *r, d3dvalue *g, d3dvalue *b);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMClippedVisual);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMClippedVisual )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmclippedvisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmclippedvisualobj.h
//
//--------------------------------------------------------------------------

// d3dRMClippedVisualObj.h : Declaration of the C_dxj_Direct3dRMClippedVisualObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMClippedVisual LPDIRECT3DRMCLIPPEDVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_Direct3dRMClippedVisualObject : 
	public I_dxj_Direct3dRMClippedVisual,
	public I_dxj_Direct3dRMVisual,
	public I_dxj_Direct3dRMObject,
	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMClippedVisualObject() ;
	virtual ~C_dxj_Direct3dRMClippedVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMClippedVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMClippedVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMClippedVisualObject)

// I_dxj_Direct3dRMClippedVisual
public:
	
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE addPlane( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal,
//            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE deletePlane( 
            /* [in] */ long id
//            /* [in] */ long flags
);
        
         HRESULT STDMETHODCALLTYPE getPlane( 
            /* [in] */ long id,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
//            /* [in] */ long flags
);
        
         HRESULT STDMETHODCALLTYPE getPlaneIds( 
            /* [in] */ long count,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *arrayOfIds);
        
         HRESULT STDMETHODCALLTYPE getPlaneIdsCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
         HRESULT STDMETHODCALLTYPE setPlane( 
            /* [in] */ long id,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *point,
            /* [out][in] */ D3dVector __RPC_FAR *normal
//            /* [in] */ long flags
);
        
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMClippedVisual);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMClippedVisual )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmdevicearrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmdevicearrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmDeviceArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmDeviceArrayObj.h"
#include "d3drmDevice3Obj.h"

CONSTRUCTOR( _dxj_Direct3dRMDeviceArray, {} );
DESTRUCTOR ( _dxj_Direct3dRMDeviceArray, {} );
GETSET_OBJECT ( _dxj_Direct3dRMDeviceArray );

GET_DIRECT_R(_dxj_Direct3dRMDeviceArray, getSize, GetSize,  long);

#ifdef DX5
HRESULT C_dxj_Direct3dRMDeviceArrayObject::getElement(long id, I_dxj_Direct3dRMDevice2 **ret){
	IDirect3DRMDevice  *realdevice=NULL;	
	IDirect3DRMDevice2  *realdevice2=NULL;	
	HRESULT hr;
	hr=m__dxj_Direct3dRMDeviceArray->GetElement((DWORD)id,&realdevice);
	if FAILED(hr) return hr;

	hr = realdevice->QueryInterface(IID_IDirect3DRMDevice2,(void**)&realdevice2);
	realdevice->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMDevice2,(IDirect3DRMDevice2*)realdevice2,ret);

	return hr;
}
#else
HRESULT C_dxj_Direct3dRMDeviceArrayObject::getElement(long id, I_dxj_Direct3dRMDevice3 **ret){
	IDirect3DRMDevice  *realdevice=NULL;	
	IDirect3DRMDevice3  *realdevice3=NULL;	
	HRESULT hr;
	hr=m__dxj_Direct3dRMDeviceArray->GetElement((DWORD)id,&realdevice);
	if FAILED(hr) return hr;

	hr = realdevice->QueryInterface(IID_IDirect3DRMDevice3,(void**)&realdevice3);
	realdevice->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMDevice3,realdevice3,ret);

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmdevice3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmdevice3obj.h
//
//--------------------------------------------------------------------------

// d3drmDevice3Obj.h : Declaration of the C_dxj_Direct3dRMDeviceObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMDevice3 LPDIRECT3DRMDEVICE3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMDevice3Object : 
	public I_dxj_Direct3dRMDevice3,
	public I_dxj_Direct3dRMObject,
	//public CComCoClass<C_dxj_Direct3dRMDevice3Object, &CLSID__dxj_Direct3dRMDevice3>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMDevice3Object();
	virtual ~C_dxj_Direct3dRMDevice3Object();
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMDevice3Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMDevice3)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

// 	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMDevice3,		"DIRECT.Direct3dRMDevice3.5",		"DIRECT.Direct3dRMDevice3.5", IDS_D3DRMDEVICE_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dRMDevice3Object)

// I_dxj_Direct3dRMDevice3
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE addUpdateCallback( 
            /* [in] */ I_dxj_Direct3dRMDeviceUpdateCallback3 __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE deleteUpdateCallback( 
            /* [in] */ I_dxj_Direct3dRMDeviceUpdateCallback3 __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE findPreferredTextureFormat( 
            /* [in] */ long bitDepth,
            /* [in] */ long flags,
            /* [out][in] */ DDPixelFormat __RPC_FAR *ddpf);
        
         HRESULT STDMETHODCALLTYPE getBufferCount( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getColorModel( 
            /* [retval][out] */ d3dColorModel __RPC_FAR *retv);
        
        // HRESULT STDMETHODCALLTYPE getDirect3DDevice3( 
        //    /* [retval][out] */ I_dxj_Direct3dDevice3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getDither( 
            /* [retval][out] */ long __RPC_FAR *d);
        
         HRESULT STDMETHODCALLTYPE getHeight( 
            /* [retval][out] */ int __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE getQuality( 
            /* [retval][out] */ d3drmRenderQuality __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getRenderMode( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getShades( 
            /* [retval][out] */ long __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getTextureQuality( 
            /* [retval][out] */ d3drmTextureQuality __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getTrianglesDrawn( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getViewports( 
            /* [retval][out] */ I_dxj_Direct3dRMViewportArray __RPC_FAR *__RPC_FAR *views);
        
         HRESULT STDMETHODCALLTYPE getWireframeOptions( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getWidth( 
            /* [retval][out] */ int __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE setBufferCount( 
            /* [in] */ long count);
        
         HRESULT STDMETHODCALLTYPE setDither( 
            /* [in] */ long dith);
        
         HRESULT STDMETHODCALLTYPE setQuality( 
            /* [in] */ d3drmRenderQuality q);
        
         HRESULT STDMETHODCALLTYPE setRenderMode( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setShades( 
            /* [in] */ int shades);
        
         HRESULT STDMETHODCALLTYPE setTextureQuality( 
            /* [in] */ d3drmTextureQuality d);
        
         HRESULT STDMETHODCALLTYPE update( void);
        
		 HRESULT STDMETHODCALLTYPE handleActivate(long wParam) ;
		 
		 HRESULT STDMETHODCALLTYPE handlePaint(long hdcThing) ;
	
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRMDevice3);

private:
	

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMDevice3 )
	IUnknown *parent2;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmdevice3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmdevice3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmDevice3Obj.h"
#include "d3drmViewportArrayObj.h"


C_dxj_Direct3dRMDevice3Object::C_dxj_Direct3dRMDevice3Object(){
	m__dxj_Direct3dRMDevice3=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;	

	parent2 =NULL;

	DPF1(1,"Constructor Creation  Direct3dRMDevice3[%d] \n",g_creationcount);

	nextobj =  g_dxj_Direct3dRMDevice3;
	g_dxj_Direct3dRMDevice3 = (void *)this;
}


C_dxj_Direct3dRMDevice3Object::~C_dxj_Direct3dRMDevice3Object(){

	DPF1(1,"Destructor  Direct3dRMDevice3 [%d] \n",creationid); 
	
	C_dxj_Direct3dRMDevice3Object *prev=NULL; 

	for(C_dxj_Direct3dRMDevice3Object *ptr=(C_dxj_Direct3dRMDevice3Object *)g_dxj_Direct3dRMDevice3;
		ptr;
		ptr=(C_dxj_Direct3dRMDevice3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMDevice3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMDevice3){ 
		int count = IUNK(m__dxj_Direct3dRMDevice3)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMDevice3 Ref count %d \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMDevice3 = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	if (parent2)
		IUNK(parent2)->Release();
}


DWORD C_dxj_Direct3dRMDevice3Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMDevice3[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMDevice3Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMDevice3 [%d] Release %d \n",creationid,i);
	return i;
}



GETSET_OBJECT(_dxj_Direct3dRMDevice3);

CLONE_R(_dxj_Direct3dRMDevice3,Direct3DRMDevice3);
SETNAME_R(_dxj_Direct3dRMDevice3);
GETNAME_R(_dxj_Direct3dRMDevice3);
GETCLASSNAME_R(_dxj_Direct3dRMDevice3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMDevice3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMDevice3);

//CLONETO_RX(_dxj_Direct3dRMDevice3, WinDevice, IID_IDirect3DRMWinDevice);

PASS_THROUGH_R(_dxj_Direct3dRMDevice3,  update,     Update)
PASS_THROUGH1_R(_dxj_Direct3dRMDevice3, setDither,  SetDither, long)
PASS_THROUGH1_R(_dxj_Direct3dRMDevice3, setShades,  SetShades, int)
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setBufferCount, SetBufferCount,long,(DWORD));
//PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMDevice3, init, Init, long,(DWORD),long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setQuality, SetQuality, d3drmRenderQuality, (enum D3DRMRENDERQUALITY));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setTextureQuality,  SetTextureQuality, d3drmTextureQuality, (enum _D3DRMTEXTUREQUALITY));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMDevice3, setRenderMode, SetRenderMode,long,(DWORD));

GET_DIRECT_R(_dxj_Direct3dRMDevice3, getHeight,  GetHeight, int)
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getWidth,   GetWidth,  int)
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getDither,  GetDither, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getShades,  GetShades, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getQuality, GetQuality,long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getAppData, GetAppData,long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getColorModel,       GetColorModel, d3dColorModel);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getBufferCount,      GetBufferCount, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getTextureQuality,   GetTextureQuality, d3drmTextureQuality);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getTrianglesDrawn,   GetTrianglesDrawn, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getWireframeOptions, GetWireframeOptions, long);
GET_DIRECT_R(_dxj_Direct3dRMDevice3, getRenderMode,  GetRenderMode, long);


RETURN_NEW_ITEM_R(_dxj_Direct3dRMDevice3, getViewports, GetViewports, _dxj_Direct3dRMViewportArray);

															    
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::addUpdateCallback( I_dxj_Direct3dRMDeviceUpdateCallback3 *devC, IUnknown *args)
{
	// killed by companion DeleteUpdate
	DeviceUpdateCallback3 *ucb;

	ucb = (DeviceUpdateCallback3*)AddCallbackLink(
		(void**)&DeviceUpdateCallbacks3, (I_dxj_Direct3dRMCallback*)devC, (void*) args);
	if( !ucb )	{
		DPF(1,"AddUpdateCallback failed!\r\n");
		return E_FAIL;
	}
	if( m__dxj_Direct3dRMDevice3->AddUpdateCallback((D3DRMDEVICE3UPDATECALLBACK)myAddUpdateCallback3, ucb) )
		return E_FAIL;

	devC->AddRef();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::deleteUpdateCallback( I_dxj_Direct3dRMDeviceUpdateCallback3 *devC, IUnknown *args)
{
	DeviceUpdateCallback3 *ucb = DeviceUpdateCallbacks3;

	// look for our own specific entry
	for ( ;  ucb;  ucb = ucb->next )   {

		if( (ucb->c == devC) && (ucb->pUser == args) )	{

			//note: assume the callback is not called: only removed from a list.
			m__dxj_Direct3dRMDevice3->DeleteUpdateCallback(
							(D3DRMDEVICE3UPDATECALLBACK)myAddUpdateCallback3, ucb);

			// Remove ourselves in a thread-safe manner.
			UndoCallbackLink((GeneralCallback*)ucb, 
								(GeneralCallback**)&DeviceUpdateCallbacks3);
			devC->Release();
			return S_OK;
		}
	}
	return E_FAIL;
}

#if 0

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::getDirect3dRMWinDevice(  I_dxj_Direct3dRMWinDevice __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DRMWINDEVICE pWinDev=NULL;
	hr=m__dxj_Direct3dRMDevice3->QueryInterface(IID_IDirect3DRMWinDevice,(void**)&pWinDev);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMWinDevice,pWinDev,retv);
	return hr;
}

#endif

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::getDirect3DDevice3(  I_dxj_Direct3dDevice3 __RPC_FAR *__RPC_FAR *retv)
{
	HRESULT hr;
	LPDIRECT3DDEVICE2 pDev2=NULL;
	LPDIRECT3DDEVICE3 pDev3=NULL;
	hr=m__dxj_Direct3dRMDevice3->GetDirect3DDevice2(&pDev2); 

	if FAILED(hr) return hr;
	if (!retv) return E_INVALIDARG;
	*retv=NULL;

	if (!pDev2) return S_OK;

	hr=pDev2->QueryInterface(IID_IDirect3DDevice3,(void**)&pDev3);
	pDev2->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dDevice3,pDev3,retv);
	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMDevice3Object::findPreferredTextureFormat(       
			/* [in] */ long bitDepth,
            /* [in] */ long flags,
            /* [out][in] */ DDPixelFormat __RPC_FAR *ddpf) 
{
	HRESULT hr;
	
	DDPIXELFORMAT realDDPF;
	realDDPF.dwSize=sizeof(DDPIXELFORMAT);

	hr=m__dxj_Direct3dRMDevice3->FindPreferredTextureFormat((DWORD)bitDepth,(DWORD) flags,&realDDPF);
	if FAILED(hr) return hr;

	hr=CopyOutDDPixelFormat(ddpf,&realDDPF);
	if FAILED(hr) return hr;

	return hr;
}


//PASS_THROUGH_CAST_1_R(C_dxj_Direct3dRMDevice3Object, handleActivate, HandleActivate, int, (unsigned short))



/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP C_dxj_Direct3dRMDevice3Object::handlePaint(long hdcThing) 
{
	LPDIRECT3DRMWINDEVICE pWinDevice=NULL;
	HRESULT hr;

	hr=m__dxj_Direct3dRMDevice3->QueryInterface(IID_IDirect3DRMWinDevice,(void**)&pWinDevice);
	if FAILED(hr) return hr;

	hr=pWinDevice->HandlePaint((HDC)hdcThing);
	
	pWinDevice->Release();
	return hr;

	
}

STDMETHODIMP C_dxj_Direct3dRMDevice3Object::handleActivate(long wParam) 
{
	LPDIRECT3DRMWINDEVICE pWinDevice=NULL;
	HRESULT hr;

	hr=m__dxj_Direct3dRMDevice3->QueryInterface(IID_IDirect3DRMWinDevice,(void**)&pWinDevice);
	if FAILED(hr) return hr;

	hr=pWinDevice->HandleActivate((WORD)wParam);
	
	pWinDevice->Release();
	return hr;

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmface2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmface2obj.h
//
//--------------------------------------------------------------------------

// d3drmFace2Obj.h : Declaration of the C_dxj_Direct3dRMFace2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMFace2 LPDIRECT3DRMFACE2


/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMFace2Object : 
	public I_dxj_Direct3dRMFace2,
	public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFace2Object() ;
	virtual ~C_dxj_Direct3dRMFace2Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMFace2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFace2)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()


	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFace2Object)

// I_dxj_Direct3dRMFace2
public:
	//updated
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg) ;
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args) ;
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data) ;
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data) ;
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
        HRESULT STDMETHODCALLTYPE addVertex( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z) ;
        
        HRESULT STDMETHODCALLTYPE addVertexAndNormalIndexed( 
            /* [in] */ long vertex,
            /* [in] */ long normal) ;
        
        HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b) ;
        
        HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c) ;
        
        HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *ref) ;
        
        HRESULT STDMETHODCALLTYPE setTextureCoordinates( 
            /* [in] */ long vertex,
            /* [in] */ float u,
            /* [in] */ float v) ;
        
        HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *ref) ;
        
        HRESULT STDMETHODCALLTYPE setTextureTopology( 
            /* [in] */ long wrap_u,
            /* [in] */ long wrap_v) ;
        
        HRESULT STDMETHODCALLTYPE getVertex( 
            /* [in] */ long idx,
            /* [out][in] */ D3dVector __RPC_FAR *vert,
            /* [out][in] */ D3dVector __RPC_FAR *norm) ;
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ long vertex_cnt,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *coord,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *normals) ;
        
        HRESULT STDMETHODCALLTYPE getTextureCoordinates( 
            /* [in] */ long vertex,
            /* [out][in] */ float __RPC_FAR *u,
            /* [out][in] */ float __RPC_FAR *v) ;
        
        
        HRESULT STDMETHODCALLTYPE getNormal( 
            /* [out][in] */ D3dVector __RPC_FAR *val) ;
        
        HRESULT STDMETHODCALLTYPE getTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *ref) ;
        
        HRESULT STDMETHODCALLTYPE getMaterial( 
            /* [retval][out] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getVertexCount( 
            /* [retval][out] */ int __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getVertexIndex( 
            /* [in] */ long which,
            /* [retval][out] */ int __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getTextureCoordinateIndex( 
            /* [in] */ long which,
            /* [retval][out] */ int __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv) ;
        
        HRESULT STDMETHODCALLTYPE getVerticesJava( 
            /* [in] */ long vertex_cnt,
            /* [out][in] */ float __RPC_FAR *coord,
            /* [out][in] */ float __RPC_FAR *normals) ;


		HRESULT STDMETHODCALLTYPE getTextureTopology(long *u, long *v);
        
private:
    DECL_VARIABLE(_dxj_Direct3dRMFace2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFace2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmfacearrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmfacearrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmFaceArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFaceArrayObj.h"
#include "d3drmFace2Obj.h"

CONSTRUCTOR( _dxj_Direct3dRMFaceArray,{});
DESTRUCTOR( _dxj_Direct3dRMFaceArray,{});
GETSET_OBJECT(_dxj_Direct3dRMFaceArray);


GET_DIRECT_R(_dxj_Direct3dRMFaceArray, getSize, GetSize,  long);
#ifdef DX5
RETURN_NEW_ITEM_CAST_1_R(_dxj_Direct3dRMFaceArray, getElement, GetElement, _dxj_Direct3dRMFace, long,(DWORD));
#else


HRESULT C_dxj_Direct3dRMFaceArrayObject::getElement(long i, I_dxj_Direct3dRMFace2 **face2){
	HRESULT hr;
	IDirect3DRMFace  *realface=NULL;
	IDirect3DRMFace2 *realface2=NULL;

	hr=m__dxj_Direct3dRMFaceArray->GetElement((DWORD)i,&realface);
	if FAILED(hr) return hr;

	hr=realface->QueryInterface(IID_IDirect3DRMFace2,(void**)&realface2);
	realface->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMFace2,(IDirect3DRMFace2*)realface2,face2);
	return hr;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmdevicearrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmdevicearrayobj.h
//
//--------------------------------------------------------------------------

// d3drmDeviceArrayObj.h : Declaration of the C_dxj_Direct3dRMDeviceArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMDeviceArray LPDIRECT3DRMDEVICEARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMDeviceArrayObject : 
	public I_dxj_Direct3dRMDeviceArray,
	//public CComCoClass<C_dxj_Direct3dRMDeviceArrayObject, &CLSID__dxj_Direct3dRMDeviceArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMDeviceArrayObject() ;
	virtual ~C_dxj_Direct3dRMDeviceArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMDeviceArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMDeviceArray)
	END_COM_MAP()

	//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMDeviceArray,	"DIRECT.Direct3dRMDeviceArray.3",	"DIRECT.Direct3dRMDeviceArray.3",  IDS_D3DRMDEVICEARRAY_DESC,  THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMDeviceArrayObject)

// I_dxj_Direct3dRMDeviceArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);

#ifdef DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMDevice2 **retval);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMDevice3 **retval);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMDeviceArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMDeviceArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmface2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmface2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmFace22Obj.cpp : Implementation of CDirectApp and DLL registration.

//#define LPDIRECT3DRMFACE2 I_dxj_Direct3dRMFace2*

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFace2Obj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmMaterial2Obj.h"



CONSTRUCTOR( _dxj_Direct3dRMFace2,{});
DESTRUCTOR( _dxj_Direct3dRMFace2,{});
GETSET_OBJECT(_dxj_Direct3dRMFace2);

CLONE_R(_dxj_Direct3dRMFace2,Direct3DRMFace2);
GETNAME_R(_dxj_Direct3dRMFace2);
SETNAME_R(_dxj_Direct3dRMFace2);
GETCLASSNAME_R(_dxj_Direct3dRMFace2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMFace2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMFace2);

GET_DIRECT_R(_dxj_Direct3dRMFace2, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMFace2, getColor, GetColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFace2, getVertexCount, GetVertexCount, int);
GET_DIRECT1_R(_dxj_Direct3dRMFace2, getVertexIndex, GetVertexIndex, int, long);
GET_DIRECT1_R(_dxj_Direct3dRMFace2, getTextureCoordinateIndex, GetTextureCoordinateIndex, int, long);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFace2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFace2, setColor, SetColor, d3dcolor,(DWORD));
PASS_THROUGH2_R(_dxj_Direct3dRMFace2, setTextureTopology, SetTextureTopology, long, long);
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMFace2, addVertexAndNormalIndexed, AddVertexAndNormalIndexed, long,(DWORD),long,(DWORD));
//PASS_THROUGH2_R(_dxj_Direct3dRMFace2, getTextureTopology, GetTextureTopology, int*, int*); //2 BOOL ptrs?
PASS_THROUGH3_R(_dxj_Direct3dRMFace2, addVertex, AddVertex, d3dvalue, d3dvalue,d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMFace2, setColorRGB, SetColorRGB, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMFace2, getTextureCoordinates, GetTextureCoordinates, long,(DWORD), d3dvalue*,(float*), d3dvalue*,(float*));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMFace2, setTextureCoordinates, SetTextureCoordinates, long,(DWORD), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMFace2, getVertex, GetVertex, long, (DWORD), D3dVector*, (_D3DVECTOR*),D3dVector*, (_D3DVECTOR*));

DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMFace2, setMaterial, SetMaterial, _dxj_Direct3dRMMaterial2);
RETURN_NEW_ITEM_R(_dxj_Direct3dRMFace2, getMaterial, GetMaterial, _dxj_Direct3dRMMaterial2);



STDMETHODIMP C_dxj_Direct3dRMFace2Object::getTextureTopology(long *u, long *v)
{		

	HRESULT hr;
	hr= m__dxj_Direct3dRMFace2->GetTextureTopology((BOOL*)u,(BOOL*)v);	
	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMFace2Object::getTexture(I_dxj_Direct3dRMTexture3 **tex)
{
		
	IDirect3DRMTexture3 *realtext3=NULL;	
	HRESULT hr;
	hr= m__dxj_Direct3dRMFace2->GetTexture(&realtext3);
	if FAILED(hr) return hr;
	
	INTERNAL_CREATE(_dxj_Direct3dRMTexture3,realtext3,tex);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFace2Object::setTexture(I_dxj_Direct3dRMTexture3 *tex)
{
	if (tex==NULL) return E_INVALIDARG;
	IDirect3DRMTexture3 *realtext3=NULL;	
	tex->InternalGetObject((IUnknown**)&realtext3);		
	return m__dxj_Direct3dRMFace2->SetTexture( realtext3);
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFace2Object::getNormal(D3dVector *norm)
{
	return m__dxj_Direct3dRMFace2->GetNormal( (D3DVECTOR*) norm);
}


/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMFace2Object::getVerticesJava(long cnt, float *v, float* n )
{
  HRESULT hr;
  __try {
	hr=m__dxj_Direct3dRMFace2->GetVertices((unsigned long *)&cnt, (D3DVECTOR *)v, (D3DVECTOR *)n);
  }
  __except(1,1){
	return E_INVALIDARG;
  }
  return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFace2Object::getVertices(long cnt, SAFEARRAY **ppsv, SAFEARRAY **ppsn )
{
  if ((*ppsv==NULL)||(*ppsn==NULL)) return E_INVALIDARG;	
  if (!ISSAFEARRAY1D(ppsv,(DWORD)cnt)) return E_INVALIDARG;
  if (!ISSAFEARRAY1D(ppsn,(DWORD)cnt)) return E_INVALIDARG;

  D3DVECTOR *v= (D3DVECTOR*)((SAFEARRAY*)*ppsv)->pvData;
  D3DVECTOR *n= (D3DVECTOR*)((SAFEARRAY*)*ppsn)->pvData;
  return m__dxj_Direct3dRMFace2->GetVertices((unsigned long *)&cnt, (D3DVECTOR *)v, (D3DVECTOR *)n);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmfacearrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmfacearrayobj.h
//
//--------------------------------------------------------------------------

// d3drmFaceArrayObj.h : Declaration of the C_dxj_Direct3dRMFaceArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMFaceArray LPDIRECT3DRMFACEARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMFaceArrayObject : 
	public I_dxj_Direct3dRMFaceArray,
	//public CComCoClass<C_dxj_Direct3dRMFaceArrayObject, &CLSID__dxj_Direct3dRMFaceArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFaceArrayObject();
	virtual ~C_dxj_Direct3dRMFaceArrayObject();

	BEGIN_COM_MAP(C_dxj_Direct3dRMFaceArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFaceArray)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMFaceArray,	"DIRECT.Direct3dRMFaceArray.3",		"DIRECT.Direct3dRMFaceArray.3",    IDS_D3DRMFACEARRAY_DESC,    THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMFaceArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFaceArrayObject)

// I_dxj_Direct3dRMFaceArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
#ifdef DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFace **retval);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFace2 **retval);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMFaceArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFaceArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmframe3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframe3obj.h
//
//--------------------------------------------------------------------------

// d3drmFrameObj.h : Declaration of the C_dxj_Direct3dRMFrame3Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"
#include "d3drmPick2ArrayObj.h"
#define typedef__dxj_Direct3dRMFrame3 LPDIRECT3DRMFRAME3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

//		public CComCoClass<Cproj3, &CLSID_proj3>,
	

class C_dxj_Direct3dRMFrame3Object : 
    public CComObjectRoot,
	public I_dxj_Direct3dRMFrame3,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual
	
{
public:

BEGIN_COM_MAP(C_dxj_Direct3dRMFrame3Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFrame3)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)

END_COM_MAP()


	C_dxj_Direct3dRMFrame3Object();
	virtual ~C_dxj_Direct3dRMFrame3Object();


DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFrame3Object)

// I_dxj_Direct3dRMFrame3
public:

	
	         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE addVisual( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *v);
        
         HRESULT STDMETHODCALLTYPE deleteVisual( 
            /* [in] */ I_dxj_Direct3dRMVisual __RPC_FAR *v);
        
         HRESULT STDMETHODCALLTYPE addLight( 
            /* [in] */ I_dxj_Direct3dRMLight __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE deleteLight( 
            /* [in] */ I_dxj_Direct3dRMLight __RPC_FAR *l);
        
         HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *child);
        
         HRESULT STDMETHODCALLTYPE deleteChild( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *c);
        
         HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *referenceFrame,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE addTransform( 
            /* [in] */ d3drmCombineType t,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE addTranslation( 
            /* [in] */ d3drmCombineType t,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
         HRESULT STDMETHODCALLTYPE addScale( 
            /* [in] */ d3drmCombineType combineType,
            /* [in] */ float sx,
            /* [in] */ float sy,
            /* [in] */ float sz);
        
         HRESULT STDMETHODCALLTYPE addRotation( 
            /* [in] */ d3drmCombineType combineType,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ float theta);
        
         HRESULT STDMETHODCALLTYPE addMoveCallback( 
            /* [in] */ I_dxj_Direct3dRMFrameMoveCallback3 __RPC_FAR *frameMoveImplementation,
            /* [in] */ IUnknown __RPC_FAR *userArgument,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE deleteMoveCallback( 
            /* [in] */ I_dxj_Direct3dRMFrameMoveCallback3 __RPC_FAR *frameMoveImplementation,
            /* [in] */ IUnknown __RPC_FAR *userArgument);
        
         HRESULT STDMETHODCALLTYPE transform( 
            /* [out][in] */ D3dVector __RPC_FAR *d,
            /* [in] */ D3dVector __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE transformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors);
        
         HRESULT STDMETHODCALLTYPE inverseTransform( 
            /* [out][in] */ D3dVector __RPC_FAR *d,
            /* [in] */ D3dVector __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE inverseTransformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors);
        
         HRESULT STDMETHODCALLTYPE getAxes( 
            /* [out][in] */ D3dVector __RPC_FAR *dir,
            /* [out][in] */ D3dVector __RPC_FAR *up);
        
         HRESULT STDMETHODCALLTYPE getBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE getBoxEnable( 
            /* [retval][out] */ long __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getChildren( 
            /* [retval][out] */ I_dxj_Direct3dRMFrameArray __RPC_FAR *__RPC_FAR *children);
        
         HRESULT STDMETHODCALLTYPE getColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getHierarchyBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE getInheritAxes( 
            /* [retval][out] */ long __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getLights( 
            /* [retval][out] */ I_dxj_Direct3dRMLightArray __RPC_FAR *__RPC_FAR *lights);
        
         HRESULT STDMETHODCALLTYPE getMaterial( 
            I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getMaterialMode( 
            /* [retval][out] */ d3drmMaterialMode __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getOrientation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *dir,
            /* [out][in] */ D3dVector __RPC_FAR *up);
        
         HRESULT STDMETHODCALLTYPE getMaterialOverride( 
            /* [out][in] */ D3dMaterialOverride __RPC_FAR *override);
        
         HRESULT STDMETHODCALLTYPE getMaterialOverrideTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getParent( 
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *position);
        
         HRESULT STDMETHODCALLTYPE getRotation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *axis,
            /* [out] */ float __RPC_FAR *theta);
        
         HRESULT STDMETHODCALLTYPE getScene( 
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneBackground( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneBackgroundDepth( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneFogColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneFogEnable( 
            /* [retval][out] */ long __RPC_FAR *enable);
        
         HRESULT STDMETHODCALLTYPE getSceneFogMode( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSceneFogMethod( 
            /* [retval][out] */ long __RPC_FAR *method);
        
         HRESULT STDMETHODCALLTYPE getSceneFogParams( 
            /* [out][in] */ float __RPC_FAR *start,
            /* [out][in] */ float __RPC_FAR *end,
            /* [out][in] */ float __RPC_FAR *density);
        
         HRESULT STDMETHODCALLTYPE getSortMode( 
            /* [retval][out] */ d3drmSortMode __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getTexture( 
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *ref);
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *ref,
            /* [out][in] */ D3dVector __RPC_FAR *vel,
            /* [in] */ long includeRotationalVelocity);
        
         HRESULT STDMETHODCALLTYPE getVisuals( 
            /* [retval][out] */ I_dxj_Direct3dRMVisualArray __RPC_FAR *__RPC_FAR *visuals);
        
         HRESULT STDMETHODCALLTYPE getVisual( 
            /* [in] */ long index,
            /* [retval][out] */ I_dxj_Direct3dRMVisual __RPC_FAR *__RPC_FAR *visualArray);
        
         HRESULT STDMETHODCALLTYPE getVisualCount( 
            /* [retval][out] */ long __RPC_FAR *vis);
        
         HRESULT STDMETHODCALLTYPE getTraversalOptions( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getZBufferMode( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ long flags,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *loadTextureImplementation,
            /* [in] */ IUnknown __RPC_FAR *userArgument);
        
         HRESULT STDMETHODCALLTYPE lookAt( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *tgt,
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ d3drmFrameConstraint contraint);
        
         HRESULT STDMETHODCALLTYPE move( 
            /* [in] */ float delta);
        
         HRESULT STDMETHODCALLTYPE rayPick( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *refer,
            /* [in] */ D3dRMRay __RPC_FAR *ray,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dRMPick2Array __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ BSTR name,
            /* [in] */ d3drmXofFormat format,
            /* [in] */ d3drmSaveFlags flags);
        
         HRESULT STDMETHODCALLTYPE setAxes( 
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz);
        
         HRESULT STDMETHODCALLTYPE setBox( 
            /* [in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE setBoxEnable( 
            /* [in] */ long boxEnable);
        
         HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setInheritAxes( 
            /* [in] */ long inheritFromParent);
        
         HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *mat);
        
         HRESULT STDMETHODCALLTYPE setMaterialMode( 
            /* [in] */ d3drmMaterialMode val);
        
         HRESULT STDMETHODCALLTYPE setMaterialOverride( 
            /* [out][in] */ D3dMaterialOverride __RPC_FAR *override);
        
         HRESULT STDMETHODCALLTYPE setMaterialOverrideTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *tex);
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz);
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
         HRESULT STDMETHODCALLTYPE setQuaternion( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            D3dRMQuaternion __RPC_FAR *quat);
        
         HRESULT STDMETHODCALLTYPE setRotation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ float theta);
        
         HRESULT STDMETHODCALLTYPE setSceneBackground( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundDepth( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundImage( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *i);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setSceneFogColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneFogEnable( 
            /* [in] */ long enable);
        
         HRESULT STDMETHODCALLTYPE setSceneFogMethod( 
            /* [in] */ long method);
        
         HRESULT STDMETHODCALLTYPE setSceneFogMode( 
            /* [in] */ long c);
        
         HRESULT STDMETHODCALLTYPE setSceneFogParams( 
            /* [in] */ float start,
            /* [in] */ float end,
            /* [in] */ float density);
        
         HRESULT STDMETHODCALLTYPE setSortMode( 
            /* [in] */ d3drmSortMode val);
        
         HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *t);
        
         HRESULT STDMETHODCALLTYPE setTraversalOptions( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long with_rotation);
        
         HRESULT STDMETHODCALLTYPE setZbufferMode( 
            /* [in] */ d3drmZbufferMode val);
        	
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRMFrame3);

private:

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFrame3 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmframearrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframearrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmFrameArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmFrame3Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMFrameArray, {});
DESTRUCTOR(_dxj_Direct3dRMFrameArray, {});
GETSET_OBJECT(_dxj_Direct3dRMFrameArray);

GET_DIRECT_R(_dxj_Direct3dRMFrameArray,getSize, GetSize, long)



HRESULT C_dxj_Direct3dRMFrameArrayObject::getElement(long i, I_dxj_Direct3dRMFrame3 **frame){
	HRESULT hr;
	IDirect3DRMFrame  *realframe=NULL;
	IDirect3DRMFrame3 *realframe3=NULL;

	hr=m__dxj_Direct3dRMFrameArray->GetElement((DWORD)i,&realframe);
	if FAILED(hr) return hr;

	hr=realframe->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realframe3);
	realframe->Release();
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realframe3,frame);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmframe3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframe3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmFrameObj.cpp : Implementation of CDirectApp and DLL registration.



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmArrayObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmLightObj.h"
#include "d3drmLightArrayObj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmVisualObj.h"
#include "d3drmVisualArrayObj.h"
#include "d3drmMeshObj.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmMaterial2Obj.h"
#include "ddSurface7Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmUserVisualObj.h"
#include "d3drmObjectObj.h"


extern HRESULT FrameToXFile(LPDIRECT3DRMFRAME3 pFrame,
                     LPCSTR filename,
                     D3DRMXOFFORMAT d3dFormat,
                     D3DRMSAVEOPTIONS d3dSaveFlags);
extern HRESULT BSTRtoGUID(LPGUID pGuid,BSTR bstr);

C_dxj_Direct3dRMFrame3Object::C_dxj_Direct3dRMFrame3Object(){
	m__dxj_Direct3dRMFrame3=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMFrame3[%d] \n ",g_creationcount);

	nextobj =  g_dxj_Direct3dRMFrame3;
	g_dxj_Direct3dRMFrame3 = (void *)this;
}


C_dxj_Direct3dRMFrame3Object::~C_dxj_Direct3dRMFrame3Object()
{
    C_dxj_Direct3dRMFrame3Object *prev=NULL; 
	for(C_dxj_Direct3dRMFrame3Object *ptr=(C_dxj_Direct3dRMFrame3Object *)g_dxj_Direct3dRMFrame3; ptr; ptr=(C_dxj_Direct3dRMFrame3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMFrame3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMFrame3){
		int count = IUNK(m__dxj_Direct3dRMFrame3)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirect3DRMFrame3 Ref count %d \n",count);
		#endif

		if(count==0) m__dxj_Direct3dRMFrame3 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
}


GETSET_OBJECT(_dxj_Direct3dRMFrame3);

CLONE_R(_dxj_Direct3dRMFrame3, Direct3DRMFrame3);
GETNAME_R(_dxj_Direct3dRMFrame3);
SETNAME_R(_dxj_Direct3dRMFrame3);
GETCLASSNAME_R(_dxj_Direct3dRMFrame3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMFrame3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMFrame3);



RETURN_NEW_ITEM_R(_dxj_Direct3dRMFrame3, getChildren, GetChildren, _dxj_Direct3dRMFrameArray);
RETURN_NEW_ITEM_R(_dxj_Direct3dRMFrame3, getLights,GetLights,_dxj_Direct3dRMLightArray);


GET_DIRECT_R(_dxj_Direct3dRMFrame3, getColor, GetColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getMaterialMode, GetMaterialMode, d3drmMaterialMode);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSortMode, GetSortMode, d3drmSortMode);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneBackground, GetSceneBackground, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneFogColor, GetSceneFogColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneFogEnable, GetSceneFogEnable, long);  //BOOL
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getSceneFogMode, GetSceneFogMode, d3drmFogMode);
GET_DIRECT_R(_dxj_Direct3dRMFrame3, getZBufferMode, GetZbufferMode, d3drmZbufferMode);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMFrame3, addLight, AddLight, _dxj_Direct3dRMLight);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMFrame3, deleteLight, DeleteLight, _dxj_Direct3dRMLight);


PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setSceneBackground, SetSceneBackground, d3dcolor);
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setSceneFogEnable, SetSceneFogEnable, long);  //BOOL
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setSceneFogColor, SetSceneFogColor, d3dcolor);
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, setColor, SetColor, d3dcolor);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMFrame3, move, Move, d3dvalue);
//PASS_THROUGH2_R(_dxj_Direct3dRMFrame3, getTextureTopology, GetTextureTopology, int*, int*);
//PASS_THROUGH2_R(_dxj_Direct3dRMFrame3, setTextureTopology, SetTextureTopology, int, int);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, getSceneFogParams, GetSceneFogParams, d3dvalue*, d3dvalue*, d3dvalue*);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, setSceneBackgroundRGB, SetSceneBackgroundRGB, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, setSceneFogParams, SetSceneFogParams, d3dvalue,d3dvalue,d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMFrame3, setColorRGB, SetColorRGB, d3dvalue,d3dvalue,d3dvalue);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setSceneFogMode, SetSceneFogMode, d3drmFogMode, (D3DRMFOGMODE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setMaterialMode, SetMaterialMode, d3drmMaterialMode, (enum _D3DRMMATERIALMODE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setSortMode, SetSortMode, d3drmSortMode,(enum _D3DRMSORTMODE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMFrame3, setZbufferMode, SetZbufferMode, d3drmZbufferMode, (enum _D3DRMZBUFFERMODE) );
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMFrame3, addScale, AddScale, d3drmCombineType, (enum _D3DRMCOMBINETYPE), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMFrame3, addTranslation, AddTranslation, d3drmCombineType, (enum _D3DRMCOMBINETYPE), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue));
PASS_THROUGH_CAST_5_R(_dxj_Direct3dRMFrame3, addRotation, AddRotation, d3drmCombineType, (enum _D3DRMCOMBINETYPE), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue), d3dvalue, (d3dvalue));

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addVisual(I_dxj_Direct3dRMVisual *f){
	IDirect3DRMVisual	 *vis=NULL;
	IUnknown			 *unk=NULL;
	HRESULT				 hr;

	if (f==NULL) return E_INVALIDARG;

	((I_dxj_Direct3dRMVisual*)f)->InternalGetObject(&unk);
	if FAILED(unk->QueryInterface(IID_IDirect3DRMVisual,(void**)&vis))
		return E_INVALIDARG;
	
	hr= m__dxj_Direct3dRMFrame3->AddVisual(vis); 

	if (vis) vis->Release();
	
	return hr;

}


STDMETHODIMP C_dxj_Direct3dRMFrame3Object::deleteVisual(I_dxj_Direct3dRMVisual *f){
	IDirect3DRMVisual	 *vis=NULL;
	IUnknown			 *unk=NULL;
	HRESULT hr;

	if (f==NULL) return E_INVALIDARG;
	f->InternalGetObject(&unk);
	if FAILED(unk->QueryInterface(IID_IDirect3DRMVisual,(void**)&vis))
		return E_INVALIDARG;
	
	hr= m__dxj_Direct3dRMFrame3->DeleteVisual(vis); 

	if (vis) vis->Release ();
	return hr;

}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVisuals(I_dxj_Direct3dRMVisualArray **retv)
{
	LPDIRECT3DRMVISUALARRAY lpv;
	HRESULT hr;
	LPDIRECT3DRMFRAME2 frame2;
	hr=m__dxj_Direct3dRMFrame3->QueryInterface(IID_IDirect3DRMFrame2,(void**)&frame2);
	if FAILED(hr) return hr;
	frame2->GetVisuals(&lpv);
	frame2->Release();
	INTERNAL_CREATE(_dxj_Direct3dRMVisualArray, lpv, retv);
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVelocity(I_dxj_Direct3dRMFrame3 *ref, D3dVector *vel, long flags)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	return m__dxj_Direct3dRMFrame3->GetVelocity((LPDIRECT3DRMFRAME3)lpf, (_D3DVECTOR*)vel, (DWORD)flags);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getRotation(I_dxj_Direct3dRMFrame3 *ref, 
											D3dVector *axis, d3dvalue *theta)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	return m__dxj_Direct3dRMFrame3->GetRotation((LPDIRECT3DRMFRAME3)lpf, (_D3DVECTOR*)axis, (D3DVALUE*)theta);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getPosition(I_dxj_Direct3dRMFrame3 *ref, D3dVector *position)
{

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	return m__dxj_Direct3dRMFrame3->GetPosition((LPDIRECT3DRMFRAME3)lpf, (_D3DVECTOR*)position);
}

/////////////////////////////////////////////////////////////////////////////
//	PASS_THROUGH_CAST_3(_dxj_Direct3dRMFrame, LookAt, I_dxj_Direct3dRMFrame*, (LPDIRECT3DRMFRAME3),
//		I_dxj_Direct3dRMFrame*, (LPDIRECT3DRMFRAME3), d3drmFrameConstraint, (_D3DRMFRAMECONSTRAINT));
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::lookAt(I_dxj_Direct3dRMFrame3 *tgt, 
							   I_dxj_Direct3dRMFrame3 *ref,d3drmFrameConstraint axis)
{
//	if(! (tgt && ref) )
//		return E_POINTER;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpr, ref);
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpt, tgt);

	return m__dxj_Direct3dRMFrame3->LookAt((LPDIRECT3DRMFRAME3)lpt,(LPDIRECT3DRMFRAME3) lpr, (enum _D3DRMFRAMECONSTRAINT)axis);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addTransform(d3drmCombineType typ, SAFEARRAY **ppmat)
{
	
	D3DVALUE rmMatrix[4][4];
	CopyFloats((d3dvalue*)&rmMatrix, (float*)((SAFEARRAY*)*ppmat)->pvData, 16 );

	m__dxj_Direct3dRMFrame3->AddTransform((enum _D3DRMCOMBINETYPE)typ, rmMatrix );
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getTransform(I_dxj_Direct3dRMFrame3 *ref,SAFEARRAY **ppmat)
{
	D3DVALUE rmMatrix[4][4];	// Get info to here
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,f3,ref);
	hr=m__dxj_Direct3dRMFrame3->GetTransform(f3,rmMatrix);
	if FAILED(hr) return hr;

	CopyFloats((float*)((SAFEARRAY*)*ppmat)->pvData, (d3dvalue*)&rmMatrix, 16 );
	return(S_OK);
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addMoveCallback( I_dxj_Direct3dRMFrameMoveCallback3 *fmC, IUnknown *args, long flags)
{
	// killed by companion DeleteMove
	FrameMoveCallback3 *fmcb;
	if (!fmC) return E_INVALIDARG;

	fmcb = (FrameMoveCallback3*)AddCallbackLink(
			(void**)&FrameMoveCallbacks3, (I_dxj_Direct3dRMCallback*)fmC, (void*) args);
	if( !fmcb )
	{
		DPF(1,"Callback AddMove creation failed!\r\n");
		return E_FAIL;
	}

	fmC->AddRef();

	return m__dxj_Direct3dRMFrame3->AddMoveCallback(myFrameMoveCallback3, fmcb, (DWORD) flags);
}

///////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::deleteMoveCallback(I_dxj_Direct3dRMFrameMoveCallback3 *fmC, IUnknown *args)
{
	DPF(1,"DeleteMoveCallback entered!\r\n");


	FrameMoveCallback3 *fmcb = FrameMoveCallbacks3;

	// look for our own specific entry
	for ( ;  fmcb;  fmcb = fmcb->next )   {

		if( (fmcb->c == fmC) && (fmcb->pUser == args) )	{

			//note: assume the callback is not called: only removed from a list.
			m__dxj_Direct3dRMFrame3->DeleteMoveCallback(myFrameMoveCallback3, fmcb);

			// Remove ourselves in a thread-safe manner.
			UndoCallbackLink((GeneralCallback*)fmcb, 
									(GeneralCallback**)&FrameMoveCallbacks3);
			return S_OK;
		}
	}
	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setVelocity( I_dxj_Direct3dRMFrame3 *reference, d3dvalue x, d3dvalue y, 
									d3dvalue z, long with_rotation)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, reference);

	m__dxj_Direct3dRMFrame3->SetVelocity((LPDIRECT3DRMFRAME3)lpf, x, y, z, with_rotation);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getOrientation( I_dxj_Direct3dRMFrame3 *reference, D3dVector *dir, D3dVector *up)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, reference);

	m__dxj_Direct3dRMFrame3->GetOrientation(lpf, (struct _D3DVECTOR *)dir, (struct _D3DVECTOR *)up);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::loadFromFile(BSTR filename, VARIANT id,long flags, I_dxj_Direct3dRMLoadTextureCallback3 *callme, IUnknown *useMe)
{
	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback3 *tcb = NULL;
	HRESULT hr;

	if( callme )
	{
		tcb = new TextureCallback3;

		if( tcb )
		{
			tcb->c				= callme;
			tcb->pUser			= useMe;
			tcb->next			= NULL;   // TextureCallbacks3;
			tcb->prev			= NULL;   //(TextureCallback3*)NULL;
			TextureCallbacks3	= tcb;

			d3dtcb = myLoadTextureCallback3;
			pArgs = (void *)tcb;
		}
		else
		{

			DPF(1,"Callback object creation failed!\r\n");

			return E_FAIL;
		}
	}

	USES_CONVERSION;
	LPCTSTR pszName = W2T(filename);	
	
	
	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		args=(void*)W2T(V_BSTR(&id));
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);

	if (flags &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszName;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRMFrame3->Load((void *)&res,(DWORD*) args,(DWORD) flags, d3dtcb, pArgs);
	}
	else {
		hr = m__dxj_Direct3dRMFrame3->Load((void *)pszName,(DWORD*) args,(DWORD) flags, d3dtcb, pArgs);
	}


	if (tcb)
	{
		delete tcb;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setOrientation( I_dxj_Direct3dRMFrame3 *reference, d3dvalue dx,d3dvalue dy,d3dvalue dz, d3dvalue ux,d3dvalue uy,d3dvalue uz)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetOrientation((LPDIRECT3DRMFRAME3)f, dx, dy, dz, ux, uy, uz);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setPosition(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,d3dvalue z)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetPosition((LPDIRECT3DRMFRAME3)f, x, y, z);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setRotation(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,
											d3dvalue z,d3dvalue theta)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetRotation((LPDIRECT3DRMFRAME3)f, x, y, z, theta);
}

/////////////////////////////////////////////////////////////////////////////
// remove this frame from the callback list. (After debugging, put this into
// the destructor macro at the tof).
//

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::transform(D3dVector* dst, D3dVector* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMFrame3->Transform( (D3DVECTOR *)dst,  (D3DVECTOR *)src );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::inverseTransform(D3dVector* dst, D3dVector* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMFrame3->InverseTransform( (D3DVECTOR *)dst,  (D3DVECTOR *)src );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getParent(I_dxj_Direct3dRMFrame3 **ret)
{
	HRESULT hr;

	IDirect3DRMFrame3 *lpFrame3=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetParent(&lpFrame3);

	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpFrame3==NULL) return S_OK;
	INTERNAL_CREATE(_dxj_Direct3dRMFrame3, lpFrame3, ret);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getScene(I_dxj_Direct3dRMFrame3 **ret)
{
	HRESULT hr;	
	IDirect3DRMFrame3 *lpFrame3=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetScene(&lpFrame3);	
	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpFrame3==NULL) return S_OK;


	INTERNAL_CREATE(_dxj_Direct3dRMFrame3, lpFrame3, ret);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getTexture(I_dxj_Direct3dRMTexture3 **ret)
{
	HRESULT hr;
	IDirect3DRMTexture *tex=NULL;
	IDirect3DRMTexture3 *lpTex3=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetTexture(&lpTex3);
	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpTex3==NULL) return S_OK;
	
	INTERNAL_CREATE(_dxj_Direct3dRMTexture3, lpTex3, ret);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getSceneBackgroundDepth(I_dxj_DirectDrawSurface7 **ret)
{
	HRESULT hr;	
	IDirectDrawSurface7 *lpSurf7=NULL;
	IDirectDrawSurface *lpSurf=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetSceneBackgroundDepth(&lpSurf);
	*ret=NULL;
	if FAILED(hr) return hr;
	if (lpSurf==NULL) return S_OK;

	if FAILED(lpSurf->QueryInterface(IID_IDirectDrawSurface7,(void**)&lpSurf7)){
		lpSurf->Release();
		return E_NOINTERFACE;
	}
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpSurf7, ret);
	lpSurf->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setSceneBackgroundDepth(I_dxj_DirectDrawSurface7 *surf)
{
	HRESULT hr;
	if (!surf) return E_INVALIDARG;
	LPDIRECTDRAWSURFACE s=NULL;

	//Get our real surface s7 becomes NULL if surf is NULL
	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, s7, surf);
	if (s7){
		hr=s7->QueryInterface(IID_IDirectDrawSurface,(void**)&s);
		if FAILED(hr) return hr;		
	}	
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackgroundDepth(s);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setSceneBackgroundImage(I_dxj_Direct3dRMTexture3 *tex)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMTEXTURE3, t, tex);
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackgroundImage(t);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setTexture(I_dxj_Direct3dRMTexture3 *tex)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(IDirect3DRMTexture3*, t, tex);
	hr= m__dxj_Direct3dRMFrame3->SetTexture(t);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::addChild(I_dxj_Direct3dRMFrame3 *frame)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, frame);
	hr= m__dxj_Direct3dRMFrame3->AddChild(f);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::deleteChild(I_dxj_Direct3dRMFrame3 *frame)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, frame);
	hr= m__dxj_Direct3dRMFrame3->DeleteChild(f);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getAxes(D3dVector *dir,D3dVector *up)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->GetAxes((D3DVECTOR*)dir,(D3DVECTOR*)up);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getBox(D3dRMBox *box)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->GetBox((D3DRMBOX*)box);
	return S_OK;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getBoxEnable(long *box)
{
	HRESULT hr=S_OK;	
	
	*box= m__dxj_Direct3dRMFrame3->GetBoxEnable();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getHierarchyBox(D3dRMBox *box)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->GetHierarchyBox((D3DRMBOX*)box);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getInheritAxes(long *box)
{
	HRESULT hr=S_OK;	
	
	*box= m__dxj_Direct3dRMFrame3->GetInheritAxes();
	return hr;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setAxes(float dx,float dy,float dz, float ux,float uy,float uz)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->SetAxes(dx,dy,dz,ux,uy,uz);
	return hr;
}
	

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setBox(D3dRMBox *box)
{
	HRESULT hr;	
	hr= m__dxj_Direct3dRMFrame3->SetBox((D3DRMBOX*)box);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setInheritAxes(long bl)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetInheritAxes(bl);
	return hr;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setBoxEnable(long bl)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetBoxEnable(bl);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setQuaternion(I_dxj_Direct3dRMFrame3 *refer,D3dRMQuaternion *quat)
{
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, refer);
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetQuaternion(f,(D3DRMQUATERNION*)quat);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::rayPick(I_dxj_Direct3dRMFrame3 *refer,D3dRMRay *ray,long flags,I_dxj_Direct3dRMPick2Array **retv)
{
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, refer);
	LPDIRECT3DRMPICKED2ARRAY lpArray=NULL;
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->RayPick(f,(D3DRMRAY*)ray,(DWORD)flags,&lpArray);		
	INTERNAL_CREATE(_dxj_Direct3dRMPick2Array, lpArray, retv);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::save(BSTR name,long format,long flags)
{
	//RM FAILED TO IMPLEMENT FRAME SAVE SO
	//IT ALWAYS RETURNS E_NOTIMPL
	//CONGPA PROVIDED A LIBRARY FOR SAVING
	//return E_NOTIMPL;

	USES_CONVERSION;
	LPSTR pszNam = W2T(name);				// Now convert to ANSI
	HRESULT hr;
	//hr= m__dxj_Direct3dRMFrame3->Save(pszNam,(D3DRMXOFFORMAT)format,(DWORD)flags);

	hr=FrameToXFile(m__dxj_Direct3dRMFrame3,
                     pszNam,
                     (D3DRMXOFFORMAT)format,
                     (D3DRMSAVEOPTIONS) flags);


	return hr;
}
	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setTraversalOptions(long flags)
{
	HRESULT hr;
	hr= m__dxj_Direct3dRMFrame3->SetTraversalOptions((DWORD)flags);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getTraversalOptions(long *flags)
{
	HRESULT hr;
	hr= m__dxj_Direct3dRMFrame3->GetTraversalOptions((DWORD*)flags);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::transformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,ref,reference);
	if (!reference) ref=NULL;

	__try{
		hr= m__dxj_Direct3dRMFrame3->TransformVectors(ref,(DWORD)num,
						(D3DVECTOR*)((SAFEARRAY*)*DstVectors)->pvData,
						(D3DVECTOR*)((SAFEARRAY*)*SrcVectors)->pvData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::inverseTransformVectors( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ long num,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *DstVectors,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *SrcVectors)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,ref,reference);	

	__try{
		hr= m__dxj_Direct3dRMFrame3->InverseTransformVectors(ref,(DWORD)num,
						(D3DVECTOR*)((SAFEARRAY*)*DstVectors)->pvData,
						(D3DVECTOR*)((SAFEARRAY*)*SrcVectors)->pvData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}

         


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getMaterial(I_dxj_Direct3dRMMaterial2 **ret)
{
	HRESULT hr;

	IDirect3DRMMaterial2 *lpMat2=NULL;
	hr= m__dxj_Direct3dRMFrame3->GetMaterial(&lpMat2);
	*ret=NULL;
	if FAILED(hr) return hr;	
	INTERNAL_CREATE(_dxj_Direct3dRMMaterial2, lpMat2, ret);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setMaterial(I_dxj_Direct3dRMMaterial2 *mat)
{
	HRESULT hr;
	if (mat==NULL) 
		return m__dxj_Direct3dRMFrame3->SetMaterial(NULL);

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMMATERIAL2,lpMat2,mat);	
	hr= m__dxj_Direct3dRMFrame3->SetMaterial(lpMat2);	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getMaterialOverride(D3dMaterialOverride *override)
{
	HRESULT hr;

	if (!override) return E_INVALIDARG;	
	override->lSize=sizeof(D3DRMMATERIALOVERRIDE);

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride((D3DRMMATERIALOVERRIDE*)override);	
	if FAILED(hr) return hr;	
	if (((D3DRMMATERIALOVERRIDE*)override)->lpD3DRMTex)
		(((D3DRMMATERIALOVERRIDE*)override)->lpD3DRMTex)->Release();
		
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setMaterialOverride(D3dMaterialOverride *override)
{
	HRESULT hr;
	
	if (!override) return E_INVALIDARG;		
	D3DRMMATERIALOVERRIDE override2;
	ZeroMemory(&override2,sizeof(D3DRMMATERIALOVERRIDE));
	override->lSize=sizeof(D3DRMMATERIALOVERRIDE);
	override2.dwSize=sizeof(D3DRMMATERIALOVERRIDE);

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride(&override2);	
	if FAILED(hr) return hr;	

	
	((D3DRMMATERIALOVERRIDE*)override)->lpD3DRMTex=override2.lpD3DRMTex;
	hr= m__dxj_Direct3dRMFrame3->SetMaterialOverride((D3DRMMATERIALOVERRIDE*)override);		
	if (override2.lpD3DRMTex) override2.lpD3DRMTex->Release();
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setMaterialOverrideTexture(I_dxj_Direct3dRMTexture3 *tex)
{
	HRESULT hr;
	
	
	D3DRMMATERIALOVERRIDE override2;	
	ZeroMemory(&override2,sizeof(D3DRMMATERIALOVERRIDE));
	override2.dwSize=sizeof(D3DRMMATERIALOVERRIDE);
	

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride(&override2);	
	if FAILED(hr) return hr;	

	if (override2.lpD3DRMTex) override2.lpD3DRMTex->Release();
	override2.lpD3DRMTex=NULL;

	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,t,tex);
	
	if (!tex) {
		hr= m__dxj_Direct3dRMFrame3->SetMaterialOverride(&override2);	
	}
	else {
		
		override2.lpD3DRMTex=t;
		override2.lpD3DRMTex->AddRef();
		hr= m__dxj_Direct3dRMFrame3->SetMaterialOverride(&override2);			
		override2.lpD3DRMTex->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getMaterialOverrideTexture(I_dxj_Direct3dRMTexture3 **tex)
{
	HRESULT hr;
	
	
	D3DRMMATERIALOVERRIDE override2;	
	ZeroMemory(&override2,sizeof(D3DRMMATERIALOVERRIDE));
	override2.dwSize=sizeof(D3DRMMATERIALOVERRIDE);
	

	hr= m__dxj_Direct3dRMFrame3->GetMaterialOverride(&override2);	
	if FAILED(hr) return hr;	

	if (override2.lpD3DRMTex){
		INTERNAL_CREATE(_dxj_Direct3dRMTexture3,override2.lpD3DRMTex,tex);
		return hr;
	}
	
	*tex=NULL;
	return S_OK;;
}


STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVisual(long index,I_dxj_Direct3dRMVisual **ret)
{
	HRESULT hr;
	DWORD count=0;
	IUnknown **ppUnk=NULL;
	IDirect3DRMVisual *vis=NULL;

	*ret=NULL;

	hr=m__dxj_Direct3dRMFrame3->GetVisuals(&count,NULL);
	if FAILED(hr) return hr;

	if (count==0) return E_INVALIDARG;

	ppUnk=(IUnknown**)malloc(sizeof(IUnknown*)*count);
	if (!ppUnk) return E_OUTOFMEMORY;

	hr=m__dxj_Direct3dRMFrame3->GetVisuals(&count,ppUnk);
	if FAILED(hr) goto exitOut;
	
	hr= ppUnk[index]->QueryInterface(IID_IDirect3DRMVisual,(void**)&vis);
	if FAILED(hr) goto exitOut;

	hr=CreateCoverVisual(vis,ret);
	if FAILED(hr) goto exitOut;

	
exitOut:

	for (DWORD i=0;i<count;i++){
		if (ppUnk[index]) ppUnk[index]->Release();
	}

	free(ppUnk);	

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getVisualCount (long *count)
{
	
	HRESULT hr=m__dxj_Direct3dRMFrame3->GetVisuals((DWORD*)count,NULL);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::setSceneFogMethod (long meth)
{
	
	HRESULT hr=m__dxj_Direct3dRMFrame3->SetSceneFogMethod(meth);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrame3Object::getSceneFogMethod (long *meth)
{
	
	HRESULT hr=m__dxj_Direct3dRMFrame3->GetSceneFogMethod((DWORD*)meth);
	return hr;
}

			

/////////////////////////////////////////////////////////////////////////////
extern "C" void __cdecl myFrameMoveCallback3( LPDIRECT3DRMFRAME3 lpf, void *lpArg, D3DVALUE delta)
{

	DPF(1,"Entered myFrameMoveCallback3\r\n");


	FrameMoveCallback3 *fmcb = (FrameMoveCallback3 *)lpArg;

	// note: need to get OUR frame object from the direct frame object, if
	//         one exists. If not, we have a crisis!
	for( C_dxj_Direct3dRMFrame3Object *that = (C_dxj_Direct3dRMFrame3Object *)g_dxj_Direct3dRMFrame3; that ; that = (C_dxj_Direct3dRMFrame3Object *)that->nextobj )
	{
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3, f, that)
		if( f == lpf )
		{
			if (fmcb->pUser) fmcb->pUser->AddRef();
			
			IUNK(that)->AddRef();
		
			fmcb->c->callbackRMFrameMove(that,fmcb->pUser, delta);

			IUNK(that)->Release();

			if (fmcb->pUser) fmcb->pUser->Release();


			return;
		}
	}

	//
	// I didn't create this frame, create a new one 
	//
	C_dxj_Direct3dRMFrame3Object *c=new CComObject<C_dxj_Direct3dRMFrame3Object>;
	I_dxj_Direct3dRMFrame3 *Iframe=NULL;
	if( c == NULL )
	{ 
		lpf->Release(); 
		return;
	} 
	c->InternalSetObject((LPDIRECT3DRMFRAME3)lpf);
	
	if ( fmcb->pParent )
	{
		c->parent = fmcb->pParent;
		fmcb->pParent->AddRef();
	}
	if (FAILED(((I_dxj_Direct3dRMFrame3*)c)->QueryInterface(IID_I_dxj_Direct3dRMFrame3, (void **)&Iframe))) 
	{
		delete c;
		return;
	}

	c->pinterface = Iframe; 
	
	if (fmcb->pUser) fmcb->pUser->AddRef();

	IUNK(Iframe)->AddRef();
	
	fmcb->c->callbackRMFrameMove(Iframe, fmcb->pUser, delta);
	
	IUNK(Iframe)->Release();
	
	if (fmcb->pUser) fmcb->pUser->Release();


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmframearrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmframearrayobj.h
//
//--------------------------------------------------------------------------

// d3drmFrameArrayObj.h : Declaration of the C_dxj_Direct3dRMFrameArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMFrameArray LPDIRECT3DRMFRAMEARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMFrameArrayObject : 
	
	//public CComDualImpl<I_dxj_Direct3dRMFrameArray, &IID_I_dxj_Direct3dRMFrameArray, &LIBID_DIRECTLib>, 
	//public ISupportErrorInfo,
	public I_dxj_Direct3dRMFrameArray,
	//public CComCoClass<C_dxj_Direct3dRMFrameArrayObject, &CLSID__dxj_Direct3dRMFrameArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFrameArrayObject() ;
	virtual ~C_dxj_Direct3dRMFrameArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMFrameArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFrameArray)
		//COM_INTERFACE_ENTRY(IDispatch)
		//COM_INTERFACE_ENTRY(ISupportErrorInfo)

	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMFrameArray,	"DIRECT.Direct3dRMFrameArray.3",	"DIRECT.Direct3dRMFrameArray.3",   IDS_D3DRMFRAMEARRAY_DESC,   THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMFrameArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFrameArrayObject)
	

	//STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// I_dxj_Direct3dRMFrameArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)(long *retval);

#if DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFrame2 **lplpD3DRMFrame);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMFrame3 **lplpD3DRMFrame);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMFrameArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFrameArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmframeinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframeinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFrameInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMFrameInterpolator;


//CONSTRUCTOR(_dxj_Direct3dRMViewport2, {});
//DESTRUCTOR(_dxj_Direct3dRMViewport2, {});

C_dxj_Direct3dRMFrameInterpolatorObject::C_dxj_Direct3dRMFrameInterpolatorObject(){
	m__dxj_Direct3dRMFrameInterpolator=NULL;
	m__dxj_Direct3dRMFrame3=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMFrameInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMFrameInterpolator;
	g_dxj_Direct3dRMFrameInterpolator = (void *)this;
}


C_dxj_Direct3dRMFrameInterpolatorObject::~C_dxj_Direct3dRMFrameInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMFrameInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMFrameInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMFrameInterpolatorObject *ptr=(C_dxj_Direct3dRMFrameInterpolatorObject *)g_dxj_Direct3dRMFrameInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMFrameInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMFrameInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMFrameInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMFrameInterpolator)->Release(); 
		
		DPF1(1,"DirectX real IDirect3dRMFrameInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMFrameInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMFrame3)
			m__dxj_Direct3dRMFrame3->Release();

}


DWORD C_dxj_Direct3dRMFrameInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMFrameInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMFrameInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMFrameInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMFrameInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMFrameInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMFrame3,(void**)&m__dxj_Direct3dRMFrame3);	
	return hr;
}



HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMFrameInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMFrameInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
HRESULT  C_dxj_Direct3dRMFrameInterpolatorObject::getAttachedObjects( /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMFrameInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	
	return S_OK;
}
        

HRESULT  C_dxj_Direct3dRMFrameInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMFrameInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMFrameInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMFrameInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMFrameInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;
	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	
	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	




	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

 	hr= m__dxj_Direct3dRMFrameInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();			
		

	

	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setVelocity( I_dxj_Direct3dRMFrame3 *reference, d3dvalue x, d3dvalue y, 
									d3dvalue z, long with_rotation)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, reference);

	m__dxj_Direct3dRMFrame3->SetVelocity((LPDIRECT3DRMFRAME3)lpf, x, y, z, with_rotation);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setOrientation( I_dxj_Direct3dRMFrame3 *reference, d3dvalue dx,d3dvalue dy,d3dvalue dz, d3dvalue ux,d3dvalue uy,d3dvalue uz)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetOrientation((LPDIRECT3DRMFRAME3)f, dx, dy, dz, ux, uy, uz);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setPosition(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,d3dvalue z)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetPosition((LPDIRECT3DRMFRAME3)f, x, y, z);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setRotation(I_dxj_Direct3dRMFrame3 *reference,d3dvalue x,d3dvalue y,
											d3dvalue z,d3dvalue theta)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, f, reference);
	return m__dxj_Direct3dRMFrame3->SetRotation((LPDIRECT3DRMFRAME3)f, x, y, z, theta);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setQuaternion(I_dxj_Direct3dRMFrame3 *refer,D3dRMQuaternion *quat)
{
	DO_GETOBJECT_NOTNULL(IDirect3DRMFrame3*, f, refer);
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetQuaternion(f,(D3DRMQUATERNION*)quat);
	return hr;

}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setColor(long color)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetColor((D3DCOLOR)color);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setColorRGB(float r, float g, float b)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetColorRGB(r,g,b);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneBackground(long color)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackground((D3DCOLOR)color);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneBackgroundRGB(float r, float g, float b)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneBackgroundRGB(r,g,b);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneFogColor(long color)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneFogColor((D3DCOLOR)color);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMFrameInterpolatorObject::setSceneFogParams(float start, float end, float density)
{
	HRESULT hr;				
	hr= m__dxj_Direct3dRMFrame3->SetSceneFogParams(start,end,density);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmframeinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmframeinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMFrameInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMFrameInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMFrameInterpolatorObject : 
	public I_dxj_Direct3dRMFrameInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMFrameInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMFrameInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMFrameInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMFrameInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMFrameInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
        

         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
         HRESULT STDMETHODCALLTYPE setQuaternion( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            D3dRMQuaternion __RPC_FAR *quat);
        
         HRESULT STDMETHODCALLTYPE setRotation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ float theta);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long with_rotation);
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *reference,
            /* [in] */ float dx,
            /* [in] */ float dy,
            /* [in] */ float dz,
            /* [in] */ float ux,
            /* [in] */ float uy,
            /* [in] */ float uz);
        
         HRESULT STDMETHODCALLTYPE setSceneBackground( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneFogColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setSceneBackgroundRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setSceneFogParams( 
            /* [in] */ float start,
            /* [in] */ float end,
            /* [in] */ float density);
        
         HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);

    
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMFrameInterpolator);
	LPDIRECT3DRMFRAME3	m__dxj_Direct3dRMFrame3;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMFrameInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmlightinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmlightinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMLightInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMLightInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMLightInterpolatorObject : 
	public I_dxj_Direct3dRMLightInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMLightInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMLightInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMLightInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMLightInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMLightInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
        
         //HRESULT STDMETHODCALLTYPE setType( 
         //   /* [in] */ d3drmLightType t);
        
         HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor c);
        
         HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setRange( 
            /* [in] */ float rng);
        
         HRESULT STDMETHODCALLTYPE setUmbra( 
            /* [in] */ float u);
        
         HRESULT STDMETHODCALLTYPE setPenumbra( 
            /* [in] */ float p);
        
         HRESULT STDMETHODCALLTYPE setConstantAttenuation( 
            /* [in] */ float atn);
        
         HRESULT STDMETHODCALLTYPE setLinearAttenuation( 
            /* [in] */ float atn);
        
         HRESULT STDMETHODCALLTYPE setQuadraticAttenuation( 
            /* [in] */ float atn);


////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMLightInterpolator);
	LPDIRECT3DRMLIGHT	m__dxj_Direct3dRMLight;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMLightInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmlightobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmlightobj.cpp
//
//--------------------------------------------------------------------------

// d3drmLightObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmFrame3Obj.h"
#include "d3drmLightObj.h"

CONSTRUCTOR(_dxj_Direct3dRMLight, {});
DESTRUCTOR(_dxj_Direct3dRMLight, {});
GETSET_OBJECT(_dxj_Direct3dRMLight);

CLONE_R(_dxj_Direct3dRMLight,Direct3DRMLight);
GETNAME_R(_dxj_Direct3dRMLight);
SETNAME_R(_dxj_Direct3dRMLight);
GETCLASSNAME_R(_dxj_Direct3dRMLight);

ADDDESTROYCALLBACK_R(_dxj_Direct3dRMLight);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMLight);

GET_DIRECT_R(_dxj_Direct3dRMLight, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMLight, getColor, GetColor, d3dcolor);
GET_DIRECT_R(_dxj_Direct3dRMLight, getRange, GetRange, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getUmbra, GetUmbra, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getPenumbra, GetPenumbra, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getConstantAttenuation, GetConstantAttenuation, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getLinearAttenuation, GetLinearAttenuation, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getQuadraticAttenuation, GetQuadraticAttenuation, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMLight, getType, GetType, d3drmLightType);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMLight, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setColor, SetColor, d3dcolor);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setRange, SetRange, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setUmbra, SetUmbra, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setPenumbra, SetPenumbra, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setConstantAttenuation, SetConstantAttenuation, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setLinearAttenuation, SetLinearAttenuation, d3dvalue);
PASS_THROUGH1_R(_dxj_Direct3dRMLight, setQuadraticAttenuation, SetQuadraticAttenuation, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMLight, setColorRGB, SetColorRGB, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMLight, setType,  SetType, d3drmLightType, (enum _D3DRMLIGHTTYPE));

//RETURN_NEW_ITEM_R(_dxj_Direct3dRMLight, getEnableFrame, GetEnableFrame, _dxj_Direct3dRMFrame);
HRESULT C_dxj_Direct3dRMLightObject::getEnableFrame(I_dxj_Direct3dRMFrame3 **frame){
	HRESULT hr;
	IDirect3DRMFrame *realframe1=NULL;
	IDirect3DRMFrame3 *realframe=NULL;
	hr=m__dxj_Direct3dRMLight->GetEnableFrame(&realframe1);
	*frame=NULL;
	if FAILED(hr) return hr;

	if (realframe1){
		hr=realframe1->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realframe);
		if FAILED(hr) return hr;
		INTERNAL_CREATE(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realframe,frame);
	}
	return S_OK;

}

HRESULT C_dxj_Direct3dRMLightObject::setEnableFrame(I_dxj_Direct3dRMFrame3 *frame){
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
	IDirect3DRMFrame *realframe1=NULL;
	if (frame){
		frame->InternalGetObject((IUnknown**)&realframe);
		hr=realframe->QueryInterface(IID_IDirect3DRMFrame,(void**)&realframe1);
		if FAILED(hr) return hr;
	}
	
	hr=m__dxj_Direct3dRMLight->SetEnableFrame(realframe1);	

	if (realframe1) realframe1->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmlightinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmlightinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmLightInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMLightInterpolator;


C_dxj_Direct3dRMLightInterpolatorObject::C_dxj_Direct3dRMLightInterpolatorObject(){
	m__dxj_Direct3dRMLightInterpolator=NULL;
	m__dxj_Direct3dRMLight=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMLightInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMLightInterpolator;
	g_dxj_Direct3dRMLightInterpolator = (void *)this;
}


C_dxj_Direct3dRMLightInterpolatorObject::~C_dxj_Direct3dRMLightInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMLightInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMLightInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMLightInterpolatorObject *ptr=(C_dxj_Direct3dRMLightInterpolatorObject *)g_dxj_Direct3dRMLightInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMLightInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMLightInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMLightInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMLightInterpolator)->Release(); 
		
		DPF1(1,"DirectX real IDirect3dRMLightInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMLightInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMLight)
			m__dxj_Direct3dRMLight->Release();

}


DWORD C_dxj_Direct3dRMLightInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMLightInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMLightInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMLightInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMLightInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMLightInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMLightInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMLightInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMLight,(void**)&m__dxj_Direct3dRMLight);	
	return hr;
}



HRESULT C_dxj_Direct3dRMLightInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMLightInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMLightInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMLightInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
HRESULT  C_dxj_Direct3dRMLightInterpolatorObject::getAttachedObjects( I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMLightInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        
        

HRESULT  C_dxj_Direct3dRMLightInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMLightInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMLightInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMLightInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMLightInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);

	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	


	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMLightInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setType( long t)									
//{	
//	return m__dxj_Direct3dRMLight->SetType((D3DRMLIGHTTYPE)t);
//}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setColor( long c)									
{	
	return m__dxj_Direct3dRMLight->SetColor((DWORD)c);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setColorRGB( float r, float g, float b)
{	
	return m__dxj_Direct3dRMLight->SetColorRGB(r,g,b);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setRange(float r)
{	
	return m__dxj_Direct3dRMLight->SetRange(r);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setUmbra(float u)
{	
	return m__dxj_Direct3dRMLight->SetUmbra(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setPenumbra(float u)
{	
	return m__dxj_Direct3dRMLight->SetPenumbra(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setConstantAttenuation(float u)
{	
	return m__dxj_Direct3dRMLight->SetConstantAttenuation(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setLinearAttenuation(float u)
{	
	return m__dxj_Direct3dRMLight->SetLinearAttenuation(u);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMLightInterpolatorObject::setQuadraticAttenuation(float u)
{	
	return m__dxj_Direct3dRMLight->SetQuadraticAttenuation(u);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmlightarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmlightarrayobj.cpp
//
//--------------------------------------------------------------------------

// _dxj_Direct3dRMLightArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmLightArrayObj.h"
#include "d3drmLightObj.h"

CONSTRUCTOR(_dxj_Direct3dRMLightArray, {});
DESTRUCTOR(_dxj_Direct3dRMLightArray, {});
GETSET_OBJECT(_dxj_Direct3dRMLightArray);

GET_DIRECT_R(_dxj_Direct3dRMLightArray,getSize,GetSize, long)
RETURN_NEW_ITEM_CAST_1_R(_dxj_Direct3dRMLightArray,getElement,GetElement,_dxj_Direct3dRMLight,long,(DWORD))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmlightobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmlightobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_Direct3dRMLightObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMLight LPDIRECT3DRMLIGHT

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMLightObject : 
	public I_dxj_Direct3dRMLight,
	public I_dxj_Direct3dRMObject,
	//public CComCoClass<C_dxj_Direct3dRMLightObject, &CLSID__dxj_Direct3dRMLight>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMLightObject();
	virtual ~C_dxj_Direct3dRMLightObject();

	BEGIN_COM_MAP(C_dxj_Direct3dRMLightObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMLight)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

	//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMLight,		"DIRECT.Direct3dRMLight.3",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMLightObject)


// I_dxj_Direct3dRMLight
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);
	STDMETHOD(getColor)( d3dcolor *value);

// methods added
	STDMETHOD(setType)(d3drmLightType t);
	STDMETHOD(setColor)(d3dcolor c);
	STDMETHOD(setColorRGB)(d3dvalue r, d3dvalue g, d3dvalue b);
	STDMETHOD(setRange)(d3dvalue rng);
	STDMETHOD(setUmbra)(d3dvalue u);
	STDMETHOD(setPenumbra)(d3dvalue p);
	STDMETHOD(setConstantAttenuation)(d3dvalue atn);
	STDMETHOD(setLinearAttenuation)(d3dvalue atn);
	STDMETHOD(setQuadraticAttenuation)(d3dvalue atn);
	STDMETHOD(getRange)(d3dvalue *retval);
	STDMETHOD(getUmbra)(d3dvalue *retval);
	STDMETHOD(getPenumbra)(d3dvalue *retval);
	STDMETHOD(getConstantAttenuation)( d3dvalue *retval);
	STDMETHOD(getLinearAttenuation)( d3dvalue *retval);
	STDMETHOD(getQuadraticAttenuation)( d3dvalue *retval);
	STDMETHOD(getType)( d3drmLightType *retval);
	STDMETHOD(setEnableFrame)( I_dxj_Direct3dRMFrame3 *f);
	STDMETHOD(getEnableFrame)( I_dxj_Direct3dRMFrame3 **retval);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMLight);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMLight )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterial2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmmaterial2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmMaterial2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMaterial2Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMMaterial2, {});
DESTRUCTOR(_dxj_Direct3dRMMaterial2, {});
GETSET_OBJECT(_dxj_Direct3dRMMaterial2);

CLONE_R(_dxj_Direct3dRMMaterial2,Direct3DRMMaterial2);
GETNAME_R(_dxj_Direct3dRMMaterial2);
SETNAME_R(_dxj_Direct3dRMMaterial2);
GETCLASSNAME_R(_dxj_Direct3dRMMaterial2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMMaterial2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMMaterial2);

GET_DIRECT_R(_dxj_Direct3dRMMaterial2, getAppData, GetAppData, long);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMaterial2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMMaterial2, setPower, SetPower, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, setSpecular, SetSpecular, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, setAmbient,  SetAmbient, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, setEmissive, SetEmissive, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, getSpecular, GetSpecular, d3dvalue*, d3dvalue*, d3dvalue*);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, getEmissive, GetEmissive, d3dvalue*, d3dvalue*, d3dvalue*);
PASS_THROUGH3_R(_dxj_Direct3dRMMaterial2, getAmbient,  GetAmbient, d3dvalue*, d3dvalue*, d3dvalue*);
GET_DIRECT_R(_dxj_Direct3dRMMaterial2,	  getPower, GetPower, d3dvalue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmlightarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmlightarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmLightArrayObj.h : Declaration of the C_dxj_Direct3dRMLightArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMLightArray LPDIRECT3DRMLIGHTARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMLightArrayObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_Direct3dRMLightArray, &IID_I_dxj_Direct3dRMLightArray, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_Direct3dRMLightArray,
#endif
	//public CComCoClass<C_dxj_Direct3dRMLightArrayObject, &CLSID__dxj_Direct3dRMLightArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMLightArrayObject() ;
	virtual ~C_dxj_Direct3dRMLightArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMLightArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMLightArray)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMLightArray,	"DIRECT.Direct3dRMLightArray.3",	"DIRECT.Direct3dRMLightArray.3",   IDS_D3DRMLIGHTARRAY_DESC,   THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMLightArrayObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_Direct3dRMLightArrayObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// I_dxj_Direct3dRMLightArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    STDMETHOD(getSize)(long *retval);
    STDMETHOD(getElement)(long index, I_dxj_Direct3dRMLight **retval);

private:
    DECL_VARIABLE(_dxj_Direct3dRMLightArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMLightArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshbuilder3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshbuilder3obj.h
//
//--------------------------------------------------------------------------

// d3drmMeshBuilderObj.h : Declaration of the C_dxj_Direct3dRMMeshBuilderObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMeshBuilder3 LPDIRECT3DRMMESHBUILDER3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMMeshBuilder3Object : 
	public I_dxj_Direct3dRMMeshBuilder3,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMMeshBuilder3Object, &CLSID__dxj_Direct3dRMMeshBuilder3>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMeshBuilder3Object();
	virtual ~C_dxj_Direct3dRMMeshBuilder3Object();

	BEGIN_COM_MAP(C_dxj_Direct3dRMMeshBuilder3Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMeshBuilder3)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMeshBuilder3Object)

// I_dxj_Direct3dRMMeshBuilder
public:


        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE addFace( 
            /* [in] */ I_dxj_Direct3dRMFace2 __RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE addFaces( 
            /* [in] */ long vc,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *verexArray,
            /* [in] */ long nc,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *normalArray,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [retval][out] */ I_dxj_Direct3dRMFaceArray __RPC_FAR *__RPC_FAR *array);
        
        HRESULT STDMETHODCALLTYPE addFacesIndexed( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [retval][out] */ long __RPC_FAR *newFaceIndex);
        
        HRESULT STDMETHODCALLTYPE addFrame( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE addMesh( 
            /* [in] */ I_dxj_Direct3dRMMesh __RPC_FAR *m);
        
        HRESULT STDMETHODCALLTYPE addMeshBuilder( 
            /* [in] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *mb, long flags);
        
        HRESULT STDMETHODCALLTYPE addNormal( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [retval][out] */ int __RPC_FAR *index);
        
        HRESULT STDMETHODCALLTYPE addTriangles(             
            /* [in] */ long format,
            /* [in] */ long vertexcount,
            /* [in] */ void __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE addVertex( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [retval][out] */ int __RPC_FAR *index);
        
        HRESULT STDMETHODCALLTYPE createFace( 
            /* [retval][out] */ I_dxj_Direct3dRMFace2 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE createSubMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE deleteFace( 
            /* [in] */ I_dxj_Direct3dRMFace2 __RPC_FAR *face);
        
        HRESULT STDMETHODCALLTYPE deleteNormals( 
            /* [in] */ long id, long count);
        
        HRESULT STDMETHODCALLTYPE deleteSubMesh( 
            /* [in] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR *mesh);
        
        HRESULT STDMETHODCALLTYPE deleteVertices( 
            /* [in] */ long id, long count);
        
        HRESULT STDMETHODCALLTYPE empty();
        
        HRESULT STDMETHODCALLTYPE enableMesh( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE generateNormals( 
            float angle,
            long flags);
        
        HRESULT STDMETHODCALLTYPE getBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getColorSource( 
            /* [retval][out] */ d3drmColorSource __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE getEnable( 
            /* [retval][out] */ long __RPC_FAR *flags);
        
        HRESULT STDMETHODCALLTYPE getFace( 
            /* [in] */ long id,
            /* [retval][out] */ I_dxj_Direct3dRMFace2 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getFaceCount( 
            /* [retval][out] */ int __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getFaces( 
            /* [retval][out] */ I_dxj_Direct3dRMFaceArray __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGeometry(             
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *verexArray,
            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *normalArray,
            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *faceData);
        
        HRESULT STDMETHODCALLTYPE getNormal( 
            /* [in] */ long __MIDL_0016,
            /* [out][in] */ D3dVector __RPC_FAR *desc);
        
        HRESULT STDMETHODCALLTYPE getNormalCount( 
            /* [retval][out] */ long __RPC_FAR *n_cnt);
        
        HRESULT STDMETHODCALLTYPE getParentMesh( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dRMMeshBuilder3 __RPC_FAR **vis);
        
        HRESULT STDMETHODCALLTYPE getPerspective( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getQuality( 
            /* [retval][out] */ d3drmRenderQuality __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getSubMeshes( 
            /* [in] */ long count,
            /* [retval][out] */ SAFEARRAY **ppsa);
        
        HRESULT STDMETHODCALLTYPE getSubMeshCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getTextureCoordinates( 
            /* [in] */ long idx,
            /* [out][in] */ float __RPC_FAR *u,
            /* [out][in] */ float __RPC_FAR *v);
        
        HRESULT STDMETHODCALLTYPE getVertex( 
            /* [in] */ long id,
            /* [out][in] */ D3dVector __RPC_FAR *vec);
        
        HRESULT STDMETHODCALLTYPE getVertexColor( 
            /* [in] */ long index,
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getVertexCount( 
            /* [retval][out] */ int __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getFaceDataSize( 
            /* [retval][out] */ long __RPC_FAR *f_cnt);
        
        HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ long flags,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *c,
            /* [in] */ IUnknown __RPC_FAR *pUser);
        
        HRESULT STDMETHODCALLTYPE optimize();
        
        HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ BSTR fname,
            /* [in] */ d3drmXofFormat xFormat,
            /* [in] */ d3drmSaveFlags save);
        
        HRESULT STDMETHODCALLTYPE scaleMesh( 
            /* [in] */ float sx,
            /* [in] */ float sy,
            /* [in] */ float sz);
        
        HRESULT STDMETHODCALLTYPE setColor( 
            /* [in] */ d3dcolor col);
        
        HRESULT STDMETHODCALLTYPE setColorRGB( 
            /* [in] */ float red,
            /* [in] */ float green,
            /* [in] */ float blue);
        
        HRESULT STDMETHODCALLTYPE setColorSource( 
            /* [in] */ d3drmColorSource val);
        
        HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *mat);
        
        HRESULT STDMETHODCALLTYPE setNormal( 
            /* [in] */ long idx,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
        HRESULT STDMETHODCALLTYPE setPerspective( 
            /* [in] */ long persp);
        
        HRESULT STDMETHODCALLTYPE setQuality( 
            /* [in] */ d3drmRenderQuality q);
        
        HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setTextureCoordinates( 
            /* [in] */ long idx,
            /* [in] */ float u,
            /* [in] */ float v);
        
        HRESULT STDMETHODCALLTYPE setTextureTopology( 
            /* [in] */ long wrap_u,
            /* [in] */ long wrap_v);
        
        HRESULT STDMETHODCALLTYPE setVertex( 
            /* [in] */ long idx,
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z);
        
        HRESULT STDMETHODCALLTYPE setVertexColor( 
            /* [in] */ long idx,
            /* [in] */ d3dcolor c);
        
        HRESULT STDMETHODCALLTYPE setVertexColorRGB( 
            /* [in] */ long idx,
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
        HRESULT STDMETHODCALLTYPE translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE addFacesJava( 
            /* [in] */ long vc,
            /* [in] */ float __RPC_FAR *ver,
            /* [in] */ long nc,
            /* [in] */ float __RPC_FAR *norm,
            /* [in] */ long __RPC_FAR *data,
            /* [retval][out] */ I_dxj_Direct3dRMFaceArray __RPC_FAR *__RPC_FAR *array);
        
////////////////////////////////////////////////////////////////////////////////////

private:
    DECL_VARIABLE(_dxj_Direct3dRMMeshBuilder3);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMeshBuilder3 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMeshInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMMeshInterpolator;


C_dxj_Direct3dRMMeshInterpolatorObject::C_dxj_Direct3dRMMeshInterpolatorObject(){
	m__dxj_Direct3dRMMeshInterpolator=NULL;
	m__dxj_Direct3dRMMesh=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMMeshInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMMeshInterpolator;
	g_dxj_Direct3dRMMeshInterpolator = (void *)this;
}


C_dxj_Direct3dRMMeshInterpolatorObject::~C_dxj_Direct3dRMMeshInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMMeshInterpolator [%d] \n",creationid); 

	
	C_dxj_Direct3dRMMeshInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMMeshInterpolatorObject *ptr=(C_dxj_Direct3dRMMeshInterpolatorObject *)g_dxj_Direct3dRMMeshInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMMeshInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMMeshInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMMeshInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMMeshInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMMeshInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMMeshInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMMesh)
			m__dxj_Direct3dRMMesh->Release();

}


DWORD C_dxj_Direct3dRMMeshInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMMeshInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMMeshInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMMeshInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMMeshInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMMeshInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMMesh,(void**)&m__dxj_Direct3dRMMesh);	
	return hr;
}



HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMeshInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMeshInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        

HRESULT  C_dxj_Direct3dRMMeshInterpolatorObject::getAttachedObjects( /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMMeshInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        

HRESULT  C_dxj_Direct3dRMMeshInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMMeshInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMMeshInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMMeshInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMMeshInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;

	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	
	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	
	if (options & D3DRMINTERPOLATION_VERTEXCOLOR)
		opt2=opt2 | D3DRMINTERPOLATION_VERTEXCOLOR;


	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMMeshInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4= pObj->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::setVertices( d3drmGroupIndex id, long idx, long cnt, SAFEARRAY **ppsa)
{
	HRESULT hr;
	//
	// Go through and reformat all the float color values back
	// to long, so the array of floats now looks like an array 
	// D3DRMVERTEXES
	//
	if (!ISSAFEARRAY1D(ppsa,(DWORD)cnt))
		return E_INVALIDARG;

	
	D3DRMVERTEX *values= (D3DRMVERTEX*)((SAFEARRAY*)*ppsa)->pvData;
	__try{
		hr=m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx,(DWORD) cnt, (struct _D3DRMVERTEX *)values);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz) {

	return m__dxj_Direct3dRMMesh->Translate(tx,ty,tz);
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::setGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3dcolor val) {

	return m__dxj_Direct3dRMMesh->SetGroupColor((DWORD)id,(D3DCOLOR)val);
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshInterpolatorObject::setGroupColorRGB( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ float r,
					   float g,
					   float b) {

	return m__dxj_Direct3dRMMesh->SetGroupColorRGB((DWORD)id,r,g,b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMMeshInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMeshInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMMeshInterpolatorObject : 
	public I_dxj_Direct3dRMMeshInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMeshInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMMeshInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMMeshInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMeshInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMeshInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        

         HRESULT STDMETHODCALLTYPE translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz) ;
        
         HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *vertexArray);
        
         HRESULT STDMETHODCALLTYPE setGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3dcolor val);
        
         HRESULT STDMETHODCALLTYPE setGroupColorRGB( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b) ;

////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMMeshInterpolator);
	LPDIRECT3DRMMESH	m__dxj_Direct3dRMMesh;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMeshInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterial2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmmaterial2obj.h
//
//--------------------------------------------------------------------------

// d3drmMaterial2Obj.h : Declaration of the C_dxj_Direct3dRMMaterial2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMaterial2 LPDIRECT3DRMMATERIAL2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMMaterial2Object : 
	public I_dxj_Direct3dRMMaterial2,
	public I_dxj_Direct3dRMObject,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMaterial2Object() ;
	virtual ~C_dxj_Direct3dRMMaterial2Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMMaterial2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMaterial2)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()
	

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMaterial2Object)

// I_dxj_Direct3dRMMaterial2
public:
         HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE setPower( 
            /* [in] */ float power);
        
         HRESULT STDMETHODCALLTYPE setSpecular( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setEmissive( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE setAmbient( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
         HRESULT STDMETHODCALLTYPE getPower( 
            /* [retval][out] */ float __RPC_FAR *power);
        
         HRESULT STDMETHODCALLTYPE getSpecular( 
            /* [out] */ float __RPC_FAR *r,
            /* [out] */ float __RPC_FAR *g,
            /* [out] */ float __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getEmissive( 
            /* [out] */ float __RPC_FAR *r,
            /* [out] */ float __RPC_FAR *g,
            /* [out] */ float __RPC_FAR *b);
        
         HRESULT STDMETHODCALLTYPE getAmbient( 
            /* [out] */ float __RPC_FAR *r,
            /* [out] */ float __RPC_FAR *g,
            /* [out] */ float __RPC_FAR *b);
        

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMMaterial2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMaterial2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterialinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmaterialinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMMaterialInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMaterialInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMMaterialInterpolatorObject : 
	public I_dxj_Direct3dRMMaterialInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMaterialInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMMaterialInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMMaterialInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMaterialInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMaterialInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        

         HRESULT STDMETHODCALLTYPE setPower( 
            /* [in] */ float power);
        
         HRESULT STDMETHODCALLTYPE setSpecular( 
            /* [in] */ float red,
            /* [in] */ float green,
            /* [in] */ float blue);
        
         HRESULT STDMETHODCALLTYPE setEmissive( 
            /* [in] */ float red,
            /* [in] */ float green,
            /* [in] */ float blue);
        

////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMMaterialInterpolator);
	LPDIRECT3DRMMATERIAL2	m__dxj_Direct3dRMMaterial2;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMaterialInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmaterialinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmaterialinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMaterialInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMMaterialInterpolator;


C_dxj_Direct3dRMMaterialInterpolatorObject::C_dxj_Direct3dRMMaterialInterpolatorObject(){
	m__dxj_Direct3dRMMaterialInterpolator=NULL;
	m__dxj_Direct3dRMMaterial2=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	
	
	DPF1(1,"Constructor Creation  Direct3dRMMaterialInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMMaterialInterpolator;
	g_dxj_Direct3dRMMaterialInterpolator = (void *)this;
}


C_dxj_Direct3dRMMaterialInterpolatorObject::~C_dxj_Direct3dRMMaterialInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMMaterialInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMMaterialInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMMaterialInterpolatorObject *ptr=(C_dxj_Direct3dRMMaterialInterpolatorObject *)g_dxj_Direct3dRMMaterialInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMMaterialInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMMaterialInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMMaterialInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMMaterialInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMMaterialInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMMaterialInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMMaterial2)
			m__dxj_Direct3dRMMaterial2->Release();

}


DWORD C_dxj_Direct3dRMMaterialInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMMaterialInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMMaterialInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMMaterialInterpolator [%d] Release %d \n",creationid,i);

	return i;
}



HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMMaterialInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMMaterialInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMMaterial2,(void**)&m__dxj_Direct3dRMMaterial2);	
	return hr;
}



HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMaterialInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMMaterialInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
        

HRESULT  C_dxj_Direct3dRMMaterialInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMMaterialInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMMaterialInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMMaterialInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;

	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);

		//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	

	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMMaterialInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}


HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::setPower( float p)
{
	return m__dxj_Direct3dRMMaterial2->SetPower(p);
}

HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::setSpecular( float r,float g, float b)
{
	return m__dxj_Direct3dRMMaterial2->SetSpecular(r,g,b);
}

HRESULT C_dxj_Direct3dRMMaterialInterpolatorObject::setEmissive( float r,float g, float b)
{
	return m__dxj_Direct3dRMMaterial2->SetEmissive(r,g,b);
}


HRESULT  C_dxj_Direct3dRMMaterialInterpolatorObject::getAttachedObjects( /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMMaterialInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshbuilder3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshbuilder3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmMeshBuilderObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmMeshObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmFace2Obj.h"
#include "d3drmFaceArrayObj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmVisualObj.h"

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_Direct3dRMMeshBuilder3, {});
DESTRUCTOR(_dxj_Direct3dRMMeshBuilder3, {});
GETSET_OBJECT(_dxj_Direct3dRMMeshBuilder3);

CLONE_R(_dxj_Direct3dRMMeshBuilder3,Direct3DRMMeshBuilder3);
GETNAME_R(_dxj_Direct3dRMMeshBuilder3);
SETNAME_R(_dxj_Direct3dRMMeshBuilder3);
GETCLASSNAME_R(_dxj_Direct3dRMMeshBuilder3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMMeshBuilder3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMMeshBuilder3);

//CLONETO_RX(_dxj_Direct3dRMMeshBuilder3, MeshBuilder3, IID_IDirect3DRMMeshBuilder3);

PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMMeshBuilder3, generateNormals, GenerateNormals, float,(float),long,(DWORD));

PASS_THROUGH1_R(_dxj_Direct3dRMMeshBuilder3, setQuality, SetQuality, d3drmRenderQuality)
PASS_THROUGH1_R(_dxj_Direct3dRMMeshBuilder3, setColor, SetColor, d3dcolor)
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMeshBuilder3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMMeshBuilder3, setPerspective, SetPerspective, long); //BOOL
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMMeshBuilder3, setVertexColor, SetVertexColor, long,(DWORD),d3dcolor,(DWORD));
PASS_THROUGH3_R(_dxj_Direct3dRMMeshBuilder3, setColorRGB,SetColorRGB,d3dvalue,d3dvalue,d3dvalue)
PASS_THROUGH3_R(_dxj_Direct3dRMMeshBuilder3, scaleMesh, Scale, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMeshBuilder3, translate, Translate, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH2_R(_dxj_Direct3dRMMeshBuilder3, setTextureTopology, SetTextureTopology, long, long); //BOOL
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMMeshBuilder3, setTextureCoordinates, SetTextureCoordinates, long,(DWORD), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMMeshBuilder3, getTextureCoordinates, GetTextureCoordinates, long,(DWORD), d3dvalue*,(float*), d3dvalue*,(float*));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMMeshBuilder3, setVertexColorRGB, SetVertexColorRGB, long,(DWORD), d3dvalue,(float), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMeshBuilder3, setColorSource, SetColorSource, d3drmColorSource, (enum _D3DRMCOLORSOURCE));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMeshBuilder3, getBox, GetBox, D3dRMBox *,(D3DRMBOX *))
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getQuality, GetQuality, d3drmRenderQuality);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getPerspective, GetPerspective, long);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getVertexCount, GetVertexCount, int);
GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getColorSource, GetColorSource, d3drmColorSource);
GET_DIRECT1_R(_dxj_Direct3dRMMeshBuilder3, getVertexColor, GetVertexColor, d3dcolor, long);


PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMMeshBuilder3, setVertex, SetVertex, long,(DWORD), d3dvalue,(float), d3dvalue,(float), d3dvalue,(float));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMMeshBuilder3, setNormal, SetNormal, long,(DWORD), d3dvalue,(float), d3dvalue,(float), d3dvalue,(float));

GET_DIRECT_R(_dxj_Direct3dRMMeshBuilder3, getFaceCount, GetFaceCount, int );

DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMMeshBuilder3, addMesh, AddMesh, _dxj_Direct3dRMMesh);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMMeshBuilder3, addFace, AddFace, _dxj_Direct3dRMFace2);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dRMMeshBuilder3, setMaterial, SetMaterial, _dxj_Direct3dRMMaterial2)


RETURN_NEW_ITEM_R(_dxj_Direct3dRMMeshBuilder3, getFaces, GetFaces, _dxj_Direct3dRMFaceArray);
RETURN_NEW_ITEM_R(_dxj_Direct3dRMMeshBuilder3, createMesh,CreateMesh,_dxj_Direct3dRMMesh)
RETURN_NEW_ITEM_R(_dxj_Direct3dRMMeshBuilder3, createFace, CreateFace, _dxj_Direct3dRMFace2);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addVertex(d3dvalue x, d3dvalue y, d3dvalue z, int *index)
{
	*index = m__dxj_Direct3dRMMeshBuilder3->AddVertex(x,y,z);
	return S_OK;			
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addNormal(d3dvalue x, d3dvalue y, d3dvalue z, int *index)
{
	*index = m__dxj_Direct3dRMMeshBuilder3->AddNormal(x,y,z);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//FOR JAVA
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFacesJava(long vcount, float *vertices, 
							long ncount, float *normals, long *data, I_dxj_Direct3dRMFaceArray **array)
{
	HRESULT hr;
	LPDIRECT3DRMFACEARRAY lpArray;
	__try{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddFaces((DWORD)vcount/3, (struct _D3DVECTOR *)vertices, ncount/3, (struct _D3DVECTOR *)normals, (unsigned long *)data, &lpArray);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	INTERNAL_CREATE(_dxj_Direct3dRMFaceArray, lpArray, array);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//STDMETHOD(Save)(BSTR fname, d3drmXofFormat format, d3dSaveOptions save);
//
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::save(BSTR Name, d3drmXofFormat ft, d3drmSaveFlags op) 
{


	USES_CONVERSION;
	LPCTSTR pszName = W2T(Name);				// Now convert to ANSI
	return m__dxj_Direct3dRMMeshBuilder3->Save(pszName, (enum _D3DRMXOFFORMAT)ft, (DWORD) op );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::loadFromFile(BSTR filename, VARIANT id, long flags, I_dxj_Direct3dRMLoadTextureCallback3 *callme, IUnknown *useMe)
{
	D3DRMLOADTEXTURE3CALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback3 *tcb = NULL;
	HRESULT hr;


	if( callme )
	{
		tcb = new TextureCallback3;

		if( tcb )
		{
			tcb->c				= callme;
			tcb->pUser			= useMe;
			tcb->next			= TextureCallbacks3;
			tcb->prev			= (TextureCallback3*)NULL;
			TextureCallbacks3	= tcb;

			d3dtcb = myLoadTextureCallback3;
			pArgs = (void *)tcb;
		}
		else
		{

			DPF(1,"Callback object creation failed!\r\n");

			return E_FAIL;
		}
	}
	USES_CONVERSION;
	LPCTSTR pszName = W2T(filename);

	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		args=(void*)W2T(V_BSTR(&id));
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);

	if (flags &D3DRMLOAD_FROMRESOURCE){
		D3DRMLOADRESOURCE res;
		ZeroMemory(&res,sizeof(D3DRMLOADRESOURCE));
		res.lpName=pszName;
		res.lpType="XFILE";
		hr = m__dxj_Direct3dRMMeshBuilder3->Load((void *)&res, (DWORD*)args,(DWORD) flags,d3dtcb, pArgs);
	}
	else {
		hr = m__dxj_Direct3dRMMeshBuilder3->Load((void *)pszName, (DWORD*)args,(DWORD) flags,d3dtcb, pArgs);
	}
	// Remove ourselves in a thread-safe manner.
	if (tcb)
		UndoCallbackLink((GeneralCallback*)tcb, 
							(GeneralCallback**)&TextureCallbacks3);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getNormalCount(long *retval)
{
	DWORD vc=0, nc=0, fsize=0;

	//Get facedata size only. The other tqo sizes are ignored.
	*retval= m__dxj_Direct3dRMMeshBuilder3->GetNormalCount();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getFaceDataSize(long *retval)
{
	DWORD vc=0, nc=0, fsize=0;

	//Get facedata size only. The other tqo sizes are ignored.
	return m__dxj_Direct3dRMMeshBuilder3->GetGeometry(&vc, (struct _D3DVECTOR *)NULL, 
					  &nc, (struct _D3DVECTOR *)NULL, (DWORD*)retval, (DWORD*)NULL);	
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFrame(I_dxj_Direct3dRMFrame3 *frame){
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFRAME3,lpFrame,frame);
	return m__dxj_Direct3dRMMeshBuilder3->AddFrame(lpFrame); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::setTexture(I_dxj_Direct3dRMTexture3 *tex){
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,lpTex,tex);
	return m__dxj_Direct3dRMMeshBuilder3->SetTexture(lpTex); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addMeshBuilder(I_dxj_Direct3dRMMeshBuilder3 *mb, long flags){
	DO_GETOBJECT_NOTNULL(LPDIRECT3DRMMESHBUILDER3,lpMb,mb);
	return m__dxj_Direct3dRMMeshBuilder3->AddMeshBuilder(lpMb,(DWORD)flags); 
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getGeometry( SAFEARRAY **ppv, 
					 SAFEARRAY **ppn,  SAFEARRAY **ppfdata)
{
	DWORD vc,nc,fsize;

	if (!ppv) return E_INVALIDARG;
	if (!ppn) return E_INVALIDARG;
	if (!ppfdata) return E_INVALIDARG;
	
	vc= (*ppv)->cbElements;
	nc= (*ppn)->cbElements;
	fsize= (*ppfdata)->cbElements;

	//if (!ISSAFEARRAY1D(ppv,(DWORD)vc)) return E_INVALIDARG;
	//if (!ISSAFEARRAY1D(ppn,(DWORD)nc)) return E_INVALIDARG;
	//if (!ISSAFEARRAY1D(ppfdata,(DWORD)fsize)) return E_INVALIDARG;

	return m__dxj_Direct3dRMMeshBuilder3->GetGeometry((DWORD*)&vc, (struct _D3DVECTOR *)((SAFEARRAY*)*ppv)->pvData, (DWORD*)&nc, 
		(struct _D3DVECTOR *)((SAFEARRAY*)*ppn)->pvData, (unsigned long *)fsize, (unsigned long *) ((SAFEARRAY*)*ppfdata)->pvData);
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFaces(long vcount, SAFEARRAY **ppv, 
					long ncount, SAFEARRAY **ppn,  SAFEARRAY **ppfdata, I_dxj_Direct3dRMFaceArray **array)
{
	HRESULT hr;
	LPDIRECT3DRMFACEARRAY lpArray;
	
	__try
	{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddFaces(
			(DWORD)vcount,	(struct _D3DVECTOR *)((SAFEARRAY*)*ppv)->pvData, 
			(DWORD)ncount, (struct _D3DVECTOR *)((SAFEARRAY*)*ppn)->pvData,
			(unsigned long *)((SAFEARRAY*)*ppfdata)->pvData, &lpArray);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMFaceArray, lpArray, array);

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addFacesIndexed( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [retval][out] */ long __RPC_FAR *newFaceIndex)
{
	HRESULT hr;
	__try
	{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddFacesIndexed(
			(DWORD)flags,	(DWORD *)((SAFEARRAY*)*indexArray)->pvData, 
			(DWORD*)newFaceIndex, NULL);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	return hr;

	
}



STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::addTriangles(             
			/* [in] */ long format,
			/* [in] */ long vertexCount,
            /* [in] */ void *data)
{
	HRESULT hr;
	__try
	{
		hr = m__dxj_Direct3dRMMeshBuilder3->AddTriangles(
			(DWORD)0,	(DWORD) format, (DWORD) vertexCount,
			data);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	return hr;
	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::createSubMesh( 
            I_dxj_Direct3dRMMeshBuilder3 **ret)
{
	HRESULT hr;
	LPUNKNOWN pUnk=NULL;
	LPDIRECT3DRMMESHBUILDER3 pMesh3=NULL;

	*ret =NULL;

	hr = m__dxj_Direct3dRMMeshBuilder3->CreateSubMesh(&pUnk);
	if FAILED(hr) return hr;

	if (!pUnk) return E_FAIL;

	hr = pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&pMesh3);
	pUnk->Release();
	if FAILED(hr) return hr;		
	

	INTERNAL_CREATE(_dxj_Direct3dRMMeshBuilder3,pMesh3,ret);

	return hr;	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteFace( I_dxj_Direct3dRMFace2 *face)

{
		HRESULT hr;				
		if (!face) return E_INVALIDARG;

		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMFACE2,pFace,face);
		__try {
			hr = m__dxj_Direct3dRMMeshBuilder3->DeleteFace(pFace);
		}
		__except(1,1){
			return E_FAIL;
		}
		return hr;

}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteNormals( long id, long count)
{
	HRESULT hr;

	hr = m__dxj_Direct3dRMMeshBuilder3->DeleteNormals((DWORD)id,(DWORD)count);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteVertices(long id, long count)
{
	HRESULT hr;
	__try {
		hr = m__dxj_Direct3dRMMeshBuilder3->DeleteVertices((DWORD)id,(DWORD) count);
	}
	__except(1,1){
		return E_FAIL;
	}
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::empty()
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->Empty((DWORD)0);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::enableMesh(long flags)
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->Enable((DWORD)flags);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getEnable(long *flags)
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->GetEnable((DWORD*)flags);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getFace(long index, I_dxj_Direct3dRMFace2 **face)
{
	HRESULT hr;
	LPDIRECT3DRMFACE2 pFace=NULL;
	*face=NULL;
	hr = m__dxj_Direct3dRMMeshBuilder3->GetFace((DWORD)index,&pFace);
	if FAILED(hr) return hr;
	if (!pFace) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3dRMFace2,pFace,face);
	return hr;	
}




STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getNormal(long index, D3dVector *vec)
{
	HRESULT hr;	
	hr = m__dxj_Direct3dRMMeshBuilder3->GetNormal((DWORD)index,(D3DVECTOR*)vec);
	return hr;	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getVertex(long index, D3dVector *vec)
{
	HRESULT hr;	
	hr = m__dxj_Direct3dRMMeshBuilder3->GetVertex((DWORD)index,(D3DVECTOR*)vec);
	return hr;	
}
        
STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::optimize()
{
	HRESULT hr;	
	hr = m__dxj_Direct3dRMMeshBuilder3->Optimize((DWORD)0);
	return hr;	
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::deleteSubMesh( 
            I_dxj_Direct3dRMMeshBuilder3 *mesh)

{
		HRESULT hr;				
		if (!mesh) return E_INVALIDARG;

		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMMESHBUILDER3,pMesh,mesh);
		hr = m__dxj_Direct3dRMMeshBuilder3->DeleteSubMesh(pMesh);
		return hr;

}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getParentMesh(long flags, 
            I_dxj_Direct3dRMMeshBuilder3 **mesh)
{
		HRESULT hr;						
		
		LPUNKNOWN pUnk=NULL;
		LPDIRECT3DRMMESHBUILDER3 pMesh=NULL;

		hr = m__dxj_Direct3dRMMeshBuilder3->GetParentMesh((DWORD)flags,&pUnk);
		if FAILED(hr) return hr;

		if (pUnk==NULL){
			*mesh=NULL;
			return S_OK;
		}

		hr= pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&pMesh);
		pUnk->Release();
		if FAILED(hr) return hr;
			
		INTERNAL_CREATE(_dxj_Direct3dRMMeshBuilder3,pMesh,mesh);

		return hr;

}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getSubMeshCount(long *count)
{
	HRESULT hr;
	hr = m__dxj_Direct3dRMMeshBuilder3->GetSubMeshes((DWORD*)count,NULL);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshBuilder3Object::getSubMeshes(long count,SAFEARRAY **psa)
{
	HRESULT hr;
	__try{
		hr = m__dxj_Direct3dRMMeshBuilder3->GetSubMeshes((DWORD*)&count,(IUnknown**)((SAFEARRAY*)*psa)->pvData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshobj.cpp
//
//--------------------------------------------------------------------------

// d3drmMeshObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmMeshObj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmTexture3Obj.h"

CONSTRUCTOR( _dxj_Direct3dRMMesh, {});
DESTRUCTOR(_dxj_Direct3dRMMesh, {});
GETSET_OBJECT(_dxj_Direct3dRMMesh);

CLONE_R(_dxj_Direct3dRMMesh,Direct3DRMMesh);
GETNAME_R(_dxj_Direct3dRMMesh);
SETNAME_R(_dxj_Direct3dRMMesh);
GETCLASSNAME_R(_dxj_Direct3dRMMesh);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMMesh);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMMesh);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMesh, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH2_R(_dxj_Direct3dRMMesh, setGroupColor,SetGroupColor,d3drmGroupIndex, d3dcolor);
PASS_THROUGH2_R(_dxj_Direct3dRMMesh, setGroupMapping,SetGroupMapping,d3drmGroupIndex,d3drmMappingFlags);
PASS_THROUGH2_R(_dxj_Direct3dRMMesh, setGroupQuality,SetGroupQuality,d3drmGroupIndex,d3drmRenderQuality);
PASS_THROUGH3_R(_dxj_Direct3dRMMesh, scaleMesh, Scale, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH3_R(_dxj_Direct3dRMMesh, translate, Translate, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMMesh, setGroupColorRGB,SetGroupColorRGB,d3drmGroupIndex,d3dvalue,d3dvalue,d3dvalue);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMMesh, getBox,GetBox, D3dRMBox*, (_D3DRMBOX*));


GET_DIRECT_R(_dxj_Direct3dRMMesh,  getAppData,		GetAppData,		long);
GET_DIRECT_R(_dxj_Direct3dRMMesh,  getGroupCount,	GetGroupCount,	long);
GET_DIRECT1_R(_dxj_Direct3dRMMesh, getGroupColor,	GetGroupColor,	d3dcolor, d3drmGroupIndex);
GET_DIRECT1_R(_dxj_Direct3dRMMesh, getGroupMapping, GetGroupMapping, d3drmMappingFlags, d3drmGroupIndex);
GET_DIRECT1_R(_dxj_Direct3dRMMesh, getGroupQuality, GetGroupQuality, d3drmRenderQuality, d3drmGroupIndex);



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::setVertex( d3drmGroupIndex id, long idx, D3dRMVertex *value)
{
	return m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx, 1, (struct _D3DRMVERTEX *)value);
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::setVertices( d3drmGroupIndex id, long idx, long cnt, SAFEARRAY **ppsa)
{
	HRESULT hr;
	//
	// Go through and reformat all the float color values back
	// to long, so the array of floats now looks like an array 
	// D3DRMVERTEXES
	//
	if (!ISSAFEARRAY1D(ppsa,(DWORD)cnt))
		return E_INVALIDARG;

	
	D3DRMVERTEX *values= (D3DRMVERTEX*)((SAFEARRAY*)*ppsa)->pvData;
	__try{
		hr=m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx,(DWORD) cnt, (struct _D3DRMVERTEX *)values);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::setVerticesJava( d3drmGroupIndex id, long idx, long cnt, float *vertData)
{
	HRESULT hr;
	
	__try {
		hr=m__dxj_Direct3dRMMesh->SetVertices((DWORD)id, (DWORD)idx,(DWORD) cnt, (struct _D3DRMVERTEX *)vertData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupDataSize( d3drmGroupIndex id, long *cnt)
{
	unsigned int *cnt1=0, *cnt2=0, *cnt3=0;

	return m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, cnt1, cnt2,
										cnt3, (DWORD*)cnt, (unsigned int *)NULL);
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVertexCount( d3drmGroupIndex id, long *cnt)
{
	unsigned int *cnt1=0, *cnt2=0;
	DWORD *cnt3=0;	
	return m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, (unsigned int*)cnt, (unsigned int*) cnt1,
										cnt2, cnt3, (unsigned int *)NULL);
}

        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVertices(d3drmGroupIndex id, long idx, long count, SAFEARRAY **ppsa )
{	
	HRESULT	hr;
	
	if (!ISSAFEARRAY1D(ppsa,(DWORD)count)) return E_INVALIDARG;
	D3DRMVERTEX *v=(D3DRMVERTEX *)((SAFEARRAY*)*ppsa)->pvData;

	__try {
		hr= m__dxj_Direct3dRMMesh->GetVertices((DWORD)id,(DWORD) idx, (DWORD)count, (struct _D3DRMVERTEX *)v);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVerticesJava(d3drmGroupIndex id, long idx, long count, float *vertData)
{	
	HRESULT	hr;
		
	__try {
		hr= m__dxj_Direct3dRMMesh->GetVertices((DWORD)id,(DWORD) idx, (DWORD)count, (struct _D3DRMVERTEX *)vertData);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getVertex(d3drmGroupIndex id, long idx, D3dRMVertex *v )
{
	DWORD count = 1;
	HRESULT	hr;
	
	hr= m__dxj_Direct3dRMMesh->GetVertices((DWORD)id,(DWORD) idx, (DWORD)count, (struct _D3DRMVERTEX *)v);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupTexture( d3drmGroupIndex id, I_dxj_Direct3dRMTexture3 **tex){
	HRESULT hr;
	IDirect3DRMTexture *realtex1=NULL;
	IDirect3DRMTexture3 *realtex3=NULL;
	
	*tex=NULL;

	hr=m__dxj_Direct3dRMMesh->GetGroupTexture((D3DRMGROUPINDEX)id,&realtex1);
	if FAILED(hr) return hr;

	if (!realtex1) return hr;

	hr=realtex1->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realtex3);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMTexture3,(IDirect3DRMTexture3*)realtex3,tex);

	realtex1->Release();

	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::setGroupTexture( d3drmGroupIndex id, I_dxj_Direct3dRMTexture3 *tex){
	HRESULT hr;
	IDirect3DRMTexture3 *realtex=NULL;
	IDirect3DRMTexture *realtex1=NULL;
	if (tex){
		tex->InternalGetObject((IUnknown**)&realtex);	//does not addref
		hr=realtex->QueryInterface(IID_IDirect3DRMTexture,(void**)&realtex1);
		if FAILED(hr) return hr;
	}

	hr=m__dxj_Direct3dRMMesh->SetGroupTexture((D3DRMGROUPINDEX)id,realtex1);
	
	if (realtex1)
		realtex1->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getSizes( d3drmGroupIndex id, long *cnt1,long *cnt2, long *cnt3, long *cnt4)
{

	//were in 32 bits so we can do this
	HRESULT hr= m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, (unsigned*)cnt1, (unsigned*)cnt2,
										(unsigned*)cnt3, (DWORD*)cnt4, (unsigned int *)NULL);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupData( d3drmGroupIndex id, SAFEARRAY **ppsa)
{
	DWORD s;

	//if (!ISSAFEARRAY1D(ppsa,(DWORD)size)) return E_INVALIDARG;
	if (!ppsa) return E_INVALIDARG;
	s= (*ppsa)->rgsabound->cElements;
 
	HRESULT hr;
	__try {
		 hr= m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, NULL, NULL, NULL,
										(DWORD*)&s, (unsigned*)((SAFEARRAY*)*ppsa)->pvData);
	}
	__except(1,1){
		return E_FAIL;
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupDataJava( d3drmGroupIndex id, long size, long *pFaceData)
{

	DWORD s=size;
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dRMMesh->GetGroup( (D3DRMGROUPINDEX)id, NULL, NULL, NULL,
										(DWORD*)&s, (unsigned*)pFaceData);
	}
	__except(1,1){
		return E_FAIL;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP C_dxj_Direct3dRMMeshObject::addGroup( 
             /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ppsa,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *pretId)

{
	
	HRESULT hr;
	__try {
		 hr= m__dxj_Direct3dRMMesh->AddGroup( 
			 (unsigned)vcnt,(unsigned)fcnt,(unsigned)vPerFace, (unsigned*)((SAFEARRAY*)*ppsa)->pvData, pretId);
	}
	__except(1,1){
		return E_FAIL;
	}
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::addGroupJava( 
             /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in] */ long *pFaceData,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *pretId)

{

	HRESULT hr;
	__try {
		 hr= m__dxj_Direct3dRMMesh->AddGroup( 
			 (unsigned)vcnt,(unsigned)fcnt,(unsigned)vPerFace, (unsigned*)pFaceData, pretId);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_Direct3dRMMeshObject::getGroupMaterial( d3drmGroupIndex id, I_dxj_Direct3dRMMaterial2 **mat){
	HRESULT hr;
	IDirect3DRMMaterial  *realmat1=NULL;
	IDirect3DRMMaterial2 *realmat2=NULL;
	
	*mat=NULL;

	hr=m__dxj_Direct3dRMMesh->GetGroupMaterial((D3DRMGROUPINDEX)id,&realmat1);
	if FAILED(hr) return hr;	
	if (!realmat1) return S_OK;

	hr=realmat1->QueryInterface(IID_IDirect3DRMMaterial2,(void**)&realmat2);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMMaterial2,realmat2,mat);

	realmat1->Release();

	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMMeshObject::setGroupMaterial( d3drmGroupIndex id, I_dxj_Direct3dRMMaterial2 *mat){
	HRESULT hr;
	IDirect3DRMMaterial2 *realmat=NULL;
	IDirect3DRMMaterial  *realmat1=NULL;

	if (mat){
		mat->InternalGetObject((IUnknown**)&realmat);	//does not addref
		hr=realmat->QueryInterface(IID_IDirect3DRMMaterial,(void**)&realmat1);
		if FAILED(hr) return hr;
	}

	hr=m__dxj_Direct3dRMMesh->SetGroupMaterial((D3DRMGROUPINDEX)id,realmat1);
	
	if (realmat1) realmat1->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmobjectarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmobjectarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmObjectArrayObj.h : Declaration of the C_dxj_Direct3dRMObjectArrayObject

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMObjectArray LPDIRECT3DRMOBJECTARRAY



class C_dxj_Direct3dRMObjectArrayObject : 
	
	public I_dxj_Direct3dRMObjectArray,

	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMObjectArrayObject() ;
	virtual ~C_dxj_Direct3dRMObjectArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMObjectArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObjectArray)

	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMObjectArrayObject)
	


// I_dxj_Direct3dRMObjectArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)(long *retval);

	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMObject **lplpD3DRMObject);

private:
    DECL_VARIABLE(_dxj_Direct3dRMObjectArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMObjectArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmpick2arrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpick2arrayobj.h
//
//--------------------------------------------------------------------------

// d3dRMPick2edArrayObj.h : Declaration of the C_dxj_Direct3dRMPick2ArrayObject
#ifndef _H_D3DRMPICK2ARRAYOBJ
#define _H_D3DRMPICK2ARRAYOBJ

#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMPick2Array IDirect3DRMPicked2Array*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMPick2ArrayObject : 
	public I_dxj_Direct3dRMPick2Array,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMPick2ArrayObject() ;
	virtual ~C_dxj_Direct3dRMPick2ArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMPick2ArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMPick2Array)
END_COM_MAP()



DECLARE_AGGREGATABLE(C_dxj_Direct3dRMPick2ArrayObject)

// I_dxj_Direct3dRMPick2Array
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    STDMETHOD(getSize)( long *retval);
	STDMETHOD(getPickVisual)(long index, D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMVisual **visual);
	STDMETHOD(getPickFrame)(long index,  D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMFrameArray **frameArray);

private:
    DECL_VARIABLE(_dxj_Direct3dRMPick2Array);   

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMPick2Array )
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmpicked2arrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpicked2arrayobj.cpp
//
//--------------------------------------------------------------------------

// d3dRMPick2edArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmPick2ArrayObj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmVisualObj.h"



CONSTRUCTOR( _dxj_Direct3dRMPick2Array, {});
DESTRUCTOR( _dxj_Direct3dRMPick2Array, {});
GETSET_OBJECT(_dxj_Direct3dRMPick2Array);

GET_DIRECT_R(_dxj_Direct3dRMPick2Array, getSize, GetSize,  long)

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPick2ArrayObject::getPickVisual(long index, D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMVisual **visual)
{
	LPDIRECT3DRMVISUAL lpVisual=NULL;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dRMPick2Array->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(D3DRMPICKDESC2 *)Desc);
	if FAILED(hr)	 return hr;
	if (!lpVisual) return S_OK;

	hr=CreateCoverVisual(lpVisual, visual);
	if (lpFrameArray) lpFrameArray->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPick2ArrayObject::getPickFrame(long index, D3dRMPickDesc2 *Desc, I_dxj_Direct3dRMFrameArray **frameArray)
{
	LPDIRECT3DRMVISUAL lpVisual;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray;
	HRESULT hr;
	hr=m__dxj_Direct3dRMPick2Array->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(D3DRMPICKDESC2 *)Desc);
	if( hr != S_OK)	return hr;
	if (!lpFrameArray) return S_OK;
	INTERNAL_CREATE(_dxj_Direct3dRMFrameArray, lpFrameArray, frameArray);
	if (lpVisual) lpVisual->Release();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmmeshobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmmeshobj.h
//
//--------------------------------------------------------------------------

// d3drmMeshObj.h : Declaration of the C_dxj_Direct3dRMMeshObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMMesh LPDIRECT3DRMMESH

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMMeshObject : 
	public I_dxj_Direct3dRMMesh,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMMeshObject, &CLSID__dxj_Direct3dRMMesh>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMMeshObject() ;
	virtual ~C_dxj_Direct3dRMMeshObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMMeshObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMMesh)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMMesh,			"DIRECT.Direct3dRMMesh.3",			"DIRECT.Direct3dRMMesh.3", IDS_D3DRMMESH_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMMeshObject)

// I_dxj_Direct3dRMMesh
public:
	// updated
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
        HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
        HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
        HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE setGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3dcolor val);
        
        HRESULT STDMETHODCALLTYPE setGroupColorRGB( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b);
        
        HRESULT STDMETHODCALLTYPE setGroupMapping( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3drmMappingFlags value);
        
        HRESULT STDMETHODCALLTYPE setGroupQuality( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ d3drmRenderQuality value);
        
        HRESULT STDMETHODCALLTYPE setGroupMaterial( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setGroupTexture( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getGroupCount( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupColor( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ d3dcolor __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupMapping( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ d3drmMappingFlags __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupQuality( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ d3drmRenderQuality __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupMaterial( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ I_dxj_Direct3dRMMaterial2 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getGroupTexture( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ I_dxj_Direct3dRMTexture3 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE scaleMesh( 
            /* [in] */ float sx,
            /* [in] */ float sy,
            /* [in] */ float sz);
        
        HRESULT STDMETHODCALLTYPE translate( 
            /* [in] */ float tx,
            /* [in] */ float ty,
            /* [in] */ float tz);
        
        HRESULT STDMETHODCALLTYPE getBox( 
            /* [in] */ D3dRMBox __RPC_FAR *vector);
        
        HRESULT STDMETHODCALLTYPE getSizes( 
            /* [in] */ d3drmGroupIndex id,
            /* [out] */ long __RPC_FAR *cnt1,
            /* [out] */ long __RPC_FAR *cnt2,
            /* [out] */ long __RPC_FAR *cnt3,
            /* [out] */ long __RPC_FAR *cnt4);
        
        HRESULT STDMETHODCALLTYPE setVertex( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ D3dRMVertex __RPC_FAR *values);
        
        HRESULT STDMETHODCALLTYPE getVertex( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [out][in] */ D3dRMVertex __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getVertexCount( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ long __RPC_FAR *cnt);
        
        HRESULT STDMETHODCALLTYPE addGroup( 
            /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *fdata,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *retId);
        
        HRESULT STDMETHODCALLTYPE getGroupData( 
            /* [in] */ d3drmGroupIndex id,            
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *psa);
        
        HRESULT STDMETHODCALLTYPE getGroupDataSize( 
            /* [in] */ d3drmGroupIndex id,
            /* [retval][out] */ long __RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ long cnt,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *vertexArray);
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            long cnt,
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *vertexArray);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE addGroupJava( 
            /* [in] */ long vcnt,
            /* [in] */ long fcnt,
            /* [in] */ long vPerFace,
            /* [in,out] */ long *fdata,
            /* [retval][out] */ d3drmGroupIndex __RPC_FAR *retId);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE getGroupDataJava( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long size,
            /* [out][in] */ long *fdata);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE setVerticesJava( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
            /* [in] */ long cnt,
            /* [in,out] */ float __RPC_FAR *vertexArray);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE getVerticesJava( 
            /* [in] */ d3drmGroupIndex id,
            /* [in] */ long idx,
						long cnt,
            /* [out][in] */ float __RPC_FAR *vertexArray);
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMMesh);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMMesh )
		

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmobjectobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmobjectobj.h
//
//--------------------------------------------------------------------------

#if 0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmobjectarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3drmobjectarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmFrameArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmObjectArrayObj.h"



CONSTRUCTOR(_dxj_Direct3dRMObjectArray, {});
DESTRUCTOR(_dxj_Direct3dRMObjectArray, {});
GETSET_OBJECT(_dxj_Direct3dRMObjectArray);

GET_DIRECT_R(_dxj_Direct3dRMObjectArray,getSize, GetSize, long)



HRESULT C_dxj_Direct3dRMObjectArrayObject::getElement(long i, I_dxj_Direct3dRMObject **obj){
	HRESULT hr;
	IDirect3DRMObject  *realObject=NULL;	

	hr=m__dxj_Direct3dRMObjectArray->GetElement((DWORD)i,&realObject);
	if FAILED(hr) return hr;



	//realObjects refcount is taken care of by CreateCoverObject
	hr=CreateCoverObject(realObject, obj);

	realObject->Release();

	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmpickedarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpickedarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmPickedArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmPickedArrayObj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmVisualObj.h"



CONSTRUCTOR( _dxj_Direct3dRMPickArray, {});
DESTRUCTOR( _dxj_Direct3dRMPickArray, {});
GETSET_OBJECT(_dxj_Direct3dRMPickArray);

GET_DIRECT_R(_dxj_Direct3dRMPickArray, getSize, GetSize,  long)

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPickArrayObject::getPickVisual(long index, D3dRMPickDesc *Desc, I_dxj_Direct3dRMVisual **visual)
{
	LPDIRECT3DRMVISUAL lpVisual=NULL;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray=NULL;
	HRESULT hr;

	*visual=NULL;

	hr=m__dxj_Direct3dRMPickArray->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(struct _D3DRMPICKDESC *)Desc);
	if(hr != S_OK)	return hr;
	
	if (!lpVisual) return S_OK;

	hr=CreateCoverVisual(lpVisual, visual);
	if (lpFrameArray) lpFrameArray->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMPickArrayObject::getPickFrame(long index, D3dRMPickDesc *Desc, I_dxj_Direct3dRMFrameArray **frameArray)
{
	LPDIRECT3DRMVISUAL lpVisual=NULL;
    LPDIRECT3DRMFRAMEARRAY lpFrameArray=NULL;
	HRESULT hr;

	hr=m__dxj_Direct3dRMPickArray->GetPick((DWORD)index, &lpVisual, &lpFrameArray, 
									(struct _D3DRMPICKDESC *)Desc);
	if( hr != S_OK)
		return hr;

	if (!lpFrameArray) return S_OK;

	INTERNAL_CREATE(_dxj_Direct3dRMFrameArray, lpFrameArray, frameArray);
	if (lpVisual) lpVisual->Release();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmpickedarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmpickedarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmPickedArrayObj.h : Declaration of the C_dxj_Direct3dRMPickArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMPickArray LPDIRECT3DRMPICKEDARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMPickArrayObject : 
	public I_dxj_Direct3dRMPickArray,
//	public CComCoClass<C_dxj_Direct3dRMPickArrayObject, &CLSID__dxj_Direct3dRMPickArray>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMPickArrayObject() ;
	virtual ~C_dxj_Direct3dRMPickArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMPickArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMPickArray)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMPickArray,	"DIRECT.Direct3dRMPickedArray.3",	"DIRECT.Direct3dRMPickedArray.3",  IDS_D3DRMPICKEDARRAY_DESC,  THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dRMPickArrayObject)

// I_dxj_Direct3dRMPickArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    STDMETHOD(getSize)( long *retval);
	STDMETHOD(getPickVisual)(long index, D3dRMPickDesc *Desc, I_dxj_Direct3dRMVisual **visual);
	STDMETHOD(getPickFrame)(long index,  D3dRMPickDesc *Desc, I_dxj_Direct3dRMFrameArray **frameArray);

private:
    DECL_VARIABLE(_dxj_Direct3dRMPickArray);   

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMPickArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmprogressivemeshobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmprogressivemeshobj.cpp
//
//--------------------------------------------------------------------------

// d3dRMProgressiveMeshObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dRMProgressiveMeshObj.h"
#include "d3dRMMeshObj.h"
#include "d3drmTexture3Obj.h"

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR( _dxj_Direct3dRMProgressiveMesh, {});
DESTRUCTOR(_dxj_Direct3dRMProgressiveMesh, {});
GETSET_OBJECT(_dxj_Direct3dRMProgressiveMesh);

CLONE_R(_dxj_Direct3dRMProgressiveMesh,Direct3DRMProgressiveMesh);
GETNAME_R(_dxj_Direct3dRMProgressiveMesh);
SETNAME_R(_dxj_Direct3dRMProgressiveMesh);
GETCLASSNAME_R(_dxj_Direct3dRMProgressiveMesh);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMProgressiveMesh);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMProgressiveMesh);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMProgressiveMesh,  getAppData,		GetAppData,		long);


PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getBox,GetBox, D3dRMBox*, (_D3DRMBOX*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getFaceDetail,GetFaceDetail, long*, (DWORD*));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getVertexDetail,GetVertexDetail, long*, (DWORD*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setFaceDetail,SetFaceDetail, long, (DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setVertexDetail,SetVertexDetail, long, (DWORD));

PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMProgressiveMesh, getFaceDetailRange,GetFaceDetailRange, long*, (DWORD*),long*, (DWORD*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMProgressiveMesh, getVertexDetailRange,GetVertexDetailRange, long*, (DWORD*),long*, (DWORD*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getQuality, GetQuality, d3drmRenderQuality*, (D3DRMRENDERQUALITY*));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setQuality, SetQuality, d3drmRenderQuality, (D3DRMRENDERQUALITY));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setDetail,SetDetail, float, (float));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getDetail,GetDetail, float*, (float*));

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, setMinRenderDetail,SetMinRenderDetail, float, (float));

//PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, abort,Abort, long, (DWORD));
//PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMProgressiveMesh, getLoadStatus,GetLoadStatus, long*, (D3DRMPMESHLOADSTATUS*));
PASS_THROUGH_CAST_3_R(_dxj_Direct3dRMProgressiveMesh, registerEvents,RegisterEvents, long,(void*),long,(DWORD),long,(DWORD));

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::abort( ){
	HRESULT hr=m__dxj_Direct3dRMProgressiveMesh->Abort(0);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::getLoadStatus( D3DRMPMESHLOADSTATUS_CDESC *status){
	
	D3DRMPMESHLOADSTATUS *pstatus=(D3DRMPMESHLOADSTATUS*)status;
	HRESULT hr;
	pstatus->dwSize=sizeof(D3DRMPMESHLOADSTATUS);
	hr=m__dxj_Direct3dRMProgressiveMesh->GetLoadStatus(pstatus);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::loadFromFile(        
			/* [in] */ BSTR filename,
            /* [in] */ VARIANT id,
            /* [in] */ long flags,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *callme,
            /* [in] */ IUnknown __RPC_FAR *useMe)
{
	
	D3DRMLOADTEXTURECALLBACK d3dtcb = NULL;
	LPVOID pArgs = NULL;
	TextureCallback *tcb = NULL;
	HRESULT hr;

	if( callme )
	{
		tcb = new TextureCallback;

		if( tcb )
		{
			tcb->c				= callme;
			tcb->pUser			= useMe;
			tcb->next			= TextureCallbacks;
			tcb->prev			= (TextureCallback*)NULL;
			TextureCallbacks	= tcb;

			d3dtcb = myLoadTextureCallback;
			pArgs = (void *)tcb;
		}
		else
		{

			DPF(1,"Callback object creation failed!\r\n");
			return E_FAIL;
		}
	}
	
	USES_CONVERSION;
	LPCTSTR pszName = W2T(filename);

	void *args=NULL;
	DWORD pos=0;
	GUID  loadGuid;
	VARIANT var;
	VariantInit(&var);
	if ((flags & D3DRMLOAD_BYNAME)||(D3DRMLOAD_FROMURL & flags)) {
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;
		args=(void*)W2T(V_BSTR(&id));
	}
	else if(flags & D3DRMLOAD_BYPOSITION){
		hr=VariantChangeType(&var,&id,0,VT_I4);
		if FAILED(hr) return E_INVALIDARG;
		pos=V_I4(&id);
		args=&pos;
	}	
	else if(flags & D3DRMLOAD_BYGUID){
		hr=VariantChangeType(&var,&id,0,VT_BSTR);
		if FAILED(hr) return E_INVALIDARG;		
		hr=BSTRtoGUID(&loadGuid,V_BSTR(&id));
		if FAILED(hr) return E_INVALIDARG;
		args=&loadGuid;		
	}
	VariantClear(&var);


	hr = m__dxj_Direct3dRMProgressiveMesh->Load((void *)pszName,(DWORD*) args,(DWORD) flags, d3dtcb, pArgs);

	// Remove ourselves in a thread-safe manner. Need unlock here
	if (tcb)
		UndoCallbackLink((GeneralCallback*)tcb, 
							(GeneralCallback**)&TextureCallbacks);

	return hr;
}


STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *mesh)
{
	HRESULT hr;
	LPDIRECT3DRMMESH pMesh=NULL;

	hr = m__dxj_Direct3dRMProgressiveMesh->CreateMesh(&pMesh);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMMesh,pMesh,mesh);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMProgressiveMeshObject::duplicate( 
            /* [retval][out] */ I_dxj_Direct3dRMProgressiveMesh __RPC_FAR *__RPC_FAR *mesh)
{
	HRESULT hr;
	LPDIRECT3DRMPROGRESSIVEMESH pMesh=NULL;

	hr = m__dxj_Direct3dRMProgressiveMesh->Duplicate(&pMesh);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMProgressiveMesh,pMesh,mesh);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmshadow2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmshadow2obj.h
//
//--------------------------------------------------------------------------

// d3drmShadow2Obj.h : Declaration of the C_dxj_Direct3dRMShadow2Object

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMShadow2 LPDIRECT3DRMSHADOW2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMShadow2Object : 
	public I_dxj_Direct3dRMShadow2,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMShadow2Object() ;
	virtual ~C_dxj_Direct3dRMShadow2Object() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMShadow2Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMShadow2)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
END_COM_MAP()


DECLARE_AGGREGATABLE(C_dxj_Direct3dRMShadow2Object)

// I_dxj_Direct3dRMShadow2
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
		HRESULT STDMETHODCALLTYPE setOptions(long flags);
		 
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMShadow2);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMShadow2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmshadow2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmshadow2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmShadowObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmShadow2Obj.h"
#include "d3drmLightObj.h"


CONSTRUCTOR(_dxj_Direct3dRMShadow2, {});
DESTRUCTOR(_dxj_Direct3dRMShadow2, {});
GETSET_OBJECT(_dxj_Direct3dRMShadow2);

GETNAME_R(_dxj_Direct3dRMShadow2);
SETNAME_R(_dxj_Direct3dRMShadow2);
GETCLASSNAME_R(_dxj_Direct3dRMShadow2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMShadow2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMShadow2);

CLONE_R(_dxj_Direct3dRMShadow2,Direct3DRMShadow2);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMShadow2, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMShadow2, getAppData, GetAppData, long);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMShadow2, setOptions, SetOptions, long,(DWORD));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmtexture3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtexture3obj.h
//
//--------------------------------------------------------------------------

// d3drmTextureObj.h : Declaration of the C_dxj_Direct3dRMTextureObject

#ifndef _D3DRMTexture3_H_
#define _D3DRMTexture3_H_

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMTexture3 LPDIRECT3DRMTEXTURE3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMTexture3Object : 
	public I_dxj_Direct3dRMTexture3,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMTexture3Object, &CLSID__dxj_Direct3dRMTexture3>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMTexture3Object() ;
	virtual ~C_dxj_Direct3dRMTexture3Object() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMTexture3Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMTexture3)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMTexture3,		"DIRECT.Direct3dRMTexture.3",		"DIRECT.Direct3dRMTexture3.5", IDS_D3DRMTEXTURE_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMTexture3Object)

// I_dxj_Direct3dRMTexture
public:

         HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE changed( 
            /* [in] */ long flags,
            /* [in] */ long nRects,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *rects);
        
         HRESULT STDMETHODCALLTYPE generateMIPMap();
        
         HRESULT STDMETHODCALLTYPE getCacheFlags( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getCacheImportance( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getColors( 
            /* [retval][out] */ long __RPC_FAR *c);
        
         HRESULT STDMETHODCALLTYPE getDecalOrigin( 
            /* [out] */ long __RPC_FAR *x,
            /* [out] */ long __RPC_FAR *y);
        
         HRESULT STDMETHODCALLTYPE getDecalScale( 
            /* [retval][out] */ long __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getDecalSize( 
            /* [out] */ float __RPC_FAR *w,
            /* [out] */ float __RPC_FAR *h);
        
         HRESULT STDMETHODCALLTYPE getDecalTransparency( 
            /* [retval][out] */ long __RPC_FAR *t);
        
         HRESULT STDMETHODCALLTYPE getDecalTransparentColor( 
            /* [retval][out] */ d3dcolor __RPC_FAR *tc);
        
         HRESULT STDMETHODCALLTYPE getShades( 
            /* [retval][out] */ long __RPC_FAR *shades);
        
         HRESULT STDMETHODCALLTYPE getSurface( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE setCacheOptions(long importance, long flags); 
        
         HRESULT STDMETHODCALLTYPE setColors( 
            /* [in] */ long c);
        
         HRESULT STDMETHODCALLTYPE setDecalOrigin( 
            /* [in] */ long x,
            /* [in] */ long y);
        
         HRESULT STDMETHODCALLTYPE setDecalScale( 
            /* [in] */ long s);
        
         HRESULT STDMETHODCALLTYPE setDecalSize( 
            /* [in] */ float width,
            /* [in] */ float height);
        
         HRESULT STDMETHODCALLTYPE setDecalTransparency( 
            /* [in] */ long trans);
        
         HRESULT STDMETHODCALLTYPE setDecalTransparentColor( 
            /* [in] */ d3dcolor tcolor);
        
         HRESULT STDMETHODCALLTYPE setShades( 
            /* [in] */ long s);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMTexture3);

public:

	//mod:dp additions for D3dRMImage 
	byte *m_buffer1;
	byte *m_buffer2;
	byte *m_pallette;
	int m_buffer1size;
	int	m_buffer2size;
	int	m_palettesize;

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMTexture3 )
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmtexture3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtexture3obj.cpp
//
//--------------------------------------------------------------------------

// d3drmTextureObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmTexture3Obj.h"
#include "ddSurface4Obj.h"

CONSTRUCTOR(_dxj_Direct3dRMTexture3, {
	m_buffer1 = NULL;
	m_buffer1size = 0;
	m_buffer2 = NULL;
	m_buffer2size = 0;
	m_pallette = NULL;
	m_palettesize = 0;

})

DESTRUCTOR(_dxj_Direct3dRMTexture3, {
	if ( m_buffer1 ) 
		free(m_buffer1);
	if ( m_buffer2 ) 
		free(m_buffer2);
	if ( m_pallette )
		free(m_pallette);
})

GETSET_OBJECT(_dxj_Direct3dRMTexture3)

CLONE_R(_dxj_Direct3dRMTexture3,Direct3DRMTexture3);
GETNAME_R(_dxj_Direct3dRMTexture3);
SETNAME_R(_dxj_Direct3dRMTexture3);
GETCLASSNAME_R(_dxj_Direct3dRMTexture3);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMTexture3);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMTexture3);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setColors, SetColors, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setShades, SetShades, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setDecalScale, SetDecalScale, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setDecalTransparency, SetDecalTransparency, long,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMTexture3, setDecalTransparentColor, SetDecalTransparentColor, d3dcolor,(DWORD));

PASS_THROUGH2_R(_dxj_Direct3dRMTexture3, setDecalSize, SetDecalSize, d3dvalue, d3dvalue);
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMTexture3, setDecalOrigin, SetDecalOrigin, long,(DWORD),long,(DWORD));
PASS_THROUGH2_R(_dxj_Direct3dRMTexture3, getDecalSize, GetDecalSize, D3DVALUE*, D3DVALUE*);
PASS_THROUGH_CAST_2_R(_dxj_Direct3dRMTexture3, getDecalOrigin, GetDecalOrigin, long*, (long*), long*,(long*));


       

GET_DIRECT_R(_dxj_Direct3dRMTexture3, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getShades, GetShades, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getColors, GetColors, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getDecalScale, GetDecalScale, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getDecalTransparency, GetDecalTransparency, long);
GET_DIRECT_R(_dxj_Direct3dRMTexture3, getDecalTransparentColor, GetDecalTransparentColor, d3dcolor);




/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMTexture3Object::generateMIPMap() 
{
	return m__dxj_Direct3dRMTexture3->GenerateMIPMap(0);
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMTexture3Object::changed(long flags, long nRects, SAFEARRAY **psa) 
{
	if ((nRects)&&(!ISSAFEARRAY1D(psa,(DWORD)nRects)))
		return E_INVALIDARG;		
	
	return m__dxj_Direct3dRMTexture3->Changed((DWORD)flags,(DWORD)nRects,(RECT*)((SAFEARRAY*)*psa)->pvData);
}


STDMETHODIMP C_dxj_Direct3dRMTexture3Object::getCacheFlags(long *flags) 
{
	long temp;
	return m__dxj_Direct3dRMTexture3->GetCacheOptions(&temp,(DWORD*)flags);
}

STDMETHODIMP C_dxj_Direct3dRMTexture3Object::getCacheImportance(long *import) 
{
	DWORD temp;
	return m__dxj_Direct3dRMTexture3->GetCacheOptions(import,&temp);
}

STDMETHODIMP C_dxj_Direct3dRMTexture3Object::setCacheOptions(long import, long flags) 
{	
	return m__dxj_Direct3dRMTexture3->SetCacheOptions(import,(DWORD)flags);
}

STDMETHODIMP C_dxj_Direct3dRMTexture3Object::getSurface(long flags, I_dxj_DirectDrawSurface4 **ppret) 
{
	

	HRESULT hr;
	LPDIRECTDRAWSURFACE lpSurf1=NULL;
	LPDIRECTDRAWSURFACE4 lpSurf4=NULL;

	*ppret=NULL;

	hr=m__dxj_Direct3dRMTexture3->GetSurface((DWORD)flags,&lpSurf1);
	if FAILED(hr) return hr;

	hr=lpSurf1->QueryInterface(IID_IDirectDrawSurface4,(void**)&lpSurf4);
    lpSurf1->Release();
	if FAILED(hr) 	return hr;
	

	INTERNAL_CREATE(_dxj_DirectDrawSurface4,lpSurf4,ppret);
	if (*ppret==NULL) {
		lpSurf4->Release();
		return hr;
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmprogressivemeshobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmprogressivemeshobj.h
//
//--------------------------------------------------------------------------

// d3dRMProgressiveMeshObj.h : Declaration of the C_dxj_Direct3dRMProgressiveMeshObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMProgressiveMesh LPDIRECT3DRMPROGRESSIVEMESH

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMProgressiveMeshObject : 
	public I_dxj_Direct3dRMProgressiveMesh,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMProgressiveMeshObject() ;
	virtual ~C_dxj_Direct3dRMProgressiveMeshObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMProgressiveMeshObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMProgressiveMesh)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()


	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMProgressiveMeshObject)

// I_dxj_Direct3dRMProgressiveMesh
public:
		// updated
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE loadFromFile( 
            /* [in] */ BSTR sFile,
            /* [in] */ VARIANT id,
            /* [in] */ long options,
            /* [in] */ I_dxj_Direct3dRMLoadTextureCallback3 __RPC_FAR *cb,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE getLoadStatus( D3DRMPMESHLOADSTATUS_CDESC *status);
        
         HRESULT STDMETHODCALLTYPE setMinRenderDetail( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE abort( 
            ///* [in] */ long flags
			);
        
         HRESULT STDMETHODCALLTYPE getFaceDetail( 
            /* [retval][out] */ long __RPC_FAR *count);
        
         HRESULT STDMETHODCALLTYPE getVertexDetail( 
            /* [retval][out] */ long __RPC_FAR *count);
        
         HRESULT STDMETHODCALLTYPE setFaceDetail( 
            /* [in] */ long count);
        
         HRESULT STDMETHODCALLTYPE setVertexDetail( 
            /* [in] */ long count);
        
         HRESULT STDMETHODCALLTYPE getFaceDetailRange( 
            /* [out][in] */ long __RPC_FAR *min,
            /* [out][in] */ long __RPC_FAR *max);
        
         HRESULT STDMETHODCALLTYPE getVertexDetailRange( 
            /* [out][in] */ long __RPC_FAR *min,
            /* [out][in] */ long __RPC_FAR *max);
        
         HRESULT STDMETHODCALLTYPE getDetail( 
            /* [retval][out] */ float __RPC_FAR *detail);
        
         HRESULT STDMETHODCALLTYPE setDetail( 
            /* [in] */ float detail);
        
         HRESULT STDMETHODCALLTYPE registerEvents( 
            /* [in] */ long hEvent,
            /* [in] */ long flags,
            /* [in] */ long reserved);
        
         HRESULT STDMETHODCALLTYPE createMesh( 
            /* [retval][out] */ I_dxj_Direct3dRMMesh __RPC_FAR *__RPC_FAR *mesh);
        
         HRESULT STDMETHODCALLTYPE duplicate( 
            /* [retval][out] */ I_dxj_Direct3dRMProgressiveMesh __RPC_FAR *__RPC_FAR *mesh);
        
         HRESULT STDMETHODCALLTYPE getBox( 
            /* [out][in] */ D3dRMBox __RPC_FAR *box);
        
         HRESULT STDMETHODCALLTYPE setQuality( 
            d3drmRenderQuality quality);
        
         HRESULT STDMETHODCALLTYPE getQuality( 
            /* [retval][out] */  d3drmRenderQuality *quality);
        
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMProgressiveMesh);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMProgressiveMesh )
		

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmtextureinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtextureinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMTextureInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMTextureInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.
	  
class C_dxj_Direct3dRMTextureInterpolatorObject : 
	public I_dxj_Direct3dRMTextureInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMTextureInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMTextureInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMTextureInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMTextureInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMTextureInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
        
			
         HRESULT STDMETHODCALLTYPE setDecalOrigin( 
            /* [in] */ long x,
            /* [in] */ long y);
        
         HRESULT STDMETHODCALLTYPE setDecalSize( 
            /* [in] */ float width,
            /* [in] */ float height);
        
         HRESULT STDMETHODCALLTYPE setDecalTransparentColor( 
            /* [in] */ d3dcolor tcolor);
        
   
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMTextureInterpolator);
	LPDIRECT3DRMTEXTURE3 m__dxj_Direct3dRMTexture3;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMTextureInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmuservisualobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmuservisualobj.cpp
//
//--------------------------------------------------------------------------

// d3drmUserVisualObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmUserVisualObj.h"

CONSTRUCTOR(_dxj_Direct3dRMUserVisual, {m_enumcb=NULL;});
DESTRUCTOR(_dxj_Direct3dRMUserVisual, {cleanup();});
GETSET_OBJECT(_dxj_Direct3dRMUserVisual);


CLONE_R(_dxj_Direct3dRMUserVisual,Direct3DRMUserVisual);
GETNAME_R(_dxj_Direct3dRMUserVisual);
SETNAME_R(_dxj_Direct3dRMUserVisual);
GETCLASSNAME_R(_dxj_Direct3dRMUserVisual);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMUserVisual);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMUserVisual);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMUserVisual, setAppData, SetAppData,long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMUserVisual, getAppData, GetAppData, long);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMUserVisualObject::init(I_dxj_Direct3dRMUserVisualCallback *uvC, IUnknown *args)
{
	return E_NOINTERFACE;
}

void C_dxj_Direct3dRMUserVisualObject::cleanup(){

	if (!m_enumcb) return;
	if (m_enumcb->c) m_enumcb->c->Release();
	if (m_enumcb->pUser) m_enumcb->pUser->Release();
	delete m_enumcb;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmuservisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmuservisualobj.h
//
//--------------------------------------------------------------------------

// d3drmUserVisualObj.h : Declaration of the C_dxj_Direct3dRMUserVisualObject
#if 0

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMUserVisual LPDIRECT3DRMUSERVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMUserVisualObject : 
	public I_dxj_Direct3dRMUserVisual,
	public I_dxj_Direct3dRMObject,
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMUserVisualObject, &CLSID__dxj_Direct3dRMUserVisual>,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMUserVisualObject() ;
	virtual ~C_dxj_Direct3dRMUserVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMUserVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMUserVisual)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMUserVisual,	"DIRECT.Direct3dRMUserVisual.3",	"DIRECT.Direct3dRMUserVisual.3", IDS_D3DRMUSERVISUAL_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMUserVisualObject)

	//I_dxj_Direct3dRMUserVisual

public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);
	STDMETHOD(init)(I_dxj_Direct3dRMUserVisualCallback *fn, IUnknown *arg);

	////////////////////////////////////////////////////////////////////////////////////
	//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_Direct3dRMUserVisual);	
	d3drmCallback *m_enumcb;

	void cleanup();

private:
	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMUserVisual )
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmtextureinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmtextureinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmTextureInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMTextureInterpolator;


C_dxj_Direct3dRMTextureInterpolatorObject::C_dxj_Direct3dRMTextureInterpolatorObject(){
	m__dxj_Direct3dRMTextureInterpolator=NULL;
	m__dxj_Direct3dRMTexture3=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	
	DPF1(1,"Constructor Creation  Direct3dRMTextureInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMTextureInterpolator;
	g_dxj_Direct3dRMTextureInterpolator = (void *)this;
}


C_dxj_Direct3dRMTextureInterpolatorObject::~C_dxj_Direct3dRMTextureInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMTextureInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMTextureInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMTextureInterpolatorObject *ptr=(C_dxj_Direct3dRMTextureInterpolatorObject *)g_dxj_Direct3dRMTextureInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMTextureInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMTextureInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMTextureInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMTextureInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMTextureInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMTextureInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMTexture3)
			m__dxj_Direct3dRMTexture3->Release();

}


DWORD C_dxj_Direct3dRMTextureInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMTextureInterpolator[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMTextureInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,,"Direct3dRMTextureInterpolator [%d] Release %d \n",creationid,i);
	return i;
}



HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMTextureInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMTextureInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMTexture3,(void**)&m__dxj_Direct3dRMTexture3);	
	return hr;
}



HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMTextureInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMTextureInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        

HRESULT  C_dxj_Direct3dRMTextureInterpolatorObject::getAttachedObjects( I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMTextureInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        
        

HRESULT  C_dxj_Direct3dRMTextureInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMTextureInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMTextureInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMTextureInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;
	LPDIRECT3DRMOBJECT pObj=NULL;

	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);

	//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	
	if (options & D3DRMINTERPOLATION_VERTEXCOLOR)
		opt2=opt2 | D3DRMINTERPOLATION_VERTEXCOLOR;

	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMTextureInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::setDecalOrigin( long x, long y)
{
	return m__dxj_Direct3dRMTexture3->SetDecalOrigin((DWORD)x,(DWORD)y);
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::setDecalSize( float x, float y)
{
	return m__dxj_Direct3dRMTexture3->SetDecalSize(x,y);
}

HRESULT C_dxj_Direct3dRMTextureInterpolatorObject::setDecalTransparentColor( long c)
{
	return m__dxj_Direct3dRMTexture3->SetDecalTransparentColor((DWORD)c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmviewport2obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewport2obj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmViewport2Obj.h"
//#include "d3dViewport3Obj.h"
#include "d3drmPickedArrayObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmDevice3Obj.h"



//CONSTRUCTOR(_dxj_Direct3dRMViewport2, {});
//DESTRUCTOR(_dxj_Direct3dRMViewport2, {});

C_dxj_Direct3dRMViewport2Object::C_dxj_Direct3dRMViewport2Object(){
	m__dxj_Direct3dRMViewport2=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMViewport2[%d] \n",g_creationcount);

	nextobj =  g_dxj_Direct3dRMViewport2;
	g_dxj_Direct3dRMViewport2 = (void *)this;
}


C_dxj_Direct3dRMViewport2Object::~C_dxj_Direct3dRMViewport2Object(){

	DPF1(1,"Destructor  Direct3dRMViewport2 [%d] \n",creationid); 
	
	C_dxj_Direct3dRMViewport2Object *prev=NULL; 

	for(C_dxj_Direct3dRMViewport2Object *ptr=(C_dxj_Direct3dRMViewport2Object *)g_dxj_Direct3dRMViewport2;
		ptr;
		ptr=(C_dxj_Direct3dRMViewport2Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMViewport2 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMViewport2){ 
		int count = IUNK(m__dxj_Direct3dRMViewport2)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMViewport2 Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMViewport2 = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
}


DWORD C_dxj_Direct3dRMViewport2Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMViewport2[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3dRMViewport2Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMViewport2 [%d] Release %d \n",creationid,i);
	return i;
}




GETSET_OBJECT(_dxj_Direct3dRMViewport2);
CLONE_R(_dxj_Direct3dRMViewport2,Direct3DRMViewport2);


GETNAME_R(_dxj_Direct3dRMViewport2);
SETNAME_R(_dxj_Direct3dRMViewport2);
GETCLASSNAME_R(_dxj_Direct3dRMViewport2);
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMViewport2);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMViewport2);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMViewport2, clear, Clear,long,(DWORD))
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setBack, SetBack, d3dvalue)
PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMViewport2, setAppData, SetAppData, long,(DWORD));
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setFront, SetFront, d3dvalue)
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setField, SetField, d3dvalue)
PASS_THROUGH1_R(_dxj_Direct3dRMViewport2, setUniformScaling, SetUniformScaling, long);
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMViewport2, configure, Configure, long,(long),long,(long),long,(DWORD),long,(DWORD));
PASS_THROUGH_CAST_4_R(_dxj_Direct3dRMViewport2, forceUpdate, ForceUpdate, long,(DWORD),long,(DWORD),long,(DWORD),long,(DWORD));
PASS_THROUGH4_R(_dxj_Direct3dRMViewport2, setPlane, SetPlane, d3dvalue, d3dvalue, d3dvalue, d3dvalue);
PASS_THROUGH4_R(_dxj_Direct3dRMViewport2, getPlane, GetPlane, D3DVALUE*, D3DVALUE*, D3DVALUE*, D3DVALUE*);

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMViewport2, setProjection, SetProjection, d3drmProjectionType, (enum _D3DRMPROJECTIONTYPE));

GET_DIRECT_R(_dxj_Direct3dRMViewport2, getHeight, GetHeight, long)
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getWidth,  GetWidth,  long)
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getAppData, GetAppData, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getUniformScaling, GetUniformScaling, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getX, GetX, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getY, GetY, long);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getField, GetField, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getBack, GetBack, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getFront, GetFront, d3dvalue);
GET_DIRECT_R(_dxj_Direct3dRMViewport2, getProjection, GetProjection, d3drmProjectionType);

//RETURN_NEW_ITEM2_R(_dxj_Direct3dRMViewport2,pick,Pick,_dxj_Direct3dRMPickArray,long,long)
//#define RETURN_NEW_ITEM2_R(c,m,m2,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
//	if( m_##c->m2(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
//	return S_OK;}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::pick(long x, long y, I_dxj_Direct3dRMPickArray **rv)
{
	HRESULT hr;
	LPDIRECT3DRMPICKEDARRAY pArray=NULL;
	
	//MANBUGS 18014 pick can GPF is mesbuilder.enable is set to renderable (as opposed to pickable)
	//
	__try{
		hr= m__dxj_Direct3dRMViewport2->Pick(x,y,&pArray);
	}
	__except(0,0){
		return E_FAIL;
	}
	if FAILED(hr) return  hr;
	INTERNAL_CREATE(_dxj_Direct3dRMPickArray,pArray,rv);
	return hr; 
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::transform(D3dRMVector4d* dst, D3dVector* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMViewport2->Transform( (D3DRMVECTOR4D*)dst,  (D3DVECTOR *)src );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::inverseTransform(D3dVector* dst, D3dRMVector4d* src)
{
	if(! (dst && src) )
		return E_POINTER;

	return  m__dxj_Direct3dRMViewport2->InverseTransform( (D3DVECTOR *)dst,  (D3DRMVECTOR4D*)src );
}

STDMETHODIMP C_dxj_Direct3dRMViewport2Object::getCamera(I_dxj_Direct3dRMFrame3 **cam)
{
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
	hr= m__dxj_Direct3dRMViewport2->GetCamera(&realframe);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realframe,cam);
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMViewport2Object::setCamera(I_dxj_Direct3dRMFrame3 *cam)
{
	HRESULT hr;
	IDirect3DRMFrame3 *realframe=NULL;
	cam->InternalGetObject((IUnknown**)&realframe);
	hr= m__dxj_Direct3dRMViewport2->SetCamera((IDirect3DRMFrame3*)realframe);	
	return hr;
}

STDMETHODIMP C_dxj_Direct3dRMViewport2Object::getDevice(I_dxj_Direct3dRMDevice3 **dev)
{
	HRESULT hr;
	IDirect3DRMDevice3 *realdev=NULL;
	hr= m__dxj_Direct3dRMViewport2->GetDevice(&realdev);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMDevice3,(IDirect3DRMDevice3*)realdev,dev);
	return hr;
}

#if 0
STDMETHODIMP C_dxj_Direct3dRMViewport2Object::getDirect3DViewport(I_dxj_Direct3dViewport3 **vp)
{
	HRESULT hr;
	IDirect3DViewport *realvp=NULL;
	IDirect3DViewport *realvp3=NULL;
	hr= m__dxj_Direct3dRMViewport2->GetDirect3DViewport(&realvp);
	if FAILED(hr) return hr;

	hr = realvp->QueryInterface(IID_IDirect3DViewport3,(void**)&realvp3);
	INTERNAL_CREATE(_dxj_Direct3dViewport3,realvp3,vp);
	return hr;
}
#endif



STDMETHODIMP C_dxj_Direct3dRMViewport2Object::render(I_dxj_Direct3dRMFrame3 *frame)
{
	HRESULT hr;
	if (frame==NULL) return E_INVALIDARG;

	IDirect3DRMFrame3 *realframe= NULL;
	frame->InternalGetObject((IUnknown**)&realframe);

	hr= m__dxj_Direct3dRMViewport2->Render(realframe);
	
#ifdef _X86_
	_asm FINIT
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmviewport2obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewport2obj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMViewport2Object

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMViewport2 LPDIRECT3DRMVIEWPORT2

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMViewport2Object : 
	public I_dxj_Direct3dRMViewport2,
	public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMViewport2Object() ;
	virtual ~C_dxj_Direct3dRMViewport2Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMViewport2Object)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMViewport2)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMViewport2Object)

// I_dxj_Direct3dRMViewport2
public:

		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE addDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *arg);
        
         HRESULT STDMETHODCALLTYPE deleteDestroyCallback( 
            /* [in] */ I_dxj_Direct3dRMCallback __RPC_FAR *fn,
            /* [in] */ IUnknown __RPC_FAR *args);
        
         HRESULT STDMETHODCALLTYPE setAppData( 
            /* [in] */ long data);
        
         HRESULT STDMETHODCALLTYPE getAppData( 
            /* [retval][out] */ long __RPC_FAR *data);
        
         HRESULT STDMETHODCALLTYPE setName( 
            /* [in] */ BSTR name);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE getClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
         HRESULT STDMETHODCALLTYPE clear( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE render( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE getCamera( 
            /* [retval][out] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE getDevice( 
            /* [retval][out] */ I_dxj_Direct3dRMDevice3 __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE setFront( 
            /* [in] */ float v);
        
         HRESULT STDMETHODCALLTYPE setBack( 
            /* [in] */ float v);
        
         HRESULT STDMETHODCALLTYPE setField( 
            /* [in] */ float v);
        
         HRESULT STDMETHODCALLTYPE setUniformScaling( 
            /* [in] */ long flag);
        
         HRESULT STDMETHODCALLTYPE setCamera( 
            /* [in] */ I_dxj_Direct3dRMFrame3 __RPC_FAR *f);
        
         HRESULT STDMETHODCALLTYPE setProjection( 
            /* [in] */ d3drmProjectionType val);
        
         HRESULT STDMETHODCALLTYPE transform( 
            /* [out] */ D3dRMVector4d __RPC_FAR *d,
            /* [in] */ D3dVector __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE inverseTransform( 
            /* [out] */ D3dVector __RPC_FAR *d,
            /* [in] */ D3dRMVector4d __RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE configure( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long width,
            /* [in] */ long height);
        
         HRESULT STDMETHODCALLTYPE forceUpdate( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
         HRESULT STDMETHODCALLTYPE setPlane( 
            /* [in] */ float left,
            /* [in] */ float right,
            /* [in] */ float bottom,
            /* [in] */ float top);
        
         HRESULT STDMETHODCALLTYPE getPlane( 
            /* [out][in] */ float __RPC_FAR *l,
            /* [out][in] */ float __RPC_FAR *r,
            /* [out][in] */ float __RPC_FAR *b,
            /* [out][in] */ float __RPC_FAR *t);
        
         HRESULT STDMETHODCALLTYPE pick( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ I_dxj_Direct3dRMPickArray __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getUniformScaling( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getX( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getY( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getHeight( 
            /* [retval][out] */ long __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE getWidth( 
            /* [retval][out] */ long __RPC_FAR *w);
        
         HRESULT STDMETHODCALLTYPE getField( 
            /* [retval][out] */ float __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getBack( 
            /* [retval][out] */ float __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getFront( 
            /* [retval][out] */ float __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getProjection( 
            /* [retval][out] */ d3drmProjectionType __RPC_FAR *retv);
        
        // HRESULT STDMETHODCALLTYPE getDirect3DViewport( 
        //    /* [retval][out] */ I_dxj_Direct3dViewport3 __RPC_FAR *__RPC_FAR *val);
    
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMViewport2);



public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMViewport2 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmviewportarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmViewportArrayObj.h : Declaration of the C_dxj_Direct3dRMViewportArrayObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMViewportArray LPDIRECT3DRMVIEWPORTARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMViewportArrayObject : 
	//public CComDualImpl<I_dxj_Direct3dRMViewportArray, &IID_I_dxj_Direct3dRMViewportArray, &LIBID_DIRECTLib>, 
	//public ISupportErrorInfo,
	public I_dxj_Direct3dRMViewportArray,
	//public CComCoClass<C_dxj_Direct3dRMViewportArrayObject, &CLSID__dxj_Direct3dRMViewportArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMViewportArrayObject() ;
	virtual ~C_dxj_Direct3dRMViewportArrayObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMViewportArrayObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMViewportArray)
	//	COM_INTERFACE_ENTRY(IDispatch)
	//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMViewportArray, "DIRECT.Direct3dRMViewportArray.3",	"DIRECT.Direct3dRMViewportArray.3",IDS_D3DRMVIEWPORTARRAY_DESC,THREADFLAGS_BOTH)

	// Use DECLARE_NOT_AGGREGATABLE(C_dxj_Direct3dRMViewportArrayObject) if you don't want your object
	// to support aggregation
	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMViewportArrayObject)

	//STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


// I_dxj_Direct3dRMViewportArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
#ifdef DX5
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMViewport **retval);
#else
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMViewport2 **retval);
#endif

private:
    DECL_VARIABLE(_dxj_Direct3dRMViewportArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMViewportArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewportarrayobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewportArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmViewportArrayObj.h"
#include "d3drmViewport2Obj.h"





CONSTRUCTOR(_dxj_Direct3dRMViewportArray, {});
DESTRUCTOR(_dxj_Direct3dRMViewportArray, {});
GETSET_OBJECT(_dxj_Direct3dRMViewportArray);

GET_DIRECT_R(_dxj_Direct3dRMViewportArray, getSize, GetSize, long);


#ifdef DX5
RETURN_NEW_ITEM_CAST_1_R(_dxj_Direct3dRMViewportArray, getElement, GetElement, _dxj_Direct3dRMViewport, long,(DWORD));
#else

STDMETHODIMP C_dxj_Direct3dRMViewportArrayObject::getElement(long index,I_dxj_Direct3dRMViewport2 **vp)
{
	HRESULT hr;
	LPDIRECT3DRMVIEWPORT pRealVP=NULL;
	LPDIRECT3DRMVIEWPORT2 pRealVP2=NULL;

	hr=m__dxj_Direct3dRMViewportArray->GetElement((DWORD)index,&pRealVP);
	if FAILED(hr) return hr;
	hr=pRealVP->QueryInterface(IID_IDirect3DRMViewport2,(void**)&pRealVP2);
	pRealVP->Release();
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_Direct3dRMViewport2,pRealVP2,vp);
	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmvisualarrayobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmvisualarrayobj.cpp
//
//--------------------------------------------------------------------------

// _dxj_Direct3dRMVisualArrayObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmVisualArrayObj.h"
#include "d3drmFrame3Obj.h"
#include "d3drmMeshbuilder3Obj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmMeshObj.h"
#include "d3drmUserVisualObj.h"



CONSTRUCTOR(_dxj_Direct3dRMVisualArray, {});
DESTRUCTOR(_dxj_Direct3dRMVisualArray, {});
GETSET_OBJECT(_dxj_Direct3dRMVisualArray);

GET_DIRECT_R(_dxj_Direct3dRMVisualArray, getSize, GetSize, long);



STDMETHODIMP C_dxj_Direct3dRMVisualArrayObject::getElement(long i,I_dxj_Direct3dRMVisual **ret){
	HRESULT hr;
	LPDIRECT3DRMVISUAL lp=NULL;
	hr=m__dxj_Direct3dRMVisualArray->GetElement((DWORD)i,&lp);
	if FAILED(hr) return hr;

    hr=CreateCoverVisual(lp,ret);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmvisualarrayobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmvisualarrayobj.h
//
//--------------------------------------------------------------------------

// d3drmVisualArrayObj.h : Declaration of the C_dxj_Direct3dRMVisualArrayObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dRMVisualArray LPDIRECT3DRMVISUALARRAY

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMVisualArrayObject : 
	public I_dxj_Direct3dRMVisualArray,
	//public CComCoClass<C_dxj_Direct3dRMVisualArrayObject, &CLSID__dxj_Direct3dRMVisualArray>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMVisualArrayObject() ;
	virtual ~C_dxj_Direct3dRMVisualArrayObject() ;

BEGIN_COM_MAP(C_dxj_Direct3dRMVisualArrayObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisualArray)
END_COM_MAP()

// DECLARE_REGISTRY(CLSID__dxj_Direct3dRMVisualArray,	"DIRECT.Direct3dRMVisualArray.3",	"DIRECT.Direct3dRMVisualArray.3",  IDS_D3DRMVISUALARRAY_DESC,  THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dRMVisualArrayObject)

// I_dxj_Direct3dRMVisualArray
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(getSize)( long *retval);
	STDMETHOD(getElement)(long index, I_dxj_Direct3dRMVisual **retv);		
	
private:
    DECL_VARIABLE(_dxj_Direct3dRMVisualArray);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMVisualArray )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportinterobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewportinterobj.cpp
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmViewportInterObj.h"
#include "d3drmObjectArrayObj.h"

extern void *g_dxj_Direct3dRMViewportInterpolator;


//CONSTRUCTOR(_dxj_Direct3dRMViewport2, {});
//DESTRUCTOR(_dxj_Direct3dRMViewport2, {});

C_dxj_Direct3dRMViewportInterpolatorObject::C_dxj_Direct3dRMViewportInterpolatorObject(){
	m__dxj_Direct3dRMViewportInterpolator=NULL;
	m__dxj_Direct3dRMViewport2=NULL;
	
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3dRMViewportInterpolator[%d] \n",g_creationcount);
	nextobj =  g_dxj_Direct3dRMViewportInterpolator;
	g_dxj_Direct3dRMViewportInterpolator = (void *)this;
}


C_dxj_Direct3dRMViewportInterpolatorObject::~C_dxj_Direct3dRMViewportInterpolatorObject(){

	DPF1(1,"Destructor  Direct3dRMViewportInterpolator [%d] \n",creationid); 
	
	C_dxj_Direct3dRMViewportInterpolatorObject *prev=NULL; 

	for(C_dxj_Direct3dRMViewportInterpolatorObject *ptr=(C_dxj_Direct3dRMViewportInterpolatorObject *)g_dxj_Direct3dRMViewportInterpolator;
		ptr;
		ptr=(C_dxj_Direct3dRMViewportInterpolatorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dRMViewportInterpolator = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dRMViewportInterpolator){ 
		int count = IUNK(m__dxj_Direct3dRMViewportInterpolator)->Release(); 
		DPF1(1,"DirectX real IDirect3dRMViewportInterpolator Ref count [%d] \n",count); 
		if(count==0){
			 m__dxj_Direct3dRMViewportInterpolator = NULL; 
		} 
	} 
	if (parent)
		IUNK(parent)->Release(); 
	
	if (m__dxj_Direct3dRMViewport2)
			m__dxj_Direct3dRMViewport2->Release();

}


DWORD C_dxj_Direct3dRMViewportInterpolatorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dRMViewportInterpolator[%d] AddRef %d \n",creationid,i);

	return i;
}

DWORD C_dxj_Direct3dRMViewportInterpolatorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3dRMViewportInterpolator [%d] Release %d \n",creationid,i);
	
	return i;
}



HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_Direct3dRMViewportInterpolator;
	
	return S_OK;
}
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::InternalSetObject(IUnknown *pUnk){
	HRESULT hr;
	m__dxj_Direct3dRMViewportInterpolator=(LPDIRECT3DRMINTERPOLATOR)pUnk;
	hr=pUnk->QueryInterface(IID_IDirect3DRMViewport2,(void**)&m__dxj_Direct3dRMViewport2);	
	return hr;
}



HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::attachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;
	
	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMViewportInterpolator->AttachObject(pObj);
	if (pObj) pObj->Release();
	return hr;
}

HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::detachObject( /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject){
	HRESULT hr;

	if (!rmObject) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	LPDIRECT3DRMOBJECT pObj=NULL;
	hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
	if FAILED(hr) return hr;

	hr=m__dxj_Direct3dRMViewportInterpolator->DetachObject(pObj);
	if (pObj) pObj->Release();

	return hr;
}

        
HRESULT  C_dxj_Direct3dRMViewportInterpolatorObject::getAttachedObjects( I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray)
{
	HRESULT hr;
	IDirect3DRMObjectArray *pArray=NULL;
	hr=m__dxj_Direct3dRMViewportInterpolator->GetAttachedObjects(&pArray);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dRMObjectArray,pArray,rmArray);
	
	return S_OK;
}        
        

HRESULT  C_dxj_Direct3dRMViewportInterpolatorObject::setIndex( /* [in] */ float val){
	return m__dxj_Direct3dRMViewportInterpolator->SetIndex(val);

}

HRESULT  C_dxj_Direct3dRMViewportInterpolatorObject::getIndex( float *val){
	if (!val) return E_INVALIDARG;
	*val=m__dxj_Direct3dRMViewportInterpolator->GetIndex();
	return S_OK;
}
        
        
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::interpolate( float val,
				     I_dxj_Direct3dRMObject __RPC_FAR *rmObject,
					 long options){
	HRESULT hr;

	LPDIRECT3DRMOBJECT pObj=NULL;
	DO_GETOBJECT_NOTNULL(LPUNKNOWN,pUnk,rmObject);
	
//we need to validate some options here or rm goes bezerk with invalid values
	//note valid flags are
	//  one of
	//		D3DRMINTERPOLATION_CLOSED 
	//		D3DRMINTERPOLATION_OPEN		-default
	//	one of 
	//		D3DRMINTERPOLATION_NEAREST
	//		D3DRMINTERPOLATION_SPLINE
	//		D3DRMINTERPOLATION_LINEAR	-default
	//		D3DRMINTERPOLATION_VERTEXCOLOR	- only on MeshInterpolator
	//		D3DRMINTERPOLATION_SLERPNORMALS	- not implemented
		
	//	VALIDATE FLAGS
	DWORD opt2=0;
	UINT i4;
	if (options & D3DRMINTERPOLATION_CLOSED) 
		opt2=D3DRMINTERPOLATION_CLOSED;
	else 
		opt2=D3DRMINTERPOLATION_OPEN;

	
	if (options & D3DRMINTERPOLATION_NEAREST) 
		opt2=opt2 | D3DRMINTERPOLATION_NEAREST;
	else if (options & D3DRMINTERPOLATION_SPLINE) 
		opt2=opt2 | D3DRMINTERPOLATION_SPLINE;
	else 
		opt2=opt2 | D3DRMINTERPOLATION_LINEAR;
	
	if (options & D3DRMINTERPOLATION_VERTEXCOLOR)
		opt2=opt2 | D3DRMINTERPOLATION_VERTEXCOLOR;


	if (pUnk){
		hr=pUnk->QueryInterface(IID_IDirect3DRMObject, (void**)&pObj);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMViewportInterpolator->Interpolate(val,pObj,(DWORD)opt2);
	if (pObj) i4=pObj->Release();

	return hr;
}
        
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setFront(  float val){
	return m__dxj_Direct3dRMViewport2->SetFront(val);
}

HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setBack(  float val){
	return m__dxj_Direct3dRMViewport2->SetBack(val);
}
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setField(  float val){
	return m__dxj_Direct3dRMViewport2->SetField(val);
}
HRESULT C_dxj_Direct3dRMViewportInterpolatorObject::setPlane(  float left, float right, float bottom, float top){
	return m__dxj_Direct3dRMViewport2->SetPlane(left,right,bottom,top);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmviewportinterobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3drmviewportinterobj.h
//
//--------------------------------------------------------------------------

// d3drmViewport2Obj.h : Declaration of the C_dxj_Direct3dRMViewportInterpolatorObject

#include "resource.h"       // main symbols
//#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMViewportInterpolator LPDIRECT3DRMINTERPOLATOR

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMViewportInterpolatorObject : 	
	public I_dxj_Direct3dRMViewportInterpolator,
	public I_dxj_Direct3dRMInterpolator,
	//public I_dxj_Direct3dRMObject,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMViewportInterpolatorObject() ;
	virtual ~C_dxj_Direct3dRMViewportInterpolatorObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

	BEGIN_COM_MAP(C_dxj_Direct3dRMViewportInterpolatorObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMViewportInterpolator)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMInterpolator)
		//COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

 

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMViewportInterpolatorObject)

// I_dxj_Direct3dRMViewport2
public:

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE attachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
        
         HRESULT STDMETHODCALLTYPE detachObject( 
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmObject);
        
         HRESULT STDMETHODCALLTYPE getAttachedObjects( 
            /* [retval][out] */ I_dxj_Direct3dRMObjectArray __RPC_FAR *__RPC_FAR *rmArray);
        
         HRESULT STDMETHODCALLTYPE setIndex( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE getIndex( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE interpolate( 
            /* [in] */ float val,
            /* [in] */ I_dxj_Direct3dRMObject __RPC_FAR *rmobject,
            /* [in] */ long options);
        
         HRESULT STDMETHODCALLTYPE setFront( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE setBack( 
            /* [in] */ float val);

         HRESULT STDMETHODCALLTYPE setField( 
            /* [in] */ float val);

         HRESULT STDMETHODCALLTYPE setPlane( 
            /* [in] */ float left,
            /* [in] */ float right,
            /* [in] */ float bottom,
            /* [in] */ float top);
        
    
    
////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks



private:
    DECL_VARIABLE(_dxj_Direct3dRMViewportInterpolator);
	LPDIRECT3DRMVIEWPORT2	m__dxj_Direct3dRMViewport2;	


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMViewportInterpolator )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmvisualobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmvisualobj.h
//
//--------------------------------------------------------------------------





// d3drmVisualObj.h : Declaration of the C_dxj_Direct3dRMVisualObject

#ifndef _D3DRMVISUAL_H_
#define _D3DRMVISUAL_H_

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMVisual LPDIRECT3DRMVISUAL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMVisualObject : 
	public I_dxj_Direct3dRMVisual,
	//public CComCoClass<C_dxj_Direct3dRMVisualObject, &CLSID__dxj_Direct3dRMVisual>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMVisualObject() ;
	virtual ~C_dxj_Direct3dRMVisualObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMVisualObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMVisual)
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_Direct3dRMVisual,		"DIRECT.Direct3dRMVisual.3",		"DIRECT.Direct3dRMVisual.3", IDS_D3DRMVISUAL_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMVisualObject)

// I_dxj_Direct3dRMVisual
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(I_dxj_Direct3dRMVisual **retval);

	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);

	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);

	STDMETHOD(getd3drmMeshBuilder)(I_dxj_Direct3dRMMeshBuilder3 **retval);
	STDMETHOD(getObjectType)(IUnknown **obj);	
	STDMETHOD(getd3drmMesh)(I_dxj_Direct3dRMMesh **retv);
	STDMETHOD(getd3drmTexture)(I_dxj_Direct3dRMTexture3 **retv);
	STDMETHOD(getd3drmFrame)(I_dxj_Direct3dRMFrame3 **retv);
	STDMETHOD(getd3drmShadow)( I_dxj_Direct3dRMShadow2 **retobj);
	
////////////////////////////////////////////////////////////////////////////////////
//
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMVisual);
	IUnknown *m_obj;

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMVisual )
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmwrapobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmwrapobj.h
//
//--------------------------------------------------------------------------

// d3drmWrapObj.h : Declaration of the C_dxj_Direct3dRMWrapObject

#include "resource.h"       // main symbols
#include "d3drmObjectObj.h"

#define typedef__dxj_Direct3dRMWrap LPDIRECT3DRMWRAP

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dRMWrapObject : 
	public I_dxj_Direct3dRMWrap,
	public I_dxj_Direct3dRMObject,	
	public CComObjectRoot
{
public:
	C_dxj_Direct3dRMWrapObject() ;
	virtual ~C_dxj_Direct3dRMWrapObject() ;

	BEGIN_COM_MAP(C_dxj_Direct3dRMWrapObject)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMWrap)
		COM_INTERFACE_ENTRY(I_dxj_Direct3dRMObject)
	END_COM_MAP()

// 	DECLARE_REGISTRY(CLSID__dxj_Direct3dRMWrap,			"DIRECT.Direct3dRMWrap.3",			"DIRECT.Direct3dRMWrap.3", IDS_D3DRMWRAP_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_Direct3dRMWrapObject)

// I_dxj_Direct3dRMWrap
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	STDMETHOD(clone)(IUnknown **retval);
	STDMETHOD(setAppData)(long);
	STDMETHOD(getAppData)(long*);
	STDMETHOD(addDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(deleteDestroyCallback)(I_dxj_Direct3dRMCallback *fn, IUnknown *args);
	STDMETHOD(getName)(BSTR *name);
	STDMETHOD(setName)(BSTR);
	STDMETHOD(getClassName)(BSTR *name);

	STDMETHOD(init)( d3drmWrapType, I_dxj_Direct3dRMFrame3 *ref,
							d3dvalue ox, d3dvalue oy, d3dvalue oz,
							d3dvalue dx, d3dvalue dy, d3dvalue dz,
							d3dvalue ux, d3dvalue uy, d3dvalue uz,
							d3dvalue ou, d3dvalue ov, d3dvalue su, d3dvalue sv);

	STDMETHOD(apply)( I_dxj_Direct3dRMObject *mesh);
	STDMETHOD(applyRelative)( I_dxj_Direct3dRMFrame3 *f, I_dxj_Direct3dRMObject *mesh);

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_Direct3dRMWrap);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dRMWrap )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3drmwrapobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3drmwrapobj.cpp
//
//--------------------------------------------------------------------------

// d3drmWrapObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3drmWrapObj.h"


CONSTRUCTOR(_dxj_Direct3dRMWrap, {});
DESTRUCTOR(_dxj_Direct3dRMWrap,  {});
GETSET_OBJECT(_dxj_Direct3dRMWrap );

CLONE_R(_dxj_Direct3dRMWrap,Direct3DRMWrap);
GETNAME_R(_dxj_Direct3dRMWrap);
SETNAME_R(_dxj_Direct3dRMWrap);
GETCLASSNAME_R(_dxj_Direct3dRMWrap);
DELETEDESTROYCALLBACK_R(_dxj_Direct3dRMWrap)
ADDDESTROYCALLBACK_R(_dxj_Direct3dRMWrap)

PASS_THROUGH_CAST_1_R(_dxj_Direct3dRMWrap, setAppData, SetAppData, long,(DWORD));
GET_DIRECT_R(_dxj_Direct3dRMWrap, getAppData, GetAppData, long);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMWrapObject::applyRelative(I_dxj_Direct3dRMFrame3 *ref, I_dxj_Direct3dRMObject *mesh)
{
	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);
	DO_GETOBJECT_NOTNULL( IUnknown*, lpU, mesh);
	IDirect3DRMFrame *realf=NULL;

	HRESULT hr;
	LPDIRECT3DRMOBJECT lpObject=NULL;

	if (lpf) lpf->QueryInterface(IID_IDirect3DRMFrame,(void**)&realf);

	hr=lpU->QueryInterface(IID_IDirect3DRMObject,(void**)&lpObject);
	if FAILED(hr) return E_FAIL;

	hr= m__dxj_Direct3dRMWrap->ApplyRelative(realf, (LPDIRECT3DRMOBJECT)lpObject);
	if(lpObject) lpObject->Release();
	if (realf) realf->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMWrapObject::apply(I_dxj_Direct3dRMObject *mesh)
{
	DO_GETOBJECT_NOTNULL( IUnknown*, lpU, mesh);

	HRESULT hr;
	LPDIRECT3DRMOBJECT lpObject=NULL;

	hr=lpU->QueryInterface(IID_IDirect3DRMObject,(void**)&lpObject);
	if FAILED(hr) return E_FAIL;

	hr= m__dxj_Direct3dRMWrap->Apply((LPDIRECT3DRMOBJECT)lpObject);
	if(lpObject) lpObject->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dRMWrapObject::init( d3drmWrapType t, I_dxj_Direct3dRMFrame3 *ref, 
						d3dvalue ox, d3dvalue oy, d3dvalue oz,
							d3dvalue dx, d3dvalue dy, d3dvalue dz,
								d3dvalue ux, d3dvalue uy, d3dvalue uz,
					d3dvalue ou , d3dvalue ov, d3dvalue su, d3dvalue sv)
{
	_D3DRMWRAPTYPE value = (enum _D3DRMWRAPTYPE)t;
	HRESULT hr;
	LPDIRECT3DRMFRAME lpf2=NULL;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DRMFRAME3, lpf, ref);

	if (lpf) 
	{
		hr=lpf->QueryInterface(IID_IDirect3DRMFrame,(void**)&lpf2);
		if FAILED(hr) return hr;
	}

	hr= m__dxj_Direct3dRMWrap->Init(value,lpf2, 
					ox, oy, oz,	dx, dy, dz,	ux, uy, uz,	ou , ov, su, sv);

	if (lpf2) lpf2->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3dvertexbuffer7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.h
//
//--------------------------------------------------------------------------

// d3dMaterialObj.h : Declaration of the C_dxj_Direct3dMaterialObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dVertexBuffer7 LPDIRECT3DVERTEXBUFFER7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dVertexBuffer7Object : 
	public I_dxj_Direct3dVertexBuffer7,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dVertexBuffer7Object() ;
	virtual ~C_dxj_Direct3dVertexBuffer7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3dVertexBuffer7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dVertexBuffer7)
END_COM_MAP()



DECLARE_AGGREGATABLE(C_dxj_Direct3dVertexBuffer7Object)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE unlock( void);
        
        HRESULT STDMETHODCALLTYPE optimize( 
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
            );
        
        HRESULT STDMETHODCALLTYPE processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);

		HRESULT STDMETHODCALLTYPE setVertexSize( /* [in] */ long n);

private:
    DECL_VARIABLE(_dxj_Direct3dVertexBuffer7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dVertexBuffer7)
	void	*m_pData;
	DWORD	m_vertSize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddclipperobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddclipperobj.h
//
//--------------------------------------------------------------------------

// ddClipperObj.h : Declaration of the C_dxj_DirectDrawClipperObject


#include "resource.h"       // main symbols
#include "wingdi.h" 

#define DDCOOPERATIVE_CLIPTOCOMPONENT   0x30000000
#define DDCOOPERATIVE_OFFSETTOCOMPONENT 0x20000000

#define typedef__dxj_DirectDrawClipper LPDIRECTDRAWCLIPPER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawClipperObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawClipper, &IID_I_dxj_DirectDrawClipper, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawClipper,
#endif
//	public CComCoClass<C_dxj_DirectDrawClipperObject, &CLSID__dxj_DirectDrawClipper>,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawClipperObject() ;
	virtual ~C_dxj_DirectDrawClipperObject() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_DirectDrawClipperObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawClipper)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawClipperObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// I_dxj_DirectDrawClipper
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpddc);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpddc);
        
         HRESULT STDMETHODCALLTYPE getClipListSize( 
            /* [retval][out] */ int __RPC_FAR *count);


         HRESULT STDMETHODCALLTYPE getClipList( 
				SAFEARRAY **list);
        
         HRESULT STDMETHODCALLTYPE setClipList( 
            /* [in] */ long count, SAFEARRAY **list);
        
         HRESULT STDMETHODCALLTYPE getHWnd( 
            /* [retval][out] */ HWnd __RPC_FAR *hdl);
        
         HRESULT STDMETHODCALLTYPE setHWnd( 
           // /* [in] */ long flags,
            /* [in] */ HWnd hdl);
        
        
         HRESULT STDMETHODCALLTYPE isClipListChanged( 
            /* [retval][out] */ int __RPC_FAR *status);
        

private:
	DECL_VARIABLE(_dxj_DirectDrawClipper);



public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawClipper );
	int m_flags;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\d3dvertexbuffer7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.cpp
//
//--------------------------------------------------------------------------

// d3dMaterialObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dVertexBuffer7Obj.h"

CONSTRUCTOR(_dxj_Direct3dVertexBuffer7,  {m_pData=NULL;m_vertSize=0;});
DESTRUCTOR(_dxj_Direct3dVertexBuffer7,  {});
GETSET_OBJECT(_dxj_Direct3dVertexBuffer7);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc)
{
	HRESULT hr;
	((D3DVERTEXBUFFERDESC*)desc)->dwSize=sizeof(D3DVERTEXBUFFERDESC);
	hr=m__dxj_Direct3dVertexBuffer7->GetVertexBufferDesc((D3DVERTEXBUFFERDESC*)desc);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
			long flags
            )
{
	HRESULT hr;

	if (!srcBuffer) return E_INVALIDARG;
	if (!dev) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DVERTEXBUFFER7, realBuffer, srcBuffer);
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realDev, dev);

	hr=m__dxj_Direct3dVertexBuffer7->ProcessVertices(
		(DWORD) vertexOp,
		(DWORD) destIndex,
		(DWORD) count,
		realBuffer,
		(DWORD) srcIndex,
		realDev,
		(DWORD) flags);


	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::lock( 
            /* [in] */ long flags)
{
	HRESULT hr;
	

	hr=m__dxj_Direct3dVertexBuffer7->Lock((DWORD) flags, &m_pData,NULL);
		
	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertexSize( /* [in] */ long n)
{
	m_vertSize=(DWORD)n;
		
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::unlock()
{
	HRESULT hr;
	hr=m__dxj_Direct3dVertexBuffer7->Unlock();
	m_pData=NULL;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::optimize(
		    /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
             )
        
{
	HRESULT hr;
	if (!dev) return E_INVALIDARG;
	
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realdev, dev);
	
	hr=m__dxj_Direct3dVertexBuffer7->Optimize(realdev,(DWORD) 0);
	
	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
		
	if (!m_vertSize) return E_FAIL;
	if (!m_pData) return E_FAIL;
	if (!verts) return E_INVALIDARG;

	__try {
		memcpy(&(((char*)m_pData) [startIndex*m_vertSize]),verts,count*m_vertSize);
	}
	__except(1,1){
		return E_FAIL;
	}
	
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////        

STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
	
	if (!m_vertSize) {				
		return E_FAIL;
	}
	if (!m_pData) {		
		return E_FAIL;
	}
	if (!verts) return E_INVALIDARG;

	__try {
		memcpy(verts,&( ((char*)m_pData) [startIndex*m_vertSize]),count*m_vertSize);
	}
	__except(1,1){		
		return E_FAIL;
	}
	

	
	return S_OK;
}
           


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddcolorcontrol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddcolorcontrol.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectDrawColorControlObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawColorControl LPDIRECTDRAWCOLORCONTROL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawColorControlObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawColorControl, &IID_I_dxj_DirectDrawColorControl, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawColorControl
#endif

//	public CComCoClass<C_dxj_DirectDrawColorControlObject, &CLSID__dxj_DirectDrawColorControl>, public CComObjectRoot
{
public:
	C_dxj_DirectDrawColorControlObject() ;
	virtual ~C_dxj_DirectDrawColorControlObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawColorControlObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawColorControl)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

	DECLARE_REGISTRY(CLSID__dxj_DirectDrawColorControl,	"DIRECT.DirectDrawColorControl.5",		"DIRECT.DirectDrawColorControl.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawColorControlObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawColorControlObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawColorControl
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);


private:
    DECL_VARIABLE(_dxj_DirectDrawColorControl);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawColorControl )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddclipperobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddclipperobj.cpp
//
//--------------------------------------------------------------------------

// ddClipperObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include <stdio.h>
#include "Direct.h"
#include "dms.h"
#include "ddClipperObj.h"


			 
typedef HRESULT (__stdcall *DDCREATECLIPPER)( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );


C_dxj_DirectDrawClipperObject::C_dxj_DirectDrawClipperObject(){ 
	 m__dxj_DirectDrawClipper= NULL;
	 parent = NULL;
	 pinterface = NULL; 
	 nextobj =  g_dxj_DirectDrawClipper;
	 creationid = ++g_creationcount;
	 
	 DPF1(1,"Clipper Creation Id [%d] \n",g_creationcount);

	 g_dxj_DirectDrawClipper = (void *)this; 

 }



C_dxj_DirectDrawClipperObject::~C_dxj_DirectDrawClipperObject()
{


    C_dxj_DirectDrawClipperObject *prev=NULL; 
	for(C_dxj_DirectDrawClipperObject *ptr=(C_dxj_DirectDrawClipperObject *)g_dxj_DirectDrawClipper; ptr; ptr=(C_dxj_DirectDrawClipperObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDrawClipper = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDrawClipper){

		int count = IUNK(m__dxj_DirectDrawClipper)->Release();
		
		DPF1(1,"Clipper Real Ref count [%d] \n",count);
		
		if(count==0) m__dxj_DirectDrawClipper = NULL;
			
	} 

	if(parent) IUNK(parent)->Release();

}

DWORD C_dxj_DirectDrawClipperObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();		
	DPF2(1,"Clipper [%d] AddRef %d \n",creationid,i);		
	return i;
}

DWORD C_dxj_DirectDrawClipperObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();		
	DPF2(1,"Clipper [%d] Release %d \n",creationid,i);	
	return i;
}


GETSET_OBJECT(_dxj_DirectDrawClipper);

PASS_THROUGH1_R(_dxj_DirectDrawClipper, isClipListChanged, IsClipListChanged, int *);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::getClipListSize(int *count) 
{

	HRESULT retval;
	unsigned long  buffsize;

	
	//a NULL RGNDATA pointer returns size!!!
	retval = m__dxj_DirectDrawClipper->GetClipList((LPRECT)NULL, (LPRGNDATA)NULL, &buffsize);

	// return size as number of longs in the rect array  
	if ( retval != DD_OK )
		*count = 0;		// this case probably means no cliplist is avaible 
	else
		*count = (buffsize - sizeof(RGNDATAHEADER))/sizeof(LONG);

	return retval;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::getClipList( SAFEARRAY **list)
{
	HRESULT retval;
	LPRGNDATA tmprgn=NULL;
	DWORD  buffsize;

	
	

	// allocate a private copy of the cliplist 
	retval = m__dxj_DirectDrawClipper->GetClipList((LPRECT)NULL, (LPRGNDATA)NULL, &buffsize);
	if FAILED(retval) return retval;

	tmprgn = (LPRGNDATA)malloc(buffsize); 
	if ( !tmprgn )	return E_OUTOFMEMORY;
	
	ZeroMemory(tmprgn,buffsize);
	tmprgn->rdh.dwSize   = sizeof(RGNDATAHEADER); 
	tmprgn->rdh.iType    = RDH_RECTANGLES;
	tmprgn->rdh.nCount;	 

	// get the actual clip list 	
	retval = m__dxj_DirectDrawClipper->GetClipList(NULL,tmprgn,&buffsize);
	if ( retval != DD_OK )	return retval;
	
	
	__try{
		memcpy ( (((SAFEARRAY*)*list))->pvData,tmprgn->Buffer,tmprgn->rdh.nRgnSize);
	}
	__except(1,1){
		if (tmprgn) free(tmprgn);
		return E_FAIL;
	}

	free(tmprgn);

	return retval;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::setClipList( long count, SAFEARRAY **list)
{
	HRESULT retval;
	LPRGNDATA tmprgn;


	// allocate a private copy of the cliplist 
	tmprgn = (LPRGNDATA)malloc(sizeof(RGNDATAHEADER)+(count*sizeof(RECT))); 
	if ( !tmprgn )	return E_OUTOFMEMORY;

	ZeroMemory(tmprgn,sizeof(RGNDATAHEADER)+(count*sizeof(RECT)));
	tmprgn->rdh.dwSize   = sizeof(RGNDATAHEADER); 
    	tmprgn->rdh.iType    = RDH_RECTANGLES;
    	tmprgn->rdh.nCount   = count;
    	tmprgn->rdh.nRgnSize = count*sizeof(RECT);

	__try{
		memcpy ( tmprgn->Buffer,(((SAFEARRAY*)*list))->pvData,tmprgn->rdh.nRgnSize);
	}
	__except(1,1){
		if (tmprgn) free(tmprgn);
		return E_FAIL;
	}


	retval = m__dxj_DirectDrawClipper->SetClipList(tmprgn,0);

	free(tmprgn);

	return retval;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::getHWnd( HWnd *hwn)
{
	if (!hwn) return E_FAIL;
	return m__dxj_DirectDrawClipper->GetHWnd( (HWND*)hwn );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDrawClipperObject::setHWnd(  HWnd hwn)
{
	return m__dxj_DirectDrawClipper->SetHWnd(0, (HWND)hwn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddcolorcontrolobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddcolorcontrolobj.cpp
//
//--------------------------------------------------------------------------

// dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddColorControlObj.h"


CONSTRUCTOR(_dxj_DirectDrawColorControl, {});
DESTRUCTOR(_dxj_DirectDrawColorControl, {});
GETSET_OBJECT(_dxj_DirectDrawColorControl);


   
STDMETHODIMP C_dxj_DirectDrawColorControlObject::getColorControls(DDColorControl *col)
{    
	HRESULT hr = DD_OK;
	if (!col) return E_INVALIDARG;
	((DDCOLORCONTROL*)col)->dwSize=sizeof(DDCOLORCONTROL);
    hr=m__dxj_DirectDrawColorControl->GetColorControls((DDCOLORCONTROL*)col);	
	return hr;
}

STDMETHODIMP C_dxj_DirectDrawColorControlObject::setColorControls(DDColorControl *col)
{    
	HRESULT hr = DD_OK;
	if (!col) return E_INVALIDARG;
	((DDCOLORCONTROL*)col)->dwSize=sizeof(DDCOLORCONTROL);
    hr=m__dxj_DirectDrawColorControl->SetColorControls((DDCOLORCONTROL*)col);	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddcolorcontrolobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddcolorcontrolobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawColorControl LPDIRECTDRAWCOLORCONTROL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawColorControlObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawColorControl, &IID_I_dxj_DirectDrawColorControl, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawColorControl,
#endif
//	public CComCoClass<C_dxj_DirectDrawColorControlObject, &CLSID__dxj_DirectDrawColorControl>,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawColorControlObject() ;
	virtual ~C_dxj_DirectDrawColorControlObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawColorControlObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawColorControl)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDrawColorControl,   "DIRECT.ddPalette.3",	"DIRECT.DirectDrawColorControl.3",	IDS_DDPALETTE_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawColorControlObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawColorControlObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawColorControl
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpddp);
	STDMETHOD(InternalGetObject)(IUnknown **lpddp);
	STDMETHOD(getColorControls)( DDColorControl *colorcontrol);
	STDMETHOD(setColorControls)( DDColorControl *colorcontrol);
        

private:
    DECL_VARIABLE(_dxj_DirectDrawColorControl);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawColorControl )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenum.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxGlob7Obj.h"
#include "DDEnumObj.h"

extern  BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg            
)
{


	DPF(1,"Entered objDirectDrawEnumCallback \r\n");
	
	C_dxj_DDEnumObject *pObj=(C_dxj_DDEnumObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if  (pObj->m_pList)
			pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumObject::C_dxj_DDEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumObject::~C_dxj_DDEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumObject::create(DDENUMERATE pcbFunc,I_dxj_DDEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnum,(void**)ppRet);
	return hr;
}

/*
HRESULT C_dxj_DDEnumObject::getItem( long index, DxDriverInfo *inf)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;
	if (!inf) return E_FAIL;
	
	//C2819
	(*inf).strGuid=SysAllocString(m_pList[index].strGuid);
	(*inf).strDescription=SysAllocString(m_pList[index].strDescription);
	(*inf).strName=SysAllocString(m_pList[index].strName);

	return S_OK;
}
*/

HRESULT C_dxj_DDEnumObject::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_DDEnumObject::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_DDEnumObject::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        


HRESULT C_dxj_DDEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenummodes2obj.h ===
#include "resource.h"       

class C_dxj_DDEnumModes2Object : 
	public I_dxj_DDEnumModes2,
	public CComObjectRoot
{
public:
	C_dxj_DDEnumModes2Object() ;
	virtual ~C_dxj_DDEnumModes2Object() ;

BEGIN_COM_MAP(C_dxj_DDEnumModes2Object)
	COM_INTERFACE_ENTRY(I_dxj_DDEnumModes2)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDEnumModes2Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDSurfaceDesc2 *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DDEnumModes2Object::create(LPDIRECTDRAW4 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DDEnumModes2 **ppRet);			   
		//static HRESULT C_dxj_DDEnumModes2Object::create7(LPDIRECTDRAW7 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DDEnumModes2 **ppRet);			   

public:
		DDSurfaceDesc2	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumexobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddenumexobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DDEnumExObject : 
	public I_dxj_DDEnumEx,
	public CComObjectRoot
{
public:
	C_dxj_DDEnumExObject() ;
	virtual ~C_dxj_DDEnumExObject() ;

BEGIN_COM_MAP(C_dxj_DDEnumExObject)
	COM_INTERFACE_ENTRY(I_dxj_DDEnumEx)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDEnumExObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DriverInfoEx *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DDEnumObject::create(DDENUMERATEEX pcbFunc,I_dxj_DDEnumEx **ppRet);
		

public:
		DriverInfoEx	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenummodes2obj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDEnumModes2Obj.h"


extern		BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumModes2Callback(LPDDSURFACEDESC2 lpDesc, void *lpArg)
{
	#ifdef _DEBUG
	OutputDebugString("Entered objEnumModes2Callback\r\n");
	#endif


	
	C_dxj_DDEnumModes2Object *pObj=(C_dxj_DDEnumModes2Object*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(DDSurfaceDesc2*)realloc(pObj->m_pList,sizeof(DDSurfaceDesc2)* pObj->m_nMax);
		else
			pObj->m_pList=(DDSurfaceDesc2*)malloc(sizeof(DDSurfaceDesc2)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	if (lpDesc==NULL) {
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
	
	
	HRESULT hr=CopyOutDDSurfaceDesc2(&(pObj->m_pList[pObj->m_nCount]),lpDesc);
	if (FAILED(hr)){
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
		
	
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumModes2Object::C_dxj_DDEnumModes2Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumModes2Object::~C_dxj_DDEnumModes2Object()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumModes2Object::create(LPDIRECTDRAW4 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DDEnumModes2 **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumModes2Object *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DDEnumModes2Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumModes2,(void**)ppRet);
	return hr;
}

#if 0
HRESULT C_dxj_DDEnumModes2Object::create7(LPDIRECTDRAW7 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DDEnumModes2 **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumModes2Object *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DDEnumModes2Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumModes2,(void**)ppRet);
	return hr;
}
#endif

HRESULT C_dxj_DDEnumModes2Object::getItem( long index, DDSurfaceDesc2 *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index-1]),sizeof(DDSurfaceDesc2));

	return S_OK;
}

HRESULT C_dxj_DDEnumModes2Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumexobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumexobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglobobj.h"
#include "DDEnumExObj.h"

extern "C" BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumExCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg,
  HANDLE hMon
)
{

	DPF(1,"Entered objDirectDrawEnumExCallback \r\n");
	
	C_dxj_DDEnumExObject *pObj=(C_dxj_DDEnumExObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		pObj->m_pList=(DriverInfoEx*)realloc(pObj->m_pList,sizeof(DriverInfoEx)* pObj->m_nMax);
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DriverInfoEx));
	
	pObj->m_pList[pObj->m_nCount].guid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].description=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].name=T2BSTR(lpDriverName);
	}

	pObj->m_pList[pObj->m_nCount].hMon=hMon

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumObject::C_dxj_DDEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumObject::~C_dxj_DDEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].guid) SysFreeString(m_pList[i].guid);
			if (m_pList[i].description) SysFreeString(m_pList[i].description);
			if (m_pList[i].name) SysFreeString(m_pList[i].name);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumObject::create(DDENUMERATE pcbFunc,I_dxj_DDEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnum,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_DDEnumObject::getItem( long index, DriverInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DriverInfo));

	return S_OK;
}

HRESULT C_dxj_DDEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenummodesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenummodesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectDrawEnumModesObject : 
	public I_dxj_DirectDrawEnumModes,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawEnumModesObject() ;
	virtual ~C_dxj_DirectDrawEnumModesObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawEnumModesObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawEnumModes)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawEnumModesObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDSurfaceDesc2 *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW7 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DirectDrawEnumModes **ppRet);			   
		
		static HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW4 pdd,long flags, DDSurfaceDesc2 *pdesc, I_dxj_DirectDrawEnumModes **ppRet);			   

public:
		DDSurfaceDesc2	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxGlob7Obj.h"
#include "DDEnumObj.h"

extern  BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg,
  HMONITOR hm
)
{

	
	DPF(1,"Entered objDirectDrawEnumCallback \r\n");	
	
	C_dxj_DirectDrawEnumObject *pObj=(C_dxj_DirectDrawEnumObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if  (pObj->m_pList)
			pObj->m_pList=(DxDriverInfoEx*)realloc(pObj->m_pList,sizeof(DxDriverInfoEx)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfoEx*)malloc(sizeof(DxDriverInfoEx)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfoEx));
	pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_pList[pObj->m_nCount].hMonitor=(long)PtrToLong(hm);	//bugbug SUNDOWN	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectDrawEnumObject::C_dxj_DirectDrawEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectDrawEnumObject::~C_dxj_DirectDrawEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DirectDrawEnumObject::create(DDENUMERATEEX pcbFunc,I_dxj_DirectDrawEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DirectDrawEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DirectDrawEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	  hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew,DDENUM_ATTACHEDSECONDARYDEVICES |   DDENUM_NONDISPLAYDEVICES);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnum,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DirectDrawEnumObject::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_DirectDrawEnumObject::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_DirectDrawEnumObject::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        

HRESULT C_dxj_DirectDrawEnumObject::getMonitorHandle( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!ret) return E_INVALIDARG;

	*ret=m_pList[index-1].hMonitor;
	
	return S_OK;
}
        


HRESULT C_dxj_DirectDrawEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenummodesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenummodesobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDEnumModesObj.h"


extern		BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumModes2Callback(LPDDSURFACEDESC2 lpDesc, void *lpArg)
{
	DPF(1,"Entered objEnumModes2Callback\r\n");



	
	C_dxj_DirectDrawEnumModesObject *pObj=(C_dxj_DirectDrawEnumModesObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(DDSurfaceDesc2*)realloc(pObj->m_pList,sizeof(DDSurfaceDesc2)* pObj->m_nMax);
		else
			pObj->m_pList=(DDSurfaceDesc2*)malloc(sizeof(DDSurfaceDesc2)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	if (lpDesc==NULL) {
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
	
	
	HRESULT hr=CopyOutDDSurfaceDesc2(&(pObj->m_pList[pObj->m_nCount]),lpDesc);
	if (FAILED(hr)){
			pObj->m_bProblem=TRUE;
			return FALSE;
	}
		
	
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectDrawEnumModesObject::C_dxj_DirectDrawEnumModesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectDrawEnumModesObject::~C_dxj_DirectDrawEnumModesObject()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW7 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DirectDrawEnumModes **ppRet)
{
	HRESULT hr;
	C_dxj_DirectDrawEnumModesObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DirectDrawEnumModesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumModes,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DirectDrawEnumModesObject::create(LPDIRECTDRAW4 pdd, long flags, DDSurfaceDesc2 *desc, I_dxj_DirectDrawEnumModes **ppRet)
{
	HRESULT hr;
	C_dxj_DirectDrawEnumModesObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	if (!pdd) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_DirectDrawEnumModesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	//note DDSurfaceDesc as a DDSURFACEDESC structure inside it.
	if ((desc==NULL)|| (IsAllZeros(desc,sizeof(DDSurfaceDesc2)))) {
		hr=pdd->EnumDisplayModes((DWORD)flags,NULL,pNew,objEnumModes2Callback);
	}
	else {
		DDSURFACEDESC2 desc2;
		hr=CopyInDDSurfaceDesc2(&desc2,desc);
		if (hr==S_OK){
			hr=pdd->EnumDisplayModes((DWORD)flags,&desc2,pNew,objEnumModes2Callback);
		}
	}
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumModes,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DirectDrawEnumModesObject::getItem( long index, DDSurfaceDesc2 *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index-1]),sizeof(DDSurfaceDesc2));

	return S_OK;
}

HRESULT C_dxj_DirectDrawEnumModesObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumplayersobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddenumplayersobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglobobj.h"
#include "DDEnumObj.h"

extern "C" BSTR GUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL PASCAL  objDirectDrawEnumCallback( 
  GUID FAR *lpGUID,           
  LPSTR lpDriverDescription,  
  LPSTR lpDriverName,         
  LPVOID lpArg            
)
{

	#ifdef _DEBUG
	OutputDebugString("Entered objDirectDrawEnumCallback \r\n");
	#endif
	
	C_dxj_DDEnumObject *pObj=(C_dxj_DDEnumObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGUID);
	
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DDEnumObject::C_dxj_DDEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DDEnumObject::~C_dxj_DDEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].guid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].description) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].name) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DDEnumObject::create(DDENUMERATE pcbFunc,I_dxj_DDEnum **ppRet)
{
	HRESULT hr;
	C_dxj_DDEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DDEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objDirectDrawEnumCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnum,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_DDEnumObject::getItem( long index, DxDriverInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DxDriverInfo));

	return S_OK;
}

HRESULT C_dxj_DDEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfaces7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddenumsurfaces7obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DDEnumSurfaces7Object : 
	public I_dxj_DDEnumSurfaces7,
	public CComObjectRoot
{
public:
	C_dxj_DDEnumSurfaces7Object() ;
	virtual ~C_dxj_DDEnumSurfaces7Object() ;

BEGIN_COM_MAP(C_dxj_DDEnumSurfaces7Object)
	COM_INTERFACE_ENTRY(I_dxj_DDEnumSurfaces7)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDEnumSurfaces7Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectDrawSurface7 **retVal);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT create(LPDIRECTDRAW7 dd,long flags, DDSurfaceDesc2 *desc,I_dxj_DDEnumSurfaces7 **ppRet);		
		static HRESULT createAttachedEnum(LPDIRECTDRAWSURFACE7  dds,  I_dxj_DDEnumSurfaces7 **ppRet);
		static HRESULT createZEnum(LPDIRECTDRAWSURFACE7  dds, long flags, I_dxj_DDEnumSurfaces7 **ppRet);

public:
		I_dxj_DirectDrawSurface7	**m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;
private:
		LPDIRECTDRAW7	m_pDD;
		LPDIRECTDRAWSURFACE7	m_pDDS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectDrawEnumObject : 
	public I_dxj_DirectDrawEnum,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawEnumObject() ;
	virtual ~C_dxj_DirectDrawEnumObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawEnum)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
		
		HRESULT STDMETHODCALLTYPE getMonitorHandle( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret);
			
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
		static HRESULT C_dxj_DirectDrawEnumObject::create(DDENUMERATEEX pcbFunc,I_dxj_DirectDrawEnum **ppRet);
		

public:
		DxDriverInfoEx *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfaces7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddenumsurfaces7obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDSurface7Obj.h"
#include "DDEnumSurfaces7Obj.h"

extern BOOL IsAllZeros(void*,DWORD size);
//extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2*,DDSurfaceDesc2*);
//extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2*);


//////////////////////////////////////////////////////////////////////
// objEnumSurfaces7Callback
//////////////////////////////////////////////////////////////////////
extern "C" HRESULT PASCAL objEnumSurfaces7Callback(LPDIRECTDRAWSURFACE7 lpddSurf,
								LPDDSURFACEDESC2 lpDDSurfaceDesc, void *lpArg)
{
	DPF1(1,"Entered objEnumSurfaces7Callback \r\n");


	C_dxj_DDEnumSurfaces7Object  *pObj=(C_dxj_DDEnumSurfaces7Object  *)lpArg;
	I_dxj_DirectDrawSurface7	*lpddSNew=NULL;

	if (pObj==NULL) {
		pObj->m_bProblem=TRUE;
		return DDENUMRET_CANCEL;
	}

	//create a surface7 object but dont have a back reference to this object!!!
	INTERNAL_CREATE_NOADDREF(_dxj_DirectDrawSurface7, lpddSurf, &lpddSNew);
	if (lpddSNew==NULL) {
		pObj->m_bProblem=TRUE;
		return DDENUMRET_CANCEL;
	}
		
	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(I_dxj_DirectDrawSurface7**)realloc(pObj->m_pList,sizeof(void*) * pObj->m_nMax);
		else
			pObj->m_pList=(I_dxj_DirectDrawSurface7**)malloc(sizeof(void*) * pObj->m_nMax);


		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return DDENUMRET_OK;
		}
	}


	pObj->m_pList[pObj->m_nCount]=lpddSNew;

	return DDENUMRET_OK;
}

//////////////////////////////////////////////////////////////////////
// C_dxj_DDEnumSurfaces7Object
//////////////////////////////////////////////////////////////////////
C_dxj_DDEnumSurfaces7Object::C_dxj_DDEnumSurfaces7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
	m_pDD=NULL;
	m_pDDS=NULL;
}

//////////////////////////////////////////////////////////////////////
// ~C_dxj_DDEnumSurfaces7Object
//////////////////////////////////////////////////////////////////////
C_dxj_DDEnumSurfaces7Object::~C_dxj_DDEnumSurfaces7Object()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i]) m_pList[i]->Release();
		}
		free(m_pList);
	}
	if (m_pDDS)	m_pDDS->Release();
	if (m_pDD)	m_pDD->Release();
}


//////////////////////////////////////////////////////////////////////
// create  ddraw->enum
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::create(LPDIRECTDRAW7  dd, long flags, DDSurfaceDesc2 *desc,I_dxj_DDEnumSurfaces7 **ppRet)
{
	
	return E_NOTIMPL;

	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	

	HRESULT hr;
	C_dxj_DDEnumSurfaces7Object *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	//ASSERT(ppRet,"C_dxj_DDEnumSurfaces7Object::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumSurfaces7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	pNew->m_pDD=dd;
	pNew->m_pDD->AddRef();
	

	//if the description is all zeros allow use to pass in NULL
	if ((desc==NULL)||(IsAllZeros(desc,sizeof(DDSurfaceDesc2)))){
		//d3dcore bug
		//hr=dd->EnumSurfaces((DWORD)flags,NULL,(void*)pNew,objEnumSurfaces7Callback);
	}
	//otherwise use the surface description to enumerate
	else {		
		DDSURFACEDESC2 realdesc;
		hr=CopyInDDSurfaceDesc2(&realdesc,desc);
		if (hr==S_OK){
			//d3dcore bug
		//	hr=dd->EnumSurfaces((DWORD)flags,(DDSURFACEDESC2*)&realdesc,(void*)pNew,objEnumSurfaces7Callback);
		}
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumSurfaces7,(void**)ppRet);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// createZEnum  ddrawsurface->enumZ
//////////////////////////////////////////////////////////////////////
			
HRESULT C_dxj_DDEnumSurfaces7Object::createZEnum(LPDIRECTDRAWSURFACE7  dd, long flags, I_dxj_DDEnumSurfaces7 **ppRet)
{
	
	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	
	//return E_NOTIMPL;

	HRESULT hr;
	C_dxj_DDEnumSurfaces7Object *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	//ASSERT(ppRet,"C_dxj_DDEnumSurfaces7Object::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumSurfaces7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	pNew->m_pDDS=dd;
	pNew->m_pDDS->AddRef();
	
	//d3d core bug
	hr=dd->EnumOverlayZOrders((DWORD)flags,(void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumSurfaces7,(void**)ppRet);
	
	return hr;
}


//////////////////////////////////////////////////////////////////////
// createAttachedEnum  ddrawsurface->enum
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::createAttachedEnum(LPDIRECTDRAWSURFACE7  dd,  I_dxj_DDEnumSurfaces7 **ppRet)
{
	
	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	
	//return E_NOTIMPL;

	HRESULT hr;
	C_dxj_DDEnumSurfaces7Object *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	//ASSERT(ppRet,"C_dxj_DDEnumSurfaces7Object::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DDEnumSurfaces7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	pNew->m_pDDS=dd;
	pNew->m_pDDS->AddRef();
	
	hr=dd->EnumAttachedSurfaces((void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DDEnumSurfaces7,(void**)ppRet);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// getItem
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::getItem( long index, I_dxj_DirectDrawSurface7 **info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*info=m_pList[index];
	if (m_pList[index-1]) (m_pList[index-1])->AddRef();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// getCount
//////////////////////////////////////////////////////////////////////
HRESULT C_dxj_DDEnumSurfaces7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfacesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenumsurfacesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectDrawEnumSurfacesObject : 
	public I_dxj_DirectDrawEnumSurfaces,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawEnumSurfacesObject() ;
	virtual ~C_dxj_DirectDrawEnumSurfacesObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawEnumSurfacesObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawEnumSurfaces)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawEnumSurfacesObject)

public:
		DWORD InternalAddRef();
		DWORD InternalRelease();
		HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectDrawSurface7 **retVal);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT create(I_dxj_DirectDraw7 *ddS,long flags, DDSurfaceDesc2 *desc,I_dxj_DirectDrawEnumSurfaces **ppRet);		
		static HRESULT createAttachedEnum(I_dxj_DirectDrawSurface7  *dds,  I_dxj_DirectDrawEnumSurfaces **ppRet);
		static HRESULT createZEnum(I_dxj_DirectDrawSurface7  *dds, long flags, I_dxj_DirectDrawEnumSurfaces **ppRet);

public:
		IDirectDrawSurface7	**m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;
		
	
		DX3J_GLOBAL_LINKS( _dxj_DirectDrawEnumSurfaces )


private:
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddenumsurfacesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddenumsurfacesobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDSurface7Obj.h"
#include "DDEnumSurfacesObj.h"
#include "DDraw7obj.h"

extern BOOL IsAllZeros(void*,DWORD size);



extern "C" HRESULT PASCAL objEnumSurfaces7Callback(LPDIRECTDRAWSURFACE7 lpddSurf,
								LPDDSURFACEDESC2 lpDDSurfaceDesc, void *lpArg)
{
	
	DPF(1,"Entered objEnumSurfaces7Callback \r\n");
	
	if (!lpddSurf) return DDENUMRET_CANCEL;

 	C_dxj_DirectDrawEnumSurfacesObject  *pObj=(C_dxj_DirectDrawEnumSurfacesObject  *)lpArg;
	I_dxj_DirectDrawSurface7	*lpddSNew=NULL;

	if (pObj==NULL) {
		pObj->m_bProblem=TRUE;
		return DDENUMRET_CANCEL;
	}
	
	

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(IDirectDrawSurface7**)realloc(pObj->m_pList,sizeof(void*) * pObj->m_nMax);
		else
			pObj->m_pList=(IDirectDrawSurface7**)malloc(sizeof(void*) * pObj->m_nMax);


		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return DDENUMRET_OK;
		}
	}


	pObj->m_pList[pObj->m_nCount]=lpddSurf;
	pObj->m_nCount++;

	//no need to release the surface we do that on tear down

	return DDENUMRET_OK;
}



    
DWORD C_dxj_DirectDrawEnumSurfacesObject::InternalAddRef(){
    DWORD i;
    i=CComObjectRoot::InternalAddRef();        	
    DPF2(1,"EnumSurf7 [%d] AddRef %d \n",creationid,i);
    return i;
}

DWORD C_dxj_DirectDrawEnumSurfacesObject::InternalRelease(){
    DWORD i;
    i=CComObjectRoot::InternalRelease();
    DPF2(1,"EnumSurf7 [%d] Release %d \n",creationid,i);
    return i;
}


C_dxj_DirectDrawEnumSurfacesObject::C_dxj_DirectDrawEnumSurfacesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
	parent=NULL;
}

C_dxj_DirectDrawEnumSurfacesObject::~C_dxj_DirectDrawEnumSurfacesObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i]) m_pList[i]->Release();
		}
		free(m_pList);
	}
	//if (m_pDDS)	m_pDDS->Release();
	//if (m_pDD)	m_pDD->Release();
	
	if (parent)		IUNK(parent)->Release();

}


HRESULT C_dxj_DirectDrawEnumSurfacesObject::create(I_dxj_DirectDraw7  *dd7, long flags, DDSurfaceDesc2 *desc,I_dxj_DirectDrawEnumSurfaces **ppRet)
{
	if (!dd7) return E_INVALIDARG;
	LPDIRECTDRAW7 dd=NULL;
	dd7->InternalGetObject((IUnknown**)&dd);
	
	//For the sake of making sure that all Surface7 are destroyed before
	//ddraw is
	

	HRESULT hr;
	C_dxj_DirectDrawEnumSurfacesObject *pNew=NULL;

		
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumSurfacesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	pNew->parent=dd7;
	IUNK(pNew->parent)->AddRef();

	
	
	//if FAILED(hr) return hr;

	if ((desc==NULL)||(IsAllZeros(desc,sizeof(DDSurfaceDesc2))))
	{
		hr=dd->EnumSurfaces((DWORD)flags,NULL,(void*)pNew,objEnumSurfaces7Callback);		
	}
	else 
	{		
		DDSURFACEDESC2 realdesc;
		hr=CopyInDDSurfaceDesc2(&realdesc,desc);
		if (hr==S_OK){			
			hr=dd->EnumSurfaces((DWORD)flags,(DDSURFACEDESC2*)&realdesc,(void*)pNew,objEnumSurfaces7Callback);
			
		}
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumSurfaces,(void**)ppRet);
	
	return hr;
}


HRESULT C_dxj_DirectDrawEnumSurfacesObject::createZEnum( I_dxj_DirectDrawSurface7 *ddS, long flags, I_dxj_DirectDrawEnumSurfaces **ppRet)
{
	HRESULT hr;
	LPDIRECTDRAWSURFACE7 dd=NULL;
	
	if (!ddS) return E_INVALIDARG;
	ddS->InternalGetObject((IUnknown**)&dd);

	
	C_dxj_DirectDrawEnumSurfacesObject *pNew=NULL;

	if (!dd) return E_INVALIDARG;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumSurfacesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	pNew->parent=ddS;
	IUNK(pNew->parent)->AddRef();
	
	hr=dd->EnumOverlayZOrders((DWORD)flags,(void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumSurfaces,(void**)ppRet);
	
	return hr;
}

HRESULT C_dxj_DirectDrawEnumSurfacesObject::createAttachedEnum(I_dxj_DirectDrawSurface7 *ddS,  I_dxj_DirectDrawEnumSurfaces **ppRet)
{
	
	//For the sake of making sure that all Surfaces2 are destroyed before
	//ddraw is
	

	HRESULT hr;
	LPDIRECTDRAWSURFACE7  dd=NULL;
	C_dxj_DirectDrawEnumSurfacesObject *pNew=NULL;

	if (!ddS) return E_INVALIDARG;

	ddS->InternalGetObject((IUnknown**)&dd);
	
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectDrawEnumSurfacesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	
	pNew->m_bProblem=FALSE;	
	pNew->parent=ddS;
	IUNK(pNew->parent)->AddRef();
	
	hr=dd->EnumAttachedSurfaces((void*)pNew,objEnumSurfaces7Callback);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}


	hr=pNew->QueryInterface(IID_I_dxj_DirectDrawEnumSurfaces,(void**)ppRet);


	return hr;
}


HRESULT C_dxj_DirectDrawEnumSurfacesObject::getItem( long index, I_dxj_DirectDrawSurface7 **info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	IDirectDrawSurface7 *pRealSurf=m_pList[index-1];
	
	if (!pRealSurf) return E_FAIL;	
	pRealSurf->AddRef();
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, pRealSurf, info);	
	

	return S_OK;
}

HRESULT C_dxj_DirectDrawEnumSurfacesObject::getCount(long *retVal)
{

	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddgammacontrolobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddgammacontrolobj.cpp
//
//--------------------------------------------------------------------------

// dDrawGammaControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddGammaControlObj.h"

extern void *g_dxj_DirectDrawGammaControl;

CONSTRUCTOR(_dxj_DirectDrawGammaControl, {});
DESTRUCTOR(_dxj_DirectDrawGammaControl, {});
GETSET_OBJECT(_dxj_DirectDrawGammaControl);
	
   
STDMETHODIMP C_dxj_DirectDrawGammaControlObject::getGammaRamp(long flags, DDGammaRamp *gammaRamp)
{    
	HRESULT hr = DD_OK;
    hr=m__dxj_DirectDrawGammaControl->GetGammaRamp((DWORD) flags,(DDGAMMARAMP*)gammaRamp);	
	return hr;
}

STDMETHODIMP C_dxj_DirectDrawGammaControlObject::setGammaRamp(long flags, DDGammaRamp *gammaRamp)
{    
	HRESULT hr = DD_OK;	
    hr=m__dxj_DirectDrawGammaControl->SetGammaRamp((DWORD) flags,(DDGAMMARAMP*)gammaRamp);	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddgammacontrolobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddgammacontrolobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawGammaControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawGammaControl LPDIRECTDRAWGAMMACONTROL

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawGammaControlObject : 
	public I_dxj_DirectDrawGammaControl,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawGammaControlObject() ;
	virtual ~C_dxj_DirectDrawGammaControlObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawGammaControlObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawGammaControl)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawGammaControlObject)

// I_dxj_DirectDrawGammaControl
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpddp);
	STDMETHOD(InternalGetObject)(IUnknown **lpddp);
	STDMETHOD(getGammaRamp)( long flags, DDGammaRamp *GammaControl);
	STDMETHOD(setGammaRamp)( long flags, DDGammaRamp *GammaControl);
        

private:
    DECL_VARIABLE(_dxj_DirectDrawGammaControl);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawGammaControl )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddidentifierobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddidentifierobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "ddIdentifierObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);




STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDriver( 
		/* [retval][out] */ BSTR __RPC_FAR *ret)
{	
	USES_CONVERSION;
	*ret=T2BSTR(m_id.szDriver);		
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDescription( 
		/* [retval][out] */ BSTR __RPC_FAR *ret)
{
	USES_CONVERSION;
	*ret=T2BSTR(m_id.szDescription);		
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDriverVersion( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.liDriverVersion.HighPart;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDriverSubVersion( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.liDriverVersion.LowPart;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getVendorId( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwVendorId;
	return S_OK;
}
		

STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDeviceId( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwDeviceId;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getSubSysId( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwSubSysId;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getRevision( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwRevision;
	return S_OK;
}

STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getDeviceIndentifier( 
		/* [retval][out] */ BSTR __RPC_FAR *ret)
{
	*ret=GUIDtoBSTR(&m_id.guidDeviceIdentifier);	
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawIdentifierObject::getWHQLLevel( 
		/* [retval][out] */ long __RPC_FAR *ret)
{
	*ret=m_id.dwWHQLLevel;
	return S_OK;
}


HRESULT C_dxj_DirectDrawIdentifierObject::Create(
	LPDIRECTDRAW7		  lpdd,	
	DWORD dwFlags, 
	I_dxj_DirectDrawIdentifier **ppret)
{
	HRESULT hr;
	C_dxj_DirectDrawIdentifierObject *c= new CComObject<C_dxj_DirectDrawIdentifierObject>;

	if (!c) return E_OUTOFMEMORY;

	hr=lpdd->GetDeviceIdentifier(&(c->m_id),dwFlags);			
	
	
	c->QueryInterface(IID_I_dxj_DirectDrawIdentifier,(void**)ppret);

	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddpaletteobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddpaletteobj.cpp
//
//--------------------------------------------------------------------------

// ddPaletteObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "ddPaletteObj.h"

CONSTRUCTOR(_dxj_DirectDrawPalette, {m_dd=NULL;});
DESTRUCTOR(_dxj_DirectDrawPalette, {m_dd=NULL;});
GETSET_OBJECT(_dxj_DirectDrawPalette);

PASS_THROUGH_CAST_1_R(_dxj_DirectDrawPalette, getCaps, GetCaps, long*,(DWORD *))

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDrawPaletteObject::getEntries( //long flags, 
								long base, long numEntries, SAFEARRAY **ppEntries){
	HRESULT hr;
	if (!ISSAFEARRAY1D(ppEntries,(DWORD)numEntries)) return E_INVALIDARG;
	LPPALETTEENTRY pe=(LPPALETTEENTRY)((SAFEARRAY*)*ppEntries)->pvData;
	hr=m__dxj_DirectDrawPalette->GetEntries((DWORD) 0,(DWORD) base, (DWORD) numEntries, pe);
	return hr;

}
STDMETHODIMP C_dxj_DirectDrawPaletteObject::setEntries(// long flags,
		long base, long numEntries, SAFEARRAY **ppEntries){
	HRESULT hr;
	if (!ISSAFEARRAY1D(ppEntries,(DWORD)numEntries)) return E_INVALIDARG;
	LPPALETTEENTRY pe=(LPPALETTEENTRY)((SAFEARRAY*)*ppEntries)->pvData;
	hr=m__dxj_DirectDrawPalette->SetEntries((DWORD) 0,(DWORD) base, (DWORD) numEntries, pe);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//

#if 0
STDMETHODIMP C_dxj_DirectDrawPaletteObject::initialize( I_dxj_DirectDraw2 *val)
{
	DO_GETOBJECT_NOTNULL( LPDIRECTDRAW2, lpdd, val)
	return m__dxj_DirectDrawPalette->Initialize((LPDIRECTDRAW)lpdd, 0, NULL);
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP C_dxj_DirectDrawPaletteObject::internalAttachDD(I_dxj_DirectDraw2 *dd)
{
	m_dd = dd;
	return S_OK;
}

#endif

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP C_dxj_DirectDrawPaletteObject::setEntriesHalftone(long start, long count)
{
	PALETTEENTRY pe[256];

	HDC hdc = GetDC(NULL);
	if (!hdc) return E_OUTOFMEMORY;

	HPALETTE hpal = CreateHalftonePalette(hdc);
	if (!hpal) return E_OUTOFMEMORY;
	

	GetPaletteEntries(hpal, 0, 256, pe );  

	for ( long i = start; i < start+count; i++ )
		pe[i].peFlags  |= PC_NOCOLLAPSE | D3DPAL_READONLY;  

	m__dxj_DirectDrawPalette->SetEntries(0,(DWORD)start,(DWORD)count,pe);

	ReleaseDC(NULL,hdc);
	return S_OK;
}


STDMETHODIMP C_dxj_DirectDrawPaletteObject::setEntriesSystemPalette(long start, long count)
{
	PALETTEENTRY pe[256];
	UINT uiRet;
	HRESULT hr;
	HDC hdc = GetDC(NULL);
	if (!hdc) return E_OUTOFMEMORY;

	uiRet=GetSystemPaletteEntries(hdc,start,count,pe);
        if (uiRet<=0) return E_FAIL; 


	for ( long i = start; i < start+count; i++ )
		pe[i].peFlags  |= /*PC_NOCOLLAPSE |*/ D3DPAL_READONLY;  

	hr=m__dxj_DirectDrawPalette->SetEntries(0,(DWORD)start,(DWORD)count,pe);

	ReleaseDC(NULL,hdc);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddidentifierobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ddidentifierobj.h
//
//--------------------------------------------------------------------------

class C_dxj_DirectDrawIdentifierObject : 
	public I_dxj_DirectDrawIdentifier,	
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawIdentifierObject(){};
	~C_dxj_DirectDrawIdentifierObject(){};

	BEGIN_COM_MAP(C_dxj_DirectDrawIdentifierObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectDrawIdentifier)		
	END_COM_MAP()



	DECLARE_AGGREGATABLE(C_dxj_DirectDrawIdentifierObject)


public:


	
	HRESULT STDMETHODCALLTYPE getDriver( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDescription( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDriverVersion( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDriverSubVersion( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getVendorId( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDeviceId( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getSubSysId( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getRevision( 
		/* [retval][out] */ long __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getDeviceIndentifier( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE getWHQLLevel( 
		/* [retval][out] */ long __RPC_FAR *ret);



	static  HRESULT C_dxj_DirectDrawIdentifierObject::Create(LPDIRECTDRAW7 lpdddi,  DWORD dwFlags, I_dxj_DirectDrawIdentifier **ppret);	

	DDDEVICEIDENTIFIER2 m_id;	

private:


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddraw7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw7obj.h
//
//--------------------------------------------------------------------------


// dDrawObj.h : Declaration of the CdDrawObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDraw7 LPDIRECTDRAW7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDraw7Object : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDraw7, &IID_I_dxj_DirectDraw7, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDraw7,
#endif

	//public CComCoClass<C_dxj_DirectDraw7Object, &CLSID__dxj_DirectDraw7>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectDraw7Object() ;
	virtual ~C_dxj_DirectDraw7Object() ;

BEGIN_COM_MAP(C_dxj_DirectDraw7Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDraw7)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDraw7, "DIRECT.DirectDraw7.3", "DIRECT.DirectDraw7.3", IDS_DDRAW_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDraw7Object)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDraw
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
 
        
         HRESULT STDMETHODCALLTYPE createClipper( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createPalette( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pe,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createSurface( 
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromFile( 
            /* [in] */ BSTR file,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromResource( 
            /* [in] */ BSTR file,
            /* [in] */ BSTR resName,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE duplicateSurface( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddIn,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *ddOut);
        
         HRESULT STDMETHODCALLTYPE flipToGDISurface( void);
        
         HRESULT STDMETHODCALLTYPE getAvailableTotalMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDCaps __RPC_FAR *hwCaps,
            /* [out][in] */ DDCaps __RPC_FAR *helCaps);
        
         HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getDisplayMode( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getFourCCCodes( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ccCodes);
        
         HRESULT STDMETHODCALLTYPE getFreeMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getGDISurface( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getMonitorFrequency( 
            /* [retval][out] */ long __RPC_FAR *freq);
        
         HRESULT STDMETHODCALLTYPE getNumFourCCCodes( 
            /* [retval][out] */ long __RPC_FAR *nCodes);
        
         HRESULT STDMETHODCALLTYPE getScanLine( 
            /* [out][in] */ long __RPC_FAR *lines,
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE getSurfaceFromDC( 
            /* [in] */ long hdc,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getSurfacesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getVerticalBlankStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE loadPaletteFromBitmap( 
            /* [in] */ BSTR bName,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE restoreAllSurfaces( void);
        
         HRESULT STDMETHODCALLTYPE restoreDisplayMode( void);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWnd hdl,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setDisplayMode( 
            /* [in] */ long w,
            /* [in] */ long h,
            /* [in] */ long bpp,
            /* [in] */ long ref,
            /* [in] */ long mode);
        
         HRESULT STDMETHODCALLTYPE testCooperativeLevel( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE waitForVerticalBlank( 
            /* [in] */ long flags,
            /* [in] */ long handle,
            /* [retval][out] */ long __RPC_FAR *status);


		HRESULT STDMETHODCALLTYPE getDeviceIdentifier(         
            /* [in] */ long flags, I_dxj_DirectDrawIdentifier **ret);

              	

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDraw7);

private:
	HWND m_hwnd;

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDraw7);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddraw4obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw4obj.h
//
//--------------------------------------------------------------------------


// dDrawObj.h : Declaration of the CdDrawObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDraw4 LPDIRECTDRAW4

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDraw4Object : 
	public I_dxj_DirectDraw4,
	public CComObjectRoot
{
public:
	C_dxj_DirectDraw4Object() ;
	virtual ~C_dxj_DirectDraw4Object() ;

BEGIN_COM_MAP(C_dxj_DirectDraw4Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDraw4)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDraw4, "DIRECT.DirectDraw4.3", "DIRECT.DirectDraw4.3", IDS_DDRAW_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDraw4Object)


// I_dxj_DirectDraw
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
 
        
         HRESULT STDMETHODCALLTYPE createClipper( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createPalette( 
            /* [in] */ long flags,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pe,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE createSurface( 
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromFile( 
            /* [in] */ BSTR file,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *dd,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE createSurfaceFromResource( 
            /* [in] */ BSTR file,
            /* [in] */ BSTR resName,
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE duplicateSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddIn,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *ddOut);
        
         HRESULT STDMETHODCALLTYPE flipToGDISurface( void);
        
         HRESULT STDMETHODCALLTYPE getAvailableTotalMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDCaps __RPC_FAR *hwCaps,
            /* [out][in] */ DDCaps __RPC_FAR *helCaps);
        
        
         HRESULT STDMETHODCALLTYPE getDisplayMode( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getFourCCCodes( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *ccCodes);
        
         HRESULT STDMETHODCALLTYPE getFreeMem( 
            /* [in] */ DDSCaps2 __RPC_FAR *ddsCaps,
            /* [retval][out] */ long __RPC_FAR *m);
        
         HRESULT STDMETHODCALLTYPE getGDISurface( 
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *s);
        
         HRESULT STDMETHODCALLTYPE getMonitorFrequency( 
            /* [retval][out] */ long __RPC_FAR *freq);
        
         HRESULT STDMETHODCALLTYPE getNumFourCCCodes( 
            /* [retval][out] */ long __RPC_FAR *nCodes);
        
         HRESULT STDMETHODCALLTYPE getScanLine( 
            /* [out][in] */ long __RPC_FAR *lines,
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE getSurfaceFromDC( 
            /* [in] */ long hdc,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *retv);
        
        
         HRESULT STDMETHODCALLTYPE getVerticalBlankStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE loadPaletteFromBitmap( 
            /* [in] */ BSTR bName,
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE restoreAllSurfaces( void);
        
         HRESULT STDMETHODCALLTYPE restoreDisplayMode( void);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWnd hdl,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setDisplayMode( 
            /* [in] */ long w,
            /* [in] */ long h,
            /* [in] */ long bpp,
            /* [in] */ long ref,
            /* [in] */ long mode);
        
         HRESULT STDMETHODCALLTYPE testCooperativeLevel( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         HRESULT STDMETHODCALLTYPE waitForVerticalBlank( 
            /* [in] */ long flags,
            /* [in] */ long handle,
            /* [retval][out] */ long __RPC_FAR *status);

              	

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDraw4);

private:
	HWND m_hwnd;

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDraw4);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddpaletteobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddpaletteobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawPaletteObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectDrawPalette LPDIRECTDRAWPALETTE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawPaletteObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectDrawPalette, &IID_I_dxj_DirectDrawPalette, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectDrawPalette,
#endif
//	public CComCoClass<C_dxj_DirectDrawPaletteObject, &CLSID__dxj_DirectDrawPalette>,
	 public CComObjectRoot
{
public:
	C_dxj_DirectDrawPaletteObject() ;
	virtual ~C_dxj_DirectDrawPaletteObject() ;

BEGIN_COM_MAP(C_dxj_DirectDrawPaletteObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawPalette)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDrawPalette,   "DIRECT.ddPalette.3",	"DIRECT.DirectDrawPalette.3",	IDS_DDPALETTE_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawPaletteObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawPaletteObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawPalette
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpddp);
	STDMETHOD(InternalGetObject)(IUnknown **lpddp);

    //STDMETHOD(initialize)( I_dxj_DirectDraw2 *val);
	STDMETHOD(getCaps)( long *caps);
	STDMETHOD(setEntries)(/*long,*/ long, long, SAFEARRAY **pe);
	STDMETHOD(getEntries)(/*long,*/ long, long, SAFEARRAY **pe);

	//STDMETHOD(internalAttachDD)(I_dxj_DirectDraw2 *dd);

	STDMETHOD(setEntriesHalftone)(long start, long count);
	STDMETHOD(setEntriesSystemPalette)(long start, long count);

private:
    DECL_VARIABLE(_dxj_DirectDrawPalette);
	IUnknown *m_dd;				// circular def's, use IUnknown to compile

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectDrawPalette )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddraw7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw7obj.cpp
//
//--------------------------------------------------------------------------

// dDrawObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddClipperObj.h"
#include "ddSurface7Obj.h"
#include "ddPaletteObj.h"
#include "ddEnumModesObj.h"
#include "ddEnumSurfacesObj.h"
#include "d3d7Obj.h"
#include "ddIdentifierObj.h"
					   

extern BOOL is4Bit;
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *,DDSurfaceDesc2*);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2 *);


///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DDraw7 [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DDraw4 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::C_dxj_DirectDraw7Object(){ 
		
	DPF1(1,"Constructor Creation  DirectDraw7Object[%d] \n ",g_creationcount);

	m__dxj_DirectDraw7= NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectDraw7;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectDraw7 = (void *)this; 
	m_hwnd=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::~C_dxj_DirectDraw7Object()
{

	DPF(1,"Entering ~DirectDraw7Object destructor \n");

     C_dxj_DirectDraw7Object *prev=NULL; 
	for(C_dxj_DirectDraw7Object *ptr=(C_dxj_DirectDraw7Object *)g_dxj_DirectDraw7; ptr; ptr=(C_dxj_DirectDraw7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDraw7 = (void*)ptr->nextobj; 
			
			DPF(1,"DirectDraw7Object found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDraw7){
		int count = IUNK(m__dxj_DirectDraw7)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectDraw7 Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectDraw7 = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}



///////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
// restoreDisplayMode
// flipToGDISurface
// setDisplayMode
///////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_DirectDraw7);
PASS_THROUGH_R(_dxj_DirectDraw7, restoreDisplayMode, RestoreDisplayMode)
PASS_THROUGH_R(_dxj_DirectDraw7, flipToGDISurface, FlipToGDISurface)
PASS_THROUGH5_R(_dxj_DirectDraw7, setDisplayMode, SetDisplayMode, long,long,long,long,long)


///////////////////////////////////////////////////////////////////
// getMonitorFrequency
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getMonitorFrequency(long *ret)
{
	HRESULT hr;
	hr=m__dxj_DirectDraw7->GetMonitorFrequency((DWORD*)ret);
	return hr;
}
														  


///////////////////////////////////////////////////////////////////
// getGDISurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getGDISurface(I_dxj_DirectDrawSurface7 **rv)
{ 
	
	LPDIRECTDRAWSURFACE7 lp4=NULL;	

	if ( is4Bit )
		return E_FAIL;

	*rv = NULL;
	HRESULT hr = DD_OK;

	if( ( hr=m__dxj_DirectDraw7->GetGDISurface(&lp4) ) != DD_OK) 
		return hr;
	 		
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lp4, rv);

	return hr; 
}

///////////////////////////////////////////////////////////////////
// getVerticalBlankStatus
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getVerticalBlankStatus( long *status)
{
	if ( is4Bit )
		return E_FAIL;

	return m__dxj_DirectDraw7->GetVerticalBlankStatus((int *)status);
}

///////////////////////////////////////////////////////////////////
// setCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::setCooperativeLevel( HWnd hwn, long flags)
{
	if ( is4Bit )
		return E_FAIL;

	m_hwnd = (HWND)hwn;

	return m__dxj_DirectDraw7->SetCooperativeLevel((HWND)hwn, (DWORD)flags);
}

///////////////////////////////////////////////////////////////////
// waitForVerticalBlank
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::waitForVerticalBlank(long flags,long handle, long *status)
{
	if ( is4Bit )
		return E_FAIL;

	*status = m__dxj_DirectDraw7->WaitForVerticalBlank(flags, (void *)handle);
	return S_OK;
}



///////////////////////////////////////////////////////////////////
// createClipper
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createClipper(long flags, I_dxj_DirectDrawClipper **val)
{
	if ( is4Bit )
		return E_FAIL;

	DPF1(1,"enter DDraw4[%d]::createClipper ",creationid);

	//
	// need to create one of MY surfaces!
	//
	LPDIRECTDRAWCLIPPER		ddc;
	HRESULT hr = DD_OK;
	if( (hr=m__dxj_DirectDraw7->CreateClipper( flags, &ddc, NULL)) != DD_OK )
		return hr;

	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);

	DPF1(1,"exit DDraw4[%d]::createClipper ",creationid);

	return hr;
}

///////////////////////////////////////////////////////////////////
// createPalette
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createPalette(long flags, SAFEARRAY **pe, I_dxj_DirectDrawPalette **val)
{
	LPPALETTEENTRY ppe;
	
	if ( is4Bit )
		return E_FAIL;


	if (!ISSAFEARRAY1D(pe,(DWORD)256)) return E_INVALIDARG;

	ppe = (LPPALETTEENTRY)((SAFEARRAY*)*pe)->pvData;

	LPDIRECTDRAWPALETTE		ddp;
	HRESULT hr = DD_OK;
	
	*val = NULL;

	if( (hr=m__dxj_DirectDraw7->CreatePalette( flags, (LPPALETTEENTRY)ppe, &ddp, NULL)) == DD_OK )
	{
		INTERNAL_CREATE( _dxj_DirectDrawPalette, ddp, val);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
// createSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurface(DDSurfaceDesc2 *dd, I_dxj_DirectDrawSurface7 **retval)
{
	HRESULT retv;
	LPDIRECTDRAWSURFACE7	  dds7; // DirectX object pointer
	DDSURFACEDESC2			  ddsd;
	DPF1(1,"enter DDraw7[%d]::createSurface ",creationid);
	
	

	if ( is4Bit )
		return E_FAIL;

	if(! (dd && retval) )
		return E_POINTER;
		
	CopyInDDSurfaceDesc2(&ddsd,dd);

	//docdoc: CreateSurface returns error if 'punk' is anything but NULL
	retv = m__dxj_DirectDraw7->CreateSurface( &ddsd, &dds7, NULL);
	if FAILED(retv)	return retv;
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, retval);

	dd->lpSurface = NULL;

	
	DPF1(1,"exit DDraw7[%d]::createSurface ",creationid);
	
	


	return S_OK;
}

///////////////////////////////////////////////////////////////////
// duplicateSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::duplicateSurface(I_dxj_DirectDrawSurface7 *ddIn, I_dxj_DirectDrawSurface7 **ddOut)
{
	HRESULT retval;

	if ( is4Bit )
		return E_FAIL;

	//
	// need to create one of MY surfaces!
	//	
	LPDIRECTDRAWSURFACE7 lpddout7=NULL;


	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpddin, ddIn);

	if( (retval = m__dxj_DirectDraw7->DuplicateSurface(lpddin, &lpddout7)) != DD_OK )
		return retval;

	INTERNAL_CREATE( _dxj_DirectDrawSurface7, lpddout7, ddOut);

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getCaps
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getCaps(DDCaps *driverCaps,  DDCaps *HELcaps)
{
	if ( is4Bit )
		return E_FAIL;
	if (!driverCaps) return E_INVALIDARG;
	if (!HELcaps) return E_INVALIDARG;

	((DDCAPS*)driverCaps)->dwSize=sizeof(DDCAPS);
	((DDCAPS*)HELcaps)->dwSize=sizeof(DDCAPS);

	HRESULT hr = m__dxj_DirectDraw7->GetCaps((DDCAPS*)driverCaps, (DDCAPS*)HELcaps);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getDisplayMode
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayMode(DDSurfaceDesc2 *desc)
{
	HRESULT retval;
	DDSURFACEDESC2 ddsd;

	if (!desc) return E_INVALIDARG;

	CopyInDDSurfaceDesc2(&ddsd,desc);

	retval = m__dxj_DirectDraw7->GetDisplayMode(&ddsd);

	if( retval != S_OK)		
		return retval;

	CopyOutDDSurfaceDesc2(desc,&ddsd);

	desc->lpSurface = NULL;

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getAvailableTotalMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getAvailableTotalMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, (unsigned long *)m, NULL);
}

///////////////////////////////////////////////////////////////////
// getFreeMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFreeMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, NULL, (unsigned long *)m);
}


///////////////////////////////////////////////////////////////////
// getDirect3D
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDirect3D(I_dxj_Direct3d7 **retval)
{
    LPDIRECT3D7 lpD3D;
	HRESULT hr = DD_OK;

	if ( is4Bit )
		return E_FAIL;

    if( (hr=m__dxj_DirectDraw7->QueryInterface(IID_IDirect3D7, (void**) &lpD3D)) != DD_OK)
		return hr;

  	INTERNAL_CREATE(_dxj_Direct3d7, lpD3D, retval);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getNumFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getNumFourCCCodes(long *retval)
{
    return m__dxj_DirectDraw7->GetFourCCCodes((DWORD*)retval, NULL);
}


///////////////////////////////////////////////////////////////////
// getScanLine
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getScanLine(long *lines, long *status)
{ 
	*status = (long)m__dxj_DirectDraw7->GetScanLine((DWORD*)lines);
	return S_OK;
}

///////////////////////////////////////////////////////////////////
// loadPaletteFromBitmap
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::loadPaletteFromBitmap(BSTR bName, I_dxj_DirectDrawPalette **retval)
{
	USES_CONVERSION;
    IDirectDrawPalette* ddpal;
    int                 i;
    int                 n;
    int                 fh;
    HRSRC               h;
    LPBITMAPINFOHEADER  lpbi;
    PALETTEENTRY        ape[256];
    RGBQUAD *           prgb;
	

	HRESULT hr=S_OK;

	if ( is4Bit )
		return E_FAIL;

	LPCTSTR szBitmap = W2T(bName);
	


    for (i=0; i<256; i++)		// build a 332 palette as the default
    {
        ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
        ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
        ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
        ape[i].peFlags = (BYTE)0;
    }

    //
    // get a pointer to the bitmap resource.
    //
    if (szBitmap && (h = FindResource(NULL, szBitmap, RT_BITMAP)))
    {
        lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h));
        if (!lpbi){	
		DPF(1,"lock resource failed\n");
		return E_OUTOFMEMORY;		// error
	}
        prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi->biSize);

        if (lpbi == NULL || lpbi->biSize < sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (lpbi->biBitCount > 8)
            n = 0;
        else if (lpbi->biClrUsed == 0)
            n = 1 << lpbi->biBitCount;
        else
            n = lpbi->biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            ape[i].peRed   = prgb[i].rgbRed;
            ape[i].peGreen = prgb[i].rgbGreen;
            ape[i].peBlue  = prgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }
    }
    else if (szBitmap && (fh = _lopen(szBitmap, OF_READ)) != -1)
    {
        BITMAPFILEHEADER bf;
        BITMAPINFOHEADER bi;

        _lread(fh, &bf, sizeof(bf));
        _lread(fh, &bi, sizeof(bi));
        _lread(fh, ape, sizeof(ape));
        _lclose(fh);

        if (bi.biSize != sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (bi.biBitCount > 8)
            n = 0;
        else if (bi.biClrUsed == 0)
            n = 1 << bi.biBitCount;
        else
            n = bi.biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            BYTE r = ape[i].peRed;
            ape[i].peRed  = ape[i].peBlue;
            ape[i].peBlue = r;
        }
    }

    m__dxj_DirectDraw7->CreatePalette(DDPCAPS_8BIT, ape, &ddpal, NULL);

	if( ddpal )
	{
		INTERNAL_CREATE(_dxj_DirectDrawPalette, ddpal, retval);
	}
	else
	{
		//
		// no object, set the return value to NULL as well.
		//
		*retval = NULL;
		hr = E_FAIL;
	}

    return hr;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromFile
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromFile(BSTR file, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw7[%d]::createSurfaceFromFile ",creationid);


	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
    HRESULT						hr;
	HBITMAP						hbm;
	HRESULT						retv;
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szFileName=NULL;
    int							width=0;
    int							height=0;


	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;
	
	
	USES_CONVERSION;
	szFileName=W2T(file);

	
	


	//If width and height are zero then we will generate our own width and
	//height from the bitmap.
	//The LoadImage api however doesnt work propery without size params
	//Consider there must be a way to make it work.
	if ((desc->lWidth!=0)&&(desc->lHeight!=0)&&(desc->lFlags & DDSD_WIDTH)&&(desc->lFlags & DDSD_HEIGHT))
	{
		width=desc->lWidth ;
		height=desc->lHeight; 
	}

	if (desc->lFlags==0) {
		desc->lFlags=DDSD_CAPS;
		((DDSURFACEDESC*)desc)->ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
	}

	if (!szFileName) return CTL_E_FILENOTFOUND;

	hbm = (HBITMAP)LoadImage((HINSTANCE)NULL, szFileName, IMAGE_BITMAP, 
				width, height, 
					LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	DWORD dwErr=GetLastError();		
	if (!hbm){
		
		//often users pass in width and height in twips and not pixels
		//loadimage compails and returns  ERROR_NOT_ENOUGH_MEMORY		
		

		if (dwErr==ERROR_NOT_ENOUGH_MEMORY)
		{
			return E_OUTOFMEMORY;
		}
		else if (dwErr==ERROR_INVALID_PARAMETER)
		{
			return E_INVALIDARG;
		}
		else {
			return CTL_E_FILENOTFOUND;
		}
	}

	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	width=bm.bmWidth;
	height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
     dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(buffer,"exit DDraw7[%d]::createSurfaceFromFile",creationid);	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromResource
///////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromResource(BSTR resFile, BSTR resourceName, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromResource ",creationid);

	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;


	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;

	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
	HBITMAP						hbm;
	HRESULT						retv;		
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szResName=NULL;

	if (!resourceName)	return E_INVALIDARG;
	if (!surf)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE:
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// so we must convert to ansi first
		 LPCTSTR pszName = W2T(resFile);
		 hMod= GetModuleHandle(pszName);
	}
	else {
		hMod= GetModuleHandle(NULL);
	}


	
	LPCTSTR pszName2 = W2T(resourceName);

    //hbm = (HBITMAP)LoadImageW((HINSTANCE)hMod, resourceName, 
	//				IMAGE_BITMAP, 
	//				0, 0, 
	//				LR_CREATEDIBSECTION);
	

    hbm = (HBITMAP)LoadImage((HINSTANCE)hMod, 
					pszName2, 
					IMAGE_BITMAP, 
					0, 0, 
					LR_CREATEDIBSECTION);


	if (!hbm){
		//MessageBox(NULL,"FAILED ON LOAD IMAGE","TEST",MB_OK);
		return E_FAIL;
	}


	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	DWORD width=bm.bmWidth;
	DWORD height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK ){
                if (hbm) DeleteObject(hbm);
	  	return retv;
        }

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
    dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

    if (!hdcImage){
		DeleteObject(hbm);
		return E_OUTOFMEMORY;
    }

    SelectObject(hdcImage, hbm);		

	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(1r,"exit DDraw4[%d]::createSurfaceFromFile",creationid);
	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// getFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFourCCCodes(SAFEARRAY **ppsa)
{
	DWORD count= ((SAFEARRAY*)*ppsa)->rgsabound[0].cElements;
	if ( ((SAFEARRAY*)*ppsa)->cDims!=1) return E_INVALIDARG;

    return m__dxj_DirectDraw7->GetFourCCCodes(&count,(DWORD*)((SAFEARRAY*)*ppsa)->pvData);

}

///////////////////////////////////////////////////////////////////
// getDisplayModesEnum
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval)
{
	HRESULT hr;	
	hr=C_dxj_DirectDrawEnumModesObject::create(m__dxj_DirectDraw7,flags, ddsd,  retval);
	return hr;	
}

///////////////////////////////////////////////////////////////////
// testCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::testCooperativeLevel( 
            /* [in,out] */ long *status)
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->TestCooperativeLevel();
	*status=(long)hr;
	return S_OK;	
}

///////////////////////////////////////////////////////////////////
// restoreAllSurfaces
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::restoreAllSurfaces()
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->RestoreAllSurfaces();
	return hr;	
}

STDMETHODIMP C_dxj_DirectDraw7Object::getSurfaceFromDC(long hdc, I_dxj_DirectDrawSurface7 **ret)
{
	HRESULT hr;	
	LPDIRECTDRAWSURFACE7 pDDS=NULL;
	hr=m__dxj_DirectDraw7->GetSurfaceFromDC((HDC)hdc,&pDDS);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectDrawSurface7,pDDS,ret);
	return hr;	
}




STDMETHODIMP C_dxj_DirectDraw7Object::getSurfacesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *ret)  
 
{
	HRESULT hr=C_dxj_DirectDrawEnumSurfacesObject::create((I_dxj_DirectDraw7*)this , flags, desc,ret);
	return hr;
}


STDMETHODIMP C_dxj_DirectDraw7Object::getDeviceIdentifier( 
             long flags,I_dxj_DirectDrawIdentifier **ret) 
{
	HRESULT hr;				
	hr=C_dxj_DirectDrawIdentifierObject::Create(m__dxj_DirectDraw7,(DWORD)flags,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddraw4obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw4obj.cpp
//
//--------------------------------------------------------------------------

// dDrawObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DDraw4Obj.h"
#include "ddClipperObj.h"
#include "ddSurface4Obj.h"
#include "ddPaletteObj.h"
#include "ddEnumModesObj.h"
#include "ddEnumSurfacesObj.h"
#include "d3d7Obj.h"
					   

extern BOOL is4Bit;
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *,DDSurfaceDesc2*);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2 *);


///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw4Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DDraw4 [%d] AddRef %d \n",creationid,i);		
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw4Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DDraw4 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectDraw4Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw4Object::C_dxj_DirectDraw4Object(){ 
		
	DPF1(1,"Constructor Creation  DirectDraw4Object[%d] \n ",g_creationcount);
	

	m__dxj_DirectDraw4= NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectDraw4;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectDraw4 = (void *)this; 
	m_hwnd=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectDraw4Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw4Object::~C_dxj_DirectDraw4Object()
{
	DPF(1,"Entering ~DirectDraw4Object destructor \n");
	

     C_dxj_DirectDraw4Object *prev=NULL; 
	for(C_dxj_DirectDraw4Object *ptr=(C_dxj_DirectDraw4Object *)g_dxj_DirectDraw4; ptr; ptr=(C_dxj_DirectDraw4Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDraw4 = (void*)ptr->nextobj; 
			
			
			DPF(1,"	DirectDraw4Object found in g_dxj list now removed\n");
			
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDraw4){
		int count = IUNK(m__dxj_DirectDraw4)->Release();
		
		DPF1(1,"DirectX IDirectDraw4 Ref count [%d] \n",count);

		if(count==0)	m__dxj_DirectDraw4 = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}



///////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
// restoreDisplayMode
// flipToGDISurface
// setDisplayMode
///////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_DirectDraw4);
PASS_THROUGH_R(_dxj_DirectDraw4, restoreDisplayMode, RestoreDisplayMode)
PASS_THROUGH_R(_dxj_DirectDraw4, flipToGDISurface, FlipToGDISurface)
PASS_THROUGH5_R(_dxj_DirectDraw4, setDisplayMode, SetDisplayMode, long,long,long,long,long)


///////////////////////////////////////////////////////////////////
// getMonitorFrequency
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getMonitorFrequency(long *ret)
{
	HRESULT hr;
	hr=m__dxj_DirectDraw4->GetMonitorFrequency((DWORD*)ret);
	return hr;
}
														  


///////////////////////////////////////////////////////////////////
// getGDISurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getGDISurface(I_dxj_DirectDrawSurface4 **rv)
{ 
	
	LPDIRECTDRAWSURFACE4 lp4=NULL;	

	if ( is4Bit )
		return E_FAIL;

	*rv = NULL;
	HRESULT hr = DD_OK;

	if( ( hr=m__dxj_DirectDraw4->GetGDISurface(&lp4) ) != DD_OK) 
		return hr;
	 		
	INTERNAL_CREATE(_dxj_DirectDrawSurface4, lp4, rv);

	return hr; 
}

///////////////////////////////////////////////////////////////////
// getVerticalBlankStatus
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getVerticalBlankStatus( long *status)
{
	if ( is4Bit )
		return E_FAIL;

	return m__dxj_DirectDraw4->GetVerticalBlankStatus((int *)status);
}

///////////////////////////////////////////////////////////////////
// setCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::setCooperativeLevel( HWnd hwn, long flags)
{
	if ( is4Bit )
		return E_FAIL;

	m_hwnd = (HWND)hwn;

	return m__dxj_DirectDraw4->SetCooperativeLevel((HWND)hwn, (DWORD)flags);
}

///////////////////////////////////////////////////////////////////
// waitForVerticalBlank
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::waitForVerticalBlank(long flags,long handle, long *status)
{
	if ( is4Bit )
		return E_FAIL;

	*status = m__dxj_DirectDraw4->WaitForVerticalBlank(flags, (void *)handle);
	return S_OK;
}



///////////////////////////////////////////////////////////////////
// createClipper
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createClipper(long flags, I_dxj_DirectDrawClipper **val)
{
	if ( is4Bit )
		return E_FAIL;
	DPF1(1,"enter DDraw4[%d]::createClipper ",creationid);

	//
	// need to create one of MY surfaces!
	//
	LPDIRECTDRAWCLIPPER		ddc;
	HRESULT hr = DD_OK;
	if( (hr=m__dxj_DirectDraw4->CreateClipper( flags, &ddc, NULL)) != DD_OK )
		return hr;

	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);

	DPF1(1,"exit DDraw4[%d]::createClipper ",creationid);

	return hr;
}

///////////////////////////////////////////////////////////////////
// createPalette
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createPalette(long flags, SAFEARRAY **pe, I_dxj_DirectDrawPalette **val)
{
	LPPALETTEENTRY ppe;
	
	if ( is4Bit )
		return E_FAIL;


	if (!ISSAFEARRAY1D(pe,(DWORD)256)) return E_INVALIDARG;

	ppe = (LPPALETTEENTRY)((SAFEARRAY*)*pe)->pvData;

	LPDIRECTDRAWPALETTE		ddp;
	HRESULT hr = DD_OK;
	
	*val = NULL;

	if( (hr=m__dxj_DirectDraw4->CreatePalette( flags, (LPPALETTEENTRY)ppe, &ddp, NULL)) == DD_OK )
	{
		INTERNAL_CREATE( _dxj_DirectDrawPalette, ddp, val);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
// createSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createSurface(DDSurfaceDesc2 *dd, I_dxj_DirectDrawSurface4 **retval)
{
	HRESULT retv;
	LPDIRECTDRAWSURFACE4	  dds4; // DirectX object pointer
	DDSURFACEDESC2			  ddsd;
	DPF1(1,"enter DDraw4[%d]::createSurface ",creationid);
	
	

	if ( is4Bit )
		return E_FAIL;

	if(! (dd && retval) )
		return E_POINTER;
		
	CopyInDDSurfaceDesc2(&ddsd,dd);

	//docdoc: CreateSurface returns error if 'punk' is anything but NULL
	retv = m__dxj_DirectDraw4->CreateSurface( &ddsd, &dds4, NULL);
	if FAILED(retv)	return retv;
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface4, dds4, retval);

	dd->lpSurface = NULL;

	
	DPF1(1,"exit DDraw4[%d]::createSurface ",creationid);
	
	


	return S_OK;
}

///////////////////////////////////////////////////////////////////
// duplicateSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::duplicateSurface(I_dxj_DirectDrawSurface4 *ddIn, I_dxj_DirectDrawSurface4 **ddOut)
{
	HRESULT retval;

	if ( is4Bit )
		return E_FAIL;

	//
	// need to create one of MY surfaces!
	//	
	LPDIRECTDRAWSURFACE4 lpddout4=NULL;


	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE4, lpddin, ddIn);

	if( (retval = m__dxj_DirectDraw4->DuplicateSurface(lpddin, &lpddout4)) != DD_OK )
		return retval;

	INTERNAL_CREATE( _dxj_DirectDrawSurface4, lpddout4, ddOut);

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getCaps
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getCaps(DDCaps *driverCaps,  DDCaps *HELcaps)
{
	if ( is4Bit )
		return E_FAIL;
	if (!driverCaps) return E_INVALIDARG;
	if (!HELcaps) return E_INVALIDARG;

	((DDCAPS*)driverCaps)->dwSize=sizeof(DDCAPS);
	((DDCAPS*)HELcaps)->dwSize=sizeof(DDCAPS);

	HRESULT hr = m__dxj_DirectDraw4->GetCaps((DDCAPS*)driverCaps, (DDCAPS*)HELcaps);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getDisplayMode
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getDisplayMode(DDSurfaceDesc2 *desc)
{
	HRESULT retval;
	DDSURFACEDESC2 ddsd;

	if (!desc) return E_INVALIDARG;

	CopyInDDSurfaceDesc2(&ddsd,desc);

	retval = m__dxj_DirectDraw4->GetDisplayMode(&ddsd);

	if( retval != S_OK)		
		return retval;

	CopyOutDDSurfaceDesc2(desc,&ddsd);

	desc->lpSurface = NULL;

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getAvailableTotalMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getAvailableTotalMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw4->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, (unsigned long *)m, NULL);
}

///////////////////////////////////////////////////////////////////
// getFreeMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getFreeMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw4->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, NULL, (unsigned long *)m);
}



///////////////////////////////////////////////////////////////////
// getNumFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getNumFourCCCodes(long *retval)
{
    return m__dxj_DirectDraw4->GetFourCCCodes((DWORD*)retval, NULL);
}


///////////////////////////////////////////////////////////////////
// getScanLine
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getScanLine(long *lines, long *status)
{ 
	*status = (long)m__dxj_DirectDraw4->GetScanLine((DWORD*)lines);
	return S_OK;
}

///////////////////////////////////////////////////////////////////
// loadPaletteFromBitmap
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::loadPaletteFromBitmap(BSTR bName, I_dxj_DirectDrawPalette **retval)
{
	USES_CONVERSION;
    IDirectDrawPalette* ddpal;
    int                 i;
    int                 n;
    int                 fh;
    HRSRC               h;
    LPBITMAPINFOHEADER  lpbi;
    PALETTEENTRY        ape[256];
    RGBQUAD *           prgb;
	
	HRESULT hr=S_OK;

	if ( is4Bit )	return E_FAIL;

	LPCTSTR szBitmap = W2T(bName);
	


    for (i=0; i<256; i++)		// build a 332 palette as the default
    {
        ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
        ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
        ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
        ape[i].peFlags = (BYTE)0;
    }

    //
    // get a pointer to the bitmap resource.
    //
    if (szBitmap && (h = FindResource(NULL, szBitmap, RT_BITMAP)))
    {
        lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h));
        if (!lpbi){
		DPF(1,"lock resource failed\n");
		return E_OUTOFMEMORY;			// error return...
	}
        prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi->biSize);

        if (lpbi == NULL || lpbi->biSize < sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (lpbi->biBitCount > 8)
            n = 0;
        else if (lpbi->biClrUsed == 0)
            n = 1 << lpbi->biBitCount;
        else
            n = lpbi->biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            ape[i].peRed   = prgb[i].rgbRed;
            ape[i].peGreen = prgb[i].rgbGreen;
            ape[i].peBlue  = prgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }
    }
    else if (szBitmap && (fh = _lopen(szBitmap, OF_READ)) != -1)
    {
        BITMAPFILEHEADER bf;
        BITMAPINFOHEADER bi;

        _lread(fh, &bf, sizeof(bf));
        _lread(fh, &bi, sizeof(bi));
        _lread(fh, ape, sizeof(ape));
        _lclose(fh);

        if (bi.biSize != sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (bi.biBitCount > 8)
            n = 0;
        else if (bi.biClrUsed == 0)
            n = 1 << bi.biBitCount;
        else
            n = bi.biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            BYTE r = ape[i].peRed;
            ape[i].peRed  = ape[i].peBlue;
            ape[i].peBlue = r;
        }
    }

    m__dxj_DirectDraw4->CreatePalette(DDPCAPS_8BIT, ape, &ddpal, NULL);

	if( ddpal )
	{
		INTERNAL_CREATE(_dxj_DirectDrawPalette, ddpal, retval);
	}
	else
	{
		//
		// no object, set the return value to NULL as well.
		//
		*retval = NULL;
		hr = E_FAIL;
	}

    return hr;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromFile
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::createSurfaceFromFile(BSTR file, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface4 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromFile ",creationid);


	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
    HRESULT						hr;
	HBITMAP						hbm;
	HRESULT						retv;
	LPDIRECTDRAWSURFACE4		dds4; // DirectX object pointer	
	LPSTR						szFileName=NULL;
    int							width=0;
    int							height=0;


	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;
	
	
	USES_CONVERSION;
	szFileName=W2T(file);

	
	


	//If width and height are zero then we will generate our own width and
	//height from the bitmap.
	//The LoadImage api however doesnt work propery without size params
	//Consider there must be a way to make it work.
	if ((desc->lWidth!=0)&&(desc->lHeight!=0)&&(desc->lFlags & DDSD_WIDTH)&&(desc->lFlags & DDSD_HEIGHT))
	{
		width=desc->lWidth ;
		height=desc->lHeight; 
	}

	if (desc->lFlags==0) {
		desc->lFlags=DDSD_CAPS;
		((DDSURFACEDESC*)desc)->ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
	}
	

	if (!szFileName) return CTL_E_FILENOTFOUND;	

	hbm = (HBITMAP)LoadImage((HINSTANCE)NULL, szFileName, IMAGE_BITMAP, 
				width, height, 
					LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	
	if (!hbm) return CTL_E_FILENOTFOUND;

	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	width=bm.bmWidth;
	height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw4->CreateSurface(&ddsd, &dds4, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface4, dds4, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
     dds4->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds4->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds4->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(buffer,"exit DDraw4[%d]::createSurfaceFromFile",creationid);	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromResource
///////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDraw4Object::createSurfaceFromResource(BSTR resFile, BSTR resourceName, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface4 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromResource ",creationid);

	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;


	HRESULT hr;
    	HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;

	HDC							hdc;
	HDC							hdcImage;
    	BITMAP						bm;
	HBITMAP						hbm;
	HRESULT						retv;		
	LPDIRECTDRAWSURFACE4		dds4; // DirectX object pointer	
	LPSTR						szResName=NULL;

	if (!resourceName)	return E_INVALIDARG;
	if (!surf)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE: we used to call 
		// GetModuleHandleW but it   returned 0 on w98			
		// so we use the ANSI version which works on w98 
		 LPCTSTR pszName = W2T(resFile);
		 hMod= GetModuleHandle(pszName);
	}
	else {
		hMod= GetModuleHandle(NULL);
	}


	
	LPCTSTR pszName2 = W2T(resourceName);
	

    	hbm = (HBITMAP)LoadImage((HINSTANCE)hMod, 
					pszName2, 
					IMAGE_BITMAP, 
					0, 0, 
					LR_CREATEDIBSECTION);


	if (!hbm){
		return E_FAIL;
	}


	// get size of the bitmap
	//	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	DWORD width=bm.bmWidth;
	DWORD height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw4->CreateSurface(&ddsd, &dds4, NULL)) != DD_OK )
	{
  		if (hbm) DeleteObject(hbm);
		return retv;
        }

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface4, dds4, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
    dds4->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

    if (!hdcImage){
		DeleteObject(hbm);
		return E_OUTOFMEMORY;
    }

    SelectObject(hdcImage, hbm);		
	

    if ((hr = dds4->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds4->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(1r,"exit DDraw4[%d]::createSurfaceFromFile",creationid);
	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// getFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getFourCCCodes(SAFEARRAY **ppsa)
{
	DWORD count= ((SAFEARRAY*)*ppsa)->rgsabound[0].cElements;
	if ( ((SAFEARRAY*)*ppsa)->cDims!=1) return E_INVALIDARG;

    return m__dxj_DirectDraw4->GetFourCCCodes(&count,(DWORD*)((SAFEARRAY*)*ppsa)->pvData);

}

///////////////////////////////////////////////////////////////////
// getDisplayModesEnum
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval)
{
	HRESULT hr;	
	hr=C_dxj_DirectDrawEnumModesObject::create(m__dxj_DirectDraw4,flags, ddsd,  retval);
	return hr;	
}

///////////////////////////////////////////////////////////////////
// testCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::testCooperativeLevel( 
            /* [in,out] */ long *status)
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw4->TestCooperativeLevel();
	*status=(long)hr;
	return S_OK;	
}

///////////////////////////////////////////////////////////////////
// restoreAllSurfaces
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw4Object::restoreAllSurfaces()
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw4->RestoreAllSurfaces();
	return hr;	
}

STDMETHODIMP C_dxj_DirectDraw4Object::getSurfaceFromDC(long hdc, I_dxj_DirectDrawSurface4 **ret)
{
	HRESULT hr;	
	LPDIRECTDRAWSURFACE4 pDDS=NULL;
	hr=m__dxj_DirectDraw4->GetSurfaceFromDC((HDC)hdc,&pDDS);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectDrawSurface4,pDDS,ret);
	return hr;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddsurface4obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface4obj.h
//
//--------------------------------------------------------------------------

// ddSurfaceObj.h : Declaration of the C_dxj_DirectDrawSurfaceObject


#include "resource.h"       // main symbols

//#define typedef__dxj_DirectDrawSurface LPDIRECTDRAWSURFACE
// 2nd #define helps with macros - same thing
//#define typedef__dxj_DirectDrawSurface  LPDIRECTDRAWSURFACE
#define typedef__dxj_DirectDrawSurface4 LPDIRECTDRAWSURFACE4

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawSurface4Object :
	public I_dxj_DirectDrawSurface4,	
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawSurface4Object() ;
	virtual ~C_dxj_DirectDrawSurface4Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_DirectDrawSurface4Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawSurface4)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectDrawSurface4Object)

// I_dxj_DirectDrawSurface4
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdds);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdds);

		HRESULT STDMETHODCALLTYPE addAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddS) ;
        
        HRESULT STDMETHODCALLTYPE blt( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltColorFill( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ long fillvalue,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFast( 
            /* [in] */ long dx,
            /* [in] */ long dy,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long trans,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFx( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [in] */ DDBltFx __RPC_FAR *bltfx,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltToDC( 
            /* [in] */ long hdc,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ Rect __RPC_FAR *destRect);
        
        HRESULT STDMETHODCALLTYPE changeUniquenessValue( void);
        
        HRESULT STDMETHODCALLTYPE deleteAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds);
        
        HRESULT STDMETHODCALLTYPE drawBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawCircle( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long r);
        
        HRESULT STDMETHODCALLTYPE drawEllipse( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawLine( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawRoundedBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2,
            /* [in] */ long rw,
            /* [in] */ long rh);
        
        HRESULT STDMETHODCALLTYPE drawText( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ BSTR text,
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE flip( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *dds,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getAttachedSurface( 
            /* [in] */ DDSCaps2 __RPC_FAR *caps,
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *dds);
                
        HRESULT STDMETHODCALLTYPE getBltStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDSCaps2 __RPC_FAR *caps);
        
        HRESULT STDMETHODCALLTYPE getClipper( 
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getColorKey( 
            /* [in] */ long flags,
            /* [out][in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getDC( 
            /* [retval][out] */ long __RPC_FAR *hdc);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw4 __RPC_FAR *__RPC_FAR *val);
        
        
        HRESULT STDMETHODCALLTYPE getDrawStyle( 
            /* [retval][out] */ long __RPC_FAR *drawStyle);
        
        HRESULT STDMETHODCALLTYPE getDrawWidth( 
            /* [retval][out] */ long __RPC_FAR *drawWidth);
        
        HRESULT STDMETHODCALLTYPE getFillColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getFillStyle( 
            /* [retval][out] */ long __RPC_FAR *fillStyle);
        
        HRESULT STDMETHODCALLTYPE getFlipStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getFontTransparency( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
        HRESULT STDMETHODCALLTYPE getForeColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ long __RPC_FAR *col);
        
        HRESULT STDMETHODCALLTYPE getPalette( 
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getPixelFormat( 
            /* [out][in] */ DDPixelFormat __RPC_FAR *pf);
        
        HRESULT STDMETHODCALLTYPE getSurfaceDesc( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
        HRESULT STDMETHODCALLTYPE getUniquenessValue( 
            /* [retval][out] */ long __RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE isLost( 
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ Rect __RPC_FAR *r,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [in] */ Handle hnd);
        
        HRESULT STDMETHODCALLTYPE releaseDC( 
            /* [in] */ long hdc);
        
        HRESULT STDMETHODCALLTYPE restore( void);
        
        HRESULT STDMETHODCALLTYPE setClipper( 
            /* [in] */ I_dxj_DirectDrawClipper __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setColorKey( 
            /* [in] */ long flags,
            /* [in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setDrawStyle( 
            /* [in] */ long drawStyle);
        
        HRESULT STDMETHODCALLTYPE setDrawWidth( 
            /* [in] */ long drawWidth);
        
        HRESULT STDMETHODCALLTYPE setFillColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setFillStyle( 
            /* [in] */ long fillStyle);
        
        HRESULT STDMETHODCALLTYPE setFont( 
            /* [in] */ IFont __RPC_FAR *font);
        
        HRESULT STDMETHODCALLTYPE setFontTransparency( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setForeColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ long col);
                
        HRESULT STDMETHODCALLTYPE setPalette( 
            /* [in] */ I_dxj_DirectDrawPalette __RPC_FAR *ddp);
        
        HRESULT STDMETHODCALLTYPE unlock( 
            /* [in] */ Rect __RPC_FAR *r);

		HRESULT STDMETHODCALLTYPE getLockedArray(SAFEARRAY **pArray);

        HRESULT STDMETHODCALLTYPE setFontBackColor( 
            /* [in] */ long color);

		HRESULT STDMETHODCALLTYPE getFontBackColor( 
            /* [out,retval] */ long *color);

        
////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDrawSurface4);
	//BOOL m_primaryflag;

private:
	C_dxj_DirectDrawSurface4Object *_dxj_DirectDrawSurface4Lock;


	DDSURFACEDESC2	m_ddsd;
	BOOL			m_bLocked;
	int				m_nPixelBytes;

	BOOL	m_fFontTransparent;
	BOOL	m_fFillSolid;
	BOOL	m_fFillTransparent;
	DWORD	m_fillStyle;
	DWORD	m_fillStyleHS;
	DWORD	m_fillColor;
	DWORD	m_foreColor;
	DWORD	m_fontBackColor;
	DWORD	m_drawStyle;
	DWORD	m_drawWidth;
	HPEN	m_hPen;
	HBRUSH	m_hBrush;
	HFONT	m_hFont;
	IFont	*m_pIFont;
	SAFEARRAY **m_ppSA;
	BOOL	m_bLockedArray;
	SAFEARRAY m_saLockedArray;
	DWORD	m_pad[4];
	
	

//pac

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDrawSurface4)
};


// 
// Copies values from native unions into redundant Java members.
void 	ExpandDDSurface4Desc(LPDDSURFACEDESC lpDesc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddsurface4obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface4obj.cpp
//
//--------------------------------------------------------------------------

    // ddSurfaceObj.cpp : Implementation of CDirectApp and DLL registration.
    #include "stdafx.h"
    #include "stdio.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dDraw4Obj.h"
    #include "ddClipperObj.h"    
    #include "ddSurface4Obj.h"
    #include "ddPaletteObj.h"
    
    
	

    
    
    
    C_dxj_DirectDrawSurface4Object::C_dxj_DirectDrawSurface4Object(){ 
    	m__dxj_DirectDrawSurface4= NULL;
    	parent = NULL;
    	pinterface = NULL; 
    	nextobj =  g_dxj_DirectDrawSurface4;
    	creationid = ++g_creationcount;
    
    	DPF1(1,"Constructor Creation Surface7 [%d] \n",g_creationcount);
    
    	g_dxj_DirectDrawSurface4 = (void *)this; 
    	_dxj_DirectDrawSurface4Lock=NULL; 
    
    	m_bLocked=FALSE;
    
    	m_drawStyle = 0;	//solid lines are default for DDraw
    	m_fillStyle = 1;	//transparent fill is default since DDRaw has no selected Brush
    	m_fFontTransparent = TRUE;
    	m_fFillTransparent = TRUE;
    	m_fFillSolid=TRUE;
    	m_foreColor = 0;	//black is the default color.
		m_fontBackColor=-1;	//white
    	m_drawWidth = 1;
    	m_hPen = NULL; 
    	m_hBrush = NULL;
    	m_hFont=NULL;
	  	m_pIFont=NULL;
		m_bLockedArray=FALSE;
		m_ppSA=NULL;
		
		setFillStyle(1);	//transparent

     }
    
    
    DWORD C_dxj_DirectDrawSurface4Object::InternalAddRef(){
    	DWORD i;
    	i=CComObjectRoot::InternalAddRef();        	
    	DPF2(1,"Surf7 [%d] AddRef %d \n",creationid,i);
    	return i;
    }
    
    DWORD C_dxj_DirectDrawSurface4Object::InternalRelease(){
    	DWORD i;
    	i=CComObjectRoot::InternalRelease();
    	DPF2(1,"Surf4 [%d] Release %d \n",creationid,i);
    	return i;
    }
    
    
    C_dxj_DirectDrawSurface4Object::~C_dxj_DirectDrawSurface4Object()
    {

		
        C_dxj_DirectDrawSurface4Object *prev=NULL; 
    	for(C_dxj_DirectDrawSurface4Object *ptr=(C_dxj_DirectDrawSurface4Object *)g_dxj_DirectDrawSurface4; ptr; ptr=(C_dxj_DirectDrawSurface4Object *)ptr->nextobj) 
    	{
    		if(ptr == this) 
    		{ 
    			if(prev) 
    				prev->nextobj = ptr->nextobj; 
    			else 
     				g_dxj_DirectDrawSurface4 = (void*)ptr->nextobj; 
    			break; 
    		} 
    		prev = ptr; 
    	} 
    	if(m__dxj_DirectDrawSurface4){
    		int count = IUNK(m__dxj_DirectDrawSurface4)->Release();
    		
    		DPF1(1,"DirectX IDirectDrawSurface4 Ref count [%d]",count);
    
    		if(count==0) m__dxj_DirectDrawSurface4 = NULL;
    	} 
    	if(parent) IUNK(parent)->Release();
    
    
    	 
        if (m_hFont)  DeleteObject (m_hFont);
        if (m_hPen)   DeleteObject (m_hPen);
        if (m_hBrush) DeleteObject (m_hBrush);
	  	if (m_pIFont) m_pIFont->Release();
    
    }
    
    
    
    GETSET_OBJECT(_dxj_DirectDrawSurface4);
    
    RETURN_NEW_ITEM_R(_dxj_DirectDrawSurface4, getPalette, GetPalette, _dxj_DirectDrawPalette)
    
    GET_DIRECT_R(_dxj_DirectDrawSurface4,  isLost, IsLost, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface4, getBltStatus,  GetBltStatus,  long, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface4, getFlipStatus, GetFlipStatus, long, long)
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::addAttachedSurface(I_dxj_DirectDrawSurface4 *s3)
    {
    	HRESULT hr;	
    
    	IDirectDrawSurface4 *realsurf=NULL;
    	if (s3) s3->InternalGetObject((IUnknown**)&realsurf);
    
    	if (m__dxj_DirectDrawSurface4 == NULL) return E_FAIL;
    	hr=m__dxj_DirectDrawSurface4->AddAttachedSurface(realsurf);
    	
    	return hr;
    }
    
    
    
    

    
    
    
    
    PASS_THROUGH_CAST_1_R(_dxj_DirectDrawSurface4,releaseDC,ReleaseDC,long,(HDC ))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface4,setColorKey,SetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface4,getColorKey,GetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getDC(long *hdc)
    {	
          return m__dxj_DirectDrawSurface4->GetDC((HDC*)hdc);
    }
    
    
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::lock(  Rect *r,  DDSurfaceDesc2 *desc,  long flags,  Handle hnd)
    {
    	if (m_bLocked) return E_FAIL;
    	
    	HRESULT hr;
    
    	CopyInDDSurfaceDesc2(&m_ddsd,desc);
    
   		
		hr = m__dxj_DirectDrawSurface4->Lock(NULL,&m_ddsd,(DWORD)flags,(void*)hnd);
        if FAILED(hr) return hr;

     	CopyOutDDSurfaceDesc2(desc,&m_ddsd);
    
    	
    	m_bLocked=TRUE;
    	m_nPixelBytes=m_ddsd.ddpfPixelFormat.dwRGBBitCount/8; 
    	return hr;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::unlock(  Rect *r)
    {
    	HRESULT hr;
    	//__try {
		if (m_bLockedArray) {				
			*m_ppSA=NULL;
			m_bLockedArray=FALSE;			
		}
		

    	//hr = m__dxj_DirectDrawSurface4->Unlock((RECT*)r);
		hr = m__dxj_DirectDrawSurface4->Unlock(NULL);
    
    	if FAILED(hr) return hr	;
    	m_bLocked=FALSE;
    
    	return hr;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setLockedPixel( int x,  int y,  long col)
    {
    	if (!m_bLocked) return E_FAIL;
    
    	//__try {
    
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*((WORD*)pByte)=(WORD)col;	
    		}
    		else if (m_nPixelBytes==4){
    			*((DWORD*)pByte)=(DWORD)col;	
    		}
    		else if (m_nPixelBytes==1){
    			*pByte=(Byte)col;
    		}
    		else if (m_nPixelBytes==3){
				*(pByte)= (char)(col & 0xFF);
				pByte++;
				*(pByte)= (char)((col & 0xFF00)>>8);
				pByte++;
    			*(pByte)= (char)((col & 0xFF0000)>>16);
		}

    		else{
    			return E_FAIL;
    		}
       	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	return S_OK;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getLockedPixel( int x,  int y,  long *col)
    {
    	//__try {
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*col=(long) *((WORD*)pByte);	
    		}
    		else if (m_nPixelBytes==4){
    			*col=(long) *((DWORD*)pByte);	
    		}
	   		else if (m_nPixelBytes==3){
    			*col=(long) (*((DWORD*)pByte))& 0x00FFFFFF;	
    		}
    		else if (m_nPixelBytes==1){
    			*col=(long) *((long*)pByte);
    		}
    		else{
    			return E_FAIL;
     		}

    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getClipper( I_dxj_DirectDrawClipper **val)
    {
    	LPDIRECTDRAWCLIPPER		ddc;
    	HRESULT hr=DD_OK;
    	if( (hr=m__dxj_DirectDrawSurface4->GetClipper( &ddc)) != DD_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);
    
    	return S_OK;
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // this is NOT the normal Blt, that is BltFx in our interface
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::blt( Rect *pDest, I_dxj_DirectDrawSurface4 *ddS, Rect *pSrc, long flags, long *status)
    {
    	
    	LPDIRECTDRAWSURFACE4 lpdds = NULL;
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc =(LPRECT)pSrc;
    	
    	if (!ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    	
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->Blt(prcDest, lpdds, prcSrc, flags, NULL);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    											
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::bltFx(Rect *pDest, I_dxj_DirectDrawSurface4 *ddS, Rect *pSrc, long flags, DDBltFx *bltfx, long *status )
    {
    
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc= (LPRECT)pSrc;
    	LPDIRECTDRAWSURFACE4 lpdds = NULL;
    
    	if ( !ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    
    	if(bltfx)	bltfx->lSize = sizeof(DDBLTFX);
    
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->Blt(prcDest, lpdds, prcSrc, flags, (struct _DDBLTFX *)bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::bltColorFill( Rect *pDest, long fillvalue, long *status )
    {
    	HWnd hWnd = NULL;
    
    	DDBLTFX bltfx;
    
    	memset(&bltfx,0,sizeof(DDBLTFX));
    	bltfx.dwSize = sizeof(DDBLTFX);
    	bltfx.dwFillColor = (DWORD)fillvalue;
    
    
    	LPRECT prcDest=(LPRECT)pDest;
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->Blt(prcDest, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::bltFast( long dx, long dy, I_dxj_DirectDrawSurface4 *dds, Rect *src, long trans, long *status)
    {
    
		if (!dds) return E_INVALIDARG;

    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4,lpdds,dds)
    	
    	LPRECT prcSrc=(LPRECT)src;
    
		if (!src) return E_INVALIDARG;

    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface4->BltFast(dx, dy, lpdds, prcSrc, trans);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::deleteAttachedSurface( I_dxj_DirectDrawSurface4 *dds)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpdds, dds)
    
    	return m__dxj_DirectDrawSurface4->DeleteAttachedSurface(0, lpdds);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::flip( I_dxj_DirectDrawSurface4 *dds, long flags)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4,lpdds,dds)
    
    	return m__dxj_DirectDrawSurface4->Flip(lpdds, flags);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getAttachedSurface( DDSCaps2  *caps, I_dxj_DirectDrawSurface4 **dds)
    {
    	LPDIRECTDRAWSURFACE4 lpdds;	
    	HRESULT hr=DD_OK;
    	
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetAttachedSurface( (DDSCAPS2*)caps, &lpdds)) != S_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawSurface4, lpdds, dds);
    
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getCaps( DDSCaps2 *caps)
    {
    	
    	HRESULT hr=DD_OK;
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetCaps((DDSCAPS2*)caps)) != S_OK)
    		return hr;
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getPixelFormat( DDPixelFormat *pf)
    {
    	
    	HRESULT hr=DD_OK;
    
    	DDPIXELFORMAT ddpf;
    	ddpf.dwSize = sizeof(DDPIXELFORMAT);
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetPixelFormat(&ddpf)) != S_OK)
    		return hr;
    
    	CopyOutDDPixelFormat(pf,&ddpf);
    
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getSurfaceDesc( DDSurfaceDesc2 *desc)
    {
    	desc->lpSurface = NULL;
    	HRESULT hr=DD_OK;
    
    	DDSURFACEDESC2 ddsd;
    	ddsd.dwSize=sizeof(DDSURFACEDESC2);
    	ddsd.ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
    	ddsd.lpSurface=NULL;
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetSurfaceDesc( &ddsd )) != S_OK )
    		return hr;
    
    	CopyOutDDSurfaceDesc2(desc,&ddsd);
    		
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::restore()
    {
    	return m__dxj_DirectDrawSurface4->Restore();
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setPalette( I_dxj_DirectDrawPalette *ddp)
    {
    	//
    	// ignore the return value here. Will only work on 256 colours anyway!
    	//
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWPALETTE,lpddp,ddp)
    
    	return m__dxj_DirectDrawSurface4->SetPalette(lpddp);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getDirectDraw( I_dxj_DirectDraw4 **val)
    {
    
    	IUnknown *pUnk=NULL;
    	LPDIRECTDRAW4 lpdd;
    	HRESULT hr=DD_OK;
    
    
    	if( (hr=m__dxj_DirectDrawSurface4->GetDDInterface((void **)&pUnk)) != S_OK)
    		return hr;
    	
    	hr=pUnk->QueryInterface(IID_IDirectDraw4,(void**)&lpdd);
    	if FAILED(hr) {
    		if (pUnk) pUnk->Release();
    		return hr;
    	}
    
    	INTERNAL_CREATE(_dxj_DirectDraw4, lpdd, val);
    
    	return S_OK;
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setClipper(I_dxj_DirectDrawClipper *val)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWCLIPPER, lpc, val);
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface4->SetClipper( lpc);
    	return hr;	
    }

    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::changeUniquenessValue()
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface4->ChangeUniquenessValue();	
    	return hr;
    }
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::getUniquenessValue(long *ret)
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface4->GetUniquenessValue((DWORD*)ret);	
    	return hr;
    }
    	 	 			
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface4Object::setFont( 
                /* [in] */ IFont __RPC_FAR *font)
    {
    
  	HRESULT hr;
    	if (!font) return E_INVALIDARG;
  	if (m_pIFont) m_pIFont->Release();
  	m_pIFont=NULL;
  	hr=font->Clone(&m_pIFont);
  	return hr;
  	   	
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFontTransparency(VARIANT_BOOL b)
    {
    	m_fFontTransparent=(b!=VARIANT_FALSE);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFontTransparency(VARIANT_BOOL *b)
    {
    	if (m_fFontTransparent) 
    		*b= VARIANT_TRUE;
    	else 
    		*b= VARIANT_FALSE;
    	return S_OK;
    }
    
    
          
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setDrawWidth(  long drawWidth)
    {	
                HPEN hNewPen=NULL;
    		if (drawWidth < 1) return E_INVALIDARG;
    		m_drawWidth=drawWidth;		
    		hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    		if (!hNewPen) return E_INVALIDARG;
    		DeleteObject(m_hPen);    
    		m_hPen=hNewPen;
    		return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getDrawWidth(long *val)
    {
    	*val=m_drawWidth;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setDrawStyle(long drawStyle)
    {
    
        HPEN hNewPen=NULL;     
    	m_drawStyle=drawStyle;		
    	hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
    	DeleteObject(m_hPen);    
    	m_hPen=hNewPen;
    	return S_OK;
    }	
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getDrawStyle(long __RPC_FAR *val)
    {
    	*val=m_drawStyle;
    	return S_OK;
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFillStyle(long fillStyle)
    {
    	
        HBRUSH hNewBrush=NULL;
    
    	
		BOOL fillTransparent =m_fFillTransparent;
		BOOL fillSolid=m_fFillSolid;
		long fillStyle2=fillStyle;

		m_fillStyle = fillStyle;    
    	m_fFillTransparent = FALSE;
    	m_fFillSolid = FALSE;

    	switch(fillStyle){
    		case 6:	//vbCross:
    			m_fillStyleHS = HS_CROSS;
    			break;
    		case 7:	//vbDiagonalCross:
    			m_fillStyleHS = HS_DIAGCROSS;
    			break;
    		case 5: //vbxDownwardDiagonal:
    			m_fillStyleHS = HS_BDIAGONAL;
    			break;
    		case 2: //vbHorizontalLine:
    			m_fillStyleHS = HS_HORIZONTAL;
    			break;
    		case 4: //vbUpwardDiagonal:
    			m_fillStyleHS = HS_FDIAGONAL;
    			break;
    		case 3: //vbVerticalLine:
    			m_fillStyleHS = HS_VERTICAL;
    			break;
    		case 0: ///vbFSSolid:
    			m_fFillSolid = TRUE;
    			break;
    		case 1: //vbFSTransparent:
    			m_fFillTransparent = TRUE;
    			m_fFillSolid = TRUE;
				break;
    		default:
				m_fFillTransparent = fillTransparent;
    			m_fFillSolid = fillSolid;
				m_fillStyle=fillStyle2;
    			return E_INVALIDARG;
    	}
    
    
    	if (m_fFillTransparent) {
    		LOGBRUSH logb;
    		logb.lbStyle = BS_NULL;
    		hNewBrush = CreateBrushIndirect(&logb);
    	}
    	else if (m_fFillSolid) {
    		hNewBrush = CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush = CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
    	if (!hNewBrush) return E_FAIL;
    
    	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFillStyle(long *val)
    {
    	*val=m_fillStyle;
    	return S_OK;
    }
    
    	
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFillColor(long c)
    {   
    	m_fillColor = c;
        HBRUSH  hNewBrush;
    
    	if (m_fFillSolid){
    		hNewBrush= CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush= CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
        
    	if (!hNewBrush) return E_INVALIDARG;
  	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFillColor(long *val)
    {
    	*val=m_fillColor;
    	return S_OK;
    }
    
            
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setForeColor(  long color)
    {
    	m_foreColor=color;
        HPEN hNewPen=NULL;
                    
        
        hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
        if (m_hPen)  DeleteObject (m_hPen);
    	m_hPen=hNewPen;
    	return S_OK;
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getForeColor(long *val)
    {
    	*val=m_foreColor;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawLine( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	POINT points[2];
        HRESULT hr;
    
        hr =m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        points[0].x = x1;
        points[0].y = y1;
        
        
        points[1].x = x2;
        points[1].y = y2;
        
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        
        Polyline(hdc, points, 2);
        
    	//why do this..
        //if (oldpen)   SelectObject(hdc, oldpen);
        //if (oldbrush) SelectObject(hdc, oldbrush);
            
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
        
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
        HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
           
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }

     
        Rectangle(hdc, x1,y1,x2,y2);
        
            
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawRoundedBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2,
                /* [in] */ long rw,
                /* [in] */ long rh)
    
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }

        
        RoundRect(hdc, x1,y1,x2,y2,rw,rh);
                    
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }        
        
        
        
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawEllipse( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    
        hr=m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
        
    	Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }        
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawCircle( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ long r)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    	long x1,y1,x2,y2;
    
        hr= m__dxj_DirectDrawSurface4->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);        
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
            
        x1 = x - r;
        x2 = x + r;
        y1 = y - r;
        y2 = y + r;
    
        Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::drawText( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ BSTR str,
                /* [in] */ VARIANT_BOOL b)
    {
        HDC hdc=NULL;
    	HRESULT hr;	
    	DWORD len=0;
    	UINT txtA;
    
    	if (!str) return E_INVALIDARG;

	  	len = ((DWORD*)str)[-1]/2;
    
        hr=m__dxj_DirectDrawSurface4->GetDC(&hdc);
    	if FAILED(hr) return hr;
    	    	
    
        if (m_fFontTransparent){             
			 SetBkMode (hdc, TRANSPARENT);			 
    	}
    	else {    
			 SetBkMode (hdc, OPAQUE);
			 SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
        
        SetTextColor(hdc, m_foreColor);
        

        
    	txtA=GetTextAlign(hdc);
    	if (b!=VARIANT_FALSE){				
    		if (!(txtA & TA_UPDATECP)) SetTextAlign(hdc,txtA | TA_UPDATECP);
    	}
    	else {		
    		if (txtA & TA_UPDATECP)	SetTextAlign(hdc,txtA-TA_UPDATECP);			
    	}
    	
  	if (m_pIFont) {
  		HFONT hFont=NULL;
  		m_pIFont->SetHdc(hdc);
  	    m_pIFont->get_hFont(&hFont);
  		SelectObject (hdc, hFont);
  	}
  
        ExtTextOutW(hdc, (int)x, (int)y, 0, 0, str, len, 0);
    
    	m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	return S_OK;
    
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::bltToDC( 
                /* [in] */ long hdcDest,
                /* [in] */ Rect __RPC_FAR *srcRect,
                /* [in] */ Rect __RPC_FAR *destRect)
    {
    	HRESULT hr;
    	BOOL b;
    	HDC		hdc=NULL;
    	
    	if (!srcRect) return E_INVALIDARG;
    	if (!destRect) return E_INVALIDARG;
    
    	hr=m__dxj_DirectDrawSurface4->GetDC(&hdc);
    	if FAILED(hr) return hr;
    	
    	int nWidthDest= destRect->right-destRect->left;
    	int nHeightDest=destRect->bottom-destRect->top;
    	int nWidthSrc= srcRect->right-srcRect->left;
    	int nHeightSrc=srcRect->bottom-srcRect->top;
    
				
		
		if ((0==srcRect->top) && (0==srcRect->left ) && (0==srcRect->top) &&(0==srcRect->bottom ))
		{
			DDSURFACEDESC2 desc;
			desc.dwSize=sizeof(DDSURFACEDESC2);
			m__dxj_DirectDrawSurface4->GetSurfaceDesc(&desc);
			nWidthSrc=desc.dwWidth;
			nHeightSrc=desc.dwHeight;
		}


    	b=StretchBlt((HDC)hdcDest,
    		destRect->left,destRect->top,
    		nWidthDest, nHeightDest,
    		hdc,
    		srcRect->left,srcRect->top,
    		nWidthSrc, nHeightSrc, SRCCOPY);
      
    
    	m__dxj_DirectDrawSurface4->ReleaseDC(hdc);
    	
    	//CONSIDER: are we being presumptious that if blt fails its due to arg probs?
    	if (!b) return E_INVALIDARG;
    
    	return S_OK;
    
    }


	STDMETHODIMP C_dxj_DirectDrawSurface4Object::getLockedArray(SAFEARRAY **pArray)
	{
		

		if (!m_bLocked) return E_FAIL;
		

		if (!pArray) return E_INVALIDARG;
		if (*pArray) return E_INVALIDARG;
		m_ppSA=pArray;


		m_bLockedArray=TRUE;

		ZeroMemory(&m_saLockedArray,sizeof(SAFEARRAY));
		m_saLockedArray.cbElements =1;
		m_saLockedArray.cDims =2;
		m_saLockedArray.rgsabound[0].lLbound =0;
		m_saLockedArray.rgsabound[0].cElements =m_ddsd.dwHeight;
		m_saLockedArray.rgsabound[1].lLbound =0;
		m_saLockedArray.rgsabound[1].cElements =m_ddsd.lPitch;
		m_saLockedArray.pvData =m_ddsd.lpSurface;

		
		*pArray=&m_saLockedArray;
    
		
    	return S_OK;
	}



	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::setFontBackColor( 
                /* [in] */ long color)
    {
		m_fontBackColor=(DWORD)color;
    	return S_OK;
    }
    

	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface4Object::getFontBackColor( 
                /* [in] */ long *color)
    {    	
		if (!color) return E_INVALIDARG;            
        *color=(DWORD)m_fontBackColor;    	                    
    	return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddsurfacedescobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ddsurfacedescobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DDSurfaceDescObject : 
	public I_dxj_DDSurfaceDesc,
	public CComCoClass<C_dxj_DDSurfaceDescObject, &CLSID__dxj_DDSurfaceDesc>, 
	public CComObjectRoot
{
public:
	C_dxj_DDSurfaceDescObject() ;
	virtual ~C_dxj_DDSurfaceDescObject() ;

BEGIN_COM_MAP(C_dxj_DDSurfaceDescObject)
	COM_INTERFACE_ENTRY( I_dxj_DDSurfaceDesc)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DDSurfaceDescObject)
DECLARE_REGISTRY(CLSID__dxj_DDSurfaceDesc,	"DIRECT.DDSurfaceDesc.5",		"DIRECT.DDSurfaceDesc.5",	IDS_GENERIC_DESC, THREADFLAGS_BOTH)


public:

        HRESULT STDMETHODCALLTYPE getDescription( DDSurfaceDesc *desc);
		HRESULT STDMETHODCALLTYPE setDescription( DDSurfaceDesc *desc);

private:
		DDSurfaceDesc m_desc;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddsurface7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface7obj.h
//
//--------------------------------------------------------------------------

// ddSurfaceObj.h : Declaration of the C_dxj_DirectDrawSurfaceObject


#include "resource.h"       // main symbols
#define typedef__dxj_DirectDrawSurface7 LPDIRECTDRAWSURFACE7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectDrawSurface7Object :
	public I_dxj_DirectDrawSurface7,
	//public CComCoClass<C_dxj_DirectDrawSurface7Object, &CLSID__dxj_DirectDrawSurface7>,
	public CComObjectRoot
{
public:
	C_dxj_DirectDrawSurface7Object() ;
	virtual ~C_dxj_DirectDrawSurface7Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_DirectDrawSurface7Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectDrawSurface7)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectDrawSurface7,  "DIRECT.ddSurface4.3",	"DIRECT.DirectDrawSurface7.3",	IDS_DDSURFACE_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectDrawSurface7Object) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectDrawSurface7Object)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectDrawSurface7
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdds);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdds);

		HRESULT STDMETHODCALLTYPE addAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddS) ;
        
        HRESULT STDMETHODCALLTYPE blt( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltColorFill( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ long fillvalue,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFast( 
            /* [in] */ long dx,
            /* [in] */ long dy,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long trans,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltFx( 
            /* [in] */ Rect __RPC_FAR *destRect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *ddS,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ long flags,
            /* [in] */ DDBltFx __RPC_FAR *bltfx,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE bltToDC( 
            /* [in] */ long hdc,
            /* [in] */ Rect __RPC_FAR *srcRect,
            /* [in] */ Rect __RPC_FAR *destRect);
        
        HRESULT STDMETHODCALLTYPE changeUniquenessValue( void);
        
        HRESULT STDMETHODCALLTYPE deleteAttachedSurface( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds);
        
        HRESULT STDMETHODCALLTYPE drawBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawCircle( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long r);
        
        HRESULT STDMETHODCALLTYPE drawEllipse( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawLine( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2);
        
        HRESULT STDMETHODCALLTYPE drawRoundedBox( 
            /* [in] */ long x1,
            /* [in] */ long y1,
            /* [in] */ long x2,
            /* [in] */ long y2,
            /* [in] */ long rw,
            /* [in] */ long rh);
        
        HRESULT STDMETHODCALLTYPE drawText( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ BSTR text,
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE flip( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getAttachedSurface( 
            /* [in] */ DDSCaps2 __RPC_FAR *caps,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *dds);
        
        HRESULT STDMETHODCALLTYPE getAttachedSurfaceEnum( 
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *retval);
        
        HRESULT STDMETHODCALLTYPE getBltStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DDSCaps2 __RPC_FAR *caps);
        
        HRESULT STDMETHODCALLTYPE getClipper( 
            /* [retval][out] */ I_dxj_DirectDrawClipper __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getColorKey( 
            /* [in] */ long flags,
            /* [out][in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getDC( 
            /* [retval][out] */ long __RPC_FAR *hdc);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getDirectDrawColorControl( 
            /* [retval][out] */ I_dxj_DirectDrawColorControl __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDirectDrawGammaControl( 
            /* [retval][out] */ I_dxj_DirectDrawGammaControl __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDrawStyle( 
            /* [retval][out] */ long __RPC_FAR *drawStyle);
        
        HRESULT STDMETHODCALLTYPE getDrawWidth( 
            /* [retval][out] */ long __RPC_FAR *drawWidth);
        
        HRESULT STDMETHODCALLTYPE getFillColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getFillStyle( 
            /* [retval][out] */ long __RPC_FAR *fillStyle);
        
        HRESULT STDMETHODCALLTYPE getFlipStatus( 
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE getFontTransparency( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
        HRESULT STDMETHODCALLTYPE getForeColor( 
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE getLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ long __RPC_FAR *col);
                        
        HRESULT STDMETHODCALLTYPE getPalette( 
            /* [retval][out] */ I_dxj_DirectDrawPalette __RPC_FAR *__RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE getPixelFormat( 
            /* [out][in] */ DDPixelFormat __RPC_FAR *pf);
        
        HRESULT STDMETHODCALLTYPE getSurfaceDesc( 
            /* [out][in] */ DDSurfaceDesc2 __RPC_FAR *surface);
        
        //HRE