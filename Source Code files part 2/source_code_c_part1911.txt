NEHDR1 *)pDXShare->pFlatDibeng)->deWidth)
    #define GET_MODE_HEIGHT()        (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deHeight)
    #define GET_MODE_PITCH()         (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan)
    #define GET_MODE_PHYSICAL_HEIGHT(dwHead) (pDriverData->flipPrimaryRecord.nvTimingInfo[dwHead].VDisplayEnd)
    #define GET_MODE_BPP()           (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deBitsPixel)
    #define GET_HALINFO()            ((LPDDHALINFO)pDXShare->pHalInfo)
    #define GET_CURRENT_HEAD()       (pDXShare->dwHeadNumber)
    #define GET_SPAN_OFFSET(dwHead)  (0)
    #define PRIMARY_BUFFER_INDEX     (pDXShare->primaryBufferIndex)
#endif // !WINNT
    #define CURRENT_FLIP             (pDriverData->dwCurrentFlip[GET_CURRENT_HEAD()])
    #define COMPLETED_FLIP           (pDriverData->dwCompletedFlip[GET_CURRENT_HEAD()])

#ifdef WINNT
    #define TEXTURE_LOCK_SWIZZLED(pTex)  ((pTex)->getSwizzled()->getOffset())
    #define TEXTURE_LOCK_LINEAR(pTex)    ((pTex)->getLinear()->getAddress())
#else // !WINNT
    #define TEXTURE_LOCK_SWIZZLED(pTex)  ((pTex)->getSwizzled()->getAddress())
    #define TEXTURE_LOCK_LINEAR(pTex)    ((pTex)->getLinear()->getAddress())
#endif // !WINNT


// this now exists for win2k, prototype it
void getDisplayDuration(void);


#if (NVARCH >= 0x04)
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.Free
#else   // !(NVARCH >= 0x04)
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.free
#endif  // !(NVARCH >= 0x04)

#define NV_ALPHA_1_032          ((U032)0xFF000000)
#if (NVARCH >= 0x04)
#define NV_ALPHA_1_016          ((U032)0xFFFF0000)
#else
#define NV_ALPHA_1_016          ((U032)0x00008000)
#endif
#define NV_ALPHA_1_008          ((U032)0x0000FF00)
#define NV_PATTERN_EVEN         ((U032)0x55555555)
#define NV_PATTERN_ODD          ((U032)0xAAAAAAAA)
#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4
#define NV_PRESCALE_OVERLAY_QUADRANT    8

#ifndef WINNT
#define NV_DD_NOTIFIER_BLOCK_SIZE       (sizeof(NvNotification) << 5)
#else
// BUGBUG we need to change this for NT when we update to latest
// Win9x driver source base.
#define NV_DD_NOTIFIER_BLOCK_SIZE       (sizeof(NvNotification) << 4)
#endif

#if (NVARCH >= 0x010)

#define NV_MAX_X_CLIP                   0x00000FFF
#define NV_MAX_X_WIDTH                  0x00001000

#define NV_MAX_Y_CLIP                   0x00000FFF
#define NV_MAX_Y_HEIGHT                 0x00001000

#else   // !(NVARCH >= 0x010)

#define NV_MAX_X_CLIP                   0x000007FF
#define NV_MAX_X_WIDTH                  0x00000800

#define NV_MAX_Y_CLIP                   0x00003FFF
#define NV_MAX_Y_HEIGHT                 0x00004000

#endif  // !(NVARCH >= 0x010)


// DMA Pusher related stuff

#if (NVARCH >= 0x04)

#define NV_PFIFO_DMA                                     0x00002508
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT               0x00000100
#define NV_PFIFO_CACHE1_DMA_PUSH                         0x00003220
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT        0x00000100

#ifndef NVSPEAK
#define NV_DD_DMA_PUSHER_SYNC() {                                           \
    volatile DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;            \
    DWORD *pDW = (DWORD *) (pPDevice->HWPDevice.pCurrentChannelID);         \
                                                                            \
  if  (*pDW != pDriverData->dwDDDmaPusherChannelIndex)                      \
  {                                                                         \
    *pDW = pDriverData->dwDDDmaPusherChannelIndex;                          \
    while ((npNvBase[(NV_PFIFO_DMA >> 2)] &                                 \
            (~pDriverData->dwDDDmaPusherChannelMask)) != 0);                \
    if ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT) && \
        ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F) !=                   \
            (WORD)pDriverData->dwDDDmaPusherChannelIndex)) {                \
        while ((npNvBase[NV_PFIFO_CACHE1_DMA_PUSH >> 2] &                   \
                 NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT) == 0);          \
    }                                                                       \
  }                                                                         \
}
#endif

#define NV_DD_GET_DMA_CHANNEL_INDEX(I) {                                    \
    volatile DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;            \
    (I) = (npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F);                    \
}

#ifndef NVSPEAK
#define NvGetDmaBufferFreeCount(dmaChannel, freeCount, requiredCount, currentBufferAddress) { \
    long getOffset = (long)(volatile)(dmaChannel)->Get;                     \
    long putOffset = (long)((currentBufferAddress) - (DWORD *)pDriverData->NvDmaPusherBufferBase) << 2; \
    if (putOffset >= getOffset) {                                           \
        (freeCount) = (long)(pDriverData->NvDmaPusherBufferSize - 64 - putOffset) >> 2; \
        if ((long)(freeCount) < (long)(requiredCount)) {                    \
            (currentBufferAddress)[0] = NV_DMA_PUSHER_JUMP;                 \
            pDriverData->NvDmaPusherBufferEnd[0] += (DWORD)currentBufferAddress; \
            _outp (0x3d0,0);                                                \
            (dmaChannel)->Put = 0;                                          \
            (currentBufferAddress) =                                        \
                (DWORD *)pDriverData->NvDmaPusherBufferBase;                \
        }                                                                   \
    } else {                                                                \
        (freeCount) = ((getOffset - putOffset) >> 2) - 1;                   \
    }                                                                       \
    if ((freeCount) < requiredCount) {                                      \
        putOffset = 350 << 3;                                               \
        while (--putOffset > 0)                                             \
            (volatile)getOffset = putOffset;                                \
    }                                                                       \
}

#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
    extern void __stdcall NvCachedFreeCountError(long, long, DWORD *);

#define NvCheckCachedFreeCount(freeCount, currentBufferAddress) { \
    long putOffset = (long)(((DWORD *)currentBufferAddress) - (DWORD *)pDriverData->NvDmaPusherBufferBase) << 2; \
    long correctFreeCount = (long)(pDriverData->NvDmaPusherBufferSize - 64 - putOffset) >> 2; \
    if ((long)freeCount > (long)correctFreeCount)                                       \
        NvCachedFreeCountError((long)freeCount, correctFreeCount, (DWORD *)currentBufferAddress); \
}
#endif  /* DEBUG */
#endif  /* CACHE_FREECOUNT */

#endif //!NVSPEAK

#else   // (NVARCH >= 0x04)

#define NV3_3D_PIPE_STATE_RESET ((U032)0x00000008)

#ifdef  NV3T
#define NV_DD_DMA_PUSHER_SYNC() {                                           \
    if (pDriverData->fDmaPusherActive) {                                    \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        pDriverData->fDmaPusherActive = 0;                                  \
        npNvBase[(0x3200 >> 2)] = 1;                                        \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);               \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#else   // ~NV3T
#define NV_DD_DMA_PUSHER_SYNC() {                                           \
    if (pDriverData->fDmaPusherActive) {                                    \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);               \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#endif  // ~NV3T

#ifdef  NEW_DMAPUSH
#define NV_DD_DMA_PUSHER_FLUSH() {                                          \
    if (pDriverData->fDmaPusherActive) {                                    \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    else if ((pDriverData->dwDmaCurrentCount > sizeSetHeaderDmaPush) || (dwDmaPendingCount != 0)) \
    {                                                                       \
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);               \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#else   // OLD_DMAPUSH
#ifdef  NV3T
#define NV_DD_DMA_PUSHER_FLUSH() {                                          \
    if (pDriverData->fDmaPusherActive) {                                    \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
        npNvBase[(0x3200 >> 2)] = 1;                                        \
    }                                                                       \
    else if (pDriverData->dwDmaCount > sizeSetHeaderDmaPush)                \
    {                                                                       \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
        npNvBase[(0x3200 >> 2)] = 1;                                        \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            npNvBase[(0x3200 >> 2)] = 1;                                    \
            while (freeCount < 4)                                           \
             freeCount = NvGetFreeCount(npDev, NV_DD_ROP);                  \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#else   // ~NV3T
#define NV_DD_DMA_PUSHER_FLUSH() {                                          \
    if (pDriverData->fDmaPusherActive) {                                    \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    else if (pDriverData->dwDmaCount > sizeSetHeaderDmaPush)                \
    {                                                                       \
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
             freeCount = NvGetFreeCount(npDev, NV_DD_ROP);                  \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#endif  // NV3T
#endif  // OLD_DMAPUSH

#endif  // !(NVARCH >= 0x04)

#ifdef NVD3D
/*
 * D3D Hal Fcts
 */
#if (NVARCH <0x04)
extern BOOL __stdcall D3DHALCreateDriver(LPD3DHAL_GLOBALDRIVERDATA *lplpGlobal,
                                         LPD3DHAL_CALLBACKS* lplpHALCallbacks
                                         );
#endif
extern BOOL __stdcall D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

extern BOOL DestroyItemArrays(void);
#endif // NVD3D
#ifdef __cplusplus
}
#endif  // __cplusplus
#endif // _NVDD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\NVDDOBJ.H ===
;/*
;***************************************************************************
;                                                                           *
;   Copyright (C) 1995, 1998 NVidia Corporation. All Rights Reserved.       *
;                                                                           *
;***************************************************************************
;*/

#ifndef NVARCH
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

#if (NVARCH >= 0x04)
#define NV_IN_PROGRESS          0x8000
#else
#define NV_IN_PROGRESS          0xFF
#endif

#define NV_DD_COMMON_DMA_BUFFER_SIZE    32768
// win9x driver does not use these values anymore
#define NV_DD_DMA_PUSH_BUFFER_SIZE      (2*1024*1024)
#define NV_DD_DMA_PUSH_BUFFER_SIZE_LRG  (4*1024*1024)

#define NV_VIDEO_NOTIFIER_BUFFER_SIZE   3 * sizeof(NvNotification)

#define NV_STATUS_DONE_OK          0

#if (NVARCH >= 0x04)

#define videoColorKey                  NVFF6_TYPEDEF
#define videoScaler                    NVFF7_TYPEDEF
#define videoFromMemory                NVFF8_TYPEDEF
#define videoColormap                  NVFF9_TYPEDEF
#define videoSink                      NVFFA_TYPEDEF
#define patchcordVideo                 NVFFB_TYPEDEF
#define contextDmaInMemory             NVFFC_TYPEDEF
#define contextDmaToMemory             NVFFD_TYPEDEF
#define contextDmaFromMemory           NVFFE_TYPEDEF

#undef  NVFF8_SET_CONTEXT_DMA_NOTIFIES
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFF8_SET_VIDEO_OUTPUT
#define NVFF8_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFF8_IMAGE_SCAN_OFFSET
#define NVFF8_IMAGE_SCAN_OFFSET                          (0x00000300)
#undef  NVFF9_SET_VIDEO_OUTPUT
#define NVFF9_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFFA_SET_VIDEO_INPUT
#define NVFFA_SET_VIDEO_INPUT                            (0x00000200)
#undef  NVFFF_SET_CONTEXT_DMA_NOTIFIES
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFFF_CREATE_OFFSET
#define NVFFF_CREATE_OFFSET                              (0x00000300)
#undef  NVFFF_DESTROY_OFFSET
#define NVFFF_DESTROY_OFFSET                             (0x00000304)

// subchannels in primary channel
                                        // default object on this sub-channel
#define NV_DD_ROP                  0    // NV_DD_CONTEXT_ROP - NV03_CONTEXT_ROP (0x043)
#define NV_DD_SURFACES             1    // NV_DD_SURFACES_2D - NV4/10_CONTEXT_SURFACES_2D (0x042/0x062)
#define NV_DD_ROP_RECT_AND_TEXT    2    // NV_DD_ROP_GDI_RECT_AND_TEXT - NV4_GDI_RECTANGLE_TEXT (0x04a)
#define NV_DD_BLIT                 3    // NV_DD_IMAGE_BLIT  - NV4_IMAGE_BLIT (0x05f)
#define NV_DD_IMAGE                4    // NV_DD_IMAGE_FROM_CPU - NV4_IMAGE_FROM_CPU (0x061)
#define NV_DD_STRETCH              5    // NV_DD_STRETCHED_IMAGE_FROM_CPU/or one of many NV_DD_SCALED_IMAGE_FROM_MEMORY - NV04/05_STRETCHED/SCALED_IMAGE_FROM_CPU/MEMORY (0x066/0x076)
#define NV_DD_CELSIUS              6    // D3D_CELSIUS_PRIMITIVE - CELSIUS_PRIMITIVE (0x056, 0x096, or 0x1196)
#define NV_DD_KELVIN               6    // D3D_KELVIN_PRIMITIVE - KELVIN_PRIMITIVE (0x097)
#ifdef WINNT // Remove this when DX7 port is complete
#define NV_DD_TRANSCOLOR           6
#endif // WINNT
#define NV_DD_SPARE                7

// subchannels in secondary channel
#define NV_DD_SUBCH_DAC            0    // D3D_DAC_xxx

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].nv3ContextRop
#define dDrawSurfaces                  subchannel[NV_DD_SURFACES].nv4ContextSurfaces2D
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].nv4GdiRectangleText
#define dDrawBlit                      subchannel[NV_DD_BLIT].nv1ImageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].nv1ImageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].nv4ContextColorKey
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#define dDrawSubchannelOffset(I)       (I * 0x00002000)

#define dVideoControlHdr               subchannel[0]
#define dVideoControl                  subchannel[0].Nv10VideoLutCursorDac
#define dVideoOverlayHdr               subchannel[1]
#define dVideoOverlay                  subchannel[1].Nv10VideoOverlay
#define dVideoDVDSubPictureHdr         subchannel[2]
#define dVideoDVDSubPicture            subchannel[2].Nv10DvdSubpicture
#define dVideoImageBlitHdr             subchannel[3]
#define dVideoImageBlit                subchannel[3].Nv04ImageBlit
#define dVideoSurface2DHdr             subchannel[4]
#define dVideoSurface2D                subchannel[4].Nv10ContextSurfaces2d

#define NV_DMA_PUSHER_JUMP             0x20000000

/* DMA pusher offsets */
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define SURFACES_2D_DEST_OFFSET                                 NV042_SET_OFFSET_DESTIN
#define IMAGE_BLACK_RECTANGLE_POINT_OFFSET                      NV019_SET_POINT
#define RECT_AND_TEXT_NO_OPERATION_OFFSET                       NV04A_NO_OPERATION
#define RECT_AND_TEXT_NOTIFY_OFFSET                             NV04A_NOTIFY
#define RECT_AND_TEXT_COLOR1A_OFFSET                            NV04A_COLOR1_A
#define RECT_AND_TEXT_CLIPPOINT0B_OFFSET                        NV04A_CLIP_POINT0_B
#define RECT_AND_TEXT_CLIPPEDRECT_POINT0_OFFSET                 NV04A_CLIPPED_RECTANGLE(0)
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define IMAGE_FROM_CPU_POINT_OFFSET                             NV061_POINT
#define IMAGE_FROM_CPU_COLOR_OFFSET                             NV061_COLOR(0)
#define STRETCHED_IMAGE_COLOR_FORMAT_OFFSET                     NV076_SET_COLOR_FORMAT
#define STRETCHED_IMAGE_SIZE_IN_OFFSET                          NV076_SIZE_IN
#define STRETCHED_IMAGE_COLOR_OFFSET                            NV076_COLOR(0)
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_CONTEXT_SURFACE_OFFSET                     NV077_SET_CONTEXT_SURFACE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_DELTADUDX_OFFSET                           NV077_DELTA_DU_DX
#define SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET                     NV077_IMAGE_OUT_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_IMAGE_IN_POINT_OFFSET                      NV077_IMAGE_IN
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET                      NV039_SET_CONTEXT_DMA_BUFFER_IN
#define MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET                     NV039_SET_CONTEXT_DMA_BUFFER_OUT
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define VIDEO_FROM_MEM_OFFSET_OFFSET                            NVFF8_IMAGE_SCAN_OFFSET
#define CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET                      NVFFE_NOTIFY
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET           NVFFE_SET_DMA_SPECIFIER
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET     NVFFE_SET_DMA_SPECIFIER_LIMIT

#else   // !(NVARCH >= 0x04)

#define NV_DD_ROP                      0
#define NV_DD_IMAGE_IN_MEMORY          1
#define NV_DD_ROP_RECT_AND_TEXT        2
#define NV_DD_BLIT                     3
#define NV_DD_IMAGE                    4
#define NV_DD_STRETCH                  5
#define NV_DD_TRANSCOLOR               6
#define NV_DD_SPARE                    7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].rop5Solid
#define dDrawImageInMemory             subchannel[NV_DD_IMAGE_IN_MEMORY].imageInMemory
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].winRectAndTextFromCpu
#define dDrawBlit                      subchannel[NV_DD_BLIT].imageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].imageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].imageSolid
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#endif  // !(NVARCH >= 0x04)
/*
      7 subchannels contain the default cached objects.  These objects
are expected to be loaded at all times except when one or more of them gets
temporarily replaced for an unusual rendering operation.  If a default cached
object does get temporarily replaced, it is expected to be restored immediately
after completion of the rendering operation which caused it's replacement.
There is a spare subchannel in the Direct Draw patch which is lazy evaluated
similarly to the one used in the display driver.

        In the Windows 95 Direct Draw patch description below outlined objects are
those expected to be cached in the 8 subchannels.  Objects with corners
marked only are objects which temporarily replace cached objects or which are
loaded into the eighth subchannel when used.  All other objects are created,
patched together, then never loaded again until the patch is destroyed.  Most of
those objects are in the interior of the patch and are referenced by row for
clear identification.  Patchcord object names are derived from the object
where their output originates (their source).


/* Windows 95 Double Buffered Direct Draw ROP3 Patch */


/*

   Objects

   Context DMA  Context DMA
    To Memory    To Memory
          . |    | . .-------. .               . .         . .---------------.
           MemToMem  |  Rop  |   Image Pattern      Image    |  Image Solid  |
            Format   | Solid |  (Alpha Enabled)     Black    |(Alpha Enabled)|
          '        ' '-------' '               '  Rectangle  '---------------'
                           |        |            '         '         |
                          P|I       |              |                 |
                           |  .-----'     .--------'    .------------'
                           | P|I         P|I           P|I
 .               .         |  |           |             |
    (Sync) Rect     P      |  |           |             |       P
     And Text     ------------------------------------------------->.
 '               '  I      |  |           |             |       I   |
                           |  |           |             |           |
                          P|IP|I         P|I           P|I          |
 .---------------.         V  V           |             V           |
 |   Rop Rect    |  P   Image Rop  P      V     P     Image     P   |
 |   And Text    |----->   And   ------------------>Color Key------>|       1
 '---------------'  I   ^          I      |     I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
| Image From CPU |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       2
'----------------'  I   ^          I            I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           V             V           |
  Image From CPU    P   Image Rop  P    Image   P     Image     P   |
 (Alt Pxl Depth)  ----->   And   ----->Stencil----->Color Key------>|       3
'                '  I   ^          I            I               I   |
 CtxDmaFromSysMem      P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.---|------------.         V  V           |             V           |
|  Scaled RGB    |  P   Image Rop  P      V     P     Image     P   |
|ImageFromSysMem |----->   And   ------------------>Color Key------>|       4
|(Alpna Disabled)|  I   ^          I      |     I               I   |
'----------------'     P|I |  |           |             |           |
 CtxDmaFromVidMem       | P|IP|I         P|I           P|I          |
.          |     .         V  V           |             V           |
   Scaled RGB       P   Image Rop  P      V     P     Image     P   |
 ImageFromVidMem  ----->   And   ------------------>Color Key------>|       5
 (Alpna Disabled)   I   ^          I      |     I               I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       6
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       7
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       8
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       9
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       A
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       B
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       C
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       D
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       AA
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       BB
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             |           |
  Stretched UV      P   Image Rop  P      V     P       V       P   |
      Image       ----->   And   ---------------------------------->|       CC
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             V           |
    Stretched       P   Image Rop  P      V     P     Image     P   |
      Image       ----->   And   ------------------>Color Key------>|       DD
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
|   Image Blit   |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       E
'------------^---'  I   ^          I            I               I   |
            P|I        P|I                                          |
             |          |                                           |
             |          |                                           |
             |          '------------------------------------.      |
             |                                               |      |
             |                                               |      |
             |                                              P|I    P|I
             |                                               |      |
            P|I                                              |      |
             |                                               |      |
             |                                               |      V
 .             .               .           .              .-------------.
     Source     --------------- Context DMA --------------| Destination |  P
  ImageInMemory                  InMemory                 |ImageInMemory|<----.
 '             '               '           '              '-------------'  I  |
                                  |    |                                      |
                                  |    '-------------------------.            |
                                  |                              |            |
 .              .          P      |                 P     .                .  |
  Render Solid   ----------------------------------------> Destination Zeta   |
  Zeta Rectangle           I      |                 I       ImageInMemory     |
 '              '                 |                       '                '  |
                                  |                                           |
                                  '------------------------------.            |
                                                                 |            |
                                                          .                .  |
 .             .      P                               P    Destination Zeta   |
   Render D3D   ----------------------------------------->  BufferInMemory    |
  Triangle Zeta       Z         P   Image    P        Z   '      ^         '  |
 '             '------------------>Stencil----------------------------------->| F
                                I            I                   |            |
                                                                P|Z           |
 .             .      P                               P          |            |
   Render D3D   -------------------------------------------------'            |
  Triangle Zeta       Z         P   Image    P        Z                       |
   From Video   ------------------>Stencil----------------------------------->' FF
     Memory                     I            I
 '             '

                            .                 .
  Floating Format               Y, U, V, UV
  Context DMA From --------- System Memory To  ---------------.
   System Memory             Vid Memory Format                |
                            '                 '               |
                                                       Context DMA To
                                                        Video Memory
                            .                 .               |
                                Y, U, V, UV                   |
         .------------------  Video Memory To  ---------------'
         |                   Vid Memory Format
 .                .         '                 '
  Context DMA From
    Video Memory
 ,                ,               .          .
       |    |                       Primary
       |    '--------------------- Video From ------Flip Primary Notifier
       |                             Memory         Context DMA To Memory
       |                          '          '
       |                            |      |
       |                            |      |
       |                           P|V    P|V
       |                            |      |
       |                            |      |   P   .            .
  .          .                      V      V//<---- Shared Video
     YUV422     P   .      .    P  .         . V      Colormap
   Video From -----> Video  ------>   Video        '            '
     Memory     V    Scaler     V   Color Key
  '          '      '      '       '         '
        |                               |
        |                               |
  Flip Overlay Notifier                P|V
  Context DMA To Memory                 |
                                        V
                                   .         .
                                      Video
                                      Sink
                                   '         '

*/


/* Video channel shared Display Driver and DDraw Object IDs */

//#define NV_VIDEO_NOTIFIER_CONTEXT_DMA_TO_MEMORY                 0x00008000 These 2 were allocated & freed, but
//#define NV_VIDEO_LUT_CURSOR_DAC_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x00008004 never referenced. 
#define NV_VIDEO_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x00008008
#define NV_VIDEO_LUT_CURSOR_DAC                                 0x00008020
#define NV_VIDEO_OVERLAY                                        0x00008030
#define NV_VIDEO_DVD_SUBPICTURE                                 0x00008040
//#define NV_VIDEO_SURFACES_2D_A8R8G8B8                           0x00008050 no longer in use
//#define NV_VIDEO_CONTEXT_BETA4                                  0x00008060 no longer in use 
//#define NV_VIDEO_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT            0x00008070 no longer in use

/* Windows 9X Direct Draw Object IDs */


#define NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_PIO_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_PIO_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_PIO_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_PIO_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_PIO_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY        0xDD001009
#define NV_DD_DMA_FLOATING_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD00100A
#define NV_DD_DMA_TRIANGLE_CONTEXT_DMA_FROM_SYSTEM_MEMORY       0xDD00100B
#define NV_DD_PIO_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_PIO_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_DMA_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_PIO_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001016
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_DMA_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_0 0xDD001017
#define NV_DD_PIO_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018
#define NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018

#ifdef NV3
#define NV_DD_PIO_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#define NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#endif

#define NV_DD_SCALED_IMAGE_CONTEXT_IID                          0xDD001019

#define NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY    0xDD00101A
#define NV_DD_PIO_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_PIO_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_1 0xDD00101E
#define NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F
#define NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F

#define NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT              0xDD001020
#define NV_DD_CONTEXT_ROP                                       0xDD001030
#define NV_DD_ROP5_SOLID                                        0xDD001030
#define NV_DD_P_I_ROP5_SOLID                                    0xDD001031
#define NV_DD_P_B_BETA_SOLID                                    0xDD001041
#define NV_DD_CONTEXT_PATTERN                                   0xDD001050
#define NV_DD_IMAGE_PATTERN                                     0xDD001050
#define NV_DD_P_I_IMAGE_PATTERN                                 0xDD001051
#define NV_DD_IMAGE_BLACK_RECTANGLE                             0xDD001060
#define NV_DD_P_I_IMAGE_BLACK_RECTANGLE                         0xDD001061
#define NV_DD_CONTEXT_COLOR_KEY                                 0xDD001070
#define NV_DD_COLOR_KEY_IMAGE_SOLID                             0xDD001070
#define NV_DD_P_I_COLOR_KEY_IMAGE_SOLID                         0xDD001071
#define NV_DD_CONTEXT_BETA4                                     0xDD001080

#define NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001090 // to 0xDD00109F (need one per head)

#define NV_DD_ROP_GDI_RECT_AND_TEXT                             0xDD001100
#define NV_DD_P_I_ROP_GDI_RECT_AND_TEXT                         0xDD001101
#define NV_DD_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU                0xDD00110A
#define NV_DD_P_I_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU            0xDD00110B
#define NV_DD_IMAGE_FROM_CPU                                    0xDD001200
#define NV_DD_P_I_IMAGE_FROM_CPU                                0xDD001201
#define NV_DD_IMAGE_BLEND_FROM_CPU                              0xDD001300
#define NV_DD_P_I_IMAGE_BLEND_FROM_CPU                          0xDD001301
#define NV_DD_STRETCHED_IMAGE_FROM_CPU                          0xDD001400
#define NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU                      0xDD001401
#ifdef NV3
#define NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY               0xDD001500
#endif
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY           0xDD001501
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY       0xDD001508
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY 0xDD001509
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY        0xDD00150A
#define NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY                0xDD001510
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY            0xDD001511
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY        0xDD001518
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY 0xDD001519
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY         0xDD00151A
#define NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY              0xDD001520
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY          0xDD001521
#define NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY               0xDD001530
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY           0xDD001531
#define NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY              0xDD001540
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY          0xDD001541
#define NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY               0xDD001550
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY           0xDD001551
#define NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001560
#define NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001561
#define NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001570
#define NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001571
#define NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001580
#define NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001581
#define NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001590
#define NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001591
#define NV_DD_SCALED_IMAGE_IID                                  0xDD0015A0
#define NV_DD_GENERIC_STRETCHED_IMAGE                           0xDD0015A1
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0xDD001600
#define NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU                   0xDD001601

#define NV_DD_IMAGE_BLIT                                        0xDD001800
#define NV_DD_P_I_IMAGE_BLIT                                    0xDD001801
#define NV_DD_SRCCOPY_IMAGE_BLIT                                0xDD001808
#define NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT               0xDD00180A
#define NV_DD_P_I_ALT_IMAGE_FROM_CPU                            0xDD001901
#define NV_DD_RENDER_SOLID_ZETA_RECTANGLE                       0xDD001A00
#define NV_DD_P_I_RENDER_SOLID_ZETA_RECTANGLE                   0xDD001A01

#define NV_D3D_RENDER_TRIANGLE_ZETA                             0xDD001B00
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA                         0xDD001B01
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA                         0xDD001B02
#define NV_D3D_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY           0xDD001B03
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B04
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B05
#define NV_D3D_FLOATING_RENDER_TRIANGLE_ZETA                    0xDD001B06
#define NV_D3D_FLOATING_P_I_RENDER_TRIANGLE_ZETA                0xDD001B07
#define NV_D3D_FLOATING_P_Z_RENDER_TRIANGLE_ZETA                0xDD001B08

// floating dma contexts for DVD acceleration
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F

#define NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY     0xDD001D00
#define NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY     (NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+1)
#define NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY     (NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY+1)
#define NV_DD_DMA_FLOATING_MC_IDCT3_CONTEXT_DMA_FROM_MEMORY     (NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY+1)

// defined in CFlipper, but listed here to keep this list comprehensive
// #define CFlipper::SEMAPHORE_CONTEXT_DMA_IN_MEMORY            0xDD001E00
// #define CFlipper::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY          0xDD001E01

/* Patch interior */

#define NV_DD_IMAGE_ROP_AND_1                                   0xDD002110
#define NV_DD_P_I_IMAGE_ROP_AND_1                               0xDD002111
#define NV_DD_IMAGE_COLOR_KEY_1                                 0xDD002130
#define NV_DD_P_I_IMAGE_COLOR_KEY_1                             0xDD002131

#define NV_DD_IMAGE_ROP_AND_2                                   0xDD002210
#define NV_DD_P_I_IMAGE_ROP_AND_2                               0xDD002211
#define NV_DD_IMAGE_STENCIL_2                                   0xDD002220
#define NV_DD_P_I_IMAGE_STENCIL_2                               0xDD002221
#define NV_DD_IMAGE_COLOR_KEY_2                                 0xDD002230
#define NV_DD_P_I_IMAGE_COLOR_KEY_2                             0xDD002231

#define NV_DD_IMAGE_ROP_AND_3                                   0xDD002310
#define NV_DD_P_I_IMAGE_ROP_AND_3                               0xDD002311
#define NV_DD_IMAGE_STENCIL_3                                   0xDD002320
#define NV_DD_P_I_IMAGE_STENCIL_3                               0xDD002321
#define NV_DD_IMAGE_COLOR_KEY_3                                 0xDD002330
#define NV_DD_P_I_IMAGE_COLOR_KEY_3                             0xDD002331

#define NV_DD_IMAGE_ROP_AND_4                                   0xDD002410
#define NV_DD_P_I_IMAGE_ROP_AND_4                               0xDD002411
#define NV_DD_IMAGE_COLOR_KEY_4                                 0xDD002430
#define NV_DD_P_I_IMAGE_COLOR_KEY_4                             0xDD002431

#define NV_DD_IMAGE_ROP_AND_5                                   0xDD002510
#define NV_DD_P_I_IMAGE_ROP_AND_5                               0xDD002511
#define NV_DD_IMAGE_COLOR_KEY_5                                 0xDD002530
#define NV_DD_P_I_IMAGE_COLOR_KEY_5                             0xDD002531

#define NV_DD_IMAGE_ROP_AND_C                                   0xDD002C10
#define NV_DD_P_I_IMAGE_ROP_AND_C                               0xDD002C11

#define NV_DD_IMAGE_ROP_AND_D                                   0xDD002D10
#define NV_DD_P_I_IMAGE_ROP_AND_D                               0xDD002D11
#define NV_DD_IMAGE_COLOR_KEY_D                                 0xDD002D30
#define NV_DD_P_I_IMAGE_COLOR_KEY_D                             0xDD002D31

#define NV_DD_IMAGE_ROP_AND_E                                   0xDD002E10
#define NV_DD_P_I_IMAGE_ROP_AND_E                               0xDD002E11
#define NV_DD_IMAGE_STENCIL_E                                   0xDD002E20
#define NV_DD_P_I_IMAGE_STENCIL_E                               0xDD002E21
#define NV_DD_IMAGE_COLOR_KEY_E                                 0xDD002E30
#define NV_DD_P_I_IMAGE_COLOR_KEY_E                             0xDD002E31

#define NV_DD_IMAGE_STENCIL_F                                   0xDD002F20
#define NV_DD_P_I_IMAGE_STENCIL_F                               0xDD002F21

#define NV_DD_IMAGE_STENCIL_F3                                  0xDD002F30
#define NV_DD_P_I_IMAGE_STENCIL_F3                              0xDD002F31

#define NV_DD_IMAGE_STENCIL_FF                                  0xDD002FF0
#define NV_DD_P_I_IMAGE_STENCIL_FF                              0xDD002FF1

/* Patch back end */

#define NV_DD_SURFACES_2D                                       0xDD003F00
#define NV_DD_DST_IMAGE_IN_MEMORY                               0xDD003F00
#define NV_DD_P_I_DST_IMAGE_IN_MEMORY                           0xDD003F01
#define NV_DD_SURFACES_2D_A8R8G8B8                              0xDD003F02
#define NV_DD_SURFACES_3D                                       0xDD003F03
#define NV_DD_SURFACES_SWIZZLED                                 0xDD003F04
#define NV_DD_SRC_IMAGE_IN_MEMORY                               0xDD003F10
#define NV_DD_P_I_SRC_IMAGE_IN_MEMORY                           0xDD003F11
#define NV_DD_ZETA_IMAGE_IN_MEMORY                              0xDD003F20
#define NV_D3D_ZETA_BUFFER_IN_MEMORY                            0xDD003F30
#define NV_D3D_P_Z_ZETA_BUFFER_IN_MEMORY                        0xDD003F31

#define NV_DD_PRIMARY_VIDEO_FROM_MEMORY                         0xDD003F80
#define NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY                     0xDD003F81
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0xDD003F90
#define NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY                      0xDD003F91
#define NV_DD_VIDEO_SCALER                                      0xDD003FA0
#define NV_DD_P_V_VIDEO_SCALER                                  0xDD003FA1
#define NV_DD_VIDEO_COLOR_KEY                                   0xDD003FB0
#define NV_DD_P_V_VIDEO_COLOR_KEY                               0xDD003FB1
#define NV_DD_SHARED_VIDEO_COLORMAP                             0xDD003FC0
#define NV_DD_P_V_SHARED_VIDEO_COLORMAP                         0xDD003FC1

#define NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT            0xDD003FD0
#define NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT            0xDD003FD1
#define NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT            0xDD003FD2
#define NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT           0xDD003FD3
#define NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT             0xDD003FE0
#define NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT             0xDD003FE1
#define NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT             0xDD003FE2
#define NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT            0xDD003FE3
#define NV_DD_GENERIC_MTMF_1                                    0xDD003FE7
#define NV_DD_GENERIC_MTMF_2                                    0xDD003FE8
#define NV_DD_VIDEO_SINK                                        0xDD003FF0

#define NV_DD_COMMON_DMA_BUFFER                                 0xDD004000
#define NV_DD_PIO_CONTEXT_ERROR_TO_MEMORY                       0xDD004010
#define NV_DD_DEV_PIO                                           0xDD004020

// channels
#define NV_DD_DEV_DMA                                           0xDD005020
//                                                              0xDD005021  reserved
#define NV_DD_DEV_VIDEO                                         0xDD005030
//                                                              0xDD005031  reserved
#define NV_DD_DEV_VPE                                           0xDD005040
//                                                              0xDD005041  reserved
#define NV_DD_DEV_DAC                                           0xDD005050
//                                                              0xDD005051  reserved

#define NV_DD_VIDEO_LUT_CURSOR_DAC                              0xDD006020
//                                                              0xDD006021-0xDD00604f  reserved for multi-head
#define NV_DD_VIDEO_LUT_CURSOR_DAC_2                            0xDD006050
//                                                              0xDD006051-0xDD00606f  reserved for multi-head

#define NV_DD_GLOBALDATA_MEMORY                                 0xDD008020
#define NV_DD_GLOBALDATA_MEMORY_NVDD32_CONTEXT                  0xDD008021
#define NV_DD_GLOBALDATA_MEMORY_NVDD32_CONTEXT_CONTENTS         0xDD008022
#define NV_DD_IPM                                               0xDD008026
#define NV_DD_CONTEXTDMA_MEMORY                                 0xDD008030

#define NV_DD_INDEXED_IMAGE_FROM_CPU                            0xDD00A000

#ifdef WINNT
// Pushbuf and default VB IDs needed for Win2k RM AGP allocator.
#define NV_DD_AGP_PUSHBUF                                       0xDD00A001
#endif // WINNT



// Events
#define NV_DD_EVENT_IDLE_SYNC                                   0xDD00C000
#define NV_DD_EVENT_CONVERT_SYNC                                0xDD00C001
#define NV_DD_EVENT_DVD_SUBPICTURE                              0xDD00C002
#define NV_DD_EVENT_ALPHA_BLIT_SYNC                             0xDD00C003
#define NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC                        0xDD00C004
#define NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC                        0xDD00C005
#define NV_DD_EVENT_COMBINER_SYNC                               0xDD00C006
#define NV_DD_EVENT_DMABLT_TO_VID                               0xDD00C007
#define NV_DD_EVENT_OVL_FLIP1                                   0xDD00C008
#define NV_DD_EVENT_OVL_FLIP2                                   0xDD00C009
#define NV_DD_EVENT_DFILTER_SYNC                                0xDD00C00A
#define NV_DD_EVENT_FSMIRROR                                    0xDD00C00B
#define NV_DD_EVENT_PRIMARY0_FLIP1                              0xDD00C00C
#define NV_DD_EVENT_PRIMARY0_FLIP2                              0xDD00C00D
#define NV_DD_EVENT_PRIMARY1_FLIP1                              0xDD00C00E
#define NV_DD_EVENT_PRIMARY1_FLIP2                              0xDD00C00F
#define NV_DD_EVENT_TIMER                                       0xDD00C010
#define NV_DD_EVENT_FOURCCBLT                                   0xDD00C020

// Floating context DMA's for system surfaces (reserve a block of 256 for now)
// HWFIX: note that context DMA IDs are incremented by 2 on each creation,
//        and to fix a hw hash error, we must swap bits 1 and 2 with bits 11 and 22
//        to hit the hash function bits on each iteration
#define MAX_FLOATING_CONTEXT_DMA                                0x40
#define MASK_FLOATING_CONTEXT_DMA_ID                            0xFFBFF005  // bits 2 and 22 swapped
#define FLOATING_CONTEXT_DMA_ID                                 0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_BASE                         0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_0                            0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_7FF                          0xDD00DFFF

#if (NVARCH < 0x4)
#define NV_DD_BETA_SOLID                                        0xDD001040
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0xDD001600
#define NV_DD_ALT_IMAGE_FROM_CPU                                0xDD001900
#define NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY                       0xDD005010 //nv3 only
#endif

// D3D objects

// naming convention:
// D3Dxxxyy
// where xxx = object class number
//        yy = enumerator, in case we have more than one object of type xxx

// DMA contexts.

#ifdef WINNT  // Still needed by old DX6 Win2k driver!!
#define D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY                  0xD3D00201
#define D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY                0xD3D00202
#endif // Still needed by old DX6 win2k driver

#define D3D_CONTEXT_xxx_unused_xxx                              0xD3D00201
#define D3D_CONTEXT_DMA_HOST_MEMORY                             0xD3D00202  // pci or agp context (growable for surfaces)

// Surface contexts.
#define D3D_CONTEXT_SURFACE_SWIZZLED                            0xD3D05201
#define D3D_CONTEXT_SURFACES_ARGB_ZS                            0xD3D05301

// D3D 2D rendering objects.
#define D3D_RENDER_SOLID_RECTANGLE                              0xD3D05E01  // Currently used for Z and Buffer Clears
#define D3D_RENDER_SOLID_RECTANGLE_2                            0xD3D05E02  // pseudo texblit notifiers
#define D3D_GDI_RECTANGLE_TEXT                                  0xD3D04A01  // Currently used for Z and Buffer Clears -- NV20 style
#define D3D_GDI_RECTANGLE_TEXT_2                                0xD3D04A02  //
#define D3D_SCALED_IMAGE_FROM_MEMORY                            0xD3D07701  // Used for swizzling textures.

// D3D Triangle objects.
#define D3D_DX5_TEXTURED_TRIANGLE                               0xD3D05401  // DX5 class triangle renderer.
#define D3D_DX6_MULTI_TEXTURE_TRIANGLE                          0xD3D05501  // Multi Texture/Stencil triangle renderer.

// Celsius primitive
#define D3D_CELSIUS_PRIMITIVE                                   0xD3D05601

// Kelvin primitive
#define D3D_KELVIN_PRIMITIVE                                    0xD3D09701

// IPM allocator
#define IPM_DEVICE_HANDLE                                       0xD3D01010
#define IPM_MEMORY_OBJECT_LO                                    0x10000000  // low
#define IPM_MEMORY_OBJECT_HI                                    0x1FFFFFFF  // high

// AGP allocator
#define AGP_DEVICE_HANDLE                                       0xD3D01011
#define AGP_MEMORY_OBJECT_LO                                    0x10000000  // low
#define AGP_MEMORY_OBJECT_HI                                    0x1FFFFFFF  // high

// see nvpatchinterface.h
//ff// FD mutual exclusion 
//ff#define FD_SEMAPHORE_HANDLE                                     0xDDFD0000
//ff#define FD_SEMAPHORE_206E_CONTEXT_DMA                           0xDDFD0001
//ff#define FD_SEMAPHORE_097_CONTEXT_DMA                            0xDDFD0002
//ff//          ... 1-32 should be considered used here for our channels ... 
//ff//#define FD_SEMAPHORE_CONTEXT_DMA                              0xDDFD0020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\nvd3ddrv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997 SGS-THOMSON Microelectronics  All Rights Reserved.
 *
 *  File:       nvd3ddrv.c
 *  Content:    master D3D include file - OS specific includes
 *
 ***************************************************************************/

#ifndef WINNT
#include <conio.h>
#include "ddrawi.h"
#include "ddmini.h"
#include <d3dhal.h>
#include "nvwin32.h"
#else

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <d3d.h>

#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <mmsystem.h>
#include <devioctl.h>

#include <ioaccess.h>
#include <math.h>
#include <dmemmgr.h>
#include <dx95type.h>
#include "nvapi.h"

//
// Type redefs excluded from dx95type.h.
//

typedef PDD_DIRECTDRAW_LOCAL            LPDDRAWI_DIRECTDRAW_LCL; //HMH
typedef D3DNTHAL_DP2CLEAR               *LPD3DNTHAL_DP2CLEAR;  //HMH
typedef LPD3DNTHAL_DP2CLEAR             LPD3DHAL_DP2CLEAR;     //HMH
typedef D3DNTHAL_DP2SETRENDERTARGET     *LPD3DNTHAL_DP2SETRENDERTARGET;  //HMH
typedef LPD3DNTHAL_DP2SETRENDERTARGET   LPD3DHAL_DP2SETRENDERTARGET;     //HMH
typedef D3DNTHAL_DP2TEXBLT     *LPD3DNTHAL_DP2TEXBLT;  //HMH
typedef LPD3DNTHAL_DP2TEXBLT   LPD3DHAL_DP2TEXBLT;     //HMH
typedef D3DNTHAL_DP2STATESET            *LPD3DNTHAL_DP2STATESET; //HMH
typedef LPD3DNTHAL_DP2STATESET          LPD3DHAL_DP2STATESET; //HMH

typedef D3DNTHAL_D3DEXTENDEDCAPS D3DHAL_D3DEXTENDEDCAPS;
typedef PDD_SURFACE_INT LPDDRAWI_DDRAWSURFACE_INT;
typedef D3DNTHAL_DP2POINTS *LPD3DNTHAL_DP2POINTS;
typedef D3DNTHAL_DP2RENDERSTATE *LPD3DNTHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2LINELIST *LPD3DNTHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST *LPD3DNTHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP *LPD3DNTHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST *LPD3DNTHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2TRIANGLESTRIP *LPD3DNTHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN *LPD3DNTHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE *LPD3DNTHAL_DP2TEXTURESTAGESTATE;

typedef LPD3DNTHAL_DP2POINTS LPD3DHAL_DP2POINTS;
typedef LPD3DNTHAL_DP2RENDERSTATE LPD3DHAL_DP2RENDERSTATE;
typedef LPD3DNTHAL_DP2LINELIST LPD3DHAL_DP2LINELIST;
typedef LPD3DNTHAL_DP2INDEXEDLINELIST LPD3DHAL_DP2INDEXEDLINELIST;
typedef LPD3DNTHAL_DP2LINESTRIP LPD3DHAL_DP2LINESTRIP;
typedef LPD3DNTHAL_DP2STARTVERTEX LPD3DHAL_DP2STARTVERTEX;
typedef LPD3DNTHAL_DP2TRIANGLELIST LPD3DHAL_DP2TRIANGLELIST;
typedef LPD3DNTHAL_DP2TRIANGLESTRIP LPD3DHAL_DP2TRIANGLESTRIP;
typedef LPD3DNTHAL_DP2TRIANGLEFAN LPD3DHAL_DP2TRIANGLEFAN;
typedef LPD3DNTHAL_DP2TEXTURESTAGESTATE LPD3DHAL_DP2TEXTURESTAGESTATE;
typedef LPD3DNTHAL_DP2VIEWPORTINFO LPD3DHAL_DP2VIEWPORTINFO;
typedef LPD3DNTHAL_DP2WINFO LPD3DHAL_DP2WINFO;
typedef LPD3DNTHAL_DP2TRIANGLEFAN_IMM LPD3DHAL_DP2TRIANGLEFAN_IMM;
#define NvGetFlatDataSelector() (0xffffffff)

/*
 * NT doesn't define the DX5 Clear routine's data structure, but the DX5 driver
 * routine can still be called from the DX6 clear routine to do fast buffer
 * clears, so need to define this ourselves (taken from d3d.h)
 */
#if 0
typedef struct _D3DHAL_CLEARDATA
{
    DWORD               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;
#endif
/*
 * These represent the "OS Independent" RM entry points. For NT they are functions
 * in the display driver which package the parms into a IOCTL packet and make
 * an IOCTL call to the miniport where the RM lives.
 */

#define NvRmOpen() \
    NvOpen(pDriverData->ppdev->hDriver)
#define NvRmAllocContextDma(hClient, hDma, hClass, flags, base, limit) \
    NvAllocContextDma(pDriverData->ppdev->hDriver, hClient, hDma, hClass, flags, base, limit)
#define NvRmFree(hClient, hParent, hObj) \
    NvFree(pDriverData->ppdev->hDriver, hClient, hParent, hObj)
#define NvRmAllocChannelPio(hClient, hDev, hChannel, hClass, hErrorCtx, ppChannel, flags) \
    NvAllocChannelPio(pDriverData->ppdev->hDriver, (hClient), hDev, (hChannel), (hClass), (hErrorCtx), (ppChannel), (flags))
#define NvRmAllocChannelDma(hClient, hDev, hChan, hClass, hErrorCtx, hDataCtx, offset, ppChan) \
    NvAllocChannelDma(pDriverData->ppdev->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (hDataCtx), (offset), (ppChan))
#define NvRmAllocMemory(hClient, hPar, hMem, hClass, fl, ppAddr, pLim) \
    NvAllocMemory(pDriverData->ppdev->hDriver, hClient, hPar, hMem, hClass, fl, ppAddress, pLim)
#define NvRmConfigGet(hClient, hDevice, index, pValue) \
    NvConfigGet(pDriverData->ppdev->hDriver, hClient, hDevice, index, pValue)
#define NvRmConfigSet(hClient, hDevice, index, newValue, pOldValue) \
    NvConfigSet(pDriverData->ppdev->hDriver, hClient, hDevice, index, newValue, pOldValue)
#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
    NvAllocObject(pDriverData->ppdev->hDriver, hCli, hChan, hObj, hCls)
#define NvRmAlloc(hCli, hChan, hObj, hCls, parms) \
    NvAlloc(pDriverData->ppdev->hDriver, hCli, hChan, hObj, hCls, parms)

/*
 * This macro is used to force the driver to check the PDEV flag to
 * determine if overlay is supported in the current video mode. Eventually
 * we want to change this to use the internal driver routine, but we'll
 * need to redefine the NT RM entry point name to do it.
 */
#define GetVideoScalerBandwidthStatus32(surfaceFlags) \
    (pDriverData->ppdev->bHwVidOvl)

/*
 * Macros for GDI functions missing from Win2K.
 */
#define IntersectRect(pIntersect, pSrc, pDst) \
    bIntersect((PRECTL) (pSrc), (PRECTL) (pDst), (PRECTL) (pIntersect))

/*
 * Macros for DirectX heap manager functions.
 */
#define DDHAL32_VidMemAlloc(pdrv, heap, x, y) \
    HeapVidMemAllocAligned((LPVIDMEM)pDriverData->ppdev->AgpHeap, x, y, \
        &(pDriverData->ppdev->AgpHeapAlignment), &(pDriverData->ppdev->AgpDummyPitch))

#define DDHAL32_VidMemFree(pdrv, heap, surface) \
    { \
    if (pDriverData->ppdev->AgpHeap->lpHeap) \
        { \
        VidMemFree((pDriverData->ppdev->AgpHeap->lpHeap), \
          ((ULONG) (surface) - (ULONG) (pDriverData->ppdev->AgpHeapBase))); \
        } \
    }

#define NV_SLEEP
#define NV_SLEEPFLIP
#define SetPriorityClass(a, b)
#define SetThreadPriority(a, b)
#define GetCurrentThread()
#define GetCurrentProcess()
#define GetSystemInfo(a)

//********************************************************************
// Global defs.
//********************************************************************
extern SURFACEALIGNMENT    AgpHeapAlignment;
extern LONG                AgpDummyPitch;

#include "basetsd.h"             // for compiling 64-bit Merced codes.
#include <ntddvdeo.h>
#include "memstruc.h"
#include "ddmini.h"
#include "nvEscDef.h"
#include "driver.h"
#include "nvntioctl.h"
#include "nvos.h"
#endif // #ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\nvgpio.h ===
/*----------------------------------------------------------------------------*/
/*
 * nvgpio.h
 *
 */

#ifdef __cplusplus
extern "C"
{
#endif

DWORD nvGPIOInit ( ULONG ourRoot, ULONG ourDev, ULONG ourChannel, NvChannel* pNV, UINT subchan );
DWORD nvGPIOUnnit();
DWORD nvGPIOWrite ( DWORD regAddr, BYTE regData );
DWORD nvGPIORead ( DWORD regAddr, BYTE* pData );
DWORD nvVIPWrite ( DWORD regAddr, DWORD regData, DWORD dataSize );
DWORD nvVIPRead ( DWORD regAddr, DWORD* pBuf, DWORD dataSize );

/* backdoors (hopefully temporary) */
DWORD nvRegWrite ( DWORD regAddr, UINT regData );
DWORD nvRegRead ( DWORD regAddr, UINT* pData );
DWORD nvGPIOSetControlObj ( void* pObj );
VOID* nvGPIOGetControlObj();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\nvi2c.h ===
/*----------------------------------------------------------------------------*/
/*
 * nvi2c.h
 *
 */

#ifdef __cplusplus
extern "C"
{
#endif

DWORD nvI2CInit ( ULONG ourRoot, ULONG ourDev, ULONG ourChannel, NvChannel* pNV, UINT subchan, UINT baseInst );
DWORD nvI2CUninit();
DWORD nvI2CWriteByte ( UCHAR chipAddr, UCHAR regAddr, UCHAR regData );
DWORD nvI2CReadByte ( UCHAR chipAddr, UCHAR regAddr, UCHAR* pData );
DWORD nvI2CWriteWord ( UCHAR chipAddr, UCHAR regAddr, USHORT regData );
DWORD nvI2CReadWord ( UCHAR chipAddr, UCHAR regAddr, USHORT* pData );
DWORD nvI2CWriteBuf ( UCHAR* pBuf, UINT bufSize );
DWORD nvI2CReadBuf ( UCHAR* pBuf, UINT bufSize, UCHAR* pData, UINT readBufSize );
DWORD nvI2CWrite(UCHAR chipAddr, DWORD subAddrLen, UCHAR* subAddr, DWORD dataLen, UCHAR* data);
DWORD nvI2CRead(UCHAR chipAddr, DWORD subAddrLen, UCHAR* subAddr, DWORD dataLen, UCHAR* data);

/* backdoors (hopefully temporary) */
DWORD nvI2CSetControlObj ( void* pObj );
VOID* nvI2CGetControlObj ();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\nv432.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1998 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1998  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

 

 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nv32.h> defines a 32-bit wide naming convention  for the functionality  *|
|*  of NVIDIA's Unified Media Architecture (TM).                             *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NV32_INCLUDED
#define NV32_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>

#include "nv332.h"

 /***************************************************************************\
|*                                NV Classes                                 *|
 \***************************************************************************/

/*
 * These structures indicate the offsets of hardware registers corresponding to
 * the methods of each class.  Since the first 256 bytes of each subchannel is 
 * the NvControlPio registers, the hexadecimal offsets in comments start at 
 * 0x100.
 */


/* class NV01_ROOT */
#define  NV01_ROOT                                                 (0x00000000)
/* NvNotification[] fields and values */
#define NV000_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv000Typedef, Nv01Root;
#define  NV000_TYPEDEF                                             nv01Root


/* class NV01_CLASS */
#define  NV01_CLASS                                                (0x00000001)
#define  NV1_CLASS                                                 (0x00000001)
/* NvNotification[] fields and values */
#define NV001_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv001Typedef, Nv01Class;
#define  Nv1Class                                                  Nv01Class
#define  nv1Class                                                  nv01Class
#define  NV001_TYPEDEF                                             nv01Class

/* class NV01_CONTEXT_DMA_FROM_MEMORY */
#define  NV01_CONTEXT_DMA_FROM_MEMORY                              (0x00000002)
#define  NV1_CONTEXT_DMA_FROM_MEMORY                               (0x00000002)
/* NvNotification[] fields and values */
#define NV002_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv002Typedef, Nv01ContextDmaFromMemory;
#define  Nv1ContextDmaFromMemory                       Nv01ContextDmaFromMemory
#define  nv1ContextDmaFromMemory                       nv01ContextDmaFromMemory
#define  NV002_TYPEDEF                                 nv01ContextDmaFromMemory


/* class NV01_CONTEXT_DMA_TO_MEMORY */
#define  NV01_CONTEXT_DMA_TO_MEMORY                                (0x00000003)
#define  NV1_CONTEXT_DMA_TO_MEMORY                                 (0x00000003)
/* NvNotification[] fields and values */
#define NV003_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv003Typedef, Nv01ContextDmaToMemory;
#define  Nv1ContextDmaToMemory                           Nv01ContextDmaToMemory
#define  nv1ContextDmaToMemory                           nv01ContextDmaToMemory
#define  NV003_TYPEDEF                                   nv01ContextDmaToMemory


/* class NV01_TIMER */
#define  NV01_TIMER                                                (0x00000004)
#define  NV1_TIMER                                                 (0x00000004)
/* NvNotification[] elements */
#define NV004_NOTIFIERS_NOTIFY                                     (0)
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
/* NvNotification[] fields and values */
#define NV004_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV004_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV004_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV004_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV004_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV004_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV004_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV004_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  U032 nanoseconds[2];         /* nsec since 1970-01-01 0=immediate    0-   7*/
 } SetAlarmTime;               /* end of method                         -0307*/
 V032 Reserved02[0x001];
 V032 SetAlarmNotify;          /* NV004_SET_ALARM_NOTIFY_*          030c-030f*/
 V032 Reserved03[0x73c];
} Nv004Typedef, Nv01Timer;
#define Nv1Timer                                                   Nv01Timer
#define nv1Timer                                                   nv01Timer
#define NV004_TYPEDEF                                              nv01Timer
/* dma method offsets, fields, and values */
#define NV004_SET_OBJECT                                           (0x00000000)
#define NV004_NO_OPERATION                                         (0x00000100)
#define NV004_NOTIFY                                               (0x00000104)
#define NV004_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV004_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV004_STOP_TRANSFER                                        (0x00000108)
#define NV004_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV004_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV004_SET_ALARM_TIME                                       (0x00000300)
#define NV004_SET_ALARM_NOTIFY                                     (0x0000030C)
#define NV004_SET_ALARM_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)

typedef V032 Nv005Typedef;

typedef V032 Nv006Typedef;

typedef V032 Nv007Typedef;

typedef V032 Nv008Typedef;

typedef V032 Nv009Typedef;

typedef V032 Nv00aTypedef;

typedef V032 Nv00bTypedef;

typedef V032 Nv00cTypedef;

typedef V032 Nv00dTypedef;

typedef V032 Nv00eTypedef;

typedef V032 Nv00fTypedef;

typedef V032 Nv010Typedef;

typedef V032 Nv011Typedef;


/* class NV01_BETA_SOLID */
#define  NV01_BETA_SOLID                                           (0x00000012)
#define  NV1_BETA_SOLID                                            (0x00000012)
/* NvNotification[] elements */
#define NV012_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV012_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV012_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV012_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV012_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV012_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV012_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV012_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetBetaOutput;           /* NV01_PATCHCORD_BETA               0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetBeta1d31;             /* S1d31 beta value                  0300-0303*/
 V032 Reserved03[0x73f];
} Nv012Typedef, Nv01BetaSolid;
#define Nv1BetaSolid                                              Nv01BetaSolid
#define nv1BetaSolid                                              nv01BetaSolid
#define NV012_TYPEDEF                                             nv01BetaSolid
/* dma method offsets, fields, and values */
#define NV012_SET_OBJECT                                           (0x00000000)
#define NV012_NO_OPERATION                                         (0x00000100)
#define NV012_NOTIFY                                               (0x00000104)
#define NV012_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV012_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV012_SET_BETA_OUTPUT                                      (0x00000200)
#define NV012_SET_BETA_1D31                                        (0x00000300)

typedef V032 Nv013Typedef;

typedef V032 Nv014Typedef;

typedef V032 Nv015Typedef;

typedef V032 Nv016Typedef;


/* class NV01_IMAGE_SOLID */
#define  NV01_IMAGE_SOLID                                          (0x00000017)
#define  NV1_IMAGE_SOLID                                           (0x00000017)
/* NvNotification[] elements */
#define NV017_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV017_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV017_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV017_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV017_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV017_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV017_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV017_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV01_PATCHCORD_IMAGE              0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetColorFormat;          /* NV017_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColor;                /* source color                      0304-0307*/
 V032 Reserved03[0x73e];
} Nv017Typedef, Nv01ImageSolid;
#define Nv1ImageSolid                                            Nv01ImageSolid
#define nv1ImageSolid                                            nv01ImageSolid
#define NV017_TYPEDEF                                            nv01ImageSolid
/* dma method offsets, fields, and values */
#define NV017_SET_OBJECT                                           (0x00000000)
#define NV017_NO_OPERATION                                         (0x00000100)
#define NV017_NOTIFY                                               (0x00000104)
#define NV017_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV017_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV017_SET_IMAGE_OUTPUT                                     (0x00000200)
#define NV017_SET_COLOR_FORMAT                                     (0x00000300)
#define NV017_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV017_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV017_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV017_SET_COLOR                                            (0x00000304)


/* class NV01_IMAGE_PATTERN */
#define  NV01_IMAGE_PATTERN                                        (0x00000018)
#define  NV1_IMAGE_PATTERN                                         (0x00000018)
/* NvNotification[] elements */
#define NV018_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV018_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV018_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV018_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV018_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV018_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV018_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV018_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV01_PATCHCORD_IMAGE              0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetColorFormat;          /* NV018_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV018_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 SetMonochromeShape;      /* NV018_SET_MONOCHROME_SHAPE_*      0308-030b*/
 V032 Reserved03[0x001];
 V032 SetMonochromeColor0;     /* color of 0 pixels                 0310-0313*/
 V032 SetMonochromeColor1;     /* color of 1 pixels                 0314-0317*/
 V032 SetMonochromePattern0;   /* first  32 bits of pattern data    0318-031b*/
 V032 SetMonochromePattern1;   /* second 32 bits of pattern data    031c-031f*/
 V032 Reserved05[0x738];
} Nv018Typedef, Nv01ImagePattern;
#define Nv1ImagePattern                                        Nv01ImagePattern
#define nv1ImagePattern                                        nv01ImagePattern
#define NV018_TYPEDEF                                          nv01ImagePattern
/* dma method offsets, fields, and values */
#define NV018_SET_OBJECT                                           (0x00000000)
#define NV018_NO_OPERATION                                         (0x00000100)
#define NV018_NOTIFY                                               (0x00000104)
#define NV018_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV018_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV018_SET_IMAGE_OUTPUT                                     (0x00000200)
#define NV018_SET_COLOR_FORMAT                                     (0x00000300)
#define NV018_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV018_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV018_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV018_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV018_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV018_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV018_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV018_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV018_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV018_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV018_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV018_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV018_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV018_SET_MONOCHORME_PATTERN1                              (0x0000031C)


/* class NV01_IMAGE_BLACK_RECTANGLE */
#define  NV01_IMAGE_BLACK_RECTANGLE                                (0x00000019)
#define  NV1_IMAGE_BLACK_RECTANGLE                                 (0x00000019)
/* NvNotification[] elements */
#define NV019_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV019_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV019_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV019_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV019_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV019_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV019_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV019_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV01_PATCHCORD_IMAGE              0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetPoint;                /* y_x S16_S16                       0300-0303*/
 V032 SetSize;                 /* height_width U16_U16              0304-0307*/
 V032 Reserved03[0x73e];
} Nv019Typedef, Nv01ImageBlackRectangle;
#define Nv1ImageBlackRectangle                          Nv01ImageBlackRectangle
#define nv1ImageBlackRectangle                          nv01ImageBlackRectangle
#define NV019_TYPEDEF                                   nv01ImageBlackRectangle
/* dma method offsets, fields, and values */
#define NV019_SET_OBJECT                                           (0x00000000)
#define NV019_NO_OPERATION                                         (0x00000100)
#define NV019_NOTIFY                                               (0x00000104)
#define NV019_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV019_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV019_SET_IMAGE_OUTPUT                                     (0x00000200)
#define NV019_SET_POINT                                            (0x00000300)
#define NV019_SET_POINT_X                                          15:0
#define NV019_SET_POINT_Y                                          31:16
#define NV019_SET_SIZE                                             (0x00000304)
#define NV019_SET_SIZE_WIDTH                                       15:0
#define NV019_SET_SIZE_HEIGHT                                      31:16

typedef V032 Nv01aTypedef;

typedef V032 Nv01bTypedef;


/* class NV01_RENDER_SOLID_LIN */
#define  NV01_RENDER_SOLID_LIN                                     (0x0000001C)
#define  NV1_RENDER_SOLID_LIN                                      (0x0000001C)
/* NvNotification[] elements */
#define NV01C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01C_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01C_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01C_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point0;                 /* y_x S16_S16 in pixels                0-   3*/
  V032 point1;                 /* y_x S16_S16 in pixels                4-   7*/
 } Lin[16];                    /* end of aliased methods in array       -047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 point0X;                /* in pixels, 0 at left                 0-   3*/
  S032 point0Y;                /* in pixels, 0 at top                  4-   7*/
  S032 point1X;                /* in pixels, 0 at left                 8-   b*/
  S032 point1Y;                /* in pixels, 0 at top                  c-   f*/
 } Lin32[8];                   /* end of aliased methods in array       -04ff*/
 V032 PolyLin[32];             /* y_x S16_S16 in pixels             0500-057f*/
 struct {                      /* start of aliased methods in array 0580-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } PolyLin32[16];              /* end of aliased methods in array       -05ff*/
 struct {                      /* start of aliased methods in array 0600-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point;                  /* y_x S16_S16 in pixels                4-   7*/
 } ColorPolyLin[16];           /* end of aliased methods in array       -067f*/
 V032 Reserved03[0x660];
} Nv01cTypedef, Nv01RenderSolidLin;
#define Nv1RenderSolidLin                                    Nv01RenderSolidLin
#define nv1RenderSolidLin                                    nv01RenderSolidLin
#define NV01C_TYPEDEF                                        nv01RenderSolidLin
/* dma method offsets, fields, and values */
#define NV01C_SET_OBJECT                                           (0x00000000)
#define NV01C_NO_OPERATION                                         (0x00000100)
#define NV01C_NOTIFY                                               (0x00000104)
#define NV01C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01C_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01C_SET_OPERATION                                        (0x000002FC)
#define NV01C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01C_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01C_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01C_COLOR                                                (0x00000304)
#define NV01C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0(a)                                        (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0_X                                         15:0
#define NV01C_LIN_POINT0_Y                                         31:16
#define NV01C_LIN_POINT1(a)                                        (0x00000404\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT1_X                                         15:0
#define NV01C_LIN_POINT1_Y                                         31:16
#define NV01C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_X(a)                                    (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_Y(a)                                    (0x00000484\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_X(a)                                    (0x00000488\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_Y(a)                                    (0x0000048C\
                                                                   +(a)*0x0010)
#define NV01C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV01C_POLY_LIN_X                                           15:0
#define NV01C_POLY_LIN_Y                                           31:16
#define NV01C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_X(a)                                      (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_Y(a)                                      (0x00000584\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_COLOR(a)                              (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT(a)                              (0x00000604\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV01C_COLOR_POLY_LIN_POINT_Y                               31:16


/* class NV01_RENDER_SOLID_TRIANGLE */
#define  NV01_RENDER_SOLID_TRIANGLE                                (0x0000001D)
#define  NV1_RENDER_SOLID_TRIANGLE                                 (0x0000001D)
/* NvNotification[] elements */
#define NV01D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01D_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01D_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01D_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x002];
 V032 TrianglePoint0;          /* y_x S16_S16 in pixels             0310-0313*/
 V032 TrianglePoint1;          /* y_x S16_S16 in pixels             0314-0317*/
 V032 TrianglePoint2;          /* y_x S16_S16 in pixels             0318-031b*/
 V032 Reserved03[0x001];
 S032 Triangle32Point0X;       /* in pixels, 0 at left              0320-0323*/
 S032 Triangle32Point0Y;       /* in pixels, 0 at top               0324-0327*/
 S032 Triangle32Point1X;       /* in pixels, 0 at left              0328-032b*/
 S032 Triangle32Point1Y;       /* in pixels, 0 at top               032c-032f*/
 S032 Triangle32Point2X;       /* in pixels, 0 at left              0330-0333*/
 S032 Triangle32Point2Y;       /* in pixels, 0 at top               0334-0337*/
 V032 Reserved04[0x032];
 V032 Trimesh[32];             /* y_x S16_S16 in pixels             0400-047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } Trimesh32[16];              /* end of aliased methods in array       -04ff*/
 struct {                      /* start of aliased methods in array 0500-    */
  V032 color;                  /* source color                         0-   3*/
  V032 y0_x0;                  /* S16_S16 in pixels, 0 at top left     4-   7*/
  V032 y1_x1;                  /* S16_S16 in pixels, 0 at top left     8-   b*/
  V032 y2_x2;                  /* S16_S16 in pixels, 0 at top left     c-   f*/
 } ColorTriangle[8];           /* end of aliased methods in array       -057f*/
 struct {                      /* start of aliased methods in array 0580-    */
  V032 color;                  /* source color                         0-   3*/
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left     4-   7*/
 } ColorTrimesh[16];           /* end of aliased methods in array       -05ff*/
 V032 Reserved05[0x680];
} Nv01dTypedef, Nv01RenderSolidTriangle;
#define Nv1RenderSolidTriangle                          Nv01RenderSolidTriangle
#define nv1RenderSolidTriangle                          nv01RenderSolidTriangle
#define NV01D_TYPEDEF                                   nv01RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV01D_SET_OBJECT                                           (0x00000000)
#define NV01D_NO_OPERATION                                         (0x00000100)
#define NV01D_NOTIFY                                               (0x00000104)
#define NV01D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01D_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01D_SET_OPERATION                                        (0x000002FC)
#define NV01D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01D_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01D_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01D_COLOR                                                (0x00000304)
#define NV01D_TRIANGLE_POINT0                                      (0x00000310)
#define NV01D_TRIANGLE_POINT0_X                                    15:0
#define NV01D_TRIANGLE_POINT0_Y                                    31:16
#define NV01D_TRIANGLE_POINT1                                      (0x00000314)
#define NV01D_TRIANGLE_POINT1_X                                    15:0
#define NV01D_TRIANGLE_POINT1_Y                                    31:16
#define NV01D_TRIANGLE_POINT2                                      (0x00000318)
#define NV01D_TRIANGLE_POINT2_X                                    15:0
#define NV01D_TRIANGLE_POINT2_Y                                    31:16
#define NV01D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV01D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV01D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV01D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV01D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV01D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV01D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV01D_TRIMESH_X                                            15:0
#define NV01D_TRIMESH_Y                                            31:16
#define NV01D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV01D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT_X                                15:0
#define NV01D_COLOR_TRIMESH_POINT_Y                                31:16


/* class NV01_RENDER_SOLID_RECTANGLE */
#define  NV01_RENDER_SOLID_RECTANGLE                               (0x0000001E)
#define  NV1_RENDER_SOLID_RECTANGLE                                (0x0000001E)
/* NvNotification[] elements */
#define NV01E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01E_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01E_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01E_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* y_x S16_S16                          0-   3*/
  V032 size;                   /* height_width U16_U16                 4-   7*/
 } Rectangle[16];              /* end of method in array in array       -047f*/
 V032 Reserved03[0x6e0];
} Nv01eTypedef, Nv01RenderSolidRectangle;
#define Nv1RenderSolidRectangle                        Nv01RenderSolidRectangle
#define nv1RenderSolidRectangle                        nv01RenderSolidRectangle
#define NV01E_TYPEDEF                                  nv01RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV01E_SET_OBJECT                                           (0x00000000)
#define NV01E_NO_OPERATION                                         (0x00000100)
#define NV01E_NOTIFY                                               (0x00000104)
#define NV01E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01E_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01E_SET_OPERATION                                        (0x000002FC)
#define NV01E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01E_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01E_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01E_COLOR                                                (0x00000304)
#define NV01E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT_X                                    15:0
#define NV01E_RECTANGLE_POINT_Y                                    31:16
#define NV01E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV01E_RECTANGLE_SIZE_HEIGHT                                31:16


/* class NV01_IMAGE_BLIT */
#define  NV01_IMAGE_BLIT                                           (0x0000001F)
#define  NV1_IMAGE_BLIT                                            (0x0000001F)
/* NvNotification[] elements */
#define NV01F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01F_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV01_IMAGE_SOLID                  0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextSurfaceSource; /* NV03_CONTEXT_SURFACE_1            0198-019b*/
 V032 SetContextSurfaceDestin; /* NV03_CONTEXT_SURFACE_0            019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV01F_SET_OPERATION_*             02fc-02ff*/
 V032 ControlPointIn;          /* y_x U16_U16, pixels, top left src 0300-0303*/
 V032 ControlPointOut;         /* y_x S16_S16, pixels, top left dst 0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels    0308-030b*/
 V032 Reserved02[0x73d];
} Nv01fTypedef, Nv01ImageBlit;
#define Nv1ImageBlit                                              Nv01ImageBlit
#define nv1ImageBlit                                              nv01ImageBlit
#define NV01F_TYPEDEF                                             nv01ImageBlit
/* dma method offsets, fields, and values */
#define NV01F_SET_OBJECT                                           (0x00000000)
#define NV01F_NO_OPERATION                                         (0x00000100)
#define NV01F_NOTIFY                                               (0x00000104)
#define NV01F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV01F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV01F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV01F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV01F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV01F_SET_CONTEXT_SURFACE_SOURCE                           (0x00000198)
#define NV01F_SET_CONTEXT_SURFACE_DESTIN                           (0x0000019C)
#define NV01F_SET_OPERATION(s)                                     (0x000002FC)
#define NV01F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01F_CONTROL_POINT_IN                                     (0x00000300)
#define NV01F_CONTROL_POINT_IN_X                                   15:0
#define NV01F_CONTROL_POINT_IN_Y                                   31:16
#define NV01F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV01F_CONTROL_POINT_OUT_X                                  15:0
#define NV01F_CONTROL_POINT_OUT_Y                                  31:16
#define NV01F_SIZE                                                 (0x00000308)
#define NV01F_SIZE_WIDTH                                           15:0
#define NV01F_SIZE_HEIGHT                                          31:16

typedef V032 Nv020Typedef;


/* class NV01_IMAGE_FROM_CPU */
#define  NV01_IMAGE_FROM_CPU                                       (0x00000021)
#define  NV1_IMAGE_FROM_CPU                                        (0x00000021)
/* NvNotification[] elements */
#define NV021_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV021_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV021_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV021_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV021_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV021_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV021_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV01_IMAGE_SOLID                  0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV021_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV021_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels             0304-0307*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 030c-030f*/
 V032 Reserved02[0x03c];
 V032 Color[32];               /* packed pixel(s) to add to image   0400-047f*/
 V032 Reserved03[0x6e0];
} Nv021Typedef, Nv01ImageFromCpu;
#define Nv1ImageFromCpu                                        Nv01ImageFromCpu
#define nv1ImageFromCpu                                        nv01ImageFromCpu
#define NV021_TYPEDEF                                          nv01ImageFromCpu
/* dma method offsets, fields, and values */
#define NV021_SET_OBJECT                                           (0x00000000)
#define NV021_NO_OPERATION                                         (0x00000100)
#define NV021_NOTIFY                                               (0x00000104)
#define NV021_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV021_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV021_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV021_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV021_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV021_SET_CONTEXT_ROP                                      (0x00000190)
#define NV021_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV021_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV021_SET_OPERATION                                        (0x000002FC)
#define NV021_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV021_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV021_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV021_SET_COLOR_FORMAT                                     (0x00000300)
#define NV021_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV021_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV021_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV021_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV021_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV021_POINT                                                (0x00000304)
#define NV021_POINT_X                                              15:0
#define NV021_POINT_Y                                              31:16
#define NV021_SIZE_OUT                                             (0x00000308)
#define NV021_SIZE_OUT_WIDTH                                       15:0
#define NV021_SIZE_OUT_HEIGHT                                      31:16
#define NV021_SIZE_IN                                              (0x0000030C)
#define NV021_SIZE_IN_WIDTH                                        15:0
#define NV021_SIZE_IN_HEIGHT                                       31:16
#define NV021_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)

typedef V032 Nv022Typedef;

typedef V032 Nv023Typedef;

typedef V032 Nv024Typedef;

typedef V032 Nv025Typedef;

typedef V032 Nv026Typedef;

typedef V032 Nv027Typedef;

typedef V032 Nv028Typedef;

typedef V032 Nv029Typedef;

typedef V032 Nv02aTypedef;

typedef V032 Nv02bTypedef;

typedef V032 Nv02cTypedef;

typedef V032 Nv02dTypedef;

typedef V032 Nv02eTypedef;

typedef V032 Nv02fTypedef;


/* class NV01_NULL */
#define  NV01_NULL                                                 (0x00000030)
#define  NV1_NULL                                                  (0x00000030)
/* NvNotification[] fields and values */
#define NV030_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv030Typedef, Nv01Null;
#define  Nv1Null                                                   Nv01Null
#define  nv1Null                                                   nv01Null
#define  NV030_TYPEDEF                                             nv01Null

typedef V032 Nv031Typedef;

typedef V032 Nv032Typedef;

typedef V032 Nv033Typedef;

typedef V032 Nv034Typedef;

typedef V032 Nv035Typedef;



/* class NV03_STRETCHED_IMAGE_FROM_CPU */
#define  NV03_STRETCHED_IMAGE_FROM_CPU                             (0x00000036)
#define  NV3_STRETCHED_IMAGE_FROM_CPU                              (0x00000036)
/* NvNotification[] elements */
#define NV036_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV036_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV036_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV036_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV036_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV036_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV036_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV01_IMAGE_SOLID                  0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV036_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV036_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SizeIn;                  /* height_width U16_U16 in texels    0304-0307*/
 V032 DeltaDxDu;               /* S12d20 ratio dx/du                0308-030b*/
 V032 DeltaDyDv;               /* S12d20 ratio dy/dv                030c-030f*/
 V032 ClipPoint;               /* y_x S16_S16                       0310-0313*/
 V032 ClipSize;                /* height_width U16_U16              0314-0317*/
 V032 Point12d4;               /* y_x S12d4_S12d4 in pixels         0318-031b*/
 V032 Reserved02[0x039];
 V032 Color[1792];             /* source colors (packed texels)     0400-1fff*/
} Nv036Typedef, Nv03StretchedImageFromCpu;
#define Nv3StretchedImageFromCpu                      Nv03StretchedImageFromCpu
#define nv3StretchedImageFromCpu                      nv03StretchedImageFromCpu
#define NV036_TYPEDEF                                 nv03StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV036_SET_OBJECT                                           (0x00000000)
#define NV036_NO_OPERATION                                         (0x00000100)
#define NV036_NOTIFY                                               (0x00000104)
#define NV036_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV036_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV036_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV036_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV036_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV036_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV036_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV036_SET_OPERATION                                        (0x000002FC)
#define NV036_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV036_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV036_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV036_SET_COLOR_FORMAT                                     (0x00000300)
#define NV036_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV036_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV036_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV036_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV036_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV036_SIZE_IN                                              (0x00000304)
#define NV036_SIZE_IN_WIDTH                                        15:0
#define NV036_SIZE_IN_HEIGHT                                       31:16
#define NV036_DELTA_DX_DU                                          (0x00000308)
#define NV036_DELTA_DY_DV                                          (0x0000030C)
#define NV036_CLIP_POINT                                           (0x00000310)
#define NV036_CLIP_POINT_X                                         15:0
#define NV036_CLIP_POINT_Y                                         31:16
#define NV036_CLIP_SIZE                                            (0x00000314)
#define NV036_CLIP_SIZE_WIDTH                                      15:0
#define NV036_CLIP_SIZE_HEIGHT                                     31:16
#define NV036_POINT_12D4                                           (0x00000318)
#define NV036_POINT_12D4_X                                         15:0
#define NV036_POINT_12D4_Y                                         31:16
#define NV036_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV03_SCALED_IMAGE_FROM_MEMORY */
#define  NV03_SCALED_IMAGE_FROM_MEMORY                             (0x00000037)
#define  NV3_SCALED_IMAGE_FROM_MEMORY                              (0x00000037)
/* NvNotification[] elements */
#define NV037_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV037_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV037_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV037_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV037_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV037_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV037_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x05A];
 V032 SetColorFormat;          /* NV037_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetOperation;            /* NV037_SET_OPERATION_*             0304-0307*/
 V032 ClipPoint;               /* y_x S16_S16                       0308-030b*/
 V032 ClipSize;                /* height_width U16_U16              030c-030f*/
 V032 ImageOutPoint;           /* y_x S16_S16                       0310-0313*/
 V032 ImageOutSize;            /* height_width U16_U16              0314-0317*/
 V032 DeltaDuDx;               /* S12d20 ratio du/dx                0318-031b*/
 V032 DeltaDvDy;               /* S12d20 ratio dv/dy                031c-031f*/
 V032 Reserved02[0x038];
 V032 ImageInSize;             /* height_width U16_U16              0400-0403*/
 U032 ImageInPitch;            /* bytes, vertical pixel delta       0404-0407*/
 U032 ImageInOffset;           /* byte offset of top-left texel     0408-040b*/
 V032 ImageInPoint;            /* v_u U12d4_U12d4                   040c-040f*/
 V032 Reserved03[0x6fc];
} Nv037Typedef, Nv03ScaledImageFromMemory;
#define Nv3ScaledImageFromMemory                      Nv03ScaledImageFromMemory
#define nv3ScaledImageFromMemory                      nv03ScaledImageFromMemory
#define NV037_TYPEDEF                                 nv03ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV037_SET_OBJECT                                           (0x00000000)
#define NV037_NO_OPERATION                                         (0x00000100)
#define NV037_NOTIFY                                               (0x00000104)
#define NV037_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV037_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV037_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV037_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV037_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV037_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV037_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV037_SET_COLOR_FORMAT                                     (0x00000300)
#define NV037_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV037_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV037_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV037_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV037_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV037_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV037_SET_OPERATION                                        (0x00000304)
#define NV037_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV037_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV037_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV037_CLIP_POINT                                           (0x00000308)
#define NV037_CLIP_POINT_X                                         15:0
#define NV037_CLIP_POINT_Y                                         31:16
#define NV037_CLIP_SIZE                                            (0x0000030C)
#define NV037_CLIP_SIZE_WIDTH                                      15:0
#define NV037_CLIP_SIZE_HEIGHT                                     31:16
#define NV037_IMAGE_OUT_POINT                                      (0x00000310)
#define NV037_IMAGE_OUT_POINT_X                                    15:0
#define NV037_IMAGE_OUT_POINT_Y                                    31:16
#define NV037_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV037_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV037_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV037_DELTA_DU_DX                                          (0x00000318)
#define NV037_DELTA_DV_DY                                          (0x0000031C)
#define NV037_IMAGE_IN_SIZE                                        (0x00000400)
#define NV037_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV037_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV037_IMAGE_IN_PITCH                                       (0x00000404)
#define NV037_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV037_IMAGE_IN_POINT                                       (0x0000040C)
#define NV037_IMAGE_IN_POINT_U                                     15:0
#define NV037_IMAGE_IN_POINT_V                                     31:16


/* class NV04_DVD_SUBPICTURE */
#define  NV04_DVD_SUBPICTURE                                       (0x00000038)
#define  NV4_DVD_SUBPICTURE                                        (0x00000038)
/* NvNotification[] elements */
#define NV038_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV038_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV038_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV038_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV038_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV038_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV038_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV038_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaOverlay;    /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaImageIn;    /* NV01_CONTEXT_DMA_FROM_MEMORY      0188-018b*/
 V032 SetContextDmaImageOut;   /* NV01_CONTEXT_DMA_TO_MEMORY        018c-018f*/
 V032 Reserved01[0x05c];
 V032 ImageOutPoint;           /* y_x S16_S16                       0300-0303*/
 V032 ImageOutSize;            /* height_width U16_U16              0304-0307*/
 U032 ImageOutFormat;          /* color_pitch V16_U16               0308-030b*/
 U032 ImageOutOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 ImageInDeltaDuDx;        /* S12d20 ratio du/dx                0310-0313*/
 V032 ImageInDeltaDvDy;        /* S12d20 ratio dv/dy                0314-0317*/
 V032 ImageInSize;             /* height_width U16_U16 in texels    0318-031b*/
 V032 ImageInFormat;           /* color_pitch V16_U16               031c-031f*/
 U032 ImageInOffset;           /* byte offset of top-left texel     0320-0323*/
 V032 ImageInPoint;            /* v_u U12d4_U12d4 in texels         0324-0317*/
 V032 OverlayDeltaDuDx;        /* S12d20 ratio du/dx                0328-032b*/
 V032 OverlayDeltaDvDy;        /* S12d20 ratio dv/dy                032c-032f*/
 V032 OverlaySize;             /* height_width U16_U16 in texels    0330-0333*/
 V032 OverlayFormat;           /* color_pitch V16_U16               0334-0337*/
 U032 OverlayOffset;           /* byte offset of top-left texel     0338-033b*/
 V032 OverlayPoint;            /* v_u U12d4_U12d4 in texels         033c-033f*/
 V032 Reserved02[0x730];
} Nv038Typedef, Nv04DvdSubpicture;
#define Nv4DvdSubpicture                                      Nv04DvdSubpicture
#define nv4DvdSubpicture                                      nv04DvdSubpicture
#define NV038_TYPEDEF                                         nv04DvdSubpicture
/* dma method offsets, fields, and values */
#define NV038_SET_OBJECT                                           (0x00000000)
#define NV038_NO_OPERATION                                         (0x00000100)
#define NV038_NOTIFY                                               (0x00000104)
#define NV038_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV038_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV038_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV038_SET_CONTEXT_DMA_OVERLAY                              (0x00000184)
#define NV038_SET_CONTEXT_DMA_IMAGE_IN                             (0x00000188)
#define NV038_SET_CONTEXT_DMA_IMAGE_OUT                            (0x0000018C)
#define NV038_IMAGE_OUT_POINT                                      (0x00000300)
#define NV038_IMAGE_OUT_POINT_X                                    15:0
#define NV038_IMAGE_OUT_POINT_Y                                    31:16
#define NV038_IMAGE_OUT_SIZE                                       (0x00000304)
#define NV038_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV038_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV038_IMAGE_OUT_FORMAT                                     (0x00000308)
#define NV038_IMAGE_OUT_FORMAT_PITCH                               15:0
#define NV038_IMAGE_OUT_FORMAT_COLOR                               31:16
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8                 (0x00000001)
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8                 (0x00000002)
#define NV038_IMAGE_OUT_OFFSET                                     (0x0000030C)
#define NV038_IMAGE_IN_DELTA_DU_DX                                 (0x00000310)
#define NV038_IMAGE_IN_DELTA_DV_DY                                 (0x00000314)
#define NV038_IMAGE_IN_SIZE                                        (0x00000318)
#define NV038_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV038_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV038_IMAGE_IN_FORMAT                                      (0x0000031C)
#define NV038_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV038_IMAGE_IN_FORMAT_COLOR                                31:16
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8                  (0x00000001)
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8                  (0x00000002)
#define NV038_IMAGE_IN_OFFSET                                      (0x00000320)
#define NV038_IMAGE_IN_POINT                                       (0x00000324)
#define NV038_IMAGE_IN_POINT_U                                     15:0
#define NV038_IMAGE_IN_POINT_V                                     31:16
#define NV038_OVERLAY_DELTA_DU_DX                                  (0x00000328)
#define NV038_OVERLAY_DELTA_DV_DY                                  (0x0000032C)
#define NV038_OVERLAY_SIZE                                         (0x00000330)
#define NV038_OVERLAY_SIZE_WIDTH                                   15:0
#define NV038_OVERLAY_SIZE_HEIGHT                                  31:16
#define NV038_OVERLAY_FORMAT                                       (0x00000334)
#define NV038_OVERLAY_FORMAT_PITCH                                 15:0
#define NV038_OVERLAY_FORMAT_COLOR                                 31:16
#define NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8                     (0x00000001)
#define NV038_OVERLAY_FORMAT_COLOR_LE_A4V6YB6A4U6YA6               (0x00000002)
#define NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT                  (0x00000003)
#define NV038_OVERLAY_OFFSET                                       (0x00000338)
#define NV038_OVERLAY_POINT                                        (0x0000033C)
#define NV038_OVERLAY_POINT_U                                      15:0
#define NV038_OVERLAY_POINT_V                                      31:16


/* class NV03_MEMORY_TO_MEMORY_FORMAT */
#define  NV03_MEMORY_TO_MEMORY_FORMAT                              (0x00000039)
#define  NV3_MEMORY_TO_MEMORY_FORMAT                               (0x00000039)
/* NvNotification[] elements */
#define NV039_NOTIFIERS_NOTIFY                                     (0)
#define NV039_NOTIFIERS_BUFFER_NOTIFY                              (1)
/* NvNotification[] fields and values */
#define NV039_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV039_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV039_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV039_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV039_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV039_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV039_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaBufferIn;   /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaBufferOut;  /* NV01_CONTEXT_DMA_TO_MEMORY        0188-018b*/
 V032 Reserved01[0x060];
 U032 OffsetIn;                /* src offset in bytes               030c-030f*/
 U032 OffsetOut;               /* dst offset in bytes               0310-0313*/
 S032 PitchIn;                 /* delta in bytes, vert pixel delta  0314-0317*/
 S032 PitchOut;                /* delta in bytes, vert pixel delta  0318-031b*/
 U032 LineLengthIn;            /* in bytes                          031c-031f*/
 U032 LineCount;               /* in lines                          0320-0323*/
 V032 Format;                  /* out_in U24_U8                     0324-0327*/
 V032 BufferNotify;            /* NV039_BUFFER_NOTIFY_*             0328-032b*/
 V032 Reserved02[0x735];
} Nv039Typedef, Nv03MemoryToMemoryFormat;
#define Nv3MemoryToMemoryFormat                        Nv03MemoryToMemoryFormat
#define nv3MemoryToMemoryFormat                        nv03MemoryToMemoryFormat
#define NV039_TYPEDEF                                  nv03MemoryToMemoryFormat
/* dma method offsets, fields, and values */
#define NV039_SET_OBJECT                                           (0x00000000)
#define NV039_NO_OPERATION                                         (0x00000100)
#define NV039_NOTIFY                                               (0x00000104)
#define NV039_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV039_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV039_SET_CONTEXT_DMA_BUFFER_IN                            (0x00000184)
#define NV039_SET_CONTEXT_DMA_BUFFER_OUT                           (0x00000188)
#define NV039_OFFSET_IN                                            (0x0000030C)
#define NV039_OFFSET_OUT                                           (0x00000310)
#define NV039_PITCH_IN                                             (0x00000314)
#define NV039_PITCH_OUT                                            (0x00000318)
#define NV039_LINE_LENGTH_IN                                       (0x0000031C)
#define NV039_LINE_COUNT                                           (0x00000320)
#define NV039_FORMAT                                               (0x00000324)
#define NV039_FORMAT_IN                                            7:0
#define NV039_FORMAT_OUT                                           31:8
#define NV039_BUFFER_NOTIFY                                        (0x00000328)
#define NV039_BUFFER_NOTIFY_WRITE_ONLY                             (0x00000000)
#define NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN                      (0x00000001)

typedef V032 Nv03aTypedef;

typedef V032 Nv03bTypedef;

typedef V032 Nv03cTypedef;



/* class NV01_CONTEXT_DMA_IN_MEMORY */
#define  NV01_CONTEXT_DMA_IN_MEMORY                                (0x0000003D)
#define  NV1_CONTEXT_DMA_IN_MEMORY                                 (0x0000003D)
/* NvNotification[] fields and values */
#define NV03D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv03dTypedef, Nv01ContextDmaInMemory;
#define  Nv1ContextDmaInMemory                           Nv01ContextDmaInMemory
#define  nv1ContextDmaInMemory                           nv01ContextDmaInMemory
#define  NV03D_TYPEDEF                                   nv01ContextDmaInMemory


/* object NV01_CONTEXT_ERROR_TO_MEMORY */
#define   NV01_CONTEXT_ERROR_TO_MEMORY                             (0x0000003E)
#define   NV1_CONTEXT_ERROR_TO_MEMORY                              (0x0000003E)
/* NvNotification[] fields and values */
#define NV03E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv03eTypedef, Nv01ContextErrorToMemory;
#define  Nv1ContextErrorToMemory                       Nv01ContextErrorToMemory
#define  nv1ContextErrorToMemory                       nv01ContextErrorToMemory
#define  NV03E_TYPEDEF                                 nv01ContextErrorToMemory


/* class NV01_MEMORY_PRIVILEGED */
#define  NV01_MEMORY_PRIVILEGED                                    (0x0000003F)
#define  NV1_MEMORY_PRIVILEGED                                     (0x0000003F)
/* NvNotification[] fields and values */
#define NV03F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv03fTypedef, Nv01MemoryPrivileged;
#define  Nv1MemoryPrivileged                               Nv01MemoryPrivileged
#define  nv1MemoryPrivileged                               nv01MemoryPrivileged
#define  NV03F_TYPEDEF                                     nv01MemoryPrivileged


/* class NV01_MEMORY_USER */
#define  NV01_MEMORY_USER                                          (0x00000040)
#define  NV1_MEMORY_USER                                           (0x00000040)
/* NvNotification[] fields and values */
#define NV040_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv040Typedef, Nv01MemoryUser;
#define  Nv1MemoryUser                                           Nv01MemoryUser
#define  nv1MemoryUser                                           nv01MemoryUser
#define  NV040_TYPEDEF                                           nv01MemoryUser

typedef V032 Nv041Typedef;


/* class NV04_CONTEXT_SURFACES_2D */
#define  NV04_CONTEXT_SURFACES_2D                                  (0x00000042)
#define  NV4_CONTEXT_SURFACES_2D                                   (0x00000042)
/* NvNotification[] elements */
#define NV042_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV042_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV042_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV042_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV042_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV042_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV042_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV042_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImageSource;/* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaImageDestin;/* NV01_CONTEXT_DMA_IN_MEMORY        0188-018b*/
 V032 Reserved01[0x05d];
 V032 SetColorFormat;          /* NV042_SET_COLOR_FORMAT_*          0300-0303*/
 U032 SetPitch;                /* destin_source U16_U16             0304-0307*/
 U032 SetOffsetSource;         /* byte offset of top-left pixel     0308-030b*/
 U032 SetOffsetDestin;         /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved02[0x73c];
} Nv042Typedef, Nv04ContextSurfaces2d;
#define Nv4ContextSurfaces2D                              Nv04ContextSurfaces2D
#define nv4ContextSurfaces2D                              nv04ContextSurfaces2D
#define NV042_TYPEDEF                                     nv04ContextSurfaces2D
/* dma method offsets, fields, and values */
#define NV042_SET_OBJECT                                           (0x00000000)
#define NV042_NO_OPERATION                                         (0x00000100)
#define NV042_NOTIFY                                               (0x00000104)
#define NV042_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV042_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV042_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV042_SET_CONTEXT_DMA_IMAGE_SOURCE                         (0x00000184)
#define NV042_SET_CONTEXT_DMA_IMAGE_DESTIN                         (0x00000188)
#define NV042_SET_COLOR_FORMAT                                     (0x00000300)
#define NV042_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV042_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000004)
#define NV042_SET_COLOR_FORMAT_LE_Y16                              (0x00000005)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV042_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x0000000A)
#define NV042_SET_COLOR_FORMAT_LE_Y32                              (0x0000000B)
#define NV042_SET_PITCH                                            (0x00000304)
#define NV042_SET_PITCH_SOURCE                                     15:0
#define NV042_SET_PITCH_DESTIN                                     31:16
#define NV042_SET_OFFSET_SOURCE                                    (0x00000308)
#define NV042_SET_OFFSET_DESTIN                                    (0x0000030C)


/* class NV03_CONTEXT_ROP */
#define  NV03_CONTEXT_ROP                                          (0x00000043)
#define  NV3_CONTEXT_ROP                                           (0x00000043)
/* NvNotification[] elements */
#define NV043_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV043_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV043_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV043_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV043_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV043_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV043_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV043_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetRop5;                 /* 32-bit ROP5                       0300-0303*/
 V032 Reserved02[0x73f];
} Nv043Typedef, Nv03ContextRop;
#define Nv3ContextRop                                            Nv03ContextRop
#define nv3ContextRop                                            nv03ContextRop
#define NV043_TYPEDEF                                            nv03ContextRop
/* dma method offsets, fields, and values */
#define NV043_SET_OBJECT                                           (0x00000000)
#define NV043_NO_OPERATION                                         (0x00000100)
#define NV043_NOTIFY                                               (0x00000104)
#define NV043_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV043_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV043_SET_ROP5                                             (0x00000300)


/* class NV04_CONTEXT_PATTERN */
#define  NV04_CONTEXT_PATTERN                                      (0x00000044)
#define  NV4_CONTEXT_PATTERN                                       (0x00000044)
/* NvNotification[] elements */
#define NV044_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV044_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV044_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV044_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV044_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV044_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV044_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV044_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetColorFormat;          /* NV044_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV044_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 SetMonochromeShape;      /* NV044_SET_MONOCHROME_SHAPE_*      0308-030b*/
 V032 SetPatternSelect;        /* NV044_SET_PATTERN_SELECT_*        030c-030f*/
 V032 SetMonochromeColor0;     /* color of 0 pixels                 0310-0313*/
 V032 SetMonochromeColor1;     /* color of 1 pixels                 0314-0317*/
 V032 SetMonochromePattern0;   /* first  32 bits of pattern data    0318-031b*/
 V032 SetMonochromePattern1;   /* second 32 bits of pattern data    031c-031f*/
 V032 Reserved02[0x038];
 V032 SetPatternY8[16];        /* y3_y2_y1_y0 U8_U8_U8_U8           0400-043f*/
 V032 Reserved03[0x030];
 V032 SetPatternR5G6B5[32];    /* see text                          0500-057f*/
 V032 Reserved04[0x020];
 V032 SetPatternX1R5G5B5[32];  /* see text                          0600-067f*/
 V032 Reserved05[0x020];
 V032 SetPatternX8R8G8B8[64];  /* ignore_red_green_blue U8_U8_U8_U8 0700-07ff*/
 V032 Reserved06[0x600];
} Nv044Typedef, Nv04ImagePattern;
#define Nv4ImagePattern                                        Nv04ImagePattern
#define nv4ImagePattern                                        nv04ImagePattern
#define NV044_TYPEDEF                                          nv04ImagePattern
/* dma method offsets, fields, and values */
#define NV044_SET_OBJECT                                           (0x00000000)
#define NV044_NO_OPERATION                                         (0x00000100)
#define NV044_NOTIFY                                               (0x00000104)
#define NV044_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV044_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV044_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV044_SET_COLOR_FORMAT                                     (0x00000300)
#define NV044_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV044_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV044_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV044_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV044_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV044_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV044_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV044_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV044_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV044_SET_PATTERN_SELECT                                   (0x0000030C)
#define NV044_SET_PATTERN_SELECT_MONOCHROME                        (0x00000001)
#define NV044_SET_PATTERN_SELECT_COLOR                             (0x00000002)
#define NV044_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV044_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV044_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV044_SET_MONOCHORME_PATTERN1                              (0x0000031C)
#define NV044_SET_PATTERN_Y8(i)                                    (0x00000400\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_Y8_Y0                                    7:0
#define NV044_SET_PATTERN_Y8_Y1                                    15:8
#define NV044_SET_PATTERN_Y8_Y2                                    23:16
#define NV044_SET_PATTERN_Y8_Y3                                    31:24
#define NV044_SET_PATTERN_R5G6B5(i)                                (0x00000500\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_R5G6B5_BLUE0                             4:0
#define NV044_SET_PATTERN_R5G6B5_GREEN0                            10:5
#define NV044_SET_PATTERN_R5G6B5_RED0                              15:11
#define NV044_SET_PATTERN_R5G6B5_BLUE1                             20:16
#define NV044_SET_PATTERN_R5G6B5_GREEN1                            26:21
#define NV044_SET_PATTERN_R5G6B5_RED1                              31:27
#define NV044_SET_PATTERN_X1R5G5B5(i)                              (0x00000600\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X1R5G5B5_BLUE0                           4:0
#define NV044_SET_PATTERN_X1R5G5B5_GREEN0                          9:5
#define NV044_SET_PATTERN_X1R5G5B5_RED0                            14:10
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE0                         15:15
#define NV044_SET_PATTERN_X1R5G5B5_BLUE1                           20:16
#define NV044_SET_PATTERN_X1R5G5B5_GREEN1                          25:21
#define NV044_SET_PATTERN_X1R5G5B5_RED1                            30:26
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE1                         31:31
#define NV044_SET_PATTERN_X8R8G8B8(i)                              (0x00000700\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X8R8G8B8_BLUE                            7:0
#define NV044_SET_PATTERN_X8R8G8B8_GREEN                           15:8
#define NV044_SET_PATTERN_X8R8G8B8_RED                             23:16
#define NV044_SET_PATTERN_X8R8G8B8_IGNORE                          31:24

typedef V032 Nv045Typedef;


/* class NV03_VIDEO_LUT_CURSOR_DAC */
#define  NV03_VIDEO_LUT_CURSOR_DAC                                 (0x00000046)
/* NvNotification[] elements */
#define NV046_NOTIFIERS_NOTIFY                                     (0)
#define NV046_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV046_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (3+(b))
#define NV046_NOTIFIERS_SET_LUT(b)                                 (5+(b))
#define NV046_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (7+(b))
#define NV046_NOTIFIERS_SET_CURSOR_POINT(b)                        (9+(b))
/* NvNotification[] fields and values */
#define NV046_NOTIFICATION_INFO16_OFFSET_VALID                     (0x0001)
#define NV046_NOTIFICATION_INFO16_OFFSET_INVALID                   (0x0002)
#define NV046_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV046_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV046_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV046_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV046_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV046_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01D];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-018b*/
 V032 SetContextDmaLut;        /* NV01_CONTEXT_DMA_FROM_MEMORY      018c-018f*/
 V032 SetContextDmaCursor;     /* NV01_CONTEXT_DMA_FROM_MEMORY      0190-0193*/
 V032 Reserved01[0x05B];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel        0-   3*/
  V032 format;                 /* pitch_color_field_notify             4-   7*/
 } SetImage[2];                /* end of methods in array               -030f*/
 V032 GetImageOffsetNotify[2]; /* NV046_GET_IMAGE_OFFSET_NOTIFY_*   0310-0317*/
 V032 SetLut[2];               /* notify_offset V02_U30             0318-031f*/
 V032 SetCursorImage[2];       /* notify_offset V02_U30             0320-0327*/
 V032 SetCursorPoint[2];       /* notify_y_x V02_S14_S16            0328-032f*/
 V032 SetDacImageSize;         /* height_width U16_U16 in pixels    0330-0333*/
 V032 SetDacHorizontalSync;    /* width_start U16_U16 in pixels     0334-0337*/
 V032 SetDacVerticalSync;      /* width_start U16_U16 in pixels     0338-033b*/
 V032 SetDacTotalSize;         /* height_width U16_U16 in pixels    033c-033f*/
 U032 SetDacPixelClock;        /* in Hertz                          0340-0343*/
 V032 Reserved02[0x72F];
} Nv046Typedef, nv03VideoLutCursorDac;
#define NV046_TYPEDEF                                     nv03VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV046_SET_OBJECT                                           (0x00000000)
#define NV046_NO_OPERATION                                         (0x00000100)
#define NV046_NOTIFY                                               (0x00000104)
#define NV046_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV046_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV046_STOP_TRANSFER                                        (0x00000108)
#define NV046_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV046_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV046_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV046_SET_CONTEXT_DMA_LUT                                  (0x0000018C)
#define NV046_SET_CONTEXT_DMA_CURSOR                               (0x00000190)
#define NV046_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV046_SET_IMAGE_FORMAT_COLOR                               23:16
#define NV046_SET_IMAGE_FORMAT_COLOR_LUT_LE_Y8                     (0x00000000)
#define NV046_SET_IMAGE_FORMAT_COLOR_BYPASS_LE_R5G6B5              (0x00000001)
#define NV046_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1R5G5B5              (0x00000002)
#define NV046_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1X7R8G8B8            (0x00000003)
#define NV046_SET_IMAGE_FORMAT_FIELD                               29:24
#define NV046_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV046_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV046_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV046_SET_IMAGE_FORMAT_NOTIFY                              31:30
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000310\
                                                                   +(b)*0x0004)
#define NV046_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_LUT(b)                                           (0x00000318\
                                                                   +(b)*0x0004)
#define NV046_SET_LUT_OFFSET                                       29:0
#define NV046_SET_LUT_NOTIFY                                       31:30
#define NV046_SET_LUT_NOTIFY_WRITE_ONLY                            (0x00000000)
#define NV046_SET_LUT_NOTIFY_WRITE_THEN_AWAKEN                     (0x00000001)
#define NV046_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0004)
#define NV046_SET_CURSOR_IMAGE_OFFSET                              29:0
#define NV046_SET_CURSOR_IMAGE_NOTIFY                              31:30
#define NV046_SET_CURSOR_IMAGE_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_CURSOR_IMAGE_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_CURSOR_POINT(b)                                  (0x00000328\
                                                                   +(b)*0x0004)
#define NV046_SET_CURSOR_POINT_X                                   15:0
#define NV046_SET_CURSOR_POINT_Y                                   29:16
#define NV046_SET_CURSOR_POINT_NOTIFY                              31:30
#define NV046_SET_CURSOR_POINT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_CURSOR_POINT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_DAC_IMAGE_SIZE                                   (0x00000330)
#define NV046_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_HORIZONTAL_SYNC                              (0x00000334)
#define NV046_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV046_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV046_SET_DAC_VERTICAL_SYNC                                (0x00000338)
#define NV046_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV046_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV046_SET_DAC_TOTAL_SIZE                                   (0x0000033C)
#define NV046_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_PIXEL_CLOCK                                  (0x00000340)

typedef V032 Nv047Typedef;


/* class NV03_DX3_TEXTURED_TRIANGLE */
#define  NV03_DX3_TEXTURED_TRIANGLE                                (0x00000048)
#define  NV3_DX3_TEXTURED_TRIANGLE                                 (0x00000048)
/* NvNotification[] elements */
#define NV048_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV048_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV048_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV048_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV048_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV048_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV048_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaTexture;    /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextSurfaceColor;  /* NV03_CONTEXT_SURFACE_2            018c-018f*/
 V032 SetContextSurfaceZeta;   /* NV03_CONTEXT_SURFACE_3            0190-0193*/
 V032 Reserved01[0x05c];
 U032 TextureOffset;           /* offset in bytes                   0304-0307*/
 V032 TextureFormat;           /* see text                          0308-030b*/
 V032 TextureFilter;           /* ignore_sizeAdjust_spreadY_spreadX 030c-030f*/
 V032 FogColor;                /* X8R8G8B8 fog color                0310-0313*/
 V032 Control0;                /* see text                          0314-0317*/
 V032 Control1;                /* alphafunc_alpharef V24_U8         0318-031b*/
 V032 Reserved02[0x339];
 struct {                      /* start of method in array          1000-    */
  V032 specular;               /* fog_i5-i0, U0d8_U4_U4_U4_U4_U4_U4   00-  03*/
  V032 color;                  /* X8R8G8B8 or A8R8G8B8                04-  07*/
  F032 sx;                     /* screen x coordinate                 08-  0b*/
  F032 sy;                     /* screen y coordinate                 0c-  0f*/
  F032 sz;                     /* screen z coordinate                 10-  13*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      14-  17*/
  F032 tu;                     /* texture u coordinate                18-  1b*/
  F032 tv;                     /* texture v coordinate                1c-  1f*/
 } Tlvertex[128];              /* end of method in array                -1fff*/
} Nv048Typedef, Nv03Dx3TexturedTriangle;
#define Nv3Dx3TexturedTriangle                          Nv03Dx3TexturedTriangle
#define nv3Dx3TexturedTriangle                          nv03Dx3TexturedTriangle
#define NV048_TYPEDEF                                   nv03Dx3TexturedTriangle
/* dma method offsets, fields, and values */
#define NV048_SET_OBJECT                                           (0x00000000)
#define NV048_NO_OPERATION                                         (0x00000100)
#define NV048_NOTIFY                                               (0x00000104)
#define NV048_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV048_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV048_SET_CONTEXT_DMA_TEXTURE                              (0x00000184)
#define NV048_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV048_SET_CONTEXT_SURFACE_COLOR                            (0x0000018C)
#define NV048_SET_CONTEXT_SURFACE_ZETA                             (0x00000190)
#define NV048_TEXTURE_OFFSET                                       (0x00000304)
#define NV048_TEXTURE_FORMAT                                       (0x00000308)
#define NV048_TEXTURE_FORMAT_VALUE                                 15:0
#define NV048_TEXTURE_FORMAT_KEY                                   19:16
#define NV048_TEXTURE_FORMAT_KEY_DISABLED                          (0x00000000)
#define NV048_TEXTURE_FORMAT_KEY_ENABLED                           (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR                                 23:20
#define NV048_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                     (0x00000000)
#define NV048_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                     (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                     (0x00000002)
#define NV048_TEXTURE_FORMAT_COLOR_LE_R5G6B5                       (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN                              27:24
#define NV048_TEXTURE_FORMAT_SIZE_MIN_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FORMAT_SIZE_MAX                              31:28
#define NV048_TEXTURE_FORMAT_SIZE_MAX_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FILTER                                       (0x0000030C)
#define NV048_TEXTURE_FILTER_SPREAD_X                              4:0
#define NV048_TEXTURE_FILTER_IGNORE0                               7:5
#define NV048_TEXTURE_FILTER_SPREAD_Y                              12:8
#define NV048_TEXTURE_FILTER_IGNORE1                               15:13
#define NV048_TEXTURE_FILTER_SIZE_ADJUST                           23:16
#define NV048_TEXTURE_FILTER_IGNORE2                               31:24
#define NV048_FOG_COLOR                                            (0x00000310)
#define NV048_CONTROL0                                             (0x00000314)
#define NV048_CONTROL0_INTERPOLATOR                                3:0
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CORNER                     (0x00000000)
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CENTER                     (0x00000001)
#define NV048_CONTROL0_INTERPOLATOR_FOH_CENTER                     (0x00000002)
#define NV048_CONTROL0_WRAP_U                                      5:4
#define NV048_CONTROL0_WRAP_U_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_U_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_U_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_U_CLAMP                                (0x00000003)
#define NV048_CONTROL0_WRAP_V                                      7:6
#define NV048_CONTROL0_WRAP_V_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_V_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_V_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_V_CLAMP                                (0x00000003)
#define NV048_CONTROL0_COLOR_FORMAT                                9:8
#define NV048_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8                    (0x00000000)
#define NV048_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8                    (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR                                11:10
#define NV048_CONTROL0_SOURCE_COLOR_NORMAL                         (0x00000000)
#define NV048_CONTROL0_SOURCE_COLOR_COLOR_INVERSE                  (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_INVERSE                  (0x00000002)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_ONE                      (0x00000003)
#define NV048_CONTROL0_CULLING                                     14:12
#define NV048_CONTROL0_CULLING_NONE                                (0x00000001)
#define NV048_CONTROL0_CULLING_COUNTERCLOCKWISE                    (0x00000002)
#define NV048_CONTROL0_CULLING_CLOCKWISE                           (0x00000003)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE                        15:15
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV048_CONTROL0_ZFUNC                                       19:16
#define NV048_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV048_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV048_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV048_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV048_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV048_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV048_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV048_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV048_CONTROL0_ZETA_WRITE                                  23:20
#define NV048_CONTROL0_ZETA_WRITE_NEVER                            (0x00000000)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA                            (0x00000001)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA_ZETA                       (0x00000002)
#define NV048_CONTROL0_ZETA_WRITE_ZETA                             (0x00000003)
#define NV048_CONTROL0_ZETA_WRITE_ALWAYS                           (0x00000004)
#define NV048_CONTROL0_COLOR_WRITE                                 27:24
#define NV048_CONTROL0_COLOR_WRITE_NEVER                           (0x00000000)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA                           (0x00000001)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA_ZETA                      (0x00000002)
#define NV048_CONTROL0_COLOR_WRITE_ZETA                            (0x00000003)
#define NV048_CONTROL0_COLOR_WRITE_ALWAYS                          (0x00000004)
#define NV048_CONTROL0_ROP                                         28:28
#define NV048_CONTROL0_ROP_BLEND_AND                               (0x00000000)
#define NV048_CONTROL0_ROP_ADD_WITH_SATURATION                     (0x00000001)
#define NV048_CONTROL0_BLEND_BETA                                  29:29
#define NV048_CONTROL0_BLEND_BETA_SRCALPHA                         (0x00000000)
#define NV048_CONTROL0_BLEND_BETA_DESTCOLOR                        (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT0                                30:30
#define NV048_CONTROL0_BLEND_INPUT0_DESTCOLOR                      (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT0_ZERO                           (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT1                                31:31
#define NV048_CONTROL0_BLEND_INPUT1_SRCCOLOR                       (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT1_ZERO                           (0x00000001)
#define NV048_CONTROL1                                             (0x00000318)
#define NV048_CONTROL1_ALPHAREF                                    7:0
#define NV048_CONTROL1_ALPHAFUNC                                   31:8
#define NV048_CONTROL1_ALPHAFUNC_NEVER                             (0x00000001)
#define NV048_CONTROL1_ALPHAFUNC_LESS                              (0x00000002)
#define NV048_CONTROL1_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV048_CONTROL1_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV048_CONTROL1_ALPHAFUNC_GREATER                           (0x00000005)
#define NV048_CONTROL1_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV048_CONTROL1_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV048_CONTROL1_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV048_TLVERTEX(a)                                          (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR(a)                                 (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR_I0                                 3:0
#define NV048_TLVERTEX_SPECULAR_I1                                 7:4
#define NV048_TLVERTEX_SPECULAR_I2                                 11:8
#define NV048_TLVERTEX_SPECULAR_I3                                 15:12
#define NV048_TLVERTEX_SPECULAR_I4                                 19:16
#define NV048_TLVERTEX_SPECULAR_I5                                 23:20
#define NV048_TLVERTEX_SPECULAR_FOG                                31:24
#define NV048_TLVERTEX_COLOR(a)                                    (0x00001004\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SX(a)                                       (0x00001008\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SY(a)                                       (0x0000100C\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SZ(a)                                       (0x00001010\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_RHW(a)                                      (0x00001014\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TU(a)                                       (0x00001018\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TV(a)                                       (0x0000101C\
                                                                   +(a)*0x0020)

typedef V032 Nv049Typedef;


/* class NV04_GDI_RECTANGLE_TEXT */
#define  NV04_GDI_RECTANGLE_TEXT                                   (0x0000004A)
#define  NV4_GDI_RECTANGLE_TEXT                                    (0x0000004A)
/* NvNotification[] elements */
#define NV04A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* memory data structures */
typedef struct {               /* start of data structure           0000-    */
   V032 size;                  /* height_width U16_U16 in pixels       0-   3*/
   V032 monochrome[1];         /* 32 monochrome pixels per write       4-   7*/
} Nv04aCharacter8[];           /* end of data structure                 -0007*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels       0-   3*/
  V032 monochrome[3];          /* 32 monochrome pixels per write       4-   f*/
} Nv04aCharacter16[];          /* end of data structure                 -000f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[7];          /* 32 monochrome pixels per write      04-  1f*/
} Nv04aCharacter32[];          /* end of data structure                 -001f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[15];         /* 32 monochrome pixels per write      04-  3f*/
} Nv04aCharacter64[];          /* end of data structure                 -003f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[31];         /* 32 monochrome pixels per write      04-  7f*/
} Nv04aCharacter128[];         /* end of data structure                 -007f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[63];         /* 32 monochrome pixels per write      04-  ff*/
} Nv04aCharacter256[];         /* end of data structure                 -00ff*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels     000- 003*/
  V032 monochrome[127];        /* 32 monochrome pixels per write     004- 1ff*/
} Nv04aCharacter512[];         /* end of data structure                 -01ff*/
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04A_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaFonts;      /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV04A_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV04A_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV04A_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 Reserved02[0x03D];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* x_y S16_S16 in pixels                0-   3*/
  V032 size;                   /* width_height U16_U16 in pixels       4-   7*/
 } UnclippedRectangle[32];     /* end of aliased methods in array       -04ff*/
 V032 Reserved03[0x03D];
 V032 ClipPoint0B;             /* top_left S16_S16 in pixels        05f4-05f7*/
 V032 ClipPoint1B;             /* bottom_right S16_S16 in pixels    05f8-05fb*/
 V032 Color1B;                 /* rectangle color                   05fc-05ff*/
 struct {                      /* start of aliased methods in array 0600-    */
  V032 point0;                 /* top_left S16_S16 in pixels           0-   3*/
  V032 point1;                 /* bottom_right S16_S16 in pixels       4-   7*/
 } ClippedRectangle[32];       /* end of aliased methods in array       -06ff*/
 V032 Reserved04[0x03B];
 V032 ClipPoint0C;             /* top_left S16_S16 in pixels        07ec-07ef*/
 V032 ClipPoint1C;             /* bottom_right S16_S16 in pixe      07f0-07f3*/
 V032 Color1C;                 /* color of 1 pixels                 07f4-07f7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    07f8-07fb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             07fc-07ff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0800-09ff*/
 V032 Reserved05[0x079];
 V032 ClipPoint0E;             /* top_left S16_S16 in pixels        0be4-0be7*/
 V032 ClipPoint1E;             /* bottom_right S16_S16 in pixels    0be8-0beb*/
 V032 Color0E;                 /* color of 0 pixels                 0bec-0bef*/
 V032 Color1E;                 /* color of 1 pixels                 0bf0-0bf3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    0bf4-0bf7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    0c00-0dff*/
 V032 Reserved06[0x07C];
 V032 FontF;                   /* pitch_offset V4_U28               0ff0-0ff3*/
 V032 ClipPoint0F;             /* top_left S16_S16 in pixels        0ff4-0ff7*/
 V032 ClipPoint1F;             /* bottom_right S16_S16 in pixels    0ff8-0ffb*/
 V032 Color1F;                 /* color of 1 pixels                 0ffc-0fff*/
 V032 CharacterColor1F[256];   /* y_x_index S12_S12_U8              1000-13ff*/
 V032 Reserved07[0x0FC];
 V032 FontG;                   /* pitch_offset V4_U28               17f0-17f3*/
 V032 ClipPoint0G;             /* top_left S16_S16 in pixels        17f4-17f7*/
 V032 ClipPoint1G;             /* bottom_right S16_S16 in pixels    17f8-17fb*/
 V032 Color1G;                 /* color of 1 pixels                 17fc-17ff*/
 struct {                      /* start of aliased methods in array 1800-    */
  V032 point;                  /* y_x S16_S16 in pixels                0-   3*/
  U032 index;                  /* 0<=index<=65525                      4-   7*/
 } CharacterColor1G[256];      /* end of aliased methods in array       -1fff*/
} Nv04aTypedef, Nv04GdiRectangleText;
#define Nv4GdiRectangleText                                Nv04GdiRectangleText
#define nv4GdiRectangleText                                nv04GdiRectangleText
#define NV04A_TYPEDEF                                      nv04GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04A_SET_OBJECT                                           (0x00000000)
#define NV04A_NO_OPERATION                                         (0x00000100)
#define NV04A_NOTIFY                                               (0x00000104)
#define NV04A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04A_SET_CONTEXT_DMA_FONTS                                (0x00000184)
#define NV04A_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV04A_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV04A_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV04A_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV04A_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV04A_SET_OPERATION                                        (0x000002FC)
#define NV04A_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04A_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04A_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04A_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV04A_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV04A_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV04A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV04A_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04A_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04A_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04A_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04A_COLOR1_A                                             (0x000003FC)
#define NV04A_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04A_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04A_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04A_CLIP_POINT0_B                                        (0x000005F4)
#define NV04A_CLIP_POINT0_B_LEFT                                   15:0
#define NV04A_CLIP_POINT0_B_TOP                                    31:16
#define NV04A_CLIP_POINT1_B                                        (0x000005F8)
#define NV04A_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04A_COLOR1_B                                             (0x000005FC)
#define NV04A_CLIPPED_RECTANGLE(a)                                 (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0                            (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0_LEFT                       15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_0_TOP                        31:16
#define NV04A_CLIPPED_RECTANGLE_POINT_1                            (0x00000604\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_1_RIGHT                      15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM                     31:16
#define NV04A_CLIP_POINT0_C                                        (0x000007EC)
#define NV04A_CLIP_POINT0_C_LEFT                                   15:0
#define NV04A_CLIP_POINT0_C_TOP                                    31:16
#define NV04A_CLIP_POINT1_C                                        (0x000007F0)
#define NV04A_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04A_COLOR1_C                                             (0x000007F4)
#define NV04A_SIZE_C                                               (0x000007F8)
#define NV04A_SIZE_C_WIDTH                                         15:0
#define NV04A_SIZE_C_HEIGHT                                        31:16
#define NV04A_POINT_C                                              (0x000007FC)
#define NV04A_POINT_C_X                                            15:0
#define NV04A_POINT_C_Y                                            31:16
#define NV04A_MONOCHROME_COLOR1_C(a)                               (0x00000800\
                                                                   +(a)*0x0004)
#define NV04A_CLIP_POINT0_E                                        (0x00000BE4)
#define NV04A_CLIP_POINT0_E_LEFT                                   15:0
#define NV04A_CLIP_POINT0_E_TOP                                    31:16
#define NV04A_CLIP_POINT1_E                                        (0x00000BE8)
#define NV04A_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04A_COLOR0_E                                             (0x00000BEC)
#define NV04A_COLOR1_E                                             (0x00000BF0)
#define NV04A_SIZE_IN_E                                            (0x00000BF4)
#define NV04A_SIZE_IN_E_WIDTH                                      15:0
#define NV04A_SIZE_IN_E_HEIGHT                                     31:16
#define NV04A_SIZE_OUT_E                                           (0x00000BF8)
#define NV04A_SIZE_OUT_E_WIDTH                                     15:0
#define NV04A_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04A_POINT_E                                              (0x00000BFC)
#define NV04A_POINT_E_X                                            15:0
#define NV04A_POINT_E_Y                                            31:16
#define NV04A_MONOCHROME_COLOR01_E(a)                              (0x00000C00\
                                                                   +(a)*0x0004
#define NV04A_FONT_F                                               (0x00000FF0)
#define NV04A_FONT_F_OFFSET                                        27:0
#define NV04A_FONT_F_PITCH                                         31:28
#define NV04A_FONT_F_PITCH_8                                       (0x00000003)
#define NV04A_FONT_F_PITCH_16                                      (0x00000004)
#define NV04A_FONT_F_PITCH_32                                      (0x00000005)
#define NV04A_FONT_F_PITCH_64                                      (0x00000006)
#define NV04A_FONT_F_PITCH_128                                     (0x00000007)
#define NV04A_FONT_F_PITCH_256                                     (0x00000008)
#define NV04A_FONT_F_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_F                                        (0x00000FF4)
#define NV04A_CLIP_POINT0_F_LEFT                                   15:0
#define NV04A_CLIP_POINT0_F_TOP                                    31:16
#define NV04A_CLIP_POINT1_F                                        (0x00000FF8)
#define NV04A_CLIP_POINT1_F_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_F_BOTTOM                                 31:16
#define NV04A_COLOR1_F                                             (0x00000FFC)
#define NV04A_CHARACTER_COLOR1_F(a)                                (0x00001000\
                                                                   +(a)*0x0004)
#define NV04A_CHARACTER_COLOR1_F_INDEX                             7:0
#define NV04A_CHARACTER_COLOR1_F_X                                 19:8
#define NV04A_CHARACTER_COLOR1_F_Y                                 31:20
#define NV04A_FONT_G                                               (0x000017F0)
#define NV04A_FONT_G_OFFSET                                        27:0
#define NV04A_FONT_G_PITCH                                         31:28
#define NV04A_FONT_G_PITCH_8                                       (0x00000003)
#define NV04A_FONT_G_PITCH_16                                      (0x00000004)
#define NV04A_FONT_G_PITCH_32                                      (0x00000005)
#define NV04A_FONT_G_PITCH_64                                      (0x00000006)
#define NV04A_FONT_G_PITCH_128                                     (0x00000007)
#define NV04A_FONT_G_PITCH_256                                     (0x00000008)
#define NV04A_FONT_G_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_G                                        (0x000017F4)
#define NV04A_CLIP_POINT0_G_LEFT                                   15:0
#define NV04A_CLIP_POINT0_G_TOP                                    31:16
#define NV04A_CLIP_POINT1_G                                        (0x000017F8)
#define NV04A_CLIP_POINT1_G_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_G_BOTTOM                                 31:16
#define NV04A_COLOR1_G                                             (0x000017FC)
#define NV04A_CHARACTER_COLOR1_G(a)                                (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT(a)                          (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT_X                           15:0
#define NV04A_CHARACTER_COLOR1_G_POINT_Y                           31:16
#define NV04A_CHARACTER_COLOR1_G_INDEX(a)                          (0x00001804\
                                                                   +(a)*0x0008)


/* class NV03_GDI_RECTANGLE_TEXT */
#define  NV03_GDI_RECTANGLE_TEXT                                   (0x0000004B)
#define  NV3_GDI_RECTANGLE_TEXT                                    (0x0000004B)
/* NvNotification[] elements */
#define NV04B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0184-0187*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0188-018b*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   018c-018f*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0190-0193*/
 V032 Reserved01[0x05a];
 V032 SetOperation;            /* NV04B_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV04B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV04B_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 Reserved02[0x03d];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* x_y S16_S16 in pixels                0-   3*/
  V032 size;                   /* width_height U16_U16 in pixels       4-   7*/
 } UnclippedRectangle[64];     /* end of aliased methods in array       -05ff*/
 V032 Reserved03[0x07D];
 V032 ClipPoint0B;             /* top_left S16_S16 in pixels        07f4-07f7*/
 V032 ClipPoint1B;             /* bottom_right S16_S16 in pixels    07f8-07fb*/
 V032 Color1B;                 /* rectangle color                   07fc-07ff*/
 struct {                      /* start of aliased methods in array 0800-    */
  V032 point0;                 /* top_left S16_S16 in pixels           0-   3*/
  V032 point1;                 /* bottom_right S16_S16 in pixels       4-   7*/
 } ClippedRectangle[64];       /* end of aliased methods in array       -09ff*/
 V032 Reserved04[0x07B];
 V032 ClipPoint0C;             /* top_left S16_S16 in pixels        0bec-0bef*/
 V032 ClipPoint1C;             /* bottom_right S16_S16 in pixels    0bf0-0bf3*/
 V032 Color1C;                 /* color of 1 pixels                 0bf4-0bf7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0c00-0dff*/
 V032 Reserved05[0x07A];
 V032 ClipPoint0D;             /* top_left S16_S16 in pixels        0fe8-0feb*/
 V032 ClipPoint1D;             /* bottom_right S16_S16 in pixels    0fec-0fef*/
 V032 Color1D;                 /* color of 1 pixels                 0ff0-0ff3*/
 V032 SizeInD;                 /* height_width U16_U16 in pixels    0ff4-0ff7*/
 V032 SizeOutD;                /* height_width U16_U16 in pixels    0ff8-0ffb*/
 V032 PointD;                  /* y_x S16_S16 in pixels             0ffc-0fff*/
 V032 MonochromeColor1D[128];  /* 32 monochrome pixels per write    1000-11ff*/
 V032 Reserved06[0x079];
 V032 ClipPoint0E;             /* top_left S16_S16 in pixels        13e4-13e7*/
 V032 ClipPoint1E;             /* bottom_right S16_S16 in pixels    13e8-13eb*/
 V032 Color0E;                 /* color of 0 pixels                 13ec-13ef*/
 V032 Color1E;                 /* color of 1 pixels                 13f0-13f3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    13f4-13f7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    13f8-13fb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             13fc-13ff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    1400-15ff*/
 V032 Reserved07[0x280];
} Nv04bTypedef, Nv03GdiRectangleText;
#define Nv3GdiRectangleText                                Nv03GdiRectangleText
#define nv3GdiRectangleText                                nv03GdiRectangleText
#define NV04B_TYPEDEF                                      nv03GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04B_SET_OBJECT                                           (0x00000000)
#define NV04B_NO_OPERATION                                         (0x00000100)
#define NV04B_NOTIFY                                               (0x00000104)
#define NV04B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04B_SET_CONTEXT_PATTERN                                  (0x00000184)
#define NV04B_SET_CONTEXT_ROP                                      (0x00000188)
#define NV04B_SET_CONTEXT_BETA1                                    (0x0000018C)
#define NV04B_SET_CONTEXT_SURFACE                                  (0x00000190)
#define NV04B_SET_OPERATION                                        (0x000002FC)
#define NV04B_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04B_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04B_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04B_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV04B_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04B_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04B_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04B_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04B_COLOR1_A                                             (0x000003FC)
#define NV04B_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04B_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04B_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04B_CLIP_POINT0_B                                        (0x000007F4)
#define NV04B_CLIP_POINT0_B_LEFT                                   15:0
#define NV04B_CLIP_POINT0_B_TOP                                    31:16
#define NV04B_CLIP_POINT1_B                                        (0x000007F8)
#define NV04B_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04B_COLOR1_B                                             (0x000007FC)
#define NV04B_CLIPPED_RECTANGLE(a)                                 (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0(a)                          (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0_LEFT                        15:0
#define NV04B_CLIPPED_RECTANGLE_POINT0_TOP                         31:16
#define NV04B_CLIPPED_RECTANGLE_POINT1(a)                          (0x00000804\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT1_RIGHT                       15:0
#define NV04B_CLIPPED_RECTANGLE_POINT1_BOTTOM                      31:16
#define NV04B_CLIP_POINT0_C                                        (0x00000BEC)
#define NV04B_CLIP_POINT0_C_LEFT                                   15:0
#define NV04B_CLIP_POINT0_C_TOP                                    31:16
#define NV04B_CLIP_POINT1_C                                        (0x00000BF0)
#define NV04B_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04B_COLOR1_C                                             (0x00000BF4)
#define NV04B_SIZE_C                                               (0x00000BF8)
#define NV04B_SIZE_C_WIDTH                                         15:0
#define NV04B_SIZE_C_HEIGHT                                        31:16
#define NV04B_POINT_C                                              (0x00000BFC)
#define NV04B_POINT_C_X                                            15:0
#define NV04B_POINT_C_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_C(a)                               (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_D                                        (0x00000FE8)
#define NV04B_CLIP_POINT0_D_LEFT                                   15:0
#define NV04B_CLIP_POINT0_D_TOP                                    31:16
#define NV04B_CLIP_POINT1_D                                        (0x00000FEC)
#define NV04B_CLIP_POINT1_D_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_D_BOTTOM                                 31:16
#define NV04B_COLOR1_D                                             (0x00000FF0)
#define NV04B_SIZE_IN_D                                            (0x00000FF4)
#define NV04B_SIZE_IN_D_WIDTH                                      15:0
#define NV04B_SIZE_IN_D_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_D                                           (0x00000FF8)
#define NV04B_SIZE_OUT_D_WIDTH                                     15:0
#define NV04B_SIZE_OUT_D_HEIGHT                                    31:16
#define NV04B_POINT_D                                              (0x00000FFC)
#define NV04B_POINT_D_X                                            15:0
#define NV04B_POINT_D_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_D(a)                               (0x00001000\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_E                                        (0x000013E4)
#define NV04B_CLIP_POINT0_E_LEFT                                   15:0
#define NV04B_CLIP_POINT0_E_TOP                                    31:16
#define NV04B_CLIP_POINT1_E                                        (0x000013E8)
#define NV04B_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04B_COLOR0_E                                             (0x000013EC)
#define NV04B_COLOR1_E                                             (0x000013F0)
#define NV04B_SIZE_IN_E                                            (0x000013F4)
#define NV04B_SIZE_IN_E_WIDTH                                      15:0
#define NV04B_SIZE_IN_E_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_E                                           (0x000013F8)
#define NV04B_SIZE_OUT_E_WIDTH                                     15:0
#define NV04B_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04B_POINT_E                                              (0x000013FC)
#define NV04B_POINT_E_X                                            15:0
#define NV04B_POINT_E_Y                                            31:16
#define NV04B_MONOCHROME_COLOR01_E(a)                              (0x00001400\
                                                                   +(a)*0x0004)

typedef V032 Nv04cTypedef;


/* class NV03_EXTERNAL_VIDEO_DECODER */
#define  NV03_EXTERNAL_VIDEO_DECODER                               (0x0000004D)
/* NvNotification[] elements */
#define NV04D_NOTIFIERS_NOTIFY                                     (0)
#define NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(b)                   (1+(b))
#define NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(b)                   (3+(b))
#define NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(b)                 (5+(b))
#define NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (7+(b))
/* NvNotification[] fields and values */
#define NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED                (0x0000)
#define NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET               (0x0001)
#define NV04D_NOTIFICATION_INFO16_FIELD_DONE                       (0x0002)
#define NV04D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04D_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04D_NOTIFY_*                   0104-0107*/
 NvV32 StopTransferVbi;         /* NV04D_STOP_TRANSFER_VBI_VALUE    0108-010b*/
 NvV32 StopTransferImage;       /* NV04D_STOP_TRANSFER_IMAGE_VALUE  010c-010f*/
 NvV32 Reserved00[0x01c];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaVbi[2];     /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x05a];
 NvU32 SetImageStartLine;       /* lines                            02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvV32 size;                   /* height_firstLine U16_U16            0-   3*/
  NvU32 offset;                 /* byte offset of top-left pixel       4-   7*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        8-   b*/
 } SetVbi[2];                   /* end of methods in array              -0317*/
 NvV32 GetVbiOffsetNotify[2];   /* NV04D_GET_VBI_OFFSET_NOTIFY_*    0318-031f*/
 struct {                       /* start of methods in array        0320-    */
  NvV32 sizeIn;                 /* height_width U16_U16 in pixels      0-   3*/
  NvV32 sizeOut;                /* height_width U16_U16 in pixels      4-   7*/
  NvU32 offset;                 /* byte offset of top-left pixel       8-   b*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        c-   f*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 GetImageOffsetNotify[2]; /* NV04D_GET_IMAGE_OFFSET_NOTIFY_*  0340-0347*/
 NvV32 Reserved02[0x72e];
} Nv04dTypedef, Nv03ExternalVideoDecoder;
#define NV04D_TYPEDEF                                  nv03ExternalVideoDecoder
/* dma method offsets, fields, and values */
#define NV04D_SET_OBJECT                                           (0x00000000)
#define NV04D_NO_OPERATION                                         (0x00000100)
#define NV04D_NOTIFY                                               (0x00000104)
#define NV04D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04D_STOP_TRANSFER_VBI                                    (0x00000108)
#define NV04D_STOP_TRANSFER_VBI_VALUE                              (0x00000000)
#define NV04D_STOP_TRANSFER_IMAGE                                  (0x0000010C)
#define NV04D_STOP_TRANSFER_IMAGE_VALUE                            (0x00000000)
#define NV04D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04D_SET_CONTEXT_DMA_VBI(b)                               (0x00000184\
                                                                   +(b)*0x0004)
#define NV04D_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04D_SET_IMAGE_START_LINE                                 (0x000002FC)
#define NV04D_SET_VBI(b)                                           (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE(b)                                      (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE_FIRST_LINE                              15:0
#define NV04D_SET_VBI_SIZE_HEIGHT                                  31:16
#define NV04D_SET_VBI_OFFSET(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT(b)                                    (0x00000308\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT_PITCH                                 15:0
#define NV04D_SET_VBI_FORMAT_FIELD                                 23:16
#define NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD                      (0x00000001)
#define NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD                       (0x00000002)
#define NV04D_SET_VBI_FORMAT_NOTIFY                                31:24
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_GET_VBI_OFFSET_NOTIFY(b)                             (0x00000318\
                                                                   +(b)*0x0004)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_SET_IMAGE(b)                                         (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN(b)                                 (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN_WIDTH                              15:0
#define NV04D_SET_IMAGE_SIZE_IN_HEIGHT                             31:16
#define NV04D_SET_IMAGE_SIZE_OUT(b)                                (0x00000324\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_OUT_WIDTH                             15:0
#define NV04D_SET_IMAGE_SIZE_OUT_HEIGHT                            31:16
#define NV04D_SET_IMAGE_OFFSET(b)                                  (0x00000328\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT(b)                                  (0x0000032C\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV04D_SET_IMAGE_FORMAT_FIELD                               23:16
#define NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY                              31:24
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000340\
                                                                   +(b)*0x0004)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)



/* class NV03_EXTERNAL_VIDEO_DECOMPRESSOR */
#define  NV03_EXTERNAL_VIDEO_DECOMPRESSOR                          (0x0000004E)
/* NvNotification[] elements */
#define NV04E_NOTIFIERS_NOTIFY                                     (0)
#define NV04E_NOTIFIERS_SET_DATA_NOTIFY(b)                         (1+(b))
#define NV04E_NOTIFIERS_SET_IMAGE_NOTIFY(b)                        (3+(b))
/* NvNotification[] fields and values */
#define NV04E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04E_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04E_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV04E_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaData[2];    /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x05b];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* in bytes                            0-   3*/
  NvU32 length;                 /* in bytes                            4-   7*/
  NvV32 notify;                 /* NV04E_SET_DATA_NOTIFY_*             8-   b*/
 } SetData[2];                  /* end of methods in array              -0317*/
 struct {                       /* start of methods in array        0318-    */
  NvV32 formatIn;               /* zero_field V16_V16                 00-  03*/
  NvV32 size;                   /* height_width U16_U16 in pixels     04-  07*/
  NvU32 offsetOut;              /* byte offset of top-left pixel      08-  0b*/
  NvV32 formatOut;              /* ignore_pitch V16_U16               0c-  0f*/
  NvV32 notify;                 /* NV04E_SET_IMAGE_NOTIFY_*           10-  13*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 Reserved02[0x730];
} Nv04eTypedef, Nv03ExternalVideoDecompressor;
#define NV04E_TYPEDEF                             nv03ExternalVideoDecompressor
/* dma method offsets, fields, and values */
#define NV04E_SET_OBJECT                                           (0x00000000)
#define NV04E_NO_OPERATION                                         (0x00000100)
#define NV04E_NOTIFY                                               (0x00000104)
#define NV04E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04E_STOP_TRANSFER                                        (0x00000108)
#define NV04E_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04E_SET_CONTEXT_DMA_DATA(b)                              (0x00000184\
                                                                   +(b)*0x0004)
#define NV04E_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04E_SET_DATA(b)                                          (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_OFFSET(b)                                   (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_LENGTH(b)                                   (0x00000304\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY(b)                                   (0x00000308\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY_WRITE_ONLY                           (0x00000000)
#define NV04E_SET_DATA_NOTIFY_WRITE_THEN_AWAKEN                    (0x00000001)
#define NV04E_SET_IMAGE(b)                                         (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN(b)                               (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD                            15:0
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_PROGRESSIVE                (0x00000001)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_EVEN_FIELD                 (0x00000002)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_ODD_FIELD                  (0x00000003)
#define NV04E_SET_IMAGE_FORMAT_IN_ZERO                             31:16
#define NV04E_SET_IMAGE_SIZE(b)                                    (0x0000031C\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV04E_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV04E_SET_IMAGE_OFFSET_OUT(b)                              (0x00000320\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT(b)                              (0x00000324\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT_PITCH                           15:0
#define NV04E_SET_IMAGE_FORMAT_OUT_IGNORE                          31:16
#define NV04E_SET_IMAGE_NOTIFY(b)                                  (0x00000324\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_VIDEO_DECOMPRESSOR                            (0x0000004E)
#define Nv3ExternalVideoDecompressor              Nv03ExternalVideoDecompressor
#define nv3ExternalVideoDecompressor              nv03ExternalVideoDecompressor




/* class NV01_EXTERNAL_PARALLEL_BUS */
#define  NV01_EXTERNAL_PARALLEL_BUS                                (0x0000004F)
#define  NV1_EXTERNAL_PARALLEL_BUS                                 (0x0000004F)
/* NvNotification[] elements */
#define NV04F_NOTIFIERS_NOTIFY                                     (0)
#define NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV04F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04F_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04F_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV04F_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 WriteSize;               /* address_data U16_U16              0300-0303*/
 U032 WriteAddress;            /* in bytes                          0304-0307*/
 V032 WriteData;               /* data                              0308-030b*/
 V032 ReadSize;                /* address_data U16_U16              030c-030f*/
 U032 ReadAddress;             /* in bytes                          0310-0313*/
 V032 ReadGetDataNotify;       /* NV04F_READ_GET_DATA_NOTIFY_*      0314-0317*/
 V032 SetInterruptNotify;      /* NV04F_SET_INTERRUPT_NOTIFY_*      0318-031b*/
 V032 Reserved02[0x739];
} Nv04fTypedef, Nv01ExternalParallelBus;
#define Nv1ExternalParallelBus                          Nv01ExternalParallelBus
#define nv1ExternalParallelBus                          nv01ExternalParallelBus
#define NV04F_TYPEDEF                                   nv01ExternalParallelBus
/* dma method offsets, fields, and values */
#define NV04F_SET_OBJECT                                           (0x00000000)
#define NV04F_NO_OPERATION                                         (0x00000100)
#define NV04F_NOTIFY                                               (0x00000104)
#define NV04F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04F_STOP_TRANSFER                                        (0x00000108)
#define NV04F_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04F_WRITE                                                (0x00000300)
#define NV04F_WRITE_SIZE                                           (0x00000300)
#define NV04F_WRITE_SIZE_DATA                                      15:0
#define NV04F_WRITE_SIZE_ADDRESS                                   31:16
#define NV04F_WRITE_ADDRESS                                        (0x00000304)
#define NV04F_WRITE_DATA                                           (0x00000308)
#define NV04F_READ                                                 (0x0000030C)
#define NV04F_READ_SIZE                                            (0x0000030C)
#define NV04F_READ_SIZE_DATA                                       15:0
#define NV04F_READ_SIZE_ADDRESS                                    31:16
#define NV04F_READ_ADDRESS                                         (0x00000310)
#define NV04F_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV04F_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)


/* class NV03_EXTERNAL_MONITOR_BUS */
#define  NV03_EXTERNAL_MONITOR_BUS                                 (0x00000050)
#define  NV3_EXTERNAL_MONITOR_BUS                                  (0x00000050)
/* NvNotification[] elements */
#define NV050_NOTIFIERS_NOTIFY                                     (0)
#define NV050_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV050_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV050_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV050_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV050_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV050_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV050_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV050_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV050_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV050_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV050_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 WriteSize;               /* address_data U16_U16              0300-0303*/
 U032 WriteAddress;            /* in bytes                          0304-0307*/
 V032 WriteData;               /* data                              0308-030b*/
 V032 ReadSize;                /* address_data U16_U16              030c-030f*/
 U032 ReadAddress;             /* in bytes                          0310-0313*/
 V032 ReadGetDataNotify;       /* NV050_READ_GET_DATA_NOTIFY_*      0314-0317*/
 V032 SetInterruptNotify;      /* NV050_SET_INTERRUPT_NOTIFY_*      0318-031b*/
 V032 Reserved02[0x739];
} Nv050Typedef, Nv03ExternalMonitorBus;
#define Nv3ExternalMonitorBus                            Nv03ExternalMonitorBus
#define nv3ExternalMonitorBus                            nv03ExternalMonitorBus
#define NV050_TYPEDEF                                    nv03ExternalMonitorBus
/* dma method offsets, fields, and values */
#define NV050_SET_OBJECT                                           (0x00000000)
#define NV050_NO_OPERATION                                         (0x00000100)
#define NV050_NOTIFY                                               (0x00000104)
#define NV050_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV050_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV050_STOP_TRANSFER                                        (0x00000108)
#define NV050_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV050_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV050_WRITE                                                (0x00000300)
#define NV050_WRITE_SIZE                                           (0x00000300)
#define NV050_WRITE_SIZE_DATA                                      15:0
#define NV050_WRITE_SIZE_ADDRESS                                   31:16
#define NV050_WRITE_ADDRESS                                        (0x00000304)
#define NV050_WRITE_DATA                                           (0x00000308)
#define NV050_READ                                                 (0x0000030C)
#define NV050_READ_SIZE                                            (0x0000030C)
#define NV050_READ_SIZE_DATA                                       15:0
#define NV050_READ_SIZE_ADDRESS                                    31:16
#define NV050_READ_ADDRESS                                         (0x00000310)
#define NV050_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV050_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)


/* class NV03_EXTERNAL_SERIAL_BUS */
#define  NV03_EXTERNAL_SERIAL_BUS                                  (0x00000051)
#define  NV3_EXTERNAL_SERIAL_BUS                                   (0x00000051)
/* NvNotification[] elements */
#define NV051_NOTIFIERS_NOTIFY                                     (0)
#define NV051_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV051_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV051_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV051_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV051_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV051_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV051_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV051_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV051_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV051_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV051_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 WriteSize;               /* address_data U16_U16              0300-0303*/
 U032 WriteAddress;            /* in bytes                          0304-0307*/
 V032 WriteData;               /* data                              0308-030b*/
 V032 ReadSize;                /* address_data U16_U16              030c-030f*/
 U032 ReadAddress;             /* in bytes                          0310-0313*/
 V032 ReadGetDataNotify;       /* NV051_READ_GET_DATA_NOTIFY_*      0314-0317*/
 V032 SetInterruptNotify;      /* NV051_SET_INTERRUPT_NOTIFY_*      0318-031b*/
 V032 Reserved02[0x739];
} Nv051Typedef, Nv03ExternalSerialBus;
#define Nv3ExternalSerialBus                              Nv03ExternalSerialBus
#define nv3ExternalSerialBus                              nv03ExternalSerialBus
#define NV051_TYPEDEF                                     nv03ExternalSerialBus
/* dma method offsets, fields, and values */
#define NV051_SET_OBJECT                                           (0x00000000)
#define NV051_NO_OPERATION                                         (0x00000100)
#define NV051_NOTIFY                                               (0x00000104)
#define NV051_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV051_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV051_STOP_TRANSFER                                        (0x00000108)
#define NV051_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV051_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV051_WRITE                                                (0x00000300)
#define NV051_WRITE_SIZE                                           (0x00000300)
#define NV051_WRITE_SIZE_DATA                                      15:0
#define NV051_WRITE_SIZE_ADDRESS                                   31:16
#define NV051_WRITE_ADDRESS                                        (0x00000304)
#define NV051_WRITE_DATA                                           (0x00000308)
#define NV051_READ                                                 (0x0000030C)
#define NV051_READ_SIZE                                            (0x0000030C)
#define NV051_READ_SIZE_DATA                                       15:0
#define NV051_READ_SIZE_ADDRESS                                    31:16
#define NV051_READ_ADDRESS                                         (0x00000310)
#define NV051_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV051_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)


/* class NV04_CONTEXT_SURFACE_SWIZZLED */
#define  NV04_CONTEXT_SURFACE_SWIZZLED                             (0x00000052)
#define  NV4_CONTEXT_SURFACE_SWIZZLED                              (0x00000052)
/* NvNotification[] elements */
#define NV052_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV052_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV052_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV052_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV052_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV052_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV052_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV052_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetFormat;               /* height_width_color V8_V8_V16      0300-0303*/
 U032 SetOffset;               /* byte offset of top-left pixel     0304-0307*/
 V032 Reserved02[0x73e];
} Nv052Typedef, Nv04ContextSurfaceSwizzled;
#define Nv4ContextSurfaceSwizzled                    Nv04ContextSurfaceSwizzled
#define nv4ContextSurfaceSwizzled                    nv04ContextSurfaceSwizzled
#define NV052_TYPEDEF                                nv04ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV052_SET_OBJECT                                           (0x00000000)
#define NV052_NO_OPERATION                                         (0x00000100)
#define NV052_NOTIFY                                               (0x00000104)
#define NV052_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV052_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV052_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV052_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV052_SET_FORMAT                                           (0x00000300)
#define NV052_SET_FORMAT_COLOR                                     15:0
#define NV052_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV052_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV052_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV052_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV052_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV052_SET_FORMAT_WIDTH                                     23:16
#define NV052_SET_FORMAT_WIDTH_1                                   (0x00000000)
#define NV052_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV052_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV052_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV052_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV052_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV052_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV052_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV052_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV052_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV052_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV052_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV052_SET_FORMAT_HEIGHT                                    31:24
#define NV052_SET_FORMAT_HEIGHT_1                                  (0x00000000)
#define NV052_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV052_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV052_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV052_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV052_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV052_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV052_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV052_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV052_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV052_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV052_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV052_SET_OFFSET                                           (0x00000304)


/* class NV04_CONTEXT_SURFACES_ARGB_ZS */
#define  NV04_CONTEXT_SURFACES_ARGB_ZS                             (0x00000053)
#define  NV4_CONTEXT_SURFACES_ARGB_ZS                              (0x00000053)
/* NvNotification[] elements */
#define NV053_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV053_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV053_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV053_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV053_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV053_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV053_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV053_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaColor;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaZeta;       /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05b];
 NvV32 SetClipHorizontal;       /* width_x U16_U16                  02F8-02FB*/
 NvV32 SetClipVertical;         /* height_y U16_U16                 02FC-02FF*/
 NvV32 SetFormat;               /* height_width_type_color all V8   0300-0303*/
 NvV32 SetClipSize;             /* height_width U16_U16             0304-0307*/
 NvU32 SetPitch;                /* zeta_color U16_U16               0308-030b*/
 NvU32 SetOffsetColor;          /* byte offset of top-left pixel    030c-030f*/
 NvU32 SetOffsetZeta;           /* byte offset of top-left pixel    0310-0313*/
 NvV32 Reserved02[0x73b];
} Nv053Typedef, Nv04ContextSurfacesArgbZs;
#define Nv4ContextSurfacesArgbZs                      Nv04ContextSurfacesArgbZs
#define nv4ContextSurfacesArgbZs                      nv04ContextSurfacesArgbZs
#define NV053_TYPEDEF                                 nv04ContextSurfacesArgbZs
/* dma method offsets, fields, and values */
#define NV053_SET_OBJECT                                           (0x00000000)
#define NV053_NO_OPERATION                                         (0x00000100)
#define NV053_NOTIFY                                               (0x00000104)
#define NV053_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV053_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV053_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV053_SET_CONTEXT_DMA_COLOR                                (0x00000184)
#define NV053_SET_CONTEXT_DMA_ZETA                                 (0x00000188)
#define NV053_SET_CLIP_HORIZONTAL                                  (0x000002F8)
#define NV053_SET_CLIP_HORIZONTAL_X                                15:0
#define NV053_SET_CLIP_HORIZONTAL_WIDTH                            31:16
#define NV053_SET_CLIP_VERTICAL                                    (0x000002FC)
#define NV053_SET_CLIP_VERTICAL_Y                                  15:0
#define NV053_SET_CLIP_VERTICAL_HEIGHT                             31:16
#define NV053_SET_FORMAT                                           (0x00000300)
#define NV053_SET_FORMAT_COLOR                                     7:0
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000001)
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000002)
#define NV053_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000003)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000004)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000005)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000006)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000007)
#define NV053_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x00000008)
#define NV053_SET_FORMAT_TYPE                                      15:8
#define NV053_SET_FORMAT_TYPE_PITCH                                (0x00000001)
#define NV053_SET_FORMAT_TYPE_SWIZZLE                              (0x00000002)
#define NV053_SET_FORMAT_WIDTH                                     23:16
#define NV053_SET_FORMAT_HEIGHT                                    31:24
#define NV053_SET_CLIP_SIZE                                        (0x00000304)
#define NV053_SET_CLIP_SIZE_WIDTH                                  15:0
#define NV053_SET_CLIP_SIZE_HEIGHT                                 31:16
#define NV053_SET_PITCH                                            (0x00000308)
#define NV053_SET_PITCH_COLOR                                      15:0
#define NV053_SET_PITCH_ZETA                                       31:16
#define NV053_SET_OFFSET_COLOR                                     (0x0000030C)
#define NV053_SET_OFFSET_ZETA                                      (0x00000310)


/* class NV04_DX5_TEXTURED_TRIANGLE */
#define  NV04_DX5_TEXTURED_TRIANGLE                                (0x00000054)
#define  NV4_DX5_TEXTURED_TRIANGLE                                 (0x00000054)
/* NvNotification[] elements */
#define NV054_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV054_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV054_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV054_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV054_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV054_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV054_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV054_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaA;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaB;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0188-018b*/
 V032 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_ARGB_ZS     018c-018f*/
 V032 Reserved01[0x05c];
 V032 ColorKey;                /* texture color key value           0300-0303*/
 U032 Offset;                  /* texture offset in bytes           0304-0307*/
 V032 Format;                  /* see text                          0308-030b*/
 V032 Filter;                  /* see text                          030c-030f*/
 V032 Blend;                   /* see text                          0310-0313*/
 V032 Control;                 /* see text                          0314-0317*/
 V032 FogColor;                /* X8R8G8B8 fog color                0318-031b*/
 V032 Reserved02[0x039];
 struct {                      /* start of method in array          0400-    */
  F032 sx;                     /* screen x coordinate                 00-  03*/
  F032 sy;                     /* screen y coordinate                 04-  07*/
  F032 sz;                     /* screen z coordinate                 08-  0b*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      0c-  0f*/
  V032 color;                  /* A8R8G8B8                            10-  13*/
  V032 specular;               /* F8R8G8B8                            14-  17*/
  F032 tu;                     /* texture u coordinate                18-  1b*/
  F032 tv;                     /* texture v coordinate                1c-  1f*/
 } Tlvertex[16];               /* end of method in array                -05ff*/
 V032 DrawPrimitive[64];       /* see text                          0600-06ff*/
 V032 Reserved03[0x640];
} Nv054Typedef, Nv04Dx5TexturedTriangle;
#define Nv4Dx5TexturedTriangle                          Nv04Dx5TexturedTriangle
#define nv4Dx5TexturedTriangle                          nv04Dx5TexturedTriangle
#define NV054_TYPEDEF                                   nv04Dx5TexturedTriangle
/* dma method offsets, fields, and values */
#define NV054_SET_OBJECT                                           (0x00000000)
#define NV054_NO_OPERATION                                         (0x00000100)
#define NV054_NOTIFY                                               (0x00000104)
#define NV054_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV054_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV054_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV054_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV054_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV054_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV054_COLOR_KEY                                            (0x00000300)
#define NV054_OFFSET                                               (0x00000304)
#define NV054_FORMAT                                               (0x00000308)
#define NV054_FORMAT_CONTEXT_DMA                                   1:0
#define NV054_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV054_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV054_FORMAT_COLORKEYENABLE                                3:2
#define NV054_FORMAT_COLORKEYENABLE_FALSE                          (0x00000000)
#define NV054_FORMAT_COLORKEYENABLE_TRUE                           (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH                                    5:4
#define NV054_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV054_FORMAT_ORIGIN_FOH                                    7:6
#define NV054_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV054_FORMAT_COLOR                                         11:8
#define NV054_FORMAT_COLOR_LE_Y8                                   (0x00000001)
#define NV054_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV054_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV054_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV054_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV054_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV054_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV054_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV054_FORMAT_BASE_SIZE_U                                   19:16
#define NV054_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV054_FORMAT_BASE_SIZE_V                                   23:20
#define NV054_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV054_FORMAT_TEXTUREADDRESSU                               26:24
#define NV054_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPU                                         27:27
#define NV054_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV                               30:28
#define NV054_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPV                                         31:31
#define NV054_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV054_FILTER                                               (0x0000030C)
#define NV054_FILTER_KERNEL_SIZE_X                                 7:0
#define NV054_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV054_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV054_FILTER_MIPMAPLODBIAS                                 23:16
#define NV054_FILTER_TEXTUREMIN                                    26:24
#define NV054_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV054_FILTER_TEXTUREMAG                                    30:28
#define NV054_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV054_BLEND                                                (0x00000310)
#define NV054_BLEND_TEXTUREMAPBLEND                                3:0
#define NV054_BLEND_TEXTUREMAPBLEND_DECAL                          (0x00000001)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATE                       (0x00000002)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA                     (0x00000003)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA                  (0x00000004)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALMASK                      (0x00000005)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK                   (0x00000006)
#define NV054_BLEND_TEXTUREMAPBLEND_COPY                           (0x00000007)
#define NV054_BLEND_TEXTUREMAPBLEND_ADD                            (0x00000008)
#define NV054_BLEND_MASK_BIT                                       5:4
#define NV054_BLEND_MASK_BIT_LSB                                   (0x00000001)
#define NV054_BLEND_MASK_BIT_MSB                                   (0x00000002)
#define NV054_BLEND_SHADEMODE                                      7:6
#define NV054_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV054_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV054_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV054_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV054_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV054_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV054_BLEND_SPECULARENABLE                                 15:12
#define NV054_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV054_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV054_BLEND_FOGENABLE                                      19:16
#define NV054_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV054_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV054_BLEND_ALPHABLENDENABLE                               23:20
#define NV054_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV054_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV054_BLEND_SRCBLEND                                       27:24
#define NV054_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV054_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV054_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV054_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV054_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV054_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV054_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV054_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV054_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV054_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV054_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV054_BLEND_DESTBLEND                                      31:28
#define NV054_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV054_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV054_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV054_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV054_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV054_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV054_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV054_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV054_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV054_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV054_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV054_CONTROL                                              (0x00000314)
#define NV054_CONTROL_ALPHAREF                                     7:0
#define NV054_CONTROL_ALPHAFUNC                                    11:8
#define NV054_CONTROL_ALPHAFUNC_NEVER                              (0x00000001)
#define NV054_CONTROL_ALPHAFUNC_LESS                               (0x00000002)
#define NV054_CONTROL_ALPHAFUNC_EQUAL                              (0x00000003)
#define NV054_CONTROL_ALPHAFUNC_LESSEQUAL                          (0x00000004)
#define NV054_CONTROL_ALPHAFUNC_GREATER                            (0x00000005)
#define NV054_CONTROL_ALPHAFUNC_NOTEQUAL                           (0x00000006)
#define NV054_CONTROL_ALPHAFUNC_GREATEREQUAL                       (0x00000007)
#define NV054_CONTROL_ALPHAFUNC_ALWAYS                             (0x00000008)
#define NV054_CONTROL_ALPHATESTENABLE                              12:12
#define NV054_CONTROL_ALPHATESTENABLE_FALSE                        (0x00000000)
#define NV054_CONTROL_ALPHATESTENABLE_TRUE                         (0x00000001)
#define NV054_CONTROL_ORIGIN                                       13:13
#define NV054_CONTROL_ORIGIN_CENTER                                (0x00000000)
#define NV054_CONTROL_ORIGIN_CORNER                                (0x00000001)
#define NV054_CONTROL_ZENABLE                                      15:14
#define NV054_CONTROL_ZENABLE_FALSE                                (0x00000000)
#define NV054_CONTROL_ZENABLE_TRUE                                 (0x00000001)
#define NV054_CONTROL_ZFUNC                                        19:16
#define NV054_CONTROL_ZFUNC_NEVER                                  (0x00000001)
#define NV054_CONTROL_ZFUNC_LESS                                   (0x00000002)
#define NV054_CONTROL_ZFUNC_EQUAL                                  (0x00000003)
#define NV054_CONTROL_ZFUNC_LESSEQUAL                              (0x00000004)
#define NV054_CONTROL_ZFUNC_GREATER                                (0x00000005)
#define NV054_CONTROL_ZFUNC_NOTEQUAL                               (0x00000006)
#define NV054_CONTROL_ZFUNC_GREATEREQUAL                           (0x00000007)
#define NV054_CONTROL_ZFUNC_ALWAYS                                 (0x00000008)
#define NV054_CONTROL_CULLMODE                                     21:20
#define NV054_CONTROL_CULLMODE_NONE                                (0x00000001)
#define NV054_CONTROL_CULLMODE_CW                                  (0x00000002)
#define NV054_CONTROL_CULLMODE_CCW                                 (0x00000003)
#define NV054_CONTROL_DITHERENABLE                                 22:22
#define NV054_CONTROL_DITHERENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_DITHERENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE                         23:23
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE                   (0x00000000)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE                    (0x00000001)
#define NV054_CONTROL_ZWRITEENABLE                                 29:24
#define NV054_CONTROL_ZWRITEENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_ZWRITEENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_FORMAT                                     31:30
#define NV054_CONTROL_Z_FORMAT_FIXED                               (0x00000001)
#define NV054_CONTROL_Z_FORMAT_FLOAT                               (0x00000002)
#define NV054_FOG_COLOR                                            (0x00000318)
#define NV054_TLVERTEX(i)                                          (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SX(i)                                       (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SY(i)                                       (0x00000404\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SZ(i)                                       (0x00000408\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_RHW(i)                                      (0x0000040C\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR(i)                                    (0x00000410\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR_BLUE                                  7:0
#define NV054_TLVERTEX_COLOR_GREEN                                 15:8
#define NV054_TLVERTEX_COLOR_RED                                   23:16
#define NV054_TLVERTEX_COLOR_ALPHA                                 31:24
#define NV054_TLVERTEX_SPECULAR(i)                                 (0x00000414\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SPECULAR_BLUE                               7:0
#define NV054_TLVERTEX_SPECULAR_GREEN                              15:8
#define NV054_TLVERTEX_SPECULAR_RED                                23:16
#define NV054_TLVERTEX_SPECULAR_FOG                                31:24
#define NV054_TLVERTEX_TU(i)                                       (0x00000418\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_TV(i)                                       (0x0000041C\
                                                                   +(i)*0x0020)
#define NV054_DRAW_PRIMITIVE(a)                                    (0x00000600\
                                                                   +(a)*0x0004)
#define NV054_DRAW_PRIMITIVE_I0                                    3:0
#define NV054_DRAW_PRIMITIVE_I1                                    7:4
#define NV054_DRAW_PRIMITIVE_I2                                    11:8
#define NV054_DRAW_PRIMITIVE_I3                                    15:12
#define NV054_DRAW_PRIMITIVE_I4                                    19:16
#define NV054_DRAW_PRIMITIVE_I5                                    31:20


/* class NV04_DX6_MULTI_TEXTURE_TRIANGLE */
#define  NV04_DX6_MULTI_TEXTURE_TRIANGLE                           (0x00000055)
#define  NV4_DX6_MULTI_TEXTURE_TRIANGLE                            (0x00000055)
/* NvNotification[] elements */
#define NV055_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV055_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV055_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV055_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV055_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV055_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV055_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV055_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaA;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaB;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0188-018b*/
 V032 SetContextSurfaces;      /* NV01_CONTEXT_SURFACES_ARGB_ZS     018c-018f*/
 V032 Reserved01[0x05e];
 U032 Offset[2];               /* offset in bytes                   0308-030f*/
 V032 Format[2];               /* see text                          0310-0317*/
 V032 Filter[2];               /* see text                          0318-031f*/
 V032 Combine0Alpha;           /* see text                          0320-0323*/
 V032 Combine0Color;           /* see text                          0324-0327*/
 V032 Reserved02[0x001];
 V032 Combine1Alpha;           /* see text                          032c-032f*/
 V032 Combine1Color;           /* see text                          0330-0333*/
 V032 CombineFactor;           /* A8R8G8B8                          0334-0337*/
 V032 Blend;                   /* see text                          0338-033b*/
 V032 Control0;                /* see text                          033c-033f*/
 V032 Control1;                /* see text                          0340-0343*/
 V032 Control2;                /* see text                          0344-0347*/
 V032 FogColor;                /* X8R8G8B8 fog color                0348-034b*/
 V032 Reserved03[0x02D];
 struct {                      /* start of method in array          0400-    */
  F032 sx;                     /* screen x coordinate                 00-  03*/
  F032 sy;                     /* screen y coordinate                 04-  07*/
  F032 sz;                     /* screen z coordinate                 08-  0b*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      0c-  0f*/
  V032 color;                  /* A8R8G8B8                            10-  13*/
  V032 specular;               /* F8R8G8B8                            14-  17*/
  F032 tu0;                    /* texture 0 u coordinate              18-  1b*/
  F032 tv0;                    /* texture 0 v coordinate              1c-  1f*/
  F032 tu1;                    /* texture 1 u coordinate              20-  23*/
  F032 tv1;                    /* texture 1 v coordinate              24-  27*/
 } Tlmtvertex[8];              /* end of method in array                -053f*/
 V032 DrawPrimitive[48];       /* see text                          0540-05ff*/
 V032 Reserved04[0x680];
} Nv055Typedef, Nv04Dx6MultiTextureTriangle;
#define Nv4Dx6MultiTextureTriangle                  Nv04Dx6MultiTextureTriangle
#define nv4Dx6MultiTextureTriangle                  nv04Dx6MultiTextureTriangle
#define NV055_TYPEDEF                               nv04Dx6MultiTextureTriangle
/* dma method offsets, fields, and values */
#define NV055_SET_OBJECT                                           (0x00000000)
#define NV055_NO_OPERATION                                         (0x00000100)
#define NV055_NOTIFY                                               (0x00000104)
#define NV055_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV055_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV055_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV055_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV055_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV055_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV055_OFFSET(b)                                            (0x00000308\
                                                                   +(b)*0x0004)
#define NV055_FORMAT(b)                                            (0x00000310\
                                                                   +(b)*0x0004)
#define NV055_FORMAT_CONTEXT_DMA                                   3:0
#define NV055_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV055_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV055_FORMAT_ORIGIN_ZOH                                    5:4
#define NV055_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV055_FORMAT_ORIGIN_FOH                                    7:6
#define NV055_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV055_FORMAT_COLOR                                         11:8
#define NV055_FORMAT_COLOR_LE_AY8                                  (0x00000001)
#define NV055_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV055_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV055_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV055_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV055_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV055_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV055_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV055_FORMAT_BASE_SIZE_U                                   19:16
#define NV055_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV055_FORMAT_BASE_SIZE_V                                   23:20
#define NV055_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV055_FORMAT_TEXTUREADDRESSU                               26:24
#define NV055_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPU                                         27:27
#define NV055_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV                               30:28
#define NV055_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPV                                         31:31
#define NV055_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV055_FILTER(b)                                            (0x00000318\
                                                                   +(b)*0x0004)
#define NV055_FILTER_KERNEL_SIZE_X                                 7:0
#define NV055_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV055_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV055_FILTER_MIPMAPLODBIAS                                 23:16
#define NV055_FILTER_TEXTUREMIN                                    26:24
#define NV055_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV055_FILTER_TEXTUREMAG                                    30:28
#define NV055_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV055_COMBINE_0_ALPHA                                      (0x00000320)
#define NV055_COMBINE_0_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_0_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_0_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_0_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_0_COLOR                                      (0x00000324)
#define NV055_COMBINE_0_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_0_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_0_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_0_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_0_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_0_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_0_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_0_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_OPERATION                            31:29
#define NV055_COMBINE_0_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_ALPHA                                      (0x0000032C)
#define NV055_COMBINE_1_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_1_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_1_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_1_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_1_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_COLOR                                      (0x00000330)
#define NV055_COMBINE_1_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_1_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_1_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_1_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_1_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_1_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_1_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_1_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_1_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_OPERATION                            31:29
#define NV055_COMBINE_1_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_FACTOR                                       (0x00000334)
#define NV055_COMBINE_FACTOR_BLUE                                  7:0
#define NV055_COMBINE_FACTOR_GREEN                                 15:8
#define NV055_COMBINE_FACTOR_RED                                   23:16
#define NV055_COMBINE_FACTOR_ALPHA                                 31:24
#define NV055_BLEND                                                (0x00000338)
#define NV055_BLEND_MASK_BIT                                       5:0
#define NV055_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV055_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV055_BLEND_SHADEMODE                                      7:6
#define NV055_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV055_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV055_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV055_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV055_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV055_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV055_BLEND_SPECULARENABLE                                 15:12
#define NV055_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV055_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV055_BLEND_FOGENABLE                                      19:16
#define NV055_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV055_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV055_BLEND_ALPHABLENDENABLE                               23:20
#define NV055_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV055_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV055_BLEND_SRCBLEND                                       27:24
#define NV055_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV055_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV055_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV055_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV055_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV055_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV055_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV055_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV055_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV055_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV055_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV055_BLEND_DESTBLEND                                      31:28
#define NV055_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV055_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV055_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV055_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV055_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV055_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV055_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV055_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV055_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV055_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV055_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV055_CONTROL0                                             (0x0000033C)
#define NV055_CONTROL0_ALPHAREF                                    7:0
#define NV055_CONTROL0_ALPHAFUNC                                   11:8
#define NV055_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV055_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV055_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV055_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV055_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV055_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV055_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV055_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV055_CONTROL0_ALPHATESTENABLE                             12:12
#define NV055_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV055_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV055_CONTROL0_ORIGIN                                      13:13
#define NV055_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV055_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV055_CONTROL0_ZENABLE                                     15:14
#define NV055_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV055_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV055_CONTROL0_ZFUNC                                       19:16
#define NV055_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV055_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV055_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV055_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV055_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV055_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV055_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV055_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV055_CONTROL0_CULLMODE                                    21:20
#define NV055_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV055_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV055_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV055_CONTROL0_DITHERENABLE                                22:22
#define NV055_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ZWRITEENABLE                                24:24
#define NV055_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV055_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV055_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV055_CONTROL0_Z_FORMAT                                    31:30
#define NV055_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV055_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV055_CONTROL1                                             (0x00000340)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC                                7:4
#define NV055_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV055_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV055_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV055_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV055_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV055_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV055_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV055_CONTROL1_STENCIL_REF                                 15:8
#define NV055_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV055_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV055_CONTROL2                                             (0x00000344)
#define NV055_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV055_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV055_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV055_FOG_COLOR                                            (0x00000348)
#define NV055_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV055_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV055_TLMTVERTEX_COLOR_RED                                 23:16
#define NV055_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV055_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV055_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV055_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV055_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV055_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV055_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV055_DRAW_PRIMITIVE_I0                                    3:0
#define NV055_DRAW_PRIMITIVE_I1                                    7:4
#define NV055_DRAW_PRIMITIVE_I2                                    11:8
#define NV055_DRAW_PRIMITIVE_I3                                    15:12
#define NV055_DRAW_PRIMITIVE_I4                                    19:16
#define NV055_DRAW_PRIMITIVE_I5                                    31:20

typedef V032 Nv056Typedef;


/* class NV04_CONTEXT_COLOR_KEY */
#define  NV04_CONTEXT_COLOR_KEY                                    (0x00000057)
#define  NV4_CONTEXT_COLOR_KEY                                     (0x00000057)
/* NvNotification[] elements */
#define NV057_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV057_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV057_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV057_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV057_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV057_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV057_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV057_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetColorFormat;          /* NV057_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColor;                /* source color                      0304-0307*/
 V032 Reserved02[0x73e];
} Nv057Typedef, Nv04ContextColorKey;
#define Nv4ContextColorKey                                  Nv04ContextColorKey
#define nv4ContextColorKey                                  nv04ContextColorKey
#define NV057_TYPEDEF                                       nv04ContextColorKey
/* dma method offsets, fields, and values */
#define NV057_SET_OBJECT                                           (0x00000000)
#define NV057_NO_OPERATION                                         (0x00000100)
#define NV057_NOTIFY                                               (0x00000104)
#define NV057_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV057_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV057_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV057_SET_COLOR_FORMAT                                     (0x00000300)
#define NV057_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV057_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV057_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV057_SET_COLOR                                            (0x00000304)


/* class NV03_CONTEXT_SURFACE_0 */
#define  NV03_CONTEXT_SURFACE_0                                    (0x00000058)
#define  NV3_CONTEXT_SURFACE_0                                     (0x00000058)
/* NvNotification[] elements */
#define NV058_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV058_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV058_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV058_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV058_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV058_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV058_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV058_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV058_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv058Typedef, Nv03ContextSurface0;
#define Nv3ContextSurface0                                  Nv03ContextSurface0
#define nv3ContextSurface0                                  nv03ContextSurface0
#define NV058_TYPEDEF                                       nv03ContextSurface0
/* dma method offsets, fields, and values */
#define NV058_SET_OBJECT                                           (0x00000000)
#define NV058_NO_OPERATION                                         (0x00000100)
#define NV058_NOTIFY                                               (0x00000104)
#define NV058_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV058_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV058_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV058_SET_COLOR_FORMAT                                     (0x00000300)
#define NV058_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV058_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV058_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV058_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV058_SET_IMAGE_PITCH                                      (0x00000308)
#define NV058_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_1 */
#define  NV03_CONTEXT_SURFACE_1                                    (0x00000059)
#define  NV3_CONTEXT_SURFACE_1                                     (0x00000059)
/* NvNotification[] elements */
#define NV059_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV059_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV059_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV059_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV059_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV059_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV059_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV059_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV059_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv059Typedef, Nv03ContextSurface1;
#define Nv3ContextSurface1                                  Nv03ContextSurface1
#define nv3ContextSurface1                                  nv03ContextSurface1
#define NV059_TYPEDEF                                       nv03ContextSurface1
/* dma method offsets, fields, and values */
#define NV059_SET_OBJECT                                           (0x00000000)
#define NV059_NO_OPERATION                                         (0x00000100)
#define NV059_NOTIFY                                               (0x00000104)
#define NV059_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV059_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV059_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV059_SET_COLOR_FORMAT                                     (0x00000300)
#define NV059_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV059_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV059_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV059_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV059_SET_IMAGE_PITCH                                      (0x00000308)
#define NV059_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_2 */
#define  NV03_CONTEXT_SURFACE_2                                    (0x0000005A)
#define  NV3_CONTEXT_SURFACE_2                                     (0x0000005A)
/* NvNotification[] elements */
#define NV05A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05A_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV05A_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv05aTypedef, Nv03ContextSurface2;
#define Nv3ContextSurface2                               Nv03ContextSurface2
#define nv3ContextSurface2                               nv03ContextSurface2
#define NV05A_TYPEDEF                                    nv03ContextSurface2
/* dma method offsets, fields, and values */
#define NV05A_SET_OBJECT                                           (0x00000000)
#define NV05A_NO_OPERATION                                         (0x00000100)
#define NV05A_NOTIFY                                               (0x00000104)
#define NV05A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05A_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05A_SET_COLOR_FORMAT_DUMMY_0                             (0x01010000)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_1              (0x01010001)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_2              (0x01000000)
#define NV05A_SET_COLOR_FORMAT_DUMMY_3                             (0x00000001)
#define NV05A_SET_IMAGE_PITCH                                      (0x00000308)
#define NV05A_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_3 */
#define  NV03_CONTEXT_SURFACE_3                                    (0x0000005B)
#define  NV3_CONTEXT_SURFACE_3                                     (0x0000005B)
/* NvNotification[] elements */
#define NV05B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV05B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv05bTypedef, Nv03ContextSurface3;
#define Nv3ContextSurface3                                  Nv03ContextSurface3
#define nv3ContextSurface3                                  nv03ContextSurface3
#define NV05B_TYPEDEF                                       nv03ContextSurface3
/* dma method offsets, fields, and values */
#define NV05B_SET_OBJECT                                           (0x00000000)
#define NV05B_NO_OPERATION                                         (0x00000100)
#define NV05B_NOTIFY                                               (0x00000104)
#define NV05B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05B_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05B_SET_COLOR_FORMAT_DUMMY_0                             (0x01010000)
#define NV05B_SET_COLOR_FORMAT_DUMMY_1                             (0x01010001)
#define NV05B_SET_COLOR_FORMAT_DUMMY_2                             (0x01000000)
#define NV05B_SET_COLOR_FORMAT_DUMMY_3                             (0x00000001)
#define NV05B_SET_IMAGE_PITCH                                      (0x00000308)
#define NV05B_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV04_RENDER_SOLID_LIN */
#define  NV04_RENDER_SOLID_LIN                                     (0x0000005C)
#define  NV4_RENDER_SOLID_LIN                                      (0x0000005C)
/* NvNotification[] elements */
#define NV05C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05C_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV05C_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV05C_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point0;                 /* y_x S16_S16 in pixels             0400-0403*/
  V032 point1;                 /* y_x S16_S16 in pixels             0404-0407*/
 } Lin[16];                    /* end of aliased methods in array       -047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 point0X;                /* in pixels, 0 at left                 0-   3*/
  S032 point0Y;                /* in pixels, 0 at top                  4-   7*/
  S032 point1X;                /* in pixels, 0 at left                 8-   b*/
  S032 point1Y;                /* in pixels, 0 at top                  c-   f*/
 } Lin32[8];                   /* end of aliased methods in array       -04ff*/
 V032 PolyLin[32];             /* y_x S16_S16 in pixels             0500-057f*/
 struct {                      /* start of method in array          0580-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } PolyLin32[16];              /* end of aliased methods in array       -05ff*/
 struct {                      /* start of aliased methods in array 0600-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point;                  /* y_x S16_S16 in pixels                4-   7*/
 } ColorPolyLin[16];           /* end of aliased methods in array       -067f*/
 V032 Reserved03[0x660];
} Nv05cTypedef, Nv04RenderSolidLin;
#define Nv4RenderSolidLin                                    Nv04RenderSolidLin
#define nv4RenderSolidLin                                    nv04RenderSolidLin
#define NV05C_TYPEDEF                                        nv04RenderSolidLin
/* dma method offsets, fields, and values */
#define NV05C_SET_OBJECT                                           (0x00000000)
#define NV05C_NO_OPERATION                                         (0x00000100)
#define NV05C_NOTIFY                                               (0x00000104)
#define NV05C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05C_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05C_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05C_SET_OPERATION                                        (0x000002FC)
#define NV05C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05C_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05C_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05C_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05C_COLOR                                                (0x00000304)
#define NV05C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0                                           (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0_X                                         15:0
#define NV05C_LIN_POINT0_Y                                         31:16
#define NV05C_LIN_POINT1                                           (0x00000404\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT1_X                                         15:0
#define NV05C_LIN_POINT1_Y                                         31:16
#define NV05C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_X                                       (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_Y                                       (0x00000484\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_X                                       (0x00000488\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_Y                                       (0x0000048C\
                                                                   +(a)*0x0010)
#define NV05C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV05C_POLY_LIN_X                                           15:0
#define NV05C_POLY_LIN_Y                                           31:16
#define NV05C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_X                                         (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_Y                                         (0x00000584\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_COLOR                                 (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT                                 (0x00000604\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV05C_COLOR_POLY_LIN_POINT_Y                               31:16


/* class NV04_RENDER_SOLID_TRIANGLE */
#define  NV04_RENDER_SOLID_TRIANGLE                                (0x0000005D)
#define  NV4_RENDER_SOLID_TRIANGLE                                 (0x0000005D)
/* NvNotification[] elements */
#define NV05D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05D_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV05D_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV05D_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x002];
 V032 TrianglePoint0;          /* y_x S16_S16 in pixels             0310-0313*/
 V032 TrianglePoint1;          /* y_x S16_S16 in pixels             0314-0317*/
 V032 TrianglePoint2;          /* y_x S16_S16 in pixels             0318-031b*/
 V032 Reserved03[0x001];
 S032 Triangle32Point0X;       /* in pixels, 0 at left              0320-0323*/
 S032 Triangle32Point0Y;       /* in pixels, 0 at top               0324-0327*/
 S032 Triangle32Point1X;       /* in pixels, 0 at left              0328-032b*/
 S032 Triangle32Point1Y;       /* in pixels, 0 at top               032c-032f*/
 S032 Triangle32Point2X;       /* in pixels, 0 at left              0330-0333*/
 S032 Triangle32Point2Y;       /* in pixels, 0 at top               0334-0337*/
 V032 Reserved04[0x032];
 V032 Trimesh[32];             /* y_x S16_S16 in pixels             0400-047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } Trimesh32[16];              /* end of aliased methods in array       -04ff*/
 struct {                      /* start of aliased methods in array 0500-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point0;                 /* y_x S16_S16 in pixels                4-   7*/
  V032 point1;                 /* y_x S16_S16 in pixels                8-   b*/
  V032 point2;                 /* y_x S16_S16 in pixels                c-   f*/
 } ColorTriangle[8];           /* end of aliased methods in array       -057f*/
 struct {                      /* start of aliased methods in array 0580-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point;                  /* y_x S16_S16 in pixels                4-   7*/
 } ColorTrimesh[16];           /* end of aliased methods in array       -05ff*/
 V032 Reserved05[0x680];
} Nv05dTypedef, Nv04RenderSolidTriangle;
#define Nv4RenderSolidTriangle                          Nv04RenderSolidTriangle
#define nv4RenderSolidTriangle                          nv04RenderSolidTriangle
#define NV05D_TYPEDEF                                   nv04RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV05D_SET_OBJECT                                           (0x00000000)
#define NV05D_NO_OPERATION                                         (0x00000100)
#define NV05D_NOTIFY                                               (0x00000104)
#define NV05D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05D_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05D_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05D_SET_OPERATION                                        (0x000002FC)
#define NV05D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05D_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05D_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05D_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05D_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05D_COLOR                                                (0x00000304)
#define NV05D_TRIANGLE                                             (0x00000310)
#define NV05D_TRIANGLE_POINT0                                      (0x00000310)
#define NV05D_TRIANGLE_POINT0_X                                    15:0
#define NV05D_TRIANGLE_POINT0_Y                                    31:16
#define NV05D_TRIANGLE_POINT1                                      (0x00000314)
#define NV05D_TRIANGLE_POINT1_X                                    15:0
#define NV05D_TRIANGLE_POINT1_Y                                    31:16
#define NV05D_TRIANGLE_POINT2                                      (0x00000318)
#define NV05D_TRIANGLE_POINT2_X                                    15:0
#define NV05D_TRIANGLE_POINT2_Y                                    31:16
#define NV05D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV05D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV05D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV05D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV05D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV05D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV05D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV05D_TRIMESH_X                                            15:0
#define NV05D_TRIMESH_Y                                            31:16
#define NV05D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV05D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT_X                                15:0
#define NV05D_COLOR_TRIMESH_POINT_Y                                31:16


/* class NV04_RENDER_SOLID_RECTANGLE */
#define  NV04_RENDER_SOLID_RECTANGLE                               (0x0000005E)
#define  NV4_RENDER_SOLID_RECTANGLE                                (0x0000005E)
/* NvNotification[] elements */
#define NV05E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05E_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV05E_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV05E_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* y_x S16_S16                          0-   3*/
  V032 size;                   /* height_width U16_U16                 4-   7*/
 } Rectangle[16];              /* end of aliased methods in array       -047f*/
 V032 Reserved03[0x6e0];
} Nv05eTypedef, Nv04RenderSolidRectangle;
#define Nv4RenderSolidRectangle                        Nv04RenderSolidRectangle
#define nv4RenderSolidRectangle                        nv04RenderSolidRectangle
#define NV05E_TYPEDEF                                  nv04RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV05E_SET_OBJECT                                           (0x00000000)
#define NV05E_NO_OPERATION                                         (0x00000100)
#define NV05E_NOTIFY                                               (0x00000104)
#define NV05E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05E_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05E_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05E_SET_OPERATION                                        (0x000002FC)
#define NV05E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05E_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05E_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05E_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05E_COLOR                                                (0x00000304)
#define NV05E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT_X                                    15:0
#define NV05E_RECTANGLE_POINT_Y                                    31:16
#define NV05E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV05E_RECTANGLE_SIZE_HEIGHT                                31:16


/* class NV04_IMAGE_BLIT */
#define  NV04_IMAGE_BLIT                                           (0x0000005F)
#define  NV4_IMAGE_BLIT                                            (0x0000005F)
/* NvNotification[] elements */
#define NV05F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05F_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0198-019b*/
 V032 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D          019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV05F_SET_OPERATION_*             02fc-02ff*/
 V032 ControlPointIn;          /* y_x U16_U16, pixels, top left src 0300-0303*/
 V032 ControlPointOut;         /* y_x S16_S16, pixels, top left dst 0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels    0308-030b*/
 V032 Reserved02[0x73d];
} Nv05fTypedef, Nv04ImageBlit;
#define Nv4ImageBlit                                              Nv04ImageBlit
#define nv4ImageBlit                                              nv04ImageBlit
#define NV05F_TYPEDEF                                             nv04ImageBlit
/* dma method offsets, fields, and values */
#define NV05F_SET_OBJECT                                           (0x00000000)
#define NV05F_NO_OPERATION                                         (0x00000100)
#define NV05F_NOTIFY                                               (0x00000104)
#define NV05F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV05F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV05F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV05F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV05F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV05F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV05F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV05F_SET_OPERATION                                        (0x000002FC)
#define NV05F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05F_CONTROL_POINT_IN                                     (0x00000300)
#define NV05F_CONTROL_POINT_IN_X                                   15:0
#define NV05F_CONTROL_POINT_IN_Y                                   31:16
#define NV05F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV05F_CONTROL_POINT_OUT_X                                  15:0
#define NV05F_CONTROL_POINT_OUT_Y                                  31:16
#define NV05F_SIZE                                                 (0x00000308)
#define NV05F_SIZE_WIDTH                                           15:0
#define NV05F_SIZE_HEIGHT                                          31:16


/* class NV04_INDEXED_IMAGE_FROM_CPU */
#define  NV04_INDEXED_IMAGE_FROM_CPU                               (0x00000060)
#define  NV4_INDEXED_IMAGE_FROM_CPU                                (0x00000060)
/* NvNotification[] elements */
#define NV060_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV060_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV060_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV060_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV060_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV060_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV060_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaLut;        /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0188-018b*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        018c-018f*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0190-0193*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0194-0197*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0198-019b*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 019c-019f*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLED 01a0-01a3*/
 V032 Reserved01[0x090];
 V032 SetOperation;            /* NV060_SET_OPERATION_*             03e4-03e7*/
 V032 SetColorFormat;          /* NV060_SET_COLOR_FORMAT_*          03e8-03eb*/
 V032 IndexFormat;             /* NV060_INDEX_FORMAT_*              03ec-03ef*/
 U032 LutOffset;               /* offset in bytes                   03f0-03f3*/
 V032 Point;                   /* y_x S16_S16 in pixels             03f4-03f7*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 03f8-03fb*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 03fc-03ff*/
 V032 Indices[1792];           /* source indices (packed texels)    0400-1fff*/
} Nv060Typedef, Nv04IndexedImageFromCpu;
#define Nv4IndexedImageFromCpu                          Nv04IndexedImageFromCpu
#define nv4IndexedImageFromCpu                          nv04IndexedImageFromCpu
#define NV060_TYPEDEF                                   nv04IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV060_SET_OBJECT                                           (0x00000000)
#define NV060_NO_OPERATION                                         (0x00000100)
#define NV060_NOTIFY                                               (0x00000104)
#define NV060_NOTIFY_WRITE_ONLY                                   (0x00000000)
#define NV060_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV060_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV060_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV060_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV060_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV060_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV060_SET_CONTEXT_ROP                                      (0x00000194)
#define NV060_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV060_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV060_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV060_SET_OPERATION                                        (0x000003E4)
#define NV060_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV060_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV060_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV060_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV060_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV060_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV060_INDEX_FORMAT                                         (0x000003EC)
#define NV060_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV060_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV060_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV060_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV060_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV060_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV060_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV060_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV060_LUT_OFFSET                                           (0x000003F0)
#define NV060_POINT                                                (0x000003F4)
#define NV060_POINT_X                                              15:0
#define NV060_POINT_Y                                              31:16
#define NV060_SIZE_OUT                                             (0x000003F8)
#define NV060_SIZE_OUT_WIDTH                                       15:0
#define NV060_SIZE_OUT_HEIGHT                                      31:16
#define NV060_SIZE_IN                                              (0x000003FC)
#define NV060_SIZE_IN_WIDTH                                        15:0
#define NV060_SIZE_IN_HEIGHT                                       31:16
#define NV060_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)


/* class NV04_IMAGE_FROM_CPU */
#define  NV04_IMAGE_FROM_CPU                                       (0x00000061)
#define  NV4_IMAGE_FROM_CPU                                        (0x00000061)
/* NvNotification[] elements */
#define NV061_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV061_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV061_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV061_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV061_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV061_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV061_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0198-019b*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV061_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV061_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels             0304-0307*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 030c-030f*/
 V032 Reserved02[0x03c];
 V032 Color[1792];             /* source colors (packed texels)     0400-1fff*/
} Nv061Typedef, Nv04ImageFromCpu;
#define Nv4ImageFromCpu                                        Nv04ImageFromCpu
#define nv4ImageFromCpu                                        nv04ImageFromCpu
#define NV061_TYPEDEF                                          nv04ImageFromCpu
/* dma method offsets, fields, and values */
#define NV061_SET_OBJECT                                           (0x00000000)
#define NV061_NO_OPERATION                                         (0x00000100)
#define NV061_NOTIFY                                               (0x00000104)
#define NV061_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV061_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV061_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV061_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV061_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV061_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV061_SET_CONTEXT_ROP                                      (0x00000190)
#define NV061_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV061_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV061_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV061_SET_OPERATION                                        (0x000002FC)
#define NV061_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV061_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV061_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV061_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV061_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV061_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV061_SET_COLOR_FORMAT                                     (0x00000300)
#define NV061_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV061_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV061_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV061_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV061_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV061_POINT                                                (0x00000304)
#define NV061_POINT_X                                              15:0
#define NV061_POINT_Y                                              31:16
#define NV061_SIZE_OUT                                             (0x00000308)
#define NV061_SIZE_OUT_WIDTH                                       15:0
#define NV061_SIZE_OUT_HEIGHT                                      31:16
#define NV061_SIZE_IN                                              (0x0000030C)
#define NV061_SIZE_IN_WIDTH                                        15:0
#define NV061_SIZE_IN_HEIGHT                                       31:16
#define NV061_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)

typedef V032 Nv062Typedef;


/* class NV05_SCALED_IMAGE_FROM_MEMORY */
#define  NV05_SCALED_IMAGE_FROM_MEMORY                             (0x00000063)
/* NvNotification[] elements */
#define NV063_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV063_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV063_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV063_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV063_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV063_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV063_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV063_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x059];
 NvV32 SetColorFormat;          /* NV063_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV063_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 SetColorConversion;      /* NV064_SET_COLOR_CONVERSION_*     0320-0323*/
 NvV32 Reserved02[0x037];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv063Typedef, Nv05ScaledImageFromMemory;
#define NV063_TYPEDEF                                 nv05ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV063_SET_OBJECT                                           (0x00000000)
#define NV063_NO_OPERATION                                         (0x00000100)
#define NV063_NOTIFY                                               (0x00000104)
#define NV063_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV063_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV063_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV063_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV063_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV063_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV063_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV063_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV063_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV063_SET_COLOR_FORMAT                                     (0x00000300)
#define NV063_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV063_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV063_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV063_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV063_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV063_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV063_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV063_SET_OPERATION                                        (0x00000304)
#define NV063_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV063_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV063_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV063_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV063_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV063_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV063_CLIP_POINT                                           (0x00000308)
#define NV063_CLIP_POINT_X                                         15:0
#define NV063_CLIP_POINT_Y                                         31:16
#define NV063_CLIP_SIZE                                            (0x0000030C)
#define NV063_CLIP_SIZE_WIDTH                                      15:0
#define NV063_CLIP_SIZE_HEIGHT                                     31:16
#define NV063_IMAGE_OUT_POINT                                      (0x00000310)
#define NV063_IMAGE_OUT_POINT_X                                    15:0
#define NV063_IMAGE_OUT_POINT_Y                                    31:16
#define NV063_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV063_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV063_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV063_DS_DX                                                (0x00000318)
#define NV063_DT_DY                                                (0x0000031C)
#define NV063_SET_COLOR_CONVERSION                                 (0x00000320)
#define NV063_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV063_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV063_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV063_IMAGE_IN_SIZE                                        (0x00000400)
#define NV063_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV063_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV063_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV063_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV063_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV063_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV063_IMAGE_IN                                             (0x0000040C)
#define NV063_IMAGE_IN_POINT_U                                     15:0
#define NV063_IMAGE_IN_POINT_V                                     31:16

/* class NV05_INDEXED_IMAGE_FROM_CPU */
#define  NV05_INDEXED_IMAGE_FROM_CPU                               (0x00000064)
#define NV064_NOTIFIERS_NOTIFY                                     (0)
#define NV064_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV064_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV064_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV064_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV064_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV064_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0188-018b*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      018c-018f*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0190-0193*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0194-0197*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                019c-019f*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 01a0-01a3*/
 NvV32 Reserved01[0x08f];
 NvV32 SetColorConversion;      /* NV064_SET_COLOR_CONVERSION_*     03e0-03e3*/
 NvV32 SetOperation;            /* NV064_SET_OPERATION_*            03e4-03e7*/
 NvV32 SetColorFormat;          /* NV064_SET_COLOR_FORMAT_*         03e8-03eb*/
 NvV32 IndexFormat;             /* NV064_INDEX_FORMAT_*             03ec-03ef*/
 NvU32 LutOffset;               /* offset in bytes                  03f0-03f3*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            03f4-03f7*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     03f8-03fb*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     03fc-03ff*/
 NvV32 Indices[1792];           /* source indices (packed texels)   0400-1fff*/
} Nv064Typedef, Nv05IndexedImageFromCpu;
#define NV064_TYPEDEF                                   nv05IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV064_NO_OPERATION                                         (0x00000100)
#define NV064_NOTIFY                                               (0x00000104)
#define NV064_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV064_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV064_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV064_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV064_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV064_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV064_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV064_SET_CONTEXT_ROP                                      (0x00000194)
#define NV064_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV064_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV064_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV064_SET_COLOR_CONVERSION                                 (0x000003E0)
#define NV064_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV064_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV064_SET_OPERATION                                        (0x000003E4)
#define NV064_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV064_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV064_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV064_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV064_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV064_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV064_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV064_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV064_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV064_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV064_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV064_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV064_INDEX_FORMAT                                         (0x000003EC)
#define NV064_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV064_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV064_LUT_OFFSET                                           (0x000003F0)
#define NV064_POINT                                                (0x000003F4)
#define NV064_POINT_X                                              15:0
#define NV064_POINT_Y                                              31:16
#define NV064_SIZE_OUT                                             (0x000003F8)
#define NV064_SIZE_OUT_WIDTH                                       15:0
#define NV064_SIZE_OUT_HEIGHT                                      31:16
#define NV064_SIZE_IN                                              (0x000003FC)
#define NV064_SIZE_IN_WIDTH                                        15:0
#define NV064_SIZE_IN_HEIGHT                                       31:16
#define NV064_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
/* class NV05_IMAGE_FROM_CPU */
#define  NV05_IMAGE_FROM_CPU                                       (0x00000065)
#define NV065_NOTIFIERS_NOTIFY                                     (0)
#define NV065_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV065_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV065_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV065_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV065_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV065_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x056];
 NvV32 SetColorConversion;      /* NV065_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV065_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV065_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv065Typedef, Nv05ImageFromCpu;
#define NV065_TYPEDEF                                          nv05ImageFromCpu
/* dma method offsets, fields, and values */
#define NV065_NO_OPERATION                                         (0x00000100)
#define NV065_NOTIFY                                               (0x00000104)
#define NV065_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV065_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV065_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV065_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV065_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV065_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV065_SET_CONTEXT_ROP                                      (0x00000190)
#define NV065_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV065_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV065_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV065_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV065_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV065_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV065_SET_OPERATION                                        (0x000002FC)
#define NV065_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV065_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV065_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV065_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV065_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV065_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV065_SET_COLOR_FORMAT                                     (0x00000300)
#define NV065_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV065_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV065_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV065_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV065_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV065_POINT                                                (0x00000304)
#define NV065_POINT_X                                              15:0
#define NV065_POINT_Y                                              31:16
#define NV065_SIZE_OUT                                             (0x00000308)
#define NV065_SIZE_OUT_WIDTH                                       15:0
#define NV065_SIZE_OUT_HEIGHT                                      31:16
#define NV065_SIZE_IN                                              (0x0000030C)
#define NV065_SIZE_IN_WIDTH                                        15:0
#define NV065_SIZE_IN_HEIGHT                                       31:16
#define NV065_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
 /* class NV05_STRETCHED_IMAGE_FROM_CPU */
#define  NV05_STRETCHED_IMAGE_FROM_CPU                             (0x00000066)
#define NV066_NOTIFIERS_NOTIFY                                     (0)
#define NV066_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV066_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV066_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV066_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV066_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV066_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetColorConversion;      /* NV066_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV066_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV066_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DxDs;                    /* S12d20 dx/ds                     0308-030b*/
 NvV32 DyDt;                    /* S12d20 dy/dt                     030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv066Typedef, Nv05StretchedImageFromCpu;
#define NV066_TYPEDEF                                 nv05StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV066_NO_OPERATION                                         (0x00000100)
#define NV066_NOTIFY                                               (0x00000104)
#define NV066_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV066_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV066_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV066_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV066_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV066_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV066_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV066_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV066_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV066_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV066_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV066_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV066_SET_OPERATION                                        (0x000002FC)
#define NV066_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV066_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV066_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV066_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV066_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV066_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV066_SET_COLOR_FORMAT                                     (0x00000300)
#define NV066_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV066_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV066_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV066_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV066_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV066_SIZE_IN                                              (0x00000304)
#define NV066_SIZE_IN_WIDTH                                        15:0
#define NV066_SIZE_IN_HEIGHT                                       31:16
#define NV066_DX_DS                                                (0x00000308)
#define NV066_DY_DT                                                (0x0000030C)
#define NV066_CLIP_POINT                                           (0x00000310)
#define NV066_CLIP_POINT_X                                         15:0
#define NV066_CLIP_POINT_Y                                         31:16
#define NV066_CLIP_SIZE                                            (0x00000314)
#define NV066_CLIP_SIZE_WIDTH                                      15:0
#define NV066_CLIP_SIZE_HEIGHT                                     31:16
#define NV066_POINT_12D4                                           (0x00000318)
#define NV066_POINT_12D4_X                                         15:0
#define NV066_POINT_12D4_Y                                         31:16
#define NV066_COLOR(a)                                             (0x00000400\


typedef V032 Nv067Typedef;

typedef V032 Nv06dTypedef;

typedef V032 Nv06eTypedef;

typedef V032 Nv06fTypedef;

typedef V032 Nv070Typedef;

typedef V032 Nv071Typedef;


/* class NV04_CONTEXT_BETA */
#define  NV04_CONTEXT_BETA                                         (0x00000072)
#define  NV4_CONTEXT_BETA                                          (0x00000072)
/* NvNotification[] elements */
#define NV072_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV072_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV072_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV072_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV072_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV072_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV072_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV072_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetBetaFactor;           /* A8R8G8B8 beta values              0300-0303*/
 V032 Reserved02[0x73f];
} Nv072Typedef, Nv04ContextBeta;
#define Nv4ContextBeta                                          Nv04ContextBeta
#define nv4ContextBeta                                          nv04ContextBeta
#define NV072_TYPEDEF                                           nv04ContextBeta
/* dma method offsets, fields, and values */
#define NV072_SET_OBJECT                                           (0x00000000)
#define NV072_NO_OPERATION                                         (0x00000100)
#define NV072_NOTIFY                                               (0x00000104)
#define NV072_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV072_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV072_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV072_SET_BETA_FACTOR                                      (0x00000300)
#define NV072_SET_BETA_FACTOR_BLUE                                 7:0
#define NV072_SET_BETA_FACTOR_GREEN                                15:8
#define NV072_SET_BETA_FACTOR_RED                                  23:16
#define NV072_SET_BETA_FACTOR_ALPHA                                31:24

typedef V032 Nv073Typedef;

typedef V032 Nv074Typedef;

typedef V032 Nv075Typedef;


/* class NV04_STRETCHED_IMAGE_FROM_CPU */
#define  NV04_STRETCHED_IMAGE_FROM_CPU                             (0x00000076)
#define  NV4_STRETCHED_IMAGE_FROM_CPU                              (0x00000076)
/* NvNotification[] elements */
#define NV076_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV076_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV076_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV076_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV076_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV076_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV076_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV076_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV076_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SizeIn;                  /* height_width U16_U16 in texels    0304-0307*/
 V032 DeltaDxDu;               /* S12d20 ratio dx/du                0308-030b*/
 V032 DeltaDyDv;               /* S12d20 ratio dy/dv                030c-030f*/
 V032 ClipPoint;               /* y_x S16_S16                       0310-0313*/
 V032 ClipSize;                /* height_width U16_U16              0314-0317*/
 V032 Point12d4;               /* y_x S12d4_S12d4 in pixels         0318-031b*/
 V032 Reserved02[0x039];
 V032 Color[1792];             /* source colors (packed texels)     0400-1fff*/
} Nv076Typedef, Nv04StretchedImageFromCpu;
#define Nv4StretchedImageFromCpu                      Nv04StretchedImageFromCpu
#define nv4StretchedImageFromCpu                      nv04StretchedImageFromCpu
#define NV076_TYPEDEF                                 nv04StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV076_SET_OBJECT                                           (0x00000000)
#define NV076_NO_OPERATION                                         (0x00000100)
#define NV076_NOTIFY                                               (0x00000104)
#define NV076_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV076_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV076_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV076_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV076_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV076_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV076_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV076_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV076_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV076_SET_OPERATION                                        (0x000002FC)
#define NV076_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV076_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV076_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV076_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV076_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV076_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV076_SET_COLOR_FORMAT                                     (0x00000300)
#define NV076_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV076_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV076_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV076_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV076_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV076_SIZE_IN                                              (0x00000304)
#define NV076_SIZE_IN_WIDTH                                        15:0
#define NV076_SIZE_IN_HEIGHT                                       31:16
#define NV076_DELTA_DX_DU                                          (0x00000308)
#define NV076_DELTA_DY_DV                                          (0x0000030C)
#define NV076_CLIP_POINT                                           (0x00000310)
#define NV076_CLIP_POINT_X                                         15:0
#define NV076_CLIP_POINT_Y                                         31:16
#define NV076_CLIP_SIZE                                            (0x00000314)
#define NV076_CLIP_SIZE_WIDTH                                      15:0
#define NV076_CLIP_SIZE_HEIGHT                                     31:16
#define NV076_POINT_12D4                                           (0x00000318)
#define NV076_POINT_12D4_X                                         15:0
#define NV076_POINT_12D4_Y                                         31:16
#define NV076_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV04_SCALED_IMAGE_FROM_MEMORY */
#define  NV04_SCALED_IMAGE_FROM_MEMORY                             (0x00000077)
#define  NV4_SCALED_IMAGE_FROM_MEMORY                              (0x00000077)
/* NvNotification[] elements */
#define NV077_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV077_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV077_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV077_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV077_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV077_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV077_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLED 0198-019b*/
 V032 Reserved01[0x059];
 V032 SetColorFormat;          /* NV077_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetOperation;            /* NV077_SET_OPERATION_*             0304-0307*/
 V032 ClipPoint;               /* y_x S16_S16                       0308-030b*/
 V032 ClipSize;                /* height_width U16_U16              030c-030f*/
 V032 ImageOutPoint;           /* y_x S16_S16                       0310-0313*/
 V032 ImageOutSize;            /* height_width U16_U16              0314-0317*/
 V032 DeltaDuDx;               /* S12d20 ratio du/dx                0318-031b*/
 V032 DeltaDvDy;               /* S12d20 ratio dv/dy                031c-031f*/
 V032 Reserved02[0x038];
 V032 ImageInSize;             /* height_width U16_U16              0400-0403*/
 U032 ImageInFormat;           /* interpolator_origin_pitch         0404-0407*/
 U032 ImageInOffset;           /* bytes                             0408-040b*/
 V032 ImageInPoint;            /* v_u U12d4_U12d4                   040c-040f*/
 V032 Reserved03[0x6fc];
} Nv077Typedef, Nv04ScaledImageFromMemory;
#define Nv4ScaledImageFromMemory                      Nv04ScaledImageFromMemory
#define nv4ScaledImageFromMemory                      nv04ScaledImageFromMemory
#define NV077_TYPEDEF                                 nv04ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV077_SET_OBJECT                                           (0x00000000)
#define NV077_NO_OPERATION                                         (0x00000100)
#define NV077_NOTIFY                                               (0x00000104)
#define NV077_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV077_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV077_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV077_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV077_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV077_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV077_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV077_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV077_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV077_SET_COLOR_FORMAT                                     (0x00000300)
#define NV077_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV077_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV077_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV077_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV077_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV077_SET_OPERATION                                        (0x00000304)
#define NV077_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV077_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV077_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV077_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV077_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV077_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV077_CLIP_POINT                                           (0x00000308)
#define NV077_CLIP_POINT_X                                         15:0
#define NV077_CLIP_POINT_Y                                         31:16
#define NV077_CLIP_SIZE                                            (0x0000030C)
#define NV077_CLIP_SIZE_WIDTH                                      15:0
#define NV077_CLIP_SIZE_HEIGHT                                     31:16
#define NV077_IMAGE_OUT_POINT                                      (0x00000310)
#define NV077_IMAGE_OUT_POINT_X                                    15:0
#define NV077_IMAGE_OUT_POINT_Y                                    31:16
#define NV077_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV077_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV077_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV077_DELTA_DU_DX                                          (0x00000318)
#define NV077_DELTA_DV_DY                                          (0x0000031C)
#define NV077_IMAGE_IN_SIZE                                        (0x00000400)
#define NV077_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV077_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV077_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV077_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV077_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV077_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV077_IMAGE_IN                                             (0x0000040C)
#define NV077_IMAGE_IN_POINT_U                                     15:0
#define NV077_IMAGE_IN_POINT_V                                     31:16

typedef V032 Nv078Typedef;

typedef V032 Nv079Typedef;

typedef V032 Nv07aTypedef;

typedef V032 Nv07bTypedef;

typedef V032 Nv07cTypedef;

typedef V032 Nv07dTypedef;

typedef V032 Nv07eTypedef;

typedef V032 Nv07fTypedef;


/* class NV01_DEVICE_0 */
#define  NV01_DEVICE_0                                             (0x00000080)
/* NvNotification[] fields and values */
#define NV080_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv080Typedef, Nv01Device0;
#define  NV080_TYPEDEF                                             nv01Device0


/* class NV01_DEVICE_1 */
#define  NV01_DEVICE_1                                             (0x00000081)
/* NvNotification[] fields and values */
#define NV081_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv081Typedef, Nv01Device1;
#define  NV081_TYPEDEF                                             nv01Device1


/* class NV01_DEVICE_2 */
#define  NV01_DEVICE_2                                             (0x00000082)
/* NvNotification[] fields and values */
#define NV082_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv082Typedef, Nv01Device2;
#define  NV082_TYPEDEF                                             nv01Device2


/* class NV01_DEVICE_3 */
#define  NV01_DEVICE_3                                             (0x00000083)
/* NvNotification[] fields and values */
#define NV083_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv083Typedef, Nv01Device3;
#define  NV083_TYPEDEF                                             nv01Device3


/* class NV01_DEVICE_4 */
#define  NV01_DEVICE_4                                             (0x00000084)
/* NvNotification[] fields and values */
#define NV084_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv084Typedef, Nv01Device4;
#define  NV084_TYPEDEF                                             nv01Device4


/* class NV01_DEVICE_5 */
#define  NV01_DEVICE_5                                             (0x00000085)
/* NvNotification[] fields and values */
#define NV085_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv085Typedef, Nv01Device5;
#define  NV085_TYPEDEF                                             nv01Device5


/* class NV01_DEVICE_6 */
#define  NV01_DEVICE_6                                             (0x00000086)
/* NvNotification[] fields and values */
#define NV086_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv086Typedef, Nv01Device6;
#define  NV086_TYPEDEF                                             nv01Device6


/* class NV01_DEVICE_7 */
#define  NV01_DEVICE_7                                             (0x00000087)
/* NvNotification[] fields and values */
#define NV087_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv087Typedef, Nv01Device7;
#define  NV087_TYPEDEF                                             nv01Device7



 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

typedef V032 Nv068Typedef;

typedef V032 Nv069Typedef;


/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                          (0x0000006A)
#define  NV3_CHANNEL_PIO                                           (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 V032 Reserved00[0x003];
 U016 Free;                    /* free count, read only             0010-0011*/
 U016 Zero[3];                 /* zeroes, read only                 0012-0017*/
 V032 Reserved01[0x03A];
} Nv03ControlPio;
#define Nv3ControlPio                                    Nv03ControlPio
typedef volatile struct {
 V032 SetObject;               /* handle of current object          0000-0003*/
 Nv03ControlPio control;       /* flow control                      0000-00ff*/
 union {                       /* start of class methods            0100-    */
  NvClass                       nvClass;
  NvContextDmaFromMemory        contextDmaFromMemory;
  NvContextDmaToMemory          contextDmaToMemory;
  NvContextDmaInMemory          contextDmaInMemory;
  NvPatchcordVideo              patchcordVideo;
  NvVideoSink                   videoSink;
  NvVideoColormap               videoColormap;
  NvVideoFromMemory             videoFromMemory;
  NvVideoScaler                 videoScaler;
  NvVideoColorKey               videoColorKey;
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv056Typedef NV056_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
  Nv06dTypedef NV06D_TYPEDEF;
  Nv06eTypedef NV06E_TYPEDEF;
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
 } /* cls */;                  /* end of class methods                  -1fff*/
} Nv03SubchannelPio;
#define Nv3SubchannelPio                                 Nv03SubchannelPio
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
#define Nv3ChannelPio                                            Nv03ChannelPio
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                                 (0x007C)
#define NV06A_FIFO_EMPTY                                           (0x007C)


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                          (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define  NV06B_TYPEDEF                                           nv03ChannelDma


/* class NV04_CHANNEL_DMA */
#define  NV04_CHANNEL_DMA                                          (0x0000006C)
#define  NV4_CHANNEL_DMA                                           (0x0000006C)
/* NvNotification[] fields and values */
#define NV06C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv06cTypedef, Nv04ChannelDma;
#define  Nv4ChannelDma                                           Nv04ChannelDma
#define  nv4ChannelDma                                           nv04ChannelDma
#define  NV06C_TYPEDEF                                           nv04ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 V032 reserved00[0x010];
 U032 Put;                     /* put offset, write only            0040-0043*/
 U032 Get;                     /* get offset, read only             0044-0047*/
 V032 reserved01[0x7EE];
} Nv04ControlDma;
#define  Nv4ControlDma                                           Nv04ControlDma



 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                                         (0x00000000)
#define   NV1_NULL_OBJECT                                          (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an 
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS. 
 * NV fills in the NvNotification[] data structure in the following order: 
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  U032 nanoseconds[2];         /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 V032 info32;                  /* info returned depends on method   0008-000b*/
 V016 info16;                  /* info returned depends on method   000c-000d*/
 V016 status;                  /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */



#ifdef __cplusplus
};
#endif
#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\TVOUT.H ===
#ifndef _TVOUT_H_
#define _TVOUT_H_
//
// the follow file defines the VIDEO_PARAMETER structure and calling parameters
// change to the ChangeDisplaySettingEx() Win32 API. 
//
// The audience for this file are Win32 developers who want to call
// ChangeDisplaySettingEx with the CDS_VIDEOPARAMETERS flag set, and
// display driver developers who want to implement the VIDEO_PARAMETERS 
// escape in their Control() function.

// Display driver Escape value to get/set the parameters.
//
#define VIDEO_PARAMETERS        3077    // escape value used in Control()

// Flags for ChangeDisplaySettings 
// these must match the flags in WINUSER.H 

#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004
#define CDS_GLOBAL          0x00000008
#define CDS_SET_PRIMARY     0x00000010
#define CDS_VIDEOPARAMETERS 0x00000020

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4
#define DISP_CHANGE_BADPARAM        -5
#define DISP_CHANGE_BADESC          -6

// the GUID for this structure is:
//    {02C62061-1097-11d1-920F-00A024DF156E}
// or  static const GUID <<name>> = { 0x2c62061, 0x1097, 0x11d1, { 0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e } };
// or DEFINE_GUID(<<name>>,           0x2c62061, 0x1097, 0x11d1,   0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e);

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16 // same as winnt.h
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;
#endif

typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         // GUID for this structure
    DWORD dwOffset;                     // leave it 0 for now.
    DWORD dwCommand;                    // VP_COMMAND_*            SET or GET
    DWORD dwFlags;                      // bitfield, defined below SET or GET
    DWORD dwMode;                       // bitfield, defined below SET or GET
    DWORD dwTVStandard;                 // bitfield, defined below SET or GET
    DWORD dwAvailableModes;             // bitfield, defined below GET
    DWORD dwAvailableTVStandard;        // bitfield, defined below GET
    DWORD dwFlickerFilter;              // value                   SET or GET
    DWORD dwOverScanX;                  // value                   SET or GET
    DWORD dwOverScanY;                  //                         SET or GET
    DWORD dwMaxUnscaledX;               // value                   SET or GET
    DWORD dwMaxUnscaledY;               //                         SET or GET
    DWORD dwPositionX;                  // value                   SET or GET
    DWORD dwPositionY;                  //                         SET or GET
    DWORD dwBrightness;                 // value                   SET or GET
    DWORD dwContrast;                   // value                   SET or GET
    DWORD dwCPType;                     // copy protection type    SET or GET
    DWORD dwCPCommand;                  // VP_CP_CMD_
    DWORD dwCPStandard;                 // what TV standards CP is available on. GET
    DWORD dwCPKey;
    DWORD bCP_APSTriggerBits;           // (a dword for alignment) SET(bits 0 and 1 valid).
    BYTE  bOEMCopyProtection[256];      // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, FAR *LPVIDEOPARAMETERS;

#define VP_COMMAND_GET          0x0001  // size set, return caps.
                                        // returned Flags = 0 if not supported.
#define VP_COMMAND_SET          0x0002  // size and params set.

#define VP_FLAGS_TV_MODE        0x0001
#define VP_FLAGS_TV_STANDARD    0x0002
#define VP_FLAGS_FLICKER        0x0004
#define VP_FLAGS_OVERSCAN       0x0008
#define VP_FLAGS_MAX_UNSCALED   0x0010  // do not use on SET
#define VP_FLAGS_POSITION       0x0020
#define VP_FLAGS_BRIGHTNESS     0x0040
#define VP_FLAGS_CONTRAST       0x0080
#define VP_FLAGS_COPYPROTECT    0x0100

#define VP_MODE_WIN_GRAPHICS    0x0001
#define VP_MODE_TV_PLAYBACK     0x0002  // optimize for TV video playback

#define VP_TV_STANDARD_NTSC_M   0x0001  //        75 IRE Setup
#define VP_TV_STANDARD_NTSC_M_J 0x0002  // Japan,  0 IRE Setup
#define VP_TV_STANDARD_PAL_B    0x0004  // Europe, SE Asia, Pacific, Middle East, Africa (25 lines/frame, 50 fields/s & 4.43361875 MHz)
#define VP_TV_STANDARD_PAL_D    0x0008  // Warsaw Pact & China (also PAL K) Same as PAL B, different audio carrier
#define VP_TV_STANDARD_PAL_H    0x0010  // Belgium, Gibralter, Liberia & Malta - UHF standard, PAL B for VHF
#define VP_TV_STANDARD_PAL_I    0x0020  // UK, Ireland, Hong Kong, S. Africa - Same as PAL B but different audio carrier 
#define VP_TV_STANDARD_PAL_M    0x0040  // Brazil - NTSC rates, PAL encoding (525 lines/frame, 60 fields/s, & 3.57671149 MHz) 
#define VP_TV_STANDARD_PAL_N    0x0080  // Argentina - Similar to PAL B but lower audio & color carrier
#define VP_TV_STANDARD_SECAM_B  0x0100  
#define VP_TV_STANDARD_SECAM_D  0x0200
#define VP_TV_STANDARD_SECAM_G  0x0400
#define VP_TV_STANDARD_SECAM_H  0x0800
#define VP_TV_STANDARD_SECAM_K  0x1000
#define VP_TV_STANDARD_SECAM_K1 0x2000
#define VP_TV_STANDARD_SECAM_L  0x4000
#define VP_TV_STANDARD_WIN_VGA  0x8000
// and the rest
#define VP_TV_STANDARD_NTSC_433 0x00010000  
#define VP_TV_STANDARD_PAL_G    0x00020000
#define VP_TV_STANDARD_PAL_60   0x00040000
#define VP_TV_STANDARD_SECAM_L1 0x00080000

#define VP_CP_TYPE_APS_TRIGGER  0x0001  // DVD trigger bits only
#define VP_CP_TYPE_MACROVISION  0x0002  // full macrovision data available

#define VP_CP_CMD_ACTIVATE      0x0001  // CP command type
#define VP_CP_CMD_DEACTIVATE    0x0002
#define VP_CP_CMD_CHANGE        0x0004
    

typedef struct _MACROVISION {
    WORD    wVersion;
    WORD    wFlags;
    BYTE    bCPCData;
    BYTE    bCPSData[34];
} MACROVISION, *PMACROVISION, FAR *LPMACROVISION;

#define MV_FLAGS_CPC_ONLY   0x0001
#define MV_FLAGS_CPS_ONLY   0x0002      // dont know if this is valid or not.
#define MV_FLAGS_CPC_CPS    0x0004      // both 8 bit and 132 bits are def'ed.

#endif  // _TVOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\nvntd3d.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997 SGS-THOMSON Microelectronics  All Rights Reserved.
 *
 *  File:       nvd3ddrv.c
 *  Content:    master D3D include file - OS specific includes
 *
 ***************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Type redefs excluded from dx95type.h.
//
#pragma warning(disable:4005)

#if (DIRECT3D_VERSION >= 0x0800)

#define D3DERR_TEXTURE_CREATE_FAILED MAKE_DDHRESULT(721)
#define D3DRS_EXTENTS 138

/*
 * This DDPF flag is used to indicate a DX8+ format capability entry in
 * the texture format list. It is not visible to applications.
 */
#define DDPF_D3DFORMAT                                          0x00200000l

/*
 * List of operations supported on formats in DX8+ texture list.
 * See the DX8 DDK for a complete description of these flags.
 */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_BACKBUFFER                 0x00000020L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

// D3DFORMAT_OP_D3DFMT_D16_LOCKABLE
// --------------------------------
//
// This flag is only valid on a format op list entry for D3DFMT_D16.
// This flag implies that the format is true 16 bit unsigned integer.
// This flag implies that the contents of a Z buffer of this format
// are persistent:
//  - The contents of the Z buffer will be the same from
//    the last EndScene (SceneCapture) to the next BeginScene.
//  - The contents of the Z buffer are not lost if the Z buffer
//    is attached to a different render target (until rendering takes
//    place, of course).
// This flag implies that data can be copied from one such surface
// to another (vidmem to vidmem, no stretch) via the Blt DDI.
#define D3DFORMAT_OP_D3DFMT_D16_LOCKABLE        0x00000200L

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * an index buffer.
 */
#define DDSCAPS2_INDEXBUFFER                    DDSCAPS2_RESERVED3

#else  // !(DIRECT3D_VERSION >= 0x0800)

typedef D3DNTHAL_DP2POINTS *LPD3DNTHAL_DP2POINTS;
typedef D3DNTHAL_DP2RENDERSTATE *LPD3DNTHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2LINELIST *LPD3DNTHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST *LPD3DNTHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP *LPD3DNTHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST *LPD3DNTHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST *LPD3DNTHAL_DP2INDEXEDTRIANGLELIST; // nV addition
typedef D3DNTHAL_DP2TRIANGLESTRIP *LPD3DNTHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN *LPD3DNTHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE *LPD3DNTHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_D3DEXTENDEDCAPS D3DHAL_D3DEXTENDEDCAPS;
typedef LPD3DNTHAL_DP2POINTS LPD3DHAL_DP2POINTS;
typedef LPD3DNTHAL_DP2RENDERSTATE LPD3DHAL_DP2RENDERSTATE;
typedef LPD3DNTHAL_DP2STATESET LPD3DHAL_DP2STATESET;
typedef LPD3DNTHAL_DP2ZRANGE LPD3DHAL_DP2ZRANGE;
typedef LPD3DNTHAL_DP2TEXBLT LPD3DHAL_DP2TEXBLT;
typedef LPD3DNTHAL_DP2SETPRIORITY LPD3DHAL_DP2SETPRIORITY;
typedef LPD3DNTHAL_DP2LINELIST LPD3DHAL_DP2LINELIST;
typedef LPD3DNTHAL_DP2INDEXEDLINELIST LPD3DHAL_DP2INDEXEDLINELIST;
typedef LPD3DNTHAL_DP2LINESTRIP LPD3DHAL_DP2LINESTRIP;
typedef LPD3DNTHAL_DP2STARTVERTEX LPD3DHAL_DP2STARTVERTEX;
typedef LPD3DNTHAL_DP2TRIANGLELIST LPD3DHAL_DP2TRIANGLELIST;
typedef LPD3DNTHAL_DP2INDEXEDTRIANGLELIST LPD3DHAL_DP2INDEXEDTRIANGLELIST;   // nV addition
typedef LPD3DNTHAL_DP2INDEXEDTRIANGLELIST2 LPD3DHAL_DP2INDEXEDTRIANGLELIST2; // nV addition
typedef LPD3DNTHAL_DP2TRIANGLESTRIP LPD3DHAL_DP2TRIANGLESTRIP;
typedef LPD3DNTHAL_DP2TRIANGLEFAN LPD3DHAL_DP2TRIANGLEFAN;
typedef LPD3DNTHAL_DP2TEXTURESTAGESTATE LPD3DHAL_DP2TEXTURESTAGESTATE;
typedef LPD3DNTHAL_DP2VIEWPORTINFO LPD3DHAL_DP2VIEWPORTINFO;
typedef LPD3DNTHAL_DP2WINFO LPD3DHAL_DP2WINFO;
typedef LPD3DNTHAL_DP2TRIANGLEFAN_IMM LPD3DHAL_DP2TRIANGLEFAN_IMM;
typedef LPD3DNTHAL_DP2SETRENDERTARGET LPD3DHAL_DP2SETRENDERTARGET;
typedef LPD3DNTHAL_DP2CLEAR LPD3DHAL_DP2CLEAR;
typedef LPD3DNTHAL_DP2SETCLIPPLANE LPD3DHAL_DP2SETCLIPPLANE;
typedef LPD3DNTHAL_DP2SETLIGHT LPD3DHAL_DP2SETLIGHT;
typedef LPD3DNTHAL_DP2SETMATERIAL LPD3DHAL_DP2SETMATERIAL;
typedef LPD3DNTHAL_DP2SETTRANSFORM LPD3DHAL_DP2SETTRANSFORM;
typedef LPD3DNTHAL_DP2CREATELIGHT LPD3DHAL_DP2CREATELIGHT;

#endif  // !(DIRECT3D_VERSION >= 0x0800)

typedef DD_D3DBUFCALLBACKS DDHAL_DDEXEBUFCALLBACKS;
typedef PDD_D3DBUFCALLBACKS LPDDHAL_DDEXEBUFCALLBACKS;
typedef PDD_SURFACE_INT LPDDRAWI_DDRAWSURFACE_INT;
typedef DD_MISCELLANEOUSCALLBACKS DDHAL_DDMISCELLANEOUSCALLBACKS;
typedef DD_MORESURFACECAPS DDMORESURFACECAPS;
typedef DD_NONLOCALVIDMEMCAPS DDNONLOCALVIDMEMCAPS;
typedef PDD_NONLOCALVIDMEMCAPS LPDDNONLOCALVIDMEMCAPS;

/*
 * DirectX7 types not redefined in DX95TYPE.H
 */
typedef PDD_DIRECTDRAW_LOCAL  LPDDRAWI_DIRECTDRAW_LCL;
#define NvGetFlatDataSelector() (0xffffffff)
// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

#define D3DHAL2_CB32_CLEAR              0x00000002L
#define D3DHAL2_CB32_DRAWONEPRIMITIVE   0x00000004L
#define D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE 0x00000008L
#define D3DHAL2_CB32_DRAWPRIMITIVES     0x00000010L

/*
 * NT doesn't define the DX5 Clear routine's data structure, but the DX5 driver
 * routine can still be called from the DX6 clear routine to do fast buffer
 * clears, so need to define this ourselves (taken from d3d.h)
 */
#if (DIRECT3D_VERSION < 0x0800)

#ifndef IA64
typedef struct _D3DHAL_CLEARDATA
{
    DWORD               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;
#endif

/*
 * DX7 DP2 structs not yet defined in d3dnthal.h.
 */
typedef D3DNTHAL_DP2SETTEXLOD   D3DHAL_DP2SETTEXLOD;
typedef LPD3DNTHAL_DP2SETTEXLOD LPD3DHAL_DP2SETTEXLOD;

#endif  // DIRECT3D_VERSION < 0x0800

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a vertex buffer. Used by CreateVertexBuffer in D3D
 */
#define DDSCAPS2_VERTEXBUFFER                   DDSCAPS2_RESERVED1

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a command buffer. Used by internally in D3D
 */
#define DDSCAPS2_COMMANDBUFFER                  DDSCAPS2_RESERVED2

/*
 * Macros for GDI functions missing from Win2K.
 */
#define IntersectRect(pIntersect, pSrc, pDst) \
    bIntersect((PRECTL) (pSrc), (PRECTL) (pDst), (PRECTL) (pIntersect))

/*
 * Macros for DirectX heap manager functions. Under Win2k, these macros
 * call wrapper functions which massage the parameters, call the DX
 * heap manager,  and adjust the offset of the surface returned by the
 * the heap manager. This is done to minimize changes the the common code.
 */
typedef struct _GLOBALDATA GLOBALDATA;
FLATPTR NvWin2kDxAllocMem(GLOBALDATA *pDriverData, ULONG ulHeapId, ULONG ulSize);
#define DDHAL32_VidMemAlloc(pdrv, heap, x, y) \
    NvWin2kDxAllocMem(pDriverData, (heap), ((x) * (y)))

void NvWin2kDxFreeMem(GLOBALDATA *pDriverData, ULONG ulHeapId, FLATPTR fpOffset);
#define DDHAL32_VidMemFree(pdrv, heap, surface) \
    NvWin2kDxFreeMem(pDriverData, (heap), (surface))

/*
 * Actual protos for the NT display driver functions which perform the
 * Ioctl call to These represent the "OS Independent" RM entry points. For NT they are functions
 * in the display driver which package the parms into a IOCTL packet and make
 * an IOCTL call to the miniport where the RM lives.
 * For WinNT, these are defined in nvapi.c
 */
HANDLE  __cdecl NvOpen            (HANDLE);
VOID    __cdecl NvClose           (HANDLE);

// control codes
ULONG __cdecl NvAllocRoot       (HANDLE, ULONG, ULONG*);
ULONG __cdecl NvAllocDevice     (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG __cdecl NvAllocContextDma (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvAllocChannelPio (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG __cdecl NvAllocChannelDma (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG __cdecl NvAllocMemory     (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG __cdecl NvAllocObject     (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG __cdecl NvAlloc           (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG __cdecl NvFree            (HANDLE, ULONG, ULONG, ULONG);
#if !defined(WINNT) || defined(IA64)
ULONG __cdecl NvAllocEvent      (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID);
#else
ULONG __cdecl NvAllocEvent      (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
#endif
ULONG __cdecl NvFree            (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvDmaFlowControl  (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG __cdecl NvArchHeap        (HANDLE, PVOID);
ULONG __cdecl NvConfigVersion   (HANDLE, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGet       (HANDLE, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigSet       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigSetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigUpdate    (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvGetDmaPushInfo  (HANDLE, ULONG, ULONG, ULONG, ULONG,ULONG);

/*
 * These represent the "OS Independent" RM entry points. For NT they are functions
 * in the display driver which package the parms into a IOCTL packet and make
 * an IOCTL call to the miniport where the RM lives.
 */

#define NvRmOpen() (!NULL)

#define NvRmClose() NULL

#define NvRmAllocRoot(pClient) \
        NvAllocRoot(ppdev->hDriver, NV01_ROOT, (pClient))

#define NvRmAllocDevice(hClient, hDevice, hClass, pName) \
    NvAllocDevice(ppdev->hDriver, hClient, hDevice, NV03_DEVICE_XX, (pName))
#define NvRmAllocContextDma(hClient, hDma, hClass, flags, base, limit) \
        NvAllocContextDma(ppdev->hDriver, hClient, hDma, hClass, flags, base, limit)

#define NvRmAlloc(hCli, hChan, hObj, hCls, parms) \
        NvAlloc(ppdev->hDriver, hCli, hChan, hObj, hCls, parms)

#define NvRmFree(hClient, hParent, hObj) \
        NvFree(ppdev->hDriver, hClient, hParent, hObj)

#define NvRmAllocChannelPio(hClient, hDev, hChan, hClass, hErrorCtx, ppChan, flags) \
        NvAllocChannelPio(ppdev->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (ppChan), (flags))

#define NvRmAllocChannelDma(hClient, hDev, hChan, hClass, hErrorCtx, hDataCtx, offset, ppChan) \
        NvAllocChannelDma(ppdev->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (hDataCtx), (offset), (ppChan))

#define NvRmAllocMemory(hClient, hPar, hMem, hClass, fl, ppAddr, pLim) \
        NvAllocMemory(ppdev->hDriver, hClient, hPar, hMem, hClass, fl, ppAddr, pLim)

#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
        NvAllocObject(ppdev->hDriver, hCli, hChan, hObj, hCls)

#define NvRmGetConfigEx(hCli, hDevice, index, pValue, dummy) \
        NvGetConfigEx(ppdev->hDriver, hCli, hDevice, index, (pValue))

#define NvRmConfigGet(hCli, hDevice, index, pValue) \
        NvConfigGet(ppdev->hDriver, hCli, hDevice, index, (pValue))
#define NvRmConfigGetEx(hCli, hDevice, index, pParams, paramSize) \
        NvConfigGetEx(ppdev->hDriver, hCli, hDevice, index, pParams, paramSize)

#define NvRmConfigSet(hCli, hDev, index, newValue, pOldValue) \
        NvConfigSet(ppdev->hDriver, hCli, hDev, index, newValue, (pOldValue))

#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
        NvAllocObject(ppdev->hDriver, hCli, hChan, hObj, hCls)

#if !defined(WINNT) || defined(IA64)
#define NvRmAllocEvent(hCli, hPar, hObjNew, hClass, index, hEvent) \
        NvAllocEvent(ppdev->hDriver, hCli, hPar, hObjNew, hClass, index, hEvent)

#else
#define NvRmAllocEvent(hCli, hPar, hObjNew, hClass, index, hEvent) \
        NvAllocEvent(ppdev->hDriver, hCli, hPar, hObjNew, hClass, index, (ULONG)hEvent)

#endif
#define NV_SLEEP     Sleep(0)
#define NV_SLEEP1    Sleep(1)
#define NV_SLEEP2    Sleep(2)
#define NV_SLEEP3    Sleep(3)
#define NV_SLEEP4    Sleep(4)
#define NV_SLEEP5    Sleep(5)
#define NV_SLEEPFLIP Sleep(1)

#define SetPriorityClass(a, b)
#define SetThreadPriority(a, b)
#define GetCurrentThread()
#define GetSystemInfo(a)
#define GetCurrentProcessId() ((DWORD)EngGetCurrentProcessId())
#define IsBadReadPtr(nop, nop1) ((nop) == NULL)
#define RegCloseKey(nop) NULL;

/*
 Obtain the amount of available memory in megabytes.
 */
#define GlobalMemoryStatus(pms) \
    (pms)->dwTotalPhys = (DWORD)ppdev->SysMemInfo.SystemMemorySize

#define EXTERN_DDAPI    WINAPI

/*
 * Global memory allocation macros.
 */
#define HeapCreate(nop, nop1, nop2)       (!NULL)
#define HeapDestroy(heap)                 (TRUE)
#define HeapAlloc(nop, nop1, size)            EngAllocMem(FL_ZERO_MEMORY, (size), 'x_VN')
#define HeapFree(nop, nop1, ptr)              { \
    if (ptr != NULL)            \
    {                           \
    EngFreeMem((ptr));          \
    }                           \
}
#define HeapRealloc(nop, ptr, size)     {   \
                                            HeapFree(nop, nop, (ptr)); \
                                            *((PULONG)(ptr)) = HeapAlloc(nop, nop, size); \
                                        }

// HeapSize should never be used on NT. it doesn't work.
#define HeapSize(nop,nop1,nop2)         { _asm int 3 }

/*
 * User mode memory allocation functions. There are no Globalxxx fcts in NT
 * kernel mode.
 */
#define GlobalAlloc(nop, size)  \
    EngAllocUserMem((size), 'x_VN')
#define GlobalLock(ptr) (ptr)
#define GlobalUnlock(nop)
#define GlobalFree(ptr)     \
    EngFreeUserMem(ptr)
#define Sleep(time)         \
    nvDelay()
#define GetCurrentProcess() \
    EngGetProcessHandle()

#define GetThreadPriority(a) \
    (0)
#define GetPriorityClass(a) \
    (0)
#define ConvertRing3EventToRing0(a) \
    HANDLE (0)
#define CreateEventA(a, b, c, d) \
    (0)
#define CreateThread(a, b, c, d, e, f) \
    (0)
#define OpenEventA(a, b, c) \
    (0)
#define CloseHandle(a)
#define GetTickCount()  0

//
// WINNT BUG - disable misc C lib, OS functions til we come up with a better
// solution.
//

#ifdef CreateFile
#undef CreateFile
#endif
#define CreateFile(a,b,c,d,e,f,g) (INVALID_HANDLE_VALUE)

#ifdef WriteFile
#undef WriteFile
#endif
#define WriteFile(a,b,c,d,e)

#ifdef SetFilePointer
#undef SetFilePointer
#endif
#define SetFilePointer(a,b,c,d)

#ifdef FlushFileBuffers
#undef FlushFileBuffers
#endif
#define FlushFileBuffers(a)

#ifdef QueryPerformanceCounter
#undef QueryPerformanceCounter
#endif
#define QueryPerformanceCounter(a) EngQueryPerformanceCounter((__int64 *)a)

#ifdef QueryPerformanceFrequency
#undef QueryPerformanceFrequency
#endif
#define QueryPerformanceFrequency(a) EngQueryPerformanceFrequency((__int64 *)a)

#ifdef RegQueryValueEx
#undef RegQueryValueEx
#endif
#define RegQueryValueEx(a,b,c,d,e,f) TRUE

#ifdef RegOpenKeyEx
#undef RegOpenKeyEx
#endif
#define RegOpenKeyEx(a,b,c,d,e) TRUE

#ifdef IsBadReadPtr
#undef IsBadReadPtr
#endif
#define IsBadReadPtr(a,b) FALSE

#ifdef IsBadWritePtr
#undef IsBadWritePtr
#endif
#define IsBadWritePtr(a,b) FALSE

/*
 * Debug print function, defined in NT display driver file DEBUG.C.
 */
#if defined(DEVELOP) || defined(DEBUG)
VOID DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );
#endif // (DEVELOP || DEBUG)

#ifdef __cplusplus
}
#endif // __cplusplus

#define DX7_DEVICE_OBJECT_HANDLE 0x0c7c6c5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\VERSION.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

#define OFFICIAL   1 
#define FINAL      1 

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

#ifndef FROSTING
/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
/* NVidia's definitions for these live in nvver.h
#ifndef WIN32
#define VERSION                     "4.02.100"
#endif                            
#define VER_PRODUCTVERSION_STR      "4.02.100\0"
#define VER_PRODUCTVERSION          4,02,0,100
#define VER_PRODUCTVERSION_DW       (0x0402000 | 100)
*/
#else
/*--------------------------------------------------------------*/
/* FROSTING Builds will need a higher version # than Windows 95 */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.05"
#endif
#define VER_PRODUCTVERSION_STR      "4.05\0"
#define VER_PRODUCTVERSION          4,05,0,000
#define VER_PRODUCTVERSION_DW       (0x04050000 | 000)
#endif

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef FROSTING
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#else
#define VER_PRODUCTNAME_STR         "Microsoft\256  Plus!  for  Windows\256  95\0"
#endif

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\inc\NVWIN32.H ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include "nv32.h"                       /* for Nv3/4/10 Channel typedef */
#endif

#define NV_SLEEP     Sleep(0)
#define NV_SLEEP1    Sleep(1)
#define NV_SLEEP2    Sleep(2)
#define NV_SLEEP3    Sleep(3)
#define NV_SLEEP4    Sleep(4)
#define NV_SLEEP5    Sleep(5)
#define NV_SLEEPFLIP Sleep(1)

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

#ifdef NOTHERENOTNOW

// this is commented out because somebody defined it else where to get their stuff working even
// though the SDK has it defined here...  ah well so much for standardization!
/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

#endif //0

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait( NvChannel *);

/*
 * NvNotifyEvent() specifies a Windows event for NV to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_EVENT style.
 *    first parameter is the NvChannel
 *    second is the Ring0 Win32 event handle
 */
extern int  __stdcall NvNotifyEvent( NvChannel *, int);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvAllocEvent() specifies a Windows event or callback for NV to send to the
 * application after requesting notifications with the
 * NV_OS_WRITE_THEN_AWAKEN style.
 *    first parameter is the NvChannel
 *    second is the object name
 *    third is the notify index
 *    fourth is the notify event type (NV_OS_EVENT_*)
 *    fifth is the lower 32bits of the 64bit event data
 *    sixth is the upper 32bits of the 64bit event data
 */
extern int  __stdcall NvAllocEvent(NvChannel *, int, int, int, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)



/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* Event Types */
#define NV_OS_EVENT_VXD_CALLBACK   0x00000000
#define NV_OS_EVENT_WIN32_EVENT    0x00000001
#define NV_OS_EVENT_VM_EVENT       0x00000002
#define NV_OS_EVENT_WIN32_MSG      0x00000003
#define NV_OS_EVENT_WIN16          0x00000004
#define NV_OS_EVENT_INVALID        0xFFFFFFFF


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\src\nvgpio.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvgpio.c
 *
 *	General purpose parallel bus support using NV_EXTERNAL_PARALLEL_BUS.
 *
 * Build Info:
 *
 *	These routines can be compiled for either Ring3 or Ring0 use.
 *	Use -DDRIVER and -DVXD when compiling into a VxD and -DDRIVER and 
 *	-DWDM when compiling into WDM.
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef VXD

#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>

#else

#include <windows.h>

/* 
 * some defines/typedef's so we don't have to include all the windows stuff 

#define	TRUE	1

typedef unsigned char	BYTE;
typedef unsigned char	UCHAR;
typedef int 		BOOL;
typedef unsigned long	DWORD;
typedef unsigned int	UINT;
 */

#endif /* VXD */

/* NV includes */
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include <nvcm.h>

/* some register defines for direct access */
#define NV_PME_VIPREG_NBYTES                             0x00200300
#define NV_PME_VIPREG_ADDR                               0x00200304
#define NV_PME_VIPREG_DATA                               0x00200308
#define NV_PME_VIPREG_CTRL                               0x0020030c

#ifdef DRIVER
#include <nvrmr0api.h>
#else
#include <nvrmapi.h>
#endif
#include <nvrmarch.inc>

#include "nvgpio.h"

/*----------------------------------------------------------------------------*/
/*
 * debug stuff
 */

#ifdef DEBUG
#ifdef DRIVER
#ifdef VXD
/* VXD driver debug */
#define DPRINTF0(fmt) _Sprintf(gpioDbgBuf, fmt); Out_Debug_String(gpioDbgBuf)
#define DPRINTF1(fmt, arg1) _Sprintf(gpioDbgBuf, fmt, arg1); Out_Debug_String(gpioDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) _Sprintf(gpioDbgBuf, fmt, arg1, arg2); Out_Debug_String(gpioDbgBuf)
#else
/* WDM driver debug */
#define DPRINTF0(fmt) DbgPrint(fmt )
#define DPRINTF1(fmt, arg1) DbgPrint(fmt, arg1 )
#define DPRINTF2(fmt, arg1, arg2) DbgPrint(fmt, arg1, arg2 )
#endif /* VXD */
#else
/* Ring3 debug */
#include <stdio.h>
#define DPRINTF0(fmt) sprintf(gpioDbgBuf, fmt); OutputDebugString(gpioDbgBuf)
#define DPRINTF1(fmt, arg1) sprintf(gpioDbgBuf, fmt, arg1); OutputDebugString(gpioDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) sprintf(gpioDbgBuf, fmt, arg1, arg2); OutputDebugString(gpioDbgBuf)
#endif /* DRIVER */
#else
/* non-debug */
#define DPRINTF0(fmt)
#define DPRINTF1(fmt, arg1)
#define DPRINTF2(fmt, arg1, arg2)
#endif /* DEBUG */

#ifdef DEBUG
static char	gpioDbgBuf[80];
#endif

/*----------------------------------------------------------------------------*/
/*
 * some nvgpio defines/typedef's
 */

#define	NVGPIO_PARALLEL_BUS_INST	0x50000010
#define	NVGPIO_NOTIFY_DMA_CONTEXT_INST	0x50000011

typedef struct _NVGPIO {
    ULONG		root;
    ULONG		dev;
    ULONG		channel;
    NvChannel*		pNV;
    UINT		subchannel;
#ifdef USE_NV_LINEAR_BASE_ADDR
    ULONG		deviceBase;
#endif
    NvNotification	nvNotifier[3];
} NVGPIO, *PNVGPIO;

#define	VIPREG_TIMEOUT_CNT	1000		// arbitrary

#ifdef DRIVER
#define	NVRM_ALLOC_ROOT		NvRmR0AllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmR0AllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmR0AllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmR0AllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmR0AllocObject
#define	NVRM_FREE		NvRmR0Free
#define	NVRM_INTERRUPT		NvRmR0Interrupt
#else
#define	NVRM_ALLOC_ROOT		NvRmAllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmAllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmAllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmAllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmAllocObject
#define	NVRM_FREE		NvRmFree
#define	NVRM_INTERRUPT		NvRmInterrupt
#endif

void ourYield();

#ifdef DRIVER
#ifdef USE_NV_LINEAR_BASE_ADDR
extern ULONG callRmAPI(ULONG, DWORD, PVOID);
#endif
#endif

/*----------------------------------------------------------------------------*/
/*
 * global GPIO control object
 *
 * XXX it might be better to allocate this object elsewhere
 */

static NVGPIO	nvGPIO;
static PNVGPIO	pGPIO = &nvGPIO;

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOInit
 */

DWORD nvGPIOInit ( 
    ULONG	ourRoot,
    ULONG	ourDev,
    ULONG	ourChannel,
    NvChannel*	pNV,
    UINT	subchan )
{

    UINT	i;
    ULONG	flags;
    DWORD	rc;
    DWORD	err;
    UCHAR*	pNotifyBuf;

    DPRINTF0("nvGPIOInit: entering\n");

    /*
     * create an EXTERNAL_PARALLEL_BUS object
     */

    err = NVRM_ALLOC_OBJECT(ourRoot, ourChannel, NVGPIO_PARALLEL_BUS_INST, NV01_EXTERNAL_PARALLEL_BUS);

    if ( err != NVOS05_STATUS_SUCCESS ) {
	DPRINTF0("nvGPIOInit: NVRM_ALLOC_OBJECT of EXTERNAL_PARALLEL_BUS failed\n");
	return(1);
    }

    /*
     * initialize notifier for parallel bus object
     */

    DPRINTF0("nvGPIOInit: clearing notifier memory\n");

    pNotifyBuf = (UCHAR*) &(pGPIO->nvNotifier);
    for ( i = 0; i < sizeof(NvNotification)*3; i++ )
	pNotifyBuf[i] = 0;

    DPRINTF0("nvGPIOInit: initializing NvNotification objects\n" );

    pGPIO->nvNotifier[NV04F_NOTIFIERS_NOTIFY].status = 0;
    pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 0;
    pGPIO->nvNotifier[NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY].status = 0;

    /*
     * create DMA-to-memory context for notifer and plug in notify memory
     */

    DPRINTF0("nvGPIOInit: creating CONTEXT_DMA_TO_MEMORY object\n");

    flags = ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED;
    rc = NVRM_ALLOC_CONTEXT_DMA(ourRoot,
    			     NVGPIO_NOTIFY_DMA_CONTEXT_INST,
			     NV01_CONTEXT_DMA,
			     flags,
			     (PVOID) pNotifyBuf,
			     sizeof(NvNotification)*3 - 1 );
    if ( rc != ALLOC_CTX_DMA_STATUS_SUCCESS ) {
	DPRINTF0( "nvGPIOInit: NVRM_ALLOC_CONTEXT_DMA failed\n" );
	return(1);
    }

    /*
     * plug notifier into parallel bus object
     */

    DPRINTF0("nvGPIOInit: plugging notifier into parallel bus object\n");

    while ( pNV->subchannel[subchan].control.Free < 2*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.SetContextDmaNotifies = 
	NVGPIO_NOTIFY_DMA_CONTEXT_INST;

#ifdef USE_NV_LINEAR_BASE_ADDR
#ifdef DRIVER
    pGPIO->deviceBase = callRmAPI(1050,0,NULL);	 /* 1050 = NVRM_API_GET_NV_ADDRESS */
#else
    pGPIO->deviceBase = NvDeviceBaseGet(NV_DEV_BASE,1);
#endif
#endif

    /*
     * misc wrap-up
     */

    DPRINTF0("nvGPIOInit: misc wrap-up\n");

    pGPIO->root = ourRoot;
    pGPIO->dev = ourDev;
    pGPIO->channel = ourChannel;
    pGPIO->pNV = pNV;
    pGPIO->subchannel = subchan;

    DPRINTF0("nvGPIOInit: exiting successfully\n");

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOUninit
 */

DWORD nvGPIOUninit()
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;

    DPRINTF0("nvGPIOUninit: entering\n");

    /*
     * XXX The below commented out code is to prevent a race condition with
     *     the synchronous NvRmFree's that occur afterwards.  The solution is
     *     to use NvRmInterrupt and watch the free count to tell when it's safe
     *     to use the synchronous free function.
     */

#ifdef COMMENT

    /*
     * unplug the context dma object
     */

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.SetContextDmaNotifies = 0;

#endif /* COMMENT */

    /*
     * destroy objects created in nvGPIOInit
     */

    NVRM_FREE(pGPIO->root, pGPIO->channel, NVGPIO_PARALLEL_BUS_INST);
    NVRM_FREE(pGPIO->root, pGPIO->root, NVGPIO_NOTIFY_DMA_CONTEXT_INST);

    DPRINTF0("nvGPIOUninit: exiting successfully\n");

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOWrite - do a GPIO write of a byte
 *
 * Note: only single byte addresses are supported at this time
 */

DWORD nvGPIOWrite (
    DWORD	regAddr,
    BYTE	regData )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0("nvGPIOWrite: entering\n");

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // Make sure there isn't a write pending
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x100 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    // Do the write now
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = 1;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA)) = (DWORD)regData;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x100;
#else
    *((DWORD*)(pGPIO->deviceBase | 0x00200800 | regAddr*4)) = regData;
#endif

#else

    /*
     * send write request to the parallel bus object
     */

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteSize = 0x00010001;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteData = (U032)regData;

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0("nvGPIOWrite: exiting\n");

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIORead - do a GPIO read of a byte
 *
 * Note: only single byte addresses are supported at this time
 */

DWORD nvGPIORead (
    DWORD	regAddr,
    BYTE*	pData )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0( "nvGPIORead: entering\n" );

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // go ahead and setup the read (XXX assumes there isn't another read in progress
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = 1;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x1;
    // wait for the read to complete
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x1 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    *pData = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA));
#else
    *pData = *((DWORD*)(pGPIO->deviceBase | 0x00200800 | regAddr*4));
#endif

#else

    /*
     * clear the notifier
     */

    pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS;

    /*
     * send read request to the parallel bus object
     */

    DPRINTF0( "nvGPIORead: sending read request\n" );

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = 0x00010001;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV04F_NOTIFY_WRITE_ONLY;

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvGPIORead: waiting for read to complete\n" );

    while ( (volatile) (pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS ) ourYield();

    /*
     * get the read data
     */

    *pData = (UCHAR)(volatile)(pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0( "nvGPIORead: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvVIPWrite
 */

DWORD nvVIPWrite (
    DWORD	regAddr,
    DWORD	regData,
    DWORD	dataSize )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0("nvVIPWrite: entering\n");

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // Make sure there isn't a write pending
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x100 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    // Do the write now
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = dataSize;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA)) = (DWORD)regData;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x100;
#endif

#else

    /*
     * send write request to the parallel bus object
     */

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteSize = 0x00020000 | dataSize;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteData = (U032)regData;

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0("nvVIPWrite: exiting\n");

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvVIPRead
 */

DWORD nvVIPRead (
    DWORD	regAddr,
    DWORD*	pData,
    DWORD	dataSize )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0( "nvVIPRead: entering\n" );

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // go ahead and setup the read (XXX assumes there isn't another read in progress
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = 1;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x1;
    // wait for the read to complete
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x1 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    *pData = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA));
#endif

#else

    /*
     * clear the notifier
     */

    pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS;

    /*
     * send read request to the parallel bus object
     */

    DPRINTF0( "nvVIPRead: sending read request\n" );

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = 0x00020000 | dataSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV04F_NOTIFY_WRITE_ONLY;

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvVIPRead: waiting for read to complete\n" );

    while ( (volatile) (pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS ) ourYield();

    /*
     * get the read data
     */

    *pData = (UCHAR)(volatile)(pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0( "nvVIPRead: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvRegWrite
 */

DWORD nvRegWrite (
    DWORD	regAddr,
    UINT	regData )
{

    DPRINTF0("nvRegWrite: entering\n");

#ifdef USE_NV_LINEAR_BASE_ADDR

    *((DWORD*)(pGPIO->deviceBase | regAddr)) = regData;

#endif

    DPRINTF0("nvRegWrite: exiting\n");

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvRegRead
 */

DWORD nvRegRead (
    DWORD	regAddr,
    UINT*	pData )
{

    DPRINTF0( "nvRegRead: entering\n" );

#ifdef USE_NV_LINEAR_BASE_ADDR

    *pData = *((DWORD*)(pGPIO->deviceBase | regAddr));

#endif

    DPRINTF0( "nvRegRead: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 * XXX Eventually, this function will be provided to us.
 */

int __GetFlatDataSelector()
{
    DWORD	Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * ourYield()
 */

#ifdef VXD
VOID VXDINLINE
Time_Slice_Sleep(DWORD timeout)
{
    __asm mov eax, timeout
    VMMCall(Time_Slice_Sleep);
}
#endif

static void ourYield()
{
    NVRM_INTERRUPT(pGPIO->root, pGPIO->dev);
}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOSetControlObj - backdoor to set the ptr the global control object
 */

DWORD nvGPIOSetControlObj (
    VOID*	pObj )
{

    pGPIO = (NVGPIO*) pObj;

    DPRINTF0( "nvGPIOSetControlObj: exiting successfully\n" );

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOGetControlObj - backdoor to get the ptr the global control object
 */

VOID* nvGPIOGetControlObj ()
{

    DPRINTF0( "nvGPIOGetControlObj: exiting successfully\n" );

    return(pGPIO);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\win9x\src\nvi2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvi2c.c
 *
 *	I2C functionality using the NV_EXTERNAL_SERIAL_BUS object.
 *
 * Build Info:
 *
 *	These routines can be compiled for either Ring3 or Ring0 use.
 *	Use -DDRIVER and -DVXD when compiling into a VxD and -DDRIVER and 
 *	-DWDM when compiling into WDM.
 */

#ifdef nv3
#define	NV3
#endif

#ifdef nv4
#define	NV4
#endif

#ifdef nv10
#define	NV10
#endif

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef VXD

#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>

#else

#include <stdio.h>
#include <windows.h>

/* 
 * some defines/typedef's so we don't have to include all the windows stuff 

#define	TRUE	1

typedef unsigned char	BYTE;
typedef unsigned char	UCHAR;
typedef int 		BOOL;
typedef unsigned long	DWORD;
typedef unsigned int	UINT;
typedef unsigned short	USHORT;
 */

#endif /* VXD */

/* NV includes */
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>

#ifdef DRIVER
#include <nvrmr0api.h>
#else
#include <nvrmapi.h>
#endif

#include "nvi2c.h"

/*----------------------------------------------------------------------------*/
/*
 * debug stuff
 */

#ifdef DEBUG
#ifdef DRIVER
#ifdef VXD
/* VXD driver debug */
#define DPRINTF0(fmt) _Sprintf(i2cDbgBuf, fmt); Out_Debug_String(i2cDbgBuf)
#define DPRINTF1(fmt, arg1) _Sprintf(i2cDbgBuf, fmt, arg1); Out_Debug_String(i2cDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) _Sprintf(i2cDbgBuf, fmt, arg1, arg2); Out_Debug_String(i2cDbgBuf)
#else
/* WDM driver debug */
#define DPRINTF0(fmt) DbgPrint(fmt )
#define DPRINTF1(fmt, arg1) DbgPrint(fmt, arg1 )
#define DPRINTF2(fmt, arg1, arg2) DbgPrint(fmt, arg1, arg2 )
#endif /* VXD */
#else
/* Ring3 debug */
#include <stdio.h>
#define DPRINTF0(fmt) sprintf(i2cDbgBuf, fmt); OutputDebugString(i2cDbgBuf)
#define DPRINTF1(fmt, arg1) sprintf(i2cDbgBuf, fmt, arg1); OutputDebugString(i2cDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) sprintf(i2cDbgBuf, fmt, arg1, arg2); OutputDebugString(i2cDbgBuf)
#define DPRINTF3(fmt, arg1, arg2, arg3 ) sprintf(i2cDbgBuf, fmt, arg1, arg2, arg3); OutputDebugString(i2cDbgBuf)
#endif /* DRIVER */
#else
/* non-debug */
#define DPRINTF0(fmt)
#define DPRINTF1(fmt, arg1)
#define DPRINTF2(fmt, arg1, arg2)
#endif /* DEBUG */

static char	i2cDbgBuf[80];

/*----------------------------------------------------------------------------*/
/*
 * misc defines/typedef's
 */

#define	NVI2C_BASE_INST			0x50000001
#define	NVI2C_SERIAL_BUS		0
#define	NVI2C_NOTIFY_DMA_CONTEXT	1
#define	NVI2C_DEVICE			2
#define	NVI2C_CHANNEL			3

typedef struct _NVI2C {
    ULONG		externalAllocd;
    ULONG		root;
    ULONG		dev;
    ULONG		channel;
    NvChannel*		pNV;
    UINT		subchannel;
    UINT		baseInst;
    NvNotification	nvNotifier[3];
    UINT		addrSize;
} NVI2C, *PNVI2C;

#ifdef DRIVER
#define	NVRM_ALLOC_ROOT		NvRmR0AllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmR0AllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmR0AllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmR0AllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmR0AllocObject
#define	NVRM_FREE		NvRmR0Free
#define	NVRM_INTERRUPT		NvRmR0Interrupt
#else
#define	NVRM_ALLOC_ROOT		NvRmAllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmAllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmAllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmAllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmAllocObject
#define	NVRM_FREE		NvRmFree
#define	NVRM_INTERRUPT		NvRmInterrupt
#endif

#define	NVI2C_READ_TIMEOUT	10000

void __yield();

/*----------------------------------------------------------------------------*/
/*
 * global I2C control object
 *
 * XXX it might be better to allocate this object elsewhere
 */

static NVI2C	nvI2C;
static PNVI2C	pI2C = &nvI2C;


/*----------------------------------------------------------------------------*/
/*
 * nvI2CInit
 */

DWORD nvI2CInit (
    ULONG	ourRoot,
    ULONG	ourDev,
    ULONG	ourChannel,
    NvChannel*	pChannel,
    UINT	subchan,
    UINT	baseInst )
{

    UINT	i;
    ULONG	flags;
    DWORD	rc;
    DWORD	err;
    UCHAR*	pNotifyBuf;
    NvChannel*	pNV;
    char	devName[32];

    DPRINTF0( "nvI2CInit: entering\n" );

    /*
     * check if user wants to use a specific base instance for our objects
     */

    if ( baseInst == 0 ) {
    	baseInst = NVI2C_BASE_INST;
    }

    /*
     * check if we need to allocate root, device and channel
     */

    if ( pChannel == NULL ) {

	/*
	 * get a NV channel
	 */

	err = NVRM_ALLOC_ROOT(&ourRoot);
	if ( err != NVOS01_STATUS_SUCCESS ) {
	    DPRINTF0("nvI2CInit: NVRM_ALLOC_ROOT failed\n");
	    return(1);
	}

	ourDev = baseInst + NVI2C_DEVICE;
	err = NVRM_ALLOC_DEVICE(ourRoot, 
			        ourDev, 
			        NV01_DEVICE_0, 
			        devName);
	if ( err != NVOS06_STATUS_SUCCESS ) {
	    DPRINTF0("nvI2CInit: NVRM_ALLOC_DEVICE failed\n");
	    NVRM_FREE(ourRoot, ourRoot, ourRoot);
	    return(1);
	}

	ourChannel = baseInst + NVI2C_CHANNEL;
	err = NVRM_ALLOC_CHANNEL_PIO(ourRoot,
				     ourDev,
				     ourChannel,
    #ifdef NV3
				     NV03_CHANNEL_PIO,
    #else
				     NV03_CHANNEL_PIO,
    #endif
				     0,
				     (PVOID) &pNV,
				     0);

	if ( err != NVOS04_STATUS_SUCCESS ) {
	    DPRINTF0("nvI2CInit: NVRM_ALLOC_CHANNEL_PIO failed\n");
	    NVRM_FREE(ourRoot, ourRoot, ourDev);
	    NVRM_FREE(ourRoot, ourRoot, ourRoot);
	    return(1);
	}

	if ( pNV == NULL ) {
	    DPRINTF0("nvI2CInit: null channel ptr returned by NVRM_ALLOC_CHANNEL_PIO\n");
	    NVRM_FREE(ourRoot, ourDev, ourChannel);
	    NVRM_FREE(ourRoot, ourRoot, ourDev);
	    NVRM_FREE(ourRoot, ourRoot, ourRoot);
	    return(1);
	}

	pI2C->externalAllocd = FALSE;
    }
    else {

        /*
	 * use the channel ptr (and root and device and channel id) that was passed to us
	 */

        pNV = pChannel;

	pI2C->externalAllocd = TRUE;

    }

    /*
     * create an EXTERNAL_SERIAL_BUS object
     */

#ifdef NV3
    err = NVRM_ALLOC_OBJECT(ourRoot, ourChannel, baseInst+NVI2C_SERIAL_BUS, NV_EXTERNAL_SERIAL_BUS);
#else
    err = NVRM_ALLOC_OBJECT(ourRoot, ourChannel, baseInst+NVI2C_SERIAL_BUS, NV04_EXTERNAL_SERIAL_BUS);
#endif

    if ( err != NVOS05_STATUS_SUCCESS ) {
	DPRINTF0("nvI2CInit: NVRM_ALLOC_OBJECT of EXTERNAL_SERIAL_BUS failed\n");
	return(1);
    }

    /*
     * initialize notifier for serial bus object
     */

    DPRINTF0( "nvI2CInit: clearing notifier memory\n" );

    pNotifyBuf = (UCHAR*) &(pI2C->nvNotifier);
    for ( i = 0; i < sizeof(NvNotification)*3; i++ )
	pNotifyBuf[i] = 0;

    DPRINTF0( "nvI2CInit: initializing NvNotification objects\n" );

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_NOTIFY].status = 0;
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = 0;
    pI2C->nvNotifier[NV_051_NOTIFICATION_SET_INTERRUPT_NOTIFY].status = 0;
#else
    pI2C->nvNotifier[NV051_NOTIFIERS_NOTIFY].status = 0;
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 0;
    pI2C->nvNotifier[NV051_NOTIFICATION_SET_INTERRUPT_NOTIFY].status = 0;
#endif

    /*
     * create DMA-to-memory context for notifer and plug in notify memory
     */

    DPRINTF0( "nvI2CInit: creating CONTEXT_DMA_TO_MEMORY object\n" );

    flags = NVOS03_FLAGS_ACCESS_READ_WRITE | NVOS03_FLAGS_COHERENCY_UNCACHED;
    rc = NVRM_ALLOC_CONTEXT_DMA(ourRoot,
    			     baseInst + NVI2C_NOTIFY_DMA_CONTEXT,
			     NV01_CONTEXT_DMA,
			     flags,
			     (PVOID) pNotifyBuf,
			     sizeof(NvNotification)*3 - 1 );
    if ( rc != NVOS03_STATUS_SUCCESS ) {
	DPRINTF0( "nvI2CInit: NVRM_ALLOC_CONTEXT_DMA failed\n" );
	return(1);
    }

    /*
     * plug notifier into serial bus object
     */

    DPRINTF0( "nvI2CInit: plugging notifer into serial bus object\n" );

#ifdef NV3
    while ( pNV->subchannel[subchan].control.free < 2*4 );

    pNV->subchannel[subchan].control.object = baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.SetContextDmaNotifies = 
	baseInst + NVI2C_NOTIFY_DMA_CONTEXT;
#else
    while ( pNV->subchannel[subchan].control.Free < 2*4 );

    pNV->subchannel[subchan].SetObject = baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.SetContextDmaNotifies = 
	baseInst + NVI2C_NOTIFY_DMA_CONTEXT;
#endif

    /*
     * misc wrap-up
     */

    DPRINTF0( "nvI2CInit: misc wrap-up\n" );

    pI2C->addrSize = 2;	/* default is 16-bit addresses */
    pI2C->root = ourRoot;
    pI2C->dev = ourDev;
    pI2C->channel = ourChannel;
    pI2C->pNV = pNV;
    pI2C->subchannel = subchan;
    pI2C->baseInst = baseInst;

    DPRINTF0( "nvI2CInit: exiting successfully\n" );

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CUninit
 *
 * XXX for now don't compile into a Ring0 driver
 */

DWORD nvI2CUninit()
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;

    DPRINTF0( "nvI2CUninit: entering\n" );

    /*
     * XXX The below commented out code is to prevent a race condition with
     *     the synchronous NvRmFree's that occur afterwards.  The solution is
     *     to use NvRmInterrupt and watch the free count to tell when it's safe
     *     to use the synchronous free function.
     */

#ifdef COMMENT

    /*
     * unplug the context dma object
     */

#ifdef NV3
    pNV->subchannel[subchan].control.object = pI2C->baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.SetContextDmaNotifies = 0;
#else
    pNV->subchannel[subchan].SetObject = pI2C->baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.SetContextDmaNotifies = 0;
#endif

#endif /* COMMENT */

    /*
     * destroy objects created in nvI2CInit
     */

    NVRM_FREE(pI2C->root, pI2C->channel, pI2C->baseInst+NVI2C_SERIAL_BUS);
    NVRM_FREE(pI2C->root, pI2C->root, pI2C->baseInst+NVI2C_NOTIFY_DMA_CONTEXT);

    /*
     * free root, device, and channel if we allocated them
     */

    if ( pI2C->externalAllocd == FALSE ) {
	NVRM_FREE(pI2C->root, pI2C->dev, pI2C->channel);
	NVRM_FREE(pI2C->root, pI2C->root, pI2C->dev);
	NVRM_FREE(pI2C->root, pI2C->root, pI2C->root);
    }

    DPRINTF0( "nvI2CUninit: exiting\n" );

    return(0);

}
 
/*----------------------------------------------------------------------------*/
/*
 * nvI2CWriteByte
 */

DWORD nvI2CWriteByte (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    UCHAR	data )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	writeSize = (pI2C->addrSize << 16) | 0x00000001;
    UINT	addr = (regAddr << 8) | chipAddr;

    DPRINTF0( "nvI2CWriteByte: entering\n" );

    /*
     * send write request to the serial bus object
     */

#ifdef NV3
    DPRINTF0("nvI2CWriteByte: doing NV3 write\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Write.size = writeSize;
    pNV->subchannel[subchan].externalSerialBus.Write.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Write.data = data;
#else
    DPRINTF0("nvWriteI2CByte: doing NV4 write\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteSize = writeSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteData = data;
#endif

    DPRINTF0( "nvI2CWriteByte: exiting\n" );

    return(0);

}
    
/*----------------------------------------------------------------------------*/
/*
 * nvI2CReadByte
 */

DWORD nvI2CReadByte (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    UCHAR*	pData )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	readSize = (pI2C->addrSize << 16) | 0x00000001;
    UINT	addr = (regAddr << 8) | chipAddr;
    UINT	timeOut = NVI2C_READ_TIMEOUT;

    DPRINTF0( "nvI2CReadByte: entering\n" );

    /*
     * clear the notifier
     */

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = NV_STATUS_IN_PROGRESS;
#else
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV051_NOTIFICATION_STATUS_IN_PROGRESS;
#endif

    /*
     * send read request to the serial bus object
     */

    DPRINTF0( "nvI2CReadByte: sending read request\n" );

#ifdef NV3
    DPRINTF0("nvI2CReadByte: doing NV3 read\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Read.size = readSize;
    pNV->subchannel[subchan].externalSerialBus.Read.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Read.getDataNotify = 
	NV_051_NOTIFY_WRITE_ONLY;
#else
    DPRINTF0("nvI2CReadByte: doing NV4 read\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = readSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV051_NOTIFY_WRITE_ONLY;
#endif

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvI2CReadByte: waiting for read to complete\n" );

    while ( timeOut > 0 ) {

#ifdef NV3
	if ( (volatile) (pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status) == NV_STATUS_IN_PROGRESS ) {
#else
	if ( (volatile) (pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	    NV051_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
	    /* data is not ready yet */
	    timeOut--;
	    __yield();
	}
	else {
	    /* stop waiting, the data is ready */
	    break; 
	}

    }

    if ( timeOut == 0 ) {
	DPRINTF0( "nvI2CReadByte: error, read timed out\n" );
	return(1);
    }

    /*
     * get the read data
     */

#ifdef NV3
    *pData = (UCHAR)(volatile)(pI2C->nvNotifier[NV_051_NOTIFICATION_READ].otherInfo32);
#else
    *pData = (UCHAR)(volatile)(pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);
#endif

    DPRINTF1( "nvI2CReadByte: exiting, with read data = 0x%x\n", *pData );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CWriteWord
 */

DWORD nvI2CWriteWord (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    USHORT	data )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	writeSize = (pI2C->addrSize << 16) | 0x00000002;
    UINT	addr = (regAddr << 8) | chipAddr;
    UINT	uiData;

    DPRINTF0( "nvI2CWriteWord: entering\n" );

    /*
     * swap data bytes
     */

    uiData = ((data & 0xff) << 8) | ((data >> 8) & 0xff);

    /*
     * send write request to the serial bus object
     */

#ifdef NV3
    DPRINTF0("nvI2CWriteWord: doing NV3 write\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Write.size = writeSize;
    pNV->subchannel[subchan].externalSerialBus.Write.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Write.data = uiData;
#else
    DPRINTF0("nvI2CWriteWord: doing NV4 write\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteSize = writeSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteData = uiData;
#endif

    DPRINTF0( "nvI2CWriteWord: exiting\n" );

    return(0);

}
    
/*----------------------------------------------------------------------------*/
/*
 * nvI2CReadWord
 */

DWORD nvI2CReadWord (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    USHORT*	pData )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	readSize = (pI2C->addrSize << 16) | 0x00000002;
    UINT	addr = (regAddr << 8) | chipAddr;
    USHORT	data;
    UINT	timeOut = NVI2C_READ_TIMEOUT;

    DPRINTF0( "nvI2CReadWord: entering\n" );

    /*
     * clear the notifier
     */

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = NV_STATUS_IN_PROGRESS;
#else
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV051_NOTIFICATION_STATUS_IN_PROGRESS;
#endif

    /*
     * send read request to the serial bus object
     */

    DPRINTF0( "nvI2CReadWord: sending read request\n" );

#ifdef NV3
    DPRINTF0("nvI2CReadWord: doing NV3 read\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Read.size = readSize;
    pNV->subchannel[subchan].externalSerialBus.Read.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Read.getDataNotify = 
	NV_051_NOTIFY_WRITE_ONLY;
#else
    DPRINTF0("nvI2CReadWord: doing NV4 read\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = readSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV051_NOTIFY_WRITE_ONLY;
#endif

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvI2CReadWord: waiting for read to complete\n" );

    while ( timeOut > 0 ) {

#ifdef NV3
	if ( (volatile) (pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status) == NV_STATUS_IN_PROGRESS ) {
#else
	if ( (volatile) (pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	    NV051_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
	    /* data is not ready yet */
	    timeOut--;
	    __yield();
	}
	else {
	    /* stop waiting, the data is ready */
	    break; 
	}

    }

    if ( timeOut == 0 ) {
	DPRINTF0( "nvI2CReadWord: error, read timed out\n" );
	return(1);
    }

    /*
     * get the read data
     */

#ifdef NV3
    data = (USHORT)(volatile)(pI2C->nvNotifier[NV_051_NOTIFICATION_READ].otherInfo32);
#else
    data = (USHORT)(volatile)(pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);
#endif

    *pData = ((data & 0xff) << 8) | ((data >> 8) & 0xff);

    DPRINTF1( "nvReadI2CWord: exiting, with read data = 0x%x\n", *pData );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CWriteBuf - do a I2C "write" of a variable length buffer of bytes
 *
 * Note: the current implemenation of the external serial class object
 *	 does not allow for more then 8 bytes total (address and data)
 *	 to be transmitted in a single I2C "transaction".
 */

DWORD nvI2CWriteBuf (
    UCHAR*	pBuf,
    UINT	bufSize )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	i, tmp;
    UINT	writeSize;
    UINT	addr;
    UINT	data;

    DPRINTF0( "nvI2CWriteBuf: entering\n" );

    /*
     * construct proper addr and data values using contents of pBuf
     */

    addr = 0;

    for ( i = 0; (i < 4) && (i < bufSize); i++ ) {
        tmp = (pBuf[i] & 0xff) << (i*8);
	addr = addr | tmp;
    }

    writeSize = i << 16;

    data = 0;

    for ( i = 4; (i < 8) && (i < bufSize); i++ ) {
        tmp = (pBuf[i] & 0xff) << ((i-4)*8);
	data = data | tmp;
    }

    writeSize = writeSize | (i-4);

    DPRINTF1( "nvI2CWriteBuf: addr = %x\n", addr );
    DPRINTF1( "nvI2CWriteBuf: data = %x\n", data );
    DPRINTF1( "nvI2CWriteBuf: writeSize = %x\n", writeSize );
    
    /*
     * send write request to the serial bus object
     */

#ifdef NV3
    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Write.size = writeSize;
    pNV->subchannel[subchan].externalSerialBus.Write.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Write.data = data;
#else
    while ( pNV->subchannel[subchan].control.Free < 4*4 ) 
        __yield();

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteSize = writeSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteData = data;
#endif

    DPRINTF0( "nvI2CWriteBuf: exiting\n" );

    return(0);

}
    
/*----------------------------------------------------------------------------*/
/*
 * nvI2CReadBuf - do a I2C "read" of a buffer of bytes using a variable length address
 *
 * Note: the address buffer and read buffer is limited to a maximum of 4 bytes
 */

DWORD nvI2CReadBuf (
    UCHAR*	pBuf,		/* address buffer */
    UINT	bufSize,	/* size of address buffer, max 4 */
    UCHAR*	pData,
    UINT	readBufSize)
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	i, tmp;
    UINT	readSize;
    UINT	addr;
    UINT	data;
    UINT	timeOut = NVI2C_READ_TIMEOUT;
#ifdef DO_TIMING
    UINT	deltaLo, startLo;
#endif

    DPRINTF0( "nvI2CReadBuf: entering\n" );

    /*
     * construct proper addr and data values using contents of pBuf
     */

    addr = 0;

    for ( i = 0; (i < 4) && (i < bufSize); i++ ) {
        tmp = pBuf[i] << (i*8);
	addr = addr | tmp;
    }

    readSize = (i << 16) | (readBufSize & 0x0000ffff);

    /*
     * clear the notifier
     */

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = NV_STATUS_IN_PROGRESS;
#else
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV051_NOTIFICATION_STATUS_IN_PROGRESS;
#endif

    /*
     * send read request to the serial bus object
     */

    DPRINTF1( "nvI2CReadBuf: addr = %x\n", addr );
    DPRINTF1( "nvI2CReadBuf: readSize = %x\n", readSize );
    
    DPRINTF0( "nvI2CReadBuf: sending read request\n" );

#ifdef NV3
    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Read.size = readSize;
    pNV->subchannel[subchan].externalSerialBus.Read.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Read.getDataNotify = 
	NV_051_NOTIFY_WRITE_ONLY;
#else
    while ( pNV->subchannel[subchan].control.Free < 4*4 )
        __yield();

#ifdef DO_TIMING
    startLo = clockop(1);	/* start timing */
#endif

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = readSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV051_NOTIFY_WRITE_ONLY;
#endif

    /*
     * wait for read to complete
     */

#ifndef DO_TIMING
    DPRINTF0( "nvI2CReadBuf: waiting for read to complete\n" );
#endif

    while ( timeOut > 0 ) {

#ifdef NV3
	if ( (volatile) (pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status) == NV_STATUS_IN_PROGRESS ) {
#else
	if ( (volatile) (pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	    NV051_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
	    /* data is not ready yet */
	    timeOut--;
	    __yield();
	}
	else {
	    /* stop waiting, the data is ready */
	    break; 
	}

    }

    if ( timeOut == 0 ) {
	DPRINTF0( "nvI2CReadWord: error, read timed out\n" );
	return(1);
    }

    /*
     * get the read data
     */

#ifdef NV3
    data = (UINT)(volatile)(pI2C->nvNotifier[NV_051_NOTIFICATION_READ].otherInfo32);
#else
    data = (UINT)(volatile)(pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);
#endif

#ifdef DO_TIMING
    deltaLo = clockop(0);	 /* stop timing */
#ifdef DRIVER
    _Sprintf( i2cDbgBuf, "nvi2CReadBuf: startLo = %d\n", startLo );
    Out_Debug_String ( i2cDbgBuf );
    _Sprintf( i2cDbgBuf, "nvi2CReadBuf: deltaLo = %d\n", deltaLo );
    Out_Debug_String ( i2cDbgBuf );
#else
    fprintf( stdout, "nvi2CReadBuf: startLo = %d\n", startLo );
    fprintf( stdout, "nvi2CReadBuf: deltaLo = %d\n", deltaLo );
#endif
#endif /* DO_TIMING */

    DPRINTF1( "nvI2CReadBuf: data = %x\n", data );

    /*
     * reorder the bytes since we're actually being passed a ptr to bytes
     */

    for ( i = 0; i < readBufSize; i++ ) {
	pData[i] = data & 0xff;
	data = data >> 8;
    }

    DPRINTF0( "nvI2CReadBuf: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CWrite
 *
 */

DWORD nvI2CWrite (
    UCHAR	chipAddr, 
    DWORD	subAddrLen, 
    UCHAR*	subAddr, 
    DWORD	dataLen, 
    UCHAR*	data)
{

    UINT	i;
    UINT	dindex;
    UCHAR	buf[8];
    UINT	bufSize;
    UINT	m;
    UINT	rc = 0;

    if ( (subAddrLen < 1) || (dataLen < 1) ) {
    	return(1);
    }

    buf[0] = chipAddr;
    for ( i = 1; i <= subAddrLen; i++ ) {
        buf[i] = subAddr[i-1];
    }
    dindex = i;

    i = 0;
    do {
        m = i & 0x3;
        buf[dindex+m] = data[i];
	if ( (m == 3) || (i == dataLen-1) ) {
	    bufSize = dindex+m+1;
	    rc |= nvI2CWriteBuf(buf, bufSize);
	}
    }
    while( ++i < dataLen );

    return(rc);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CRead
 *
 */

DWORD nvI2CRead (
    UCHAR	chipAddr, 
    DWORD	subAddrLen, 
    UCHAR*	subAddr, 
    DWORD	dataLen, 
    UCHAR*	data)
{

    UINT	i;
    UINT	dindex;
    UCHAR	buf[8];
    UINT	bufSize;

    if ( (subAddrLen > 3) || (dataLen > 1) ) {
    	return(1);
    }

    buf[0] = chipAddr;
    for ( i = 1; i <= subAddrLen; i++ ) {
        buf[i] = subAddr[i-1];
    }
    dindex = i;

    bufSize = dindex;

    return ( nvI2CReadBuf(buf, bufSize, data, 1) );

}


/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 * XXX Eventually, this function will be provided to us.
 */

static int __GetFlatDataSelector()
{
    DWORD	Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * __yield()
 */

#ifdef VXD
VOID VXDINLINE
Time_Slice_Sleep(DWORD timeout)
{
    __asm mov eax, timeout
    VMMCall(Time_Slice_Sleep);
}
#endif

static void __yield()
{
    NVRM_INTERRUPT(pI2C->root, pI2C->dev);
}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CSetControlObj - backdoor to set the ptr the global control object
 */

DWORD nvI2CSetControlObj (
    VOID*	pObj )
{

    pI2C = (NVI2C*) pObj;

    DPRINTF0( "nvI2CSetControlObj: exiting successfully\n" );

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CGetControlObj - backdoor to get the ptr the global control object
 */

VOID* nvI2CGetControlObj ()
{

    DPRINTF0( "nvI2CGetControlObj: exiting successfully\n" );

    return(pI2C);

}

/*----------------------------------------------------------------------------*/
/*
 * utility real-time clock routines
 */

#ifdef DO_TIMING

UINT
clockcount( UINT* phi, UINT* plo )
{

    UINT        hi, lo;

    /* emit RDTSC instruction to get clock count */
    __asm
    {
        _emit   0x0f 
        _emit   0x31
        mov         hi, edx
        mov         lo, eax
    }

    *phi = hi;
    *plo = lo;

    return(lo);

}

UINT
deltacount ( 
    UINT startHi, 
    UINT startLo, 
    UINT stopHi, 
    UINT stopLo, 
    UINT* deltaHi, 
    UINT* deltaLo )
{

    if ( stopLo > startLo ) {
        *deltaLo = stopLo - startLo;
	*deltaHi = stopHi - startHi;
    }
    else {
    	*deltaLo = 0xffffffff - ( startLo - stopLo );
	*deltaHi = stopHi - startHi - 1;
    }

    return(*deltaLo);

}

/* 
 * clockop() only works for delta processor clocks < 2^32 - 1 
 * which is ~14 seconds on 300MHz clock
 *
 * start > op = 1, stop -> op = 0
 */

UINT clockop( UINT op )	
{

    static UINT	startHi, startLo;
    static UINT	stopHi, stopLo;
    static UINT	deltaHi, deltaLo;

    if ( op ) {
    	clockcount ( &startHi, &startLo );
	return(startLo);
    }
    else {
    	clockcount ( &stopHi, &stopLo );
    	deltacount ( startHi, startLo, stopHi, stopLo, &deltaHi, &deltaLo );
	return(deltaLo);
    }

}

#endif /* DO_TIMING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusNvTSS.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusNvTSS.h
//      Celsius 2 stage combiner setup routines.
//
// **************************************************************************
//
//  History:
//      Lorie Sixia Deng       12Dec99         NV10 development
//
// **************************************************************************

#ifndef _NVCELSIUSNVTSS_H
#define _NVCELSIUSNVTSS_H

#define COMBINER_STATUS 0

#if (NVARCH >= 0x10)

// prototypes
BOOL nvCheckBumpMapStates          (PNVD3DCONTEXT pContext, int nStage);
BOOL nvCelsiusCheck3Stage2Textures (PNVD3DCONTEXT pContext);
BOOL nvCelsiusCheck2Stage1Combiner (PNVD3DCONTEXT pContext);
BOOL nvCelsiusCheck3StageSpecial (PNVD3DCONTEXT pContext);


HRESULT nvSetCelsius8StageBumpMapCombiners  (PNVD3DCONTEXT pContext);
HRESULT nvSetCelsius4StageBumpMapCombiners  (PNVD3DCONTEXT pContext);
HRESULT nvCelsiusSetTextures3StageCombiners (PNVD3DCONTEXT pContext);
HRESULT nvCelsiusSet2Stage1Combiner (PNVD3DCONTEXT pContext);
HRESULT nvCelsiusSet3StageSpecial (PNVD3DCONTEXT pContext);

#endif//NVARCH >= 0x10
#endif//_NVCELSIUSNVTSS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusAA.h ===
#ifndef _NVCELSIUSAA_H
#define _NVCELSIUSAA_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusAA.h                                                     *
*     prototypes for aa routines                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                      12Jan2000   created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x010)

struct AAAppCompatState
{
    LPTSTR lpApp;
    BOOL bNoAA;
    BOOL bPath;
    BOOL bDiscardFBContents;
    BOOL bAlwaysMagnifyUponUnlock;
    BOOL bMinifyUponEndScene;
    BOOL bDither;
    BOOL bBlitSync;
    BOOL bDiscardSRT;
    BOOL bAllowSpecial;
};

#define AA_ENABLED(pDriverData, pContext) \
    (((pDriverData)->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) \
     && (((pContext)->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE) \
     || ((pDriverData)->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK)))

struct AASTATE
{
    enum
    {
        FLAG_ENABLED        = 0x80000000,       // aa is enabled and in use
        FLAG_INIT           = 0x20000000,       // aa is ready (super buffers exist)
        FLAG_SUSPENDED      = 0x10000000,       // aa is enabled but suspended for render to texture


        FLAG_RT_VALID       = 0x00800000,       // render target valid
        FLAG_ZB_VALID       = 0x00400000,       // zeta buffer valid
        FLAG_SRT_VALID      = 0x00200000,       // super render target valid
        FLAG_SZB_VALID      = 0x00100000,       // super zeta buffer valid

        MASK_BSCOUNT        = 0x00000ff0,
            BSC_RESET           = 0x200,
            BSC_DEC             = 0x010,

        MASK_METHOD         = 0x00000007,
            METHOD_1x2          = 0,
            METHOD_2x2lod       = 1,
            METHOD_2x2          = 2,
            METHOD_2x2spec      = 3,
            METHOD_3x3lod       = 4,
            METHOD_3x3          = 5,
            METHOD_4x4lod       = 6,
            METHOD_4x4          = 7,
    };
// bank
protected:
    DWORD dwFlags;

public:
    AAAppCompatState mAppCompat;

    CSimpleSurface *pSuperRenderTarget;
    CSimpleSurface *pSuperZetaBuffer;
    CSimpleSurface *pBlitTempSpace;

    float fWidthAmplifier;
    float fHeightAmplifier;
    DWORD dwDepthAmplifier;

    DWORD dwOriginalRenderTargetWidth;
    DWORD dwOriginalRenderTargetHeight;
    DWORD dwOriginalZBHandle;

    float fLODBias;
    DWORD dwLinePointSize;

    // helpers
    inline void setFlags (DWORD dwMask)
    {
        dwFlags |= dwMask;
        invalidateState();
    }

    inline void modFlags (DWORD dwAndMask,DWORD dwOrMask)
    {
        dwFlags &= dwAndMask;
        dwFlags |= dwOrMask;
        invalidateState();
    }

    inline BOOL isInit (void) const
    {
        return dwFlags & AASTATE::FLAG_INIT;
    }

    inline BOOL isEnabled (void) const
    {
        return dwFlags & AASTATE::FLAG_ENABLED;
    }

    inline BOOL isSuspended (void) const
    {
        return dwFlags & AASTATE::FLAG_SUSPENDED;
    }

    inline BOOL isRenderTargetValid (void) const
    {
        return dwFlags & AASTATE::FLAG_RT_VALID;
    }

    inline BOOL isSuperBufferValid (void) const
    {
        return dwFlags & AASTATE::FLAG_SRT_VALID;
    }

    inline BOOL isZetaBufferValid (void) const
    {
        return dwFlags & AASTATE::FLAG_ZB_VALID;
    }

    inline BOOL isSuperZBValid (void) const
    {
        return dwFlags & AASTATE::FLAG_SZB_VALID;
    }

    inline void invalidateSRT() {
        dwFlags &= ~FLAG_SRT_VALID;
    }

    inline void makeRenderBuffersMatch (PNVD3DCONTEXT pContext);
    inline void makeZBuffersMatch (PNVD3DCONTEXT pContext);

    // In the next four functions, we assume that at least one of the
    // buffers (of each type, either color or Z), is valid.
    // Instantiated in nvCelsiusAA.cpp
    void makeRenderTargetValid (PNVD3DCONTEXT pContext);
    void makeZetaBufferValid (PNVD3DCONTEXT pContext);
    void makeSuperBufferValid (PNVD3DCONTEXT pContext);
    void makeSuperZBValid (PNVD3DCONTEXT pContext);

    inline DWORD getMethod (void) const
    {
        return dwFlags & AASTATE::MASK_METHOD;
    }

    inline void bsReset (void)
    {
        dwFlags &= ~MASK_BSCOUNT;
        dwFlags |=  BSC_RESET;
    }

    inline BOOL bsDec (void)
    {
        if (dwFlags & MASK_BSCOUNT)
        {
            dwFlags -= BSC_DEC;
            return 0;
        }
        return 1;
    }

    inline BOOL WantEnabled (PNVD3DCONTEXT pContext);

    // The next few parts basically parallel various parts fo the driver.
    // They are called just before the various D3D functions are executed
    // to prepare the AA buffers for proper use.

    inline void BeginScene (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) Create(pContext);
    }

    inline void EndScene (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;

#ifndef WINNT   // WinNT requires that we minify on endscene in windowed apps
        if (mAppCompat.bMinifyUponEndScene)
#endif
        {
            makeRenderTargetValid(pContext);
        }
    }

    inline void Flip (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;

        if (!(dwFlags & AASTATE::FLAG_RT_VALID)) {
            // Don't set both buffers valid unless we are
            // actively making the render target valid.
            makeRenderTargetValid(pContext);
            if (mAppCompat.bDiscardFBContents) {
                // We don't care what happens to the superbuffer after
                // this, so either buffer can be valid
                setFlags(AASTATE::FLAG_SRT_VALID);
            }
        }
    }

    inline void Lock (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeRenderTargetValid(pContext);
    }

    inline void LockZ (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeZetaBufferValid(pContext);
    }

    inline void Unlock (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        //invalidateSRT();
        if (mAppCompat.bAlwaysMagnifyUponUnlock) makeSuperBufferValid(pContext);
    }

    inline void UnlockZ (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        if (mAppCompat.bAlwaysMagnifyUponUnlock) makeSuperZBValid(pContext);
    }

    inline void Rendering (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;

        makeSuperBufferValid(pContext);
        makeSuperZBValid(pContext);
    }

    inline void Minify (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeRenderTargetValid(pContext);
    }

    inline void MinifyZ (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeZetaBufferValid(pContext);
    }

    void Create          (PNVD3DCONTEXT pContext);
    void invalidateState (void);

};

//
// prototypes
//
PNVD3DCONTEXT nvCelsiusAAFindContext         (CSimpleSurface *pSurface);
BOOL          nvCelsiusAACanCreate           (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);
BOOL          nvCelsiusAACreate              (PNVD3DCONTEXT pContext);
BOOL          nvCelsiusAADestroy             (PNVD3DCONTEXT pContext);
void          nvCelsiusAASelectSuperBuffers  (PNVD3DCONTEXT pContext);
void          nvCelsiusAASelectNormalBuffers (PNVD3DCONTEXT pContext,BOOL bPreserveBufferContents);
void          nvCelsiusAAMagnify             (PNVD3DCONTEXT pContext);
void          nvCelsiusAAMinify              (PNVD3DCONTEXT pContext);
void          nvCelsiusAAMagnifyZ            (PNVD3DCONTEXT pContext);
void          nvCelsiusAAMinifyZ             (PNVD3DCONTEXT pContext);


#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSAA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusState.h ===
#ifndef _NVCELSIUSSTATE_H
#define _NVCELSIUSSTATE_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusState.h                                                  *
*     Constants and macros associated with nvCelsiusState.cpp               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   22June99     created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x010)

// general HW capabilities exported to D3D ----------------------------------

#define CELSIUS_MAXVERTEXCOUNT                    32768
#define CELSIUS_MAXBUFFERSIZE                     0

#define CELSIUS_CAPS_GUARD_BAND_LEFT             -1.0e8f  // nv10 can use a guardband as large as 1e25, but 1e8 appears
#define CELSIUS_CAPS_GUARD_BAND_TOP              -1.0e8f  // to be the largest value that the game re-volt will handle.
#define CELSIUS_CAPS_GUARD_BAND_RIGHT             1.0e8f  // anything larger aggravates an app bug that causes it to
#define CELSIUS_CAPS_GUARD_BAND_BOTTOM            1.0e8f  // send us completely broken geometry.

#define CELSIUS_CAPS_MAX_TEXTURE_REPEAT           8192 // the constraint on nv10 is actually du/dx < 8192
#define CELSIUS_CAPS_MAX_TEXTURE_ASPECT_RATIO     0
#define CELSIUS_CAPS_MAX_ANISOTROPY               2    // Means we support anisotropic filtering.
#define CELSIUS_CAPS_EXTENTS_ADJUST               0

#define CELSIUS_CAPS_MAX_UV_PAIRS                 8    // Number of texture uv's supported.

#define CELSIUS_CAPS_FVF_CAPS                     (CELSIUS_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define CELSIUS_CAPS_MAX_TEXTURE_BLEND_STATES     8
#define CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES    2

// DX7 stuff
#define CELSIUS_CAPS_MAX_ACTIVE_LIGHTS            8
#define CELSIUS_CAPS_MAX_USER_CLIP_PLANES         0    // we can do 4, but it's not orthogonal to texturing, so WHQL won't let us export it
#define CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES    2

// DX8 stuff
#define CELSIUS_CAPS_MAX_STREAMS                  16
#define CELSIUS_CAPS_MAX_PSHADER_CONSTS           16
#define CELSIUS_CAPS_MAX_VSHADER_CONSTS           0
#define CELSIUS_CAPS_MAX_VSHADER_TEMPS            0

// general HW capabilities used internally by driver ------------------------

#define CELSIUS_NUM_COMBINERS            2           // virtual combiner stages
#define CELSIUS_NUM_TEXTURES             2           // texture units

#define CELSIUS_ALIGNMENT_MIN           64
#define CELSIUS_PAGE_MASK               0xfffff000

#define CELSIUS_VIEWPORT_BOUND          2048

// Because our h/w is OpenGL'ized, we must D3D'ize it by adding 0.5 so
// that D3D pixels line up with OpenGL pixels.  Halfsubpixelbias is
// to adjust for floating point numbers which are not accurately
// represented.  E.g., -.7 is actually represented as -.699999
// If coordinates were only positive, this would be ok since it would
// result in being just to the left of the pixel center (integer coord).
// But, since the viewport is -2K...2K and the negative portion is used
// first, we actually end up being to the right of pixel center.
// Since the h/w doesn't do rounding to nearest 1/16 of a pixel, we
// adjust this here by subtracting 1/32 to round it.
#define CELSIUS_D3D2OGL                 0.5f
#define CELSIUS_HALFSUBPIXELBIAS        0.03125f     // round to nearest 1/16 pixel grid
#define CELSIUS_BORDER                  (-CELSIUS_VIEWPORT_BOUND + CELSIUS_D3D2OGL - CELSIUS_HALFSUBPIXELBIAS)

#define TEXTUREPM                       0xCAFEBEEF   // arbitrary identifier
#define TSS_USES_NULL_TEXTURE           0x1

#define CELSIUS_MAX_WINDOWS             8

#define CELSIUS_Z_SCALE16               65535.0f     // 2^16 - 1
#define CELSIUS_Z_SCALE24               16777215.0f  // 2^24 - 1
#define CELSIUS_Z_SCALE16_INV           (1.0f / CELSIUS_Z_SCALE16)
#define CELSIUS_Z_SCALE24_INV           (1.0f / CELSIUS_Z_SCALE24)

// maximum vertices = maximum method data size / maximum vertex size
//                  = 2^11 DWORDs / 16 DWORDs
//                  = 128
#define CELSIUS_MAX_INLINE_VERTICES     120

// maximum fog scale = 2^13. (the HW has 14 bits. we leave one for roundoff)
#define CELSIUS_MAX_FOG_SCALE           8192.0f

#define NONINC_METHOD(method) (0x40000000 | method)

// combiner input masks
#define CELSIUS_COMBINER_A_SOURCE_MASK  0x0f000000
#define CELSIUS_COMBINER_B_SOURCE_MASK  0x000f0000
#define CELSIUS_COMBINER_C_SOURCE_MASK  0x00000f00
#define CELSIUS_COMBINER_D_SOURCE_MASK  0x0000000f

// combiner inputs
typedef enum _celsiusCombinerInput {
    celsiusCombinerInputA = 0,
    celsiusCombinerInputB = 1,
    celsiusCombinerInputC = 2,
    celsiusCombinerInputD = 3,
} celsiusCombinerInput;

// the positions of the inputs in the input control words
static DWORD celsiusCombinerInputShift[4] = {24, 16, 8, 0};

//---------------------------------------------------------------------------
// dirty bits

// celsius uses 0x0000FFFF
// kelvin  uses 0xFFFF0000
#define CELSIUS_DIRTY_DEFAULTS          0x00000001
#define CELSIUS_DIRTY_TL_MODE           0x00000002
#define CELSIUS_DIRTY_FVF               0x00000004
#define CELSIUS_DIRTY_SURFACE           0x00000008
#define CELSIUS_DIRTY_TRANSFORM         0x00000010
#define CELSIUS_DIRTY_TEXTURE_TRANSFORM 0x00000020
#define CELSIUS_DIRTY_CONTROL0          0x00000040
#define CELSIUS_DIRTY_COMBINERS         0x00000080
#define CELSIUS_DIRTY_TEXTURE_STATE     0x00000100
#define CELSIUS_DIRTY_LIGHTS            0x00000200
#define CELSIUS_DIRTY_MISC_STATE        0x00000400
#define CELSIUS_DIRTY_SPECFOG_COMBINER  0x00000800
#define CELSIUS_DIRTY_PIXEL_SHADER      0x00001000

#define CELSIUS_DIRTY_REALLY_FILTHY     (CELSIUS_DIRTY_DEFAULTS          | \
                                         CELSIUS_DIRTY_TL_MODE           | \
                                         CELSIUS_DIRTY_FVF               | \
                                         CELSIUS_DIRTY_SURFACE           | \
                                         CELSIUS_DIRTY_TRANSFORM         | \
                                         CELSIUS_DIRTY_TEXTURE_TRANSFORM | \
                                         CELSIUS_DIRTY_CONTROL0          | \
                                         CELSIUS_DIRTY_COMBINERS         | \
                                         CELSIUS_DIRTY_TEXTURE_STATE     | \
                                         CELSIUS_DIRTY_LIGHTS            | \
                                         CELSIUS_DIRTY_MISC_STATE        | \
                                         CELSIUS_DIRTY_SPECFOG_COMBINER  | \
                                         CELSIUS_DIRTY_PIXEL_SHADER)

//---------------------------------------------------------------------------

// values for the texture stage <=> texture unit mappings
#define CELSIUS_UNUSED                          0xdeadbeef
#define CELSIUS_COMBINER_REG_TEX0               0x00000008      // the combiner's first texture register
                                                                // (data from first texture unit provided we always pack the tex units)

// values for texture unit status
#define CELSIUS_TEXUNITSTATUS_IDLE              0x00000000      // texture unit is unused
#define CELSIUS_TEXUNITSTATUS_USER              0x00000001      // texture unit has a real user-supplied texture
#define CELSIUS_TEXUNITSTATUS_DEFAULT           0x00000002      // texture unit has the default texture
#define CELSIUS_TEXUNITSTATUS_CLIP              0x00000004      // texture unit is being used to handle user clip plnes

#define CELSIUS_TEX_MATRIX_HACK_THRESHOLD       0.0001f         // the value that the broken element must exceed
                                                                // before the texture matrix hack will be enabled.

// general celsius state flags
#define CELSIUS_FLAG_PASSTHROUGHMODE            0x00000001      // are we in passthrough mode?
#define CELSIUS_FLAG_ZFOG                       0x00000002      // are we using z for fog?
#define CELSIUS_FLAG_TEXSTATENEEDSINVMV         0x00000004      // inverse modelview matrix is needed b/c of texture state
#define CELSIUS_FLAG_LIGHTINGNEEDSINVMV         0x00000008      // inverse modelview matrix is needed b/c of light state
#define CELSIUS_FLAG_COMBINERSNEEDSPECULAR      0x00000010      // specular is referenced as a combiner (TSS) input
#define CELSIUS_FLAG_SETUPFAILURE               0x00000020      // did we fail to give the app what it really wanted for one reason or another?
#define CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE    0x00000040

// per-texture-unit and per-combiner state flags
#define CELSIUS_FLAG_USERTEXCOORDSNEEDED(i)     (0x00000100 << (4*(i)))  // are user texture coordinates needed by HW texture unit i?
#define CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(i)  (0x00000200 << (4*(i)))  // are we using the hack to get around broken cube maps in passthru mode?
#define CELSIUS_FLAG_TEXMATRIXHACK(i)           (0x00000400 << (4*(i)))  // are we using the hack to get around a broken texture matrix in unit i?
#define CELSIUS_FLAG_TEXMATRIXSWFIX(i)          (0x00000800 << (4*(i)))  // this stage needs a full SW work-around for the broken texture matrix
#define CELSIUS_FLAG_WDIVIDE(i)                 (0x00010000 << (4*(i)))  // is w-divide enabled in HW texture unit i?
#define CELSIUS_FLAG_WSOURCE(i)                 (0x00020000 << (4*(i)))  // can w be sourced from this unit for the purposes of w-buffering?
#define CELSIUS_FLAG_DOTPRODUCT3(i)             (0x00040000 << (4*(i)))  // this stage uses DOTPRODUCT3 as a colorop
#define CELSIUS_FLAG_ADDCOMPLEMENTRGB(i)        (0x00080000 << (4*(i)))  // this stage uses nv4's ADDCOMPLEMENT as a colorop
#define CELSIUS_FLAG_ADDCOMPLEMENTALPHA(i)      (0x01000000 << (4*(i)))  // this stage uses nv4's ADDCOMPLEMENT as an alphaop

#ifdef STOMP_TEX_COORDS
#define CELSIUS_FLAG_STOMP_4TH_COORD(i)         (0x02000000 << (4*(i)))  // stupid app fix: stomp 4th texcoord to 1.0 when they moronically send down extraneous coordinates

#define CELSIUS_FLAG_STOMP_4TH_COORD_MASK       (CELSIUS_FLAG_STOMP_4TH_COORD(0) | CELSIUS_FLAG_STOMP_4TH_COORD(1))
#endif  // STOMP_TEX_COORDS

#define CELSIUS_MASK_TEXMATRIXHACKS             (CELSIUS_FLAG_TEXMATRIXHACK(0)  | CELSIUS_FLAG_TEXMATRIXHACK(1) |   \
                                                 CELSIUS_FLAG_TEXMATRIXSWFIX(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))

#ifdef STOMP_TEX_COORDS
#define CELSIUS_MASK_INNERLOOPUNIQUENESS        (CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)    | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)    |    \
                                                 CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |    \
                                                 CELSIUS_FLAG_TEXMATRIXHACK(0)          | CELSIUS_FLAG_TEXMATRIXHACK(1)          |    \
                                                 CELSIUS_FLAG_TEXMATRIXSWFIX(0)         | CELSIUS_FLAG_TEXMATRIXSWFIX(1)         |    \
                                                 CELSIUS_FLAG_STOMP_4TH_COORD(0)        | CELSIUS_FLAG_STOMP_4TH_COORD(1))
#else  // !STOMP_TEX_COORDS
#define CELSIUS_MASK_INNERLOOPUNIQUENESS        (CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)    | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)    |    \
                                                 CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |    \
                                                 CELSIUS_FLAG_TEXMATRIXHACK(0)          | CELSIUS_FLAG_TEXMATRIXHACK(1)          |    \
                                                 CELSIUS_FLAG_TEXMATRIXSWFIX(0)         | CELSIUS_FLAG_TEXMATRIXSWFIX(1))
#endif  // !STOMP_TEX_COORDS

#define CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS  (CELSIUS_FLAG_DOTPRODUCT3(0) | CELSIUS_FLAG_DOTPRODUCT3(1) | CELSIUS_FLAG_COMBINERSNEEDSPECULAR)

#define CELSIUS_SET_NUM_TEX_COORDS(stage,num)   ((num) << (4*(stage)))
#define CELSIUS_GET_NUM_TEX_COORDS(value,stage) (((value) >> (4*(stage))) & 0xf)

// inner loop constants
#define CELSIUS_ILMASK_PRIMTYPE        0x0000ffff
#define CELSIUS_ILFLAG_LEGACY          0x00010000  // use legacy strides
#define CELSIUS_ILFLAG_CMHACK          0x00020000  // use tex matrix hack vertex copy routine
#define CELSIUS_ILFLAG_NOCULL          0x00040000  // no culling

#define CELSIUS_ILMASK_LOOPTYPE        0xf0000000  // type of inner loop
#define CELSIUS_ILFLAG_IX_VB_PRIM      0x00000000
#define CELSIUS_ILFLAG_IX_STR_PRIM     0x10000000
#define CELSIUS_ILFLAG_IX_INL_PRIM     0x20000000
#define CELSIUS_ILFLAG_IX_INL_TRI_LIST 0x40000000
#define CELSIUS_ILFLAG_IX_DVB_TRI      0x60000000
#define CELSIUS_ILFLAG_OR_VB_PRIM      0x80000000
#define CELSIUS_ILFLAG_OR_STR_PRIM     0x90000000
#define CELSIUS_ILFLAG_OR_INL_PRIM     0xa0000000
#define CELSIUS_ILFLAG_OR_INL_TRI_LIST 0xc0000000
#define CELSIUS_ILFLAG_SUPER_TRI_LIST  0xe0000000

#define CELSIUS_SHORT_INDEXED_PRIM_COUNT_CUTOFF     25    // prim length before we introduce culling
#define CELSIUS_SHORT_ORDERED_PRIM_COUNT_CUTOFF     25

// xPipe / Super-tri constants
#define CELSIUS_CULLFLAG_MODELOK       0x00000001

// xPipe / Super-tri inner loop flags. These ought to be in the inner loop flags above, but we don't have enough
// flag bits.
#define CELSIUS_STILFLAG_STDEFVB       0x00000001  // default VB is used (affects supertri logic)
#define CELSIUS_STILFLAG_MODEL         0x00000002  // Model Culling
#define CELSIUS_STILFLAG_XFORM         0x00000004  // Xform / clipcheck / cull
#define CELSIUS_STILFLAG_HIBW          0x00000008  // High bandwidth mode -- check all triangles

#ifdef WIN2K_DX7OPT
// copy of system memory vertices into hardware readable VB's
#define CELSIUS_CPFLAG_SYS2AGP         0x00000001
#define CELSIUS_CPFLAG_RESTORE         0x00000002
#define CELSIUS_CPFLAG_UPDATEMAP       0x00000004
#endif

// types
typedef void (__stdcall *CELSIUSDISPATCHPRIMITIVE)(void);

#ifdef STATE_CULL
#define CELSIUS_HWSTATE_SIZE (0x1000 >> 2)
#endif

//---------------------------------------------------------------------------

// forward definitions
class CVertexShader;

//---------------------------------------------------------------------------

// information about the state of the celsius object. these values are:
// a. shadowed from the HW so we can detect changes, or
// b. derived from several others and cached here to avoid
//    lengthy recalculation every time they're needed

class CCelsiusState
{
    //
    // intermediate state
    //
public:
#ifdef STATE_CULL
    DWORD hwState[CELSIUS_HWSTATE_SIZE];                // shadow of the hw state
    DWORD valid[CELSIUS_HWSTATE_SIZE];                  // shadow state invalidation
#endif

// bank
    DWORD          dwZEnable;                           // z-buffering? w-buffering?
    DWORD          dwSavedTexUnitToTexStageMapping[2];  // backup of mapping state so that pixel shaders can restore state when disabled
    DWORD          pfnVertexCopy;                       // routine that copies the actual vertices
    DWORD          _pad4[2];
// bank
#ifdef WIN2K_DX7OPT
    DWORD          dwSTBuff_VBOffset;                 // SuperTriangle lookaside buffer vertex buffer offset
    DWORD          dwCPFlags;                         // Copy flags
    DWORD          dw_DP2VertexLength;                // pdp2d->dwVertexLength
    DWORD          dw_DP2VertexOffset;                // pdp2d->dwVertexOffset
    DWORD          dwPromoVBOffset;
    CVertexBuffer *pPromo_DP2VertexBuffer;            // Pointer to promoted vertex buffer supplied by DP2 (or NULL)
    CVertexBuffer *pSave_VertexBufferInUse;           // vertex buffer to program in SetCelsiusState
    DWORD          _pad5[1];
#endif

//////////////////////////////////////////////////////////////////////////////
// smart celsius
//////////////////////////////////////////////////////////////////////////////

public:
    // workaround for a nv10 decode bug. fixed for all other chips, but harmless if used
    // apply before the following methods:-
    //   NV056_SET_SURFACE_CLIP_HORIZONTAL
    //   NV056_SET_SURFACE_CLIP_VERTICAL
    //   NV056_SET_SURFACE_FORMAT
    //   NV056_SET_SURFACE_PITCH
    //   NV056_SET_SURFACE_COLOR_OFFSET
    //   NV056_SET_SURFACE_ZETA_OFFSET
    //   NV056_SET_FOG_MODE
    //   NV056_SET_WINDOW_CLIP_TYPE
    //   NV056_SET_WINDOW_CLIP_HORIZONTAL(i)
    //   NV056_SET_WINDOW_CLIP_VERTICAL(i)
    __forceinline void prep_wait_for_idle_nv10 (void)
    {
        nvPushData (0,0x00040000 | (NV_DD_CELSIUS << 13) | NV056_NO_OPERATION);
        nvPushData (1,0);
        nvPusherAdjust (2);
    }
    void set (DWORD dwOffset, DWORD dwData0)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                valid[dwIndex] = 1;
            }
        }
        if (bSend) 
#endif
        {
            getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.adjust (2);
        }
    }
    void set2 (DWORD dwOffset, DWORD dwData0, DWORD dwData1)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (hwState[dwIndex+1] != dwData1) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                hwState[dwIndex+1] = dwData1;
                valid[dwIndex] = 1;
            }
        }
        if (bSend)
#endif
        {
            getDC()->nvPusher.push (0, 0x00080000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.push (2, dwData1);
            getDC()->nvPusher.adjust (3);
        }
    }
    void set3 (DWORD dwOffset, DWORD dwData0, DWORD dwData1, DWORD dwData2)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (hwState[dwIndex+1] != dwData1) ||
                (hwState[dwIndex+2] != dwData2) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                hwState[dwIndex+1] = dwData1;
                hwState[dwIndex+2] = dwData2;
                valid[dwIndex] = 1;
            }
        }
        if (bSend)
#endif
        {
            getDC()->nvPusher.push (0, 0x000C0000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.push (2, dwData1);
            getDC()->nvPusher.push (3, dwData2);
            getDC()->nvPusher.adjust (4);
        }
    }
    void set4 (DWORD dwOffset, DWORD dwData0, DWORD dwData1, DWORD dwData2, DWORD dwData3)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (hwState[dwIndex+1] != dwData1) ||
                (hwState[dwIndex+2] != dwData2) ||
                (hwState[dwIndex+3] != dwData3) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                hwState[dwIndex+1] = dwData1;
                hwState[dwIndex+2] = dwData2;
                hwState[dwIndex+3] = dwData3;
                valid[dwIndex] = 1;
            }
        }
        if (bSend)
#endif
        {
            getDC()->nvPusher.push (0, 0x00100000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.push (2, dwData1);
            getDC()->nvPusher.push (3, dwData2);
            getDC()->nvPusher.push (4, dwData3);
            getDC()->nvPusher.adjust (5);
        }
    }

    //////////////////////////////////////////////////////////////////////////

    __forceinline void setf (DWORD dwOffset,float fData)
    {
        set (dwOffset,*(DWORD*)&fData);
    }
    __forceinline void set2f (DWORD dwOffset,float fData0,float fData1)
    {
        set2(dwOffset, *(DWORD*)&fData0, *(DWORD*)&fData1);
    }
    __forceinline void set3f (DWORD dwOffset,float fData0,float fData1,float fData2)
    {
        set3(dwOffset, *(DWORD*)&fData0, *(DWORD*)&fData1, *(DWORD*)&fData2);
    }
    __forceinline void set4f (DWORD dwOffset,float fData0,float fData1,float fData2,float fData3)
    {
        set4(dwOffset, *(DWORD*)&fData0, *(DWORD*)&fData1, *(DWORD*)&fData2, *(DWORD*)&fData3);
    }

    //////////////////////////////////////////////////////////////////////////
    // for cubemapping we need to move r into q's slot since HW can't actually see r and uses q instead
    // if the user doesn't give us a texture transform, just use a munged identity matrix
    void setTextureTransformMatrixCubeMapIdent (DWORD dwName)
    {
        set4f (dwName +  0,1.0f,0.0f,0.0f,0.0f);
        set4f (dwName + 16,0.0f,1.0f,0.0f,0.0f);
        set4f (dwName + 32,0.0f,0.0f,0.0f,0.0f);
        set4f (dwName + 48,0.0f,0.0f,1.0f,0.0f);
    }
    // if the user gave a matrix, move the third column to the 4th and transpose
    void setTextureTransformMatrixCubeMap (DWORD dwName,D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0,pMatrix->_11,pMatrix->_21,pMatrix->_31,pMatrix->_41);
        set4f (dwName + 16,pMatrix->_12,pMatrix->_22,pMatrix->_32,pMatrix->_42);
        set4f (dwName + 32,0.0f,        0.0f,        0.0f,        0.0f        );
        set4f (dwName + 48,pMatrix->_13,pMatrix->_23,pMatrix->_33,pMatrix->_43);
    }

    // the form of the texture transform matrix varies depending on the number
    // of texture coords and on whether or not projection is enabled.
    // 1.) if there are two texture coordinates, then only the upper left
    // 3x3 is used. openGL and kelvin, however, always put q in the fourth position.
    // for these cases, we need to expand the 3x3 to a 4x4 and then transpose
    // 2.) if projection is disabled it is OUR reponsibility to override the
    // last column of the matrix with [0 0 0 1]' to produce q==1.0
    // type A : expand, override, and transpose
    void setTextureTransformMatrixTypeA (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // type B : override, and transpose
    void setTextureTransformMatrixTypeB (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // type C : expand and transpose
    void setTextureTransformMatrixTypeC (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
    }
    // type D : just transpose
    void setTextureTransformMatrixTypeD (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
    }

    void setInverseModelViewMatrix (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_12, pMatrix->_13, pMatrix->_14);
        set4f (dwName + 16, pMatrix->_21, pMatrix->_22, pMatrix->_23, pMatrix->_24);
        set4f (dwName + 32, pMatrix->_31, pMatrix->_32, pMatrix->_33, pMatrix->_34);
    }

    // transpose the matrix since d3d does {v}[M] instead of [M]{v}'
    void setMatrixTransposed (DWORD dwName,D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, pMatrix->_34, pMatrix->_44);
    }

    //////////////////////////////////////////////////////////////////////////

    void setMatrixIdent (DWORD dwName)
    {
        set4f (dwName +  0,1.0f,0.0f,0.0f,0.0f);
        set4f (dwName + 16,0.0f,1.0f,0.0f,0.0f);
        set4f (dwName + 32,0.0f,0.0f,1.0f,0.0f);
        set4f (dwName + 48,0.0f,0.0f,0.0f,1.0f);
    }

    //////////////////////////////////////////////////////////////////////////

public:
    inline void queueTLNOP (void)
    {
        getDC()->nvPusher.push (0,0x00040000 | (NV_DD_CELSIUS << 13) | NV056_TL_NOP);
        getDC()->nvPusher.push (1,0);
        getDC()->nvPusher.adjust (2);
    }

public:
};

// prototypes ---------------------------------------------------------------

// update all state of the celsius object
// should be called prior to rendering
HRESULT __stdcall nvSetCelsiusState        (PNVD3DCONTEXT pContext);
HRESULT           nvSetCelsiusVertexFormat (PNVD3DCONTEXT pContext);
HRESULT           nvSetCelsiusTextureState (PNVD3DCONTEXT pContext);
HRESULT           nvSetCelsiusMiscState    (PNVD3DCONTEXT pContext);

CELSIUSDISPATCHPRIMITIVE nvCelsiusGetDispatchRoutine (PNVD3DCONTEXT pConext,DWORD dwFlags);

#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSSTATE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusTables.h ===
#ifndef _NVCELSIUSTABLES_H
#define _NVCELSIUSTABLES_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusTables.h                                                 *
*     Constants and macros associated with nvCelsiusTables.cpp              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)    23June99    created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x010)

// table for looking up pre-computed combiner settings for legacy texture blends
extern DWORD celsiusTextureBlendSettings[D3D_TBLEND_MAX+1][4];
extern DWORD celsiusTextureBlendDefault[4];

// table of dependencies between d3d renderstates and celsius state
extern DWORD celsiusDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1];

// table of dependencies between d3d texture stage states and celsius state
extern DWORD celsiusDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1];

// table mapping dp2ops to the celsius method values associated with them.
extern DWORD celsiusBeginEndOp[D3D_DP2OP_MAX+1];

// table mapping dp2ops to the scale and bias required to calculate
// the number of vertices from the number of primitives.
extern DWORD celsiusPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1];

#ifdef DEBUG
// table for primitive names
extern char* celsiusPrimitiveName[D3D_DP2OP_MAX+1];
#endif

#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSTABLES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusStateHelp.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusStateHelp.h
//      Constants, macros, and prototypes for nvCelsiusStateHelp.cpp
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        27Sep99         created
//
// **************************************************************************

#ifndef _NVCELSIUSSTATEHELP_H
#define _NVCELSIUSSTATEHELP_H

#if (NVARCH >= 0x010)

// combiner program hash table stuff

#define D3DTA_FLAGMASK           (D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE)
#define NVTSSARGMASK(dwArg)      ((dwArg & D3DTA_SELECTMASK) | ((dwArg & D3DTA_FLAGMASK) >> 1))

#define CELSIUSCPTABLE_INDEXMASK 0x7f  // should be <= 0xff
#define CELSIUSCPTABLE_SIZE      (CELSIUSCPTABLE_INDEXMASK+1)

typedef struct __CELSIUSCOMBINERPROGRAM {
    // tags
    DWORD dwTSSMask0;
    DWORD dwTSSMask1;
    // data
    DWORD dwStateFlags;
    DWORD dwColorICW[2];
    DWORD dwColorOCW[2];
    DWORD dwAlphaICW[2];
    DWORD dwAlphaOCW[2];
    DWORD dwTexUnitMapping[2];
    DWORD dwNumActiveStages;
    // link to resolve hash collisions
    struct __CELSIUSCOMBINERPROGRAM *pNext;
} CELSIUSCOMBINERPROGRAM, *PCELSIUSCOMBINERPROGRAM;

//---------------------------------------------------------------------------

// prototypes

void  explut (float n, float *l, float *m);
DWORD nvCelsiusBuildTSSMask                   (PNVD3DCONTEXT pContext, DWORD dwStage);
BOOL  nvCelsiusCombinersSetFromHashTable      (PNVD3DCONTEXT pContext, DWORD dwTSSMask0, DWORD dwTSSMask1);
void  nvCelsiusCombinersAddProgramToHashTable (PCELSIUSCOMBINERPROGRAM pProgram);
BOOL  nvCelsiusCombinersAddToHashTable        (PNVD3DCONTEXT pContext, DWORD dwTSSMask0, DWORD dwTSSMask1);
DWORD nvCelsiusValidateTextureStageState      (LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);

#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSSTATEHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusAA.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusAA.cpp                                                   *
*   Celsius antialiasing                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             11Jan2000       NV15 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x10)

//////////////////////////////////////////////////////////////////////////////
// super buffer info
//
struct AAMETHODINFO
{
    float fXScale;
    float fYScale;
    DWORD dwLODBias;
    DWORD dwLinePointSize; 
};

static AAMETHODINFO g_aAAMethodInfo[] =
{
   // X     Y     bias(4.4) line/point size (6.3)
    { 1.0f, 2.0f, 0x00,          0x0C           },// 1x2
    { 2.0f, 2.0f, 0x10,          0x10           },// 2x2 lod
    { 2.0f, 2.0f, 0x00,          0x10           },// 2x2
    { 2.0f, 2.0f, 0x00,          0x10           },// 2x2 spec
    { 3.0f, 3.0f, 0x19,          0x18           },// 3x3 lod
    { 3.0f, 3.0f, 0x00,          0x18           },// 3x3
    { 4.0f, 4.0f, 0x20,          0x20           },// 4x4 lod
    { 4.0f, 4.0f, 0x00,          0x20           },// 4x4
};

// Methods starting with this one require a temporary work space for blits.
#define FIRST_TEMP_SPACE_METHOD 3

__declspec(dllexport) void nvCelsiusAAInitCompatibilitySettings();
__declspec(dllexport) void nvCelsiusAAGetCompatibilitySettings(PNVD3DCONTEXT);

extern char* nvGetCommandLine();

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAFindContext
//
PNVD3DCONTEXT nvCelsiusAAFindContext
(
    CSimpleSurface *pSurface
)
{

    //if the surface is NULL (i.e. we tried to get a CSimpleSurface from
    //a CTexture object this will be null.  Combine that with a NULL zbuffer
    //and we'll return a context that matches.  BAD.

    if(!pSurface) return NULL;

    // AA is enabled for some context. Now we have to find out which one
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        // is this the one?
        if (pContext->pZetaBuffer == pSurface)
        {
            return pContext;
        }
        if (pContext->pRenderTarget == pSurface)
        {
            return pContext;
        }

        // next
        pContext = pContext->pContextNext;
    }

    // not found
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAACanCreate
//
BOOL nvCelsiusAACanCreate
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl
)
{
    //
    // figure out if we have enough memory to create AA buffers.
    //  AA may still fail if the memory is not available at nvCelsiusAACreate() time which
    //  is invoked when AA renderstate is set (i.e. this function may give false positives).
    //

    //
    // does registry allow it and do we have to right AA bits set
    //
    DWORD dwCaps  = pDDSLcl->ddsCaps.dwCaps;
    DWORD dwCaps2 = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2;
    if (!(dwCaps & DDSCAPS_3DDEVICE)
     || !(dwCaps2 & DDSCAPS2_HINTANTIALIASING)
     || !(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK))
    {
        return TRUE; // since AA is not enabled, allow creation to continue
    }

    //
    // extract surface info
    //
    DWORD dwBufferWidth  = pDDSLcl->lpGbl->wWidth;
    DWORD dwBufferHeight = pDDSLcl->lpGbl->wHeight;

    DWORD dwBufferBPP    = (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
                         ? (pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount / 8)
                         : (GET_MODE_BPP() / 8);

    //
    // try all combinations
    //
    DWORD dwAAMethodMax = getDC()->nvD3DRegistryData.regAntiAliasQuality - 1;
    for (DWORD dwAAMethod = dwAAMethodMax; !(dwAAMethod & 0x80000000); dwAAMethod--)
    {
        //
        // set up data
        //
        float fWidthAmplifier  = g_aAAMethodInfo[dwAAMethod].fXScale;
        float fHeightAmplifier = g_aAAMethodInfo[dwAAMethod].fYScale;

        /*
        //
        // check again if we can AA this buffer
        //
        if (((dwBufferWidth  * fWidthAmplifier)  > 2048.0f)
         || ((dwBufferHeight * fHeightAmplifier) > 2048.0f))
        {
            // next
            continue;
        }
        */


        //
        // see if we can allocate all the memory required by computation
        //   we will have 2 super buffers and usually 3 normal buffers
        //
        DWORD dwMemoryRequired  = DWORD(2 * dwBufferWidth * fWidthAmplifier * dwBufferHeight * fHeightAmplifier * dwBufferBPP
                                      + 3 * dwBufferWidth *                   dwBufferHeight *                    dwBufferBPP);
              dwMemoryRequired += dwMemoryRequired / 20; // add 5% wastage

        if (dwMemoryRequired > (DWORD)pDriverData->VideoHeapTotal)
        {
            continue;
        }

        //
        // this looks like a good combination - accept
        //
        return TRUE;
    }

    //
    // none found - fail
    //
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAACreate
//
BOOL nvCelsiusAACreate
(
    PNVD3DCONTEXT pContext
)
{    
    dbgTracePush ("nvCelsiusAACreate");
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {   // Kelvin has it's own AA functions
        dbgTracePop();
        return FALSE;
    }

    if (pContext->aa.mAppCompat.bNoAA){
        dbgTracePop();
        return FALSE;
    }

    //
    // check if this is really a celsius machine
    //
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
    {
        // no, clear the reg bit and bye bye
        getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASENABLE_MASK;
        dbgTracePop();
        return FALSE;
    }

    //
    // check if we can AA this buffer
    //
    if (!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) // aa enabled
     || !pContext->pRenderTarget                        // must exist
     || pContext->pRenderTarget->isSwizzled())          // cannot be swizzled
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvCelsiusAACreate: AA failed because render target either does not exist or it is swizzled.");
        dbgTracePop();
        return FALSE;
    }

    // do not AA when rendering to texture
    if (pContext->pRenderTarget->getWrapper()->getTexture()) {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvCelsiusAACreate: AA failed because render target is a texture.");
        dbgTracePop();
        return FALSE;
    }

    // extract current render buffer information
    //
    DWORD           dwBufferWidth  = pContext->pRenderTarget->getWidth();
    DWORD           dwBufferHeight = pContext->pRenderTarget->getHeight();
    CSimpleSurface *pRenderTarget  = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer    = pContext->pZetaBuffer;

    //objects created already?
    if (pContext->aa.isInit())
    {
        //check whether the target dimension changed
        //if not, save some work, keep the old AA buffer
        if ((dwBufferWidth        == pContext->aa.dwOriginalRenderTargetWidth)
         && (dwBufferHeight       == pContext->aa.dwOriginalRenderTargetHeight)
         && (pContext->dwZBHandle == pContext->aa.dwOriginalZBHandle))
        {
            dbgTracePop();
            return TRUE;
        }
        //if the dimension changed, destroy the old aa buffer and continue to build a new one
        else
            nvCelsiusAADestroy(pContext);
    }

    nvCelsiusAAInitCompatibilitySettings();
    nvCelsiusAAGetCompatibilitySettings(pContext);

    // This one is needed to catch the first pass through
    if (pContext->aa.mAppCompat.bNoAA) return FALSE;

    //initialize the original RenderTarget dimension
    pContext->aa.dwOriginalRenderTargetWidth  = dwBufferWidth;
    pContext->aa.dwOriginalRenderTargetHeight = dwBufferHeight;
    pContext->aa.dwOriginalZBHandle           = pContext->dwZBHandle;

    DWORD dwAAMethodMax;

    // attempt to find the highest quality super buffer
    if (pContext->pRenderTarget && (pContext->pRenderTarget->getMultiSampleBits() > 1)) {
        if (pContext->pRenderTarget->getMultiSampleBits() == 2) {
            dwAAMethodMax = 0;
        } else if (pContext->pRenderTarget->getMultiSampleBits() == 4) {
            dwAAMethodMax = 2;
        } else {
            DPF("Bad number of multisample bits: %d", pContext->pRenderTarget->getMultiSampleBits());
            dbgD3DError();
        }
    } else {
        dwAAMethodMax = getDC()->nvD3DRegistryData.regAntiAliasQuality - 1;
    }

    for (DWORD dwAAMethod = dwAAMethodMax; !(dwAAMethod & 0x80000000); dwAAMethod--)
    {
        //
        // set up data
        //

        //Smetimes we dont want to allow special setting
        if ((dwAAMethod  == AASTATE::METHOD_2x2spec) && !(pContext->aa.mAppCompat.bAllowSpecial))
            continue;

        // never allow us to drop down to 2x2 special.
        // Only allow it if it is explicitly requested.
        if ((dwAAMethod == AASTATE::METHOD_2x2spec) && (dwAAMethodMax > AASTATE::METHOD_2x2spec))
            continue;

        pContext->aa.fWidthAmplifier  = g_aAAMethodInfo[dwAAMethod].fXScale;
        pContext->aa.fHeightAmplifier = g_aAAMethodInfo[dwAAMethod].fYScale;
        pContext->aa.fLODBias         = float(g_aAAMethodInfo[dwAAMethod].dwLODBias) / 16.0f;
        pContext->aa.dwDepthAmplifier = 1;
        pContext->aa.dwLinePointSize  = g_aAAMethodInfo[dwAAMethod].dwLinePointSize;
        pContext->aa.modFlags (~AASTATE::MASK_METHOD,dwAAMethod);
        DPF_LEVEL (NVDBG_LEVEL_INFO,"Attempting %fx%f...",pContext->aa.fWidthAmplifier,pContext->aa.fHeightAmplifier);

        /*
        //
        // check again if we can AA this buffer
        //
        if (((dwBufferWidth  * pContext->aa.fWidthAmplifier)  > 2048.0f)
         || ((dwBufferHeight * pContext->aa.fHeightAmplifier) > 2048.0f))
        {
            // next
            DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not addressable.");
            continue;
            
        }
        */

        DWORD dwMem = (DWORD)(2*pContext->aa.fWidthAmplifier*pContext->aa.fHeightAmplifier*pRenderTarget->getBPP()*pRenderTarget->getWidth()*pRenderTarget->getHeight());
        if (dwMem > (DWORD)pDriverData->VideoHeapFree) {
            // next
            continue;
        }

        // create super frame buffer
        //
        pContext->aa.pSuperRenderTarget = new CSimpleSurface;
        if (!pContext->aa.pSuperRenderTarget)
        {
            // failed
            return FALSE;
        }

        // Ask to be created as Tiled memory in the Zbuffer area (Bank 1) -- this reduces memory bank collisions.
        DWORD dwPitch = DWORD(0.5f + pRenderTarget->getWidth() * pContext->aa.fWidthAmplifier * pRenderTarget->getBPP());
              dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

        if (!pContext->aa.pSuperRenderTarget->create(NULL,
                                                     pRenderTarget->getFormat(),
                                                     DWORD(0.5f + pRenderTarget->getWidth()  * pContext->aa.fWidthAmplifier),
                                                     DWORD(0.5f + pRenderTarget->getHeight() * pContext->aa.fHeightAmplifier),
                                                     pRenderTarget->getDepth()               * pContext->aa.dwDepthAmplifier,
                                                     1,
                                                     pRenderTarget->getBPPRequested(),
                                                     pRenderTarget->getBPP(),
                                                     dwPitch,
                                                     pRenderTarget->getHeapLocation(),
                                                     pRenderTarget->getHeapLocation(),
                                                     (CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC)
#ifdef CAPTURE
                                                    ,CAPTURE_SURFACE_KIND_TARGET
#endif
                                                     ))
        {
            // failed - clean up
            delete pContext->aa.pSuperRenderTarget;
            pContext->aa.pSuperRenderTarget = NULL;
            // next
            DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not enough frame buffer space.");
            continue;
        }

        //
        // create super z buffer
        //
        // Ask to be created as Tiled memory to force it to go on Bank 0 --- reduces memory collisions
        if (pZetaBuffer)
        {
            pContext->aa.pSuperZetaBuffer = new CSimpleSurface;
            if (!pContext->aa.pSuperZetaBuffer)
            {
                // failed
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                return FALSE;
            }
            DWORD dwPitch = DWORD(0.5f + pZetaBuffer->getWidth() * pContext->aa.fWidthAmplifier * pZetaBuffer->getBPP());
                  dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            if (!pContext->aa.pSuperZetaBuffer->create(NULL,
                                                         pZetaBuffer->getFormat(),
                                                         DWORD(0.5f + pZetaBuffer->getWidth()  * pContext->aa.fWidthAmplifier),
                                                         DWORD(0.5f + pZetaBuffer->getHeight() * pContext->aa.fHeightAmplifier),
                                                         pZetaBuffer->getDepth()               * pContext->aa.dwDepthAmplifier,
                                                         1,
                                                         pZetaBuffer->getBPPRequested(),
                                                         pZetaBuffer->getBPP(),
                                                         dwPitch,
                                                         pZetaBuffer->getHeapLocation(),
                                                         pZetaBuffer->getHeapLocation(),
                                                         CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                                        ,CAPTURE_SURFACE_KIND_ZETA
#endif
                                                         ))

            {
                // failed - clean up
                delete pContext->aa.pSuperZetaBuffer;
                pContext->aa.pSuperZetaBuffer = NULL;
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                // next
                DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not enough z buffer space.");
                continue;
            }
        }

#ifdef  STEREO_SUPPORT
        if (STEREO_ENABLED)
        {
            pContext->aa.pSuperRenderTarget->tagNotReal();
            pContext->aa.pSuperRenderTarget->createStereo();
            pContext->aa.pSuperZetaBuffer->tagNotReal();
            pContext->aa.pSuperZetaBuffer->createStereo();
        }
#endif  //STEREO_SUPPORT

        //
        // if necessary, create blit temporary space
        //
        if (dwAAMethod >= FIRST_TEMP_SPACE_METHOD) {
            pContext->aa.pBlitTempSpace = new CSimpleSurface;
            if (!pContext->aa.pBlitTempSpace)
            {
                // failed - clean up
                if (pContext->aa.pSuperZetaBuffer) {
                    pContext->aa.pSuperZetaBuffer->destroy();
                    delete pContext->aa.pSuperZetaBuffer;
                    pContext->aa.pSuperZetaBuffer = NULL;
                }
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                return FALSE;
            }
            DWORD dwPitch = 2 * pRenderTarget->getWidth() * pRenderTarget->getBPP();
                  dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            if (!pContext->aa.pBlitTempSpace->create(NULL,
                                                     pRenderTarget->getFormat(),
                                                     pRenderTarget->getWidth()  * 2,
                                                     pRenderTarget->getHeight() * 2,
                                                     pRenderTarget->getDepth()  * pContext->aa.dwDepthAmplifier,
                                                     1,
                                                     pRenderTarget->getBPPRequested(),
                                                     pRenderTarget->getBPP(),
                                                     dwPitch,
                                                     pRenderTarget->getHeapLocation(),
                                                     pRenderTarget->getHeapLocation(),
                                                     CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                                    ,CAPTURE_SURFACE_KIND_TARGET
#endif
                                                     ))
            {
                // failed - clean up
                delete pContext->aa.pBlitTempSpace;
                pContext->aa.pBlitTempSpace = NULL;
                if (pContext->aa.pSuperZetaBuffer) {
                    pContext->aa.pSuperZetaBuffer->destroy();
                    delete pContext->aa.pSuperZetaBuffer;
                    pContext->aa.pSuperZetaBuffer = NULL;
                }
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                // next
                DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not enough blit temporary buffer space.");
                continue;
            }
        }

        // success
        break;
    }
    if (dwAAMethod & 0x80000000)
    {
        pContext->aa.fWidthAmplifier  = 1.0;
        pContext->aa.fHeightAmplifier = 1.0;
        pContext->aa.fLODBias         = 0.0;
        pContext->aa.dwLinePointSize  = 1;
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvCelsiusAACreate: AA failed due to lack of memory or limited drawable area.");
        dbgTracePop();
        return FALSE;
    }

    //
    // update flags
    //
    pContext->aa.modFlags (~(AASTATE::FLAG_ENABLED),
                            (AASTATE::FLAG_INIT));
    pContext->aa.bsReset();
    getDC()->dwAAContextCount ++;

    //walk the pcontext list and update anyone else's pcontext->aa data
    //if they point to the same targets here
    PNVD3DCONTEXT pTempContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
    while (pTempContext) {
        if (pTempContext != pContext && pTempContext->pRenderTarget == pContext->pRenderTarget) {
            pTempContext->aa.pSuperRenderTarget = pContext->aa.pSuperRenderTarget;
            pTempContext->aa.pBlitTempSpace = pContext->aa.pBlitTempSpace;
        }
        if (pTempContext != pContext && pTempContext->pZetaBuffer == pContext->pZetaBuffer) {
            pTempContext->aa.pSuperZetaBuffer = pContext->aa.pSuperZetaBuffer;
        }
        pTempContext = pTempContext->pContextNext;
    }


    // Make wrapper objects
    CNvObject *pWrapper;

    if (pContext->aa.pSuperRenderTarget) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pContext->aa.pSuperRenderTarget);
        pContext->aa.pSuperRenderTarget->setWrapper(pWrapper);
    }

    if (pContext->aa.pSuperZetaBuffer) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pContext->aa.pSuperZetaBuffer);
        pContext->aa.pSuperZetaBuffer->setWrapper(pWrapper);
    }

    pContext->aa.modFlags(~AASTATE::FLAG_SRT_VALID & ~AASTATE::FLAG_SZB_VALID, AASTATE::FLAG_RT_VALID | AASTATE::FLAG_ZB_VALID);

    // Always select super buffers
    nvCelsiusAASelectSuperBuffers(pContext);

    //
    // done
    //
    dbgTracePop();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAADestroy
//
BOOL nvCelsiusAADestroy
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAADestroy");

    //walk the pcontext list and update anyone else's pcontext->aa data
    //if they point to the same targets here

    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;

    PNVD3DCONTEXT pTempContext = pContext;
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext) {

        //
        // do we have AA objects?
        //
        if (pContext->aa.isInit())
        {
            BOOL bDestroyed = FALSE;
            //
            // destroy objects
            //
            if (getDC()->nvPusher.getSize() > 0 &&
                getDC()->nvPusher.isValid()){
                // only do this if push buffer is valid.  This
                // additional check is due to the fact we can get
                // an nvCelsiusAADestroy calling into here AFTER
                // the pushbuffer has been destroyed on Win2K, in
                // this case you can't minify.
                nvCelsiusAASelectNormalBuffers (pContext,TRUE);
            }

            if (pContext == pTempContext) {
                CNvObject *pWrapper = pContext->aa.pSuperRenderTarget->getWrapper();
                if (pWrapper) {
                    pWrapper->release();
                } else {
                    // SRT has no wrapper object!
                    nvAssert(0);
                }
                if (pContext->aa.pSuperZetaBuffer) {
                    pWrapper = pContext->aa.pSuperZetaBuffer->getWrapper();
                    if (pWrapper) {
                        pWrapper->release();
                    } else {
                        // SZB has no wrapper object!
                        nvAssert(0);
                    }
                    bDestroyed = TRUE;
                }
                if (pContext->aa.pBlitTempSpace) {
                    pContext->aa.pBlitTempSpace->destroy();
                    delete pContext->aa.pBlitTempSpace;
                    bDestroyed = TRUE;
                }
            }

            if (pContext->pRenderTarget == pRenderTarget) {
                pContext->aa.pSuperRenderTarget = NULL;
                pContext->aa.pBlitTempSpace = NULL;
                bDestroyed = TRUE;
            }
            if (pContext->pZetaBuffer == pZetaBuffer) {
                pContext->aa.pSuperZetaBuffer = NULL;
                bDestroyed = TRUE;
            }
            if (bDestroyed) {
                //
                // update flags
                //
                pContext->aa.modFlags (~(AASTATE::FLAG_INIT | AASTATE::FLAG_ENABLED),0);
                if(getDC()->dwAAContextCount > 0)
                    getDC()->dwAAContextCount --;
            }
        }
        pContext = pContext->pContextNext;
    }

    dbgTracePop();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAASelectSuperBuffers
//
void nvCelsiusAASelectSuperBuffers
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAASelectSuperBuffers");
/*
    if (!pContext->aa.isSuperCurrent())
    {
        //
        // update state
        //
        pContext->aa.setFlags (AASTATE::FLAG_SUPERCURRENT);
    }
*/
    //
    // done
    //
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAASelectNormalBuffers
//
void nvCelsiusAASelectNormalBuffers
(
    PNVD3DCONTEXT pContext,
    BOOL          bPreserveBufferContents
)
{
    dbgTracePush ("nvCelsiusAASelectNormalBuffers");
/*
    if (pContext->aa.isSuperCurrent())
    {
        //
        // minify buffer if it has valuable information
        //
        if (bPreserveBufferContents)
        {

            nvCelsiusAAMinify (pContext);
        }

        //
        // update state
        //
        pContext->aa.modFlags (~AASTATE::FLAG_SUPERCURRENT,0);
    }
*/
    //
    // done
    //
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAScaledBltHW
//
inline void nvCelsiusAAScaledBltHW
(
    PNVD3DCONTEXT pContext,

    DWORD         dwSrcOffset,
    DWORD         dwSrcPitch,
    DWORD         dwSrcPoint,       // 12.4:12.4
    DWORD         dwSrcSize,        // 16:16                2 <= x <= 2046

    DWORD         dwDstOffset,
    DWORD         dwDstPitch,
    DWORD         dwDstPoint,       // 16:16
    DWORD         dwDstSize,        // 16:16

    DWORD         dwDsDx,           // 12.20
    DWORD         dwDtDy,           // 12.20

    DWORD         dwFormat,
    BOOL          bFOH,
    BOOL          bCenter,
    BOOL          bDither
)
{
    dbgTracePush ("nvCelsiusAAScaledBltHW");

    assert (~nv062SurfaceFormat[dwFormat]);
    assert (~nv089SurfaceFormat[dwFormat]);

    dwSrcSize += 0x00010001;
    dwSrcSize &= 0xfffefffe;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
    nvPushData(1, (SRCCOPY >> 16));
    nvPusherAdjust(2);
    pDriverData->bltData.dwLastRop = (SRCCOPY >> 16);

    /*
    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_SURFACES) | NV062_SET_CONTEXT_DMA_IMAGE_SOURCE | 0x080000);
    nvPushData ( 1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDMAImageSource
    nvPushData ( 2, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDMAImageDestin
    nvPusherAdjust (3);
    */


    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData ( 1, nv062SurfaceFormat[dwFormat]);    // SetColorFormat
    nvPushData ( 2, (dwDstPitch << 16) | dwSrcPitch); // SetPitch
    nvPushData ( 3, dwSrcOffset);                     // SetOffset
    nvPushData ( 4, dwDstOffset);                     // SetOffset
    nvPusherAdjust (5);
    pDriverData->bltData.dwLastColourFormat = nv062SurfaceFormat[dwFormat];
    pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
    nvPushData(3, 0);
    nvPusherAdjust(4);
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
    pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;


    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwDstPoint);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwDstPoint);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDsDx);                 // DsDx
    nvPushData (12, dwDtDy);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (bFOH ? (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24)
                          : (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24)) |     // ImageInFormat
                    (bCenter ? (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16)
                             : (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16)) |
                    dwSrcPitch);
    nvPushData (16, dwSrcOffset);            // ImageInOffset
    nvPushData (17, dwSrcPoint);             // ImageInPoint

    if (bDither) {
        nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
        nvPusherAdjust (20);
    } else {
        nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (19, NV089_SET_COLOR_CONVERSION_TRUNCATE); // SetColorFormat
        nvPusherAdjust (20);
//        nvPusherAdjust (18);
    }

    nvPusherStart (TRUE);

    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;

    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAScaledBlt
//
void nvCelsiusAAScaledBlt
(
    PNVD3DCONTEXT pContext,

    DWORD         dwSrcOffset,
    DWORD         dwSrcPitch,
    DWORD         dwSrcX,           // 12.4
    DWORD         dwSrcY,           // 16
    DWORD         dwSrcWidth,
    DWORD         dwSrcHeight,

    DWORD         dwDstOffset,
    DWORD         dwDstPitch,
    DWORD         dwDstX,           // 16
    DWORD         dwDstY,           // 16
    DWORD         dwDstWidth,
    DWORD         dwDstHeight,

    DWORD         dwDsDx,           // 12.20     assume integer scaling
    DWORD         dwDtDy,           // 12.20

    DWORD         dwFormat,
    BOOL          bFOH,
    BOOL          bCenter,
    BOOL          bDither
)
{
    dbgTracePush ("nvCelsiusAAScaledBlt");

    // limit width
    if (dwSrcWidth > 2046)
    {
        DWORD dwDstSplit = 1024 / (dwDsDx >> 20);
        DWORD dwSrcSplit = dwDstSplit * (dwDsDx >> 20);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX,dwSrcY,dwSrcSplit,dwSrcHeight,
                              dwDstOffset,dwDstPitch,dwDstX,dwDstY,dwDstSplit,dwDstHeight,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX + (dwSrcSplit << 4),dwSrcY,dwSrcWidth - dwSrcSplit,dwSrcHeight,
                              dwDstOffset,dwDstPitch,dwDstX + dwDstSplit,dwDstY,dwDstWidth - dwDstSplit,dwDstHeight,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        return;
    }

    // limit height
    if (dwSrcHeight > 2047)
    {
        DWORD dwDstSplit = 1024 / (dwDtDy >> 20);
        DWORD dwSrcSplit = dwDstSplit * (dwDtDy >> 20);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX,dwSrcY,dwSrcWidth,dwSrcSplit,
                              dwDstOffset,dwDstPitch,dwDstX,dwDstY,dwDstWidth,dwDstSplit,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX,dwSrcY + (dwSrcSplit << 4),dwSrcWidth,dwSrcHeight - dwSrcSplit,
                              dwDstOffset,dwDstPitch,dwDstX,dwDstY + dwDstSplit,dwDstWidth,dwDstHeight - dwDstSplit,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        return;
    }

    // Lie about format for Z buffers
    switch (dwFormat) {
    case NV_SURFACE_FORMAT_Z16:
        dwFormat = NV_SURFACE_FORMAT_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        dwFormat = NV_SURFACE_FORMAT_A8R8G8B8;
        break;
    }

    // attempt to minimize the subrect offset (nvCelsius is not too kosher with large subrects)
    DWORD dwBPP = nvSurfaceFormatToBPP[dwFormat];

    dwSrcOffset += dwBPP * (dwSrcX >> 4) + dwSrcPitch * (dwSrcY >> 4);
    dwSrcX      &= 0xf;
    dwSrcY      &= 0xf;
    if (dwSrcOffset & NV_BYTE_ALIGNMENT_PAD)
    {
        dwSrcX      += ((dwSrcOffset & NV_BYTE_ALIGNMENT_PAD) / dwBPP) << 4;
        dwSrcOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    dwDstOffset += dwBPP * dwDstX + dwDstPitch * dwDstY;;
    dwDstX       = 0;
    dwDstY       = 0;
    if (dwDstOffset & NV_BYTE_ALIGNMENT_PAD)
    {
        dwDstX      += (dwDstOffset & NV_BYTE_ALIGNMENT_PAD) / dwBPP;
        dwDstOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    // send to hardware
    nvCelsiusAAScaledBltHW (pContext,
                            dwSrcOffset,dwSrcPitch,(dwSrcY << 16) | dwSrcX,(dwSrcHeight << 16) | dwSrcWidth,
                            dwDstOffset,dwDstPitch,(dwDstY << 16) | dwDstX,(dwDstHeight << 16) | dwDstWidth,
                            dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

    dbgTracePop();
}


//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMagnify
//
static void nvCelsiusAAMagnifyInternal
(
    PNVD3DCONTEXT pContext,
    CSimpleSurface *pSrc,
    CSimpleSurface *pDst
)
{
    dbgTracePush ("nvCelsiusAAMagnifyInternal");

    switch (pContext->aa.getMethod())
    {
        case AASTATE::METHOD_1x2:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  8,
                                  4,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00100000,
                                  0x00080000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
        case AASTATE::METHOD_2x2lod:
        case AASTATE::METHOD_2x2:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  4,
                                  4,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00080000,
                                  0x00080000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
        
        case AASTATE::METHOD_2x2spec:
        {
           //change 2x2 special into 2x2
           pContext->aa.modFlags(~1,0); 
           
           nvCelsiusAAScaledBlt  (pContext,
                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  4,
                                  4,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00080000,
                                  0x00080000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }

        case AASTATE::METHOD_3x3lod:
        case AASTATE::METHOD_3x3:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  3,
                                  3,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00055555,
                                  0x00055555,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
        case AASTATE::METHOD_4x4lod:
        case AASTATE::METHOD_4x4:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  2,
                                  2,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00040000,
                                  0x00040000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
    }
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMinifyInternal
//
static void nvCelsiusAAMinifyInternal
(
    PNVD3DCONTEXT pContext,
    BOOL bFOH,
    CSimpleSurface *pSrc,
    CSimpleSurface *pDst
)
{
    dbgTracePush ("nvCelsiusAAMinifyInternal");

    // Note: some of the source width/height parameters have 2
    // subtracted from them.  Some apps that were not designed for AA
    // have artifacts on the edge if we do not clamp the bottom and right
    // edges.

    switch (pContext->aa.getMethod())
    {
        case AASTATE::METHOD_1x2:
        {
            nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                  pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                  pSrc->getPitch(),
                                  0,
                                  bFOH ? 8 : 0,
                                  pSrc->getWidth(),
                                  pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                  pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00100000,
                                  0x00200000,

                                  pDst->getFormat(),
                                  bFOH,
                                  TRUE,
                                  pContext->aa.mAppCompat.bDither);
            break;
        }
        case AASTATE::METHOD_2x2lod:
        case AASTATE::METHOD_2x2:
        {
            nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                  pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                  pSrc->getPitch(),
                                  bFOH ? 8 : 0,
                                  bFOH ? 8 : 0,
                                  pSrc->getWidth()-2,
                                  pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                  pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00200000,
                                  0x00200000,

                                  pDst->getFormat(),
                                  bFOH,
                                  TRUE,
                                  pContext->aa.mAppCompat.bDither);
            break;
        }
        case AASTATE::METHOD_2x2spec:
        {
            if (bFOH) {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth(),
                                      pSrc->getHeight(),

                                      0x00100000,
                                      0x00100000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);

                nvCelsiusAAScaledBlt (pContext,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth(),
                                      pSrc->getHeight(),

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            else {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            break;
        }
        case AASTATE::METHOD_3x3lod:
        case AASTATE::METHOD_3x3:
        {
            if (bFOH) {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      4,
                                      4,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      0,
                                      0,
                                      (pSrc->getWidth() * 2) / 3,
                                      (pSrc->getHeight() * 2) / 3,

                                      0x00180000,
                                      0x00180000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);

                nvCelsiusAAScaledBlt (pContext,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      8,
                                      8,
                                      (pSrc->getWidth() * 2) / 3,
                                      (pSrc->getHeight() * 2) / 3,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            else {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00300000,
                                      0x00300000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            break;
        }
        case AASTATE::METHOD_4x4lod:
        case AASTATE::METHOD_4x4:
        {
            if (bFOH) {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth() / 2,
                                      pSrc->getHeight() / 2,

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      pContext->aa.mAppCompat.bDither);

                nvCelsiusAAScaledBlt (pContext,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth() / 2,
                                      pSrc->getHeight() / 2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      pContext->aa.mAppCompat.bDither);
            }
            else {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00400000,
                                      0x00400000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      pContext->aa.mAppCompat.bDither);
            }
            break;
        }
        default:
        {
            DPF ("INVALID AA METHOD - impossible condition");
            dbgD3DError();
            break;
        }
    }

    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMagnify
//
void nvCelsiusAAMagnify
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMagnify");
    nvCelsiusAAMagnifyInternal(pContext,
                               pContext->pRenderTarget,
                               pContext->aa.pSuperRenderTarget);
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMinify
//
void nvCelsiusAAMinify
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMinify");

#ifdef  STEREO_SUPPORT
    if (STEREO_ACTIVATED)
    {
		//We can't mess up the pStereoData->dwLastEye or use SetupStereoContext
		//for that matter. Those are higher level primitives.
		DWORD dwLastEye = pStereoData->dwLastEye;
		pStereoData->dwLastEye = EYE_LEFT;
        nvCelsiusAAMinifyInternal(pContext,
                                  TRUE, // filter colors
                                  pContext->aa.pSuperRenderTarget,
                                  pContext->pRenderTarget);
        pStereoData->dwLastEye = EYE_RIGHT;
        nvCelsiusAAMinifyInternal(pContext,
                                  TRUE, // filter colors
                                  pContext->aa.pSuperRenderTarget,
                                  pContext->pRenderTarget);
		pStereoData->dwLastEye = dwLastEye;
		pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE;
    } else
#endif  //STEREO_SUPPORT
        nvCelsiusAAMinifyInternal(pContext,
                                  TRUE, // filter colors
                                  pContext->aa.pSuperRenderTarget,
                                  pContext->pRenderTarget);

    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMagnifyZ
//
void nvCelsiusAAMagnifyZ
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMagnifyZ");
    if (pContext->pZetaBuffer && pContext->aa.pSuperZetaBuffer) {
        nvCelsiusAAMagnifyInternal(pContext,
                                 pContext->pZetaBuffer,
                                 pContext->aa.pSuperZetaBuffer);
    }
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMinifyZ
//
void nvCelsiusAAMinifyZ
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMinifyZ");

    if (pContext->pZetaBuffer && pContext->aa.pSuperZetaBuffer) {
        nvCelsiusAAMinifyInternal(pContext,
                                  FALSE, // never filter Z's
                                  pContext->aa.pSuperZetaBuffer,
                                  pContext->pZetaBuffer);
    }

    dbgTracePop();
}



#ifdef WINNT
    // No way on God's green earth we should need more than 32k.
    #define MAX_AAFILE_SIZE 32768
#endif
#ifndef WINNT
    #define DYNAMIC_AA_COMPAT_SETTINGS
#endif



// Dynamically loaded settings

AAAppCompatState *AAAppSettings = 0;

struct AANameValue {
    char *lpName;
    BOOL bValue;
};

AANameValue AANamesToValues[] = {
    {"DISCARD_FB",               TRUE},
    {"DONT_DISCARD_FB",          FALSE},
    {"MAGNIFY_ON_UNLOCK",        TRUE},
    {"DONT_MAGNIFY_ON_UNLOCK",   FALSE},
    {"MINIFY_ON_ENDSCENE",       TRUE},
    {"DONT_MINIFY_ON_ENDSCENE",  FALSE},
    {"DITHER",                   TRUE},
    {"DONT_DITHER",              FALSE},
    {"NO_AA_ON",                 TRUE},
    {"AA_ON",                    FALSE},
    {"BLIT_SYNC",                TRUE},
    {"NO_BLIT_SYNC",             FALSE},
    {"DISCARD_SRT",              TRUE},
    {"DONT_DISCARD_SRT",         FALSE},
    {"ALLOW_SPECIAL",            TRUE},
    {"DONT_ALLOW_SPECIAL",       FALSE},
    {"FULL_PATH",                TRUE},
    {"NO_PATH",                  FALSE},
    {0,                          FALSE}
};


// Compiled-in settings

#define DISCARD_FB               TRUE
#define DONT_DISCARD_FB          FALSE
#define MAGNIFY_ON_UNLOCK        TRUE
#define DONT_MAGNIFY_ON_UNLOCK   FALSE
#define MINIFY_ON_ENDSCENE       TRUE
#define DONT_MINIFY_ON_ENDSCENE  FALSE
#define DITHER                   TRUE
#define DONT_DITHER              FALSE
#define NO_AA_ON                 TRUE
#define AA_ON                    FALSE
#define BLIT_SYNC                TRUE
#define NO_BLIT_SYNC             FALSE
#define DISCARD_SRT              TRUE
#define DONT_DISCARD_SRT         FALSE
#define ALLOW_SPECIAL            TRUE
#define DONT_ALLOW_SPECIAL       FALSE
#define FULL_PATH                TRUE
#define NO_PATH                  FALSE

// The macros in nvCelsiusAACompatibility.h get expanded out to array entries
#define appcompat(app, path, no_aa, discard_fb, magnify_on_unlock, minify_on_endscene, dither, blitsync, discard_srt, special) \
    {app, path, no_aa, discard_fb, magnify_on_unlock, minify_on_endscene, dither, blitsync, discard_srt, special},


AAAppCompatState AAAppSettingsCompiled[] = {
#include "nvCelsiusAACompatibility.h"
    {0, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE}
};


////////////////////////////////////
// Gets the unadorned (no path, no params) name 
// of the calling exe file.  Won't work in 
// Win2k until we figure out a better way than
// accessing the offset directly.

void GetExecutableName(LPTSTR pOut, DWORD dwSize, PNVD3DCONTEXT pContext) {

#ifndef WINNT
    LPTSTR pCmdLine = GetCommandLine();
#else
    LPTSTR pCmdLine = nvGetCommandLine(); 
#endif

    LPTSTR pStr, pExe;
    BOOL bInQuotes = 0;

    // quick check
    if (*pCmdLine == '\"') {
        pCmdLine++;
        bInQuotes = TRUE;
    }

    // strip path and leave the raw executable name
    for (pExe = pCmdLine; *pCmdLine != '\0'; pCmdLine++) {
        if (*pCmdLine == '"') bInQuotes = !bInQuotes;

        if (!bInQuotes && *pCmdLine <= ' ') {
            break;
        }
        if (*pCmdLine == '\\' || *pCmdLine == ':') {
            pExe = pCmdLine + 1;
        }
    }

    for (int i=0; pExe[i] != '\0'; i++) {
        if (pExe[i] >= 'A' && pExe[i] <= 'Z') pExe[i] += 'a' - 'A';
    }

    strncpy(pOut, pExe, dwSize);

    // early string termination if quote, space, or control character is detected
    for (pStr = pOut; *pStr != '\0'; pStr++) {
        if (*pStr == '\"' || *pStr <= ' ') {
            *pStr = '\0';
        }
    }

    pOut[dwSize-1] = '\0';       // Just to be safe
}


// Get Full name, including path
void GetFullExecutableName(LPTSTR pOut, DWORD dwSize, PNVD3DCONTEXT pContext) {

#ifndef WINNT
    LPTSTR pCmdLine = GetCommandLine();
#else
    LPTSTR pCmdLine = nvGetCommandLine(); 
#endif

    LPTSTR pExe;
    BOOL bInQuotes = 0;

    if(pCmdLine[0] != '\0'){
        pExe = pCmdLine+1;
        pExe[strlen(pExe)] = '\0';
    }
    else{
        pExe = pCmdLine;
    }   

    for (int i=0; pExe[i] != '\0'; i++) {
        if (pExe[i] >= 'A' && pExe[i] <= 'Z') pExe[i] += 'a' - 'A';
    }

    strncpy(pOut, pExe, dwSize);
    pOut[dwSize-1] = '\0';       // Just to be safe
}


#define WORD_CHAR(x) ((((x) >= 'a') && ((x) <= 'z')) || (((x) >= 'A') && ((x) <= 'Z')) || ((x) == '_'))

__declspec(dllexport) void nvCelsiusAAInitCompatibilitySettings()
{

#ifdef DYNAMIC_AA_COMPAT_SETTINGS
    DWORD i;
    DWORD dwCurSetting = 0;

    if (pDriverData->nvD3DRegistryData.regAAReadCompatibilityFile != 0xd3dbeef) {
        AAAppSettings = AAAppSettingsCompiled;
    }

    if (AAAppSettings) return;

    // Hard-coded filename.  If it's not found, use the
    HANDLE hFile = NvCreateFile("\\NvCelsiusAACompatibility.h",
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);


    // Note: this parsing is "quick-and dirty."  Fortunately, no one
    // outside of NVIDIA should care.
    if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL)) {
        DWORD dwNumBytes, dwSize;
        LPTSTR lpStr;

#ifndef WINNT
        dwSize = GetFileSize(hFile, NULL);
        lpStr = new char[dwSize];
        NvReadFile(hFile, lpStr, dwSize, &dwNumBytes, NULL);
#else
        lpStr = new char[MAX_AAFILE_SIZE];
        for (i =0; i< MAX_AAFILE_SIZE; i++) {
            NvReadFile(hFile, lpStr+i,1,&dwNumBytes, NULL);
            if (dwNumBytes == 0) {
                lpStr[i] = '\0';
                break;
            }
        }
        dwSize = i;
#endif

        DWORD dwNumSettings = 1; // Start with 1 to make room for the default
        for (i=0; i<dwSize; i++) {
            // Skip comment lines
            if (lpStr[i] == '/') {
                while (lpStr[i] != '\n') i++;
            }

            // The number of () pairs should be equal to the number of
            // settings there are in the file
            if (lpStr[i] == '(') {
                dwNumSettings++;
            }
        }

        AAAppSettings = new AAAppCompatState[dwNumSettings];

        // Iterate over all characters in the file
        for (i=0; i<dwSize; i++) {
            // Skip comment lines
            if (lpStr[i] == '/') {
                while (lpStr[i] != '\n') i++;
            }

            if (lpStr[i] == '(') {
                char lpIdent[256];
                DWORD j;

                while (lpStr[i-1] != '"') i++;
                j = 0;
                while (lpStr[i] != '"') lpIdent[j++] = lpStr[i++];
                lpIdent[j] = '\0';


                AAAppSettings[dwCurSetting].lpApp = new char[strlen(lpIdent) +1];
                strcpy(AAAppSettings[dwCurSetting].lpApp, lpIdent);

                DWORD dwParam = 0;
                while (1) {
                    while (!WORD_CHAR(lpStr[i]) && lpStr[i] != ')') i++;
                    if (lpStr[i] == ')') break;

                    j = 0;
                    while (WORD_CHAR(lpStr[i])) lpIdent[j++] = lpStr[i++];
                    lpIdent[j] = '\0';

                    // Find the name to value matching of the identifier
                    for (DWORD k=0; AANamesToValues[k].lpName != 0; k++) {
                        if (strcmp(AANamesToValues[k].lpName, lpIdent) == 0) break;
                    }

                    *(&(AAAppSettings[dwCurSetting].bPath) + dwParam) = AANamesToValues[k].bValue;
                    dwParam++;
                }
                dwCurSetting++;
            }

        }

        delete [] lpStr;

        // Make default setting
        AAAppSettings[dwCurSetting].lpApp = 0;
        AAAppSettings[dwCurSetting].bNoAA = FALSE;
        AAAppSettings[dwCurSetting].bPath = FALSE;
        AAAppSettings[dwCurSetting].bDiscardFBContents = TRUE;
        AAAppSettings[dwCurSetting].bAlwaysMagnifyUponUnlock = FALSE;
        AAAppSettings[dwCurSetting].bMinifyUponEndScene = FALSE;
        AAAppSettings[dwCurSetting].bDither = FALSE;
        AAAppSettings[dwCurSetting].bBlitSync = FALSE;
        AAAppSettings[dwCurSetting].bDiscardSRT = TRUE;
        AAAppSettings[dwCurSetting].bAllowSpecial = TRUE;
    } else {
        AAAppSettings = AAAppSettingsCompiled;
    }
#else
    AAAppSettings = AAAppSettingsCompiled;
#endif
}



__declspec(dllexport) void nvCelsiusAAGetCompatibilitySettings
(
    PNVD3DCONTEXT pContext
)
{
    DWORD i;
    char pExe[256];

    // Should never happen, I think...
    nvAssert(pContext);
    nvAssert(AAAppSettings);

    // Get name of exe (sans path) and convert to lowercase
    //GetExecutableName(pExe, 256);
    //for (i=0; pExe[i] != '\0'; i++) {
    //   if (pExe[i] >= 'A' && pExe[i] <= 'Z') pExe[i] += 'a' - 'A';
    //}

    // Iterate through list, stopping on the last one (has null for the filename),
    // or on the one that matches.
    for (i=0; AAAppSettings[i].lpApp != 0; i++)
    {
        if (AAAppSettings[i].bPath) {
            GetFullExecutableName(pExe, 256, pContext);
        } else {
            GetExecutableName(pExe, 256, pContext);
        }

        if (strcmp(pExe, AAAppSettings[i].lpApp) == 0)
        {
            pContext->aa.mAppCompat = AAAppSettings[i];
            return;
        }
    }

    // App not found, use default...
    pContext->aa.mAppCompat = AAAppSettings[i];
}

// AASTATE functionality ----------------------------------------------------

inline void AASTATE::makeRenderBuffersMatch (PNVD3DCONTEXT pContext)
{
    if ((dwFlags & FLAG_RT_VALID) && (dwFlags & FLAG_SRT_VALID)) return;
    if (dwFlags & FLAG_RT_VALID) {
        nvCelsiusAAMagnify(pContext);
        dwFlags |= FLAG_SRT_VALID;
        return;
    }
    if (dwFlags & FLAG_SRT_VALID) {
        nvCelsiusAAMinify(pContext);
        dwFlags |= FLAG_RT_VALID;
        return;
    }
}

inline void AASTATE::makeZBuffersMatch (PNVD3DCONTEXT pContext)
{
    if ((dwFlags & FLAG_ZB_VALID) && (dwFlags & FLAG_SZB_VALID)) return;
    if (dwFlags & FLAG_ZB_VALID) {
        nvCelsiusAAMagnifyZ(pContext);
        dwFlags |= FLAG_SZB_VALID;
        return;
    }
    if (dwFlags & FLAG_SZB_VALID) {
        nvCelsiusAAMinifyZ(pContext);
        dwFlags |= FLAG_ZB_VALID;
        return;
    }
}

inline BOOL AASTATE::WantEnabled (PNVD3DCONTEXT pContext)
{
    return ((pDriverData->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK)
        && (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)
        || (pDriverData->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK)
        || (pContext->pRenderTarget && (pContext->pRenderTarget->getMultiSampleBits() > 1)));
}

void AASTATE::makeRenderTargetValid (PNVD3DCONTEXT pContext)
{
    if (!(dwFlags & FLAG_RT_VALID))
    {
        nvCelsiusAAMinify(pContext);
        dwFlags |= FLAG_RT_VALID;
    }
    dwFlags &= ~FLAG_SRT_VALID;
}

void AASTATE::makeZetaBufferValid (PNVD3DCONTEXT pContext)
{
    if (!pContext->aa.pSuperZetaBuffer)
        return;

    if (!(dwFlags & FLAG_ZB_VALID))
    {
        nvCelsiusAAMinifyZ(pContext);
        dwFlags |= FLAG_ZB_VALID;
    }
    dwFlags &= ~FLAG_SZB_VALID;
}

void AASTATE::makeSuperBufferValid (PNVD3DCONTEXT pContext)
{
    if (!(dwFlags & FLAG_SRT_VALID))
    {
        nvCelsiusAAMagnify(pContext);
        //flags can get modified in the function above, the optimizer uses the cached, unmodified value.
        //force loading through the pointer to work around it.
        pContext->aa.dwFlags |= FLAG_SRT_VALID;
    }
    pContext->aa.dwFlags &= ~FLAG_RT_VALID;
}

void AASTATE::makeSuperZBValid (PNVD3DCONTEXT pContext) {

    if (!pContext->aa.pSuperZetaBuffer)
        return;

    if (!(dwFlags & FLAG_SZB_VALID))
    {
        nvCelsiusAAMagnifyZ(pContext);
        pContext->aa.dwFlags |= FLAG_SZB_VALID;
    }
    pContext->aa.dwFlags &= ~FLAG_ZB_VALID;
}

void AASTATE::Create (PNVD3DCONTEXT pContext)
{
    if (WantEnabled(pContext))
    {
        if (nvCelsiusAACreate(pContext))
        {
            // enable AA
            setFlags (AASTATE::FLAG_ENABLED);
        }
    }
}

void AASTATE::invalidateState (void)
{
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)(DWORD(this) - OFFSETOF(NVD3DCONTEXT,aa)); // we know aa lives in context (not good practice)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE
                                   |  CELSIUS_DIRTY_TRANSFORM
                                   |  CELSIUS_DIRTY_TEXTURE_STATE
                                   |  CELSIUS_DIRTY_SPECFOG_COMBINER
                                   |  CELSIUS_DIRTY_MISC_STATE;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusAACompatibility.h ===
// AA_ON                   The default
// NO_AA_ON	           Use if AA just seems fundamentally broken	
// DISCARD_FB              The default
// DONT_DISCARD_FB         Use if there seems to be 2D corruption: missing buttons,
//                         cursor trails, etc
// DONT_MAGNIFY_ON_UNLOCK  The default
// MAGNIFY_ON_UNLOCK       Try this as a secondary measure for 2D corruption
// DONT_MINIFY_ON_ENDSCENE The default
// MINIFY_ON_ENDSCENE      Use for windowed apps if the scene doesn't seem to be updating
// DONT_DITHER             The default
// DITHER                  Use if color banding seems to be a problem. May cause weird
//                         color effects for 2D
// BLIT_SYNC		   Force blitting to always sync the render and super render targets by always blitting to the render target
// NO_BLIT_SYNC		   The Default
// DISCARD_SRT		   Invalidate the super render target when the render target changes
// DONT_DISCARD_SRT        The default
// ALLOW_SPECIAL	         The default
// DONT_ALLOW_SPECIAL	   Force down one level if special is set
//
// If you can't seem to get a game working, make sure you have the right .exe file.  Some
// games launch other exe files.  Check the game directories for other .exe files, and try using 
// those

// Default settings to cut-n-paste from
// appcompat("game.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Descent: Freespace 2
appcompat("fs2.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Omikron, the Nomad Soul
appcompat("nomad.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)


//Crusaders of Might and Magic, demo ('crusaders' matches 'crusaders demo.exe') and full version presumably.
appcompat("crusaders", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("crusaders.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)


appcompat("eqgame.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("bend.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

appcompat("powerslide.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("hiddenevil.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("mcm2.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("allegiance.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)


// Apps that just break when dithering is on
// Wild Wild West
appcompat("vrdmfc.exe", NO_PATH, AA_ON, DISCARD_FB, MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
// Superbike
appcompat("bike.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("revolt.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)


//RogueSpear
appcompat("roguespear.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("rainbowsix.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

// baseball 20001
appcompat("baseball2001.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

appcompat("lemans.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

// Turned off because it doesn't react well to buffers not being allocated =)
appcompat("c:\\program files\\motoracer\\go.exe", FULL_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

// NON FUNCTIONAL with AA (IE, There not worth the trouble)
appcompat("moto.exe",  NO_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("df2.exe",  NO_PATH, NO_AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

appcompat("nascar", NO_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("f1_2000.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

appcompat("avp.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//MTM2, retail and demo
appcompat("monster.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("monsterx.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Madden 99
appcompat("madnd3d.exe", NO_PATH, AA_ON, DISCARD_FB, MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Homeworld
appcompat("homeworld.exe", NO_PATH, AA_ON, DISCARD_FB, MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Machines
appcompat("machines.exe", NO_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Shogun
appcompat("shogdemo.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("shogun.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("hellbndx.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("shadows.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//KA-52 Team Alligator
appcompat("sldteam2.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//USAF
appcompat("usaf.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("usafdemo.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("revenant.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//ground control
appcompat("gc.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

//sports car GT
appcompat("spcar.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Nocturne
appcompat("nocturne.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Mech warrior
appcompat("mech3demo.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Panzer Commander  
appcompat("panzer.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Fox BB2k
appcompat("foxbb2k.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("td5_d3d.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Everquest
appcompat("everquest.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("eqgame.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Layrinth
appcompat("thelabyrinth.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Links 2001
appcompat("linkslauncher.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("linksmmi.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Vampire
appcompat("vampire.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//championship bass
appcompat("championshipbass.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Psygnosis Expert Pool
appcompat("pool.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusAlphaCombiner.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusAlphaCombiner.cpp                                        *
*       Routines for programming the celsiusalpha combiner                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        02Mar99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

// Set an alpha input to to 1 or -1

void SetAlphaInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                       DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT SelectAlphaInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal)
{
    DWORD dwICW = 0;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0 && (pContext->tssState[0].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP)) {
            // Output from previous stage
                dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current' alpha.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                dwICW |= DRF_NUM(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, CELSIUS_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);
            break;
        case D3DTA_SPECULAR: //specular is an invalid arg.
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_5);
            
            DPF ("Specular Alpha doesn't exist in Celsius, rendering corruption will result.",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            
            dbgD3DError();
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;
            
            break;
        default:
            DPF ("unknown / illegal alpha argument '%d' in SelectAlphaInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
    }

    // now handle the alpha replicate and complement flags

    if (((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) == D3DTA_CURRENT) &&
         (dwCombinerStage != 0) &&
         (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(dwCombinerStage - 1))) {
        // if the last stage produced a dot product, we were supposed to have replicated the result
        // into alpha, but couldn't b/c celsius can't. get it from the color channels now.
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    }
    else {
        // just get alpha from alpha
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE);
    }

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT combineselect1 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Make A input
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT combineselect2 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply D * 1
    SetAlphaInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr = SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // A & B default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulate (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply D * 1
    SetAlphaInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinesub (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply D * -1
    SetAlphaInputOne (pContext, celsiusCombinerInputC, hdStage, TRUE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + -D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineaddsmooth (PNVD3DCONTEXT pContext,int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineblendalpha (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int type)
{
    HRESULT hr;
    int temp;

    // Multiply A * B(alpha)
    hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);

    if (type == TEXTUREPM) { // this type defined by us
        // Make B 1 since texture is already pre-multiplied
        SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        // set type again for making C (1-alpha) below
        type = D3DTA_TEXTURE;
    }
    else {
        // Make B alpha, appropriate type
        temp = pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2];
        pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = type;
        hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
        // copy arg2 back
        pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = temp;
    }

    // Make C: 1-alpha, make D: arg2
    temp = pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG1];
    pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG1] = type;
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    // copy back to alphaarg1
    pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG1] = temp;
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)
static HRESULT combinepremodulate (PNVD3DCONTEXT pContext,int hdStage, int dxStage)
{
    HRESULT hr;
    int temp, premodulate = 1;

    DPF ("pre-modulation is totally broken right now");
    dbgD3DError();

    if (dxStage == 0) {
        if(pContext->tssState[dxStage+1].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE){
            // make A: alphaArg1(0), make B: texture(1)
             hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
             temp = pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2];
             pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = D3DTA_TEXTURE;
             hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
             // copy back arg2
             pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAARG2] = temp;
        }
        else{
            //asked to do premodulate on a single texture stage -- just pass down
            //the colorarg1
            hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
            SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        }

    }
    else { // well, right now we only handle two stages (we could compress these)
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
        SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    }

    return (hr);
}
//---------------------------------------------------------------------------

static HRESULT combinemultiplyadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    //set B to 1
    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set D to arg3
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinelerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = SelectAlphaInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG0, TRUE, FALSE);
    //set D to arg3
    hr |= SelectAlphaInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

void ConstructOutputAlphaCombiners (PNVD3DCONTEXT pContext, BOOL enable, int stage, int bias, int shift, int outtemp)
{
    outtemp  &= (stage != 1);

    if (!enable) {
        pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    if (shift == 0) {
        if (bias == 0)
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT);
        else
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT_BIAS);
    }
    else if (shift == 1) {
        if (bias == 0)
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1);
        else
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
    }
    else if (shift == 2) {
        if (bias == 0)
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY2);
        else
            // we can't shift by 2 and bias. do the best we can...
            pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
    }
    pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_MUX_ENABLE, _FALSE);
    if (outtemp)
        pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_D);
    else
        pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_C);
    pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0);
    pContext->hwState.dwAlphaOCW[stage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0);
}

//---------------------------------------------------------------------------

void ConstructAlphaCombiners (PNVD3DCONTEXT pContext, int hdStage, int dxStage, BOOL bStageActive)
{
    int     bias, shift;
    BOOL    enable;
    HRESULT hr = 0;

    bias = 0;
    shift = 0;
    enable = TRUE;

    pContext->hwState.dwAlphaICW[hdStage] = 0;
    pContext->hwState.dwAlphaOCW[hdStage] = 0;

    if (!bStageActive) {
        // colorop was set to disable
        if (hdStage == 0) { // only construct default for stage 0
            // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
            pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
            pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
            SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        }
        else {
            enable = FALSE;
        }
    }

    else {

        switch (pContext->tssState[dxStage].dwValue[D3DTSS_ALPHAOP]) {
            default:
            case D3DTOP_DOTPRODUCT3:
                // We treat dot3 like disable because it doesn't really matter.
                // if the colorop is also dot3, then alpha will be overwritten momentarily anyhow.
                // BUGBUG if the colorop is NOT dot3, what the heck does this even mean???
            case D3DTOP_DISABLE:
                if (hdStage == 0) { // only construct default for stage 0
                    // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
                    pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
                    pContext->hwState.dwAlphaICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
                    SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
                }
                else {
                    enable = FALSE;
                }
                break;
            case D3DTOP_SELECTARG1:
                hr = combineselect1 (pContext, hdStage, dxStage);
                break;
            case D3DTOP_SELECTARG2:
                hr = combineselect2 (pContext, hdStage, dxStage);
                break;
            case D3DTOP_MODULATE4X:
                shift++;
            case D3DTOP_MODULATE2X:
                shift++;
            case D3DTOP_MODULATE:
                hr = combinemodulate (pContext, hdStage, dxStage);
                break;
            case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
                shift = 1;
            case D3DTOP_ADDSIGNED:   // same as add with following change
                bias = 1;
            case D3DTOP_ADD:
                hr = combineadd (pContext, hdStage, dxStage);
                break;
            case D3DTOP_SUBTRACT:
                hr = combinesub (pContext, hdStage, dxStage);
                break;
            case D3DTOP_ADDSMOOTH:
                hr = combineaddsmooth (pContext, hdStage, dxStage);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_DIFFUSE);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TEXTURE);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TFACTOR);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                hr = combineblendalpha (pContext,hdStage, dxStage, TEXTUREPM);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_CURRENT);
                break;
            case D3DTOP_PREMODULATE:
                hr = combinepremodulate (pContext, hdStage, dxStage);
                break;
// BUGBUG
#if 0
            case D3DTOP_ALPHAMODULATE:
                // This is the case where the old D3DRENDERSTATE_TEXTUREMAPBLEND was used with
                // the D3DTBLEND_MODULATE op because the dump translates this into TSS we define
                // a new op that properly handles D3DTBLEND_MODULATE
                // Alpha is obtained by the texture, if it has alpha otherwise it is obtained from
                // the vertex. The dump always sets arg1 to be texture and arg2 to be current
                if (statev.ptexture[0] && statev.ptexture[0]->sd.ddpfPixelFormat.dwRGBAlphaBitMask) {
                    combineselect1(hdStage);
                }
                else {
                    combineselect2(hdStage);
                }
                break;
#endif
            case D3DTOP_MULTIPLYADD:
                hr = combinemultiplyadd (pContext, hdStage, dxStage);
                break;
            case D3DTOP_LERP:
                hr = combinelerp (pContext, hdStage, dxStage);
                break;
        }  // switch

    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (hdStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwAlphaICW[hdStage] = DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4) |
                                                    DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        else {
            pContext->hwState.dwAlphaICW[hdStage]  = DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_C);
            pContext->hwState.dwAlphaICW[hdStage] |= (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(0)) ?
                                                     DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _FALSE) :
                                                     DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        SetAlphaInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    }

    ConstructOutputAlphaCombiners (pContext, enable, hdStage, bias, shift,
                                  pContext->tssState[dxStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusCompileVS_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvCelsiusCompileVS_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "nvprecomp.h"
#include "..\..\..\common\src\vpcompilex86.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusComp.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusComp.cpp                                                 *
*       Celsius inner loop compiler                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             29Sep99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"
#include "nvILHash.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//
// inner loop uniqueness is a function of:
//  - fvfData.dwVertexStride
//  - fvfData.dwVertexType
//  - fvfData.dwUVCount[8]
//  - fvfData.dwUVOffset[8]
//  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
//  - pContext->hwState.celsius.dwTexUnitToTexStageMapping[2]
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define PRINT_NAME          // prints ilcFlags for every primitive batch

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define KNIMEM(x)           ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

//////////////////////////////////////////////////////////////////////////////
// external declarations (mostly nvcomp.cpp)
//
void ILCCompile_GetSpace (void);
void ILCCompile_mul      (DWORD reg,DWORD num);

//////////////////////////////////////////////////////////////////////////////
// forward declarations
//
DWORD nvCelsiusILCompile_inline_prim      (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusInlPrim.cpp
DWORD nvCelsiusILCompile_inline_tri_list  (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusInlTri.cpp
DWORD nvCelsiusILCompile_vb_prim          (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusVbPrim.cpp
DWORD nvCelsiusILCompile_str_prim         (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusInlStrPrim.cpp
DWORD nvCelsiusILCompile_super_tri_list   (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvCelsiusSuperTri.cpp

//---------------------------------------------------------------------------

// nvCelsiusGetDispatchRoutine

CELSIUSDISPATCHPRIMITIVE nvCelsiusGetDispatchRoutine
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    // check quick cache
    if (global.celsius.dwLoopCache)
    {
        CILHashEntry *pEntry = (CILHashEntry*)global.celsius.dwLoopCache;
        if (pEntry->match (pContext,NVCLASS_FAMILY_CELSIUS,dwFlags))
        {
            return (CELSIUSDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
    }

    // check hash table
    DWORD dwHashIndex = (DRAW_PRIM_TABLE_ENTRIES - 1) & ((dwFlags + (dwFlags >> 12) + (dwFlags >> 24))
                                                      + pContext->hwState.pVertexShader->getStride()
                                                      + pContext->hwState.pVertexShader->getFVF());

    CILHashEntry *pEntry = (CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex];

    while (pEntry)
    {
        // found it?
        if (pEntry->match (pContext,NVCLASS_FAMILY_CELSIUS,dwFlags))
        {
            global.celsius.dwLoopCache = (DWORD)pEntry;
            return (CELSIUSDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
        // next
        pEntry = pEntry->getNext();
    }

    // build new innerloop
    //  loops require pContext->hwState.dwStateFlags to be set up correctly (CM hack, inline expansion)
    DWORD dwOffset;
    switch (dwFlags & CELSIUS_ILMASK_LOOPTYPE)
    {
        case CELSIUS_ILFLAG_IX_VB_PRIM:
        case CELSIUS_ILFLAG_OR_VB_PRIM:      dwOffset = nvCelsiusILCompile_vb_prim(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_STR_PRIM:
        case CELSIUS_ILFLAG_OR_STR_PRIM:     dwOffset = nvCelsiusILCompile_str_prim(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_INL_PRIM:
        case CELSIUS_ILFLAG_OR_INL_PRIM:     dwOffset = nvCelsiusILCompile_inline_prim(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_INL_TRI_LIST:
        case CELSIUS_ILFLAG_OR_INL_TRI_LIST: dwOffset = nvCelsiusILCompile_inline_tri_list(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_SUPER_TRI_LIST:  dwOffset = 0;//nvCelsiusILCompile_super_tri_list(pContext,dwFlags);
                                             break;
        case CELSIUS_ILFLAG_IX_DVB_TRI:      dwOffset = 0;//todo - nvCelsiusILCompile_indexed_dvb_tri(pContext,dwFlags);
                                             break;
    }

    //
    // add to hash list
    //
    pEntry = new CILHashEntry (pContext,NVCLASS_FAMILY_CELSIUS,dwFlags,dwOffset,(CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex]);
    if (!pEntry) {
        nvAssert(0);
        return NULL;
    }
    dwDrawPrimitiveTable[dwHashIndex] = (DWORD)pEntry;

#ifdef PRINT_NAME
    PF ("new celsius loop (%08x): type %x, dp2 %s (%2x), state = %08x, %s %s %s", pEntry,
        (dwFlags & 0xF0000000) >> 28,
        celsiusPrimitiveName[dwFlags & 0xFFFF], dwFlags & 0xFFFF,
        pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS,
        dwFlags & CELSIUS_ILFLAG_LEGACY ? "LEGACY" : "",
        dwFlags & CELSIUS_ILFLAG_CMHACK ? "CMHACK" : "",
        dwFlags & CELSIUS_ILFLAG_NOCULL ? "NOCULL" : "");
#endif

    //
    // done
    //
    global.celsius.dwLoopCache = (DWORD)pEntry;
    return (CELSIUSDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
}
/*
//---------------------------------------------------------------------------

// indexed vertex buffer copy

DWORD nvCelsiusILCompile_indexed_vb
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// ordered vertex buffer copy

DWORD nvCelsiusILCompile_ordered_vb
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// indexed copy

DWORD nvCelsiusILCompile_indexed
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// ordered copy

DWORD nvCelsiusILCompile_ordered
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// ordered transformed triangle

DWORD nvCelsiusILCompile_ordered_tri
(
    DWORD dwFlags
)
{
    DWORD label;
    xLABEL (label);
    xMOV_rm_imm (rmREG(rEAX),dwFlags);
    xRET

    return label;
}

//---------------------------------------------------------------------------

// helpers - called by inner loops

void __stdcall nvCelsiusDispatchGetFreeSpace (PNVD3DCONTEXT pContext)
{
    // make space
    nvPusherAdjust (0);
    // read back defVB values
    getDC()->defaultVB.updateOffset (global.celsius.dwVBOffset);
    // get more space
    DWORD dwOffset = getDC()->defaultVB.waitForSpace (12 * 64 * 10, TRUE);
    // reset defVB values
    getDC()->defaultVB.updateOffset (dwOffset);
    global.celsius.dwVBGetOffset = getDC()->defaultVB.getCachedOffset();
}
*/
void __stdcall nvCelsiusDispatchGetPusherSpace (void)
{
    // wrap around -or- make space
    nvPusherAdjust (0);
}

#ifdef DEBUG
void __stdcall nvCelsiusDispatchFlush (void)
{
    nvPusherAdjust (0);
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
}

void __stdcall nvCelsiusDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
    static DWORD dwVertexCount = 0;

    if (dbgShowState & NVDBG_SHOW_VERTICES)
    {
        DWORD *pdwData = ((DWORD*)dwPutAddress) + 1;

        dwVertexCount ++;

        DPF ("Vertex %d", dwVertexCount);

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT])) {
            DPF ("         B = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL])) {
            DPF ("    Normal = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
            DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
            pdwData += 3;
        }

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                               4 : (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV1[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >>  0) & 0xffff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                               4 : (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV0[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])){
            DPF ("  Specular = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
            DPF ("   Diffuse = %08x",pdwData[0]);
            pdwData += 1;
        }

        nvAssert (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));
        DPF ("       XYZ = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
        DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
        pdwData += 3;

        if (pContext->hwState.pVertexShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
            DPF ("       RHW = %f [%08x]", FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
            pdwData += 1;
        }
        DPF ("");
    }
}
#endif
/*
//---------------------------------------------------------------------------

// helpers

void nvCelsiusILCompile_beginEnd
(
    DWORD dwPrimType
)
{
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv10CelsiusBeginEnd2MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END2))
    xMOV_rm_imm (rmREG(rEBX),dwPrimType)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif
}

void nvCelsiusILCompile_computeThreshold (void)
{
    DWORD dwVBReservedSpace = 64 * 12; // max fvf size times 12
    DWORD dwDefaultVBSize = getDC()->defaultVB.getSize();

    // global.celsius.dwVBThreshold = (dwVBOffset < dwVBGetOffset) ? (dwVBGetOffset - dwVBSpace)
    //                                                             : (dwDefaultVBSize - dwVBSpace);
    xMOV_r_i32  (rEAX,mMEM32(global.celsius.dwVBOffset))
        xMOV_rm_imm (rmREG(rEDX),dwDefaultVBSize)
    xXOR_r_rm   (rECX,rmREG(rECX))
    xSUB_r_i32  (rEAX,mMEM32(global.celsius.dwVBGetOffset))
    xSETL_rm8   (rmREG(rCL))        // ecx = (ofs < get) ? 1 : 0
        xSUB_r_i32  (rEDX,mMEM32(global.celsius.dwVBGetOffset)) // edx = (dwDefaultVBSize - dwVBGetOffset)
    xDEC_rm     (rmREG(rECX))       // ecx = (ofs < get) ? 0 : ~0
    xAND_r_rm   (rECX,rmREG(rEDX))  // ecx = (ofs < get) ? 0 : edx -> (dwDefaultVBSize - dwVBGetOffset)
    xADD_r_i32  (rECX,mMEM32(global.celsius.dwVBGetOffset))
                                    // ecx = (ofs < get) ? get : vbsize
    xSUB_rm_imm (rmREG(rECX),dwVBReservedSpace)
    xMOV_i32_r  (mMEM32(global.celsius.dwVBThreshold),rECX)
}

void nvCelsiusILCompile_computeIndexAndOffset
(
    DWORD dwVBStride,
    DWORD dwLogStride       // must be zero if dwVBstride is not a power of 2
)
{
    // global.celsius.dwVBIndex = (getDC()->dwDefVBCurrentOffset + dwVBStride * 4 - 1) / dwVBStride;
    xMOV_r_i32  (rEAX,mMEM32(pDriverData))
    xMOV_rm_imm (rmREG(rEBX),dwVBStride * 4 - 1)
    if (dwLogStride)
    {
        xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(OFFSETOF(CDriverContext,defaultVB.m_dwCurrentOffset))
        xADD_r_rm   (rEAX,rmREG(rEBX))
        xSHR_rm_imm (rmREG(rEAX),dwLogStride)
    }
    else
    {
        xXOR_r_rm   (rEDX,rmREG(rEDX))
        xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(OFFSETOF(CDriverContext,defaultVB.m_dwCurrentOffset))
        xMOV_rm_imm (rmREG(rECX),dwVBStride)
        xADD_r_rm   (rEAX,rmREG(rEBX))
        xDIV_rm     (rmREG(rECX))
    }
    xMOV_i32_r  (mMEM32(global.celsius.dwVBIndex),rEAX)

    // global.celsius.dwVBOffset = global.celsius.dwVBIndex * dwVBStride;
    ILCCompile_mul (rEAX,dwVBStride);
    xMOV_i32_r  (mMEM32(global.celsius.dwVBOffset),rEAX)

    // compute threshold
    nvCelsiusILCompile_computeThreshold();

    // compute DVB banks
    xMOV_r_i32  (rEAX,mMEM32(global.celsius.dwVBIndex))
    xMOV_r_rm   (rEBX,rmREG(rEAX))
    xAND_rm_imm (rmREG(rEAX),0xffff8000)
    xAND_rm_imm (rmREG(rEBX),0x00007fff)
    xMOV_i32_r  (mMEM32(global.celsius.dwVBIndex),rEBX)
    // check if we need to reprogram FVF (dwVBBank is in eax)
    xMOV_r_i32  (rESI,mMEM32(global.celsius.pContext_celsiusState))
    ILCCompile_mul (rEAX,dwVBStride);
    // pContext->hwState.celsius.dwVertexOffsetInUse = dwVBBank * dwVBStride;
    xMOV_rm_r   (rmIND32(rESI),rEAX) xOFS32(OFFSETOF(CCelsiusState,dwVertexOffsetInUse))
    // set fvf dirty if (getDC()->dwVBCachedVertexOffset != dwDefVBBase))
    xMOV_r_i32  (rEDI,mMEM32(pDriverData))
    xXOR_r_rm   (rECX,rmREG(rECX))
    xCMP_r_rm   (rEAX,rmIND32(rEDI)) xOFS32(OFFSETOF(CDriverContext,dwVBCachedVertexOffset))
    xSETZ_rm8   (rmREG(rCL))
    xDEC_rm     (rmREG(rECX))
    xAND_rm_imm (rmREG(rECX),CELSIUS_DIRTY_FVF)
    xOR_rm_r    (rmIND32(rESI),rECX) xOFS32(OFFSETOF(CCelsiusState,dwDirtyFlags))

    //
    // set state
    //
    xMOV_r_i32  (rESI,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),(DWORD)nvSetCelsiusState)
    xPUSH_r     (rESI)
    xCALL_rm    (rmREG(rEBX))
}
*/
// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvCelsiusILCompile_memcpy
(
    DWORD dwCount, bool recurse
)
{

//    if (dwCount)
//    {
//        xMOV_rm_imm (rmREG(rECX),dwCount)
//    }
//
//    xMOV_r_rm   (rEAX,rmREG(rECX))
//    xSHR_rm_imm (rmREG(rECX),2)
//    xAND_rm_imm (rmREG(rEAX),3)
//    xREP xMOVSD
//    xMOV_r_rm   (rECX,rmREG(rEAX))
//    xREP xMOVSB
//
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy
            //
            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xMOVQ_r_rm      (rMM4,rmIND8(rESI)) xOFS8(32)
                xMOVQ_r_rm      (rMM5,rmIND8(rESI)) xOFS8(40)
                xMOVQ_r_rm      (rMM6,rmIND8(rESI)) xOFS8(48)
                xMOVQ_r_rm      (rMM7,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM4) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM5) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM6) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM7) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }

            if (needFemms)
            {
                xFEMMS
            }

        }
        else
        {
            //
            // normal 8086 copy
            //
            DWORD dwWordCount = dwCount / 4;
            if (dwWordCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwWordCount)
                xREP xMOVSD
            }
            dwCount &= 3;
            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
    }
    else
    {
        // variable length copy
        if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON))
        {
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            //
            // kni copy
            //
            DWORD label1;
            DWORD label2;
            // 64 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),64)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvCelsiusILCompile_memcpy (64, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-64)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // 16 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),16)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvCelsiusILCompile_memcpy (16, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-16)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // the rest
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB

            if (needFemms)
            {
                xFEMMS
            }
        }
        else
        {
            //
            // normal 8086 copy
            //
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB
        }
    }
}
// adds a base vertex index (16bit) to all 16bit chunks
// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvCelsiusILCompile_indexcpy
(
    DWORD dwCount
)
{
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            //
            // WNI copy
            //
            xMOV_r_i32      (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.celsius.dwBaseVertex))
            xMOVDX_r_rm      (rXMM4, rmREG(rECX))
            xPSHUFLW_r_rm_imm (rXMM4, rmREG(rXMM4), 0)
            xPUNPCKLWDX_r_rm (rXMM4, rmREG(rXMM4))

            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xPADDWX_r_rm    (rXMM1, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xPADDWX_r_rm    (rXMM2, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xPADDWX_r_rm    (rXMM3, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy - we use MMX because there's no integer add for KNI regs.
            //
            xEMMS
            xMOV_r_i32      (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.celsius.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPSHUFW_r_rm_imm (rMM4, rmREG(rMM4), 0)
            while (dwCount >= 64)
            {

                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xEMMS

        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            xFEMMS
            xMOV_r_i32      (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.celsius.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPUNPCKLDQ_r_rm (rMM4, rmREG(rMM4))
            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xFEMMS
        }
        if (dwCount)
        {
            //
            // normal 8086 copy
            //
            DWORD label;
            xLABEL (label)


            xMOV_r_i32  (rECX,mMEM32(global.celsius.dwBaseVertex))
            xSHL_rm_imm8 (rmREG(rECX),16)
            xOR_r_i32   (rECX,mMEM32(global.celsius.dwBaseVertex))
            //hmmm fully unrolled loop might not be the best... HMH
            //never mind, 64 indices is max (aka 32 moves)
            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;

            }
            if (dwCount) //it had better be 2
            {
                x16r xMOV_r_rm (rAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),2)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rAX)
                xADD_rm_imm  (rmREG(rEDI),2)
                dwCount -= 2;
            }
        }
    }
}

// vertex at ESI, pusher at EDI
//  thrashes eax,ebx,ecx,edx and ebp
void nvCelsiusILCompile_copyVertex_texMatrixFix
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags,
    DWORD         dwD3DStage,
    DWORD         dwTCIndex,
    DWORD         dwInCount,
    DWORD         dwOutCount,
    BOOL          bProjected,
    DWORD        *pdwDstIndex
)
{
    // psuedo-C equivalent of the snippet below

    // D3DMATRIX *pMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
    // D3DVALUE dvCoordsIn[4], dvCoordsOut[4];
    // DWORD i;
    //
    // // fetch incoming coords
    // for (i = 0; i < dwInCount; i++) {
    //     dvCoordsIn[i] = rmIND8(rESI) xOFS8(i * 4 + fvfData.dwUVOffset[dwTCIndex])
    // }
    // // tack on a 1.0
    // dvCoordsIn[dwInCount] = 1.0;
    // // set the rest to zero
    // for (i = dwInCount+1; i < 4; i++) {
    //     dvCoordsIn[i] = 0;
    // }
    //
    // // transform
    // XformVector4 (D3DVALUE dvCoordsOut, D3DVALUE dvCoordsIn, pMatrix);
    //
    // // write out the real coordinates
    // for (i = 0; i < (dwOutCount - (bProjected ? 1 : 0)); i++) {
    //     xMOV_rm_r (rmIND8(rEDI), dvCoordsOut[i]) xOFS8(dwDstIndex)
    //     dwDstIndex += 4;
    // }
    // // pad with zeros
    // for (; i < 3; i++) {
    //     xMOV_rm_r (rmIND8(rEDI), 0);
    //     dwDstIndex += 4;
    // }
    // // fill the last slot with either 1.0 or the projected value
    // xMOV_rm_r (rmIND8(rEDI), bProjected ? dvCoordsOut[dwOutCount-1] : 1.0) xOFS8(dwDstIndex)
    // dwDstIndex += 4;

    //
    // get active tex transform matrix
    //
    xMOV_r_i32  (rEAX,mMEM32(global.celsius.pContext))
    xLEA_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(OFFSETOF(NVD3DCONTEXT,tssState[dwD3DStage].mTexTransformMatrix))

    //
    // fetch
    //
    for (DWORD i = 0; i < dwInCount; i++)
    {
        xFLD_rm32 (rmIND8(rESI)) xOFS8(i * 4 + global.celsius.dwOffsetUV[dwTCIndex])
    }
    xFLD1
    for (i++; i < 4; i++)
    {
        xFLDZ
    }

    //
    // transform into temp space
    //
    for (i = 0; i < dwInCount; i++)
    {                                                           // w z y x
        xFLD_st (rST3)                                          // x w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((0*4+i)*4)                // x*m1i w z y x
        xFLD_st (rST3)                                          // y x*m1i w z y x
        xFLD_st (rST3)                                          // z y x*m1i w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((2*4+i)*4)                // z*m3i y x*m1i w z y x
        xFLD_st (rST3)                                          // w z*m3i y x*m1i w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((3*4+i)*4)                // w*m4i z*m3i y x*m1i w z y x
        xFXCH_st (rST2)                                         // y w*m4i z*m3i x*m1i w z y x
        xFMUL_rm (rmIND8(rEAX)) xOFS8((1*4+i)*4)                // y*m2i w*m4i z*m3i x*m1i w z y x
        xFADDP_st (rST1)                                        // y*m2i+w*m4i z*m3i x*m1i w z y x
        xFADDP_st (rST1)                                        // y*m2i+w*m4i+z*m3i x*m1i w z y x
        xFADDP_st (rST1)                                        // y*m2i+w*m4i+z*m3i+x*m1i w z y x
        xFSTP_i32 (KNIMEM(fRHW) + i*4)                          // w z y x
    }

    xFFREE_st (rST0)
    xFFREE_st (rST1)
    xFFREE_st (rST2)
    xFFREE_st (rST3)

    //
    // write out
    //
    for (i = 0; i < (dwOutCount - (bProjected ? 1 : 0)); i++)
    {
        xMOV_r_i32 (rEBX,KNIMEM(fRHW) + i*4)
        xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8(*pdwDstIndex)
        (*pdwDstIndex) += 4;
    }
    xXOR_r_rm (rEBX,rmREG(rEBX))
    for (; i < 3; i++) {
        xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8(*pdwDstIndex)
        (*pdwDstIndex) += 4;
    }
    // fill the last slot with either 1.0 or the projected value
    if (bProjected)
    {
        xMOV_r_i32 (rEBX,KNIMEM(fRHW) + 4*(dwOutCount-1))
    }
    else
    {
        xMOV_r_i32 (rEBX,KNIMEM(fOne))
    }
    xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8(*pdwDstIndex)
    (*pdwDstIndex) += 4;
}

// vertex at ESI, pusher at EDI
//  trashes eax,ebx,ecx,edx and ebp
void nvCelsiusILCompile_copyVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    CVertexShader *pVShader;
    DWORD          i;

    const DWORD    adwRegister[]        = { rEAX,rEBX,rECX,rEDX,rEBP };
    DWORD          dwDstIndex           = 0;
    DWORD          dwInlineVertexStride = pContext->hwState.dwInlineVertexStride;

    // cache the vertex shader
    pVShader = pContext->hwState.pVertexShader;
    nvAssert (pVShader);

    // rd: method
    xMOV_rm_imm (rmREG(rEAX),(((dwInlineVertexStride) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)))))

    // rd: b
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]))
    {
        xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetWeight)
    }

    // rd: normal
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL]))
    {
        xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetNormal)
        xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetNormal + 4)
        xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetNormal + 8)
    }

    // wr: method
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    dwDstIndex += 4;

    // wr: b
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: normal
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
        xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
        xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
        dwDstIndex += 12;
    }

    // rd & wr: tex coords 1
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        DWORD dwCount    = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1)) ?
                           3 : ((pVShader->getVASize(dwVAIndex)) >> 2);
        assert (dwCount < 5);

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXMATRIXSWFIX(1))
        {
            DWORD dwXFormFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
            DWORD dwOutCount   = dwXFormFlags & 0xff;
            BOOL  bProjected   = (dwXFormFlags & D3DTTFF_PROJECTED) ? TRUE : FALSE;
            nvCelsiusILCompile_copyVertex_texMatrixFix (pContext,dwFlags,dwD3DStage,dwTCIndex,dwCount,dwOutCount,bProjected,&dwDstIndex);
        }
        else
        {
            for (i=0; i<dwCount; i++) {
                xMOV_r_rm   (adwRegister[i],rmIND8(rESI)) xOFS8(i * 4 + global.celsius.dwOffsetUV[dwTCIndex])
            }
#ifdef STOMP_TEX_COORDS
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(1)) {
                xMOV_r_imm (adwRegister[3],0x3f800000)
            }
#endif  // STOMP_TEX_COORDS
            for (i=0; i<dwCount; i++) {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[i]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1)) {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[2]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
        }
    }

    // rd & wr: tex coords 0
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        DWORD dwCount    = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0)) ?
                           3 : ((pVShader->getVASize(dwVAIndex)) >> 2);
        assert (dwCount < 5);

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXMATRIXSWFIX(0))
        {
            DWORD dwXFormFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
            DWORD dwOutCount   = dwXFormFlags & 0xff;
            BOOL  bProjected   = (dwXFormFlags & D3DTTFF_PROJECTED) ? TRUE : FALSE;
            nvCelsiusILCompile_copyVertex_texMatrixFix (pContext,dwFlags,dwD3DStage,dwTCIndex,dwCount,dwOutCount,bProjected,&dwDstIndex);
        }
        else
        {
            for (DWORD i = 0; i < dwCount; i++)
            {
                xMOV_r_rm   (adwRegister[i],rmIND8(rESI)) xOFS8(i * 4 + global.celsius.dwOffsetUV[dwTCIndex])
            }
#ifdef STOMP_TEX_COORDS
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(0)) {
                xMOV_r_imm (adwRegister[3],0x3f800000)
            }
#endif  // STOMP_TEX_COORDS
            for (DWORD k = 0; k < dwCount; k++)
            {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[k]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0))
            {
                xMOV_rm_r   (rmIND8(rEDI),adwRegister[2]) xOFS8(dwDstIndex)
                dwDstIndex += 4;
            }
        }
    }

    // rd: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetSpecular)
    }

    // rd: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetDiffuse)
    }

    // rd: xyz
    nvAssert (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));

    xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetXYZ)
    xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetXYZ + 4)
    xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetXYZ + 8)

    // wr: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: xyz
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
    xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
    xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
    dwDstIndex += 12;

    // rd & wr: rhw
    if (pVShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.celsius.dwOffsetRHW)
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // sanity check
    assert ((dwDstIndex - 4) == dwInlineVertexStride);

    // we can optionally print the vertex here
#if defined(DEBUG) || defined(NVSTATDRIVER)
    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchPrintVertex)
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.pContext))
    xPUSH_r     (rEDI)
    xPUSH_r     (rEBX)
    xCALL_rm    (rmREG(rEAX))
#endif

    // adjust put
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(dwDstIndex)
}

//
// range limit <only on NT> (dummy must be eax, ebx, ecx or edx)
//
void nvCelsiusILCompile_limit
(
    DWORD regLimit,
    DWORD regDummy
)
{
    assert ((regDummy == rEAX)
         || (regDummy == rEBX)
         || (regDummy == rECX)
         || (regDummy == rEDX));

#ifdef WINNT
    xXOR_r_rm   (regDummy,rmREG(regDummy))
    xCMP_r_i32  (regLimit,mMEM32(global.dwMaxVertexOffset))
    xSETAE_rm8  (rmREG(regDummy))
    xDEC_rm     (rmREG(regDummy))
    xAND_r_rm   (regLimit,rmREG(regDummy))
#endif
}

// prefetch data
//  will trash ESI, ECX, EDX, EAX
void nvCelsiusILCompile_prefetch
(
    BOOL bIsIndexed,
    BOOL bLegacyStrides
)
{
    if (bIsIndexed)
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.celsius.pIndices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.celsius.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            xPUSH_r     (rECX)
            // read index
            xXOR_r_rm   (rEDX,rmREG(rEDX))
       x16r xMOV_r_rm   (rDX,rmIND(rESI))
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rESI))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rESI,rmREG(rECX))
            }
            ILCCompile_mul (rEDX,global.celsius.dwVertexStride);
            // range limit
            nvCelsiusILCompile_limit (rEDX,rECX);
            // compute vertex address
            xADD_r_i32  (rEDX,mMEM32(global.celsius.pVertices))
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            if (global.celsius.dwVertexStride > 32)
            {
                xMOV_r_rm   (rEAX,rmIND8(rEDX)) xOFS8(32)
            }
            xMOV_rm_imm (rmREG(rEAX),0)
            // end of valid run?
            xPOP_r      (rECX)
            xCMP_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
    else
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.celsius.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_rm_imm (rmREG(rEAX),0)
            xADD_rm_imm (rmREG(rESI),32)
            // end of valid run?
            xCMP_r_i32  (rESI,mMEM32(global.celsius.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusColorCombiner.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusColorCombiner.cpp                                        *
*       Routines for programming the celsius color combiner                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        02Mar99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

// Set a color input to to 1 or -1

void SetColorInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                       DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_MAP, ~0) << celsiusCombinerInputShift[eInput]);
    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, ~0) << celsiusCombinerInputShift[eInput]);
    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, ~0) << celsiusCombinerInputShift[eInput]);

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Set the input mapping mode for the given stage and input

void SetColorMapping (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                       DWORD dwCombinerStage, DWORD dwMapping)
{
    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_MAP, 0xffffffff)  << celsiusCombinerInputShift[eInput]);
    pContext->hwState.dwColorICW[dwCombinerStage] |= (DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_MAP, dwMapping) << celsiusCombinerInputShift[eInput]);
}

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT SelectColorInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate)
{
    DWORD dwICW = 0;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0 && (pContext->tssState[0].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP) ) {
                // Output from previous stage
                dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current'.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                dwICW |= DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, CELSIUS_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_D);
            break;
        default:
            DPF ("unknown / illegal color argument '%d' in SelectColorInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
    }

    // Now handle the alpha replicate and complement flags

    bAlphaReplicate |= (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_ALPHAREPLICATE);

    dwICW |= bAlphaReplicate ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _TRUE) :
                               DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT combineselect1 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT combineselect2 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply D * 1
    SetColorInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr = SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // A & B default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulate (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1(B)
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // Make B 1
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply 1(C) * D
    SetColorInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinesub (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply D * -1
    SetColorInputOne (pContext, celsiusCombinerInputC, hdStage, TRUE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + -D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineaddsmooth (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, TRUE, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineblendalpha (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int type)
{
    HRESULT hr = 0;
    int     temp;
    BOOL    bAlphaReplicate;

    // if the last stage involved a dot3 operation, pull alpha_current from the last stage's color channels
    // rather than its alpha channel, because the copy into the latter will have been deferred and the value
    // will not yet be available there.
    bAlphaReplicate = ((type==D3DTA_CURRENT) &&
                       (hdStage > 0) &&
                       (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(hdStage-1))) ? FALSE : TRUE;

    // A gets alpha, as appropriate
    if (type == TEXTUREPM) {
        // Make A=1 since texture is already pre-multiplied
        SetColorInputOne (pContext, celsiusCombinerInputA, hdStage, FALSE);
        // set type again for making C (1-alpha) below
        type = D3DTA_TEXTURE;
    }
    else {
        temp = pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2];
        pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = type;
        hr |= SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, bAlphaReplicate);
        pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = temp;
    }

    // B gets arg1
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);

    // C gets 1-alpha
    temp = pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG1];
    pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG1] = type;
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, TRUE, FALSE, bAlphaReplicate);
    pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG1] = temp;

    // D gets arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)

// Premodulate in stage (i-1) is effectively selectarg1
// Then, in stage i, modulate current color (the above) with texture in stage i
// Then, do the operation chosen for stage i

static HRESULT combinepremodulate (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;
    int temp, premodulate = 1;

    DPF ("pre-modulationis totally broken");
    dbgD3DError();

    if (dxStage == 0) {
        if (pContext->tssState[1].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE) {
            // This modulates selectarg1(stage0) with texture(stage1) now!
            // The right solution is really to wait and see if there is a stage 1
            // make A: colorArg1(0), make B: texture(nextstage)
            hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            // This is a bit of a hack here since we use colorarg from stage 0
            // but we get the texture from stage 1 (told to in SelectB)
            temp = pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2];
            pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = D3DTA_TEXTURE;
            hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
            // reset back arg2
            pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = temp;
        }
        else {
            // asked to do premodulate on a single texture stage -- just pass down
            // the colorarg1
            hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        }
    }
    else // well, right now we only handle two stages (we could compress these)
    {
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);

        //DCR check for premodulate on stage 0?
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulatealpha (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int complement)
{
    HRESULT hr;

    // A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Set C alpha(arg1), Set D: arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, complement, FALSE, TRUE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulatecolor (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int complement)
{
    HRESULT hr;

    // A * B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, complement, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    // Set C alpha(arg1), Set D: 1
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, TRUE);
    SetColorInputOne (pContext, celsiusCombinerInputD, hdStage, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinedotproduct (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply expanded A * expanded B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, TRUE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, TRUE, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemultiplyadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    //set B to 1
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    //set D to arg3
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinelerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;
    
    // Multiply A * B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG0, TRUE, FALSE, FALSE);
    //set D to arg3
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    
    return (hr);
}

//---------------------------------------------------------------------------

// Set up output combiners

void ConstructOutputColorCombiners(PNVD3DCONTEXT pContext, int enable, int stage, int bias, int shift, int dotAB, int dotCD, int outtemp)
{
    outtemp  &= (stage != 1);

    if (!enable) {
        assert(stage > 0);  // stage 0 should always be enabled
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    if (stage == 0) {

        if (shift == 0) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _NOSHIFT);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _NOSHIFT_BIAS);
        }
        else if (shift == 1) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
        }
        else if (shift == 2) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY2);
            else
                // we can't shift by 2 and bias. do the best we can...
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
        }

        // select mux enable
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_MUX_SELECT, _LSB);  // the '1' is not a typo
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_MUX_ENABLE, _FALSE);

        // select AB dot enable
        if (dotAB)
        {
            pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_AB_DOT_ENABLE, _TRUE);

            if(dotCD)//select CD dot enable, and the sum as final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                            DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_D));
                else
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                            DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_C));
            }
            else //if only AB dot enabled, put A*B as the final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_AB_DST, _REG_D); 
                else
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_AB_DST, _REG_C); 
            }
        }
        else //select the sum as final result
        {
            if (outtemp)
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_D);
            else
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_C);
        }
    }

    else { // stage 1

        if (shift == 0) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _NOSHIFT);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _NOSHIFT_BIAS);
        }
        else if (shift == 1) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
        }
        else if (shift == 2) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY2);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1);
        }

        // select mux enable
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_MUX_SELECT, _LSB);
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_MUX_ENABLE, _FALSE);

        // select AB dot enable
        if (dotAB)
        {
            pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_AB_DOT_ENABLE, _TRUE);

            if(dotCD)// select CD dot enable, and sum as final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                                DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_D));
                else
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                                DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_C));
            }
            else //if only AB dot enabled, put A*B as the final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_AB_DST, _REG_D);
                else
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_AB_DST, _REG_C); 
            }
        }
        else //select the sum as final result
        {
            if (outtemp)
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_D);
            else
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_C);
        }
    }
}

//---------------------------------------------------------------------------

BOOL ConstructColorCombiners (PNVD3DCONTEXT pContext, int hdStage, int dxStage )
{
    int     dotproduct, bias, shift;
    BOOL    enable, stageactive;
    HRESULT hr = 0;

    dotproduct = 0;
    bias = 0;
    shift = 0;
    enable = TRUE;
    stageactive = TRUE;

    pContext->hwState.dwColorICW[hdStage] = 0;
    pContext->hwState.dwColorOCW[hdStage] = 0;

    switch (pContext->tssState[dxStage].dwValue[D3DTSS_COLOROP]) {
        default:
        case D3DTOP_DISABLE:
            if (dxStage == 0) { // only construct for stage 0
                // Default is diffuse color, make A=diffuse, B=1, C=D=0
                pContext->hwState.dwColorICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
                SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
            }
            else {
                enable = FALSE; // don't enable output combiner
            }
            stageactive = FALSE;
            break;
        case D3DTOP_SELECTARG1:
            hr = combineselect1 (pContext, hdStage, dxStage);
            break;
        case D3DTOP_SELECTARG2: // same as 2 from above
            hr = combineselect2 (pContext, hdStage, dxStage);
            break;
        case D3DTOP_MODULATE4X:
            shift++;
        case D3DTOP_MODULATE2X:
            shift++;
        case D3DTOP_MODULATE:
            hr = combinemodulate (pContext, hdStage, dxStage);
            break;
        case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
            shift = 1;
        case D3DTOP_ADDSIGNED:   // same as add with following change
            bias = 1;
        case D3DTOP_ADD:
            hr = combineadd (pContext, hdStage, dxStage);
            break;
        case D3DTOP_SUBTRACT:
            hr = combinesub (pContext, hdStage, dxStage);
            break;
        case D3DTOP_ADDSMOOTH:
            hr = combineaddsmooth (pContext, hdStage, dxStage);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_DIFFUSE);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TEXTURE);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TFACTOR);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            hr = combineblendalpha (pContext, hdStage, dxStage, TEXTUREPM);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_CURRENT);
            break;
        case D3DTOP_PREMODULATE:
            hr = combinepremodulate (pContext, hdStage, dxStage);
            break;
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            hr = combinemodulatealpha (pContext, hdStage, dxStage, 0);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            hr = combinemodulatecolor (pContext, hdStage, dxStage, 0);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            hr = combinemodulatealpha (pContext, hdStage, dxStage, 1); // complement
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            hr = combinemodulatecolor (pContext, hdStage, dxStage, 1); // complement
            break;
        case D3DTOP_BUMPENVMAP:
            break;
        case D3DTOP_BUMPENVMAPLUMINANCE:
            break;
        case D3DTOP_DOTPRODUCT3:
            hr = combinedotproduct (pContext, hdStage, dxStage);
            dotproduct = 1;
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_DOTPRODUCT3(hdStage);
            break;
        case D3DTOP_MULTIPLYADD:
            hr = combinemultiplyadd (pContext, hdStage, dxStage);
            break;
        case D3DTOP_LERP:
            hr = combinelerp (pContext, hdStage, dxStage);
            break;
        }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (hdStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwColorICW[hdStage] = DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
        }
        else {
            pContext->hwState.dwColorICW[hdStage] = DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_C);
        }
        SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    }

    ConstructOutputColorCombiners (pContext, enable, hdStage, bias, shift, dotproduct, 0, 
                                   pContext->tssState[dxStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);

    return (stageactive);
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusInlPrim.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusInlPrim.cpp                                              *
*       indexed and ordered inline primitive                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             20Oct99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
//void nvCelsiusILCompile_beginEnd               (DWORD dwPrimType);
//void nvCelsiusILCompile_computeIndexAndOffset  (DWORD dwVBStride,DWORD dwVBLogStride);
//void nvCelsiusILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvCelsiusILCompile_copyVertex             (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvCelsiusILCompile_prefetch               (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvCelsiusILCompile_limit                  (DWORD regLimit,DWORD regDummy);

//void __stdcall nvCelsiusDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvCelsiusDispatchGetPusherSpace (void);
#ifdef DEBUG
//void __stdcall nvCelsiusDispatchFlush          (void);
//void __stdcall nvCelsiusDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

//---------------------------------------------------------------------------

// transformed points with per-vertex pointsize

// this handles the specific case of SW-transformed vertices that include a per-vertex
// point size. we are guaranteed that it is a single-stream primitive from stream zero.
// the vertex format will be a DX6-style TL vertex plus a point size.

// the HW may or may not have been programmed to expect one set of texture coordinates,
// continent on whether this is a textured point sprite or just a plain point. note that
// if we do send texture coordinates, we generate them upside down relative to D3D so
// that we match the manner in which celsius itself generates them in the HW T&L case.

void __cdecl nvCelsiusDumpTLPoints (DWORD dwFlags)
{
    DWORD          dwDiffuse,dwSpecular,dwU,dwV;
    float          fx,fy,fz,fw,fpsize;
    float          fx1,fx2,fy1,fy2;
    BOOL           bIsIndexed, bTexCoords;
    WORD          *pIndices   = (WORD *)(global.celsius.pIndices);
    PBYTE          pVertices  = (PBYTE)(global.celsius.pVertices);
    PBYTE          pVertex;
    PNVD3DCONTEXT  pContext   = (PNVD3DCONTEXT)global.celsius.pContext;
    CVertexShader *pVertexShader = pContext->pCurrentVShader;

    nvAssert ((pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS) ||
              (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT));
    nvAssert (pContext->pCurrentVShader->getStride() == 0x24);

    bIsIndexed = ((dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_INL_PRIM)    ? TRUE : FALSE;
    bTexCoords = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) ? TRUE : FALSE;

    // cache current values, then set solid fill, solid shading, and disable culling
    DWORD dwOldFillMode  = pContext->dwRenderState[D3DRENDERSTATE_FILLMODE];
    DWORD dwOldShadeMode = pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE];
    DWORD dwOldCullMode  = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];

    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]  = D3DFILL_SOLID;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] = D3DSHADE_FLAT;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]  = D3DCULL_NONE;

    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
    nvSetCelsiusState (pContext);

    // begin primitive
    nvPushData (0, ((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
    nvPushData (1, NV056_SET_BEGIN_END_OP_TRIANGLES);
    nvPusherAdjust (2);

    for (DWORD i=0; i<global.celsius.dwPrimCount; i++)
    {
        pVertex = pVertices + ((bIsIndexed ? pIndices[i] : i) * pVertexShader->getStride());

        fpsize  = *(float*)(pVertex + pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_PSIZE]));
        fpsize *= 0.5f;
        fpsize  = min (fpsize, 32.0f);
        fx1     = *(float*)(pVertex + 0) - fpsize;
        fx2     = *(float*)(pVertex + 0) + fpsize;
        fy1     = *(float*)(pVertex + 4) - fpsize;
        fy2     = *(float*)(pVertex + 4) + fpsize;
        fz      = *(float*)(pVertex + 8);
        fw      = *(float*)(pVertex + 12);
        dwDiffuse  = *(DWORD *)(pVertex + pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]));
        dwSpecular = *(DWORD *)(pVertex + pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]));

        if (bTexCoords) {
            for (DWORD j=0; j<6; j++) {
                switch (j) {
                    case 0:        fx=fx1; fy=fy1; dwU=FP_ONE_BITS; dwV=FP_ONE_BITS; break;
                    case 5:        fx=fx2; fy=fy2; dwU=0;           dwV=0;           break;
                    case 2:case 3: fx=fx1; fy=fy2; dwU=FP_ONE_BITS; dwV=0;           break;
                    case 1:case 4: fx=fx2; fy=fy1; dwU=0;           dwV=FP_ONE_BITS; break;
                }
                getDC()->nvPusher.push (0, (8 << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
                getDC()->nvPusher.push (1, dwU);
                getDC()->nvPusher.push (2, dwV);
                getDC()->nvPusher.push (3, dwSpecular);
                getDC()->nvPusher.push (4, dwDiffuse);
                getDC()->nvPusher.push (5, DWORD_FROM_FLOAT(fx));
                getDC()->nvPusher.push (6, DWORD_FROM_FLOAT(fy));
                getDC()->nvPusher.push (7, DWORD_FROM_FLOAT(fz));
                getDC()->nvPusher.push (8, DWORD_FROM_FLOAT(fw));
                nvPusherAdjust (9);
            }
        }
        else {
            for (DWORD j=0; j<6; j++) {
                switch (j) {
                    case 0:        fx=fx1; fy=fy1; break;
                    case 5:        fx=fx2; fy=fy2; break;
                    case 2:case 3: fx=fx1; fy=fy2; break;
                    case 1:case 4: fx=fx2; fy=fy1; break;
                }
                getDC()->nvPusher.push (0, (6 << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
                getDC()->nvPusher.push (1, dwSpecular);
                getDC()->nvPusher.push (2, dwDiffuse);
                getDC()->nvPusher.push (3, DWORD_FROM_FLOAT(fx));
                getDC()->nvPusher.push (4, DWORD_FROM_FLOAT(fy));
                getDC()->nvPusher.push (5, DWORD_FROM_FLOAT(fz));
                getDC()->nvPusher.push (6, DWORD_FROM_FLOAT(fw));
                nvPusherAdjust (7);
            }
        }
    }

    // end primitive
    nvPushData (0,((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    nvPushData (1, NV056_SET_BEGIN_END_OP_END);
    nvPusherAdjust(2);

    // restore original fill, shade, and cull values
    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]  = dwOldFillMode;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] = dwOldShadeMode;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]  = dwOldCullMode;

    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
}

//---------------------------------------------------------------------------

DWORD nvCelsiusILCompile_inline_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    DWORD  dwMagic                = celsiusPrimitiveToPrimitiveMagic[dwFlags & CELSIUS_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & CELSIUS_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_INL_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    if ((pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
        &&
        ((pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS) || (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT)))
    {
        // do the point size expansion
#if 1 //USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
            xPUSH_r (rEAX)
            xMOV_rm_imm (rmREG(rEAX),nvCelsiusDumpTLPoints)
            xCALL_rm (rmREG(rEAX))
            xADD_rm_imm (rmREG(rESP),4);
#else //USE_C_LOGIC
        nvAssert(0);
#endif
    }
    else
    {
    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
    ILCCompile_mul (rEBX, dwVerticesPerPrim);
    if (dwStartVerticesPerPrim)
    {
        xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
    }

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
        if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
            xMOV_i32_r  (mMEM32(global.celsius.pIndexBase),rEAX)
        }
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.celsius.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvCelsiusILCompile_prefetch (bIsIndexed, bLegacyStrides);

        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEDX)
            // compute vertex offset
            ILCCompile_mul (rESI,global.celsius.dwVertexStride);
            // range limit for NT
            nvCelsiusILCompile_limit (rESI,rECX);

            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(global.celsius.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvCelsiusILCompile_copyVertex (pContext,dwFlags);

        // update instumentation stats
#ifdef INSTRUMENT_INNER_LOOPS
        {
            xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride)
            xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
        }
#endif


        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32  (labelLoop)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END4_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif
    }
    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET

    return lEntry;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusInlTri.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusInlTri.cpp                                               *
*       indexed and ordered inline triangle lists                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             20Oct99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
void nvCelsiusILCompile_beginEnd               (DWORD dwPrimType);
void nvCelsiusILCompile_computeIndexAndOffset  (DWORD dwVBStride,DWORD dwVBLogStride);
void nvCelsiusILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvCelsiusILCompile_copyVertex             (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvCelsiusILCompile_prefetch               (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvCelsiusILCompile_limit                  (DWORD regLimit,DWORD regDummy);

void __stdcall nvCelsiusDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvCelsiusDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvCelsiusDispatchFlush          (void);
void __stdcall nvCelsiusDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

/*****************************************************************************
 *****************************************************************************
 *** helpers *****************************************************************
 *****************************************************************************
 *****************************************************************************/

void nvCelsiusILCompile_cullcheck
(
    BOOL bIsIndexed
)
{
    //
    // get vertices into eax, ebx and ecx
    //
    if (bIsIndexed)
    {
        // already set up correctly
    }
    else
    {
        xMOV_r_i32       (rEAX,mMEM32(global.celsius.pVertices))
        xMOV_r_rm        (rEBX,rmREG(rEAX))
        xMOV_r_rm        (rECX,rmREG(rEAX))
        xADD_rm_imm      (rmREG(rEBX),global.celsius.dwVertexStride)
        xADD_rm_imm      (rmREG(rECX),global.celsius.dwVertexStride * 2)
    }

    //
    // compute cross product
    //
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        /*
         * katmai
         */
        xMOVLPS_r_rm     (rXMM0,rmIND(rEAX))
        xMOVLPS_r_rm     (rXMM1,rmIND(rEBX))
        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0x44)          // xmm0: y0     x0      y0      x0
        xMOVHPS_r_rm     (rXMM1,rmIND(rECX))                // xmm1: y2     x2      y1      x1

        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: y2-y0  x2-x0   y1-y0   x1-x0
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: y2-y0  x2-x0   x1-x0   y1-y0

        xMOVHLPS_r_r     (rXMM0,rXMM1)                      // xmm0: ?      ?       y2-y0   x2-x0
        xMULPS_r_rm      (rXMM0,rmREG(rXMM1))               // xmm0: ?      ?       (x1-x0)*(y2-y0) (y1-y0)*(x2-x0)

        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)

        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0)
        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.celsius.dwCullValue))
    }
    else
    {
        /*
         * generic
         */
        xFLD_rm32  (rmIND(rEAX))                    // X0
        xFLD_rm32  (rmIND(rEBX))                    // X1 | X0
        xFXCH_st   (rST1)                           // X0 | X1
        xFSUBP_st  (rST1)                           // X1-X0
        xFLD_rm32  (rmIND8(rECX)) xOFS8(4)          // Y2 | X1-X0
        xFXCH_st   (rST1)                           // X1-X0 | Y2
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | X1-X0 | Y2
        xFXCH_st   (rST1)                           // X1-X0 | Y0 | Y2
        xFLD_rm32  (rmIND(rECX))                    // X2 | X1-X0 | Y0 | Y2
        xFXCH_st   (rST3)                           // Y2 | X1-X0 | Y0 | X2
        xFLD_rm32  (rmIND(rEAX))                    // X0 | Y2 | X1-X0 | Y0 | X2
        xFXCH_st   (rST3)                           // Y0 | Y2 | X1-X0 | X0 | X2
        xFSUBP_st  (rST1)                           // Y2-Y0 | X1-X0 | X0 | X2
        xFXCH_st   (rST3)                           // X2 | X1-X0 | X0 | Y2-Y0
        xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)          // Y1 | X2 | X1-X0 | X0 | Y2-Y0
        xFXCH_st   (rST3)                           // X0 | X2 | X1-X0 | Y1 | Y2-Y0
        xFSUBP_st  (rST1)                           // X2-X0 | X1-X0 | Y1 | Y2-Y0
        xFXCH_st   (rST3)                           // Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFXCH_st   (rST2)                           // X1-X0 | Y2-Y0 | Y0 | Y1 | X2-X0
        xFMULP_st  (rST1)                           // (X1-X0)(Y2-Y0) | Y0 | Y1 | X2-X0
        xFXCH_st   (rST1)                           // Y0 | (X1-X0)(Y2-Y0) | Y1 | X2-X0
        xFSUBP_st  (rST2)                           // (X1-X0)(Y2-Y0) | Y1-Y0 | X2-X0
        xFXCH_st   (rST2)                           // X2-X0 | Y1-Y0 | (X1-X0)(Y2-Y0)
        xFMULP_st  (rST1)                           // (X2-X0)(Y1-Y0) | (X1-X0)(Y2-Y0)
        xFSUBP_st  (rST1)                           // (X1-X0)(Y2-Y0)-(X2-X0)(Y1-Y0)
        xFSTP_i32  (mMEM32(global.dwTemp))
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.celsius.dwCullValue))
    }
}

/*****************************************************************************
 *****************************************************************************
 *** inline triangle lists ***************************************************
 *****************************************************************************
 *****************************************************************************/
DWORD nvCelsiusILCompile_inline_tri_list
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    BOOL   bLegacyStrides = dwFlags & CELSIUS_ILFLAG_LEGACY;
    BOOL   bIsIndexed     = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_INL_TRI_LIST;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
    ILCCompile_mul (rEBX,bLegacyStrides ? 4 : 3);

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.celsius.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END_OP_TRIANGLES)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // load prim count into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelEarlyExit;
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvCelsiusILCompile_prefetch (bIsIndexed,bLegacyStrides);

        //
        // do two triangles at a time
        //
        for (DWORD dwTriNum = 0; dwTriNum < 2; dwTriNum++)
        {
            if (bIsIndexed)
            {
                //
                // compute vertices
                //
                xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
                xXOR_r_rm   (rECX,rmREG(rECX))
                xLEA_r_rm   (rEAX,rmIND8(rEDX)) xOFS8 (bLegacyStrides ? 8 : 6)
                xMOV_r_rm   (rEBX,rmIND(rEDX))
           x16r xMOV_r_rm   (rCX,rmIND8(rEDX)) xOFS8(4)
                xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEAX)
                xMOV_r_rm   (rEAX,rmREG(rEBX))
                xSHR_rm_imm8(rmREG(rEBX),16)
                xAND_rm_imm (rmREG(rEAX),0xffff)
                // convert indices to vertex address with limit checking (on NT)
                        ILCCompile_mul (rECX,global.celsius.dwVertexStride);
                    ILCCompile_mul (rEBX,global.celsius.dwVertexStride);
                ILCCompile_mul (rEAX,global.celsius.dwVertexStride);
                        nvCelsiusILCompile_limit (rECX,rEDX);
                    nvCelsiusILCompile_limit (rEBX,rEDX);
                nvCelsiusILCompile_limit (rEAX,rEDX);
                    xADD_r_i32  (rEBX,mMEM32(global.celsius.pVertices))
                xADD_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
                        xADD_r_i32  (rECX,mMEM32(global.celsius.pVertices))
            }

            //
            // do cull check
            //      indexed - eax,ebx and ecx has vertex addresses
            //      ordered - pVertices has vertex0, rest follow in dwVertexStride increments
            DWORD labelCull;
            if (!(dwFlags & CELSIUS_ILFLAG_NOCULL))
            {
                nvCelsiusILCompile_cullcheck (bIsIndexed);
                xLABEL      (labelCull)
                xJZ32       (0)
            }

            //
            // copy vertices
            //
            if (bIsIndexed)
            {
                xPUSH_r     (rECX)
                xPUSH_r     (rEBX)
                xMOV_r_rm   (rESI,rmREG(rEAX))
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
            }
            else
            {
                xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.celsius.dwVertexStride)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.celsius.dwVertexStride)
                nvCelsiusILCompile_copyVertex (pContext,dwFlags);
            }

            if (!(dwFlags & CELSIUS_ILFLAG_NOCULL))
            {
                xTARGET_b32 (labelCull)
            }

            // update instrumentation count (include culled tris so we have a normalized result)
#ifdef INSTRUMENT_INNER_LOOPS
            {
                xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride * 3)
                xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
            }
#endif

            //
            // next triangle
            //
            if (bIsIndexed)
            {
                // nothing to do here
            }
            else
            {
                xMOV_r_i32  (rEAX,mMEM32(global.celsius.pVertices))
                xADD_rm_imm (rmREG(rEAX),global.celsius.dwVertexStride * 3)
                xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
            }

            //
            // done already? (odd # of triangles)
            //
            if (dwTriNum == 0)
            {
                xPOP_r  (rEBX)
                xDEC_rm (rmREG(rEBX))
                xLABEL  (labelEarlyExit)
                xJZ32   (0)
                xPUSH_r (rEBX)
            }
        }

/*
        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {

// do in setup ....
          if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
            xMOV_i32_r  (mMEM32(global.celsius.pIndexBase),rEAX)
        }


                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEDX)
            // compute vertex offset
            ILCCompile_mul (rESI,fvfData.dwVertexStride);
            // range limit
            xXOR_r_rm   (rECX,rmREG(rECX))
            xCMP_r_i32  (rESI,mMEM32(global.dwMaxVertexOffset))
            xSETAE_rm8  (rmREG(rCL))
            xDEC_rm     (rmREG(rECX))
            xAND_r_rm   (rESI,rmREG(rECX))
            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(fvfData.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvCelsiusILCompile_copyVertex (pContext);
*/

        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32      (labelLoop)
    xTARGET_b32 (labelEarlyExit)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END4_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusNvTSS.cpp ===
// **************************************************************************
///
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusNvTSS.cpp
//      Celsius 2 stage combiner setup routines.
//
// **************************************************************************
//
//  History:
//      Lorie Sixia Deng       12Dec99         NV10 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

BOOL nvCheckBumpMapStates(PNVD3DCONTEXT pContext, int nStage)
{

    PNVD3DTEXSTAGESTATE ptssState0, ptssState1, ptssState2, ptssState3,
                        ptssState4, ptssState5, ptssState6, ptssState7;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    ptssState4 = &pContext->tssState[4];
    ptssState5 = &pContext->tssState[5];
    ptssState6 = &pContext->tssState[6];
    ptssState7 = &pContext->tssState[7];

    /*
    * Make specific check for our version of bump mapping.
    *
    * THIS IS A VERY SPECIFIC CHECK FOR OUR BUMP MAPPING ALGORITHM.  ALL CONDITIONS MUST BE
    * TRUE OR WE WILL FAIL VALIDATION AND NOT RENDER ANYTHING PREDICTABLE.
    *
    * Even though D3D specifies that Arg2 cannot be a texture, since we used to do this for
    * our bump mapping algorithm, I'm going to continue to allow it so that we don't break
    * anything.
    */

    if ((ptssState0->dwValue[D3DTSS_TEXTUREMAP] == NULL) ||
        (ptssState1->dwValue[D3DTSS_TEXTUREMAP] == NULL))
    {
        return FALSE;
    }

    if (nStage==4)
    {

        if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
            || (ptssState0->dwValue[D3DTSS_ALPHAARG1] != (D3DTA_TEXTURE | D3DTA_COMPLEMENT))
            || (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
            || (ptssState0->dwValue[D3DTSS_TEXCOORDINDEX] != 0)
            || (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
            || (!((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_TEXTURE)
            && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_CURRENT))
            && !((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_CURRENT)
            && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)))
            || (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
            || (ptssState1->dwValue[D3DTSS_TEXCOORDINDEX] != 1)
            || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
            || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
            || (ptssState2->dwValue[D3DTSS_COLORARG1] != (D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE))
            || (ptssState2->dwValue[D3DTSS_COLORARG2] != D3DTA_DIFFUSE)
            || (ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
            || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState3->dwValue[D3DTSS_COLORARG1] != D3DTA_TEXTURE)
            || (ptssState3->dwValue[D3DTSS_TEXCOORDINDEX] != 0))
            return FALSE;

        else
            return TRUE;
    }

    else if (nStage==8)
    {
        /*
        * Check the alphaops and colorops.
        *
        * Stages 0, 2, 4, and 6 should all be set as D3DTOP_MODULATE.
        */
        if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState4->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState4->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
            || (ptssState6->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
            || (ptssState6->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE))
            return FALSE;

        /*
        * Stages 3 and and 7 should all be set as D3DTOP_SELECTARG1
        */
        if ((ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
            || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1)
            || (ptssState7->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
            || (ptssState7->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
            return FALSE;

        /*
        * Stages 1 and 5 should be one of the following:
        * D3DTOP_ADD, D3DTOP_ADDSIGNED, D3DTOP_ADDSIGNED2X or D3DTOP_SUBTRACT.
        * We also allow D3DTOP_MODULATE2X and D3DTOP_MODULATE4X to be specified
        * but these operations are translated to ADD2 and ADD4 respectively.
        */
        if ((ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
            && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
            return FALSE;

        if ((ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
            && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
            return FALSE;

        if ((ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
            && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
            return FALSE;

        if ((ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
            && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
            return FALSE;

        return TRUE;

    }
    else
    {
        return FALSE;
    }
}

//set up the celsius combiners for either the current texture stage state
// or a legacy texture blend
HRESULT nvSetCelsius4StageBumpMapCombiners  (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE ptssState0, ptssState1, ptssState2, ptssState3;

    //dbgTracePush ("nvSetCelsuisBumpMap1Combiners");

    /*
    * Set up some pointers to the individual texture stages.
    */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];

    /*
    * Set up Bump Mapping State.
    *
    * Texture0 and Texture1 comes from stage 0, 1 or 3 (always same texture).
    * Texture0 is used for stages with TEXCOORDINDEX = 0
    * Texture1 is used for stages with TEXCOORDINDEX = 1
    */
    pContext->hwState.dwTexUnitToTexStageMapping[0]=0;
    pContext->hwState.dwTexUnitToTexStageMapping[1]=1;
    pContext->hwState.dwNumActiveCombinerStages=2;

    pContext->hwState.dwAlphaICW[0] = DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, 8)   // texture0
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,1)       // replicate alpha
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,9)    // texture1
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,0);

    pContext->hwState.dwAlphaOCW[0] = DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, 1)  // add bais
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, 0xc)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);

    pContext->hwState.dwColorICW[0] = DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,1)     // replicate alpha
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, 8)   // texture0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,1)     // replicate alpha
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,9);   // texture1

    pContext->hwState.dwColorOCW[0] = DRF_NUM(056, _SET_COMBINER0_COLOR_OCW, _OPERATION, 3) // add bais shiftleft by1
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_SUM_DST, 0xc)  // out put from combiner0
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DST, 0);

    pContext->hwState.dwAlphaICW[1] = DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,1)       // unsigned_invert
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,0);

    pContext->hwState.dwAlphaOCW[1] = DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, 0)  // add no shift
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, 0xc)   // output from combiner0
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);

    pContext->hwState.dwColorICW[1] = DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,1)       // unsinged_invert
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, 0xc) // output from combiner0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,8)    // texture0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,8)    // texture0
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,0)
                                    | DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,4);   // diffuse

    pContext->hwState.dwColorOCW[1] = DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _ITERATION_COUNT, 2) // use both cominbers
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_SELECT, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _OPERATION, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_SUM_DST, 0xc)  // output from cominber0
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DST, 0)
                                    | DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DST, 0);

#if COMBINER_STATUS
    DPF ("Result in 4 stage bump mapping set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif

    return (D3D_OK);
}

HRESULT nvSetCelsius8StageBumpMapCombiners(PNVD3DCONTEXT pContext)
{
    DWORD                   operation, finDst;
    DWORD                   argASource, argAMap, argAAlpha;
    DWORD                   argBSource, argBMap, argBAlpha;
    DWORD                   argCSource, argCMap, argCAlpha;
    DWORD                   argDSource, argDMap, argDAlpha;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3, ptssState4, ptssState5, ptssState6, ptssState7;
    PNVD3DTEXSTAGESTATE     ptssTexture0, ptssTexture1;

    finDst=0xc;

    //dbgTracePush ("nvSetCelsuisBumpMap2Combiners");

    /*
     * Set up some pointers to the individual texture stages.
     */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    ptssState4 = &pContext->tssState[4];
    ptssState5 = &pContext->tssState[5];
    ptssState6 = &pContext->tssState[6];
    ptssState7 = &pContext->tssState[7];
    // pmtsState  = &pContext->mtsState;


    /*
     * Next track down all the textures being used.
     * The method for selecting the textures is simple:
     *   Map Stage 0 Texture/TextureCoordIndex to TEXTURE0.
     *   Map Stage 1 Texture/TextureCoordIndex to TEXTURE1.
     */

    ptssTexture0 = &pContext->tssState[0];
    ptssTexture1 = &pContext->tssState[1];

    pContext->hwState.dwTexUnitToTexStageMapping[0]=0;
    pContext->hwState.dwTexUnitToTexStageMapping[1]=1;
    pContext->hwState.dwNumActiveCombinerStages=2;


    /*
     * Setup hardware texture combiner 0 alpha components based on texture stages 0-3.
     * Operation comes from AlphaOp of stage 1.
     * Arguments come from AlphaArg1 of stages 0-3.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0));
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
     * Select Alpha Argument A Combiner 0.
     */
    switch (ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argAMap=!((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument B Combiner 0.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argBMap=!((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Select Alpha Argument C Combiner 0.
    */
    switch (ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argCMap=!((ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument D Combiner 0.
     */
    switch (ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argDMap=!((ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Program Texture Combine 0 Alpha Stage.
     */
    pContext->hwState.dwAlphaICW[0]= DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,argAMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, argASource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,argBMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,argBSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,argCMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,argCSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,argDMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwAlphaOCW[0]=DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, operation)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, finDst)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);

    /*
    * Setup hardware texture combiner 0 color components based on texture stages 0-3.
    * Operation comes from ColorOp of stage 1.
    * Arguments come from ColorArg1 of stages 0-3.
    */
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTRGB(0));
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
    * Select Color Argument A Combiner 0.
    */
    switch (ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0;
        break;
    }
    argAMap=!((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argAAlpha = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Select Color Argument B Combiner 0.
    */
    switch (ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0;
        break;
    }
    argBMap=!((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argBAlpha = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Select Color Argument C Combiner 0.
    */
    switch (ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0;
        break;
    }
    argCMap=!((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argCAlpha = !((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Select Color Argument D Combiner 0.
    */
    switch (ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;
        break;
    }
    argDMap=!((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argDAlpha = !((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
    * Program Texture Combine 0 Color Stage.
    */
    pContext->hwState.dwColorICW[0]= DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,argAMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,argAAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, argASource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,argBMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,argBAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,argBSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,argCMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,argCAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,argCSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,argDMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,argDAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwColorOCW[0]= DRF_NUM(056, _SET_COMBINER0_COLOR_OCW, _OPERATION, operation)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_MUX_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_SUM_DST, finDst)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_AB_DST, 0)
                                        |DRF_NUM(056, _SET_COMBINER0_COLOR_OCW,_CD_DST, 0);

    /*
    * Setup hardware texture combiner 1 alpha components based on texture stages 0-3.
    * Operation comes from AlphaOp of stage 5.
    * Arguments come from AlphaArg1 of stages 4-7.
    */

    argAMap=argBMap=argCMap=argDMap=0;

    switch (ptssState5->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTALPHA(1));
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SPECFOG_COMBINER;
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
    * Select Alpha Argument A Combiner 1.
    */

    switch (ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argAMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }

    argAMap ^=!((ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Select Alpha Argument B Combiner 1.
    */
    switch (ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argBMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argBMap  =argBMap ^(!((ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0));

    /*
    * Select Alpha Argument C Combiner 1.
    */
    switch (ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argCMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }
    argCMap ^=!((ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Select Alpha Argument D Combiner 1.
    */
    switch (ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0))
            argDMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0;
        break;
    }

    argDMap ^=!((ptssState7->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
    * Program Texture Combine 1 Alpha Stage.
    */
    pContext->hwState.dwAlphaICW[1]= DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,argAMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, argASource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,argBMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE,argBSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,argCMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE,argCSource)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,argDMap)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,1)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwAlphaOCW[1]=DRF_NUM(056, _SET_COMBINER_ALPHA_OCW, _OPERATION, operation)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_MUX_ENABLE, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_SUM_DST, finDst)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_AB_DST, 0)
                                |DRF_NUM(056, _SET_COMBINER_ALPHA_OCW,_CD_DST, 0);



    /*
     * Setup hardware texture combiner 1 color components based on texture stages 0-3.
     * Operation comes from ColorOp of stage 5.
     * Arguments come from ColorArg1 of stages 4-7.
     */
    argAMap=argBMap=argCMap=argDMap=0;

    switch (ptssState5->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADD:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT;
        break;
    case D3DTOP_ADDSIGNED:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS;
        break;
    case D3DTOP_ADDSIGNED2X:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS;
        break;
    case D3DTOP_SUBTRACT:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT;
        pContext->hwState.dwStateFlags |= (CELSIUS_FLAG_ADDCOMPLEMENTRGB(1));
        pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SPECFOG_COMBINER);
        break;
    case D3DTOP_MODULATE2X:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1;
        break;
    case D3DTOP_MODULATE4X:
        operation = NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2;
        break;
    }

    /*
     * Select Color Argument A Combiner 1.
     */
    switch (ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argAMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1;
        else
            argASource = NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0;
        break;
    }
    argAMap ^= !(ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0;
    argAAlpha = !((ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument B Combiner 1.
     */
    switch (ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argBMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8;
        else if (ptssTexture0 && ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1;
        else
            argBSource = NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0;
        break;
    }
    argBMap ^=!((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argBAlpha = !((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument C Combiner 1.
     */
    switch (ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argCMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1;
        else
            argCSource = NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0;
        break;
    }
    argCMap ^= !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argCAlpha = !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument D Combiner 1.
     */
    switch (ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
    case D3DTA_DIFFUSE:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_CURRENT:
        argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C;
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(0))
            argDMap=1;
        break;
    case D3DTA_TEXTURE:
        if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8;
        else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4;
        break;
    case D3DTA_TFACTOR:
        if ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1;
        else
            argDSource = NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;
        break;
    }
    argDMap ^= !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    argDAlpha = !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Program Texture Combine 1 Color Stage.
     */
    pContext->hwState.dwColorICW[1]= DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_MAP,argAMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,argAAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, argASource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_MAP,argBMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,argBAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE,argBSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_MAP,argCMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,argCAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE,argCSource)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_MAP,argDMap)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,argDAlpha)
                                        |DRF_NUM(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE,argDSource);

    pContext->hwState.dwColorOCW[1]= DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _ITERATION_COUNT, 2)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_SELECT, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW, _OPERATION, operation)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_MUX_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DOT_ENABLE, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_SUM_DST, finDst)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_AB_DST, 0)
                                        |DRF_NUM(056, _SET_COMBINER1_COLOR_OCW,_CD_DST, 0);

#if COMBINER_STATUS
    DPF ("Result in 8 stage mapping set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif

    return (D3D_OK);
}


static BOOL Check3StageColor(PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    //In stage 0: Color Op = D3DTOP_SELECTARG1 or D3DTOP_SELECTARG2
    if ((ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG2))
        goto Fail;

   //in stage 0: texture has to be selected
    if(!((((ptssState0->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1))
        ||(((ptssState0->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG2))))
        goto Fail;

    //In Stage 0: validate the texture
    if (!(ptssState0->dwValue[D3DTSS_TEXTUREMAP]))
        goto Fail;

    //In stage 1: Color Arg1=current xor Arg2=current
    //And not alpha replication could be used for current in stage 1
    if (!(((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
        ^((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK) == D3DTA_CURRENT)))
        goto Fail;
    else
    {
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
        {
            if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
        else
        {
             if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
    }

    //When the stage1 color op = BlendCurrentAlpha, the stage0 alpha has to be select texture
    //restrictly, cannot use complement of the texture
    if((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDCURRENTALPHA)
        &&(!(((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG1)
        &&(ptssState0->dwValue[D3DTSS_ALPHAARG1] == D3DTA_TEXTURE))
        ||((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG2)
        &&(ptssState0->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)))))
        goto Fail;

    //In Stage 1: Vaidate texture if it is used
    //We know that op1!= selectArg1 or selectArg2 (if it is, it is going to fail the final setting)
    if ((((ptssState1->dwValue[D3DTSS_COLORARG1] &D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        ||((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE))
        &&(!(ptssState1->dwValue[D3DTSS_TEXTUREMAP])))
        goto Fail;

    //In stage 2: Color Arg1=current or Arg2==current
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) != D3DTA_CURRENT)
        &&((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)!= D3DTA_CURRENT))
        goto Fail;
     else
    {
        if((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
        {
            if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
        else
        {
             if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
                goto Fail;
        }
    }


    //In Stage 2: Non of the Arg could be Texture
    if (((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_TEXTURE)
        ||((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK) == D3DTA_TEXTURE))
        goto Fail;

    return TRUE;

Fail:
    DPF_LEVEL (NVDBG_LEVEL_INFO,"Failed the Color Arg check or the Color Op0 for 2 texture 3 stage");

    return FALSE;
}


static BOOL Check3StageAlpha(PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    DWORD alphaStageCount = 0;
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    while ((alphaStageCount < 8) &&
        (pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    if(alphaStageCount==0)
        return TRUE;
    else //alphaStageCount>0
    {
        //In stage 0: Texture is validated in Color Check alrady

        if(alphaStageCount==1)
            return TRUE;
        else //alphaStageCount>1
        {
            //In stage 1: Validate texture if is used.
            if (((((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK) == D3DTA_TEXTURE)
                &&(ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2))
                ||((ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)
                &&((ptssState1->dwValue[D3DTSS_ALPHAOP]&D3DTA_SELECTMASK)!= D3DTOP_SELECTARG1)))
                &&(!(ptssState1->dwValue[D3DTSS_TEXTUREMAP])))
                return FALSE;
            else
            {
                if(alphaStageCount==2)
                    return TRUE;
                else
                {
                    DPF_LEVEL (NVDBG_LEVEL_INFO,"Alpha Stage# > 2, Too many alpha stages");

                    return FALSE;
                }
            }
        }
    }
}

//Check for the conditions that meet for 2 texture stage one combiner
static BOOL colorCheck2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //Add, Modulate
    if ((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        &&
        ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)   ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X) ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)))
    {
        //one and only one arg ins tage1 be current
        //no apha replicate or complement allowed for the "current" arg
        if (((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            ^((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        {
            if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            {
                if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            else
            {
                 if((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            return TRUE;
        }
        else
            goto Fail;
    }

    //Modulate, Add
    if((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
        &&((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)))
    {
        //one and only one arg ins tage1 be current
        //no apha replicate or complement allowed for the "current" arg
           if (((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            ^((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        {
            if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            {
                if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            else
            {
                 if((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE))
                    goto Fail;
            }
            return TRUE;
        }
        else
            goto Fail;
    }

Fail:
/*#ifdef DEBUG
        DPF("Cannot put 2 stages Color setting into one combiner");
        _asm int 3;
#endif
*/
        return FALSE;
}
static BOOL alphaCheck2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;
    DWORD                  alphaStageCount=0;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    while ((alphaStageCount < 2)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    if (alphaStageCount < 2)
        return TRUE;

    else //alpha stage > 1
    {
        //Add, Modulate
        if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
           &&
           ((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)   ||
            (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE2X) ||
            (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE4X)))
        {
            //one and only one arg ins tage1 be current
            //no complement allowed for the "current" arg
            if (((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                ^((ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
            {
                if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                else
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                return TRUE;
            }
            else
                goto Fail;
        }

        //Modulate, Add
        if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)
            &&((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
            ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED)
            ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SUBTRACT)))
        {
            //one and only one arg ins tage1 be current
            //no complement allowed for the "current" arg
            if (((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                ^((ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
            {
                if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                else
                {
                    if(ptssState1->dwValue[D3DTSS_ALPHAARG2]&D3DTA_COMPLEMENT)
                        goto Fail;
                }
                return TRUE;
            }
            else
                goto Fail;
        }
    }

Fail:
/*#ifdef DEBUG
DPF("Cannot put 2 stages alpha setting into one combiner");
_asm int 3;
#endif
    */
    return FALSE;
}


/***************************************************************************************
* This is a special case to save one combiner stage
* Handle the case of (X0+X1)*X2 for color operation
* Set Color Combiner0 A=X0; B=X2; C=X1; D=X2
* Where  X0= one Arg of Stage 0; could be T0
*        X1= one Arg of Stage 1; could be T1;(the other Arg of Stage 1 is CURRENT)
* Disable Combiner1
*        X3= one Arg of Stage 2; cannot be TEXTURE;(the other Arg of Stage 1 is CURRENT)
* Alpha setting may not follow this
****************************************************************************************/

static HRESULT AddMod1(PNVD3DCONTEXT pContext)
{
    int      shift;
    BOOL     compA,compC, repA, repC, expA, expC;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2;

    //initialize the flag for combiner
    shift  = 0;
    compA=compC=repA=repC=expA=expC=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    //initialize color combiner0
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //Disable color combine1
    pContext->hwState.dwColorICW[1]=0;
    pContext->hwState.dwColorOCW[1]=0x10000000;
    pContext->hwState.dwNumActiveCombinerStages = 1;

    //deal with the situation for current complement

    if((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)!=0))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)!=0)))
        compA ^=TRUE;

    /***************************************************************/
    /*Color Combiner 0 Setup
    /**************************************************************/
    //Stage0 Op = SelectArg1 or SelectArg2
    //Check Stage1 Op

    if (ptssState1->dwValue[D3DTSS_COLOROP]==D3DTOP_SUBTRACT)
    {
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        {   //(T0*B)+(-T1)*D
            compC ^=TRUE;
            expC=TRUE;
        }
        else
        {   //(-T0)*B+(T1)*D
            compA ^=TRUE;
            expA=TRUE;
        }
    }
    //Check Stage2 Op
    switch (ptssState2->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift +=2;
        break;
    }

    //Color combiner ICW[0]
    pContext->hwState.dwNextAvailableTextureUnit=0;
    //input value A from stage0 Arg
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1,compA, expA, repA);
    else//D3DOP_SELECTARG2
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG2,compA, expA, repA);

    pContext->hwState.dwNextAvailableTextureUnit=1;

    //input value C from stage1 args
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG2,compC, expC, repC);
    else
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1,compC, expC, repC);

    //input value  B & D from stage2 args (B=D)
    if((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
    }
    else
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, shift, 0, 0, 0 );
    //End of Color Combiner 0 Setup
    return (D3D_OK);

} //end AddMod1


/******************************************************************************************
/*
/*Normal case of Color Combiner0 set up, DX7 Stage 0 and Stage 1
/*
/******************************************************************************************/

/*****************************************************************************************
/*Set Color Combiner0 for op1=add/subtract: A=X0; B=1/-1; C=X1; D=1/-1
/*****************************************************************************************/
static HRESULT Add1(PNVD3DCONTEXT pContext)
{
    int                     bias, shift;
    BOOL                    compA, repA, negB, negD, smoothA, smoothC;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;

    //initialize the flags for combiner
    bias=shift = 0;
    compA=repA=FALSE;
    negB=negD=smoothA=smoothC=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize color combiner0
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //deal with the situation for current complement and alpha replicat
    if((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)!=0))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)!=0)))
        compA ^=TRUE;

    //Color Combiner 0
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADDSIGNED:
        bias=1;
        break;
    case D3DTOP_ADDSIGNED2X:
        bias=1;
        shift++;
        break;
    case D3DTOP_SUBTRACT:
        if((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
            negB=TRUE; // T0*(-1)+T1*1
        else
            negD=TRUE; // T0*1+T1*(-1)
        break;
    case D3DTOP_ADDSMOOTH:
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
            smoothA=TRUE;
        else
            smoothC=TRUE;
        break;
    }

    pContext->hwState.dwNextAvailableTextureUnit=0;
    //input value A from stage0 Arg
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
    {
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1,compA,FALSE,repA);
        if(smoothA)  //input D as ~(A-alpha)
        {
            compA ^=TRUE;
            SelectColorInput(pContext, celsiusCombinerInputD, 0, 0, D3DTSS_COLORARG1,compA,FALSE,repA);
        }
    }
    else//D3DOP_SELECTARG2
    {
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG2,compA,FALSE,repA);
        if(smoothA) //input D as ~(A-alpha)
        {
            compA ^=TRUE;
            SelectColorInput(pContext, celsiusCombinerInputD, 0, 0, D3DTSS_COLORARG1,compA,FALSE,repA);
        }
    }

    pContext->hwState.dwNextAvailableTextureUnit=1;

    //input value C from stage1 args
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG2,FALSE,FALSE,FALSE);
        if(smoothC) //input B as ~(C-alpha)
        {
            SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG2,TRUE,FALSE,FALSE);
            SetColorInputOne(pContext, celsiusCombinerInputD, 0, FALSE);
        }
    }
    else
    {
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1,FALSE,FALSE,FALSE);
        if(smoothC) //input B as ~(C-alpha)
        {
            SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1,TRUE,FALSE,FALSE);
            SetColorInputOne(pContext, celsiusCombinerInputD, 0, FALSE);
        }
    }

    //If no addSmooth is used, use the normal setting
    if((!smoothC)&&(!smoothA))
    {
        //Set B=1 or (-1 if op 1 is subtract)
        SetColorInputOne (pContext, celsiusCombinerInputB, 0, negB);
        //Set D=1 or (-1 if op 1 is subtract)
        SetColorInputOne (pContext, celsiusCombinerInputD, 0, negD);
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, bias, shift, 0, 0, 0);
    //End of Color Combiner 0 Setup

    return (DD_OK);
}//end Add1

/***************************************************************************************
/*Set Color Combiner0 for op1=add/subtract: A=X0; B=1; C=0; D=0
/****************************************************************************************/
static HRESULT Mod1(PNVD3DCONTEXT pContext)
{
    int                     shift;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    BOOL                    compA0, repA0;

     //initialize the flags for combiner
    shift = 0;
    compA0=repA0=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;


    if((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)!=0))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        &((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)!=0)))
        compA0 ^=TRUE;

    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift +=2;
        break;
    }
    //Color combiner ICW[0]
    //input value A from stage 0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1,compA0, FALSE, repA0);
    else//D3DOP_SELECTARG2
        SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG2,compA0, FALSE, repA0);

    //input value B from Stage 1
    pContext->hwState.dwNextAvailableTextureUnit=1;
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
    else
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);

    //input value  C & D default to be 0

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, shift, 0, 0, 0);
    //End of Color Combiner 0 Setup

    return (D3D_OK);
}//end Mod1


/********************************************************************
/* Set Color Combiner0 for AlphaBlend
/* alpha * arg1 + (1-alpha) * arg2
/********************************************************************/
static HRESULT Blend1(PNVD3DCONTEXT  pContext)
{
    int                    pm, type, temp;
    BOOL                   compA0, repA0;
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;

    //initialize the flags for combiner
    pm=0;
    compA0=repA0=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize combiner0 & Combiner1
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //deal with the situation for current complement
    if ((((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) &&
         ((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) != 0))
        ||
        (((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT) &&
         ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_COMPLEMENT) != 0))) {
        compA0 ^= TRUE;
    }

    // check Stage1 op to determine source of alpha
    switch (ptssState1->dwValue[D3DTSS_COLOROP]) {
        case D3DTOP_BLENDDIFFUSEALPHA:
            type=D3DTA_DIFFUSE;
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            type=D3DTA_TEXTURE;
            // alpha comes from stage 1's texture
            pContext->hwState.dwNextAvailableTextureUnit = 1;
            break;
        case D3DTOP_BLENDFACTORALPHA:
            type=D3DTA_TFACTOR;
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            type=D3DTA_TEXTURE;
            // alpha comes from stage 1's texture
            pContext->hwState.dwNextAvailableTextureUnit = 1;
            pm=1;
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            type=D3DTA_TEXTURE;
            // current alpha comes in from stage 0's texture
            pContext->hwState.dwNextAvailableTextureUnit = 0;
            break;
    }

    // A gets alpha (or 1)
    if (pm == 1) {
        // Make A 1 since texture is already pre-multiplied
        SetColorInputOne (pContext, celsiusCombinerInputA, 0, FALSE);
    }
    else {
        // Make A alpha, appropriate type
        temp = ptssState1->dwValue[D3DTSS_COLORARG2];
        ptssState1->dwValue[D3DTSS_COLORARG2] = type;
        SelectColorInput (pContext, celsiusCombinerInputA, 0, 1, D3DTSS_COLORARG2, FALSE, FALSE, TRUE);
        ptssState1->dwValue[D3DTSS_COLORARG2] = temp;
    }

    // C gets (1-alpha)
    temp = ptssState1->dwValue[D3DTSS_COLORARG1];
    ptssState1->dwValue[D3DTSS_COLORARG1] = type;
    SelectColorInput (pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1, TRUE, FALSE, TRUE);
    ptssState1->dwValue[D3DTSS_COLORARG1] = temp;

    // B gets arg1
    if ((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        // take output of d3d stage 0 (stage 0 op guaranteed to be a simple selectarg)
        pContext->hwState.dwNextAvailableTextureUnit = 0;
        SelectColorInput (pContext, celsiusCombinerInputB, 0, 0,
                          (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1) ? D3DTSS_COLORARG1 : D3DTSS_COLORARG2,
                          compA0, FALSE, repA0);
    }
    else {
        // take arg1 from this stage in the normal fashion
        pContext->hwState.dwNextAvailableTextureUnit = 1;
        SelectColorInput (pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    }

    // D gets arg2
    if ((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        // take output of d3d stage 0 (stage 0 op guaranteed to be a simple selectarg)
        pContext->hwState.dwNextAvailableTextureUnit = 0;
        SelectColorInput (pContext, celsiusCombinerInputD, 0, 0,
                          (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1) ? D3DTSS_COLORARG1 : D3DTSS_COLORARG2,
                          compA0, FALSE, repA0);
    }
    else if (((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT)
        && ((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK) == D3DTA_TEXTURE)) {
        // take output of d3d stage 0 - fix for mfc tex bug ((tex0 OP tex1) MOD diffuse)
        pContext->hwState.dwNextAvailableTextureUnit = 0;
        SelectColorInput (pContext, celsiusCombinerInputD, 0, 0, D3DTSS_COLORARG1, compA0, FALSE, repA0);
    }
    else {
        // take arg2 from this stage in the normal fashion
        pContext->hwState.dwNextAvailableTextureUnit = 1;
        SelectColorInput (pContext, celsiusCombinerInputD, 0, 1, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    }

    // color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, 0, 0, 0, 0);

    return(D3D_OK);

} // Blend1


/*************************************************************************************
/* Color combiner1 set up for DX7 Stage 2
/**************************************************************************************/

/************************************************************************************
/ Color Combiner1 for op=add/mod/select in stage2
/************************************************************************************/
static HRESULT AddModSelect2(PNVD3DCONTEXT  pContext)
{
    int                     dotproduct, bias,shift, modselect;
    BOOL                    negD, smooth, forcearg1to1, forcearg2to1;
    PNVD3DTEXSTAGESTATE     ptssState2;

    //initialize
    negD=smooth=forcearg1to1=forcearg2to1=FALSE;
    dotproduct=bias =shift=modselect=0;

    ptssState2 = &pContext->tssState[2];

    pContext->hwState.dwColorICW[1] = 0; //enable 2 combiners
    pContext->hwState.dwColorOCW[1] = 0x20000000;

     //Check the Stage2 Op
     switch (ptssState2->dwValue[D3DTSS_COLOROP])
     {
     case D3DTOP_ADDSIGNED:
         bias=1;
         break;
     case D3DTOP_ADDSIGNED2X:
         bias=1;
         shift++;
         break;
     case D3DTOP_SUBTRACT:
         negD=TRUE;
         break;
     case D3DTOP_ADDSMOOTH:
         smooth=TRUE;
         break;
     case D3DTOP_MODULATE:
         modselect=1;
         break;
     case D3DTOP_MODULATE2X:
         modselect=1;
         shift++;
         break;
     case D3DTOP_MODULATE4X:
         modselect=1;
         shift +=2;
         break;
     case D3DTOP_SELECTARG1:
         modselect=1;
         forcearg2to1=TRUE;
         break;
     case D3DTOP_SELECTARG2:
         modselect=1;
         forcearg1to1=TRUE;
         break;
     case D3DTOP_DOTPRODUCT3: //in DX stage2
         dotproduct=1;
         modselect=1;
         pContext->hwState.dwStateFlags |= CELSIUS_FLAG_DOTPRODUCT3(1);
         break;
     }

     //Color combiner ICW[1]
     //input value A & B from Stage 2
     if(modselect) //modulate setting
     {
         if (forcearg1to1) SetColorInputOne (pContext, celsiusCombinerInputA, 1, FALSE);
         else              SelectColorInput(pContext, celsiusCombinerInputA, 1, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);

         if (forcearg2to1) SetColorInputOne (pContext, celsiusCombinerInputB, 1, FALSE);
         else              SelectColorInput(pContext, celsiusCombinerInputB, 1, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
         //input value  C & D defalt to 0
     }
     else //add involved
     {
         SelectColorInput(pContext, celsiusCombinerInputA, 1, 2, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
         SelectColorInput(pContext, celsiusCombinerInputC, 1, 2, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
         SetColorInputOne (pContext, celsiusCombinerInputB, 1, FALSE);
         if(smooth)
             SelectColorInput(pContext, celsiusCombinerInputD, 1, 2, D3DTSS_COLORARG1,TRUE, FALSE, FALSE);
         else
             SetColorInputOne (pContext, celsiusCombinerInputD, 1, negD);
     }

     //Color Combiner OWC[1]
     ConstructOutputColorCombiners(pContext, TRUE, 1, bias, shift, dotproduct, 0, 0);

     //update the number of combinerstage that are used
     pContext->hwState.dwNumActiveCombinerStages = 2;

     return (D3D_OK);
}//end AddModSelect2

/************************************************************
Color: stage0: arg0+arg1; stage1: arg0*arg1
*************************************************************/
static HRESULT colorAddMod(PNVD3DCONTEXT  pContext, int textureCount)
{
    PNVD3DTEXSTAGESTATE ptssState0, ptssState1;
    int                 shift;

    //initialize the flag for combiner
    shift = 0;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize color combiner0
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;

    //Disable color combine1
    pContext->hwState.dwColorICW[1]=0;
    pContext->hwState.dwColorOCW[1]=0x10000000;
    pContext->hwState.dwNumActiveCombinerStages = 1;

    //Check Stage0 Op

    // can't do subtraction. this would require a mapping like [0 1] -> [0 -1] which we don't have
    nvAssert (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT);

    //Chech Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift +=2;
        break;
    }

    //Color combiner ICW[0]
    pContext->hwState.dwNextAvailableTextureUnit=0;

    //input A, C from stage0 args
    SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SelectColorInput(pContext, celsiusCombinerInputC, 0, 0, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;

    //input value  B & D from stage2 args (B=D)
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_COLORARG2,FALSE, FALSE, FALSE);
    }
    else
    {
        SelectColorInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
        SelectColorInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_COLORARG1,FALSE, FALSE, FALSE);
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, 0, shift,0, 0, 0);
    return (D3D_OK);
}//colorAddMod


/************************************************************
Color: stage0: arg0*arg1; stage1: arg0+arg1
*************************************************************/
static HRESULT colorModAdd(PNVD3DCONTEXT  pContext, int textureCount)
{
    int                     shift, bias;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;

    //initialize the flags for combiner
    shift = bias = 0;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize
    pContext->hwState.dwColorICW[0] = 0;
    pContext->hwState.dwColorOCW[0] = 0;
    pContext->hwState.dwColorICW[1] = 0;
    pContext->hwState.dwColorOCW[1] = 0x10000000;


    SetColorInputOne(pContext, celsiusCombinerInputD, 0, 0); // Set D = 1

    //Check Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
    case D3DTOP_ADDSIGNED:
        bias=1;
        break;
    case D3DTOP_ADDSIGNED2X:
        bias=1;
        shift++;
        break;
    }

    //input A & B from stage 0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    SelectColorInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SelectColorInput(pContext, celsiusCombinerInputB, 0, 0, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    //input C from stage1
    pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    else
        SelectColorInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);


    if (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT) {
        if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        {
            SetColorInputOne(pContext, celsiusCombinerInputD, 0, 1); //Set D = -1
        }
        else //Make the setting to be (A*(-B))+C*1
        {
            SetColorMapping(pContext, celsiusCombinerInputB, 0, NV056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE);
        }
    }

    //Color Combiner OCW[0]
    ConstructOutputColorCombiners(pContext, TRUE, 0, bias, shift,  0, 0, 0);
    //End of Color Combiner 0 Setup
    return (D3D_OK);
}//colorModAdd

/************************************************************
Alpha: stage0: arg0+arg1; stage1: arg0*arg1
*************************************************************/
static HRESULT alphaAddMod(PNVD3DCONTEXT  pContext, int textureCount)
{
    PNVD3DTEXSTAGESTATE ptssState0, ptssState1;
    int                 shift;

    //initialize the flag for combiner
    shift = 0;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //Disable alpha combines
    pContext->hwState.dwAlphaICW[0]=0;
    pContext->hwState.dwAlphaOCW[0]=0;
    pContext->hwState.dwAlphaICW[1]=0;
    pContext->hwState.dwAlphaOCW[1]=0;
    pContext->hwState.dwNumActiveCombinerStages = 1;

    //Check Stage0 Op

    // can't subtract. this would require a mapping like [0 1] -> [0 -1] which we don't have
    nvAssert (ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT);

    //Chech Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_MODULATE2X:
        shift++;
        break;
    case D3DTOP_MODULATE4X:
        shift += 2;
        break;
    }

    //ALPHA combiner ICW[0]
    pContext->hwState.dwNextAvailableTextureUnit=0;
    //input A, C from stage0 args
    SelectAlphaInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_ALPHAARG1, FALSE, FALSE);
    SelectAlphaInput(pContext, celsiusCombinerInputC, 0, 0, D3DTSS_ALPHAARG2, FALSE, FALSE);

    pContext->hwState.dwNextAvailableTextureUnit = textureCount-1;

    //input value  B & D from stage1 args (B=D)
    if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
    {
        SelectAlphaInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_ALPHAARG2, FALSE, FALSE);
        SelectAlphaInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_ALPHAARG2, FALSE, FALSE);
    }
    else
    {
        SelectAlphaInput(pContext, celsiusCombinerInputB, 0, 1, D3DTSS_ALPHAARG1, FALSE, FALSE);
        SelectAlphaInput(pContext, celsiusCombinerInputD, 0, 1, D3DTSS_ALPHAARG1, FALSE, FALSE);
    }


    //Color Combiner OCW[0]
    ConstructOutputAlphaCombiners(pContext, TRUE, 0, 0, shift, 0);
    //End of Color Combiner 0 Setup

    return (D3D_OK);

}//alphaAddMod

/************************************************************
Alpha: stage0: arg0*arg1; stage1: arg0+arg1
*************************************************************/
static HRESULT alphaModAdd(PNVD3DCONTEXT  pContext, int textureCount)
{   int                     shift, bias;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    BOOL     compA,repA,expA;

    //initialize the flags for combiner
    shift =bias = 0;
    compA=repA=expA=FALSE;

    //Set up some pointers to the individual texture stages.
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    //initialize
    pContext->hwState.dwAlphaICW[0] = 0;
    pContext->hwState.dwAlphaOCW[0] = 0;
    pContext->hwState.dwAlphaICW[1] = 0;
    pContext->hwState.dwAlphaOCW[1] = 0; //0x10000000;

    //Set D = 1
    SetAlphaInputOne(pContext, celsiusCombinerInputD, 0, 0);

    //Check Stage1 Op
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
    case D3DTOP_ADDSIGNED:
        bias=1;
        break;
    case D3DTOP_ADDSIGNED2X:
        bias=1;
        shift++;
        break;
    case D3DTOP_SUBTRACT:
        if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
        {
            //Set A*B+C*(-1)
            SetAlphaInputOne(pContext, celsiusCombinerInputD,0, 1);
        }
        else//Make the setting to be ((-A)*B))+C*1
        {
            compA ^=TRUE;
            expA=TRUE;
        }
        break;
    }

    //input A & B from stage 0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    SelectAlphaInput(pContext, celsiusCombinerInputA, 0, 0, D3DTSS_ALPHAARG1,compA, expA);
    SelectAlphaInput(pContext, celsiusCombinerInputB, 0, 0, D3DTSS_ALPHAARG2,FALSE, FALSE);

    //input C from stage1
    pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;
    if((ptssState1->dwValue[D3DTSS_ALPHAARG1]&D3DTA_SELECTMASK) == D3DTA_CURRENT)
        SelectAlphaInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_ALPHAARG2,FALSE, FALSE);
    else
        SelectAlphaInput(pContext, celsiusCombinerInputC, 0, 1, D3DTSS_ALPHAARG1,FALSE, FALSE);


    //Alpha Combiner OCW[0]
    ConstructOutputAlphaCombiners(pContext, TRUE, 0, bias, shift, 0);

    return (D3D_OK);
}//alphaModAdd
 /***********************************************************************************
 /*Alpha combiner setup
/***********************************************************************************/
static HRESULT SetAlphaCombiner(PNVD3DCONTEXT pContext, DWORD alphaCount, DWORD textureCount)
{
    DWORD combCount;

    //Initialize alpha combiners
    pContext->hwState.dwAlphaICW[0] = 0;
    pContext->hwState.dwAlphaOCW[0] = 0;
    pContext->hwState.dwAlphaICW[1] = 0;
    pContext->hwState.dwAlphaOCW[1] = 0;

    combCount=pContext->hwState.dwNumActiveCombinerStages;

    pContext->hwState.dwNextAvailableTextureUnit=0;


    if(alphaCount<=1)
        ConstructAlphaCombiners(pContext, 0, 0, TRUE );

    else if(alphaCount==2)
    {
        if(combCount==1)
        {
            if(alphaCheck2Stage1Combiner(pContext))
            {
                PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
                //Set up some pointers to the individual texture stages.
                ptssState0 = &pContext->tssState[0];
                ptssState1 = &pContext->tssState[1];

                if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
                   &&
                   ((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)   ||
                    (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE2X) ||
                    (ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE4X)))
                {
                    if (alphaAddMod(pContext, textureCount)==D3D_OK)
                        return D3D_OK;
                }

                //Modulate, Add
                if((ptssState0->dwValue[D3DTSS_ALPHAOP] == D3DTOP_MODULATE)
                    &&((ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADD)
                    ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED)
                    ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_ADDSIGNED2X)
                    ||(ptssState1->dwValue[D3DTSS_ALPHAOP] == D3DTOP_SUBTRACT)))
                {
                    if (alphaModAdd(pContext, textureCount)==D3D_OK)
                        return D3D_OK;
                }
            }

            else
                pContext->hwState.dwColorOCW[1] = 0x20000000;//enable color combiner1
        }

        pContext->hwState.dwNumActiveCombinerStages = 2;

        pContext->hwState.dwNextAvailableTextureUnit=0;
        ConstructAlphaCombiners(pContext, 0,0, TRUE );
        pContext->hwState.dwNextAvailableTextureUnit=textureCount-1;
        ConstructAlphaCombiners(pContext, 1,1, TRUE );
    }
    else
        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;

    return (D3D_OK);
}//end SetAlphaCombiner

/*************************************************************************
Set up color combiners for (X0 op X1) op X2 with 3 DX7 TSS:
*X0 is one of the colorargs from stage0
*X1 is one of the colorargs from stage1, cannot be D3DTA_CURRENT
*X2 is color arg from stage2, cannot be D3DTA_TEXTURE
In order the above is true:
*colorOp is stage0 has to be D3DTOP_SELECTARG1/2
*one and only one of the color args in stage1 to be D3DTA_CURRENT
*at least one of the color args in stage2 to be D3DTA_CURRENT

 op=all Modulateion,addition,subtraction and linear alpha blending
 Including D3DTOP_DUCTPRODUCT3 and D3DTOP_ADDSMOOTH

Only allow 2 alpha active stages, if has more, only look at the first 2
**************************************************************************/

#ifdef THREE_STAGE_ALPHA_SUPPORT

#define D3DTA_FLAGSMASK 0x000000f0
#define D3DTA_STAGEMASK 0xf0000000
#define D3DTA_STAGE0    0x00000000
#define D3DTA_STAGE1    0x10000000
#define D3DTA_STAGE2    0x20000000
#define D3DTA_STAGE3    0x30000000

HRESULT SelectAlphaInput2(PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwArg, BOOL bComplement, BOOL bInv) {
    DWORD dwICW = 0x10101010;

    switch (dwArg & D3DTA_SELECTMASK) {
    case D3DTA_DIFFUSE:   dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);   break;
    case D3DTA_CURRENT:   dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);   break;
    case D3DTA_TEXTURE:
        if ((dwArg & D3DTA_STAGEMASK) == D3DTA_STAGE0) {
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_8);
        } else {
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_9);
        }
        break;
    case D3DTA_TFACTOR:   dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);   break;
    case D3DTA_SPECULAR:  dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_5);   break;
    case D3DTA_TEMP:      dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);   break;
    }

    if (bComplement && bInv) {
        // not quite right, but close enough
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    } else if (bComplement && !bInv) {
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);
    } else if (!bComplement && bInv) {
        dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _SIGNED_NEGATE);
    }

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);

    return TRUE;
}


BOOL nvCelsiusSet3StageAlphaCombiners(PNVD3DCONTEXT pContext, BOOL program) {
    NVD3DTEXSTAGESTATE tssState0 = pContext->tssState[0];
    NVD3DTEXSTAGESTATE tssState1 = pContext->tssState[1];
    NVD3DTEXSTAGESTATE tssState2 = pContext->tssState[2];

    if (tssState0.dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP) return FALSE;

    int current;
    if (tssState0.dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG1) {
        current = tssState0.dwValue[D3DTSS_ALPHAARG1];
    } else if (tssState0.dwValue[D3DTSS_ALPHAOP] == D3DTOP_SELECTARG2) {
        current = tssState0.dwValue[D3DTSS_ALPHAARG2];
    } else {
        return FALSE;
    }

    tssState1.dwValue[D3DTSS_ALPHAARG1] |= D3DTA_STAGE1;
    tssState1.dwValue[D3DTSS_ALPHAARG2] |= D3DTA_STAGE1;

    if ((tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG1] = ((tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_FLAGSMASK) ^ (current & D3DTA_FLAGSMASK)) | current;
    }
    if ((tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG2] = ((tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_FLAGSMASK) ^ (current & D3DTA_FLAGSMASK)) | current;
    }


    // stage 0 current is really diffuse
    if ((tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG1] = (tssState1.dwValue[D3DTSS_ALPHAARG1] & D3DTA_FLAGSMASK) | D3DTA_DIFFUSE;
    }
    if ((tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_CURRENT) {
        tssState1.dwValue[D3DTSS_ALPHAARG2] = (tssState1.dwValue[D3DTSS_ALPHAARG2] & D3DTA_FLAGSMASK) | D3DTA_DIFFUSE;
    }

    int shift=0, bias=0;
    int inputA=0xf, inputB=0xf, inputC=0xf, inputD=0xf, inputTemp;
    int invA=0, invB=0, invC=0, invD=0;
    int compA=0, compB=0, compC=0, compD=0;

    switch (tssState1.dwValue[D3DTSS_ALPHAOP]) {
    case D3DTOP_SELECTARG1:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        break;
    case D3DTOP_SELECTARG2:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compB = 1;
        break;

    case D3DTOP_MODULATE4X:
        shift = 1;
    case D3DTOP_MODULATE2X:
        shift++;
    case D3DTOP_MODULATE:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState1.dwValue[D3DTSS_ALPHAARG2];
        break;

    case D3DTOP_PREMODULATE:
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        break;

    case D3DTOP_ADDSIGNED2X:
        shift = 1;
    case D3DTOP_ADDSIGNED:
        bias = 1;
    case D3DTOP_ADD:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;
        break;

    case D3DTOP_SUBTRACT:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;
        invD = 1;
        break;

    case D3DTOP_ADDSMOOTH:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compB = 1;
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA:
    case D3DTOP_BLENDTEXTUREALPHA:
    case D3DTOP_BLENDFACTORALPHA:
    case D3DTOP_BLENDTEXTUREALPHAPM:
    case D3DTOP_BLENDCURRENTALPHA:
        inputA = tssState1.dwValue[D3DTSS_ALPHAARG1];
        inputC = tssState1.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;

        switch (tssState1.dwValue[D3DTSS_ALPHAOP]) {
        case D3DTOP_BLENDDIFFUSEALPHA:     inputTemp = D3DTA_DIFFUSE;  break;
        case D3DTOP_BLENDTEXTUREALPHA:     inputTemp = D3DTA_TEXTURE;  break;
        case D3DTOP_BLENDFACTORALPHA:      inputTemp = D3DTA_TFACTOR;  break;
        case D3DTOP_BLENDCURRENTALPHA:     inputTemp = current;        break;
        case D3DTOP_BLENDTEXTUREALPHAPM:   return FALSE;   // not supported yet
        }

        inputB = inputTemp;
        inputD = inputTemp;

        break;


    case D3DTOP_BUMPENVMAP:
    case D3DTOP_BUMPENVMAPLUMINANCE:
    case D3DTOP_DOTPRODUCT3:
    case D3DTOP_MULTIPLYADD:
    case D3DTOP_LERP:
        // not supported yet
        return FALSE;
    }

    if (program) {
        pContext->hwState.dwAlphaICW[0] = 0;
        pContext->hwState.dwAlphaOCW[0] = 0;
        SelectAlphaInput2(pContext, celsiusCombinerInputA, 0, inputA, compA, invA);
        SelectAlphaInput2(pContext, celsiusCombinerInputB, 0, inputB, compB, invB);
        SelectAlphaInput2(pContext, celsiusCombinerInputC, 0, inputC, compC, invC);
        SelectAlphaInput2(pContext, celsiusCombinerInputD, 0, inputD, compD, invD);
        ConstructOutputAlphaCombiners(pContext, TRUE, 0, bias, shift, tssState1.dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);
    }

//////////////////////////////////////

    shift = 0;
    bias = 0;
    inputA = inputB = inputC = inputD = 0xf;
    invA = invB = invC = invD = 0;
    compA = compB = compC = compD = 0;

    if (((tssState2.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_TEXTURE) ||
        ((tssState2.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE) ||
        ((tssState2.dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK) == D3DTA_TEMP) ||
        ((tssState2.dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEMP))
        return FALSE;

    switch (tssState2.dwValue[D3DTSS_ALPHAOP]) {
    case D3DTOP_SELECTARG1:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        compB = 1;
        break;
    case D3DTOP_SELECTARG2:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compB = 1;
        break;

    case D3DTOP_MODULATE4X:
        shift = 1;
    case D3DTOP_MODULATE2X:
        shift++;
    case D3DTOP_MODULATE:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState2.dwValue[D3DTSS_ALPHAARG2];
        break;

    case D3DTOP_PREMODULATE:
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        break;

    case D3DTOP_ADDSIGNED2X:
        shift = 2;
    case D3DTOP_ADDSIGNED:
        bias = 2;
    case D3DTOP_ADD:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        compB = 2;
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 2;
        break;

    case D3DTOP_SUBTRACT:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        compB = 2;
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 2;
        invD = 2;
        break;

    case D3DTOP_ADDSMOOTH:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        inputB = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compB = 2;
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 2;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA:
    case D3DTOP_BLENDTEXTUREALPHA:
    case D3DTOP_BLENDFACTORALPHA:
    case D3DTOP_BLENDTEXTUREALPHAPM:
    case D3DTOP_BLENDCURRENTALPHA:
        inputA = tssState2.dwValue[D3DTSS_ALPHAARG1];
        inputC = tssState2.dwValue[D3DTSS_ALPHAARG2];
        compD = 1;

        switch (tssState2.dwValue[D3DTSS_ALPHAOP]) {
        case D3DTOP_BLENDDIFFUSEALPHA:     inputTemp = D3DTA_DIFFUSE;  break;
        case D3DTOP_BLENDTEXTUREALPHA:     inputTemp = D3DTA_TEXTURE;  break;
        case D3DTOP_BLENDFACTORALPHA:      inputTemp = D3DTA_TFACTOR;  break;
        case D3DTOP_BLENDCURRENTALPHA:     inputTemp = D3DTA_CURRENT;  break;
        case D3DTOP_BLENDTEXTUREALPHAPM:   return FALSE;   // not supported yet
        }

        break;

    case D3DTOP_BUMPENVMAP:
    case D3DTOP_BUMPENVMAPLUMINANCE:
    case D3DTOP_DOTPRODUCT3:
    case D3DTOP_MULTIPLYADD:
    case D3DTOP_LERP:
        // not supported yet
        return FALSE;
    }


    if (program) {
        pContext->hwState.dwAlphaICW[1] = 0;
        pContext->hwState.dwAlphaOCW[1] = 0;
        SelectAlphaInput2(pContext, celsiusCombinerInputA, 1, inputA, compA, invA);
        SelectAlphaInput2(pContext, celsiusCombinerInputB, 1, inputB, compB, invB);
        SelectAlphaInput2(pContext, celsiusCombinerInputC, 1, inputC, compC, invC);
        SelectAlphaInput2(pContext, celsiusCombinerInputD, 1, inputD, compD, invD);
        ConstructOutputAlphaCombiners(pContext, TRUE, 1, bias, shift, tssState2.dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);
    }

    return TRUE;
}
#endif

BOOL nvCelsiusCheck3Stage2Textures(PNVD3DCONTEXT pContext)
{
    if((Check3StageAlpha(pContext)
#ifdef THREE_STAGE_ALPHA_SUPPORT
        || nvCelsiusSet3StageAlphaCombiners(pContext, FALSE)
#endif
        )
        &&Check3StageColor(pContext))
        return TRUE;
    else
        return FALSE;
}

HRESULT nvCelsiusSetTextures3StageCombiners(PNVD3DCONTEXT pContext)
{

    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1, ptssState2;
    DWORD                  alphaStageCount=0;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    dbgTracePush("nvCelsiusSetTextures3StageCombiners");

    while ((alphaStageCount < 8)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    //Set up Color Combiners
   //Check for Add in Stage1
    if((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH))

    {
        //Cehck for AddMod which could be done in one combiner.
        if(((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT))
            &&((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X))
            &&(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT)
            ^((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT)))
        {
            if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_CURRENT)
            {
                if(!((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
                    ||(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)))
                {
                    if (AddMod1(pContext)==D3D_OK)
                        goto FinalStep;
                }
            }
            else
            {
                //hack for single combiner (arg1 OP arg2) MOD diffuse where OP=subtract when
                //arg1=tex0, arg2=tex0,diffuse,etc. the math fits in one combiner stage but the result
                //does not match refrast. TODO: make two tex,3 stage subtract work in one combiner
                if((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
                    &&((ptssState0->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK )== D3DTA_TEXTURE)
                    &&(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT))
                {
                       goto Normal2ColorCombiner;
                }

                if(!((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
                   ||(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)))
                {
                   if (AddMod1(pContext)==D3D_OK)
                       goto FinalStep;
                 }
            }
        }

Normal2ColorCombiner:

        //Fall to the normal 2 color combiner stage
        if((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)
            //Last stage, stage2: Color operation could be dotprocut3
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))

        {
            Add1(pContext);
            AddModSelect2(pContext);
            goto FinalStep;
        }

        else //Something Wrong
            goto Invalid;
    }

    //Check for Modulate in stage 1
    else if ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X))

    {
        if((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)
            //Last stage, stage2: Color operation could be dotprocut3
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
        {
            Mod1(pContext);
            AddModSelect2(pContext);
            goto FinalStep;
        }

        else //Something Wrong
            goto Invalid;
    }

    //Check for alphaBlend in Stage1
    else if((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDDIFFUSEALPHA)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDTEXTUREALPHA)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDFACTORALPHA)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDTEXTUREALPHAPM)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_BLENDCURRENTALPHA))
    {
        if((ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSMOOTH)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG1)
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_SELECTARG2)
            //Last stage, stage2: Color operation could be dotprocut3
            ||(ptssState2->dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
        {
            Blend1(pContext);
            AddModSelect2(pContext);
            goto FinalStep;
        }
        else
            goto Invalid;
    }
    else
        goto Invalid;

Invalid:

    DPF ("Invalid COLOR OPERATION for 2 texture 3 stages");
    nvAssert(0);

    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
    dbgTracePop();
    return (D3D_OK);

FinalStep:
#ifdef THREE_STAGE_ALPHA_SUPPORT
    if (alphaStageCount > 2) {
        nvCelsiusSet3StageAlphaCombiners(pContext, TRUE);
    } else
#endif
    {
        SetAlphaCombiner (pContext,alphaStageCount, 2);
    }
    pContext->hwState.dwTexUnitToTexStageMapping[0]=0;
    pContext->hwState.dwTexUnitToTexStageMapping[1]=1;

#if COMBINER_STATUS
    DPF ("Result in 3 stage 2 set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif
    dbgTracePop();
    return (D3D_OK);

} // nvCelsiusSetTextures3StagesCombiners

/**************************************************************
For special 2 DX texutre stages but only one combiner stage
case 1:
stage0: arg0+arg1
stage1: arg0*arg1  (arg0=current or arg1=current)

case 2:
stage0: arg0*arg1
stage1: arg0+arg1  (arg0=current or arg1=current)

+ = ADD, ADDSIGNED, ADDSIGNED2X, SUBTRACR
* = MODULATE, MODULATE2X, MODULATE4X, cannot be DOT3
***************************************************************/


BOOL nvCelsiusCheck2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    if(colorCheck2Stage1Combiner(pContext)
        &&alphaCheck2Stage1Combiner(pContext))
        return TRUE;
    else
        return FALSE;
}//nvCelsiusCheck2Stage1Combiner


HRESULT nvCelsiusSet2Stage1Combiner (PNVD3DCONTEXT pContext)
{
    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1;
    WORD alphaStageCount, textureCount;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];

    dbgTracePush("nvCelsiusSet2Stage1Combiner");

    alphaStageCount=textureCount=0;

    //Get the # of active alpha stages
    while ((alphaStageCount < 8)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    //Get the  # of active textures
    if((((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG2))
        ||(((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
        ||(((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2))
        ||(((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)))
        textureCount++;

    if((((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG2))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
        ||(((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2))
        ||(((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&(ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)))
        textureCount++;

    //Add, Modulate
    if ((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        &&
        ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)   ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE2X) ||
         (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE4X)))
    {
        if (colorAddMod(pContext,textureCount) == D3D_OK)
            goto Final;
        else
            goto Fail;
    }

    //Modulate, Add
    if((ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_MODULATE)
        &&((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADD)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_ADDSIGNED2X)
        ||(ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_SUBTRACT)))
    {
        if(colorModAdd(pContext,textureCount)==D3D_OK)
            goto Final;
        else
            goto Fail;
    }


Final:
    SetAlphaCombiner(pContext, alphaStageCount, textureCount);

#if COMBINER_STATUS
    DPF ("Result in 3 stage 2 set up");
    DPF ("   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
    DPF ("   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
    DPF ("   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
    DPF ("   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
    DPF ("   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
    DPF ("   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
    DPF ("   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
    DPF ("   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
    __asm int 3;
#endif
    dbgTracePop();
    return (D3D_OK);

Fail:
    //reset the texture unit
    pContext->hwState.dwNextAvailableTextureUnit =0;
    dbgTracePop();
    return (DD_FALSE);
}//nvCelsiusSet2Stage1Combiner


/**************************************************************
*For special 3 DX texutre stages but only one combiner stage
***************************************************************/
BOOL nvCelsiusCheck3StageSpecial (PNVD3DCONTEXT pContext)
{

    PNVD3DTEXSTAGESTATE    ptssState0, ptssState1, ptssState2;
    DWORD                  alphaStageCount=0;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];


    //check for specular and fog off
    if((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        ||(pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]))
        return FALSE;

    //check for the # of active alpha stages
    while ((alphaStageCount < 8)
        &&(pContext->tssState[alphaStageCount].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE))
    {
        alphaStageCount++;
    }

    if(alphaStageCount>1)
        return FALSE;

    //check the color operations in all 3 stages
    if((ptssState0->dwValue[D3DTSS_COLOROP]!= D3DTOP_DOTPRODUCT3)
        ||(ptssState1->dwValue[D3DTSS_COLOROP]!= D3DTOP_MODULATE)
        ||(ptssState2->dwValue[D3DTSS_COLOROP]!= D3DTOP_MODULATE))
        return FALSE;

    //check for the stage0 args: one and only one arg to be texture
    if(!(((ptssState0->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        ^((ptssState0->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)))
        return FALSE;

    //check for the stage1 args:
    //arg1=texture arg2=current  or arg1=current, arg2=texture
    if(!((((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        ||(((ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        &&((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT))))
        return FALSE;

    //check for the stage2 args: at least one of the arg to be current
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)!= D3DTA_CURRENT)
        &&((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)!= D3DTA_CURRENT))
        return FALSE;

    //check for stage2 args: not texture should be used
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
        ||((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE))
        return FALSE;

    //alpha replication cannot be used in stage2 current
    if(((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
        &&((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_CURRENT))
        ||((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
        &&((ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_CURRENT)))
        return FALSE;

    //validate textures
    if(!((ptssState0->dwValue[D3DTSS_TEXTUREMAP])
        &&(ptssState1->dwValue[D3DTSS_TEXTUREMAP])))
        return FALSE;

    return TRUE;
}

HRESULT nvCelsiusSet3StageSpecial (PNVD3DCONTEXT pContext)
{
    // HW control words for SpecularFog combiner
    DWORD dwControl0, dwControl1;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2;

    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];

    //Disable color combinr1
    pContext->hwState.dwNumActiveCombinerStages = 1;
    pContext->hwState.dwColorICW[1]=0;
    pContext->hwState.dwColorOCW[1]=0x10000000;

    //initialize alpha combiner
    pContext->hwState.dwAlphaICW[0]=0;
    pContext->hwState.dwAlphaOCW[0]=0;
    pContext->hwState.dwAlphaICW[1]=0;
    pContext->hwState.dwAlphaOCW[1]=0;

    //initialize SpecularFog combiner
    dwControl0=dwControl1=0;

    //map stage0 to color combiner0
    pContext->hwState.dwNextAvailableTextureUnit=0;
    ConstructColorCombiners (pContext, 0, 0);
    //alpha value is going to be pull from the result of color stage0
    //don't bother to canculate.

    pContext->hwState.dwNextAvailableTextureUnit=1;

    //Use SpecularFog combiner as another two layer of color combiner

    //A= current (E*F)
    dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_SOURCE, _REG_EF_PROD);

    //B= ARG in stage2

    //in stage2 arg1=current
    if((ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
    {
        //complement of A (current/arg1)
        if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_INVERSE, _TRUE);

        //complement and alpha replication of B (arg2)
        if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_INVERSE, _TRUE);

        if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_ALPHA, _TRUE);

        switch (ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)
        {
        case D3DTA_CURRENT:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_EF_PROD);
            break;

        case D3DTA_DIFFUSE:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_4);
            break;

        case D3DTA_TFACTOR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_1);
            break;

        case D3DTA_SPECULAR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_5);
            break;

        default:
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
        }
    }

    else //in stage2 arg2 is current
    {
        //complement of A (current/arg2)
        if(ptssState2->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_INVERSE, _TRUE);

        //complement and alpha replication of B (arg2)
        if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_INVERSE, _TRUE);

        if(ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_ALPHA, _TRUE);

        switch (ptssState2->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)
        {
        case D3DTA_CURRENT:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_EF_PROD);
            break;

        case D3DTA_DIFFUSE:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_4);
            break;

        case D3DTA_TFACTOR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_1);
            break;

        case D3DTA_SPECULAR:
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;
            break;

        default:
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
        }
    }

    //C=0, D=0

    //E=T1, F=current

    dwControl1 |= (DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_SOURCE, _REG_9)|
                   DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_SOURCE, _REG_C));

    //in stage1 arg1=current
    if((ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)==D3DTA_CURRENT)
    {
        //complement and alphareplication of F (current/arg1)
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_ALPHA, _TRUE);

        //complement and alphareplication of E (T1/arg2)
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_ALPHA, _TRUE);
    }
    else  //in stage1 arg2=current
    {
        //complement and alphareplication of F (current/arg2)
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG2]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _F_ALPHA, _TRUE);

        //complement and alphareplication of E (T1/arg1)
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_COMPLEMENT)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_INVERSE, _TRUE);
        if(ptssState1->dwValue[D3DTSS_COLORARG1]&D3DTA_ALPHAREPLICATE)
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _E_ALPHA, _TRUE);
    }



    //G= out put of color from stage0 (regC' color chanel)
    dwControl1 |= (DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_SOURCE, _REG_C)|
                   DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _FALSE));

    //Set the value
    pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, dwControl1);

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_SPECFOG_COMBINER;

    return D3D_OK;

}//nvCelsiusSet3Stage1Combiner


#endif // (NVARCH >= 0x10)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusPrim.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusPrim.cpp                                                 *
*       Celsius primitive rendering routines.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        04Mar99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define FORCE_NULL                // force no work
//#define FORCE_FROMDVB_VERTICES    // force CPU copy of verts (may be slow if read from AGP or VID vertex buffers)

//////////////////////////////////////////////////////////////////////////////
// forward declarations
//
#ifdef FORCE_INLINE_VERTICES
void nvCelsiusDispatchIndexedPrimitiveInline    (PNVD3DCONTEXT       pContext,
                                                 WORD                wCount,
                                                 LPWORD              lpIndices,
                                                 BOOL                bLegacyStrides);
void nvCelsiusDispatchNonIndexedPrimitiveInline (PNVD3DCONTEXT       pContext,
                                                 WORD                wCount);
#endif


#ifdef PROFILE_LIST2STRIP
void profile_lists2strips(WORD PrimCount, LPWORD pIndices);
#endif

// helper function that takes a src texture and updates the destination with
// an inverted (both horizontally and vertically mirrored) copy of the source

static void nvInvertSwizzle (CTexture *pSrcText,CTexture *pDestText)
{
    BYTE *pSrc,*pDest,*pDestScrap,*pSrcScrap;
    DWORD x,y,dwSrc,dwSrc2;

    //make sure both textures have linear surfaces
    //hmm... what about mipmap case? ignore mip mapped
    //point sprites for now...
    pSrcText->updateLinearSurface();
    pSrcText->cpuLockLin(CSimpleSurface::LOCK_NORMAL);
    pDestText->updateLinearSurface();
    pDestText->cpuLockLin(CSimpleSurface::LOCK_NORMAL);
    pDestText->getSwizzled()->tagOutOfDate();
    //alrighty, both texture exist, linear copies are locked, do the bit twiddling...
    pSrc  = (BYTE *)(pSrcText->getLinear()->getfpVidMem() + (pSrcText->getHeight() * pSrcText->getPitch()) );
    pDest = (BYTE *)(pDestText->getLinear()->getfpVidMem() );
    for (y = 0; y < pSrcText->getHeight(); y++)
    {
        pSrcScrap = pSrc;
        pDestScrap = pDest;
        for (x=0; x < pSrcText->getWidth();x++)
        {
            pSrcScrap -= pSrcText->getBPP();
            switch(pSrcText->getBPP())
            {
                case 1:
                    *pDestScrap = *pSrcScrap;
                    break;
                case 2:
                    *(WORD *)pDestScrap = *(WORD *)pSrcScrap;
                    break;
                case 4:
                    *(DWORD *)pDestScrap = *(DWORD *)pSrcScrap;
                    break;
                case 8:
                    //DXT1
                    *(DWORD *)pDestScrap = *(DWORD *)pSrcScrap;
                    dwSrc = *(DWORD *)(pSrcScrap+4 );
                    *(DWORD *)(pDestScrap +4) = (
                        (dwSrc & 0xC0000000) >> 30 | (dwSrc & 0x30000000) >> 26 |
                        (dwSrc & 0x0C000000) >> 22 | (dwSrc & 0x03000000) >> 18 |
                        (dwSrc & 0x00C00000) >> 14 | (dwSrc & 0x00300000) >> 10 |
                        (dwSrc & 0x000C0000) >> 6  | (dwSrc & 0x00030000) >> 2  |
                        (dwSrc & 0x0000C000) << 2  | (dwSrc & 0x00003000) << 6  |
                        (dwSrc & 0x00000C00) << 10 | (dwSrc & 0x00000300) << 14 |
                        (dwSrc & 0x000000C0) << 18 | (dwSrc & 0x00000030) << 22 |
                        (dwSrc & 0x0000000C) << 26 | (dwSrc & 0x00000003) << 30);
                    break;
                case 16:
                    if (pSrcText->getFormat() == NV_SURFACE_FORMAT_DXT23_A8R8G8B8)
                    {
                        dwSrc = *(DWORD *)(pSrcScrap + 4);
                        *(DWORD *)(pDestScrap) = (
                          (dwSrc & 0xF0000000) >> 28 | (dwSrc & 0x0F000000) >> 20 |
                          (dwSrc & 0x00F00000) >> 12 | (dwSrc & 0x000F0000) >>  4 |
                          (dwSrc & 0x0000F000) <<  4 | (dwSrc & 0x00000F00) << 12 |
                          (dwSrc & 0x000000F0) << 20 | (dwSrc & 0x0000000F) << 28);
                        dwSrc = *(DWORD *)(pSrcScrap);
                        *(DWORD *)(pDestScrap + 4) = (
                          (dwSrc & 0xF0000000) >> 28 | (dwSrc & 0x0F000000) >> 20 |
                          (dwSrc & 0x00F00000) >> 12 | (dwSrc & 0x000F0000) >>  4 |
                          (dwSrc & 0x0000F000) <<  4 | (dwSrc & 0x00000F00) << 12 |
                          (dwSrc & 0x000000F0) << 20 | (dwSrc & 0x0000000F) << 28);
                    }
                    else
                    {
                        dwSrc = *(DWORD *)(pSrcScrap);
                        dwSrc2 = *(DWORD *)(pSrcScrap + 4);
                        *(DWORD *)(pDestScrap) = (
                        (dwSrc  & 0x0000FFFF) |
                        (dwSrc2 & 0xE0000000) >> 13 | (dwSrc2 & 0x1C000000) >> 7  |
                        (dwSrc2 & 0x03800000) >> 1  | (dwSrc2 & 0x00700000) << 5  |
                        (dwSrc2 & 0x000E0000) << 11 | (dwSrc2 & 0x0001C000) << 17);
                        *(DWORD *)(pDestScrap + 4) = (
                        (dwSrc2 & 0x0001C000) >> 15 | (dwSrc2 & 0x00003800) >> 9  |
                        (dwSrc2 & 0x00000700) >> 3  | (dwSrc2 & 0x000000E0) << 3  |
                        (dwSrc2 & 0x0000001C) << 9  | (dwSrc2 & 0x00000003) << 14 |
                        (dwSrc  & 0x80000000) >> 15 | (dwSrc  & 0x70000000) >> 11 |
                        (dwSrc  & 0x0E000000) >> 5  | (dwSrc  & 0x01C00000) << 1  |
                        (dwSrc  & 0x00380000) << 7  | (dwSrc  & 0x00070000) << 13);
                    }
                    *(DWORD *)(pDestScrap + 8) = *(DWORD *)(pSrcScrap + 8);
                    dwSrc = *(DWORD *)(pSrcScrap + 12 );
                    *(DWORD *)(pDestScrap + 12) = (
                        (dwSrc & 0xC0000000) >> 30 | (dwSrc & 0x30000000) >> 26 |
                        (dwSrc & 0x0C000000) >> 22 | (dwSrc & 0x03000000) >> 18 |
                        (dwSrc & 0x00C00000) >> 14 | (dwSrc & 0x00300000) >> 10 |
                        (dwSrc & 0x000C0000) >> 6  | (dwSrc & 0x00030000) >> 2  |
                        (dwSrc & 0x0000C000) << 2  | (dwSrc & 0x00003000) << 6  |
                        (dwSrc & 0x00000C00) << 10 | (dwSrc & 0x00000300) << 14 |
                        (dwSrc & 0x000000C0) << 18 | (dwSrc & 0x00000030) << 22 |
                        (dwSrc & 0x0000000C) << 26 | (dwSrc & 0x00000003) << 30);
                    break;
                default:
                    DPF ("unknown or unhandled texture bit depth in nvInvertSwizzle");
                    dbgD3DError();
                    pSrcText->cpuUnlockLin();
                    pDestText->cpuUnlockLin();
                    return;
                    break;
            }
            pDestScrap += pSrcText->getBPP();
        }
        pSrc -= pSrcText->getPitch();
        pDest += pSrcText->getPitch();
    }
    //unlock the textures and continue
    pSrcText->cpuUnlockLin();
    pDestText->cpuUnlockLin();
}

//helper function for point sprite texture
static void nvPreparePointSpriteTexture(PNVD3DCONTEXT pContext)
{
    //create the inverted texture

    if (((pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS)  ||
         (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT) ) &&
         (pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] == TRUE) &&
         (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] ) &&
         ((DWORD)pContext->pCelsiusPointTexture != pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) )
    {
        if (pContext->dwPointHandle != pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP])
        {
            //we have to recreate the point texture
            CNvObject *pSrcObj = (CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]);
            CTexture  *pBaseTexture = pSrcObj->getTexture();
            CNvObject *pNvObj   = new CNvObject (0);
            CNvObject *pCurrObj,*pNextObj;
            CTexture  *pPointTexture = new CTexture;
            CTexture  *pNextTexture;
            DWORD     dwMipCount;

            //check to see if the current streams/rendertarget/Z/textures need to be unlocked
            if(pContext->dwHWUnlockAllPending){ //HMH
                nvHWUnlockTextures (pContext);
                // need to mark all streams as in use by hardware...
                nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                pContext->dwHWUnlockAllPending=FALSE;
            }

            if(pContext->pCelsiusPointTexture)
            {
                //destroy the old texture;
                pCurrObj=pContext->pCelsiusPointTexture;
                pNextObj=pCurrObj->getAttachedA();
                for (dwMipCount=1;dwMipCount < pContext->pCelsiusPointTexture->getTexture()->getMipMapCount();dwMipCount++ ) //destroy each mip map
                {
                    pCurrObj=pNextObj;
                    pNextObj=pCurrObj->getAttachedA();
                    pCurrObj->getTexture()->destroy();
                    pCurrObj->release();
                }
                pContext->pCelsiusPointTexture->getTexture()->destroy();
                pContext->pCelsiusPointTexture->release(); //call destructor
            }
            if (!pNvObj || !pPointTexture || !pBaseTexture) {
                //something went horribly wrong
                if (pNvObj) pNvObj->release();
                if (pPointTexture ) pPointTexture->destroy();
            }
            else
            {
#ifdef WINNT
                pNvObj->setDDSLcl(NULL);
#endif
                pNvObj->setObject (CNvObject::NVOBJ_TEXTURE, pPointTexture);
                pPointTexture->create (pNvObj,
                                       pBaseTexture->getWidth(),
                                       pBaseTexture->getHeight(),
                                       pBaseTexture->getDepth(),
                                       pBaseTexture->getBPP(),
                                       pBaseTexture->getBPP(),
                                       pBaseTexture->getMipMapCount(),
                                       pBaseTexture->getFormat(),
                                       pBaseTexture->getSwizzled()->getHeapLocation(),
                                       pBaseTexture->getSwizzled()->getHeapLocation());
                pPointTexture->setFourCC (pBaseTexture->getFourCC());
                //although this looks stupid, we have to do it for reset the control words
                pPointTexture->calculateNV056ControlWords();
                nvInvertSwizzle (pBaseTexture,pPointTexture);
                pCurrObj = pNvObj;
                for (dwMipCount=1;dwMipCount<pBaseTexture->getMipMapCount();dwMipCount++)
                {
                    pNextObj = new CNvObject(0);
                    pNextTexture = new CTexture;
                    pCurrObj->setAttachedA(pNextObj);
#ifdef WINNT
                    pNextObj->setDDSLcl(NULL);
#endif
                    pNextObj->setObject (CNvObject::NVOBJ_TEXTURE, pNextTexture);

                    pSrcObj = pSrcObj->getAttachedA();

                    if (!pNextObj || !pNextTexture) {
                        //something went horribly wrong
                        if (pNextObj) pNextObj->release();
                        if (pNextTexture ) pNextTexture->destroy();
                    }
                    else
                    {
                        pNextTexture->create(pNextObj,0,pPointTexture,dwMipCount);
                        pNextTexture->setFourCC (pBaseTexture->getFourCC());
                        pNextTexture->calculateNV056ControlWords();
                        nvInvertSwizzle(pSrcObj->getTexture(),pNextTexture);
                    }
                    pCurrObj = pCurrObj->getAttachedA();
                }
                pContext->pCelsiusPointTexture = pNvObj;
            }
            pContext->dwPointHandle = pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP];
        }
        //check to see if the current streams/rendertarget/Z/textures need to be unlocked
        if(pContext->dwHWUnlockAllPending){ //HMH
            nvHWUnlockTextures (pContext);
            // need to mark all streams as in use by hardware...
            nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
            pContext->dwHWUnlockAllPending=FALSE;
        }

        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD)pContext->pCelsiusPointTexture;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE |
                                          CELSIUS_DIRTY_TEXTURE_TRANSFORM |
                                          CELSIUS_DIRTY_COMBINERS;
    }
    if( (((pContext->dp2.dwDP2Prim != D3DDP2OP_POINTS) &&
          (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] != D3DFILL_POINT)) ||
        (pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] != TRUE)) &&
        ( pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) &&
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pContext->pCelsiusPointTexture)
    {
        //check to see if the current streams/rendertarget/Z/textures need to be unlocked
        if(pContext->dwHWUnlockAllPending){ //HMH
            nvHWUnlockTextures (pContext);
            // need to mark all streams as in use by hardware...
            nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
            pContext->dwHWUnlockAllPending=FALSE;
        }

        //oops, set the real texture
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = pContext->dwPointHandle;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE |
                                          CELSIUS_DIRTY_TEXTURE_TRANSFORM |
                                          CELSIUS_DIRTY_COMBINERS;
    }
}


/*****************************************************************************
 *****************************************************************************
 *** nvCelsiusDispatchIndexedPrimitive ****************************************
 *****************************************************************************
 *****************************************************************************/

void nvCelsiusDispatchIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    BOOL bLegacyStrides;

#ifdef FORCE_NULL
    return;
#endif

    // any work?
    if (dwCount == 0) return;

    // we must at least have position data
    if (!pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]) {
        DPF ("caught attempt to render without a position stream");
        nvAssert (0);
        // return;
    }

#ifdef INSTRUMENT_INNER_LOOPS
    CNVTimer sw;
    global.dwBytesCopied = 0;
    sw.start (0);
#endif

#ifdef PROFILE_LIST2STRIP
    profile_lists2strips(dwCount, pIndices);
#endif //PROFILE_LISTS2STRIPS

    bLegacyStrides = (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST) ? TRUE : FALSE;

    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

#if SYSVB2AGP
    DWORD bAltVBPerfStrategy = ((pContext->dwEarlyCopyStrategy == 6) || (pContext->dwEarlyCopyStrategy == 7) || (pContext->dwEarlyCopyStrategy > 0x20));

    if (bAltVBPerfStrategy) {

        if (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST2 && pContext->dp2.dwVertexBufferOffset == 0)
        {
            if (!pContext->sysvb.pSysMemVB)
            {
                DWORD stream = pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION]);
                CVertexBuffer *pVertexBuffer = pContext->ppDX8Streams[stream];
                if (!pVertexBuffer->cachedhwCanRead())
                {

                    DWORD dwTotalSize = pContext->hwState.pVertexShader->getStride() * pContext->dp2.dwVertexLength;
                    if (dwTotalSize < pDriverData->nvD3DPerfData.dwRecommendedStageBufferSize)   // never fill more than 1/4 at once
                    {
                        pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                        pContext->dwStreamDMACount &= 0xffff;
                        // get default VB
                        CVertexBuffer *pDefVertexBuffer = getDC()->defaultVB.getVB();
                        DWORD stride = pContext->hwState.pVertexShader->getStride();

                        pDefVertexBuffer->setVertexStride(stride);

                        // check for space
                        DWORD dwVBOffset = (getDC()->defaultVB.waitForSpace(dwTotalSize + 64 * 12, TRUE) + 32) & ~31;
                        // copy verts
                        nvMemCopy (pDefVertexBuffer->getAddress() + dwVBOffset ,
                                   (DWORD)pVertexBuffer->getAddress(),
                                   dwTotalSize);
                        // set up supertri
                        pDefVertexBuffer->setSuperTriLookAsideBuffer ((void*)((DWORD)pVertexBuffer->getAddress()));
                        pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                        pContext->sysvb.dwDefVBOffset = pContext->dp2.dwVertexBufferOffset = dwVBOffset;

                        pContext->sysvb.pSysMemVB = pVertexBuffer;
                        pContext->sysvb.dwSysMemVBStream = stream;
                        pContext->ppDX8Streams[stream] = pDefVertexBuffer;

                        // unlock vb
                        getDC()->defaultVB.m_dwTotalVerticesSincePut += pContext->dp2.dwVertexLength;
                        if (getDC()->defaultVB.m_dwTotalVerticesSincePut >= 128)
                        {
                            pContext->sysvb.bWriteOffset = TRUE;
                            getDC()->defaultVB.m_dwTotalVerticesSincePut = 0;
                        }
                        getDC()->defaultVB.m_dwCurrentOffset = dwVBOffset + dwTotalSize;

                    }
                }
            }
            else
            {
                pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                pContext->dwStreamDMACount &= 0xffff;
                pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                pContext->dp2.dwVertexBufferOffset = pContext->sysvb.dwDefVBOffset;
                pContext->sysvb.pSysMemVB = pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream];
                pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = getDC()->defaultVB.getVB();
            }
        }
    }
#endif //SYSVB2AGP

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    //this is code to fix the upside down point sprites on NV10/NV11/NV15
    //It is NOT fast/efficient/optimized
    //It will perform well assuming that there is a single small texture used for points
    //if the point texture changes this code will thrash horribly.
    //This is pretty much strictly to pass WHQL since asymetrical point sprites are
    //basically never seen in real world apps
    //
    //HMH
    nvPreparePointSpriteTexture(pContext);

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);

    // set celsius state (required to get the correct inner loop)
    nvSetCelsiusState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvCelsiusDispatchIndexedPrimitiveInline (pContext, dwCount, pIndices, bLegacyStrides);

#else // !FORCE_INLINE_VERTICES

    // get inner loop entry point flags
    DWORD dwFlags = (pContext->dp2.dwDP2Prim & CELSIUS_ILMASK_PRIMTYPE)
                  | (bLegacyStrides ? CELSIUS_ILFLAG_LEGACY : 0);

    if (pContext->hwState.dwInlineVertexStride) {

        // set up inner loops to inline vertices
        if (pContext->hwState.pVertexShader->hasProgram()
            || (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
            || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1)) {
            dwFlags |= CELSIUS_ILFLAG_IX_STR_PRIM;
        }
        else if ((dwCount >= CELSIUS_SHORT_INDEXED_PRIM_COUNT_CUTOFF) &&
                 ((celsiusPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim] & 0x00ffffff) == 0x00030300))
        {
            if (NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader)) {
                dwFlags |= CELSIUS_ILFLAG_IX_INL_TRI_LIST;
            }
            else {
                dwFlags |= CELSIUS_ILFLAG_IX_INL_PRIM;
            }
            dwFlags                    |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);
            global.celsius.dwCullValue  =  (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        }
        else {
            dwFlags |= CELSIUS_ILFLAG_IX_INL_PRIM;
        }
    }

    else {
        if (pContext->hwState.SuperTri.Strategy (pContext->dp2.dwDP2Prim, dwCount, pContext->hwState.pVertexShader))
        {
            dwFlags &= ~CELSIUS_ILMASK_LOOPTYPE;
            dwFlags |= CELSIUS_ILFLAG_SUPER_TRI_LIST;
        }
        else
        {
            dwFlags |= CELSIUS_ILFLAG_IX_VB_PRIM;
        }
    }


#ifdef LPC_OPT
    static DWORD savedFlags=0;
    if ((savedFlags == dwFlags) && (pDriverData->dwLastDP2 == pDriverData->dwThisDP2))
    {
        global.celsius.dwPrimCount           = dwCount;
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwIndexStride         = pContext->dp2.dwIndexStride;

        // BUGBUG this won't work with vertex shaders
        // pVertices is used in the inline functions and needs the base vertex (dwVStart) built in.
        // pVertices is not used in the VB routines - they use dwBaseVertex
        global.celsius.pVertices             = pContext->hwState.ppStreams[0]->getAddress() +
            pContext->hwState.dwVertexOffset +
            pContext->dp2.dwVStart * pContext->hwState.ppStreams[0]->getVertexStride() +
            pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex for use in VB Prim and super tri routines
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;
        global.celsius.dwEyeAddr             = pContext->hwState.SuperTri.getEyeAddr();
        global.celsius.dwCullAddr            = pContext->hwState.SuperTri.getCullsignAddr();
    }
    else
#endif
    {
        // setup variables passed to innerloop
        global.celsius.pContext              = (DWORD)pContext;
        global.celsius.pContext_hwState      = (DWORD)&pContext->hwState;
        global.celsius.dwPrimCount           = dwCount;

        global.celsius.dwVertexStride        = pContext->hwState.pVertexShader->getStride();  // vertex stride of source data
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwIndexStride         = pContext->dp2.dwIndexStride;
        // BUGBUG this won't work with vertex shaders
        // pVertices is used in the inline functions and needs the base vertex (dwVStart) built in.
        // pVertices is not used in the VB routines - they use dwBaseVertex
        global.celsius.pVertices             = pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getAddress() +
                                               pContext->hwState.dwVertexOffset +
                                               pContext->dp2.dwVStart * pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getVertexStride() +
                                               pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex for use in VB Prim and super tri routines
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;

        // set component offsets
        global.celsius.dwOffsetXYZ           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        global.celsius.dwOffsetRHW           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]) + 3*sizeof(DWORD);
        global.celsius.dwOffsetDiffuse       = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);
        global.celsius.dwOffsetSpecular      = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]);
        global.celsius.dwOffsetNormal        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_NORMAL]);
        global.celsius.dwOffsetWeight        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        for (DWORD i=0; i<CELSIUS_CAPS_MAX_UV_PAIRS; i++) {
            global.celsius.dwOffsetUV[i]     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_TEXCOORD0+i]);
        }

        global.celsius.dwEyeAddr             = pContext->hwState.SuperTri.getEyeAddr();
        global.celsius.dwCullAddr            = pContext->hwState.SuperTri.getCullsignAddr();


    }

    if ((dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_SUPER_TRI_LIST)
    {
        //
        // do preprocessing
        //
        dwFlags                    |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);
        global.celsius.dwCullValue  = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        CVertexBuffer *pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];
        global.celsius.pVertices             = (DWORD) pVertexBufferInUse->getSuperTriLookAsideBuffer() +
                                               pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);

    }


    // go
    CELSIUSDISPATCHPRIMITIVE pfn = nvCelsiusGetDispatchRoutine(pContext,dwFlags);
    if (pfn) pfn();

    // restore important values
    nvPusherAdjust (0);

#ifdef LPC_OPT
    savedFlags = dwFlags;
#endif

#endif // !FORCE_INLINE_VERTICES

    //set that we need to unlock all surfaces.  defer till we need to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;

#ifdef INSTRUMENT_INNER_LOOPS
    sw.stop (0);
    PF ("Prim=%d, VPS=%f",dwFlags & 0xffff,float(global.dwBytesCopied)/sw.getTime(0));
#endif

#if SYSVB2AGP
    if (pContext->sysvb.pSysMemVB)
    {
        DWORD stream = pContext->sysvb.dwSysMemVBStream;
        pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = pContext->sysvb.pSysMemVB;
        pContext->sysvb.pSysMemVB = getDC()->defaultVB.getVB();
        pContext->dwStreamDMACount = pContext->sysvb.dwStreamDMACount;
        pContext->dp2.dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffsetSave;
    }
#endif
}

/*****************************************************************************
 *****************************************************************************
 *** nvCelsiusDispatchNonIndexedPrimitive ************************************
 *****************************************************************************
 *****************************************************************************/
void nvCelsiusDispatchNonIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
#ifdef FORCE_NULL
    return;
#endif

    // any work?
    if (dwCount == 0) return;

    // we must at least have position data
    if (!pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]) {
        DPF ("caught attempt to render without a position stream");
        nvAssert (0);
        return;
    }

#ifdef INSTRUMENT_INNER_LOOPS
    CNVTimer sw;
    global.dwBytesCopied = 0;
    sw.start (0);
#endif

    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    //this is code to fix the upside down point sprites on NV10/NV11/NV15
    //It is NOT fast/efficient/optimized
    //It will perform well assuming that there is a single small texture used for points
    //if the point texture changes this code will thrash horribly.
    //This is pretty much strictly to pass WHQL since asymetrical point sprites are
    //basically never seen in real world apps
    //
    //HMH
    nvPreparePointSpriteTexture(pContext);

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);

    // set celsius state (required to get the correct inner loop)
    nvSetCelsiusState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvCelsiusDispatchNonIndexedPrimitiveInline (pContext, dwCount);

#else // !FORCE_INLINE_VERTICES

    // get inner loop entry point flags
    DWORD dwFlags = (pContext->dp2.dwDP2Prim & CELSIUS_ILMASK_PRIMTYPE)
                  | ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);


    if (pContext->hwState.dwInlineVertexStride ) {

        // set up inner loops to inline vertices
        if (pContext->hwState.pVertexShader->hasProgram()
            || (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
            || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1)) {
            dwFlags |= CELSIUS_ILFLAG_OR_STR_PRIM;
        }
        else {
            if ((dwCount >= CELSIUS_SHORT_ORDERED_PRIM_COUNT_CUTOFF)
             && (NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
             && ((celsiusPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim] & 0x00ffffff) == 0x00030300)) {
                dwFlags |= CELSIUS_ILFLAG_OR_INL_TRI_LIST
                        |  ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? CELSIUS_ILFLAG_NOCULL : 0);
                global.celsius.dwCullValue  = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
            }
            else {
                dwFlags |= CELSIUS_ILFLAG_OR_INL_PRIM;
            }
        }

    }

    else {

#ifdef LPC_OPT
        //hw can pull verts directly from vid mem
        if (pContext->hwState.ppStreams[0]->getContextDMA() == NV_CONTEXT_DMA_VID && dwCount < 40)
        {
            nvAssert (celsiusBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
            nvglSetNv10CelsiusBeginEnd (NV_DD_CELSIUS, celsiusBeginEndOp[pContext->dp2.dwDP2Prim]);

            DWORD dwScaleAndBias = celsiusPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim];
            nvAssert (dwScaleAndBias != ~0);
            DWORD dwNumVertices = (((dwScaleAndBias >> 8) & 0xff) * dwCount) + (dwScaleAndBias & 0xff);

            DWORD dwIndex = 0;
            if (dwNumVertices) {
                nvglSetNv10CelsiusDrawArrays (NV_DD_CELSIUS,
                    DRF_NUM(056, _DRAW_ARRAYS, _COUNT, dwNumVertices-1) |
                    DRF_NUM(056, _DRAW_ARRAYS, _START_INDEX, dwIndex + pContext->dp2.dwVStart));
            }

            nvglSetNv10CelsiusBeginEnd (NV_DD_CELSIUS, NV056_SET_BEGIN_END_OP_END);

            return;
        }
#endif
        // set up inner loops to pull vertices
        dwFlags |= CELSIUS_ILFLAG_OR_VB_PRIM;

    }

#ifdef LPC_OPT
    static DWORD savedFlags=0;
    if ((savedFlags == dwFlags) && (pDriverData->dwLastDP2 == pDriverData->dwThisDP2))
    {
        global.celsius.dwPrimCount           = dwCount;
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;
        global.celsius.pVertices             =
            pContext->hwState.ppStreams[0]->getAddress() +
            pContext->hwState.dwVertexOffset +
            pContext->dp2.dwVStart * pContext->hwState.ppStreams[0]->getVertexStride() +
            pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);


    }
    else
#endif
    {
        // setup variables passed to innerloop
        global.celsius.pContext              = (DWORD)pContext;
        global.celsius.pContext_hwState      = (DWORD)&pContext->hwState;
        global.celsius.dwPrimCount           = dwCount;
        global.celsius.dwVertexStride        = pContext->hwState.pVertexShader->getStride();  // vertex stride of source data
        global.celsius.pIndices              = pContext->dp2.dwIndices;
        global.celsius.dwIndexStride         = pContext->dp2.dwIndexStride;
        global.celsius.pVertices             = pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getAddress() +
                                               pContext->hwState.dwVertexOffset +
                                               pContext->dp2.dwVStart * pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getVertexStride() +
                                               pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex
        global.celsius.dwBaseVertex          = pContext->dp2.dwVStart;
        // set component offsets
        global.celsius.dwOffsetXYZ           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        global.celsius.dwOffsetRHW           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]) + 3*sizeof(DWORD);
        global.celsius.dwOffsetDiffuse       = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);
        global.celsius.dwOffsetSpecular      = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]);
        global.celsius.dwOffsetNormal        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_NORMAL]);
        global.celsius.dwOffsetWeight        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        for (DWORD i = 0; i < 7; i++) {
            global.celsius.dwOffsetUV[i]     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_TEXCOORD0+i]);
        }

    }

    // go
    CELSIUSDISPATCHPRIMITIVE pfn = nvCelsiusGetDispatchRoutine(pContext,dwFlags);
    if (pfn) pfn();

    // restore pusher
    nvPusherAdjust (0);

#ifdef LPC_OPT
    savedFlags = dwFlags;
#endif

#endif // !FORCE_INLINE_VERTICES
    //set that we need to unlock all surfaces.  defer till we need to to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;
#ifdef INSTRUMENT_INNER_LOOPS
    sw.stop (0);
    PF ("Prim=%d, VPS=%f",dwFlags & 0xffff,float(global.dwBytesCopied)/sw.getTime(0));
#endif

}

/*****************************************************************************
 *****************************************************************************
 *** nvCelsiusDispatchLegacyWireframePrimitive *******************************
 *****************************************************************************
 *****************************************************************************/

void nvCelsiusDispatchLegacyWireframePrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    // this routine handles DX5 primitives in wireframe mode, which may
    // have edge flags. we don't really care much about being efficient here.

    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME);

    DWORD dwCachedDP2Op     = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;

    if (dwCachedDP2Op == D3DDP2OP_INDEXEDTRIANGLELIST) {

        LPD3DHAL_DP2INDEXEDTRIANGLELIST pTriListData;
        DWORD dwEdge;
        WORD  wIndicesIn[3];
        WORD  wIndicesOut[2];

        pTriListData = (LPD3DHAL_DP2INDEXEDTRIANGLELIST)(pContext->dp2.dwIndices);
        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        while (dwCount) {

            wIndicesIn[0] = pTriListData->wV1;
            wIndicesIn[1] = pTriListData->wV2;
            wIndicesIn[2] = pTriListData->wV3;

            for (dwEdge=0; dwEdge<3; dwEdge++) {
                if (pTriListData->wFlags & (D3DTRIFLAG_EDGEENABLE1 << dwEdge)) {
                    wIndicesOut[0] = wIndicesIn [(dwEdge+0) % 3];
                    wIndicesOut[1] = wIndicesIn [(dwEdge+1) % 3];
                    nvCelsiusDispatchIndexedPrimitive (pContext, 1);
                }
            }

            pTriListData ++;
            dwCount --;

        }

    }

    else if ((dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM) || (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN)) {

        DWORD dwEdgeFlags, dwEdgeMask;
        WORD  wTriNum;
        WORD  wIndicesOut[2];

        nvAssert (dwCount < 32);

        dwEdgeFlags = pContext->dp2.dwEdgeFlags;
        dwEdgeMask  = 0x1;

        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        // we never draw edge v0-v1 for anything but the first triangle
        wIndicesOut[0] = 1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvCelsiusDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

        // we may draw edge v1-v2 for any or all triangles
        for (wTriNum=0; wTriNum<dwCount; wTriNum++) {
            wIndicesOut[0] = wTriNum+1;
            wIndicesOut[1] = wTriNum+2;
            if (dwEdgeFlags & dwEdgeMask) {
                nvCelsiusDispatchIndexedPrimitive (pContext, 1);
                dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
            }
            dwEdgeMask <<= 1;
        }

        // we never draw edge v2-v0 for anything but the last triangle
        wIndicesOut[0] = dwCount+1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvCelsiusDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

    }

    else {

        // we don't handle any other legacy primitives
        nvAssert (0);

    }

    pContext->dp2.dwDP2Prim = dwCachedDP2Op;

}

/*****************************************************************************
 *****************************************************************************
 *** Inline Vertex Code ******************************************************
 *****************************************************************************
 *****************************************************************************/

#ifdef FORCE_INLINE_VERTICES

// this code is typically unused. it's used only for debugging
// purposes if FORCE_INLINE_VERTICES is defined

//---------------------------------------------------------------------------

// table mapping dp2ops to the scale and bias required to calculate the number
// of vertices from the number of primitives. the scale is in the upper half
// of the word and the bias is in the lower.
// numVertices = scale * numPrimitives + bias

DWORD celsiusPrimitiveToVertexCountScaleAndBias[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010000,                                  //   1  D3DDP2OP_POINTS
    0x00020000,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030000,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020000,                                  //  15  D3DDP2OP_LINELIST
    0x00010001,                                  //  16  D3DDP2OP_LINESTRIP
    0x00010001,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030000,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x00010002,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x00010002,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x00010002,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x00010002,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x00010002,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020000,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030000,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020000,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// dumps one FVF vertex into the push buffer with the components in the order
// celsius requires. note that adequate push buffer space is assumed to have
// been verified already!

void nvCelsiusDumpInlineVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwIndex
)
{
    CVertexShader  *pShader;
    CVertexBuffer **ppStreams;
    DWORD           dwStreamSelector;
    DWORD           dwVertexBufferOffset;
    DWORD           dwBaseVertex;
    D3DTLVERTEX     vertex;
    DWORD           pComponent;
    DWORD           i, j, n;
    DWORD           dwD3DStage, dwTCIndex, dwVAIndex;

    pShader              = pContext->hwState.pVertexShader;
    ppStreams            = pContext->hwState.ppStreams;
    dwVertexBufferOffset = pContext->hwState.dwVertexOffset;
    dwBaseVertex         = pContext->dp2.dwVStart;
    j=0;
    memset (&vertex, 0, sizeof(D3DTLVERTEX));

    // weights
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
    }

    // normal
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_NORMAL]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_NORMAL])      // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<3; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
    }

    // tex1 coords
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (dwVAIndex)                               // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
            4 : (pShader->getVASize (dwVAIndex) / sizeof(DWORD));

        for (i=0; i<n; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
#ifdef STOMP_TEX_COORDS
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(1)) nvglSetData (3, 0x3f800000);
#endif  // STOMP_TEX_COORDS
    }

    // tex0 coords
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (dwVAIndex)                               // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
            4 : (pShader->getVASize (dwVAIndex) / sizeof(DWORD));

        for (i=0; i<n; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
#ifdef STOMP_TEX_COORDS
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD(0)) nvglSetData (3, 0x3f800000);
#endif  // STOMP_TEX_COORDS

        vertex.tu = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
        vertex.tv = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[1]);
    }

    // specular
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_SPECULAR]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_SPECULAR])    // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
        vertex.specular = ((LPDWORD)pComponent)[0];
    }

    // diffuse
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_DIFFUSE]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        pComponent = ppStreams[dwStreamSelector]->getAddress()                      // address of buffer
                   + dwVertexBufferOffset                                           // global offset within buffer
                   + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
                   + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_DIFFUSE])     // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();        // offset of this particular vertex
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
        vertex.color = ((LPDWORD)pComponent)[0];
    }

    // x,y,z
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
    nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector]));
    pComponent = ppStreams[dwStreamSelector]->getAddress()                          // address of buffer
               + dwVertexBufferOffset                                               // global offset within buffer
               + dwBaseVertex * ppStreams[dwStreamSelector]->getVertexStride()
               + pShader->getVAOffset (defaultInputRegMap[D3DVSDE_POSITION])        // offset of this component
               + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();            // offset of this particular vertex
    for (i=0; i<3; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
    vertex.sx = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
    vertex.sy = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[1]);
    vertex.sz = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[2]);
#ifdef CHECK_DEPTHS
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
        float fz = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[2]);
        if ((fz < 0.f) || (fz > 1.f)) {
            DPF ("unbiased z=%f is out of bounds", fz);
        }
        if (pContext->dwRenderState[D3DRENDERSTATE_ZBIAS] && pContext->hwState.celsius.dwZEnable) {
            float fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
            float fZScale = 0.25f * fZBias;
            fZBias  *= pContext->hwState.dvInvZScale;
            fZScale *= pContext->hwState.dvInvZScale;
            fz = fZScale*fz + fZBias;
            if ((fz < 0.f) || (fz > 1.f)) {
                DPF ("biased z'=%f is out of bounds", fz);
            }
        }
    }
#endif  // CHECK_DEPTHS

    // w
    if (pShader->getVASize (defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
        pComponent += 3*sizeof(DWORD);
        for (i=0; i<1; i++) { nvglSetData (j, ((LPDWORD)pComponent)[i]); j++; }
        vertex.rhw = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
#ifdef CHECK_DEPTHS
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
            float frhw = FLOAT_FROM_DWORD(((LPDWORD)pComponent)[0]);
            if (frhw < 0.f) {
                DPF ("rhw=%f is out of bounds", frhw);
            }
        }
#endif  // CHECK_DEPTHS
    }

    dbgDisplayVertexData (FALSE, (DWORD*)(&vertex));

    nvAssert (j == (pContext->hwState.dwInlineVertexStride >> 2));
    getDC()->nvPusher.inc (j);
}

//---------------------------------------------------------------------------

// dumps a block of 'count' non-indexed vertices starting with index 'i0'

void nvCelsiusDumpNonIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         count,
    DWORD         dwInlineVertexStride
)
{
    DWORD methodCount;

    methodCount = count * dwInlineVertexStride;  // number of 4-byte words
    assert (methodCount <= 2048);

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + methodCount);
    nvglSetStartMethod (0, NV_DD_CELSIUS, NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)), methodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    for (DWORD i=i0; i<i0+count; i++) {
        nvCelsiusDumpInlineVertex (pContext, i);
    }
}

//---------------------------------------------------------------------------

// dumps a block of 'count' indexed vertices beginning with index 'i0'

void nvCelsiusDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    LPWORD        lpIndices,
    DWORD         i0,
    DWORD         count,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD methodCount;

    methodCount = count * dwInlineVertexStride;  // number of 4-byte words
    assert (methodCount <= 2048);

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + methodCount);
    nvglSetStartMethod (0, NV_DD_CELSIUS, NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)), methodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    if (bLegacyStrides) {
        DWORD i1;
        // stupid old style indexing - {index16:index16 index16:junk16} repeat
        for (DWORD i=i0; i < (i0+count); i++) {
            i1 = 4*i / 3;  // offset of the i'th index
            nvCelsiusDumpInlineVertex (pContext, lpIndices[i1]);
        }
    }
    else {
        // new indexing - fully packed
        for (DWORD i=i0; i < (i0+count); i++) {
            nvCelsiusDumpInlineVertex (pContext, lpIndices[i]);
        }
    }
}

//---------------------------------------------------------------------------

void nvCelsiusDispatchNonIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    WORD                dwCount
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride;

    dwInlineVertexStride = pContext->hwState.dwInlineVertexStride >> 2;

    nvAssert (celsiusBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, celsiusBeginEndOp[pContext->dp2.dwDP2Prim]);

    dwScaleAndBias = celsiusPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > CELSIUS_MAX_INLINE_VERTICES) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvCelsiusDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, CELSIUS_MAX_INLINE_VERTICES, dwInlineVertexStride);
        emittedVertices += CELSIUS_MAX_INLINE_VERTICES;
        numVertices -= CELSIUS_MAX_INLINE_VERTICES;
    }

    nvCelsiusDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, numVertices, dwInlineVertexStride);

    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, NV056_SET_BEGIN_END4_OP_END);

    // attempt to kick off some work already
    nvPusherStart (FALSE);
}

//---------------------------------------------------------------------------

void nvCelsiusDispatchIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    DWORD               dwCount,
    LPWORD              lpIndices,
    BOOL                bLegacyStrides
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride;

    dwInlineVertexStride = pContext->hwState.dwInlineVertexStride >> 2;

    // tell the hardware what kind of thing we're going to draw
    nvAssert (celsiusBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, celsiusBeginEndOp[pContext->dp2.dwDP2Prim]);

    // determine the number of vertices
    dwScaleAndBias = celsiusPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > CELSIUS_MAX_INLINE_VERTICES) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvCelsiusDumpIndexedInlineVertexBlock (pContext, lpIndices, emittedVertices,
                                               CELSIUS_MAX_INLINE_VERTICES, bLegacyStrides, dwInlineVertexStride);
        emittedVertices += CELSIUS_MAX_INLINE_VERTICES;
        numVertices -= CELSIUS_MAX_INLINE_VERTICES;
    }

    nvCelsiusDumpIndexedInlineVertexBlock (pContext, lpIndices, emittedVertices,
                                           numVertices, bLegacyStrides, dwInlineVertexStride);

    nvglSetNv10CelsiusBeginEnd4 (NV_DD_CELSIUS, NV056_SET_BEGIN_END4_OP_END);

    nvPusherStart (FALSE);
}

#endif  // FORCE_INLINE_VERTICES

#endif  // NVARCH == 0x10


#ifdef PROFILE_LIST2STRIP

#define A1A2_B1C2 1     //New Vtx = B2
#define A1A2_C1B2 2     //New Vtx = C2
#define A1B2_B1A2 3     //New Vtx = C2
#define A1B2_C1C2 4     //New Vtx = A2
#define A1C2_B1B2 5     //New Vtx = A2
#define A1C2_C1A2 6     //New Vtx = B2
#define B1A2_C1C2 7     //New Vtx = B2
#define B1B2_C1A2 8     //New Vtx = C2
#define B1C2_C1B2 9     //New Vtx = A2

#define A1 0
#define B1 1
#define C1 2
#define A2 3
#define B2 4
#define C2 5

static DWORD listmatch[10] =
{
    0,0,0,0,0,0,0,0,0,0
};

typedef struct _strip_length_stats
{
    DWORD len2;     //length 2-4
    DWORD len5;     //length 5-9
    DWORD len10;    //length 10-19
    DWORD len20;    //length 20-49
    DWORD len50;    //length 50-99
    DWORD len100;   //length 100+
    DWORD count;    //total count;
} STRIP_STATS;

#define MAX_PAT_LEN 16
typedef struct _strip_length_pat
{
  BYTE pattern[MAX_PAT_LEN];
  DWORD pat_len;
  STRIP_STATS stats;
} STRIP_PATTERN;

#define MAX_PATS 200
static STRIP_PATTERN strip_pats[MAX_PATS+2];
static DWORD num_pats = 0;
static DWORD num_tris = 0;
static DWORD num_tris_in_strips = 0;
static STRIP_STATS stripstats;
static DWORD first_time = 1;

bool match(BYTE *s1, BYTE *s2, DWORD len)
{
    for (DWORD i = 0; i < len; i++)
    {
        if (*s1++ != *s2++)
            return false;
    }
    return true;
}

DWORD pat_len(BYTE *src, DWORD len)
{
    BYTE *pat;
    BYTE *subpat;
    for (DWORD length = 2; length < len/2 ;length++ )
    {
        pat = subpat = src;
        for (DWORD i = 0; i < len/length; i++ )
        {
            if (!match(pat, subpat+i*length, length)) goto next_len;
        }
        return length;
next_len:;

    }
    return len;
}

STRIP_PATTERN *get_smallest()
{
    DWORD i;
    DWORD count = 0xffffffff;
    STRIP_PATTERN *p = strip_pats;
    STRIP_PATTERN *low = 0;
    for (i = 0; i < MAX_PATS; i++,p++)
    {
        if (p->stats.count < count)
        {
            low = p;
            count = p->stats.count;

        }
    }
    return low;

}


DWORD match_pair(LPWORD pIndices)
{
        if (pIndices[A1] == pIndices[A2])
        {
            if (pIndices[B1] == pIndices[C2])
                return A1A2_B1C2;
            else if (pIndices[C1] == pIndices[B2])
                return A1A2_C1B2;
            // else no match
        }
        else if (pIndices[A1] == pIndices[B2])
        {
            if (pIndices[B1] == pIndices[A2])
                return A1B2_B1A2;
            else if (pIndices[C1] == pIndices[C2])
                return A1B2_C1C2;
            // else no match

        }
        else if (pIndices[A1] == pIndices[C2])
        {
            if (pIndices[B1] == pIndices[B2])
                return A1C2_B1B2;
            else if (pIndices[C1] == pIndices[A2])
                return A1C2_C1A2;
            // else no match
        }
        else if (pIndices[B1] == pIndices[A2])
        {
            if (pIndices[C1] == pIndices[C2])
                return B1A2_C1C2;
            // else no match
        }
        else if (pIndices[B1] == pIndices[B2])
        {
            if (pIndices[C1] == pIndices[A2])
                return B1B2_C1A2;
            // else no match
        }
        else if (pIndices[B1] == pIndices[C2])
        {
            if (pIndices[C1] == pIndices[B2])
                return B1C2_C1B2;
            // else no match
        }

        return 0;
}

void init_strip_stats()
{
    int i, j;
    num_pats = 0;
    for (i = 0; i < MAX_PATS ; i++)
    {
        for (j = 0; j < MAX_PAT_LEN; j++ )
        {
            strip_pats[i].pattern[j] = 0;
        }
        strip_pats[i].pat_len = 0;
        strip_pats[i].stats.len2 = 0;
        strip_pats[i].stats.len5 = 0;
        strip_pats[i].stats.len10 = 0;
        strip_pats[i].stats.len20 = 0;
        strip_pats[i].stats.len50 = 0;
        strip_pats[i].stats.len100 = 0;
        strip_pats[i].stats.count = 0;
    }
    first_time = 0;
    stripstats.len2 = 0;
    stripstats.len5 = 0;
    stripstats.len10 = 0;
    stripstats.len20 = 0;
    stripstats.len50 = 0;
    stripstats.len100 = 0;
    stripstats.count = 0;
    num_tris = 0;
    num_tris_in_strips = 0;
}

void strip_stats(STRIP_PATTERN *pat, DWORD len)
{
    pat->stats.count++;
    stripstats.count++;

    if (len >= 2 && len < 5)
    {
        pat->stats.len2++;
        stripstats.len2++;
    }
    else if (len >= 5 && len < 10)
    {
        pat->stats.len5++;
        stripstats.len5++;
    }
    else if (len >= 10 && len < 20)
    {
        pat->stats.len10++;
        stripstats.len10++;
    }
    else if (len >= 20 && len < 50)
    {
        pat->stats.len20++;
        stripstats.len20++;
    }
    else if (len >= 50 && len < 100)
    {
        pat->stats.len50++;
        stripstats.len50++;
    }
    else if (len >= 100)
    {
        pat->stats.len100++;
        stripstats.len100++;
    }
}

void add_strip(BYTE *strip, DWORD patlen, DWORD striplen)
{
    STRIP_PATTERN *p;
    p = strip_pats;
    DWORD i;
    if (num_pats == 0)
    {
        for (i = 0; i < patlen; i++)
        {
            p->pattern[i] = strip[i];
        }
        p->pat_len = patlen;
        strip_stats(p, striplen);
        num_pats++;
    }
    else
    {
        for (i = 0; i < num_pats ; i++)
        {
            if (patlen == p->pat_len)
            {
                if (match(p->pattern, strip, patlen))
                {
                    strip_stats(p, striplen);
                    goto done;
                }
            }
            p++;
        }

        if (num_pats < MAX_PATS)
        {
            num_pats++;
            for (i = 0; i < patlen; i++)
            {
                p->pattern[i] = strip[i];
            }
            p->pat_len = patlen;
            strip_stats(p, striplen);

        }
        else
        {
            p = get_smallest();
            if (p)
            {

                for (i = 0; i < patlen; i++)
                {
                    p->pattern[i] = strip[i];
                }
                p->pat_len = patlen;
                p->stats.len2 = 0;
                p->stats.len5 = 0;
                p->stats.len10 = 0;
                p->stats.len20 = 0;
                p->stats.len50 = 0;
                p->stats.len100 = 0;
                p->stats.count = 0;
                strip_stats(p, striplen);
            }
        }
    }
done: ;
}


void profile_lists2strips(WORD PrimCount, LPWORD pIndices)
{
    bool inStrip = false;
    int striplen = 0;
    int patlen = 0;
    BYTE strip[MAX_PAT_LEN];
    if (first_time)
        init_strip_stats();

    for (int i = 0; i < PrimCount-1; i++)
    {
        num_tris++;
        DWORD p = match_pair(pIndices);
        if (p)
        {
            num_tris_in_strips++;
            listmatch[p]++;
            if (!inStrip)
            {
                inStrip = true;
                striplen = 1;
                strip[0] = p;
            }
            else
            {
                if (striplen < MAX_PAT_LEN)
                    strip[striplen] = p;
                striplen++;
            }

        }
        else
        {
            if (inStrip)
            {
                patlen = pat_len(strip, (striplen<MAX_PAT_LEN) ? striplen : MAX_PAT_LEN);
                add_strip(strip, patlen, striplen);
            }
            inStrip = false;
            striplen = 0;
        }

        pIndices += 3;
    }

    if (inStrip)
    {
        patlen = pat_len(strip, (striplen<MAX_PAT_LEN) ? striplen : MAX_PAT_LEN);
        add_strip(strip, patlen, striplen);
    }
}

#endif // PROFILE_LIST2STRIP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusInlStrPrim.cpp ===
/*
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusInlPrim.cpp                                              *
*       indexed and ordered inline primitive                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Hadden Hoppert          20Oct99         Dx8 Stream support          *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// aliases

#define ilcData     global.dwILCData
#define ilcCount    global.dwILCCount
#define ilcMax      global.dwILCMax

//=========================================================================

extern DWORD dwCelsiusMethodDispatch[11][16][2];

static int inline_renderorder[] = {
    D3DVSDE_BLENDWEIGHT,
    D3DVSDE_NORMAL,
    D3DVSDE_TEXCOORD1,
    D3DVSDE_TEXCOORD0,
    D3DVSDE_SPECULAR,
    D3DVSDE_DIFFUSE,
    D3DVSDE_POSITION
};

inline void vsCopyVertex(PVSHADERREGISTER pDest, DWORD dwSrc, DWORD dwType)
{
    switch(dwType)
    {
    case D3DVSDT_FLOAT1:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = 0.0f;
        pDest->z = 0.0f;
        pDest->w = 1.0f;
        break;
    case D3DVSDT_FLOAT2:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = ((float*)dwSrc)[1];
        pDest->z = 0.0f;
        pDest->w = 1.0f;
        break;
    case D3DVSDT_FLOAT3:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = ((float*)dwSrc)[1];
        pDest->z = ((float*)dwSrc)[2];
        pDest->w = 1.0f;
        break;
    case D3DVSDT_FLOAT4:
        pDest->x = ((float*)dwSrc)[0];
        pDest->y = ((float*)dwSrc)[1];
        pDest->z = ((float*)dwSrc)[2];
        pDest->w = ((float*)dwSrc)[3];
        break;
    case D3DVSDT_D3DCOLOR: {
        const DWORD v = *((DWORD*)dwSrc);
        pDest->x = RGBA_GETRED  (v) / 255.;
        pDest->y = RGBA_GETGREEN(v) / 255.;
        pDest->z = RGBA_GETBLUE (v) / 255.;
        pDest->w = RGBA_GETALPHA(v) / 255.;
        break;             }
    case D3DVSDT_UBYTE4:   {
        const BYTE *v = (BYTE*)dwSrc;
        pDest->x = v[0];
        pDest->y = v[1];
        pDest->z = v[2];
        pDest->w = v[3];
        break;             }
    case D3DVSDT_SHORT2:   {
        const SHORT *v = (SHORT*)dwSrc;
        pDest->x = v[0];
        pDest->y = v[1];
        pDest->z = 0.0f;
        pDest->w = 1.0f;
        break;             }
    case D3DVSDT_SHORT4:   {
        const SHORT *v = (SHORT*)dwSrc;
        pDest->x = v[0];
        pDest->y = v[1];
        pDest->z = v[2];
        pDest->w = v[3];
        break;             }
    default:
        DPF("Unknown vertex type");
        nvAssert(0);
    }
}

//---------------------------------------------------------------------------

__inline void pushPassthruCubeMapCoords (DWORD *pPusherIndex, PBYTE pVAData)
{
    // expand the three incoming coords into 4 slots
    nvPushData (*pPusherIndex, *(DWORD*)(pVAData + 0*sizeof(DWORD)));    (*pPusherIndex)++;
    nvPushData (*pPusherIndex, *(DWORD*)(pVAData + 1*sizeof(DWORD)));    (*pPusherIndex)++;
    nvPushData (*pPusherIndex, 0);                                       (*pPusherIndex)++;
    nvPushData (*pPusherIndex, *(DWORD*)(pVAData + 2*sizeof(DWORD)));    (*pPusherIndex)++;
}

//---------------------------------------------------------------------------

void pushTransformedTexCoords (DWORD *pPusherIndex, PBYTE pVAData, DWORD dwHWStage, DWORD dwInCount)
{
    PNVD3DCONTEXT pContext     = (PNVD3DCONTEXT)(global.celsius.pContext);
    DWORD         dwD3DStage   = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
    DWORD         dwXFormFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
    DWORD         dwOutCount   = dwXFormFlags & 0xff;
    BOOL          bProjected   = (dwXFormFlags & D3DTTFF_PROJECTED) ? TRUE : FALSE;
    D3DMATRIX    *pMatrix      = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
    D3DVALUE      dvCoordsIn[4], dvCoordsOut[4];

    // fetch incoming coords
    for (DWORD ii = 0; ii < dwInCount; ii++) {
        dvCoordsIn[ii] = *(D3DVALUE*)(pVAData + ii*sizeof(DWORD));
    }
    // tack on a 1.0
    dvCoordsIn[dwInCount] = 1.0;
    // set the rest to zero
    for (ii = dwInCount+1; ii < 4; ii++) {
        dvCoordsIn[ii] = 0;
    }
    // transform
    XformVector4 (dvCoordsOut, dvCoordsIn, pMatrix);
    // write out the real coordinates
    for (ii = 0; ii < (dwOutCount - (bProjected ? 1 : 0)); ii++) {
        nvPushData (*pPusherIndex, DWORD_FROM_FLOAT(dvCoordsOut[ii]));
        (*pPusherIndex)++;
    }
    // pad with zeros
    for (; ii < 3; ii++) {
        nvPushData (*pPusherIndex, 0);
        (*pPusherIndex)++;
    }
    // fill the last slot with either 1.0 or the projected value
    nvPushData (*pPusherIndex, bProjected ?
                               DWORD_FROM_FLOAT(dvCoordsOut[dwOutCount-1]) :
                               FP_ONE_BITS);
    (*pPusherIndex)++;
}

//---------------------------------------------------------------------------

void __cdecl nvCelsiusDumpStrPrimData (DWORD dwFlags)
{
    if (!global.celsius.dwPrimCount) return;

    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)(global.celsius.pContext);

    CVertexShader *pVertexShader  = pContext->pCurrentVShader;

    BOOL   bIsIndexed             = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) <= CELSIUS_ILFLAG_IX_DVB_TRI;
    DWORD  dwMagic                = celsiusPrimitiveToPrimitiveMagic[dwFlags & CELSIUS_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    DWORD  dwCount = global.celsius.dwPrimCount * dwVerticesPerPrim + dwStartVerticesPerPrim;

    WORD  *pIndices = (WORD*)global.celsius.pIndices;
    DWORD  dwVertexBufferOffset = pContext->dp2.dwVStart;

    DWORD  dwCopyAddr  [NV_CAPS_MAX_STREAMS];
    DWORD  dwCopyLength[NV_CAPS_MAX_STREAMS];
    DWORD  dwCopyStride[NV_CAPS_MAX_STREAMS];

    DWORD  dwReg, dwStreamSelector;
    DWORD  dwD3DStage, dwHWStage, dwTCIndex, dwVAIndex;

    if (pVertexShader->hasProgram()) {

        // calculate fetch addresses
        for (dwReg = 0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++)
        {
            dwStreamSelector = pVertexShader->getVAStream(dwReg);
            if (dwStreamSelector != CVertexShader::VA_STREAM_NONE)
            {
                CVertexBuffer *pStream = pContext->ppDX8Streams[dwStreamSelector];
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                           dwReg, pVertexShader->getVAStream(dwReg), pVertexShader->getVAType(dwReg),
                           pVertexShader->getVAOffset(dwReg), pVertexShader->getVASrc(dwReg), pVertexShader->getVAFlag(dwReg));
                dwCopyAddr  [dwReg]  = pStream->getAddress();
                dwCopyStride[dwReg]  = pStream->getVertexStride();
                dwCopyLength[dwReg]  = pVertexShader->getVASize(dwReg) / sizeof(DWORD);
                dwCopyAddr  [dwReg] += dwCopyStride[dwReg] * dwVertexBufferOffset + pVertexShader->getVAOffset(dwReg);
            }
            else
            {
                dwCopyAddr[dwReg] = 0;
            }
        }

        // VShader program
        nvPushData (0, ((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
        nvPushData (1, celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE]);
        nvPusherAdjust (2);

        // get the vertex program
        void *pfVertexProgram = (void *)pVertexShader->m_ProgramOutput.residentProgram;

        // counter
        DWORD k = 0;

        if (bIsIndexed)
        {
            while (k < dwCount)
            {
                // load
                for (dwReg = 0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++)
                {
                    if (dwCopyAddr[dwReg])
                    {
                        vsCopyVertex (&pVertexShader->m_Attrib[dwReg],
                                      dwCopyAddr[dwReg] + pIndices[k] * dwCopyStride[dwReg],
                                      pVertexShader->getVAType(dwReg));

                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "reg[%2d] indx (%f, %f, %f, %f)", dwReg,
                                   pVertexShader->m_Attrib[dwReg].x, pVertexShader->m_Attrib[dwReg].y,
                                   pVertexShader->m_Attrib[dwReg].z, pVertexShader->m_Attrib[dwReg].w);
                    }
                }

                // execute
                ((void (__cdecl *)(void *))pfVertexProgram)(NULL);

                // store
                for (int ii = 8; ii >= 0; ii--)
                {
                    DWORD  dwRegWriteMask = pVertexShader->m_ParsedProgram.resultRegsWritten[ii];
                    DWORD *pResult        = (DWORD*)&(pVertexShader->m_Result[ii]);

                    // data in this stream ?
                    if (dwRegWriteMask)
                    {
                        DWORD c1 = 0;
                        DWORD c2 = 0;
                        DWORD dwMethod = dwCelsiusMethodDispatch[ii][dwRegWriteMask][0];
                        DWORD dwCount  = dwCelsiusMethodDispatch[ii][dwRegWriteMask][1];

                        nvAssert (dwMethod != 0xDEADBEEF);

                        nvPushData (0,((((dwCount) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (dwMethod)));
                        // for all the reg components
                        while (dwRegWriteMask)
                        {
                            if (dwRegWriteMask & 1)
                            {
                                c1 ++;
                                nvPushData (c1, pResult[c2]);
                            }
                            dwRegWriteMask >>= 1;
                            c2 ++;
                        }

                        float *pFloat = (float*)pResult;
                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "out(%2d): %x (%f, %f, %f, %f)", ii,
                                   dwMethod, pFloat[0], pFloat[1], pFloat[2], pFloat[3]);

                        nvPusherAdjust (dwCount + 1);
                    }
                }
                k++;
            }
        }

        else {

            // non indexed
            while (k < dwCount)
            {
                // load
                for (dwReg = 0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++)
                {
                    if (dwCopyAddr[dwReg])
                    {
                        vsCopyVertex (&pVertexShader->m_Attrib[dwReg],
                                      dwCopyAddr[dwReg],
                                      pVertexShader->getVAType(dwReg));

                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "reg[%2d] ninx (%f, %f, %f, %f)", dwReg,
                                   pVertexShader->m_Attrib[dwReg].x, pVertexShader->m_Attrib[dwReg].y,
                                   pVertexShader->m_Attrib[dwReg].z, pVertexShader->m_Attrib[dwReg].w);

                        dwCopyAddr[dwReg] += dwCopyStride[dwReg];
                    }
                }

                // execute
                ((void (__cdecl *)(void *))pfVertexProgram)(NULL);

                // store
                for (int ii = 8; ii >= 0; ii--)
                {
                    DWORD dwRegWriteMask = pVertexShader->m_ParsedProgram.resultRegsWritten[ii];
                    DWORD *pResult       = (DWORD*)&pVertexShader->m_Result[ii];

                    // data in this stream ?
                    if (dwRegWriteMask)
                    {
                        DWORD c1 = 0;
                        DWORD c2 = 0;
                        DWORD dwMethod = dwCelsiusMethodDispatch[ii][dwRegWriteMask][0];
                        DWORD dwCount  = dwCelsiusMethodDispatch[ii][dwRegWriteMask][1];

                        nvAssert (dwMethod != 0xDEADBEEF);

                        nvPushData (0,((((dwCount) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (dwMethod)));
                        // for all the reg components
                        while (dwRegWriteMask)
                        {
                            if (dwRegWriteMask & 1)
                            {
                                c1 ++;
                                nvPushData (c1, pResult[c2]);
                            }
                            dwRegWriteMask >>= 1;
                            c2 ++;
                        }

                        float *pFloat = (float*)pResult;
                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_IO, "out(%2d): %x (%f, %f, %f, %f)", ii,
                                   dwMethod, pFloat[0], pFloat[1], pFloat[2], pFloat[3]);

                        nvPusherAdjust (dwCount + 1);
                    }
                }
                k++;
            }
        }
    }

    else {

        // no vertex program. we should be here because we have multiple DMAs
        nvAssert ((NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
               || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1));

        // calculate fetch addresses
        for (dwReg = defaultInputRegMap[D3DVSDE_POSITION]; dwReg < defaultInputRegMap[D3DVSDE_TEXCOORD0]; dwReg++)
        {
            dwStreamSelector = pVertexShader->getVAStream(dwReg);
            if (dwStreamSelector != CVertexShader::VA_STREAM_NONE)
            {
                CVertexBuffer *pStream = pContext->ppDX8Streams[dwStreamSelector];
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                           dwReg, pVertexShader->getVAStream(dwReg), pVertexShader->getVAType(dwReg),
                           pVertexShader->getVAOffset(dwReg), pVertexShader->getVASrc(dwReg), pVertexShader->getVAFlag(dwReg));
                dwCopyAddr  [dwReg]  = pStream->getAddress();
                dwCopyStride[dwReg]  = pStream->getVertexStride();
                dwCopyLength[dwReg]  = pVertexShader->getVASize(dwReg) / sizeof(DWORD);
                dwCopyAddr  [dwReg] += dwCopyStride[dwReg] * dwVertexBufferOffset + pVertexShader->getVAOffset(dwReg);
            }
            else
            {
                dwCopyAddr[dwReg] = 0;
            }
        }
        for (dwReg = defaultInputRegMap[D3DVSDE_TEXCOORD0]; dwReg < defaultInputRegMap[D3DVSDE_TEXCOORD2]; dwReg++)
        {
            dwHWStage = dwReg - defaultInputRegMap[D3DVSDE_TEXCOORD0];
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(dwHWStage))
            {
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != CELSIUS_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (16*dwHWStage)) & 0xffff;
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                dwStreamSelector = pVertexShader->getVAStream (dwVAIndex);
                nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (pContext->ppDX8Streams[dwStreamSelector])); // they better have given us coordinates
                CVertexBuffer *pStream = pContext->ppDX8Streams[dwStreamSelector];
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                           dwReg, pVertexShader->getVAStream(dwVAIndex), pVertexShader->getVAType(dwVAIndex),
                           pVertexShader->getVAOffset(dwVAIndex), pVertexShader->getVASrc(dwVAIndex), pVertexShader->getVAFlag(dwVAIndex));
                dwCopyAddr  [dwReg]  = pStream->getAddress();
                dwCopyStride[dwReg]  = pStream->getVertexStride();
                dwCopyLength[dwReg]  = pVertexShader->getVASize(dwVAIndex) / sizeof(DWORD);
                dwCopyAddr  [dwReg] += dwCopyStride[dwReg] * dwVertexBufferOffset + pVertexShader->getVAOffset(dwVAIndex);
            }
            else
            {
                dwCopyAddr[dwReg] = 0;
            }
        }

        // fixed path
        nvPushData (0,((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
        nvPushData (1, celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE]);
        nvPusherAdjust(2);

        DWORD dwVertexSize = pContext->hwState.dwInlineVertexStride >> 2;
        DWORD dwPushed;

        for (DWORD k=0; k < dwCount; k++)
        {
            dwPushed = 0;
            getDC()->nvPusher.makeSpace(dwVertexSize + 1);
            getDC()->nvPusher.push (dwPushed, (dwVertexSize << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
            dwPushed++;

            for (DWORD i=0; i<7; i++)
            {
                DWORD dwCurrentArray = defaultInputRegMap[inline_renderorder[i]];
                PBYTE pVAData        = (PBYTE)(dwCopyAddr[dwCurrentArray]) + ((bIsIndexed ? pIndices[k] : k) * dwCopyStride[dwCurrentArray]);

                if (dwCopyAddr[dwCurrentArray])
                {
                    BOOL  bTex = ((dwCurrentArray == defaultInputRegMap[D3DVSDE_TEXCOORD0]) ||
                                  (dwCurrentArray == defaultInputRegMap[D3DVSDE_TEXCOORD1]));
                    DWORD dwTexIndex = dwCurrentArray - defaultInputRegMap[D3DVSDE_TEXCOORD0];

                    if (bTex && (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(dwTexIndex))) {
                        pushPassthruCubeMapCoords (&dwPushed, pVAData);
                    }
                    else if (bTex && (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXMATRIXSWFIX(dwTexIndex))) {
                        pushTransformedTexCoords (&dwPushed, pVAData, dwTexIndex, dwCopyLength[dwCurrentArray]);
                    }
                    else {
                        for (DWORD j=0; j < dwCopyLength[dwCurrentArray]; j++) {
                            nvPushData (dwPushed, *(DWORD*)(pVAData + j*sizeof(DWORD)));
                            dwPushed++;
                        }
                    }
                }
            }

            nvPusherAdjust(dwPushed);
        }

    }

    nvPushData (0,((1 << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END4);
    nvPushData (1, NV056_SET_BEGIN_END_OP_END);
    nvPusherAdjust(2);
}

//---------------------------------------------------------------------------

// must be used to handle the following cases not handled by the regular inner loops:
// 1. streams are coming from more than one context DMA
// 2. the current vertex shader includes a program

DWORD nvCelsiusILCompile_str_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
        DWORD ld1,ld2;
    xLABEL      (ld1)
        xJMP        (0)
        xLABEL      (ld2)
        xINT3

#define CHECK(a,x)                  \
    {                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
    }
#define CHECK2(a,x,y,t)             \
    {                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
    }

        xTARGET_jmp (ld1)

        //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
        xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
        xMOV_rm_imm (rmREG(rEBX),0x00040000)
        xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT,hwState.dwStateFlags))
        xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
        xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
        xJNZ32      (ld2)

        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
        {
            CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
        }
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
        {
            CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
        }
#endif

#if 1 //USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
            xPUSH_r (rEAX)
            xMOV_rm_imm (rmREG(rEAX),nvCelsiusDumpStrPrimData)
            xCALL_rm (rmREG(rEAX))
            xADD_rm_imm (rmREG(rESP),4);
#else //USE_C_LOGIC
        nvAssert(0);
#endif
        //
        // done
        //
        xPOP_r      (rEDI)
        xPOP_r      (rESI)
        xPOP_r      (rEBX)
        xPOP_r      (rEBP)
        xRET
        return lEntry;
}
#endif  // NVARCH >= 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusState.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusState.cpp
//      Celsius state management routines.
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Feb99         NV10 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "nvCelsiusCaps.h"

// all values in this matrix are constant except 3,1 and 4,1 which get correctly set later
// column 1 = vector by which [x,y,z,w] is scaled
// column 2 = vector by which [x,y,z] are biased
static D3DMATRIX mPassthruModelViewMatrix =
{
     1.f,   CELSIUS_BORDER,   0.f,   0.f,
     1.f,   CELSIUS_BORDER,   0.f,   0.f,
     0.f,   0.f,           0.f,   0.f,
     0.f,   0.f,           0.f,   0.f
};

// all elements of this matrix remain zero except the last row and the diagonal
// which get set appropriately in nvSetCelsiusTransform
static D3DMATRIX mViewportMatrix = matrixZero;

//---------------------------------------------------------------------------

// set things that are never changed in D3D. this routine is run once to initialize
// and then only whenever someone else (DDRAW) stomps on our celsius object

HRESULT nvSetCelsiusD3DDefaults (PNVD3DCONTEXT pContext)
{
    DWORD dwWindow;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_DEFAULTS;

    // context dmas
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_NOTIFIES,NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY); // notifier context
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_A,       D3D_CONTEXT_DMA_HOST_MEMORY);                          // dma a - system/agp memory
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_B,       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                // dma b - video memory
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_VERTEX,  NV01_NULL_OBJECT);                                     // vertex buffer context (gets set later)
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_STATE,   NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);                // state context
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_COLOR,   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                // frame buffer context
    pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_ZETA,    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                // zeta buffer context

    // use the first vertex to determine the color used for flat-shading
    pContext->hwState.celsius.set (NV056_SET_FLAT_SHADE_OP,   NV056_SET_FLAT_SHADE_OP_V_FIRST_VTX);
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_TYPE,NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    // deactivate all but the first clip rectangle
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    for (dwWindow=1; dwWindow<CELSIUS_MAX_WINDOWS; dwWindow++) {
        pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_HORIZONTAL(dwWindow),0);
        pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_VERTICAL(dwWindow),0);
    }

    pContext->hwState.celsius.set (NV056_SET_POINT_PARAMS_ENABLE, NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);

    pContext->hwState.celsius.set (NV056_SET_BLEND_EQUATION,      NV056_SET_BLEND_EQUATION_V_FUNC_ADD);
    pContext->hwState.celsius.set (NV056_SET_BLEND_COLOR,         0);

    pContext->hwState.celsius.set (NV056_SET_EDGE_FLAG,  1);

    pContext->hwState.celsius.set4f (NV056_SET_TEXCOORD0_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.celsius.set4f (NV056_SET_TEXCOORD1_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);

    pContext->hwState.celsius.set3f (NV056_SET_NORMAL3F(0), 0.0f, 0.0f, 1.0f);

    pContext->hwState.celsius.setf (NV056_SET_FOG1F, 0.0f);

    // we never have fog arrays
    pContext->hwState.celsius.set (NV056_SET_FOG_ARRAY_OFFSET, 0);
    pContext->hwState.celsius.set (NV056_SET_FOG_ARRAY_FORMAT,DRF_DEF(056, _SET_FOG_ARRAY_FORMAT, _SIZE, _0) |
                                                           DRF_DEF(056, _SET_FOG_ARRAY_FORMAT, _TYPE, _FLOAT));

    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL1(0), DRF_NUM(056, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008));
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL1(1), DRF_NUM(056, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008));
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL2(0),(DRF_NUM(056, _SET_TEXTURE_CONTROL2, _IMAGE_LODF, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DU, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DV, 0)));
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL2(1),(DRF_NUM(056, _SET_TEXTURE_CONTROL2, _IMAGE_LODF, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DU, 0) |
                                                               DRF_NUM(056, _SET_TEXTURE_CONTROL2, _PERTURB_DV, 0)));

    // D3D has no texgen (yet)
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_S(0), NV056_SET_TEXGEN_S_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_T(0), NV056_SET_TEXGEN_T_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_R(0), NV056_SET_TEXGEN_Q_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_Q(0), NV056_SET_TEXGEN_R_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_S(1), NV056_SET_TEXGEN_S_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_T(1), NV056_SET_TEXGEN_T_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_R(1), NV056_SET_TEXGEN_Q_V_DISABLE);
    pContext->hwState.celsius.set (NV056_SET_TEXGEN_Q(1), NV056_SET_TEXGEN_R_V_DISABLE);

    // D3D has no smoothing (note smoothing != anti-aliasing!)
    pContext->hwState.celsius.set (NV056_SET_POINT_SMOOTH_ENABLE, NV056_SET_POINT_SMOOTH_ENABLE_V_FALSE);
    pContext->hwState.celsius.set (NV056_SET_LINE_SMOOTH_ENABLE,  NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);
    pContext->hwState.celsius.set (NV056_SET_POLY_SMOOTH_ENABLE,  NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // swath width for the boustrophedonic rasterization
    // todo - use montrym's algorithm
    pContext->hwState.celsius.set (NV056_SET_SWATH_WIDTH, NV056_SET_SWATH_WIDTH_V_64);

    pContext->hwState.celsius.set4f (NV056_SET_EYE_POSITION(0), 0.0f, 0.0f, 0.0f, 1.0f);

    // we'll always cull what we call backfacing geometry.
    // this goes along with D3D's definition of culling.
    pContext->hwState.celsius.set (NV056_SET_CULL_FACE, NV056_SET_CULL_FACE_V_BACK);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set surface info: offset, pitch, clip

HRESULT nvSetCelsiusSurfaceInfo (PNVD3DCONTEXT pContext)
{
    DWORD dwClipH, dwClipV;  // horizontal and vertical clip locations

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_SURFACE;

    //
    // get render targets
    //
    CSimpleSurface *pRenderTarget;
    CSimpleSurface *pZetaBuffer;


    if (pContext->aa.isEnabled() && pContext->aa.isRenderTargetValid()) {
        pContext->aa.makeRenderTargetValid(pContext);
        pRenderTarget = pContext->pRenderTarget;
    } else if (!pContext->aa.isEnabled()) {
        pRenderTarget = pContext->pRenderTarget;
    } else {
        pRenderTarget = pContext->aa.pSuperRenderTarget;
    }

    if (pContext->aa.isEnabled() && pContext->aa.isZetaBufferValid()) {
        pContext->aa.makeZetaBufferValid(pContext);
        pZetaBuffer   = pContext->pZetaBuffer;
    } else if (!pContext->aa.isEnabled()) {
        pZetaBuffer   = pContext->pZetaBuffer;
    } else {
        pZetaBuffer   = pContext->aa.pSuperZetaBuffer;
    }


    if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M) && pZetaBuffer && (pZetaBuffer->getBPP() == 4) && 
        ((pContext->dwEarlyCopyStrategy == 2) || (pContext->dwEarlyCopyStrategy > 3)) &&
        !(pContext->aa.isEnabled() && (pContext->dwEarlyCopyStrategy > 9)))
    {
        pZetaBuffer->recreate(2);
    }


    //
    // program HW
    //
    nvAssert (pRenderTarget);
    DWORD dwFormat  = DRF_DEF(056, _SET_SURFACE_FORMAT, _TYPE, _PITCH);
    if (pRenderTarget->isSwizzled())
    {
        CTexture* pTexture = pRenderTarget->getWrapper()->getTexture();
        nvAssert(pTexture);
        dwFormat  = DRF_DEF(056, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        dwFormat |= DRF_NUM(056, _SET_SURFACE_FORMAT, _WIDTH, pTexture->getLogWidth());
        dwFormat |= DRF_NUM(056, _SET_SURFACE_FORMAT, _HEIGHT, pTexture->getLogHeight());
    }
    nvAssert(nv056SurfaceFormat[pRenderTarget->getFormat()] != ~0);
    dwFormat |= nv056SurfaceFormat[pRenderTarget->getFormat()];
    if (pZetaBuffer && (pZetaBuffer->getBPP() == 2) && (pRenderTarget->getBPP() == 4))
    {
        // NV11 mixed mode support
        nvAssert(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS);
        dwFormat |= NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5 ^
                    NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_Z1R5G5B5;
    }

    DWORD dwZPitch  = pZetaBuffer ? pZetaBuffer->getPitch()  : CELSIUS_ALIGNMENT_MIN;
#ifdef  STEREO_SUPPORT
    DWORD dwZOffset = pZetaBuffer ? GetStereoOffset(pZetaBuffer) : 0;
#else   //STEREO_SUPPORT==0
    DWORD dwZOffset = pZetaBuffer ? pZetaBuffer->getOffset() : 0;
#endif  //STEREO_SUPPORT
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_SURFACE_FORMAT,       dwFormat);
    pContext->hwState.celsius.set (NV056_SET_SURFACE_PITCH,        (DRF_NUM(056, _SET_SURFACE_PITCH, _COLOR, pRenderTarget->getPitch()) |
                                                                 DRF_NUM(056, _SET_SURFACE_PITCH, _ZETA,  dwZPitch)));
#ifdef  STEREO_SUPPORT
    pContext->hwState.celsius.set (NV056_SET_SURFACE_COLOR_OFFSET, GetStereoOffset(pRenderTarget));
#else   //STEREO_SUPPORT==0
    pContext->hwState.celsius.set (NV056_SET_SURFACE_COLOR_OFFSET, pRenderTarget->getOffset());
#endif  //STEREO_SUPPORT
    pContext->hwState.celsius.set (NV056_SET_SURFACE_ZETA_OFFSET,  dwZOffset);

    // since we're using the window clip to clip to the viewport,
    // the surface clip can just clip to the whole window.
    dwClipH = DRF_NUM(056, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0) |
              DRF_NUM(056, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, ((DWORD)pRenderTarget->getWidth()));
    dwClipV = DRF_NUM(056, _SET_SURFACE_CLIP_VERTICAL, _Y, 0) |
              DRF_NUM(056, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, ((DWORD)pRenderTarget->getHeight()));
    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_SURFACE_CLIP_HORIZONTAL, dwClipH);
    pContext->hwState.celsius.set (NV056_SET_SURFACE_CLIP_VERTICAL,   dwClipV);

    if (pZetaBuffer) {
        if (pZetaBuffer->getBPP() == 2) {
            pContext->hwState.dvZScale    = CELSIUS_Z_SCALE16;
            pContext->hwState.dvInvZScale = CELSIUS_Z_SCALE16_INV;
        }
        else {
            pContext->hwState.dvZScale    = CELSIUS_Z_SCALE24;
            pContext->hwState.dvInvZScale = CELSIUS_Z_SCALE24_INV;
        }
    }

    return (D3D_OK);
}


//---------------------------------------------------------------------------

// set up the combiners to produce one of the legacy D3D texture blends

HRESULT nvCelsiusSetTextureBlend (PNVD3DCONTEXT pContext)
{
    DWORD dwTBlend;

    if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) {

        // we have a texture. go ahead and do the blend

        dwTBlend = pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];

        nvAssert (dwTBlend <= D3D_TBLEND_MAX);  // make sure we're not off the end of the table

        pContext->hwState.dwAlphaICW[0] = celsiusTextureBlendSettings[dwTBlend][0];
        pContext->hwState.dwColorICW[0] = celsiusTextureBlendSettings[dwTBlend][1];
        pContext->hwState.dwAlphaOCW[0] = celsiusTextureBlendSettings[dwTBlend][2];
        pContext->hwState.dwColorOCW[0] = celsiusTextureBlendSettings[dwTBlend][3];

        // handle the stupid special case in which we have TBLEND_MODULATE and a
        // texture without alpha; use D3DTBLEND_MODULATEALPHA instead
        if (dwTBlend == D3DTBLEND_MODULATE) {
            CTexture *pTexture = ((CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            if (!pTexture->hasAlpha()) {
                pContext->hwState.dwAlphaICW[0] = celsiusTextureBlendSettings[D3DTBLEND_MODULATEALPHA][0];
            }
        }

        pContext->hwState.dwTexUnitToTexStageMapping[0] = 0;

    }

    else {

        // they've enabled a texture blend without a texture. just use diffuse
        pContext->hwState.dwAlphaICW[0] = celsiusTextureBlendDefault[0];
        pContext->hwState.dwColorICW[0] = celsiusTextureBlendDefault[1];
        pContext->hwState.dwAlphaOCW[0] = celsiusTextureBlendDefault[2];
        pContext->hwState.dwColorOCW[0] = celsiusTextureBlendDefault[3];

    }

    pContext->hwState.dwAlphaICW[1] = 0;
    pContext->hwState.dwColorICW[1] = 0;
    pContext->hwState.dwAlphaOCW[1] = 0;
    pContext->hwState.dwColorOCW[1] = DRF_DEF(056, _SET_COMBINER1_COLOR_OCW, _ITERATION_COUNT, _ONE) |
                                          DRF_DEF(056, _SET_COMBINER1_COLOR_OCW, _MUX_SELECT, _LSB);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// define to enable profiling of combiner programs
// #define COMBINER_STATS

// set up the celsius combiners for either the current texture stage state
// or a legacy texture blend

HRESULT nvSetCelsiusColorCombiners (PNVD3DCONTEXT pContext)
{
    BOOL  bStageActive;
    DWORD dwMapping0, dwMapping1, dwStateFlags;
    DWORD dwTSSMask0, dwTSSMask1;

    #ifdef DEBUG
    static DWORD dwActiveStageCounts[2] = {0,0};
    static DWORD dwTotalPrograms = 0;
    static DWORD dwLastMask0, dwLastMask1;
    // masks requiring 2 stages that we already know about and don't want reported again
    // (also modes that could be compacted into one stage but are idiotic and don't deserve it)
    static DWORD dwKnownMasks[19][2] = {
        // uncompactable
        0x90020820, 0xb0220820,
        0x90400400, 0x90410400,
        0x90400400, 0x90411040,
        0x90400400, 0x94410400,
        0x90400400, 0xb4410400,
        0x90400840, 0x90410400,
        0x90400840, 0xb4410c01,
        0x90401040, 0x90411040,
        0x90401040, 0x94411c41,
        0x90401043, 0xc0411c41,
        0x90400c00, 0x10410840,
        0x90410400, 0x90411040,
        0x90410840, 0x90410400,
        0x90620840, 0x90220820,
        0xb8403840, 0x9c200c00,
        0xb8403840, 0x9c201c20,
        0xe0440840, 0x90410400,
        // idiotic
        0x10401040, 0x10411041,
        0x10401040, 0x34410400
    };
    #endif  // DEBUG

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_COMBINERS;

    // cache current values
    dwStateFlags = pContext->hwState.dwStateFlags & CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS;
    dwMapping0   = pContext->hwState.dwTexUnitToTexStageMapping[0];
    dwMapping1   = pContext->hwState.dwTexUnitToTexStageMapping[1];

    // clear state that will be re-determined here
    pContext->hwState.dwNextAvailableTextureUnit = 0;
    pContext->hwState.dwTexUnitToTexStageMapping[0] = CELSIUS_UNUSED;
    pContext->hwState.dwTexUnitToTexStageMapping[1] = CELSIUS_UNUSED;
    pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_DOTPRODUCT3(0)        |
                                        CELSIUS_FLAG_DOTPRODUCT3(1)        |
                                        CELSIUS_FLAG_ADDCOMPLEMENTRGB(0)   |
                                        CELSIUS_FLAG_ADDCOMPLEMENTRGB(1)   |
                                        CELSIUS_FLAG_ADDCOMPLEMENTALPHA(0) |
                                        CELSIUS_FLAG_ADDCOMPLEMENTALPHA(1));

    if (pContext->bUseTBlendSettings) {

        nvCelsiusSetTextureBlend (pContext);
        pContext->hwState.dwNumActiveCombinerStages = 1;

    }

    else {

#ifdef CELSIUS_NVCOMBINER
        // count the number of texture stages
        DWORD dwStageCount = 0;
        DWORD dwTexCount = 0;
        while ((dwStageCount < 8) &&
               (pContext->tssState[dwStageCount].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
        {
            if(pContext->tssState[dwStageCount].dwValue[D3DTSS_TEXTUREMAP]) dwTexCount++;
            dwStageCount++;
        }
        if (dwStageCount > 2) {
            switch (dwStageCount) {
                case 3:
                    // a very Special case required from developer
                    // disable for now, since not functional
                    /* if (nvCelsiusCheck3StageSpecial (pContext)) {
                        nvCelsiusSet3StageSpecial(pContext);
                    } else
                    */
                    // check for special 3-stage, 2-texture setting
                    if (nvCelsiusCheck3Stage2Textures (pContext)) {
                        nvCelsiusSetTextures3StageCombiners (pContext);
                    } else {
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        return (D3D_OK);
                    }
                    break;
                case 4:
                    // check for special 4-stage bumpmapping
                    if (nvCheckBumpMapStates (pContext, dwStageCount)) {
                        nvSetCelsius4StageBumpMapCombiners (pContext);
                    } else {
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        return (D3D_OK);
                    }
                    break;
                case 8:
                    // check for special 8-stage bumpmapping
                    if (((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_DIRECTMAPENABLE_MASK) == D3D_REG_DIRECTMAPENABLE_ENABLE) &&
                        (nvCheckBumpMapStates (pContext,dwStageCount))) {
                        nvSetCelsius8StageBumpMapCombiners (pContext);
                    } else {
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        return (D3D_OK);
                    }
                    break;
                default:
                    DPF ("unhandled number of combiner stages");
                    pContext->hwState.dwStateFlags |=CELSIUS_FLAG_SETUPFAILURE;
                    return (D3D_OK);
            }
        }

        // see if we can pack two texture stages into one combiner
        else if ((dwStageCount==2) &&
                 (nvCelsiusCheck2Stage1Combiner(pContext)) &&
                 (nvCelsiusSet2Stage1Combiner(pContext) == D3D_OK)) {
            // everything's ok. nothing more to do
        }
        else
#endif
        {
            dwTSSMask0 = nvCelsiusBuildTSSMask (pContext, 0);
            dwTSSMask1 = nvCelsiusBuildTSSMask (pContext, 1);

            if (!nvCelsiusCombinersSetFromHashTable (pContext, dwTSSMask0, dwTSSMask1)) {

                // program the old-fashioned way
                pContext->hwState.dwNumActiveCombinerStages = 1;  // we always have at least one stage

                bStageActive = ConstructColorCombiners (pContext, 0, 0);
                ConstructAlphaCombiners (pContext, 0, 0, bStageActive);

                // if the current unit got assigned to this stage, move on to the next
                if (pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] != CELSIUS_UNUSED) {
                    pContext->hwState.dwNextAvailableTextureUnit++;
                }

                if (bStageActive) {

                    // if the first stage was active, go ahead and process the second
                    bStageActive = ConstructColorCombiners (pContext, 1, 1);
                    ConstructAlphaCombiners (pContext, 1, 1, bStageActive);

                    if (bStageActive) {
                        pContext->hwState.dwNumActiveCombinerStages = 2;
                    }

                }  // bStageActive

                else {

                    pContext->hwState.dwColorICW[1] = 0;
                    pContext->hwState.dwColorOCW[1] = 0;
                    pContext->hwState.dwAlphaICW[1] = 0;
                    pContext->hwState.dwAlphaOCW[1] = 0;

                }

                pContext->hwState.dwColorOCW[1] |= DRF_NUM(056, _SET_COMBINER1_COLOR, _OCW_ITERATION_COUNT,
                                                               pContext->hwState.dwNumActiveCombinerStages);

                // add this program to the hash table for future reference
                //only add it if it didn't fail.
                if (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_SETUPFAILURE))
                {
                    nvCelsiusCombinersAddToHashTable (pContext, dwTSSMask0, dwTSSMask1);
                }
            }  // !nvCelsiusCombinersSetFromHashTable

            #ifdef DEBUG
            dwActiveStageCounts[pContext->hwState.dwNumActiveCombinerStages-1] ++;
            if (pContext->hwState.dwNumActiveCombinerStages == 2) {
                // try to cut down on complaints a bit
                if ((dwTSSMask0 != dwLastMask0) ||
                    (dwTSSMask1 != dwLastMask1)) {
                    dwLastMask0 = dwTSSMask0;
                    dwLastMask1 = dwTSSMask1;
                    BOOL bKnown = FALSE;
                    for (DWORD i=0; i<(sizeof(dwKnownMasks)>>3); i++) {
                        if ((dwKnownMasks[i][0] == dwTSSMask0) &&
                            (dwKnownMasks[i][1] == dwTSSMask1)) {
                            bKnown = TRUE;
                            break;
                        }
                    }
                    if (!bKnown) {
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"using two combiner stages in unknown mode.");
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"please give the following information to craig.");
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   TSS mask 0 = 0x%08x", dwTSSMask0);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   TSS mask 1 = 0x%08x", dwTSSMask1);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color icw[0] = 0x%08x", pContext->hwState.dwColorICW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color ocw[0] = 0x%08x", pContext->hwState.dwColorOCW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha icw[0] = 0x%08x", pContext->hwState.dwAlphaICW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha ocw[0] = 0x%08x", pContext->hwState.dwAlphaOCW[0]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color icw[1] = 0x%08x", pContext->hwState.dwColorICW[1]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   color ocw[1] = 0x%08x", pContext->hwState.dwColorOCW[1]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha icw[1] = 0x%08x", pContext->hwState.dwAlphaICW[1]);
                        DPF_LEVEL(NVDBG_LEVEL_INFO,"   alpha ocw[1] = 0x%08x", pContext->hwState.dwAlphaOCW[1]);
//                        __asm int 3;  comment out so others can use debug builds without hitting int 3
                    }
                }
            }
            #ifdef COMBINER_STATS
            dwTotalPrograms ++;
            if (dwTotalPrograms % 1000 == 0) {
                DPF ("----------------- combiner stats -------------------");
                DPF ("instances of 1 active stages: %d", dwActiveStageCounts[0]);
                DPF ("             2 active stages: %d", dwActiveStageCounts[1]);
                DPF ("total combiner programs: %d", dwTotalPrograms);
            }
            #endif  // COMBINER_STATS
            #endif  // DEBUG
        }
    }

#if 0
    // force combiner settings
    pContext->hwState.dwColorICW[0] = 0x20200000;
    pContext->hwState.dwColorOCW[0] = 0x00000c00;
    pContext->hwState.dwAlphaICW[0] = 0x30300000;
    pContext->hwState.dwAlphaOCW[0] = 0x00000c00;

    pContext->hwState.dwColorICW[1] = 0x00000000;
    pContext->hwState.dwColorOCW[1] = 0x10000000;
    pContext->hwState.dwAlphaICW[1] = 0x00000000;
    pContext->hwState.dwAlphaOCW[1] = 0x00000000;
#endif

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), pContext->hwState.dwColorICW[0]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   pContext->hwState.dwColorOCW[0]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), pContext->hwState.dwAlphaICW[0]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), pContext->hwState.dwAlphaOCW[0]);

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(1), pContext->hwState.dwColorICW[1]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER1_COLOR_OCW,   pContext->hwState.dwColorOCW[1]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(1), pContext->hwState.dwAlphaICW[1]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(1), pContext->hwState.dwAlphaOCW[1]);

    // if we've changed the flags or mappings, invalidate a bunch of state
    if ((pContext->hwState.dwStateFlags & CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS) != dwStateFlags) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SPECFOG_COMBINER |
                                          CELSIUS_DIRTY_LIGHTS;
    }

    if ((pContext->hwState.dwTexUnitToTexStageMapping[0] != dwMapping0) ||
        (pContext->hwState.dwTexUnitToTexStageMapping[1] != dwMapping1)) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE
                                       |  CELSIUS_DIRTY_TEXTURE_TRANSFORM
                                       |  CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_FVF
                                       |  CELSIUS_DIRTY_TRANSFORM;
    }

#ifdef ALPHA_CULL
    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
#endif

    return D3D_OK;
}


//---------------------------------------------------------------------------

// set up all the fundamental stuff that can be derived from the texture
// itself (without looking at renderstate, texture stage state, etc.)
// these are values that are handled identically for real user textures,
// the default texture, and the texture used for user clip planes, so we
// consolidate the code here.

__inline void nvCelsiusSetTextureBasics (CTexture *pTexture, DWORD *dwControl0,
                                         DWORD *dwFormatMask, DWORD *dwFilterMask)
{
    *dwControl0    = pTexture->getNV056Control0();
    *dwFormatMask  = pTexture->getNV056Format();
    *dwFilterMask  = 0;
}

//---------------------------------------------------------------------------

// OR in additional default texture stuff. these are values that are common
// to the default white texture and the clip plane texture but NOT real
// user textures. for the latter, they are contingent on other state settings.

__inline void nvCelsiusAddTextureDefaults (CTexture *pTexture,
                                           DWORD *dwControl0, DWORD *dwFormatMask,
                                           DWORD *dwFilterMask, DWORD *dwOffset)
{
    // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
    // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
    // the d3d minimum level (the openGL / celsius maximum) is always just the end of the chain
    *dwControl0 |= DRF_NUM(056, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP,
                           ((pTexture->getMipMapCount()-1) << 8));  // 4.8 fixed point

    *dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

    *dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _FALSE)  |

                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSU, _CLAMP) |
                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSV, _CLAMP) |

                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _FALSE)           |
                     DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _FALSE);

    *dwFilterMask |= DRF_DEF(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, _NEAREST) |
                     DRF_DEF(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, _NEAREST);

    *dwOffset = pTexture->getSwizzled()->getOffset();
}

//---------------------------------------------------------------------------

__inline void nvCelsiusSendTextureData (PNVD3DCONTEXT pContext,
                                        DWORD dwStage, DWORD dwControl0, DWORD dwOffset,
                                        DWORD dwFormatMask, DWORD dwFilterMask)
{
// #define TEXSTATE_STATS
#if defined(DEBUG) && defined(TEXSTATE_STATS)
    static DWORD dwC0Last = 0;
    static DWORD dwOffsetLast = 0;
    static DWORD dwFormatLast = 0;
    static DWORD dwFilterLast = 0;
    static DWORD dwC0Changes = 0;
    static DWORD dwOffsetChanges = 0;
    static DWORD dwFormatChanges = 0;
    static DWORD dwFilterChanges = 0;
    static DWORD dwTotalTexDataSets = 0;
    static DWORD dwLoopTime = 0;
#endif  // DEBUG && TEXSTATE_STATS

    pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL0(dwStage), dwControl0);
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_OFFSET(dwStage),   dwOffset);
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_FORMAT(dwStage),   dwFormatMask);
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_FILTER(dwStage),   dwFilterMask);

#if defined(DEBUG) && defined(TEXSTATE_STATS)
    dwTotalTexDataSets++;
    if (dwControl0 != dwC0Last) {
        dwC0Last = dwControl0;
        dwC0Changes++;
    }
    if (dwOffset != dwOffsetLast) {
        dwOffsetLast = dwOffset;
        dwOffsetChanges++;
    }
    if (dwFormatMask != dwFormatLast) {
        dwFormatLast = dwFormatMask;
        dwFormatChanges++;
    }
    if (dwFilterMask != dwFilterLast) {
        dwFilterLast = dwFilterMask;
        dwFilterChanges++;
    }
    DWORD dwNow = GetTickCount();
    if ((dwNow - dwLoopTime) > 1000) {
        DPF ("----------------- TEX STATS ----------------- dwNow = %d",dwNow);
        dwLoopTime = dwNow;
        DPF ("control0 changes: %d", dwC0Changes);
        DPF ("  offset changes: %d", dwOffsetChanges);
        DPF ("  format changes: %d", dwFormatChanges);
        DPF ("  filter changes: %d", dwFilterChanges);
    }
#endif  // DEBUG && TEXSTATE_STATS
}

//---------------------------------------------------------------------------

HRESULT nvSetCelsiusTexturePalette (PNVD3DCONTEXT pContext, PNVD3DTEXSTAGESTATE pTSSState, DWORD dwHWStage)
{
    CSimpleSurface     *pPalette;
    CNvObject          *pPalObj;
    DWORD               dwCDMA, dwOffset;
    DWORD               dwSystemPalette = 0;    // count of system memory palettes
    DWORD               dwPaletteOffset = 0;

    // NV10 ISSUE:
    // The run-time DMA error STATUS_ERROR_INVALID_STATE (0x01000000) occurs
    // if the DMA controller requests 32-bit data words from system (PCI or AGP) memory
    // This can occur if the following condition was true when a primitive was launched:
    //  (((SetTextureControl0[0].Enable == TRUE) ||
    //    (SetTextureControl0[1].Enable == TRUE))   &&
    //   ((SetTextureFormat[0].Color == I8_A8R8G8B8) ||
    //    (SetTextureFormat[1].Color == I8_A8R8G8B8))   &&
    //   ((SetTexturePalette[0].PaletteContextDMA != SetTexturePalette[1].PaletteContextDMA) ||
    //    (SetTexturePalette[0].PaletteOffset != SetTexturePalette[1].PaletteOffset))   &&
    //   ((MemoryType(SetContextDmaA.handle) == SYSTEM) ||
    //    (MemoryType(SetContextDmaB.handle) == SYSTEM)))
    //   i.e. you can't fetch BOTH palettes from system/agp memory -- we don't have the bandwith.
    //   we can fetch them from video memory however.

    pPalObj = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getPalette();

    if (pPalObj == NULL) {
        DPF ("stupid app/runtime gave us a palettized texture without a palette");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pPalette = pPalObj->getPaletteSurface();
    nvAssert (pPalette);   // should already have bound a palette before using this texture

    dwCDMA   = nv056PaletteContextDma[pPalette->getContextDMA()];
    dwOffset = pPalette->getOffset();

    // only accept a VID MEM Palette
    nvAssert ((dwCDMA == NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A) ||
              (dwCDMA == NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B));
    nvAssert ((dwOffset & 0xff) == 0);

    if (dwCDMA == NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B) {
        if (dwSystemPalette == 1 && dwPaletteOffset != dwOffset) {
            // nvAssert(0); // We can't do two system palettes at the same time
            dwOffset = dwPaletteOffset; // rather than faulting in the driver do this gross thing
                                        // of forcing the second palette to match the first.
        }
        else {
            dwSystemPalette = 1;
            dwPaletteOffset=dwOffset;
        }
    }

    // set the HW state. this perverse method wants dwOffset>>6. ours is not to reason why...
    pContext->hwState.celsius.set (NV056_SET_TEXTURE_PALETTE(dwHWStage),
                                (DRF_NUM (056, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, dwCDMA) |
                                 DRF_NUM (056, _SET_TEXTURE_PALETTE, _PALETTE_OFFSET, (dwOffset>>6))));

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set celsius state having to do with textures, including:
//      - formats
//      - filters
//      - offsets
// note: the combiners must be set up before calling this routine!

HRESULT nvSetCelsiusTextureState (PNVD3DCONTEXT pContext)
{
    DWORD               dwHWStage, dwD3DStage, dwTexUnitStatus;
    DWORD               dwTexGen, dwTCIndex, dwVAIndex, dwMod;
    PNVD3DTEXSTAGESTATE pTSSState;
    DWORD               dwControl0, dwFormatMask, dwFilterMask;
    DWORD               dwOffset, dwTexgenMode;
    DWORD               dwTexgenT, dwZEnable;
    DWORD               dwUserCoordsNeeded = 0;
    DWORD               dwTexCoordIndices = 0;
    DWORD               dwNumTexCoordsNeeded = 0;
    DWORD               dwInvMVNeeded = 0;
    CTexture           *pTexture;
    BOOL                bCubeMap;
    BOOL                bWrapU, bWrapV, bWrapP, bWrapQ;
    DWORD               dwWDivideFlags = 0;
    DWORD               dwWSourceFlags = 0;
    BOOL                bWSourceFound = FALSE;
    D3DVALUE            pClipPlaneEye[4];
    D3DVALUE           *pClipPlane1, *pClipPlane2;
    DWORD               dwClipPlaneEnable, dwCurrentClipPlaneIndex;
    D3DMATRIX           mTmp, mTmp2;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TEXTURE_STATE;

    dwZEnable = pContext->pZetaBuffer ? pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] : 0;

    dwClipPlaneEnable = pContext->dwRenderState[D3DRENDERSTATE_CLIPPLANEENABLE];
    dwCurrentClipPlaneIndex = 0;

    // iterate over the HW's two texture units

    for (dwHWStage=0; dwHWStage < 2 ; dwHWStage++) {

        // which D3D stage is handled by this HW stage

        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage != CELSIUS_UNUSED) {

#ifdef NV_PROFILE_DP2OPS
            pDriverData->pBenchmark->incActiveTextures();
#endif

            // the combiners assigned this texture unit.
            // we must have a legitimate texture to use

            pTSSState = &(pContext->tssState[dwD3DStage]);
            nvAssert(pTSSState->dwValue[D3DTSS_TEXTUREMAP]);

            if (pTSSState->dwValue[D3DTSS_TEXTUREMAP]) {
                pTexture = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
                if(!pTexture){
                    //if failed to get a texture but user requested one -- use the default
                    pTexture = getDC()->pDefaultTexture;
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                }
            } else {
                pTexture = getDC()->pDefaultTexture;
            }

            bCubeMap = pTexture->isCubeMap();
            if (bCubeMap) {
                // cubemaps may only be referenced from their bases
                pTexture = pTexture->getBaseTexture();

                if (dwZEnable == D3DZB_USEW) {
                    DPF("switching from W-buffering to Z-buffering b/c cube maps are enabled");
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                    dwZEnable = D3DZB_TRUE;
                }
            }

            nvAssert (pTexture);
            dbgTextureDisplay (pTexture);

            dwNumTexCoordsNeeded |= KELVIN_SET_NUM_TEX_COORDS(dwHWStage, pTexture->getNumTexCoords());

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_USER;
            pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            if (pTexture->isPalettized()) {
                nvSetCelsiusTexturePalette (pContext, pTSSState, dwHWStage);
            }
            else if (pTexture->hasAutoPalette()) {
                nvAssert((pTexture->getAutoPaletteOffset() & 63) == 0);
                // the header file (nv32.h) appears to be wrong here, texture offset is at bit 0
                // so we can't use the expected DRF_NUM(056, _SET_TEXTURE_PALETTE, _PALETTE_OFFSET, pTexture->getAutoPaletteOffset());
                DWORD dwFormat = DRF_NUM(056, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, nv056PaletteContextDma[pTexture->getSwizzled()->getContextDMA()])
                               | (pTexture->getAutoPaletteOffset());
                pContext->hwState.celsius.set (NV056_SET_TEXTURE_PALETTE(dwHWStage), dwFormat);
            }

            // set up basic texture info
            nvCelsiusSetTextureBasics (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask);

            // set up info specific to real user textures...

            dwTexGen  = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) ?
                        D3DTSS_TCI_PASSTHRU : pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            dwTCIndex = pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
            dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];

            // texgen
            switch (dwTexGen) {
                case D3DTSS_TCI_PASSTHRU:
                    if (pContext->pCurrentVShader->bVAExists(dwVAIndex)) {
                        dwUserCoordsNeeded |= CELSIUS_FLAG_USERTEXCOORDSNEEDED(dwHWStage);
                        dwTexCoordIndices  |= dwTCIndex << (16*dwHWStage);
                    }
                    else {
                        // u,v = 0,0   (says MS) W=1.0 THIS IS IMPORTANT (DOH!)
                            DWORD dwBase = NV056_SET_TEXCOORD0_4F(0) + 0x28 * dwHWStage; // macro not designed well
                            pContext->hwState.celsius.set4f (dwBase,0.0f, 0.0f, 0.0f, 1.0f);
                    }
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_DISABLE;
                    break;
                case D3DTSS_TCI_CAMERASPACENORMAL:
                    dwInvMVNeeded = CELSIUS_FLAG_TEXSTATENEEDSINVMV;
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_NORMAL_MAP;
                    break;
                case D3DTSS_TCI_CAMERASPACEPOSITION:
                    dwMod = 0x40 * dwHWStage; // macro not designed well
                    pContext->hwState.celsius.set4f (dwMod + NV056_SET_TEXGEN_SPLANE0(0), 1.0f, 0.0f, 0.0f, 0.0f);
                    pContext->hwState.celsius.set4f (dwMod + NV056_SET_TEXGEN_TPLANE0(0), 0.0f, 1.0f, 0.0f, 0.0f);
                    pContext->hwState.celsius.set4f (dwMod + NV056_SET_TEXGEN_RPLANE0(0), 0.0f, 0.0f, 1.0f, 0.0f);
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_EYE_LINEAR;
                    break;
                case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                    dwInvMVNeeded = CELSIUS_FLAG_TEXSTATENEEDSINVMV;
                    dwTexgenMode = NV056_SET_TEXGEN_S_V_REFLECTION_MAP;
                    break;
                default:
                    DPF ("unknown texgen mode in nvSetCelsiusTextureState");
                    dbgD3DError();
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                    break;
            }

            // we always generate three coordinates (i think)
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_S(dwHWStage), dwTexgenMode);
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_T(dwHWStage), dwTexgenMode);
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_R(dwHWStage), dwTexgenMode);
            pContext->hwState.celsius.set (NV056_SET_TEXGEN_Q(dwHWStage), NV056_SET_TEXGEN_Q_V_DISABLE);

            // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
            // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
            // the d3d minimum level (the openGL / celsius maximum) is always just the end of the chain
            dwControl0 |= DRF_NUM(056, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP,
                                  (pTSSState->dwValue[D3DTSS_MAXMIPLEVEL] << 8));  // 4.8 fixed point

            // colorkey
            if ((pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]) &&
                (pTexture->hasColorKey())) {
                dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _KILL);  // use this choice since the texture may not have alpha
                DWORD dwKey = pTexture->getColorKey();
#ifdef DEBUG
                DWORD dwFailState = 1;
#endif
                if (pTexture->isPalettized()) {
                    CNvObject *pObj = pTexture->getWrapper();
                    if (!pObj) goto failColorKeyPalette;

                    CNvObject *pPalette = pObj->getPalette();
                    if (!pPalette) goto failColorKeyPalette;

                    CSimpleSurface *pPaletteSurface = pPalette->getPaletteSurface();
                    if (!pPaletteSurface) goto failColorKeyPalette;

                    DWORD *dwPalette = (DWORD *)pPaletteSurface->getAddress();
                    if (!dwPalette) goto failColorKeyPalette;

                    if (dwKey >= 256) goto failColorKeyPalette;

                    dwKey = dwPalette[dwKey];
                }
#ifdef DEBUG
                dwFailState = 0;
#endif
failColorKeyPalette:  // We should put some kind of error code in here eventually
#ifdef DEBUG
                if (dwFailState) {
                    __asm int 3;
                    // Palettized
                }
#endif
                pContext->hwState.celsius.set (NV056_SET_COLOR_KEY_COLOR(dwHWStage), dwKey);
            }
            else {
                dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
            }

            // handle cubemapping
            dwFormatMask |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, bCubeMap);

            dwFormatMask |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSU,
                                    nv056TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSU]]);
            dwFormatMask |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _TEXTUREADDRESSV,
                                    nv056TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSV]]);

            // Check cylindrical wrapping (disallow it if we're cubemapping)
            NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);

            if (bWrapU && !bCubeMap) {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _TRUE);
            }
            else {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _FALSE);
            }

            if (bWrapV && !bCubeMap) {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _TRUE);
            }
            else {
                dwFormatMask |= DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _FALSE);
            }

            if (!(dwFormatMask & (DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPU, _TRUE) |
                                  DRF_DEF(056, _SET_TEXTURE_FORMAT, _WRAPV, _TRUE)))) {
#ifdef CELSIUS_ENABLE_BAD_PERSPECTIVE
                if (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
#endif
                {
                    dwWDivideFlags |= CELSIUS_FLAG_WDIVIDE (dwHWStage);
                    // we can source w from this stage for the purposes of w-buffering if w-divide is enabled
                    // and the texture is non-projective. we can't source w from a projective texture because
                    // the non-unitary q will be multiplied into the w values.
                    if (!(pTSSState->dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] & D3DTTFF_PROJECTED)) {
                        dwWSourceFlags |= CELSIUS_FLAG_WSOURCE (dwHWStage);
                        bWSourceFound = TRUE;
                    }
                }
            }

            DWORD dwMinFilter = pTSSState->dwValue[D3DTSS_MINFILTER];
            DWORD dwMagFilter = pTSSState->dwValue[D3DTSS_MAGFILTER];
            DWORD dwMipFilter = pTSSState->dwValue[D3DTSS_MIPFILTER];

            if (pContext->dwDXAppVersion >= 0x800) {
                // DX8 changed the filter enumerants.  Remap them so we don't have to change our code.
                dwMinFilter = dx8MinFilterMapping[dwMinFilter];
                dwMagFilter = dx8MagFilterMapping[dwMagFilter];
                dwMipFilter = dx8MipFilterMapping[dwMipFilter];
            }

            // Mag filter aniso is bilinear in HW, and this passes WHQL.
            // As a result trigger anisotropic off of Min filter only
            if ((dwMinFilter == D3DTFN_ANISOTROPIC) ||
                (getDC()->nvD3DRegistryData.regAnisotropicLevel != D3D_REG_ANISOTROPICLEVEL_PASSIVE))
            {
                DWORD dwMaxAnisotropy = (getDC()->nvD3DRegistryData.regAnisotropicLevel == D3D_REG_ANISOTROPICLEVEL_PASSIVE) ?
                                        pTSSState->dwValue[D3DTSS_MAXANISOTROPY] :
                                        getDC()->nvD3DRegistryData.regAnisotropicLevel;
                switch (dwMaxAnisotropy) {
                    case 0:
                        // default back to point
                        dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[D3DTFN_POINT][dwMipFilter]);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[dwMagFilter]);
                        break;
                    case 1:
                        // default back to linear with no aniso
                        dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[dwMagFilter]);
                        break;
                    default:
                        // aniso > 2. we can't really do it, but we'll approximate it as best we can
                        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        // fall through
                    case 2:
                        // use real aniso
                        dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _1);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                        dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[D3DTFG_LINEAR]);

                        if(dwMagFilter == D3DTFG_POINT) {
                            // When aniso filtering is on, mag filter will be linear, point filtering
                            // won't happen, so we must fail validate texture stage for DCT450.
                            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                        }
                        break;
                }  // switch
            }

            else {

                dwControl0   |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMIN, nv056TextureMinFilter[dwMinFilter][dwMipFilter]);
                dwFilterMask |= DRF_NUM(056, _SET_TEXTURE_FILTER, _TEXTUREMAG, nv056TextureMagFilter[dwMagFilter]);
            }

            // OR in LOD bias
            DWORD dwLODBias = pTSSState->dwLODBias;
            if ((pContext->bScaledFlatPanel)         &&
                (pContext->dwEarlyCopyStrategy > 2)  &&
                (pContext->dwEarlyCopyStrategy < 10) &&
                (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE))) {
                // sign-extend from 5.8 to 24.8
                int iLODBias = (dwLODBias & 0x00001000) ? (dwLODBias | 0xfffff000) : dwLODBias;
                iLODBias += int (0.5f * 256.0f);   // 5.8 format
                // clamp to -2^12...2^12-1 (5.8 twos-complement fixed-point)
                iLODBias = max (iLODBias, int(-4096));
                iLODBias = min (iLODBias, int(4095));
                // return the last 13 bits
                dwLODBias = iLODBias & 0x00001fff;
            }
            dwFilterMask |= dwLODBias;

            dwOffset = pTexture->getSwizzled()->getOffset();

            nvCelsiusSendTextureData (pContext, dwHWStage, dwControl0, dwOffset, dwFormatMask, dwFilterMask);
        }

        else if (dwClipPlaneEnable) {

            // if user clip planes are enabled, knock off as many as we can.
            // (each texture stage can handle two)

            pTexture = getDC()->pClipPlaneTexture;

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_CLIP;
            pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            dwWDivideFlags |= CELSIUS_FLAG_WDIVIDE (dwHWStage);
            dwWSourceFlags |= CELSIUS_FLAG_WSOURCE (dwHWStage);
            bWSourceFound = TRUE;

            // find the first enabled plane
            while (!(dwClipPlaneEnable & 0x1)) {
                dwClipPlaneEnable >>= 1;
                dwCurrentClipPlaneIndex++;
            }
            pClipPlane1 = pContext->ppClipPlane[dwCurrentClipPlaneIndex];
            dwClipPlaneEnable >>= 1;
            dwCurrentClipPlaneIndex++;

            // find the second enabled plane, if any
            if (dwClipPlaneEnable) {
                while (!(dwClipPlaneEnable & 0x1)) {
                    dwClipPlaneEnable >>= 1;
                    dwCurrentClipPlaneIndex++;
                }
                pClipPlane2 = pContext->ppClipPlane[dwCurrentClipPlaneIndex];
                dwTexgenT = NV056_SET_TEXGEN_T_V_EYE_LINEAR;
                dwClipPlaneEnable >>= 1;
                dwCurrentClipPlaneIndex++;
            }

            else {
                pClipPlane2 = NULL;
                dwTexgenT = NV056_SET_TEXGEN_T_V_DISABLE;
            }

            // set up tex coordinate sources
            // default to [1,1,0,1] and get s and/or t from eye space coords, as needed
            pContext->hwState.celsius.set4f (NV056_SET_TEXCOORD0_4F(0) + 0x28 * dwHWStage, 1.0f, 1.0f, 0.0f, 1.0f);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_S(dwHWStage), NV056_SET_TEXGEN_S_V_EYE_LINEAR);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_T(dwHWStage), dwTexgenT);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_R(dwHWStage), NV056_SET_TEXGEN_R_V_DISABLE);
            pContext->hwState.celsius.set   (NV056_SET_TEXGEN_Q(dwHWStage), NV056_SET_TEXGEN_Q_V_DISABLE);

            // dot the eyespace coords with clip plane normals
            // D3D gives us the normals in world space, so they need to be converted to eye space
            Inverse4x4 (&mTmp, &(pContext->xfmView), TRUE);
            MatrixTranspose4x4 (&mTmp2, &mTmp);

            XformVector4 (pClipPlaneEye, pClipPlane1, &mTmp2);
            pContext->hwState.celsius.set4f (NV056_SET_TEXGEN_SPLANE0(0) + 0x40 * dwHWStage,
                                          pClipPlaneEye[0], pClipPlaneEye[1],
                                          pClipPlaneEye[2], pClipPlaneEye[3]);

            if (pClipPlane2) {
                XformVector4 (pClipPlaneEye, pClipPlane2, &mTmp2);
                pContext->hwState.celsius.set4f (NV056_SET_TEXGEN_TPLANE0(0) + 0x40 * dwHWStage,
                                              pClipPlaneEye[0], pClipPlaneEye[1],
                                              pClipPlaneEye[2], pClipPlaneEye[3]);
            }

            // we now have s<0 behind the plane and s>0 in front of the plane at the input
            // to the texture transform. we need to shift these coords by 0.5 so that clipped
            // stuff falls on the left (or upper) part of the texture and unclipped stuff falls
            // on the right (or lower) part of the texture
            pContext->hwState.celsius.set (NV056_SET_TEXTURE_MATRIX0_ENABLE + dwHWStage * 4, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

            // for user clip planes we need a transform matrix that just adds small
            // quantities to the s and t coords produced by texgen
            DWORD dwBase = dwHWStage ? NV056_SET_TEXTURE_MATRIX1(0) : NV056_SET_TEXTURE_MATRIX0(0);
            pContext->hwState.celsius.set4f (dwBase +  0, 1.0f, 0.0f, 0.0f, 0.5f);
            pContext->hwState.celsius.set4f (dwBase + 16, 0.0f, 1.0f, 0.0f, pClipPlane2 ? 0.5f : 0.0f);
            pContext->hwState.celsius.set4f (dwBase + 32, 0.0f, 0.0f, 1.0f, 0.0f);
            pContext->hwState.celsius.set4f (dwBase + 48, 0.0f, 0.0f, 0.0f, 1.0f);

            nvCelsiusSetTextureBasics (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask);
            nvCelsiusAddTextureDefaults (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask, &dwOffset);

            dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _KILL);
            pContext->hwState.celsius.set (NV056_SET_COLOR_KEY_COLOR(dwHWStage), 0);

            nvCelsiusSendTextureData (pContext, dwHWStage, dwControl0, dwOffset, dwFormatMask, dwFilterMask);
        }

        else if ((dwZEnable==D3DZB_USEW) && (bWSourceFound==FALSE)) {

            // we're using w-buffering, but we haven't yet enabled a texture unit
            // in which we can do the requisite w divide. the w divide is required
            // because the inverted 1/w value (plain w itself) required for w-buffering
            // is only available (with sufficient precision) from the texturing unit.

            // use the default texture (white)
            pTexture = getDC()->pDefaultTexture;

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_DEFAULT;
            pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            dwWDivideFlags |= CELSIUS_FLAG_WDIVIDE (dwHWStage);
            dwWSourceFlags |= CELSIUS_FLAG_WSOURCE (dwHWStage);
            bWSourceFound = TRUE;

            pContext->hwState.celsius.set4 (NV056_SET_TEXGEN_S(dwHWStage),
                                         NV056_SET_TEXGEN_S_V_DISABLE,
                                         NV056_SET_TEXGEN_T_V_DISABLE,
                                         NV056_SET_TEXGEN_R_V_DISABLE,
                                         NV056_SET_TEXGEN_Q_V_DISABLE);

            nvCelsiusSetTextureBasics (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask);
            nvCelsiusAddTextureDefaults (pTexture, &dwControl0, &dwFormatMask, &dwFilterMask, &dwOffset);

            dwControl0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);

            nvCelsiusSendTextureData (pContext, dwHWStage, dwControl0, dwOffset, dwFormatMask, dwFilterMask);
        }

        else {

            // no user texture, no clip planes, no w-buffering. go ahead and totally disable the stage

            dwTexUnitStatus = CELSIUS_TEXUNITSTATUS_IDLE;
            pContext->hwState.pTextureInUse[dwHWStage] = NULL;

            pContext->hwState.celsius.set4 (NV056_SET_TEXGEN_S(dwHWStage),
                                            NV056_SET_TEXGEN_S_V_DISABLE,
                                            NV056_SET_TEXGEN_T_V_DISABLE,
                                            NV056_SET_TEXGEN_R_V_DISABLE,
                                            NV056_SET_TEXGEN_Q_V_DISABLE);

            // control 0
            // explicitly disable aniso because celsius will not automatically
            // disable it when the texture itself is disabled (can cost performance)
            dwControl0 = DRF_DEF(056, _SET_TEXTURE_CONTROL0, _ENABLE, _FALSE) |
                         DRF_DEF(056, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

            pContext->hwState.celsius.set (NV056_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);
        }

        if (pContext->hwState.dwTextureUnitStatus[dwHWStage] != dwTexUnitStatus) {
            pContext->hwState.dwTextureUnitStatus[dwHWStage] = dwTexUnitStatus;
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_TRANSFORM
                                           |  CELSIUS_DIRTY_FVF
                                           |  CELSIUS_DIRTY_TL_MODE;
        }

    }  // for dwHWStage=0...

    // we can't w-buffer if we can't get w from any of the texture units
    if ((dwZEnable==D3DZB_USEW) && (bWSourceFound==FALSE)) {
        DPF("no texture unit available for w divide. w-buffering impossible");
        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
        dwZEnable = D3DZB_TRUE;
    }

    // set dependent dirty state

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_USERTEXCOORDSNEEDED(0) | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))) != dwUserCoordsNeeded) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_USERTEXCOORDSNEEDED(0) | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1));
        pContext->hwState.dwStateFlags |= dwUserCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_WDIVIDE(0) | CELSIUS_FLAG_WDIVIDE(1))) != dwWDivideFlags) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_WDIVIDE(0) | CELSIUS_FLAG_WDIVIDE(1));
        pContext->hwState.dwStateFlags |= dwWDivideFlags;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_TEXTURE_TRANSFORM;
    }

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_WSOURCE(0) | CELSIUS_FLAG_WSOURCE(1))) != dwWSourceFlags) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_WSOURCE(0) | CELSIUS_FLAG_WSOURCE(1));
        pContext->hwState.dwStateFlags |= dwWSourceFlags;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_CONTROL0;
    }

    if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXSTATENEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_TEXSTATENEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? CELSIUS_DIRTY_TRANSFORM : 0;
    }

    if (pContext->hwState.dwTexCoordIndices != dwTexCoordIndices) {
        pContext->hwState.dwTexCoordIndices = dwTexCoordIndices;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    if (dwNumTexCoordsNeeded != pContext->hwState.dwNumTexCoordsNeeded) {
        pContext->hwState.dwNumTexCoordsNeeded = dwNumTexCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }


    if (pContext->hwState.celsius.dwZEnable != dwZEnable) {
        pContext->hwState.celsius.dwZEnable = dwZEnable;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_FVF
                                       |  CELSIUS_DIRTY_TRANSFORM
                                       |  CELSIUS_DIRTY_SPECFOG_COMBINER
                                       |  CELSIUS_DIRTY_CONTROL0
                                       |  CELSIUS_DIRTY_MISC_STATE;
    }

    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE) {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvCelsiusSetFogMode (PNVD3DCONTEXT pContext, DWORD *dwZFogMask)
{
    float fBias, fScale;

    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]);

    cacheFogValues(pContext);

    pContext->hwState.celsius.prep_wait_for_idle_nv10();

    switch (pContext->fogData.dwFogTableMode) {
        case D3DFOG_NONE:   // user-supplied fog (neither table nor vertex)
            fBias = 1.0f;
            fScale = 1.0f;
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);
            break;
        case D3DFOG_LINEAR:
            fBias = 1.0f + pContext->fogData.fFogTableEnd * pContext->fogData.fFogTableLinearScale;
            fScale = -pContext->fogData.fFogTableLinearScale;
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);
            break;
        case D3DFOG_EXP:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * 5.5452f));
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_EXP);
            break;
        case D3DFOG_EXP2:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * (float)sqrt(5.5452f)));
            pContext->hwState.celsius.set (NV056_SET_FOG_MODE, NV056_SET_FOG_MODE_FOG_MODE_EXP2);
            break;
        default:
            DPF ("uh oh. unknown fog mode");
    }

    *dwZFogMask = 0;

    if (pContext->fogData.dwFogTableMode == D3DFOG_NONE) {
        // both table fog and vertex fog are disabled. we default back to regular user fog
        pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);
        // the hardware needs OGL's infinite view vector for user fog (for reasons that escape me)
        if (getDC()->bD3DViewVector) {
            nvglSetNv10CelsiusNoOp (NV_DD_CELSIUS);
            pContext->hwState.celsius.set3f (NV056_SET_EYE_DIRECTION_SW(0), 0.f,0.f,1.f);
            getDC()->bD3DViewVector = FALSE;
        }
    }

    else {
        // we're doing vertex or table fog. on celsius we simply upgrade the former to the
        // latter and treat them both the same way.
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
            // if we're in passthru mode, we have to hack things a bit to still get
            // the use of the HW fog table which is intimately tied to the T&L unit.
            // we use the foggenmode to tell the HW what to use for depth
            nvAssert(pContext->hwState.dwFogSource); // assert that fog source has been set
            if (pContext->hwState.dwFogSource == CHardwareState::FOG_SOURCE_Z) {
                // use z for fog depth
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, 0x01);
                *dwZFogMask = CELSIUS_FLAG_ZFOG;
            }
            else {
                // use w for fog depth
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, 0x02);
                // if we're w-buffering, 1/w will get scaled before it gets to the fog unit.
                // we need to undo the scale by re-applying the same scale here.
                // (we just re-apply, b/c 1/w has also been subsequently inverted)
                if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
                    nvAssert (pContext->pRenderTarget);
                    fScale *= (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                }
            }
        }
        else {
            // not in passthru mode. just do things normally
            if (pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]) {
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL);
            }
            else {
                pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR);
                // Since we're already in eye space, just construct the plane
                pContext->hwState.celsius.set4f (NV056_SET_FOG_PLANE(0), 0.0f, 0.0f, 1.0f, 0.0f);
            }
        }
    }

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
        // in passthru mode, K0, K1, and K2 all get the scale.
        // ambient red gets overloaded with the bias
        pContext->hwState.celsius.set3f (NV056_SET_FOG_PARAMS(0),          fScale, fScale, fScale);
        pContext->hwState.celsius.set3f (NV056_SET_SCENE_AMBIENT_COLOR(0), fBias,  0.0f,   0.0f  );
    }
    else {
        pContext->hwState.celsius.set3f (NV056_SET_FOG_PARAMS(0), fBias, fScale, 0.0f);
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set the fog/specular combiner

HRESULT nvSetCelsiusSpecularFogCombiner (PNVD3DCONTEXT pContext)
{
    DWORD dwControl0, dwControl1;  // HW control words
    DWORD dwZFogMask;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_SPECFOG_COMBINER;

    dwControl0 = 0;

    if (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]) {
        pContext->hwState.celsius.set (NV056_SET_FOG_ENABLE, NV056_SET_FOG_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_FOG_COLOR,  swapRGB(pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]));

        nvCelsiusSetFogMode (pContext, &dwZFogMask);

        // A is fog factor in fog alpha
        dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_SOURCE, _REG_3);
        // A alpha is used for fog - replicate it
        dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _A_ALPHA, _TRUE);

        // B source is (textured diffuse) or (textured diffuse + specular)
        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_C);
        }

        // if the last stage was using addcomplement as its colorop, we need to invert color here
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(pContext->hwState.dwNumActiveCombinerStages - 1)) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _B_INVERSE, _TRUE);
        }

        // C is fog color
        dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _C_SOURCE, _REG_3);

        // D isn't used
        pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    }

    else { // no fog, just output diffuse (+ specular)
        pContext->hwState.celsius.set (NV056_SET_FOG_ENABLE, NV056_SET_FOG_ENABLE_V_FALSE);

        dwZFogMask = 0;

        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_C);
        }

        // if the last stage was using addcomplement as its colorop, we need to invert color here
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTRGB(pContext->hwState.dwNumActiveCombinerStages - 1)) {
            dwControl0 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW0, _D_INVERSE, _TRUE);
        }

        pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);

        pContext->hwState.celsius.prep_wait_for_idle_nv10();
        pContext->hwState.celsius.set (NV056_SET_FOG_MODE,                  NV056_SET_FOG_MODE_FOG_MODE_LINEAR);
        pContext->hwState.celsius.set (NV056_SET_FOG_GEN_MODE,              NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);
    }

    dwControl1 = 0;

    // the final value for alpha is just taken from G
    dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_SOURCE, _REG_C);

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(pContext->hwState.dwNumActiveCombinerStages-1)) {
        // if the last stage produced a dot product, we were supposed to have replicated the result
        // into alpha, but couldn't b/c celsius can't. get it from the color channels now.
        dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _FALSE);
    }
    else {
        // just grab alpha from alpha
        dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _TRUE);
        // if the last stage was using addcomplement as its alphaop, we need to invert alpha here
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_ADDCOMPLEMENTALPHA(pContext->hwState.dwNumActiveCombinerStages-1)) {
            dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _G_INVERSE, _TRUE);
        }
    }

    dwControl1 |= DRF_DEF(056, _SET_COMBINER_SPECULAR_FOG_CW1, _SPECULAR_CLAMP, _TRUE);

    pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, dwControl1);

    //cachec off spec/fog control words
    pContext->hwState.specfog_cw[0] = dwControl0;
    pContext->hwState.specfog_cw[1] = dwControl1;

#ifdef ALPHA_CULL
    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_MISC_STATE;
#endif

    if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_ZFOG) != dwZFogMask) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_ZFOG;
        pContext->hwState.dwStateFlags |= dwZFogMask;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set celsius TL mode (passthrough stuff)

HRESULT nvSetCelsiusTLMode (PNVD3DCONTEXT pContext)
{
    DWORD dwPassthru, dwHWStage;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TL_MODE;

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {
        dwPassthru = DRF_DEF(056, _SET_TLMODE, _PASSTHROUGH, _TRUE);
    }
    else {
        dwPassthru = DRF_DEF(056, _SET_TLMODE, _PASSTHROUGH, _FALSE);
    }

    for (dwHWStage=0; dwHWStage<2; dwHWStage++) {
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WDIVIDE(dwHWStage)) {
            dwPassthru |= (dwHWStage == 0) ?
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_0, _ENABLE) :
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_1, _ENABLE);
        }
        else {
            dwPassthru |= (dwHWStage == 0) ?
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_0, _DISABLE) :
                          DRF_DEF(056, _SET_TLMODE, _W_DIVIDE_1, _DISABLE);
        }
    }

    pContext->hwState.celsius.set (NV056_SET_TLMODE, dwPassthru);

    return (D3D_OK);
}

#if 1

//---------------------------------------------------------------------------

// Check for need / feasibility of texture matrix hack and return values in bNeeded and bFeasible.
// The hack is needed if:
// - we only have a class 056 celsius
// - the broken matrix element is non-negligibly non-zero
// The HW hack if feasible if:
// - this stage uses eyespace coordinates generated by the HW
// - the other texture stage is either disabled or has a user texture with texgen disabled
// - we're not in passthru mode
// The SW workaround is feasible if:
// - texgen is not enabled

void nvTexMatrixHackCheck
(
    PNVD3DCONTEXT pContext,
    DWORD         dwHWStage,
    BOOL          bTexgen,
    D3DVALUE      dvCriticalElement,
    BOOL         *bEnableHWHack,
    BOOL         *bEnableSWHack
)
{
    DWORD dwOtherHWStage, dwOtherTexUnitStatus, dwOtherD3DStage, dwOtherTexgenMode;
    BOOL  bOtherTexgen;

    // assume things are ok unless we find otherwise
    *bEnableHWHack = *bEnableSWHack = FALSE;

    // we only need to worry about this if we have nothing better than a class 056 celsius
    // and the critical element is non-negligible
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS))
        &&
        ((dvCriticalElement > CELSIUS_TEX_MATRIX_HACK_THRESHOLD) ||
         (dvCriticalElement < -CELSIUS_TEX_MATRIX_HACK_THRESHOLD)))
    {
        // a texture matrix workaround is required. can we do it?
        dwOtherHWStage       = dwHWStage ^ 0x1;
        dwOtherTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwOtherHWStage];

        if (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) {
            dwOtherD3DStage   = pContext->hwState.dwTexUnitToTexStageMapping[dwOtherHWStage];
            dwOtherTexgenMode = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) ?
                                D3DTSS_TCI_PASSTHRU:pContext->tssState[dwOtherD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            bOtherTexgen      = (dwOtherTexgenMode != D3DTSS_TCI_PASSTHRU);
        }

        if ((bTexgen)
            &&
            ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_IDLE)
             ||
             (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_DEFAULT)
             ||
             ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) && (!bOtherTexgen)))
            &&
            (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE)))
        {
            // enable the HW-based hack
            *bEnableHWHack = TRUE;
        }
        else if (!bTexgen)
        {
            // enable the SW workaround
            *bEnableSWHack = TRUE;
        }
        else
        {
            // we need it but can't do it
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
        }
    }

}

#else

//---------------------------------------------------------------------------

// check for need / feasibility of texture matrix hack :
// - this stage uses eyespace coordinates generated by the HW
// - the broken matrix element is non-negligibly non-zero
// - the other texture stage is either disabled or has a user texture with texgen disabled
// - we're not in passthru mode

BOOL nvTexMatrixHackEnable (PNVD3DCONTEXT pContext, DWORD dwHWStage, BOOL bTexgen, D3DVALUE dvCriticalElement)
{
    DWORD dwOtherHWStage, dwOtherTexUnitStatus, dwOtherD3DStage, dwOtherTexgenMode;
    BOOL  bOtherTexgen;

    // we only need to worry about this if we have nothing better than a class 056 celsius
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS)) {
        return (FALSE);
    }

    if ((dvCriticalElement > CELSIUS_TEX_MATRIX_HACK_THRESHOLD) ||
        (dvCriticalElement < -CELSIUS_TEX_MATRIX_HACK_THRESHOLD))
    {
        // the texture matrix hack is required. can we actually do it?
        dwOtherHWStage       = dwHWStage ^ 0x1;
        dwOtherTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwOtherHWStage];

        if (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) {
            dwOtherD3DStage   = pContext->hwState.dwTexUnitToTexStageMapping[dwOtherHWStage];
            dwOtherTexgenMode = pContext->tssState[dwOtherD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            bOtherTexgen      = (dwOtherTexgenMode != D3DTSS_TCI_PASSTHRU);
        }

        if ((bTexgen)
            &&
            ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_IDLE)
             ||
             (dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_DEFAULT)
             ||
             ((dwOtherTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) && (!bOtherTexgen)))
            &&
            (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE)))
        {
            // we need it and can do it
            return (TRUE);
        }
        else
        {
            // we need it but can't do it
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            return (FALSE);
        }
    }
    else
    {
        // texture matrix hack isn't required
        return (FALSE);
    }
}

#endif

//---------------------------------------------------------------------------

// set texture transformation matrices

HRESULT nvSetCelsiusTextureTransform (PNVD3DCONTEXT pContext)
{
    CTexture    *pTexture;
    BOOL        bEnable, bXForm, bCubeMap, bTexgen;
    DWORD       dwPassthruCubeMappingMask = 0;
    DWORD       dwTextureMatrixHackMask = 0;
#if (NVARCH >= 0x015)
    BOOL        bWDivideEnable;
#endif
    DWORD       dwOp, dwFlags, dwInCount, dwOutCount, dwTexUnitStatus, dwTexgenMode;
    DWORD       dwHWStage, dwD3DStage, dwMatrixEnable, dwMatrixDisable;
    DWORD       dwMatrixName, dwMatrixType;
    LPD3DMATRIX pMatrix;
#ifdef CELSIUS_TEX_MATRIX_HACK
    D3DVALUE    dvCriticalElement;
    BOOL        bHWHack, bSWHack;
#endif  // CELSIUS_TEX_MATRIX_HACK

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TEXTURE_TRANSFORM;

    for (dwHWStage=0; dwHWStage < 2; dwHWStage++) {

        dwTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwHWStage];

        if (dwTexUnitStatus == CELSIUS_TEXUNITSTATUS_CLIP) {
            // if we're doing clip planes, we've already set up texture transform
            continue;
        }

        if (dwHWStage==0) {
            dwMatrixEnable  = NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE;
            dwMatrixDisable = NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE;
            dwMatrixName    = NV056_SET_TEXTURE_MATRIX0(0);
        }
        else {
            dwMatrixEnable  = NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE;
            dwMatrixDisable = NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE;
            dwMatrixName    = NV056_SET_TEXTURE_MATRIX1(0);
        }

        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage == CELSIUS_UNUSED) {
            bEnable = FALSE;
        }

        else {

            nvAssert (dwTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER);
            dwOp    = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP];

            // Stage state doesn't matter if pixel shaders are on
            nvAssert (dwOp != D3DTOP_DISABLE || pContext->pCurrentPShader);

            dwFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];

            // the number of coordinates to come out of the transformation, INCLUSIVE
            // of the projective coordinate when the D3DTTFF_PROJECTED flag is set.
            // (== the number of matrix columns with non-zero elements)
            dwOutCount = dwFlags & 0xff; // BUGBUG there should be a #define for this. pester MS
            bXForm = (dwOutCount != D3DTTFF_DISABLE);

            pTexture = pContext->hwState.pTextureInUse[dwHWStage];
            bCubeMap = pTexture && pTexture->isCubeMap();

            dwTexgenMode = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            bTexgen = (dwTexgenMode != D3DTSS_TCI_PASSTHRU);

            bWDivideEnable = (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WDIVIDE(dwHWStage)) ? TRUE : FALSE;

            // enable if they requested a transform explicitly or:
            // - cubemapping (requires shift of r into q)
            // - texgen is enabled (accommodate hacky nv15 HW fix for nv10 tex matrix bug)
            // - w divide is disabled in T&L mode (likewise)
            bEnable = bXForm   ||
                      bCubeMap ||
                      bTexgen  ||
                      (!bWDivideEnable && !(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE));

            if (bEnable && (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE))
            {
                bEnable = FALSE;
                if (bXForm || bTexgen) {
                    // we wanted tex transform for something more than just cubemapping. no can do.
                    DPF ("Hardware can't do texture matrix transform in passthrough mode");
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
                }
                if (bCubeMap) {
                    dwPassthruCubeMappingMask |= CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(dwHWStage);
                }
            }
        }


        if (!bEnable) {

            pContext->hwState.celsius.set (NV056_SET_TEXTURE_MATRIX0_ENABLE + dwHWStage * 4, dwMatrixDisable);

        }

        else {

            pContext->hwState.celsius.set (NV056_SET_TEXTURE_MATRIX0_ENABLE + dwHWStage * 4, dwMatrixEnable);

            pMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);

            if (bCubeMap) {

                if (!bXForm) {
                    // no transformation desired by user, but celsius still requires a transformation
                    // to shift the r coordinate into the q position where the HW can access it.
                    // (celsius doesn't really handle 3 coordinates and always ignores the r slot)
                    pContext->hwState.celsius.setTextureTransformMatrixCubeMapIdent (dwMatrixName);
                }

                else {
                    // texture transformation and cubemapping are both enabled.

#ifdef CELSIUS_TEX_MATRIX_HACK
                    nvTexMatrixHackCheck (pContext, dwHWStage, bTexgen, pMatrix->_13, &bHWHack, &bSWHack);

                    if (bHWHack) {
                        DPF ("using tex transform hack #1a");
                        dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXHACK(dwHWStage);
                        pContext->hwState.celsius.setTextureTransformMatrixCubeMapIdent (dwMatrixName);
                    }
                    else if (bSWHack) {
                        DPF ("using SW workaround for broken texture matrix in stage %d", dwHWStage);
                        dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXSWFIX(dwHWStage);
                        pContext->hwState.celsius.setTextureTransformMatrixCubeMapIdent (dwMatrixName);
                    }
                    else
#endif  // CELSIUS_TEX_MATRIX_HACK
                    {
#ifdef DEBUG
                        // some sanity checks:
                        // the transformation should be a 3-coordinate transformation.
                        if (dwOutCount != D3DTTFF_COUNT3) {
                            DPF ("ugh. cubemap texture tranformation matrix is not a 3-D transformation");
                        }
                        // the transform should not include any shifting. translating 3 coordinates
                        // requires four rows in the matrix, but celsius only looks at three rows.
                        if ((pMatrix->_41) || (pMatrix->_42) || (pMatrix->_43)) {
                            DPF ("blurg. cubemap texture tranformation matrix is attempting translation");
                        }
                        // finally, the transform cannot include a projection because projecting
                        // requires q which is unavailable because r will be stored in its place.
                        // projecting cubemap coordinates really just means scaling a vector which
                        // is meaningless anyhow.
                        if (dwFlags & D3DTTFF_PROJECTED) {
                            DPF ("ack. can't do projective cubemapping, but who cares");
                        }
#endif
                        // set the matrix, copying column 3 to column 4, thereby moving r to the q slot.
                        pContext->hwState.celsius.setTextureTransformMatrixCubeMap (dwMatrixName,pMatrix);
                    }

                }

            }  // cubemap

            else if (bXForm) {

                // the number of coordinates incoming from the FVF vertex data or texgen
                // (== the number of matrix rows with non-zero elements)
                // (actually there can be dwInCount+1 rows with non-zero elements b/c D3D assumes
                // that a q==1 is automatially postpended to the coordinates they give you)
                DWORD dwTexGen  = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
                DWORD dwTCIndex = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
                DWORD dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                if (dwTexGen) {
                    dwInCount = 3;
                }
                else {
                    // if index invalid, just use 0,0
                    dwInCount = (pContext->pCurrentVShader->bVAExists(dwVAIndex)) ?
                                (pContext->pCurrentVShader->getVASize(dwVAIndex)) :
                                2*sizeof(DWORD);
                    dwInCount >>= 2;
                }

                // calculate an arbitrary identifier
                dwMatrixType = ((dwFlags & D3DTTFF_PROJECTED) ? 2 : 1) * dwInCount;

#ifdef CELSIUS_TEX_MATRIX_HACK
                switch (dwMatrixType) {
                    case 2:
                    case 3:
                        dvCriticalElement = 0.0f;
                        break;
                    case 4:
                    case 6:
                        dvCriticalElement = pMatrix->_13;
                        break;
                }

                nvTexMatrixHackCheck (pContext, dwHWStage, bTexgen, dvCriticalElement, &bHWHack, &bSWHack);

                if (bHWHack) {
                    DPF ("using tex transform hack #1b");
                    dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXHACK(dwHWStage);
                    //swap R/Q columns so we divide by the right thing later.
                    D3DMATRIX mTemp;
                    mTemp._11 = mTemp._22 = mTemp._34 = mTemp._43 = 1;
                    mTemp._12 = mTemp._13 = mTemp._14 = mTemp._21 = mTemp._23 = mTemp._24 = 0;
                    mTemp._31 = mTemp._32 = mTemp._33 = mTemp._41 = mTemp._42 = mTemp._44 = 0;
                    pContext->hwState.celsius.setMatrixTransposed (dwMatrixName, &mTemp);
                    //nvglSetNv10CelsiusTextureMatrixEnable (NV_DD_CELSIUS, dwHWStage, dwMatrixDisable);
                }
                else if (bSWHack) {
                    DPF ("using SW workaround for broken texture matrix in stage %d", dwHWStage);
                    dwTextureMatrixHackMask |= CELSIUS_FLAG_TEXMATRIXSWFIX(dwHWStage);
                    pContext->hwState.celsius.setMatrixIdent (dwMatrixName);
                }
                else
#endif  // CELSIUS_TEX_MATRIX_HACK

                {
#if defined(CELSIUS_TEX_MATRIX_HACK) && defined(DEBUG)
                    if ((!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS))) &&
                        (fabs(dvCriticalElement) > CELSIUS_TEX_MATRIX_HACK_THRESHOLD)) {
                        DPF ("nvSetCelsiusTextureTransform: Critical element is non-zero. Undefined result.");
                    }
#endif

                    switch (dwMatrixType) {

                        case 2:

                            // 2 incoming texture coordinates, unprojected
                            // dwOutCount for an unprojected texture should be 2 : (s,t)
                            nvAssert (dwOutCount == 2);
                            // expand the matrix and override the last column with [0 0 0 1]'
                            pContext->hwState.celsius.setTextureTransformMatrixTypeA (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_13 != 0.0f) || (pMatrix->_23 != 0.0f) || (pMatrix->_33 != 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is sketchy. driver overwrote values in last column b/c it was");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"given a projective texture matrix when projection was disabled");
                            }
#endif
                            break;

                        case 3:

                            // 3 incoming texture coordinates, unprojected
                            // dwOutCount for an unprojected texture should be 2 : (s,t)
                            nvAssert (dwOutCount == 2);
                            // override the last column with [0 0 0 1]'
                            pContext->hwState.celsius.setTextureTransformMatrixTypeB (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_14 != 0.0f) || (pMatrix->_24 != 0.0f) ||
                                (pMatrix->_34 != 0.0f) || (pMatrix->_44 != 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is sketchy. driver overwrote values in last column b/c it was");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"given a projective texture matrix when projection was disabled");
                            }
#endif
                            break;

                        case 4:

                            // 2 incoming texture coordinates, projected
                            // dwOutCount for a projected texture should be 3 : (s,t,q)
                            nvAssert (dwOutCount == 3);
                            // expand the matrix but don't override the last column
                            pContext->hwState.celsius.setTextureTransformMatrixTypeC (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_13 == 0.0f) && (pMatrix->_23 == 0.0f) && (pMatrix->_33 == 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is REALLY sketchy. got a projective texture transform matrix");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"with no non-zero values in the last column");
                            }
#endif
                            break;

                        case 6:

                            // 3 incoming texture coordinates, projected
                            // dwOutCount for a projected texture should be 3 : (s,t,q)
                            nvAssert (dwOutCount == 3);
                            // move col 3 to col 4
                            pContext->hwState.celsius.setTextureTransformMatrixTypeD (dwMatrixName, pMatrix);
#ifdef DEBUG
                            if ((pMatrix->_13 == 0.0f) && (pMatrix->_23 == 0.0f) &&
                                (pMatrix->_33 == 0.0f) && (pMatrix->_43 == 0.0f)) {
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"d3d is REALLY sketchy. got a projective texture transform matrix");
                                DPF_LEVEL(NVDBG_LEVEL_INFO,"with zeros in the whole 3rd column");
                            }
#endif
                            break;

                        default:

                            DPF ("unknown combination of projectivism and number of texture coords");
                            dbgD3DError();
                            break;

                    }  // switch

                }  // else ! tex matrix hack

            }  // bXForm

            else {  // !bcubemap && !bXForm

                // we don't have a cubemap and haven't enabled tex xform explicitly, but we're
                // using texgen or we've disabled w divide. due to some hacky HW fixes on nv15,
                // both of these require that we enable the texture transform.
                nvAssert (bTexgen || !bWDivideEnable);
                pContext->hwState.celsius.setMatrixIdent (dwMatrixName);

            }

        }  // else enable

    }  // for dwHWStage=0...

    if ((pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1))) != dwPassthruCubeMappingMask) {
        pContext->hwState.dwStateFlags &= ~(CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1));
        pContext->hwState.dwStateFlags |= dwPassthruCubeMappingMask;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
    }

    // if we now need a tex matrix hack or used to need it and now don't, re-program some other state
    // that has all sorts of hack-specific dependencies for which the dirty bits won't normally get set
    if ((dwTextureMatrixHackMask) || (pContext->hwState.dwStateFlags & CELSIUS_MASK_TEXMATRIXHACKS)) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_MASK_TEXMATRIXHACKS;
        pContext->hwState.dwStateFlags |= dwTextureMatrixHackMask;
        pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_FVF);
    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set celsius class specular parameters

HRESULT nvCelsiusSetSpecularParams (PNVD3DCONTEXT pContext)
{
    float L, M, N, L1, M1, N1, power;

    nvAssert ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
              (pContext->hwState.dwStateFlags & CELSIUS_FLAG_COMBINERSNEEDSPECULAR));

    power = pContext->Material.power;
    explut (power, &L, &M);
    N = 1.f+L-M;
    explut (0.5f*power, &L1, &M1);
    N1 = 1.f+L1-M1;
    pContext->hwState.celsius.set3f (NV056_SET_SPECULAR_PARAMS(0),L, M, N);
    pContext->hwState.celsius.set3f (NV056_SET_SPECULAR_PARAMS(3),L1,M1,N1);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set diffuse, specular, and ambient colors for a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data
//      - dwCmArg   = color material flags

HRESULT nvCelsiusDumpLightColors (PNVD3DCONTEXT pContext,
                                  DWORD dwLightID, LPD3DLIGHT7 pLight7,
                                  DWORD dwCmArg, BOOL bSpecularNeeded)
{
    D3DVALUE dvAmbientR, dvAmbientG, dvAmbientB;
    D3DVALUE dvDiffuseR, dvDiffuseG, dvDiffuseB;
    D3DVALUE dvSpecularR, dvSpecularG, dvSpecularB;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    dvAmbientR = pLight7->dcvAmbient.dvR;
    dvAmbientG = pLight7->dcvAmbient.dvG;
    dvAmbientB = pLight7->dcvAmbient.dvB;
    if (!(dwCmArg & NV056_SET_COLOR_MATERIAL_V_AMBIENT)) {
        // follow material ambient color
        dvAmbientR *= pContext->Material.dcvAmbient.dvR;
        dvAmbientG *= pContext->Material.dcvAmbient.dvG;
        dvAmbientB *= pContext->Material.dcvAmbient.dvB;
    }

    dvDiffuseR = pLight7->dcvDiffuse.dvR;
    dvDiffuseG = pLight7->dcvDiffuse.dvG;
    dvDiffuseB = pLight7->dcvDiffuse.dvB;
    if (!(dwCmArg & NV056_SET_COLOR_MATERIAL_V_DIFFUSE)) {
        // follow material diffuse color
        dvDiffuseR *= pContext->Material.dcvDiffuse.dvR;
        dvDiffuseG *= pContext->Material.dcvDiffuse.dvG;
        dvDiffuseB *= pContext->Material.dcvDiffuse.dvB;
    }

    if (bSpecularNeeded) {
        dvSpecularR = pLight7->dcvSpecular.dvR;
        dvSpecularG = pLight7->dcvSpecular.dvG;
        dvSpecularB = pLight7->dcvSpecular.dvB;
        if (!(dwCmArg & NV056_SET_COLOR_MATERIAL_V_SPECULAR)) {
            // follow material specular color
            dvSpecularR *= pContext->Material.dcvSpecular.dvR;
            dvSpecularG *= pContext->Material.dcvSpecular.dvG;
            dvSpecularB *= pContext->Material.dcvSpecular.dvB;
        }
    }
    else {
        dvSpecularR = dvSpecularG = dvSpecularB = 0.0f;
    }

    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_AMBIENT_COLOR(dwLightID,0), dvAmbientR, dvAmbientG, dvAmbientB);  // ambient
    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_DIFFUSE_COLOR(dwLightID,0), dvDiffuseR, dvDiffuseG, dvDiffuseB);  // diffuse
    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_SPECULAR_COLOR(dwLightID,0),dvSpecularR,dvSpecularG,dvSpecularB); // specular

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set position and attenuation of a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data

HRESULT nvCelsiusDumpLocalLightData (PNVD3DCONTEXT pContext, int dwLightID, LPD3DLIGHT7 pLight7)
{
    D3DVECTOR pos0, pos1;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    // We don't normalize the position
    pos0 = pLight7->dvPosition;
    XformBy4x3 (&pos1, &pos0, 1.f, &(pContext->xfmView));

#ifdef CELSIUS_TEX_MATRIX_HACK
    DWORD dwHackMask = pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1));
    // the hack can't be enabled for both stages simultaneously
    nvAssert (dwHackMask != (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1)));

    if (dwHackMask) {
        DWORD dwHWStage  = (dwHackMask & CELSIUS_FLAG_TEXMATRIXHACK(0)) ? 0 : 1;
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
        LPD3DMATRIX pTexMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
        XformBy4x3 (&pos0, &pos1, 1.f, pTexMatrix);
        pos1 = pos0;
    }
#endif  // CELSIUS_TEX_MATRIX_HACK

    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_LOCAL_POSITION(dwLightID,0), pos1.dvX, pos1.dvY, pos1.dvZ);

    if ((*(DWORD *)(&(pLight7->dvAttenuation0)) == 0) &&
        (*(DWORD *)(&(pLight7->dvAttenuation1)) == 0) &&
        (*(DWORD *)(&(pLight7->dvAttenuation2)) == 0)) {
        DPF ("d3d gave us a divide by 0 error b/c all attenuations are 0. nice.");
        pLight7->dvAttenuation0 = 1.f;
    }

    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_LOCAL_ATTENUATION(dwLightID,0),
                                  pLight7->dvAttenuation0,
                                  pLight7->dvAttenuation1,
                                  pLight7->dvAttenuation2);

#ifdef STATE_CULL
    // attenuation stomps on infinite half-vector and vice-versa
    pContext->hwState.celsius.valid [NV056_SET_LIGHT_INFINITE_HALF_VECTOR(dwLightID,0) >> 2] = 0;
#endif

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// D3D allows you to assign either of the two vertex colors (diffuse / specular)
// to ANY of the material colors, eg. you can stuff vertex diffuse into material
// emissive. Celsius can't do all these permutations, so we implement only those
// that we can.

DWORD getCelsiusColorMaterialFlags (PNVD3DCONTEXT pContext)
{
    DWORD dwArgs;

    dwArgs = NV056_SET_COLOR_MATERIAL_V_DISABLED;

    // if COLORVERTEX isn't set just return now
    if (!pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]) {
        return (dwArgs);
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            // inherit material ambient from vertex diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_AMBIENT;
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                DPF ("Celsius can't map vertex specular into material ambient");
            }
            break;
        default:
            DPF ("unknown AMBIENTMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            // inherit material diffuse from vertex diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_DIFFUSE;
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                DPF ("Celsius can't map vertex specular into material diffuse");
            }
            break;
        default:
            DPF ("unknown DIFFUSEMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                    // if vertex specular is valid, enabling NV056_SET_COLOR_MATERIAL_SPECULAR
                    // will make the HW pull material specular from the vertex specular,
                    // NOT vertex diffuse as desired.
                    DPF ("Celsius can't map vertex diffuse into material specular when vertex specular is valid");
                }
                else {
                    // in the absence of a vertex specular, NV056_SET_COLOR_MATERIAL_SPECULAR
                    // will make the HW pull material specular from the vertex diffuse
                    dwArgs |= NV056_SET_COLOR_MATERIAL_V_SPECULAR;
                }
            }
            break;
        case D3DMCS_COLOR2:  // specular
            // inherit material specular from vertex specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_SPECULAR;
            }
            break;
        default:
            DPF ("unknown SPECULARMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            // inherit material emissive from vertex diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= NV056_SET_COLOR_MATERIAL_V_EMISSION;
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                DPF ("Celsius can't map vertex specular into material emissive");
            }
            break;
        default:
            DPF ("unknown EMISSIVEMATERIALSOURCE");
            break;
    }

    return (dwArgs);
}

//---------------------------------------------------------------------------

// set lighting state

HRESULT nvSetCelsiusLights (PNVD3DCONTEXT pContext)
{
    DWORD         dwColorMaterialArgs;
    DWORD         dwControl = 0;
    DWORD         dwLightNum;
    DWORD         dwMask = 0;
    D3DCOLORVALUE dcvAmbient, dcvEmissive;
    D3DVECTOR     eyeDirection;
    D3DVECTOR     dir, hv, tmp;          // light directions
    pnvLight      pLight;
    LPD3DLIGHT7   pLight7;
#ifdef CELSIUS_TEX_MATRIX_HACK
    DWORD         dwHackMask, dwHWStage, dwD3DStage;
    LPD3DMATRIX   pTexMatrix;
#endif  // CELSIUS_TEX_MATRIX_HACK
    BOOL          bSpecularNeeded;
    DWORD         dwInvMVNeeded;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_LIGHTS;

    // specular enable
    bSpecularNeeded = ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
                       (pContext->hwState.dwStateFlags & CELSIUS_FLAG_COMBINERSNEEDSPECULAR)) ? TRUE : FALSE;
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ENABLE, DRF_NUM(056, _SET_SPECULAR_ENABLE, _V, bSpecularNeeded));


    // disable hardware lighting if app has disabled it or if we're in passthrough mode
    // (yes, stupid apps will try to enable lighting without giving us normals, etc...)
    if (!GET_LIGHTING_STATE(pContext) || (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE)) {

        // disable lighting
        pContext->hwState.celsius.set (NV056_SET_LIGHTING_ENABLE, NV056_SET_LIGHTING_ENABLE_V_FALSE);

        dwInvMVNeeded = 0;

        // lighting control
        dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE) |
                      DRF_DEF(056, _SET_LIGHT_CONTROL, _ATTENUATION_MODE, _INVERT));

        if (bSpecularNeeded) {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE) |  // don't force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _TRUE));    // get specular from user input
        }
        else {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _FALSE) | // force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _FALSE));   // doesn't actually matter where we get it from
        }
        pContext->hwState.celsius.set (NV056_SET_LIGHT_CONTROL, dwControl);

    }

    else {

        // we shouldn't be in passthru mode if we're really going to do lighting
        // (moreover we can't be, b/c we won't have calculated xfmInvModelView which
        // is needed for spot lights)
        nvAssert (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE));

        // enable lighting
        pContext->hwState.celsius.set (NV056_SET_LIGHTING_ENABLE, NV056_SET_LIGHTING_ENABLE_V_TRUE);

        dwInvMVNeeded = CELSIUS_FLAG_LIGHTINGNEEDSINVMV;

        // lighting control
        dwControl |= DRF_DEF(056, _SET_LIGHT_CONTROL, _ATTENUATION_MODE, _INVERT);

        // use local viewer only if we really need to, since it's slow
        if ((pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER]) &&
            (pContext->lighting.pActiveLights != NULL) &&
            (bSpecularNeeded)) {
            dwControl |= DRF_DEF(056, _SET_LIGHT_CONTROL, _LOCALEYE, _TRUE);
        }
        else {
            dwControl |= DRF_DEF(056, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE);
            // if the hardware is currently set up to use OGL's infinite
            // view vector, re-program D3D's backward view vector
            if (!getDC()->bD3DViewVector) {
                nvglSetNv10CelsiusNoOp (NV_DD_CELSIUS);
                pContext->hwState.celsius.set3f (NV056_SET_EYE_DIRECTION_SW(0), 0.f,0.f,-1.f);
                getDC()->bD3DViewVector = TRUE;
            }
        }

        // set up specular
        if (bSpecularNeeded) {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE) |  // don't force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _FALSE));   // get specular from T&L
            nvCelsiusSetSpecularParams (pContext);
        }
        else {
            dwControl |= (DRF_DEF(056, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _FALSE) |  // force specular to 0
                          DRF_DEF(056, _SET_LIGHT_CONTROL, _SECONDARY_COLOR_EN, _FALSE));    // doesn't actually matter where we get it from
        }

        pContext->hwState.celsius.set (NV056_SET_LIGHT_CONTROL, dwControl);

        // material properties
        dwColorMaterialArgs = getCelsiusColorMaterialFlags (pContext);

        // We need to handle each of these combinations separately, because the hardware is a bit weird in some
        // ways.  First, Celsius can't do AMBIENT and EMISSION simultaneously--so we factor the emission component
        // into ambient by adding 1.  Second, material emission doesn't seem to work when AMBIENT isn't set, so we
        // again add that component into ambient.  Last, the hardware doesn't have separate controls for material
        // ambient and scene ambient, so we fold both of those into the global ambient when necessary.
        if ((dwColorMaterialArgs & NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT) == NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT) {
            dwColorMaterialArgs &= ~NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT;
            dwColorMaterialArgs |= NV056_SET_COLOR_MATERIAL_V_AMBIENT;
            dcvAmbient.dvR = pContext->lighting.dcvAmbient.dvR + 1.0f;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG + 1.0f;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB + 1.0f;
            dcvEmissive.dvR = 0.0f;
            dcvEmissive.dvG = 0.0f;
            dcvEmissive.dvB = 0.0f;
        }
        else if ((dwColorMaterialArgs & NV056_SET_COLOR_MATERIAL_V_AMBIENT) == NV056_SET_COLOR_MATERIAL_V_AMBIENT) {
            dcvAmbient.dvR  = pContext->lighting.dcvAmbient.dvR;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB;
            dcvEmissive.dvR = pContext->Material.dcvEmissive.dvR;
            dcvEmissive.dvG = pContext->Material.dcvEmissive.dvG;
            dcvEmissive.dvB = pContext->Material.dcvEmissive.dvB;
        }
        else if ((dwColorMaterialArgs & NV056_SET_COLOR_MATERIAL_V_EMISSION) == NV056_SET_COLOR_MATERIAL_V_EMISSION) {
            dcvAmbient.dvR = pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB;
            dcvEmissive.dvR = 0.0f;
            dcvEmissive.dvG = 0.0f;
            dcvEmissive.dvB = 0.0f;
        }
        else {
            dcvAmbient.dvR = pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR + pContext->Material.dcvEmissive.dvR;
            dcvAmbient.dvG = pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG + pContext->Material.dcvEmissive.dvG;
            dcvAmbient.dvB = pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB + pContext->Material.dcvEmissive.dvB;
            dcvEmissive.dvR = 0.0f;
            dcvEmissive.dvG = 0.0f;
            dcvEmissive.dvB = 0.0f;
        }

        pContext->hwState.celsius.set (NV056_SET_COLOR_MATERIAL, dwColorMaterialArgs);

        pContext->hwState.celsius.set3f (NV056_SET_SCENE_AMBIENT_COLOR(0), dcvAmbient.dvR,  dcvAmbient.dvG,  dcvAmbient.dvB);
        pContext->hwState.celsius.set3f (NV056_SET_MATERIAL_EMISSION(0),   dcvEmissive.dvR, dcvEmissive.dvG, dcvEmissive.dvB);

        pContext->hwState.celsius.setf  (NV056_SET_MATERIAL_ALPHA,         pContext->Material.diffuse.a);

        // Set the eye position and direction
        eyeDirection = vectorZero;
        eyeDirection.dvZ = -1.0f;

    #ifdef CELSIUS_TEX_MATRIX_HACK
        dwHackMask = pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1));
        // the hack can't be enabled for both stages simultaneously
        nvAssert (dwHackMask != (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1)));

        if (dwHackMask) {
            dwHWStage  = (dwHackMask & CELSIUS_FLAG_TEXMATRIXHACK(0)) ? 0 : 1;
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            pTexMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
            XformBy4x3 (&tmp, &eyeDirection, 0.f, pTexMatrix);
            NormalizeVector3 (&tmp);
            eyeDirection = tmp;
        }
    #endif  // CELSIUS_TEX_MATRIX_HACK

        // Download transform and lighting methods. Pack lights and send them

        dwMask = 0;
        dwLightNum = 0;

        for (pLight=pContext->lighting.pActiveLights; pLight!=NULL; pLight=pLight->pNext) {

            if (dwLightNum == 8) break; // too many

            pLight7 = &(pLight->Light7);
            dbgDisplayLight (pLight7);

            switch (pLight7->dltType) {

                case D3DLIGHT_POINT:
                    dwMask |= NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL << (dwLightNum << 1);

                    nvCelsiusDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs, bSpecularNeeded);
                    pContext->hwState.celsius.setf (NV056_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvCelsiusDumpLocalLightData (pContext, dwLightNum, pLight7);

                    break;

                case D3DLIGHT_SPOT:
                    dwMask |= NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT << (dwLightNum << 1);

                    nvCelsiusDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs, bSpecularNeeded);
                    pContext->hwState.celsius.setf (NV056_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvCelsiusDumpLocalLightData (pContext, dwLightNum, pLight7);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

    #ifdef CELSIUS_TEX_MATRIX_HACK
                    if (dwHackMask) {
                        XformBy4x3 (&tmp, &dir, 0.f, pTexMatrix);
                        NormalizeVector3 (&tmp);
                        dir = tmp;
                    }
    #endif  // CELSIUS_TEX_MATRIX_HACK

                    ScaleVector3 (&dir, &dir, pLight->dvScale);
                    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_SPOT_FALLOFF(dwLightNum,0),
                                                  pLight->falloffParams.L,
                                                  pLight->falloffParams.M,
                                                  pLight->falloffParams.N);
                    pContext->hwState.celsius.set4f (NV056_SET_LIGHT_SPOT_DIRECTION(dwLightNum,0),
                                                  dir.dvX, dir.dvY, dir.dvZ, pLight->dvW);

                    break;

                case D3DLIGHT_DIRECTIONAL:
                    dwMask |= NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE << (dwLightNum << 1);

                    nvCelsiusDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs, bSpecularNeeded);
                    pContext->hwState.celsius.setf (NV056_SET_LIGHT_LOCAL_RANGE(dwLightNum), 1e30f);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

    #ifdef CELSIUS_TEX_MATRIX_HACK
                    if (dwHackMask) {
                        XformBy4x3 (&tmp, &dir, 0.f, pTexMatrix);
                        NormalizeVector3 (&tmp);
                        dir = tmp;
                    }
    #endif  // CELSIUS_TEX_MATRIX_HACK

                    AddVectors3 (&hv, &dir, &eyeDirection);
                    NormalizeVector3 (&hv);
                    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_INFINITE_HALF_VECTOR(dwLightNum,0), hv.dvX, hv.dvY, hv.dvZ);
                    pContext->hwState.celsius.set3f (NV056_SET_LIGHT_INFINITE_DIRECTION(dwLightNum,0),   dir.dvX, dir.dvY, dir.dvZ);

#ifdef STATE_CULL
                    // infinite half-vector stomps on attenuation and vice-versa
                    pContext->hwState.celsius.valid [NV056_SET_LIGHT_LOCAL_ATTENUATION(dwLightNum,0) >> 2] = 0;
#endif

                    break;

                default:
                    DPF ("unknown light type in nvSetCelsiusLights");
                    dbgD3DError();
                    break;

            } // switch

            dwLightNum++;

        } // for all lights

        // Tell HW which lights are active
        pContext->hwState.celsius.set (NV056_SET_LIGHT_ENABLE_MASK, dwMask);

    }

    pContext->hwState.SuperTri.setNumLights(dwLightNum);

    if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_LIGHTINGNEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_LIGHTINGNEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? CELSIUS_DIRTY_TRANSFORM : 0;
    }

    // disable lights after setting them up (i.e minimum impact)
#ifdef NV_NULL_LIGHTS_DRIVER
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ENABLE, DRF_NUM(056, _SET_SPECULAR_ENABLE, _V, FALSE));
    pContext->hwState.celsius.set (NV056_SET_LIGHTING_ENABLE, NV056_SET_LIGHTING_ENABLE_V_FALSE);
#endif

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set geometric transformation matrices

HRESULT nvSetCelsiusTransform (PNVD3DCONTEXT pContext)
{
    D3DMATRIX        mMV0, mMV1, mCTM, mInvMV, mTemp;
    DWORD            dwClipH, dwClipV;
    float            fm11, fm22, fm33, fm41, fm42, fm43, fm44;
    float            fxTrans, fyTrans;
    D3DVALUE         dvClip0, dvClip1;
    pSurfaceViewport pViewport;
#ifdef CELSIUS_TEX_MATRIX_HACK
    LPD3DMATRIX      pTexMatrix;
    D3DMATRIX        mTexMatrixInv;
    DWORD            dwHackMask;
#endif

    if (pContext->pZetaBuffer && !pContext->dwEarlyCopyStrategy)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      != D3DZB_TRUE)
             || (pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] != TRUE))
            {
                pNvObj->tagCTZE();
            }
        }
    }

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_TRANSFORM;

    pViewport = &(pContext->surfaceViewport);

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) {

        // set up the model view for passthru

        if ((pContext->hwState.celsius.dwZEnable != D3DZB_TRUE) &&
            (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_ZFOG))) {
            // we have no need for Z. squash it to zero to eliminates the chance
            // of clipping away bogus z's that we see in apps like 3d flipcube
            mPassthruModelViewMatrix._31 = 0.0;
            mPassthruModelViewMatrix._32 = 0.0f;
        }
        else {
            if (getDC()->nvD3DRegistryData.regfZBias) {
                mPassthruModelViewMatrix._31 = pContext->hwState.dvZScale / (1.f + getDC()->nvD3DRegistryData.regfZBias);
                mPassthruModelViewMatrix._32 = getDC()->nvD3DRegistryData.regfZBias * mPassthruModelViewMatrix._31;
            }
            else {
                mPassthruModelViewMatrix._31 = pContext->hwState.dvZScale;
                mPassthruModelViewMatrix._32 = 0.0f;
            }
        }

        if ( ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE)
             &&
             ( ((pContext->hwState.dwTextureUnitStatus[0] == CELSIUS_TEXUNITSTATUS_IDLE) &&
                (pContext->hwState.dwTextureUnitStatus[1] == CELSIUS_TEXUNITSTATUS_IDLE))
               ||
               (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] == FALSE)
             )
           )
        {
            mPassthruModelViewMatrix._41 = 0.0f;
        }

        else {

            if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
                // we are doing w-buffering
                mPassthruModelViewMatrix._41 = pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale;
            }

            else  {
                mPassthruModelViewMatrix._41 = 1.0f;

                // be sensitive to CT
                if (pContext->pZetaBuffer) {
                    CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
                    if (pNvObj->hasCTEnabled()) {
                        if (pNvObj->isCTFront()) {
                            mPassthruModelViewMatrix._32  =  0.0f;
                            mPassthruModelViewMatrix._31 *=  0.5f;
                        }
                        else {
                            mPassthruModelViewMatrix._32  =  mPassthruModelViewMatrix._31;
                            mPassthruModelViewMatrix._31 *= -0.5f;
                        }
                    }  // CT enabled
                }  // pZetaBuffer

            }  // !wbuffering

        }  // ! squashing w

        // apply AA scales
        if (pContext->aa.isEnabled()) {
            mPassthruModelViewMatrix._11 = pContext->aa.fWidthAmplifier;
            mPassthruModelViewMatrix._21 = pContext->aa.fHeightAmplifier;
            // The best sample pattern in AA mode is for the samples to be centered over
            // the original sample.  Without the following correction, the new samples would
            // be down and to the right of the old sample.  Here, we offset the samples by 
            // a small amount such that the new samples are fairly well centered over the old
            // sample
            mPassthruModelViewMatrix._12 = CELSIUS_BORDER + 0.5 - 0.5f/pContext->aa.fWidthAmplifier;
            mPassthruModelViewMatrix._22 = CELSIUS_BORDER + 0.5 - 0.5f/pContext->aa.fHeightAmplifier;
        }
        else {
            mPassthruModelViewMatrix._11 = 1.0f;
            mPassthruModelViewMatrix._21 = 1.0f;
            mPassthruModelViewMatrix._12 = CELSIUS_BORDER;
            mPassthruModelViewMatrix._22 = CELSIUS_BORDER;
        }

#ifdef NV_NULL_FILL_DRIVER
        mPassthruModelViewMatrix._11 = 0.0f;
        mPassthruModelViewMatrix._21 = 0.0f;
#endif

        // this uses the 2nd matrix (normally used for skinning)
        pContext->hwState.celsius.setMatrixTransposed (NV056_SET_MODEL_VIEW_MATRIX1(0), &mPassthruModelViewMatrix);

        // set z clipping extents
        // if we're w-buffering in passthru mode, do the best we can to disable the HW's inevitable
        // z clipping because dumb apps may give us bad z's thinking they're unneeded.
        // otherwise, just clip z to the real range of the z-buffer
        dvClip0 = 0.0f;
        dvClip1 = (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) ?
                  CELSIUS_Z_SCALE24 :
                  pContext->hwState.dvZScale;

    }

    else {  // !FVF_TRANSFORMED

        // apply AA scales
        float fx = 1.0f;
        float fy = 1.0f;
        float fdx = 0.0f;
        float fdy = 0.0f;
        if (pContext->aa.isEnabled()) {
            fx = pContext->aa.fWidthAmplifier;
            fy = pContext->aa.fHeightAmplifier;
            fdx = 0.5 - 0.5f/pContext->aa.fWidthAmplifier;
            fdy = 0.5 - 0.5f/pContext->aa.fHeightAmplifier;
        }

        // process viewport dependencies

        fxTrans = (float)(fx * pViewport->clipHorizontal.wX) + CELSIUS_BORDER + fdx;
        fyTrans = (float)(fy * pViewport->clipVertical.wY) + CELSIUS_BORDER + fdy;

        pContext->hwState.celsius.set4f (NV056_SET_VIEWPORT_OFFSET(0), fxTrans, fyTrans, 0.0f, 0.0f);

        // this is based on clipX = -1.0, clipY = 1.0

        fm11 = 0.5f * fx * (float)(pViewport->clipHorizontal.wWidth);
        fm41 = fm11;

        fm22 = -0.5f * fy * (float)(pViewport->clipVertical.wHeight);
        fm42 = -fm22;

        if (pContext->pZetaBuffer && pContext->pZetaBuffer->getWrapper()->hasCTEnabled()) {
            if (pContext->pZetaBuffer->getWrapper()->isCTFront()) {
                // z=0 => z_min/2    z=1 => z_max/2
                fm33 = 0.5f * (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
                fm43 = 0.5f * pContext->surfaceViewport.dvMinZ;
            }
            else {
                // z=0 => 1.0-z_min/2    z=1 => 1.0-z_max/2
                fm33 = -0.5f * (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
                fm43 = -0.5f * pContext->surfaceViewport.dvMinZ + 1.0f;
            }
        }
        else {
            // z=0 => z_min    z=1 => z_max
            fm33 = pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ;
            fm43 = pContext->surfaceViewport.dvMinZ;
        }

        if( fm33 != 0.f ) {
            fm33 *= pContext->hwState.dvZScale;
            fm43 *= pContext->hwState.dvZScale;

            dvClip0 = fm43;         // 0*fm33 + fm43
            dvClip1 = fm33 + fm43;  // 1*fm33 + fm43
        }
        else {
            // MinZ and MaxZ are equal. It appears that the Z clip planes are not
            // inclusive. If dvClip0 == dvClip1 then primtivies are discarded. We should
            // not have Z clipping anyway (the Z transform has collapsed), so just get
            // the z clip planes out of the way.

            dvClip1 = pContext->hwState.dvZScale;
            dvClip0 = 0.f;

            // The Z clip planes can't always be moved out of the way, so muck with the matrix.
            // BUGBUG - this has been tuned to work with the Quake3 sky (w/ OGL wrapper), but
            // this might not work for all apps.
            float fDeltaZ = 0.0000001f;

            if( fm43 > 1.f - fDeltaZ ) {
                fm43 = pContext->hwState.dvZScale * (1.f - fDeltaZ);
            }
            else if( fm43 < fDeltaZ ) {
                fm43 = pContext->hwState.dvZScale * fDeltaZ;
            }
            else {
                fm43 *= pContext->hwState.dvZScale;
            }
        }

        if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
            // we are doing w-buffering  - scale w to optimize use of buffer
            fm44 = pContext->hwState.dvZScale * pContext->surfaceViewport.dvInvWFar;
            // scale x, y, and z similarly to negate the effect of dividing through by a scaled w
            fm11 *= fm44;  fm22 *= fm44;  fm33 *= fm44;
            fm41 *= fm44;  fm42 *= fm44;  fm43 *= fm44;
        }
        else {
            fm44 = 1.0f;
        }

#ifdef NV_NULL_FILL_DRIVER
        fm11 = 0.0f;
        fm22 = 0.0f;
#endif

        mViewportMatrix._11 = fm11;
        mViewportMatrix._22 = fm22;
        mViewportMatrix._33 = fm33;
        mViewportMatrix._41 = fm41;
        mViewportMatrix._42 = fm42;
        mViewportMatrix._43 = fm43;
        mViewportMatrix._44 = fm44;

        // set the 3 Cheops matrices

        // Cheops modelview = D3D world * D3D view
        MatrixProduct4x4 (&mMV0, &(pContext->xfmWorld[0]), &(pContext->xfmView));

#ifdef CELSIUS_TEX_MATRIX_HACK
        dwHackMask = pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1));
        // the hack can't be enabled for both stages simultaneously
        nvAssert (dwHackMask != (CELSIUS_FLAG_TEXMATRIXHACK(0) | CELSIUS_FLAG_TEXMATRIXHACK(1)));

        if (dwHackMask) {
            // cache off the original modelview matrix and redefine eye space to be
            // "texture space" by incorporating the texture transform here.
            DWORD dwHWStage  = (dwHackMask & CELSIUS_FLAG_TEXMATRIXHACK(0)) ? 0 : 1;
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            pTexMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);
            mTemp = mMV0;
            MatrixProduct4x4 (&mMV0, &mTemp, pTexMatrix);
        }
#endif  // CELSIUS_TEX_MATRIX_HACK

        pContext->hwState.celsius.setMatrixTransposed (NV056_SET_MODEL_VIEW_MATRIX0(0), &mMV0);

        pContext->hwState.SuperTri.setEye(&mMV0);

        // Normals are transformed by the transpose of the inverse of the model view matrix.
        // (see Graphics Gems I, p. 541).
        // We only invert the upper 3x3 in order to eliminate the effects of translations.
        // the transposition happens because unlike all other matrices, we DON'T un-transpose
        // this one when we send it to the HW. (this is the one matrix for which D3D's
        // backwardness is convenient)

        if (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXSTATENEEDSINVMV | CELSIUS_FLAG_LIGHTINGNEEDSINVMV)) {
            // there's no reason to waste time normalizing the inverse MV matrix if we're going to have to normalize
            // normals anyway. otherwise, they give us normalized stuff and we need to preserve the normalization
            Inverse4x4 (&mInvMV, &mMV0, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
            pContext->hwState.celsius.setInverseModelViewMatrix (NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(0), &mInvMV);
        }

        if (pContext->pCurrentVShader->hasProgram()) {
            // prog pipe
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_COMPOSITE_MATRIX(0), &mViewportMatrix);
        }

        else if (GET_VERTEXBLEND_STATE(pContext)) {
            // we're skinning
            // compute the second modelview matrix, its inverse, and a distilled composite matrix:
            // cheops composite = projection plus accomodations for the viewport
            MatrixProduct4x4 (&mMV1, &(pContext->xfmWorld[1]), &(pContext->xfmView));
            if (dwHackMask) {
                mTemp = mMV1;
                MatrixProduct4x4 (&mMV1, &mTemp, pTexMatrix);
            }
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_MODEL_VIEW_MATRIX1(0), &mMV1);
            if (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_TEXSTATENEEDSINVMV | CELSIUS_FLAG_LIGHTINGNEEDSINVMV)) {
                Inverse4x4 (&mInvMV, &mMV1, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
                pContext->hwState.celsius.setInverseModelViewMatrix (NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(0), &mInvMV);
            }
            MatrixProduct4x4 (&mCTM, &(pContext->xfmProj), &mViewportMatrix);
            if (dwHackMask) {
                // pre-multiply by the inverted texture matrix to undo the mess
                // we made by introducing it into the modelview matrices above
                Inverse4x4 (&mTexMatrixInv, pTexMatrix, FALSE);
                MatrixProduct4x4 (&mTemp, &mTexMatrixInv, &mCTM);
                mCTM = mTemp;
            }
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_COMPOSITE_MATRIX(0), &mCTM);
        }

        else {
            // we're not skinning
            // skip the second set of modelview matrices and compute the composite matrix normally:
            // cheops composite = D3D World*View*projection plus accomodations for the viewport
#ifdef CELSIUS_TEX_MATRIX_HACK
            if (dwHackMask) {
                // restore the original MV matrix for the sake of computing the composite matrix
                mMV0 = mTemp;
            }
#endif  // CELSIUS_TEX_MATRIX_HACK
            MatrixProduct4x4 (&mTemp,  &(pContext->xfmProj), &mViewportMatrix);
            MatrixProduct4x4 (&mCTM, &mMV0, &mTemp);
            pContext->hwState.celsius.setMatrixTransposed (NV056_SET_COMPOSITE_MATRIX(0), &mCTM);
            // for supertri we need world*view*proj
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI) {
                MatrixProduct4x4 (&pContext->hwState.mTransform, &mMV0, &(pContext->xfmProj));
            }
        }

        pContext->hwState.celsius.set (NV056_SET_NORMALIZATION_ENABLE,
                                       DRF_NUM(056, _SET_NORMALIZATION_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS]));

    }  // !FVF_TRANSFORMED

    // set z clipping
    // note that clips may be reversed because of CT, so we need the min/max functions
    pContext->hwState.celsius.set2f (NV056_SET_CLIP_MIN, min (dvClip0, dvClip1), max (dvClip0, dvClip1));

    // set window clipping
    // we subtract one from xmax (ymax) because the HW clips to xmin <= x <= xmax
    // ie. it's inclusive of the upper limit. note this makes it impossible to clip to nothing
    DWORD x,y,w,h;
    if (pContext->aa.isEnabled()) {
        float s;
        s = pContext->aa.fWidthAmplifier;
        x = DWORD(0.5f + pViewport->clipHorizontal.wX * s);
        //No one remembers the why of this (below) and we think its bogus
        //but leaving this alternative here commented just in case this is
        //revisited
        //w = DWORD(pViewport->clipHorizontal.wWidth * s + s - 1);
        w = DWORD(pViewport->clipHorizontal.wWidth * s );

        s = pContext->aa.fHeightAmplifier;
        y = DWORD(0.5f + pViewport->clipVertical.wY * s);
        //why??? h = DWORD(pViewport->clipVertical.wHeight * s + s - 1);
        h = DWORD(pViewport->clipVertical.wHeight * s );
    }
    else {
        x = pViewport->clipHorizontal.wX;
        w = pViewport->clipHorizontal.wWidth;
        y = pViewport->clipVertical.wY;
        h = pViewport->clipVertical.wHeight;
    }

    dwClipH = DRF_NUM(056, _SET_WINDOW_CLIP_HORIZONTAL, _XMIN,
                      ((x - CELSIUS_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM(056, _SET_WINDOW_CLIP_HORIZONTAL, _XMAX,
                      ((x + w - 1 - CELSIUS_VIEWPORT_BOUND) & 0xfff));
    dwClipV = DRF_NUM(056, _SET_WINDOW_CLIP_VERTICAL, _YMIN,
                      ((y - CELSIUS_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM(056, _SET_WINDOW_CLIP_VERTICAL, _YMAX,
                      ((y + h - 1 - CELSIUS_VIEWPORT_BOUND) & 0xfff));

    pContext->hwState.celsius.prep_wait_for_idle_nv10();
    pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_HORIZONTAL(0), dwClipH);
    pContext->hwState.celsius.set (NV056_SET_WINDOW_CLIP_VERTICAL(0),   dwClipV);

    // BUBUG
    // This fixes a problem with the Billboard SDK app.  It sends down new vertices, and
    // changes the transform state for each primitive it renders, 4 vertices each
    // It seems likely that we should invalidate the cache here, but it seems just
    // as likely that the hardware should take care of this by itself.  Awaiting more
    // info
    nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);

    return (D3D_OK);
}


//---------------------------------------------------------------------------

// set everything else not covered by other celsius state routines. this includes:
//      - depth testing
//      - stencil testing
//      - alpha testing
//      - alpha blending

HRESULT nvSetCelsiusMiscState (PNVD3DCONTEXT pContext)
{
    DWORD dwMask, dwZBiasRS;
    DWORD dwSrcFactor, dwDstFactor;
    DWORD dwPointSize;
    float fZBias, fZScale;
    float a, t0, t1, t2, t3, t4, t5;  //point size variables
    float fSizeMin,fSizeMax,fSize;
    float aten1,aten2,aten3,fHeight, fScale;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_MISC_STATE;

    // z-buffering
    if (pContext->hwState.celsius.dwZEnable != D3DZB_FALSE) {
        pContext->hwState.celsius.set (NV056_SET_DEPTH_TEST_ENABLE, NV056_SET_DEPTH_TEST_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_DEPTH_MASK,        DRF_NUM(056, _SET_DEPTH_MASK, _V, pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]));
        pContext->hwState.celsius.set (NV056_SET_DEPTH_FUNC,        nv056DepthFunc[CTFunc(pContext,pContext->dwRenderState[D3DRENDERSTATE_ZFUNC])]);
    }
    else {
        pContext->hwState.celsius.set (NV056_SET_DEPTH_TEST_ENABLE, NV056_SET_DEPTH_TEST_ENABLE_V_FALSE);
    }

    // fill mode
    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
        case D3DFILL_POINT:
            pContext->hwState.celsius.set (NV056_SET_FRONT_POLYGON_MODE, NV056_SET_FRONT_POLYGON_MODE_V_POINT);
            pContext->hwState.celsius.set (NV056_SET_BACK_POLYGON_MODE,  NV056_SET_BACK_POLYGON_MODE_V_POINT);
            break;
        case D3DFILL_WIREFRAME:
            pContext->hwState.celsius.set (NV056_SET_FRONT_POLYGON_MODE, NV056_SET_FRONT_POLYGON_MODE_V_LINE);
            pContext->hwState.celsius.set (NV056_SET_BACK_POLYGON_MODE,  NV056_SET_BACK_POLYGON_MODE_V_LINE);
            break;
        case D3DFILL_SOLID:
            pContext->hwState.celsius.set (NV056_SET_FRONT_POLYGON_MODE, NV056_SET_FRONT_POLYGON_MODE_V_FILL);
            pContext->hwState.celsius.set (NV056_SET_BACK_POLYGON_MODE,  NV056_SET_BACK_POLYGON_MODE_V_FILL);
            break;
        default:
            DPF ("unknown FILLMODE");
            dbgD3DError();
            break;
    }

    // shading
    pContext->hwState.celsius.set (NV056_SET_SHADE_MODE,(pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
                                                     ? NV056_SET_SHADE_MODE_V_FLAT
                                                     : NV056_SET_SHADE_MODE_V_SMOOTH);

    // color write enable
    DWORD dwPlaneMask = pContext->dwRenderState[D3DRS_COLORWRITEENABLE];
    if (dwPlaneMask == (D3DCOLORWRITEENABLE_ALPHA |
                        D3DCOLORWRITEENABLE_RED   |
                        D3DCOLORWRITEENABLE_GREEN |
                        D3DCOLORWRITEENABLE_BLUE)) {
        // the common case
        dwMask = 0x01010101;
    }
    else {
        dwMask = 0;
        if (dwPlaneMask & D3DCOLORWRITEENABLE_ALPHA) dwMask |= (0x1 << 24);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_RED)   dwMask |= (0x1 << 16);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_GREEN) dwMask |= (0x1 << 8);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_BLUE)  dwMask |= (0x1 << 0);
    }

    pContext->hwState.celsius.set (NV056_SET_COLOR_MASK, dwMask);

    // alpha blending
    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]) {
        pContext->hwState.celsius.set (NV056_SET_BLEND_ENABLE, NV056_SET_BLEND_ENABLE_V_TRUE);
        dwSrcFactor = nv056BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]];
        dwDstFactor = nv056BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]];
        // for these two cases, we need to go back and override dwDstFactor
        switch (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]) {
            case D3DBLEND_BOTHSRCALPHA:    // obsolete, but we'll do it for Dx5 and prior
                dwDstFactor = NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA;
                break;
            case D3DBLEND_BOTHINVSRCALPHA: // likewise
                dwDstFactor = NV056_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA;
                break;
            default:
                // nada
                break;
        }

        pContext->hwState.celsius.set2 (NV056_SET_BLEND_FUNC_SFACTOR, dwSrcFactor, dwDstFactor);
        pContext->hwState.celsius.set (NV056_SET_BLEND_EQUATION, nv056BlendOp[pContext->dwRenderState[D3DRS_BLENDOP]]);
      }
    else {
        pContext->hwState.celsius.set (NV056_SET_BLEND_ENABLE, NV056_SET_BLEND_ENABLE_V_FALSE);
    }

    // culling
    switch (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]) {
        case D3DCULL_CW:
            pContext->hwState.celsius.set (NV056_SET_CULL_FACE_ENABLE, NV056_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_FRONT_FACE,       NV056_SET_FRONT_FACE_V_CCW);
            break;
        case D3DCULL_CCW:
            pContext->hwState.celsius.set (NV056_SET_CULL_FACE_ENABLE, NV056_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_FRONT_FACE,       NV056_SET_FRONT_FACE_V_CW);
            break;
        default:
            DPF ("unknown cull mode");
        case D3DCULL_NONE:
            pContext->hwState.celsius.set (NV056_SET_CULL_FACE_ENABLE, NV056_SET_CULL_FACE_ENABLE_V_FALSE);
            break;
    }

    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]) {
        pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_ALPHA_REF,         pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC,        nv056AlphaFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
    }
    else {
        pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_FALSE);
    }
#ifdef ALPHA_CULL
    // alpha test
#if ALPHA_CULL ==0
    pContext->hwState.alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        !pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] && !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] &&
    pContext->dwEarlyCopyStrategy
       )
    {
#else
    pContext->hwState.alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        /*!pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] &&*/ !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]  &&
    pContext->dwEarlyCopyStrategy
       )
#endif
    {
        pContext->hwState.alphacull_mode = 1;
        if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_SRCALPHA &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }
#if ALPHA_CULL >= 2
        /*else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCCOLOR &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00)
        {
            pContext->hwState.celsius.alphacull_mode = 2;
            pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), 0x08042820);
            pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   0x000010CD);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }*/
#endif
#if ALPHA_CULL >= 3
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00 &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->dwEarlyCopyStrategy == 3)
        {
            pContext->hwState.alphacull_mode = 3;
            pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), 0x08040820);
            pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   0x000010CD);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }
#endif
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_INVSRCALPHA &&
                pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0xf4);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_LESS);
        }
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO){
            if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0xf4);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_LESS);
            }
            else if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
                pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
            }
        }
    }
#endif

    //anti aliased edges
    if (getDC()->nvD3DPerfData.dwHaveAALines){
        if (pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]){
            pContext->hwState.celsius.set (NV056_SET_BLEND_ENABLE, NV056_SET_LINE_SMOOTH_ENABLE_V_TRUE);
        }
        else {
            pContext->hwState.celsius.set (NV056_SET_LINE_SMOOTH_ENABLE, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);
        }
    }

    // dithering
    pContext->hwState.celsius.set (NV056_SET_DITHER_ENABLE, DRF_NUM(056, _SET_DITHER_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]));

    // z bias
    dwZBiasRS = (pContext->dwRenderState[D3DRENDERSTATE_ZBIAS] != 0) ? 1 : 0;
    // switch on an arbitrary identifier
    switch (dwZBiasRS * pContext->hwState.celsius.dwZEnable) {
        case D3DZB_TRUE:
            // renderstate_zbias!=0 and zenable==D3DZB_TRUE.
            // the bias is applied to z values in device coordinates
            // (i.e in the range [0..2^16-1] or [0..2^24-1])
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_POINT_ENABLE, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_LINE_ENABLE,  NV056_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_FILL_ENABLE,  NV056_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE);
            fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
            fZScale = 0.25f * fZBias;
            pContext->hwState.celsius.set2f (NV056_SET_POLYGON_OFFSET_SCALE_FACTOR, fZScale, fZBias);
            break;
        case D3DZB_USEW:
            // renderstate_zbias!=0 and zenable==D3DZB_USEW
            // D3D would want us to apply the bias to w instead of z, but we can't
            // really do this, so note a setup failure and fall through to disable
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
        case 0:
            // renderstate_zbias==0 and/or zenable==D3DZB_FALSE
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_POINT_ENABLE, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_LINE_ENABLE,  NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);
            pContext->hwState.celsius.set (NV056_SET_POLY_OFFSET_FILL_ENABLE,  NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);
            break;
        default:
            DPF ("oops. i goofed. got unexpected zbias case");
            dbgD3DError();
            break;
    }

    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;

    if (pNvObj) {
        if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
            pNvObj->tagAltStencilBadSemantics();
            pNvObj->tagAltStencilDisabled();
        }
    }

    // stencil
    if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
        pContext->bStencilEnabled = TRUE;
        pContext->hwState.celsius.set (NV056_SET_STENCIL_TEST_ENABLE, NV056_SET_STENCIL_TEST_ENABLE_V_TRUE);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_FAIL,     nv056StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZFAIL,    nv056StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZPASS,    nv056StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC,        nv056StencilFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]]);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_REF,    pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]       & 0xff);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_MASK,   pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]      & 0xff);
        pContext->hwState.celsius.set (NV056_SET_STENCIL_MASK,        pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK] & 0xff);
    }
    else if (pNvObj && pNvObj->isAltStencilEnabled()) {
        // Do nothing; stencil is set elsewhere
    } else {
        pContext->hwState.celsius.set (NV056_SET_STENCIL_TEST_ENABLE, NV056_SET_STENCIL_TEST_ENABLE_V_FALSE);
    }

    // combiner factor
    pContext->hwState.celsius.set (NV056_SET_COMBINE_FACTOR(0), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
    pContext->hwState.celsius.set (NV056_SET_COMBINE_FACTOR(1), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);

    // skinning
    pContext->hwState.celsius.set (NV056_SET_SKIN_ENABLE,(GET_VERTEXBLEND_STATE(pContext) ?
                                                       DRF_DEF(056, _SET_SKIN_ENABLE, _V, _TRUE) :
                                                       DRF_DEF(056, _SET_SKIN_ENABLE, _V, _FALSE)));

    // line and point sizes for AA
    if (pContext->aa.isEnabled()) {
        pContext->hwState.celsius.set (NV056_SET_LINE_WIDTH, pContext->aa.dwLinePointSize);
        pContext->hwState.celsius.set (NV056_SET_POINT_SIZE, pContext->aa.dwLinePointSize);
    }
    else {
        pContext->hwState.celsius.set (NV056_SET_LINE_WIDTH, 0x00000008);  // 6.3 format
        pContext->hwState.celsius.set (NV056_SET_POINT_SIZE, 0x00000008);  // 6.3 format
    }

    // Only do the pt. size renderstate if app is dx8 app.
    if (pContext->dwDXAppVersion >= 0x800)
    {

        fSizeMin = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MIN]);
        fSizeMax = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MAX]);
        fSize    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE]);
        fScale = fSize;
        aten1    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_A]);
        aten2    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_B]);
        aten3    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_C]);
        if (fScale <= 0.0f) fScale = 0.0001f;
        if (fSizeMin <= 0.0f) fSizeMin =  0.0001f;   //watch out for divide by zero....
        if (fSizeMin > 63.869f) fSizeMin = 63.869f;   //watch out for divide by zero....
        if (fSizeMax > 63.870f) fSizeMax = 63.870f;
        if (fSizeMax < 0.0f) fSizeMax = 0.0f;
        //if (pContext->dwRenderState[D3DRS_POINTSCALEENABLE]) fSize *= pContext->surfaceViewport.clipVertical.wHeight;
        if (fSize > fSizeMax ) fSize = fSizeMax;
        if (fSize < fSizeMin ) fSize = fSizeMin;
        t3 = fSizeMax - fSizeMin;
        if (t3) t4 = -fSizeMin / t3;
        t5 = fSizeMin;

        fHeight = 1;
        if ( pContext->surfaceViewport.clipVertical.wHeight &&
             pContext->dwRenderState[D3DRS_POINTSCALEENABLE])
        {
            fHeight = (float)(pContext->surfaceViewport.clipVertical.wHeight);
            //have to do this loop if we want to move height into the attenuation
            //factors because valid point sprite sizes < 0.125 will be expressed
            //as zeros if we don't do something  HMH
            while (fSize < 32.0f && fHeight > 2.0f)
            {
                fSize *= 2;
                fScale *= 2;
                fHeight *= 0.5f;
            }
        }

        a = (t3 / fScale) * (t3 / fScale) * (1.0f / (fHeight * fHeight) );

        t0 = aten1 * a;
        t1 = aten2 * a;
        t2 = aten3 * a;

        dwPointSize = ((DWORD)(fSize * 8.0f)) & 0x1ff;  // convert to 6.3

        pContext->hwState.celsius.set3f (NV056_SET_POINT_PARAMS(0), t0,t1,t2);
        pContext->hwState.celsius.set3f (NV056_SET_POINT_PARAMS(3), t3,t3,t3);
        pContext->hwState.celsius.setf (NV056_SET_POINT_PARAMS(6), t4);
        pContext->hwState.celsius.setf (NV056_SET_POINT_PARAMS(7), t5);
        pContext->hwState.celsius.set (NV056_SET_POINT_SIZE, dwPointSize);  // 6.3 format
        pContext->hwState.celsius.set (NV056_SET_POINT_PARAMS_ENABLE, pContext->dwRenderState[D3DRS_POINTSCALEENABLE] ?
                                                                   NV056_SET_POINT_PARAMS_ENABLE_V_TRUE :
                                                                   NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);
        pContext->hwState.celsius.set (NV056_SET_POINT_SMOOTH_ENABLE, pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] ?
                                                                   NV056_SET_POINT_SMOOTH_ENABLE_V_TRUE:
                                                                   NV056_SET_POINT_SMOOTH_ENABLE_V_FALSE);


    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// This handles the SetControl0 method:
//      premultiplied alpha
//      texture perspective
//      z perspective
//      z format
//      alpha kill mode
//      stencil write enable

HRESULT nvSetCelsiusControl0 (PNVD3DCONTEXT pContext)
{
    DWORD dwMask = 0;

    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_CONTROL0;

    // SRWNOTE: D3D has the possibility of having pre-multiplied alpha in 1
    // texture stage and not in another stage. How do we handle this?
    // hmm... actually this seems to be specified on a per surface basis
    // hedge on this for now
// BUGBUG
#if 0
    if (statev.premultipliedalpha)
        dwMask |= DRF_DEF(056, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _TRUE);
    else
        dwMask |= DRF_DEF(056, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _FALSE);
#endif

#ifdef CELSIUS_ENABLE_BAD_PERSPECTIVE
    // this method is horribly named. setting it to false forces w to 1.0 in primitive assembly
    // which actually has almost nothing to do with texture perspective, because the w-divide that
    // perspectively corrects textures has already been done in the transform unit.
    // the only things actually affected are those downstream of primitive assembly:
    // - perspectively correct color interpolation
    // - w-clipping
    // this should not ever be disabled in T&L mode because of the latter!
    dwMask |= (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) ?
              DRF_NUM(056, _SET_CONTROL0, _TEXTUREPERSPECTIVE, pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]) :
              DRF_DEF(056, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE);
#else
    dwMask |= DRF_DEF(056, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE);
#endif

    // w or z buffering
    dwMask |= DRF_NUM(056, _SET_CONTROL0, _Z_PERSPECTIVE_ENABLE, (DWORD)(pContext->hwState.celsius.dwZEnable == D3DZB_USEW));

    // D3D has no provision for specification of zbuffer format
    // somewhat arbitrarily choose FIXED. alternately we could select it
    // to their advantage according to whether w-buffering is enabled (?)
    dwMask |= DRF_DEF(056, _SET_CONTROL0, _Z_FORMAT, _FIXED);

    if (pContext->hwState.celsius.dwZEnable == D3DZB_USEW) {
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WSOURCE(0)) {
            // pull w-buffer values from texture unit 0
            dwMask |= DRF_DEF(056, _SET_CONTROL0, _WBUFFER_SELECT, _0);
        }
        else if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_WSOURCE(1)) {
            // pull w-buffer values from texture unit 1
            dwMask |= DRF_DEF(056, _SET_CONTROL0, _WBUFFER_SELECT, _1);
        }
        else {
            // w-buffering with no available w value
            nvAssert(0);
        }
    }
    else {
        // disable w-buffering
        dwMask |= DRF_DEF(056, _SET_CONTROL0, _WBUFFER_SELECT, _0);
    }

    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;

    dwMask |= (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] || (pNvObj && pNvObj->isAltStencilEnabled())) ?
        DRF_DEF(056, _SET_CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE) :
        DRF_DEF(056, _SET_CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);

    pContext->hwState.celsius.set (NV056_SET_CONTROL0, dwMask);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// returns the size (in 4-byte words) of an inlined vertex

DWORD nvCelsiusInlineVertexStride (PNVD3DCONTEXT pContext)
{
    CVertexShader *pShader;
    DWORD          dwStride;

    pShader = pContext->pCurrentVShader;

    dwStride  = 0;
    dwStride += pShader->bVAExists (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) ? sizeof(DWORD) : 0;
    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_NORMAL]);

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        nvAssert (pShader->bVAExists (dwVAIndex));  // they better have given us coordinates
        DWORD n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                  4*sizeof(DWORD) : pShader->getVASize (dwVAIndex);
        dwStride += n;
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
        DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >>  0) & 0xffff;
        DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        nvAssert (pShader->bVAExists (dwVAIndex));  // they better have given us coordinates
        DWORD n = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                  4*sizeof(DWORD) : pShader->getVASize (dwVAIndex);
        dwStride += n;
    }

    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_SPECULAR]);
    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_DIFFUSE]);
    dwStride += pShader->getVASize (defaultInputRegMap[D3DVSDE_POSITION]);

    //don't actually add in point size because we we remove it in the inner loop HMH
    //    dwStride += (fvfData.dwPointSizeMask ? 1 : 0);

    return (dwStride >> 2);
}

//---------------------------------------------------------------------------

// set sources and offsets of various vertex components.

HRESULT nvSetCelsiusVertexFormat (PNVD3DCONTEXT pContext)
{
    DWORD   dwFormat[7], dwD3DStage, dwTexCount;
    DWORD   dwTCIndex, dwVAIndex;
    DWORD   dwVertexBufferOffset;
    DWORD   dwFormatShadow = 0;
    DWORD   dwStreamSelector;
    BOOL    bInlineVertices, bTess;
    DWORD   dwInlineStride, dwStride;
    DWORD   dwOffsetAdjustment;

    // clear dirty flag
    pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_FVF;

    // calculate a tessellator style FVF format
    bTess = pContext->hwState.dwStateFlags & CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;

    CVertexShader  *pShader   = pContext->pCurrentVShader;
    CVertexBuffer **ppStreams = pContext->ppDX8Streams;

    // shadow the values so we know what we last sent to the HW
    pContext->hwState.dwVertexOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->hwState.pVertexShader  = pContext->pCurrentVShader;
    nvMemCopy (pContext->hwState.ppStreams, pContext->ppDX8Streams, CELSIUS_CAPS_MAX_STREAMS*sizeof(CVertexBuffer *));

    // find the stream containing geometry
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
    if ((dwStreamSelector == CVertexShader::VA_STREAM_NONE) || (ppStreams[dwStreamSelector] == NULL)) {
        // we don't have vertex data yet (happens if called via validateTSS())
        return (TRUE);
    }

#ifdef STOMP_TEX_COORDS
    pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_STOMP_4TH_COORD_MASK;

    if (!pShader->hasProgram()) {
        for (DWORD dwHWStage=0; dwHWStage < CELSIUS_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (16*dwHWStage)) & 0xffff;
                if ((pShader->getVASize(defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex]) == 16) &&
                    (CELSIUS_GET_NUM_TEX_COORDS(pContext->hwState.dwNumTexCoordsNeeded, dwHWStage) < 4)) {
                    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_STOMP_4TH_COORD(dwHWStage);
                }
            }
        }
    }

    // This should only happen in WHQL.  If it's happening elsewhere, either the app
    // is really stupid, or we're doing something wrong.
    nvAssert(!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_STOMP_4TH_COORD_MASK));
#endif  // STOMP_TEX_COORDS

    // figure out if we need to inline this vertex data
    bInlineVertices = (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1)
                      ||
                      (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 0)
                      ||
                      (pShader->hasProgram())
                      ||
                      (pShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
                      ||
#ifdef STOMP_TEX_COORDS
                      (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) |
                                                         CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(0)         |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(1)         |
                                                         CELSIUS_FLAG_STOMP_4TH_COORD(0)        |
                                                         CELSIUS_FLAG_STOMP_4TH_COORD(1)));
#else  // !STOMP_TEX_COORDS
                      (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) |
                                                         CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(0)         |
                                                         CELSIUS_FLAG_TEXMATRIXSWFIX(1)));
#endif  // !STOMP_TEX_COORDS

    #ifdef FORCE_INLINE_VERTICES
        bInlineVertices = TRUE;
    #endif

    if (bInlineVertices) {
        dwInlineStride = nvCelsiusInlineVertexStride(pContext) << 2;
        pContext->hwState.dwInlineVertexStride = dwInlineStride;
    }
    else {
        pContext->hwState.dwInlineVertexStride = 0;
    }

    // note: dwFormatShadow is a hideous hack. basically, the hardware fails to write out
    // and restore vertex formats (actually just the sizes contained therein) correctly
    // upon context switches, so we store the information redundantly in some dead space
    // (the last element of the fourth row of the second inverse model view matrix).
    // From there, the RM can grab them and reset things properly after a context switch.

    // x, y, z, [w]
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
    dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
    if (pShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
        // w present
        dwFormat[0] = DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _SIZE, _4) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _W, _PRESENT) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_VERTEX_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_4 << 0);
    }
    else {
        // x,y,z only
        dwFormat[0] = DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _SIZE, _3) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _W, _NONE) |
                      DRF_DEF(056, _SET_VERTEX_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_VERTEX_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_3 << 0);
    }

    // diffuse array
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_DIFFUSE]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[1]  = DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _SIZE, _4) |
                       DRF_NUM(056, _SET_DIFFUSE_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormat[1] |= bTess?
                       DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _TYPE, _FLOAT) :
                       DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4 << 4);
    }
    else {
#ifdef STATE_CULL
        pContext->hwState.celsius.valid [NV056_SET_DIFFUSE_COLOR4UB >> 2] = 0;
#endif
        pContext->hwState.celsius.set (NV056_SET_DIFFUSE_COLOR4UB, 0xFFFFFFFF); // default to white
        dwFormat[1] = DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_DIFFUSE_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4);
    }

    // specular array
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_SPECULAR]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[2]  = DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _SIZE, _4) |
                       DRF_NUM(056, _SET_SPECULAR_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormat[2] |= bTess ?
                       DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _TYPE, _FLOAT) :
                       DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_4 << 8);
    }
    else {
#ifdef STATE_CULL
        pContext->hwState.celsius.valid [NV056_SET_SPECULAR_COLOR4UB >> 2] = 0;
#endif
        pContext->hwState.celsius.set (NV056_SET_SPECULAR_COLOR4UB, 0); // default to black
        dwFormat[2] = DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_SPECULAR_ARRAY_FORMAT, _TYPE, _UNSIGNED_BYTE_BGRA);
        dwFormatShadow |= (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8);
    }

    // tex 0 array
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        dwTexCount = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                     4 : ((pShader->getVASize (dwVAIndex)) >> 2);
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[3] = DRF_NUM(056, _SET_TEX_COORD0_ARRAY_FORMAT, _SIZE, dwTexCount) |
                      DRF_DEF(056, _SET_TEX_COORD0_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_TEX_COORD0_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (dwTexCount << 12);
    }
    else {
        dwFormat[3] = DRF_DEF(056, _SET_TEX_COORD0_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_TEX_COORD0_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0 << 12);
    }

    // tex 1 array
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
        nvAssert (dwD3DStage != CELSIUS_UNUSED);
        dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
        dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        dwStreamSelector = pShader->getVAStream (dwVAIndex);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
        dwTexCount = (pContext->hwState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                     4 : ((pShader->getVASize (dwVAIndex)) >> 2);
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[4] = DRF_NUM(056, _SET_TEX_COORD1_ARRAY_FORMAT, _SIZE, dwTexCount) |
                      DRF_DEF(056, _SET_TEX_COORD1_ARRAY_FORMAT, _TYPE, _FLOAT) |
                      DRF_NUM(056, _SET_TEX_COORD1_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (dwTexCount << 16);
    }
    else {
        dwFormat[4] = DRF_DEF(056, _SET_TEX_COORD1_ARRAY_FORMAT, _SIZE, _0) |
                      DRF_DEF(056, _SET_TEX_COORD1_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0 << 16);
    }

    // normal array
    dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_NORMAL]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[5] = DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _SIZE, _3)      |
                      DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _TYPE, _FLOAT)  |
                      DRF_NUM(056, _SET_NORMAL_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_3 << 20);
    }
    else {
        dwFormat[5] = DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _SIZE, _0)      |
                      DRF_DEF(056, _SET_NORMAL_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20);
    }

    // weight array
    dwStreamSelector = pShader->getVAStream(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
    if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
        dwStride = bInlineVertices ? dwInlineStride : ppStreams[dwStreamSelector]->getVertexStride();
        dwFormat[6] = DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _SIZE, _1)      |
                      DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _TYPE, _FLOAT)  |
                      DRF_NUM(056, _SET_WEIGHT_ARRAY_FORMAT, _STRIDE, dwStride);
        dwFormatShadow |= (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_1 << 24);
    }
    else {
        dwFormat[6] = DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _SIZE, _0)      |
                      DRF_DEF(056, _SET_WEIGHT_ARRAY_FORMAT, _TYPE, _FLOAT);
        dwFormatShadow |= (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24);
    }

    // fog arrays (non-existent in D3D)
    dwFormatShadow |= (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28);

    // now go ahead and actually set all the formats, PREFACED by the shadowed copy
    pContext->hwState.celsius.set (NV056_SET_VERTEX_FORMAT_SHADOW,    dwFormatShadow);
    pContext->hwState.celsius.set (NV056_SET_VERTEX_ARRAY_FORMAT,     dwFormat[0]);
    pContext->hwState.celsius.set (NV056_SET_DIFFUSE_ARRAY_FORMAT,    dwFormat[1]);
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ARRAY_FORMAT,   dwFormat[2]);
    pContext->hwState.celsius.set (NV056_SET_TEX_COORD0_ARRAY_FORMAT, dwFormat[3]);
    pContext->hwState.celsius.set (NV056_SET_TEX_COORD1_ARRAY_FORMAT, dwFormat[4]);
    pContext->hwState.celsius.set (NV056_SET_NORMAL_ARRAY_FORMAT,     dwFormat[5]);
    pContext->hwState.celsius.set (NV056_SET_WEIGHT_ARRAY_FORMAT,     dwFormat[6]);

    // if we're going to fetch vertex data directly, we also need to program up the context dma and offsets
    if (!bInlineVertices) {

        // program the context dma and calculate a celsius-specific offset adjustment:
        // celsius wants an offset relative to a page aligned context dma, something
        // we do not know we have using the built in getOffset() methods.
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);

        switch (ppStreams[dwStreamSelector]->getContextDMA()) {

            case NV_CONTEXT_DMA_AGP_OR_PCI:
                pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_VERTEX, D3D_CONTEXT_DMA_HOST_MEMORY);
                pContext->hwState.celsius.set (NV056_INVALIDATE_VERTEX_CACHE_FILE, 0);
                // compensate for ctx dma that is possibly not 4k aligned
                dwOffsetAdjustment = (ppStreams[dwStreamSelector]->getHeapLocation() == CSimpleSurface::HEAP_AGP) ?
                                     (pDriverData->GARTLinearBase & 0xfff) :      // AGP
                                     (getDC()->nvD3DTexHeapData.dwBase & 0xfff);  // PCI
                break;
            case NV_CONTEXT_DMA_VID:
                pContext->hwState.celsius.set (NV056_SET_CONTEXT_DMA_VERTEX, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
                pContext->hwState.celsius.set (NV056_INVALIDATE_VERTEX_CACHE_FILE, 0);
                // compensate for ctx dma that is possibly not 4k aligned
                // NOTE - this is highly unlikely to not be 4k aligned...
                nvAssert ((pDriverData->BaseAddress & 0xfff) == 0);
                dwOffsetAdjustment = 0;
                break;
            default:
                DPF ("unknown context DMA");
                dbgD3DError();
                break;

        }  // switch

        // x, y, z, [w]
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_POSITION]);
        nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector]));
        dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                               pContext->hwState.dwVertexOffset +
                               pShader->getVAOffset (defaultInputRegMap[D3DVSDE_POSITION]) +
                               dwOffsetAdjustment;
        pContext->hwState.celsius.set (NV056_SET_VERTEX_ARRAY_OFFSET, dwVertexBufferOffset);

        // diffuse color
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_DIFFUSE]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_DIFFUSE]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_DIFFUSE_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // specular color
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_SPECULAR]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_SPECULAR]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_SPECULAR_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // texture0 coordinates
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            nvAssert (dwD3DStage != CELSIUS_UNUSED);
            dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xffff;
            dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            dwStreamSelector = pShader->getVAStream (dwVAIndex);
            nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (dwVAIndex) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_TEX_COORD0_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // texture1 coordinates
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            nvAssert (dwD3DStage != CELSIUS_UNUSED);
            dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
            dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            dwStreamSelector = pShader->getVAStream (dwVAIndex);
            nvAssert ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])); // they better have given us coordinates
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (dwVAIndex) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_TEX_COORD1_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // normal
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_NORMAL]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_NORMAL]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_NORMAL_ARRAY_OFFSET, dwVertexBufferOffset);
        }

        // weights (for skinning)
        dwStreamSelector = pShader->getVAStream (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        if ((dwStreamSelector != CVertexShader::VA_STREAM_NONE) && (ppStreams[dwStreamSelector])) {
            dwVertexBufferOffset = ppStreams[dwStreamSelector]->getOffset() +
                                   pContext->hwState.dwVertexOffset +
                                   pShader->getVAOffset (defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) +
                                   dwOffsetAdjustment;
            pContext->hwState.celsius.set (NV056_SET_WEIGHT_ARRAY_OFFSET, dwVertexBufferOffset);
        }

    }  // if (!bInlineVertices)

    // do not remove
    pContext->hwState.celsius.queueTLNOP();

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set all state of the celsius object
// should be called prior to rendering
HRESULT __stdcall nvSetCelsiusState (PNVD3DCONTEXT pContext)
{

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->beginHWStateChange(pContext->hwState.dwDirtyFlags, pDriverData->nvPusher.m_dwPut);
#endif

#ifdef NV_NULL_BLEND

    if (((pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_MISC_STATE)) || (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_COMBINERS) || (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TEXTURE_STATE)) {

    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    DWORD dwLODBias0 = nvTranslateLODBias (0);
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    for (int i = 0; i < 8; i++) {
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]      = 0;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSU]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSV]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_MAGFILTER]       = D3DTFG_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MINFILTER]       = D3DTFN_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MIPFILTER]       = D3DTFP_POINT;
        pContext->tssState[i].dwValue[D3DTSS_COLOROP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG2]       = D3DTA_CURRENT;
#endif
        pContext->tssState[i].dwValue[D3DTSS_ALPHAOP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG2]       = D3DTA_CURRENT;
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT00]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT01]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT10]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT11]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_TEXCOORDINDEX]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BORDERCOLOR]     = 0x00000000;
        pContext->tssState[i].dwValue[D3DTSS_MIPMAPLODBIAS]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXMIPLEVEL]     = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXANISOTROPY]   = 1;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLSCALE]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLOFFSET]  = 0;
        pContext->tssState[i].dwHandle                        = 0;
        pContext->tssState[i].dwLODBias                       = dwLODBias0;
#endif
    }
#ifdef NV_NULL_TEXTURES
    pContext->tssState[0].dwValue[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
    pContext->dwStageCount       = 1;
#endif
    }

#endif

#if (NVARCH >= 0x010)
    // Tell AASTATE that we're starting 3D rendering
    // Note that we call nvSetCelsiusState whenever
    // we're about to do some 3D rendering
    pContext->aa.Rendering(pContext);
#endif  // NVARCH >= 0x010


    // clear the failure flag
    pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_SETUPFAILURE;

    // if ddraw has sullied the celsius object or if we last programmed
    // the celsius object for a different context, start from scratch
    if ((pDriverData->dwMostRecentHWUser != MODULE_ID_D3D) ||
        (getDC()->dwLastHWContext        != (DWORD)pContext))
    {
        pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;
        getDC()->dwLastHWContext        = (DWORD)pContext;
        pContext->hwState.dwDirtyFlags  = CELSIUS_DIRTY_REALLY_FILTHY;
#ifdef STATE_CULL
        for (int i=0; i < CELSIUS_HWSTATE_SIZE; i++) {
            // this case also implies that the object has state inconsistent with our shadowed copy
            // therefore we need to disable HW shadowing for the rest of call
            pContext->hwState.celsius.valid[i] = 0;
        }
#endif
    }

    // apply out-of-context dirty flags
    pContext->hwState.dwDirtyFlags |= getDC()->dwOutOfContextCelsiusDirtyFlags;
    getDC()->dwOutOfContextCelsiusDirtyFlags = 0;

    // this compiles away to nothing in a retail build
    pContext->hwState.dwDirtyFlags |= dbgForceHWRefresh;

    // mask out any non-celsius bits
    pContext->hwState.dwDirtyFlags &= CELSIUS_DIRTY_REALLY_FILTHY;


    // if nothing is dirty, just return
    if (!(pContext->hwState.dwDirtyFlags)) {
        return D3D_OK;
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_START(NVP_T_SETCELSIUSSTATE);
#endif

    // fundamental D3D stuff that doesn't normally change
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_DEFAULTS) {
        nvSetCelsiusD3DDefaults (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_SURFACE) {
        nvSetCelsiusSurfaceInfo (pContext);
    }

    // program the color combiners early since they determine the mapping
    // between hardware texture units and D3D texture stages, upon
    // which tons of other stuff depends.
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_COMBINERS) {
        nvSetCelsiusColorCombiners (pContext);
    }

    // If a pixel shader is enabled, use it to update the state
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_PIXEL_SHADER) {
        if (pContext->pCurrentPShader) {
            pContext->pCurrentPShader->setCelsiusState(pContext);
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_FVF;
        }
        pContext->hwState.dwDirtyFlags &= ~CELSIUS_DIRTY_PIXEL_SHADER;
    }

    // texture state
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TEXTURE_STATE) {
        nvSetCelsiusTextureState (pContext);
    }

    // fog / specular combiner
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_SPECFOG_COMBINER) {
        nvSetCelsiusSpecularFogCombiner (pContext);
    }

    // transform / lighting mode
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TL_MODE) {
        nvSetCelsiusTLMode (pContext);
    }

    // texture transform
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TEXTURE_TRANSFORM) {
        nvSetCelsiusTextureTransform (pContext);
    }

    // lighting
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_LIGHTS) {
        nvSetCelsiusLights (pContext);
    }

    // transform
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_TRANSFORM) {
        nvSetCelsiusTransform (pContext);
    }

    // remaining random stuff
    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_MISC_STATE) {
        nvSetCelsiusMiscState (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_CONTROL0) {
        nvSetCelsiusControl0 (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & CELSIUS_DIRTY_FVF) {
        nvSetCelsiusVertexFormat (pContext);
    }


#ifdef NV_PROFILE_CALLSTACK
    NVP_STOP(NVP_T_SETCELSIUSSTATE);
    nvpLogTime(NVP_T_SETCELSIUSSTATE,nvpTime[NVP_T_SETCELSIUSSTATE]);
#endif

    // make sure we're not dirty anymore. (this might happen if
    // there are interdepencies among the celsius state routines
    // and the routines get called in the 'wrong' order)
    nvAssert (!(pContext->hwState.dwDirtyFlags));

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->endHWStateChange(pDriverData->nvPusher.m_dwPut);
#endif

    return D3D_OK;
}

#endif // NV_ARCH == 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusTables.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusTables.cpp                                               *
*       tables useful for quick lookups of precomputed values               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        13May99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

// table of precomputed combiner settings for stupid legacy texture blends.

// the table is indexed as [i][j]
// where i = D3DTBLEND_BLAH
//       j=0 => alpha_icw[0]
//       j=1 => color_icw[0]
//       j=2 => alpha_ocw[0]
//       j=3 => color_ocw[0]

DWORD celsiusTextureBlendSettings[D3D_TBLEND_MAX+1][4] =
{
    // i=0
    // invalid

    ~0,
    ~0,
    ~0,
    ~0,

    // i=1
    // D3DTBLEND_DECAL
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=2
    // D3DTBLEND_MODULATE
    // aPix = aTex
    // cPix = cTex * cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=3
    // D3DTBLEND_DECALALPHA
    // aPix = aDiffuse
    // cPix = ((1 - aTex) * cDiffuse) + (aTex * cTex)

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // 1-aTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_8),               // cTex0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=4
    // D3DTBLEND_MODULATEALPHA
    // aPix = aTex * aDiffuse
    // cPix = cTex * cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=5
    // D3DTBLEND_DECALMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex : cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _TRUE)    |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=6
    // D3DTBLEND_MODULATEMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex * cDiffuse : cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_4),               // cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _TRUE)    |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=7
    // D3DTBLEND_COPY (same as DECAL)
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0),     // dev/null

    // i=8
    // D3DTBLEND_ADD
    // aPix = aDiffuse
    // cPix = cTex + cDiffuse

    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 1

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// combiner settings used when they enable a texture blend but not a texture
// aPix = aDiffuse
// cPix = cDiffuse

DWORD celsiusTextureBlendDefault[4] =
{
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(056, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(056, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _OPERATION,     _NOSHIFT) |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _MUX_ENABLE,    _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DOT_ENABLE, _FALSE)   |
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _SUM_DST,       _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _AB_DST,        _REG_0)   |  // dev/null
    DRF_DEF(056, _SET_COMBINER0_COLOR_OCW, _CD_DST,        _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d renderstates and celsius state.

// celsiusDirtyBitsFromRenderState[D3DRENDERSTATE_FOO] contains the celsius class
// dirty bits that should be set whenever D3DRENDERSTATE_FOO is changed

DWORD celsiusDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1] =
{
    0,                                                            //  0   invalid
    (CELSIUS_DIRTY_COMBINERS | CELSIUS_DIRTY_TEXTURE_STATE |      //  1   D3DRENDERSTATE_TEXTUREHANDLE
     CELSIUS_DIRTY_TEXTURE_TRANSFORM),
    0,                                                            //  2   D3DRENDERSTATE_ANTIALIAS
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  3   D3DRENDERSTATE_TEXTUREADDRESS
    (CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_CONTROL0),       //  4   D3DRENDERSTATE_TEXTUREPERSPECTIVE
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  5   D3DRENDERSTATE_WRAPU
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  6   D3DRENDERSTATE_WRAPV
    (CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_CONTROL0 |           //  7   D3DRENDERSTATE_ZENABLE
     CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_MISC_STATE |
     CELSIUS_DIRTY_SPECFOG_COMBINER | CELSIUS_DIRTY_TL_MODE),
    CELSIUS_DIRTY_MISC_STATE,                                     //  8   D3DRENDERSTATE_FILLMODE
    CELSIUS_DIRTY_MISC_STATE,                                     //  9   D3DRENDERSTATE_SHADEMODE
    0,                                                            //  10  D3DRENDERSTATE_LINEPATTERN
    0,                                                            //  11  D3DRENDERSTATE_MONOENABLE
    0,                                                            //  12  D3DRENDERSTATE_ROP2
    CELSIUS_DIRTY_MISC_STATE,                                     //  13  D3DRENDERSTATE_PLANEMASK
    CELSIUS_DIRTY_MISC_STATE,                                     //  14  D3DRENDERSTATE_ZWRITEENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  15  D3DRENDERSTATE_ALPHATESTENABLE
    0,                                                            //  16  D3DRENDERSTATE_LASTPIXEL
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  17  D3DRENDERSTATE_TEXTUREMAG
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  18  D3DRENDERSTATE_TEXTUREMIN
    CELSIUS_DIRTY_MISC_STATE,                                     //  19  D3DRENDERSTATE_SRCBLEND
    CELSIUS_DIRTY_MISC_STATE,                                     //  20  D3DRENDERSTATE_DESTBLEND
    CELSIUS_DIRTY_COMBINERS,                                      //  21  D3DRENDERSTATE_TEXTUREMAPBLEND
    CELSIUS_DIRTY_MISC_STATE,                                     //  22  D3DRENDERSTATE_CULLMODE
    CELSIUS_DIRTY_MISC_STATE,                                     //  23  D3DRENDERSTATE_ZFUNC
    CELSIUS_DIRTY_MISC_STATE,                                     //  24  D3DRENDERSTATE_ALPHAREF
    CELSIUS_DIRTY_MISC_STATE,                                     //  25  D3DRENDERSTATE_ALPHAFUNC
    CELSIUS_DIRTY_MISC_STATE,                                     //  26  D3DRENDERSTATE_DITHERENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  27  D3DRENDERSTATE_ALPHABLENDENABLE
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  28  D3DRENDERSTATE_FOGENABLE
    (CELSIUS_DIRTY_LIGHTS | CELSIUS_DIRTY_SPECFOG_COMBINER),      //  29  D3DRENDERSTATE_SPECULARENABLE
    0,                                                            //  30  D3DRENDERSTATE_ZVISIBLE
    0,                                                            //  31  D3DRENDERSTATE_SUBPIXEL
    0,                                                            //  32  D3DRENDERSTATE_SUBPIXELX
    0,                                                            //  33  D3DRENDERSTATE_STIPPLEDALPHA
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  34  D3DRENDERSTATE_FOGCOLOR
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  35  D3DRENDERSTATE_FOGTABLEMODE
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  36  D3DRENDERSTATE_FOGTABLESTART   (D3DRENDERSTATE_FOGSTART)
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  37  D3DRENDERSTATE_FOGTABLEEND     (D3DRENDERSTATE_FOGEND)
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  38  D3DRENDERSTATE_FOGTABLEDENSITY (D3DRENDERSTATE_FOGDENSITY)
    0,                                                            //  39  D3DRENDERSTATE_STIPPLEENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  40  D3DRENDERSTATE_EDGEANTIALIAS
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  41  D3DRENDERSTATE_COLORKEYENABLE
    0,                                                            //  42  D3DRENDERSTATE_OLDALPHABLENDENABLE
    0,                                                            //  43  D3DRENDERSTATE_BORDERCOLOR
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  44  D3DRENDERSTATE_TEXTUREADDRESSU
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  45  D3DRENDERSTATE_TEXTUREADDRESSV
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  46  D3DRENDERSTATE_MIPMAPLODBIAS
    CELSIUS_DIRTY_MISC_STATE,                                     //  47  D3DRENDERSTATE_ZBIAS
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  48  D3DRENDERSTATE_RANGEFOGENABLE
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  49  D3DRENDERSTATE_ANISOTROPY
    0,                                                            //  50  D3DRENDERSTATE_FLUSHBATCH
    0,                                                            //  51  D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT
    (CELSIUS_DIRTY_CONTROL0 | CELSIUS_DIRTY_MISC_STATE),          //  52  D3DRENDERSTATE_STENCILENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  53  D3DRENDERSTATE_STENCILFAIL
    CELSIUS_DIRTY_MISC_STATE,                                     //  54  D3DRENDERSTATE_STENCILZFAIL
    CELSIUS_DIRTY_MISC_STATE,                                     //  55  D3DRENDERSTATE_STENCILPASS
    CELSIUS_DIRTY_MISC_STATE,                                     //  56  D3DRENDERSTATE_STENCILFUNC
    CELSIUS_DIRTY_MISC_STATE,                                     //  57  D3DRENDERSTATE_STENCILREF
    CELSIUS_DIRTY_MISC_STATE,                                     //  58  D3DRENDERSTATE_STENCILMASK
    CELSIUS_DIRTY_MISC_STATE,                                     //  59  D3DRENDERSTATE_STENCILWRITEMASK
    CELSIUS_DIRTY_MISC_STATE,                                     //  60  D3DRENDERSTATE_TEXTUREFACTOR
    0,                                                            //  61  D3DRENDERSTATE_EVICTMANAGEDTEXTURES
    0,                                                            //  62  D3DRENDERSTATE_SCENECAPTURE
    0,                                                            //  63  invalid
    0,                                                            //  64  D3DRENDERSTATE_STIPPLEPATTERN00
    0,                                                            //  65  D3DRENDERSTATE_STIPPLEPATTERN01
    0,                                                            //  66  D3DRENDERSTATE_STIPPLEPATTERN02
    0,                                                            //  67  D3DRENDERSTATE_STIPPLEPATTERN03
    0,                                                            //  68  D3DRENDERSTATE_STIPPLEPATTERN04
    0,                                                            //  69  D3DRENDERSTATE_STIPPLEPATTERN05
    0,                                                            //  70  D3DRENDERSTATE_STIPPLEPATTERN06
    0,                                                            //  71  D3DRENDERSTATE_STIPPLEPATTERN07
    0,                                                            //  72  D3DRENDERSTATE_STIPPLEPATTERN08
    0,                                                            //  73  D3DRENDERSTATE_STIPPLEPATTERN09
    0,                                                            //  74  D3DRENDERSTATE_STIPPLEPATTERN10
    0,                                                            //  75  D3DRENDERSTATE_STIPPLEPATTERN11
    0,                                                            //  76  D3DRENDERSTATE_STIPPLEPATTERN12
    0,                                                            //  77  D3DRENDERSTATE_STIPPLEPATTERN13
    0,                                                            //  78  D3DRENDERSTATE_STIPPLEPATTERN14
    0,                                                            //  79  D3DRENDERSTATE_STIPPLEPATTERN15
    0,                                                            //  80  D3DRENDERSTATE_STIPPLEPATTERN16
    0,                                                            //  81  D3DRENDERSTATE_STIPPLEPATTERN17
    0,                                                            //  82  D3DRENDERSTATE_STIPPLEPATTERN18
    0,                                                            //  83  D3DRENDERSTATE_STIPPLEPATTERN19
    0,                                                            //  84  D3DRENDERSTATE_STIPPLEPATTERN20
    0,                                                            //  85  D3DRENDERSTATE_STIPPLEPATTERN21
    0,                                                            //  86  D3DRENDERSTATE_STIPPLEPATTERN22
    0,                                                            //  87  D3DRENDERSTATE_STIPPLEPATTERN23
    0,                                                            //  88  D3DRENDERSTATE_STIPPLEPATTERN24
    0,                                                            //  89  D3DRENDERSTATE_STIPPLEPATTERN25
    0,                                                            //  90  D3DRENDERSTATE_STIPPLEPATTERN26
    0,                                                            //  91  D3DRENDERSTATE_STIPPLEPATTERN27
    0,                                                            //  92  D3DRENDERSTATE_STIPPLEPATTERN28
    0,                                                            //  93  D3DRENDERSTATE_STIPPLEPATTERN29
    0,                                                            //  94  D3DRENDERSTATE_STIPPLEPATTERN30
    0,                                                            //  95  D3DRENDERSTATE_STIPPLEPATTERN31
    0,                                                            //  96  invalid
    0,                                                            //  97  invalid
    0,                                                            //  98  invalid
    0,                                                            //  99  invalid
    0,                                                            //  100 invalid
    0,                                                            //  101 invalid
    0,                                                            //  102 invalid
    0,                                                            //  103 invalid
    0,                                                            //  104 invalid
    0,                                                            //  105 invalid
    0,                                                            //  106 invalid
    0,                                                            //  107 invalid
    0,                                                            //  108 invalid
    0,                                                            //  109 invalid
    0,                                                            //  110 invalid
    0,                                                            //  111 invalid
    0,                                                            //  112 invalid
    0,                                                            //  113 invalid
    0,                                                            //  114 invalid
    0,                                                            //  115 invalid
    0,                                                            //  116 invalid
    0,                                                            //  117 invalid
    0,                                                            //  118 invalid
    0,                                                            //  119 invalid
    0,                                                            //  120 invalid
    0,                                                            //  121 invalid
    0,                                                            //  122 invalid
    0,                                                            //  123 invalid
    0,                                                            //  124 invalid
    0,                                                            //  125 invalid
    0,                                                            //  126 invalid
    0,                                                            //  127 invalid
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  128 D3DRENDERSTATE_WRAP0
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  129 D3DRENDERSTATE_WRAP1
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  130 D3DRENDERSTATE_WRAP2
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  131 D3DRENDERSTATE_WRAP3
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  132 D3DRENDERSTATE_WRAP4
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  133 D3DRENDERSTATE_WRAP5
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  134 D3DRENDERSTATE_WRAP6
    (CELSIUS_DIRTY_TL_MODE | CELSIUS_DIRTY_TEXTURE_STATE),        //  135 D3DRENDERSTATE_WRAP7
    0,                                                            //  136 D3DRENDERSTATE_CLIPPING
    CELSIUS_DIRTY_LIGHTS,                                         //  137 D3DRENDERSTATE_LIGHTING
    0,                                                            //  138 D3DRENDERSTATE_EXTENTS
    CELSIUS_DIRTY_LIGHTS,                                         //  139 D3DRENDERSTATE_AMBIENT
    CELSIUS_DIRTY_SPECFOG_COMBINER,                               //  140 D3DRENDERSTATE_FOGVERTEXMODE
    CELSIUS_DIRTY_LIGHTS,                                         //  141 D3DRENDERSTATE_COLORVERTEX
    CELSIUS_DIRTY_LIGHTS,                                         //  142 D3DRENDERSTATE_LOCALVIEWER
    CELSIUS_DIRTY_TRANSFORM,                                      //  143 D3DRENDERSTATE_NORMALIZENORMALS
    0,                                                            //  144 D3DRENDERSTATE_COLORKEYBLENDENABLE
    CELSIUS_DIRTY_LIGHTS,                                         //  145 D3DRENDERSTATE_DIFFUSEMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  146 D3DRENDERSTATE_SPECULARMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  147 D3DRENDERSTATE_AMBIENTMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  148 D3DRENDERSTATE_EMISSIVEMATERIALSOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  149 D3DRENDERSTATE_ALPHASOURCE
    CELSIUS_DIRTY_LIGHTS,                                         //  150 D3DRENDERSTATE_FOGFACTORSOURCE
    (CELSIUS_DIRTY_MISC_STATE | CELSIUS_DIRTY_TRANSFORM),         //  151 D3DRENDERSTATE_VERTEXBLEND
    CELSIUS_DIRTY_TEXTURE_STATE,                                  //  152 D3DRENDERSTATE_CLIPPLANEENABLE
    0,                                                            //  153 D3DRENDERSTATE_SOFTWAREVEXTEXPROCESSING
    CELSIUS_DIRTY_MISC_STATE,                                     //  154 D3DRENDERSTATE_POINTSIZE
    CELSIUS_DIRTY_MISC_STATE,                                     //  155 D3DRENDERSTATE_POINTSIZEMIN
    CELSIUS_DIRTY_MISC_STATE | CELSIUS_DIRTY_TEXTURE_STATE,       //  156 D3DRENDERSTATE_POINTSPRITEENABLE
    CELSIUS_DIRTY_MISC_STATE | CELSIUS_DIRTY_TEXTURE_STATE,       //  157 D3DRENDERSTATE_POINTSCALEENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  158 D3DRENDERSTATE_POINTSCALEA
    CELSIUS_DIRTY_MISC_STATE,                                     //  159 D3DRENDERSTATE_POINTSCALEB
    CELSIUS_DIRTY_MISC_STATE,                                     //  150 D3DRENDERSTATE_POINTSCALEC
    0,                                                            //  161 D3DRENDERSTATE_MULTISAMPLEAA
    0,                                                            //  162 D3DRENDERSTATE_MULTISAMPLEMASK
    0,                                                            //  163 D3DRENDERSTATE_COLORKEYMASK
    0,                                                            //  164 D3DRS_PATCHSEGMENTS
    0,                                                            //  165 D3DRS_DEBUGMONITORTOKEN
    0,                                                            //  166 D3DRS_POINTSIZE_MAX
    0,                                                            //  167 D3DRS_INDEXEDVERTEXBLENDENABLE
    CELSIUS_DIRTY_MISC_STATE,                                     //  168 D3DRS_COLORWRITEENABLE
    0,                                                            //  169 invalid
    0,                                                            //  170 D3DRS_TWEENFACTOR
    CELSIUS_DIRTY_MISC_STATE,                                     //  171 D3DRS_BLENDOP
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d texture stage state and celsius state.

// celsiusDirtyBitsFromTextureStageState[D3DTSS_FOO] contains the celsius class
// dirty bits that should be set whenever D3DTSS_FOO is changed

DWORD celsiusDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1] =
{
    CELSIUS_DIRTY_TEXTURE_STATE | CELSIUS_DIRTY_TEXTURE_TRANSFORM | //  0  D3DTSS_TEXTUREMAP
    CELSIUS_DIRTY_COMBINERS,
    CELSIUS_DIRTY_TEXTURE_TRANSFORM | CELSIUS_DIRTY_COMBINERS,      //  1  D3DTSS_COLOROP
    CELSIUS_DIRTY_COMBINERS,                                        //  2  D3DTSS_COLORARG1
    CELSIUS_DIRTY_COMBINERS,                                        //  3  D3DTSS_COLORARG2
    CELSIUS_DIRTY_COMBINERS,                                        //  4  D3DTSS_ALPHAOP
    CELSIUS_DIRTY_COMBINERS,                                        //  5  D3DTSS_ALPHAARG1
    CELSIUS_DIRTY_COMBINERS,                                        //  6  D3DTSS_ALPHAARG2
    0,                                                              //  7  D3DTSS_BUMPENVMAT00
    0,                                                              //  8  D3DTSS_BUMPENVMAT01
    0,                                                              //  9  D3DTSS_BUMPENVMAT10
    0,                                                              //  10 D3DTSS_BUMPENVMAT11
    CELSIUS_DIRTY_TEXTURE_TRANSFORM | CELSIUS_DIRTY_TEXTURE_STATE | //  11 D3DTSS_TEXCOORDINDEX
    CELSIUS_DIRTY_FVF | CELSIUS_DIRTY_TL_MODE,
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  12 D3DTSS_ADDRESS
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  13 D3DTSS_ADDRESSU
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  14 D3DTSS_ADDRESSV
    0,                                                              //  15 D3DTSS_BORDERCOLOR
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  16 D3DTSS_MAGFILTER
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  17 D3DTSS_MINFILTER
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  18 D3DTSS_MIPFILTER
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  19 D3DTSS_MIPMAPLODBIAS
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  20 D3DTSS_MAXMIPLEVEL
    CELSIUS_DIRTY_TEXTURE_STATE,                                    //  21 D3DTSS_MAXANISOTROPY
    0,                                                              //  22 D3DTSS_BUMPENVLSCALE
    0,                                                              //  23 D3DTSS_BUMPENVLOFFSET
    CELSIUS_DIRTY_TEXTURE_TRANSFORM,                                //  24 D3DTSS_TEXTURETRANSFORMFLAGS
    0,                                                              //  25 D3DTSS_ADDRESSW
    CELSIUS_DIRTY_COMBINERS,                                        //  26 D3DTSS_COLORARG0
    CELSIUS_DIRTY_COMBINERS,                                        //  27 D3DTSS_ALPHAARG0
    CELSIUS_DIRTY_COMBINERS                                         //  28 D3DTSS_RESULTARG
};

//---------------------------------------------------------------------------

// table mapping dp2ops to the celsius method values associated with them.
// these are defined in term of NV056_SET_BEGIN_END_OP_X but the same values
// are used for all enumerants of type NV056_SET_BEGIN_ENDX_OP_X

DWORD celsiusBeginEndOp[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    NV056_SET_BEGIN_END_OP_POINTS,               //   1  D3DDP2OP_POINTS
    NV056_SET_BEGIN_END_OP_LINES,                //   2  D3DDP2OP_INDEXEDLINELIST
    NV056_SET_BEGIN_END_OP_TRIANGLES,            //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    NV056_SET_BEGIN_END_OP_LINES,                //  15  D3DDP2OP_LINELIST
    NV056_SET_BEGIN_END_OP_LINE_STRIP,           //  16  D3DDP2OP_LINESTRIP
    NV056_SET_BEGIN_END_OP_LINE_STRIP,           //  17  D3DDP2OP_INDEXEDLINESTRIP
    NV056_SET_BEGIN_END_OP_TRIANGLES,            //  18  D3DDP2OP_TRIANGLELIST
    NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  19  D3DDP2OP_TRIANGLESTRIP
    NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NV056_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  21  D3DDP2OP_TRIANGLEFAN
    NV056_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NV056_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NV056_SET_BEGIN_END_OP_LINES,                //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    NV056_SET_BEGIN_END_OP_TRIANGLES,            //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NV056_SET_BEGIN_END_OP_LINES,                //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// table mapping dp2ops to the scale and bias required to calculate the number
// of vertices from the number of primitives. the scale is in the upper half
// of the word and the bias is in the lower.
// numVertices = scale * numPrimitives + bias

DWORD celsiusPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010100,                                  //   1  D3DDP2OP_POINTS
    0x00020200,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030300,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020200,                                  //  15  D3DDP2OP_LINELIST
    0x00020101,                                  //  16  D3DDP2OP_LINESTRIP
    0x00020101,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030300,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x40030102,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x40030102,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x80030102,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x80030102,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x80030102,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020200,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030300,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020200,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// table mapping dp2ops to a name humans understand

#ifdef DEBUG
char* celsiusPrimitiveName[D3D_DP2OP_MAX+1] =
{
    "oops",                                      //   0  invalid
    "points",                                    //   1  D3DDP2OP_POINTS
    "indexed line list",                         //   2  D3DDP2OP_INDEXEDLINELIST
    "indexed tri list",                          //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    "oops",                                      //   4  invalid
    "oops",                                      //   5  invalid
    "oops",                                      //   6  invalid
    "oops",                                      //   7  invalid
    "oops",                                      //   8  D3DDP2OP_RENDERSTATE
    "oops",                                      //   9  invalid
    "oops",                                      //  10  invalid
    "oops",                                      //  11  invalid
    "oops",                                      //  12  invalid
    "oops",                                      //  13  invalid
    "oops",                                      //  14  invalid
    "line list",                                 //  15  D3DDP2OP_LINELIST
    "line strip",                                //  16  D3DDP2OP_LINESTRIP
    "indexed line strip",                        //  17  D3DDP2OP_INDEXEDLINESTRIP
    "tri list",                                  //  18  D3DDP2OP_TRIANGLELIST
    "tri strip",                                 //  19  D3DDP2OP_TRIANGLESTRIP
    "indexed tri strip",                         //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    "tri fan",                                   //  21  D3DDP2OP_TRIANGLEFAN
    "indexed tri fan",                           //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    "tri fan imm",                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    "line list imm",                             //  24  D3DDP2OP_LINELIST_IMM
    "oops",                                      //  25  D3DDP2OP_TEXTURESTAGESTATE
    "indexed tri list 2",                        //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    "indexed line list 2",                       //  27  D3DDP2OP_INDEXEDLINELIST2
    "oops",                                      //  28  D3DDP2OP_VIEWPORTINFO
    "oops",                                      //  29  D3DDP2OP_WINFO
    "oops",                                      //  30  D3DDP2OP_SETPALETTE
    "oops",                                      //  31  D3DDP2OP_UPDATEPALETTE
    "oops",                                      //  32  D3DDP2OP_ZRANGE
    "oops",                                      //  33  D3DDP2OP_SETMATERIAL
    "oops",                                      //  34  D3DDP2OP_SETLIGHT
    "oops",                                      //  35  D3DDP2OP_CREATELIGHT
    "oops",                                      //  36  D3DDP2OP_SETTRANSFORM
    "oops",                                      //  37  D3DDP2OP_EXT
    "oops",                                      //  38  D3DDP2OP_TEXBLT
    "oops",                                      //  39  D3DDP2OP_STATESET
    "oops",                                      //  40  D3DDP2OP_SETPRIORITY
    "oops",                                      //  41  D3DDP2OP_SETRENDERTARGET
    "oops",                                      //  42  D3DDP2OP_CLEAR
    "oops",                                      //  43  D3DDP2OP_SETTEXLOD
    "oops"                                       //  44  D3DDP2OP_SETCLIPPLANE
};
#endif

// table needed to dispatch the right method for vertex shaders
// [] . .  stream  - ie vertex vs diffuse
// . [] .  data type  - ie XYZ vs XYZW
// . . [0] method name
// . . [1] param count (popcount of second index)
DWORD dwCelsiusMethodDispatch[11][16][2] = {
        // 0 vertex
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        NV056_SET_VERTEX3F(0),         3, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        NV056_SET_VERTEX3F(0),         3, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_VERTEX4F(0),         4, // 15 xyzw

        // 1 diffuse
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        NV056_SET_DIFFUSE_COLOR3F(0),  3, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        NV056_SET_DIFFUSE_COLOR3F(0),  3, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_DIFFUSE_COLOR4F(0),  4, // 15 xyzw

        // 2 specular
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        NV056_SET_SPECULAR_COLOR3F(0), 3, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        NV056_SET_SPECULAR_COLOR3F(0), 3, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_SPECULAR_COLOR4F(0), 4, // 15 xyzw

        // 3 backfacing diffuse - unused
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 4 backfacing specular - unused
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 5 fog
        0xDEADBEEF,                    0, //  0 none
        NV056_SET_FOG1F,               1, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 6 point size
        0xDEADBEEF,                    0, //  0 none
        NV056_SET_POINT_SIZE,          1, //  1 x
        0xDEADBEEF,                    0, //  2  y
        0xDEADBEEF,                    0, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        0xDEADBEEF,                    0, //  5 x z
        0xDEADBEEF,                    0, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        0xDEADBEEF,                    0, //  9 x  w
        0xDEADBEEF,                    0, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        0xDEADBEEF,                    0, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        0xDEADBEEF,                    0, // 15 xyzw

        // 7 texture 0
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        NV056_SET_TEXCOORD0_2F(0),     2, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        NV056_SET_TEXCOORD0_2F(0),     2, //  5 x z
        NV056_SET_TEXCOORD0_2F(0),     2, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        NV056_SET_TEXCOORD0_2F(0),     2, //  9 x  w
        NV056_SET_TEXCOORD0_2F(0),     2, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        NV056_SET_TEXCOORD0_2F(0),     2, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_TEXCOORD0_4F(0),     4, // 15 xyzw

        // 8 texture 1
        0xDEADBEEF,                    0, //  0 none
        0xDEADBEEF,                    0, //  1 x
        0xDEADBEEF,                    0, //  2  y
        NV056_SET_TEXCOORD1_2F(0),     2, //  3 xy
        0xDEADBEEF,                    0, //  4   z
        NV056_SET_TEXCOORD1_2F(0),     2, //  5 x z
        NV056_SET_TEXCOORD1_2F(0),     2, //  6  yz
        0xDEADBEEF,                    0, //  7 xyz
        0xDEADBEEF,                    0, //  8    w
        NV056_SET_TEXCOORD1_2F(0),     2, //  9 x  w
        NV056_SET_TEXCOORD1_2F(0),     2, // 10  y w
        0xDEADBEEF,                    0, // 11 xy w
        NV056_SET_TEXCOORD1_2F(0),     2, // 12   zw
        0xDEADBEEF,                    0, // 13 x zw
        0xDEADBEEF,                    0, // 14  yzw
        NV056_SET_TEXCOORD1_4F(0),     4, // 15 xyzw
};

#endif  // NVARCH >= 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusVbPrim.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusVbPrim.cpp                                               *
*       indexed and ordered vb primitives                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             20Oct99         NV10 optimization effort    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"
#if (NVARCH >= 0x10)

#include "x86.h"

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                      (DWORD reg,DWORD num);
void nvCelsiusILCompile_beginEnd              (DWORD dwPrimType);
void nvCelsiusILCompile_computeIndexAndOffset (DWORD dwVBStride,DWORD dwVBLogStride);
void nvCelsiusILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvCelsiusILCompile_indexcpy               (DWORD dwCount);
void nvCelsiusILCompile_copyVertex            (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvCelsiusILCompile_prefetch              (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvCelsiusILCompile_limit                 (DWORD regLimit,DWORD regDummy);

void __stdcall nvCelsiusDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvCelsiusDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvCelsiusDispatchFlush          (void);
void __stdcall nvCelsiusDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

//---------------------------------------------------------------------------

// vb primitive

DWORD nvCelsiusILCompile_vb_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    DWORD  dwMagic                = celsiusPrimitiveToPrimitiveMagic[dwFlags & CELSIUS_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & CELSIUS_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_IX_VB_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.celsius.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // start prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
    xMOV_rm_imm (rmREG(rECX),celsiusBeginEndOp[dwFlags & CELSIUS_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // do work
    //
    if (bIsIndexed)
    {
        //
        // indexed VB
        //

        //
        // setup prefetcher
        //
        xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
        ILCCompile_mul (rEBX,bLegacyStrides ? 4 : dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }
        xLEA_r_rm   (rECX,rmSIB) xSIB(rEBX,rEBX,x1)

        xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
        xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEAX)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchMax),rECX)

        //
        // send indices
        //
        xMOV_r_i32  (rESI,mMEM32(global.celsius.pIndices))
        DWORD labelNext;
        xLABEL      (labelNext)

        //
        // prefetch
        //
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        xMOV_r_i32  (rEDX,mMEM32(global.celsius.dwPrefetchBase))
        xCMP_r_rm   (rEDX,rmREG(rESI))
        xLABEL      (labelPrefetch1)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / 32)
        xLABEL      (labelPrefetch2)
        {
            xCMP_r_i32  (rEDX,mMEM32(global.celsius.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            xDEC_rm     (rmREG(rECX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(32)
            xJNZ32      (labelPrefetch2)
        }
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.celsius.dwPrefetchBase),rEDX)
        xTARGET_b32 (labelPrefetch1)

        //
        // copy indices
        //
        if (bLegacyStrides)
        {
            //
            // legacy - pretty simple since it MUST be a tri list
            //          source = index0:16,index1:16,index2:16,flags:16
            //
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(4)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(8)
            xMOV_r_rm   (rEBP,rmREG(rEAX))
            xAND_rm_imm (rmREG(rEAX),0xffff)
            xADD_r_i32  (rEAX, mMEM32(global.celsius.dwBaseVertex) ) //add base index
            xMOV_rm_imm (rmREG(rEDX),((((3) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT32(0)))))
            xSHR_rm_imm8(rmREG(rEBP),16)
            xADD_r_i32  (rEBP, mMEM32(global.celsius.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND(rEDI),rEDX)
            xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(16)
            xAND_rm_imm (rmREG(rECX),0xffff)
            xADD_r_i32  (rECX, mMEM32(global.celsius.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(8 - 16)
            xSUB_rm_imm (rmREG(rEBX),4)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(12 - 16)
            // next tri
            xJNZ32      (labelNext)
        }
        else
        {
            //
            // do a 64 index batch
            //
            DWORD labelCopy0;
            xCMP_rm_imm (rmREG(rEBX),64)
            xLABEL      (labelCopy0)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((32) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT16(0)))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)
                
                nvCelsiusILCompile_indexcpy (128);

                // check for pusher space
                DWORD labelSpace;
                xMOV_r_i32  (rEDX,mMEM32(pDriverData))
                xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
                xLABEL      (labelSpace)
                xJL         (0)
                {
                    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
                    xPUSH_r     (rEDX)
                    xCALL_rm    (rmREG(rEAX))
                    xPOP_r      (rEDX)
                    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                }
                xTARGET_b8  (labelSpace)

                xSUB_rm_imm (rmREG(rEBX),64)
                xJMP        (labelNext)
            }
            xTARGET_b32 (labelCopy0) // back to prefetch

            //
            // do a 16 index batch
            //
            DWORD labelCopy1;
            xCMP_rm_imm (rmREG(rEBX),16)
            xLABEL      (labelCopy1)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((8) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT16(0)))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvCelsiusILCompile_indexcpy (32);

                xSUB_rm_imm (rmREG(rEBX),16)
                xJMP        (labelNext) // back to prefetch
            }
            xTARGET_b32 (labelCopy1)

            //
            // do a 4 index batch
            //
            DWORD labelCopy2,labelNext2;
            xLABEL      (labelNext2)
            xCMP_rm_imm (rmREG(rEBX),4)
            xLABEL      (labelCopy2)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((2) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT16(0)))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvCelsiusILCompile_indexcpy (8);

                xSUB_rm_imm (rmREG(rEBX),4)
                xJMP        (labelNext2)
            }
            xTARGET_b32 (labelCopy2)

            //
            // do a single index
            //
            DWORD labelCopy3,labelNext3;
            xOR_r_rm    (rEBX,rmREG(rEBX))
            xLABEL      (labelCopy3)
            xJZ32       (0)
            xMOV_rm_imm (rmREG(rEDX),8)
            xLABEL      (labelNext3)
            {
                xXOR_r_rm   (rECX,rmREG(rECX))
                xMOV_rm_imm (rmREG(rEAX),((((1) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT32(0)))))
           x16r xMOV_r_rm   (rCX,rmIND(rESI))
                xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xADD_r_rm   (rEDI,rmREG(rEDX))
                xADD_r_i32  (rECX, mMEM32(global.celsius.dwBaseVertex) ) //add base index
                xDEC_rm     (rmREG(rEBX))
                xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                xJNZ32      (labelNext3)
            }
            xTARGET_b32 (labelCopy3)
        }
    }
    else
    {
        //
        // ordered VB
        //

        //
        // compute how many vertices to send
        //
        xMOV_r_i32  (rEBX,mMEM32(global.celsius.dwPrimCount))
        ILCCompile_mul (rEBX,dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }

        //
        // actually use base vertex
        //
        xMOV_r_i32  (rESI,mMEM32(global.celsius.dwBaseVertex))
        //
        // send
        //
        DWORD labelNext1;
        DWORD labelNext3;
        xLABEL      (labelNext3)
        xCMP_rm_imm (rmREG(rEBX),256)
        xLABEL      (labelNext1)
        xJB32       (0)
        {
            // send 128 vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_DRAW_ARRAYS(0)))
            xMOV_rm_r   (rmREG(rECX),rESI)
            // xSHL_rm_imm (rmREG(rECX),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_imm  (rmREG(rECX),DRF_NUM(056, _DRAW_ARRAYS, _COUNT, (256 - 1)))
            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xSUB_rm_imm (rmREG(rEBX),256)  // decrement the vertex counter
            xADD_rm_imm (rmREG(rESI),256)  // increment the index counter

            // check for pusher space
            xMOV_r_i32  (rEDX,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
            xJL32       (labelNext3)
            {
                xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
                xPUSH_r     (rEDX)
                xCALL_rm    (rmREG(rEAX))
                xPOP_r      (rEDX)
                xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            }
            xJMP        (labelNext3)
        }
        xTARGET_b32     (labelNext1)

        DWORD labelNext2;
        xOR_r_rm        (rEBX,rmREG(rEBX))
        xLABEL          (labelNext2)
        xJZ32           (0)
        {
            // send rest of vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_DRAW_ARRAYS(0)))
            xDEC_rm     (rmREG(rEBX))
            xSHL_rm_imm8(rmREG(rEBX),0 ? NV056_DRAW_ARRAYS_COUNT)
            // xSHL_rm_imm (rmREG(rESI),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_r    (rmREG(rEBX),rESI)

            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
        }
        xTARGET_b32     (labelNext2)
    }

    //
    // end prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
    xMOV_rm_imm (rmREG(rECX),NV056_SET_BEGIN_END3_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    // check for pusher space
    DWORD labelSpace;
    xMOV_r_i32  (rESI,mMEM32(pDriverData))
    xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
    xLABEL      (labelSpace)
    xJL         (0)
    {
        xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        xMOV_rm_imm (rmREG(rEAX),(DWORD)nvCelsiusDispatchGetPusherSpace)
        xCALL_rm    (rmREG(rEAX))
        xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    }
    xTARGET_b8  (labelSpace)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusStateHelp.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusStateHelp.cpp                                            *
*       Celsius state management helper routines.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        26May99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "nvCelsiusCaps.h"

//---------------------------------------------------------------------------

// this function comes from erik.

static float lar[32] =
{
     0.000000f,  // error=0.687808
    -0.023353f,  // error=0.070106
    -0.095120f,  // error=0.010402
    -0.170208f,  // error=0.016597
    -0.251038f,  // error=0.021605
    -0.336208f,  // error=0.025186
    -0.421539f,  // error=0.027635
    -0.503634f,  // error=0.029262
    -0.579592f,  // error=0.030311
    -0.647660f,  // error=0.030994
    -0.708580f,  // error=0.031427
    -0.760208f,  // error=0.031702
    -0.803673f,  // error=0.031889
    -0.840165f,  // error=0.031995
    -0.871344f,  // error=0.032067
    -0.896105f,  // error=0.032105
    -0.916457f,  // error=0.032139
    -0.933262f,  // error=0.032165
    -0.946507f,  // error=0.032173
    -0.957755f,  // error=0.032285
    -0.966165f,  // error=0.032230
    -0.972848f,  // error=0.032189
    -0.978413f,  // error=0.032191
    -0.983217f,  // error=0.032718
    -0.986471f,  // error=0.032289
    -0.988778f,  // error=0.033091
    -0.991837f,  // error=0.035067
    -0.993452f,  // error=0.034156
    -0.994839f,  // error=0.034863
    -0.995434f,  // error=0.034785
    -0.996690f,  // error=0.033426
    -1.000000f
};

static float mar[32] =
{
    -0.494592f,  // error=0.687808
    -0.494592f,  // error=0.070106
    -0.570775f,  // error=0.010402
    -0.855843f,  // error=0.016597
    -1.152452f,  // error=0.021605
    -1.436778f,  // error=0.025186
    -1.705918f,  // error=0.027635
    -1.948316f,  // error=0.029262
    -2.167573f,  // error=0.030311
    -2.361987f,  // error=0.030994
    -2.512236f,  // error=0.031427
    -2.652873f,  // error=0.031702
    -2.781295f,  // error=0.031889
    -2.890906f,  // error=0.031995
    -2.938739f,  // error=0.032067
    -3.017491f,  // error=0.032105
    -3.077762f,  // error=0.032139
    -3.099087f,  // error=0.032165
    -3.144977f,  // error=0.032173
    -3.100986f,  // error=0.032285
    -3.151608f,  // error=0.032230
    -3.212636f,  // error=0.032189
    -3.219419f,  // error=0.032191
    -3.079402f,  // error=0.032718
    -3.174922f,  // error=0.032289
    -3.469706f,  // error=0.033091
    -2.895668f,  // error=0.035067
    -2.959919f,  // error=0.034156
    -2.917150f,  // error=0.034863
    -3.600301f,  // error=0.034785
    -3.024990f,  // error=0.033426
    -3.300000f
};

#define LOG_64F    4.15888308336f
#define INV_LOG_2F 1.44269504089f

void explut (float n, float *l, float *m)
{
    float idx,f,a;
    long  i;

    if (n < 1.f) {
        a  = (n == 0.f) ? 0.f : (float)exp(-LOG_64F/n);
        *l = -a;
        *m = 1.f - (1.f-a)*n;
    }
    else {
        idx = 3.f * (float)log(n) * INV_LOG_2F;
        i = (long)idx;
        f = idx-i;

        *l = lar[i]*(1.f-f) + lar[i+1]*f;
        *m = mar[i]*(1.f-f) + mar[i+1]*f;
    }
}

//---------------------------------------------------------------------------

DWORD nvCelsiusBuildTSSMask (PNVD3DCONTEXT pContext, DWORD dwStage)
{
    PNVD3DTEXSTAGESTATE pTSS;
    DWORD dwMask, dwColorOp, dwAlphaOp;

    pTSS = &(pContext->tssState[dwStage]);
    dwColorOp = pTSS->dwValue[D3DTSS_COLOROP];
    dwAlphaOp = pTSS->dwValue[D3DTSS_ALPHAOP];

    dwMask = ( ((pTSS->dwValue[D3DTSS_TEXTUREMAP] != NULL) ? 0x80000000 : 0x0) |
               ((dwColorOp & 0x0000001f) << 26) |
               ((dwAlphaOp & 0x0000001f) << 10) );

    // don't bother with args unless op is not disable. this reduces
    // several otherwise inconsequentially distinct cases to one case
    switch (dwColorOp) {
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG1]) << 21);
            break;
        case D3DTOP_SELECTARG2:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG2]) << 16);
            break;
        default:
            dwMask |= ((NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG1]) << 21) |
                       (NVTSSARGMASK(pTSS->dwValue[D3DTSS_COLORARG2]) << 16));
            break;
    }

    switch (dwAlphaOp) {
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG1]) << 5);
            break;
        case D3DTOP_SELECTARG2:
            dwMask |= (NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG2]) << 0);
            break;
        default:
            dwMask |= ((NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG1]) << 5) |
                       (NVTSSARGMASK(pTSS->dwValue[D3DTSS_ALPHAARG2]) << 0));
            break;
    }

    //dwMask |= ((pTSS->dwValue[D3DTSS_RESULTARG] == D3DTA_CURRENT) ? 0 : 1) << 15; 

    return (dwMask);
}

//---------------------------------------------------------------------------

DWORD nvCelsiusCombinersGetHashIndex
(
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    DWORD dwIndex;

    // generate an index. until i think of something better,
    // just add the 8 bytes together and mask off the lower N bits
    dwIndex = ((dwTSSMask0 >>  0) & 0xff) +
              ((dwTSSMask0 >>  8) & 0xff) +
              ((dwTSSMask0 >> 16) & 0xff) +
              ((dwTSSMask0 >> 24) & 0xff) +
              ((dwTSSMask1 >>  0) & 0xff) +
              ((dwTSSMask1 >>  8) & 0xff) +
              ((dwTSSMask1 >> 16) & 0xff) +
              ((dwTSSMask1 >> 24) & 0xff);
    dwIndex &= CELSIUSCPTABLE_INDEXMASK;

    return (dwIndex);
}

//---------------------------------------------------------------------------

// lookup a combiner program in the hash table

PCELSIUSCOMBINERPROGRAM nvCelsiusCombinersLookupProgram
(
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    PCELSIUSCOMBINERPROGRAM pProgram;
    DWORD dwIndex;

    dwIndex  = nvCelsiusCombinersGetHashIndex (dwTSSMask0, dwTSSMask1);
    pProgram = global.celsiusCombinerProgramTable[dwIndex];

    while (pProgram) {
        if ((pProgram->dwTSSMask0 == dwTSSMask0) &&
            (pProgram->dwTSSMask1 == dwTSSMask1)) {
            return (pProgram);
        }
        pProgram = pProgram->pNext;
    }

    return (NULL);
}

//---------------------------------------------------------------------------

// attempt to set celsius combiners from the hash table.
// return TRUE if successful

BOOL nvCelsiusCombinersSetFromHashTable
(
    PNVD3DCONTEXT pContext,
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    PCELSIUSCOMBINERPROGRAM pProgram = nvCelsiusCombinersLookupProgram (dwTSSMask0, dwTSSMask1);

    if (pProgram) {
        // set celsius state from the program
        pContext->hwState.dwStateFlags                 &= ~CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS;
        pContext->hwState.dwStateFlags                 |= pProgram->dwStateFlags;
        pContext->hwState.dwColorICW[0]                 = pProgram->dwColorICW[0];
        pContext->hwState.dwColorOCW[0]                 = pProgram->dwColorOCW[0];
        pContext->hwState.dwAlphaICW[0]                 = pProgram->dwAlphaICW[0];
        pContext->hwState.dwAlphaOCW[0]                 = pProgram->dwAlphaOCW[0];
        pContext->hwState.dwColorICW[1]                 = pProgram->dwColorICW[1];
        pContext->hwState.dwColorOCW[1]                 = pProgram->dwColorOCW[1];
        pContext->hwState.dwAlphaICW[1]                 = pProgram->dwAlphaICW[1];
        pContext->hwState.dwAlphaOCW[1]                 = pProgram->dwAlphaOCW[1];
        pContext->hwState.dwTexUnitToTexStageMapping[0] = pProgram->dwTexUnitMapping[0];
        pContext->hwState.dwTexUnitToTexStageMapping[1] = pProgram->dwTexUnitMapping[1];
        pContext->hwState.dwNumActiveCombinerStages     = pProgram->dwNumActiveStages;
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//---------------------------------------------------------------------------

// add a combiner program to the hash table

void nvCelsiusCombinersAddProgramToHashTable
(
    PCELSIUSCOMBINERPROGRAM pProgram
)
{
    DWORD dwIndex;

    // make sure it's not already in the hash table (needed when using running apps)
    if (nvCelsiusCombinersLookupProgram (pProgram->dwTSSMask0, pProgram->dwTSSMask1)) {
        delete pProgram;
        return;
    }

    // hash out an index
    dwIndex = nvCelsiusCombinersGetHashIndex (pProgram->dwTSSMask0, pProgram->dwTSSMask1);

    // add the new program to the front of the list
    pProgram->pNext = global.celsiusCombinerProgramTable[dwIndex];
    global.celsiusCombinerProgramTable[dwIndex] = pProgram;
}

//---------------------------------------------------------------------------

// add the current combiner settings to the hash table as a new program.
// return true if successful.

BOOL nvCelsiusCombinersAddToHashTable
(
    PNVD3DCONTEXT pContext,
    DWORD dwTSSMask0,
    DWORD dwTSSMask1
)
{
    PCELSIUSCOMBINERPROGRAM pProgram;

/*    
#ifdef DEBUG
    // make sure it's not already in the hash table
    if (nvCelsiusCombinersLookupProgram (dwTSSMask0, dwTSSMask1)) {
        DPF ("nvCelsiusCombinersAddToHashTable: attempt to add something redundant");
        dbgD3DError();
    }
#endif
*/
    // create the program
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));

    if (!pProgram) {
        // couldn't get memory. just return
        DPF ("failure to allocate memory for combiner program hash table entry");
        dbgD3DError();
        return (FALSE);
    }

    pProgram->dwTSSMask0          = dwTSSMask0;
    pProgram->dwTSSMask1          = dwTSSMask1;
    pProgram->dwStateFlags        = pContext->hwState.dwStateFlags & CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS;
    pProgram->dwColorICW[0]       = pContext->hwState.dwColorICW[0];
    pProgram->dwColorOCW[0]       = pContext->hwState.dwColorOCW[0];
    pProgram->dwAlphaICW[0]       = pContext->hwState.dwAlphaICW[0];
    pProgram->dwAlphaOCW[0]       = pContext->hwState.dwAlphaOCW[0];
    pProgram->dwColorICW[1]       = pContext->hwState.dwColorICW[1];
    pProgram->dwColorOCW[1]       = pContext->hwState.dwColorOCW[1];
    pProgram->dwAlphaICW[1]       = pContext->hwState.dwAlphaICW[1];
    pProgram->dwAlphaOCW[1]       = pContext->hwState.dwAlphaOCW[1];
    pProgram->dwTexUnitMapping[0] = pContext->hwState.dwTexUnitToTexStageMapping[0];
    pProgram->dwTexUnitMapping[1] = pContext->hwState.dwTexUnitToTexStageMapping[1];
    pProgram->dwNumActiveStages   = pContext->hwState.dwNumActiveCombinerStages;

    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    return (TRUE);
}

//---------------------------------------------------------------------------

#define CELSIUS_VALIDATE_FAIL(reason)   \
{                                       \
    pvtssd->dwNumPasses = 0xffffffff;   \
    pvtssd->ddrval = reason;            \
    dbgTracePop();                      \
    return (DDHAL_DRIVER_HANDLED);      \
}

//---------------------------------------------------------------------------

DWORD nvCelsiusValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    DWORD dwHWStage, dwD3DStage;

    dbgTracePush ("nvCelsiusValidateTextureStageState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pvtssd);

    // update everything
    pContext->hwState.dwDirtyFlags = CELSIUS_DIRTY_REALLY_FILTHY;
    nvSetCelsiusState (pContext);

    // make sure the setup went smoothly
    if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_SETUPFAILURE) {
        CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
    }

#ifndef CELSIUS_NVCOMBINER
    // make sure we don't have more than two texture stages in use
    DWORD dwStageCount = 0;
    if (!pContext->bUseTBlendSettings) {
        while ((dwStageCount < 8) && (pContext->tssState[dwStageCount].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)) {
            dwStageCount++;
        }
        if (dwStageCount > CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES) {
            CELSIUS_VALIDATE_FAIL (D3DERR_TOOMANYOPERATIONS);
        }
    }
#endif

    // count free stages
    DWORD dwFreeStages = 0;
    for (dwHWStage = 0; dwHWStage < 2; dwHWStage++) {
        // which D3D stage is handled by this HW stage
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage == CELSIUS_UNUSED) {
            dwFreeStages++;
        }
    }

    // check clip planes
    DWORD dwClipPlaneEnable = pContext->dwRenderState[D3DRENDERSTATE_CLIPPLANEENABLE];
    DWORD dwClipPlaneCount = 0;

    // count the planes
    while (dwClipPlaneEnable) {
        if (dwClipPlaneEnable & 0x1) dwClipPlaneCount++;
        dwClipPlaneEnable >>= 1;
    }

    if (dwClipPlaneCount > 2*dwFreeStages) {
        CELSIUS_VALIDATE_FAIL (D3DERR_TOOMANYOPERATIONS);
    }

    // verify texture transform
    for (dwHWStage=0; dwHWStage < 2; dwHWStage++) {

        DWORD dwTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwHWStage];

        if (dwTexUnitStatus == CELSIUS_TEXUNITSTATUS_USER) {

            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

            DWORD dwOutCount = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] & 0xff;
            BOOL  bXForm     = (dwOutCount != D3DTTFF_DISABLE);

            DWORD dwTexgenMode = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            BOOL  bTexgen      = (dwTexgenMode != D3DTSS_TCI_PASSTHRU);

            if ((bXForm || bTexgen) &&
                (pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) &&
                (!pContext->pCurrentVShader->hasProgram()))
            {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }

        }

        // check for cube maps and w-buffering
        if (pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage] != CELSIUS_UNUSED) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            if (dwD3DStage != CELSIUS_UNUSED) {
                PNVD3DTEXSTAGESTATE pTSSState = &(pContext->tssState[dwD3DStage]);
                CTexture* pTexture = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
                DWORD dwZEnable = pContext->pZetaBuffer ? pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] : 0;
                if (pTexture->isCubeMap() && (dwZEnable == D3DZB_USEW)) {
                    CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
                }
            }

        }

    }

    // verify color material
    if (pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]) {

        if (pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE] == D3DMCS_COLOR2) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }
        }

        if (pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE] == D3DMCS_COLOR2) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }
        }

        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE] == D3DMCS_COLOR1) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                    // if vertex specular is valid, enabling NV056_SET_COLOR_MATERIAL_SPECULAR
                    // will make the HW pull material specular from the vertex specular,
                    // NOT vertex diffuse as desired.
                    CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
                }
            }
        }

        if (pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE] == D3DMCS_COLOR2) {
            if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
            }
        }

    }

    // check lights
    if (GET_LIGHTING_STATE(pContext) && (!(pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE))) {

        DWORD    dwNumLights = 0;
        pnvLight pLight = pContext->lighting.pActiveLights;

        while (pLight) {
            dwNumLights++;
            pLight = pLight->pNext;
        }

        if (dwNumLights > 8) {
            CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
        }

    }

    // miscellaneous sanity checks (are these legit or should we just quietly tolerate such crap?)
    if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
        if ((pContext->pZetaBuffer == NULL) ||
            (pContext->pZetaBuffer->hasStencil() == FALSE)) {
            CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
        }
    }

    if (pContext->hwState.celsius.dwZEnable != D3DZB_FALSE) {
        if (pContext->pZetaBuffer == NULL) {
            CELSIUS_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
        }
    }

    // everything is kosher. get the number of passes and return OK
    pvtssd->dwNumPasses = 1;    // don't want this... implies multipass when it is not. pContext->hwState.celsius.dwNumActiveCombinerStages;
    pvtssd->ddrval      = D3D_OK;

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);


}
#endif  // NVARCH >= 0x010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\d3dDebug.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: d3dDebug.h
//      D3D-specific debugging routines
//
// **************************************************************************
//
//  History:
//      Chas Inman              18Nov97         original version
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************

#ifndef _NV3DDBG_H_
#define _NV3DDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------------------
// SHARED DEBUG CODE CONFIGURATION
//-------------------------------------------------------------------------

// override the defaults
#undef  DPF_START_STR
#define DPF_START_STR  "NVDD32: "

#undef  DPF_END_STR
#define DPF_END_STR    "\r\n"

#undef  DPF_LOG_FILE
#define DPF_LOG_FILE   "\\nvdd32.log"

// definitions for dbgLevel debug output level flags
#define NVDBG_LEVEL_ERROR               0x80000000
#define NVDBG_LEVEL_INFO                0x40000000
#define NVDBG_LEVEL_VERTEX_REUSE        0x20000000
#define NVDBG_LEVEL_COLORKEY_INFO       0x10000000
#define NVDBG_LEVEL_AA_INFO             0x08000000
#define NVDBG_LEVEL_FLIP                0x04000000
#define NVDBG_LEVEL_SURFACE             0x02000000  // shows info for CreateSurface, CreateSurfaceEx and DestroySurface
#define NVDBG_LEVEL_SURFACE_ACTIVITY    0x01000000  // shows surface activity
#define NVDBG_LEVEL_SURFACEALLOC        0x00800000  // print info about surface allocations
#define NVDBG_LEVEL_NVOBJ_INFO          0x00400000  // print reference/release access on CNVObjects
#define NVDBG_LEVEL_TEXMAN              0x00200000  // print info about texture fetches and evictions
#define NVDBG_LEVEL_HEAP_ACTIVITY       0x00100000  // print info about IPM heap activity
#define NVDBG_LEVEL_HEAP_USAGE          0x00080000  // print info about heap usage
#define NVDBG_LEVEL_PALETTE             0x00040000  // print info about palette usage
#define NVDBG_LEVEL_PERFORMANCE         0x00020000  // print performance issues
#define NVDBG_LEVEL_VSHADER_INFO        0x00010000  // print inner loop info about vertex shaders
#define NVDBG_LEVEL_VSHADER_IO          0x00008000  // print inner loop info about vertex shader input/output data
#define NVDBG_LEVEL_VSHADER_INS         0x00004000  // print vertex shader instructions
#define NVDBG_LEVEL_HOS_INFO            0x00002000  // print info on HOS processing
#define NVDBG_LEVEL_HOS_VERTEX_INFO     0x00001000  // print info on HOS vertex data
#define NVDBG_LEVEL_PIXEL_SHADER        0x00000800  // print pixel shader instructions (create info)
#define NVDBG_LEVEL_NV_AGP              0x00000400  // print info about nvidia managed AGP activity
#ifdef KPFS
#define NVDBG_LEVEL_VSHADER_MAN         0x00000200  // print info about the vertex shader manager
#endif

//-------------------------------------------------------------------------
// D3D DEBUG BITS
//-------------------------------------------------------------------------

// Bit definitions for the dbgShowState debug flags
#define NVDBG_SHOW_RENDER_STATE         0x80000000
#define NVDBG_SHOW_DX5_CLASS_STATE      0x40000000
#define NVDBG_SHOW_SURFACE_STATE        0x20000000
#define NVDBG_SHOW_VERTICES             0x10000000
#define NVDBG_SHOW_MTS_STATE            0x0F000000  // Selects number of multi-texture stage state values to display.
#define NVDBG_SHOW_MTS_STATE_MAX        8
#define NVDBG_SHOW_MTS_STATE_SHIFT      24
#define NVDBG_SHOW_DX6_CLASS_STATE      0x00800000
#define NVDBG_SHOW_DRAWPRIM2_INFO       0x00400000
#define NVDBG_SHOW_VERTEX_MAX_MIN       0x00200000
#define NVDBG_SHOW_LIGHTS               0x00100000
#define NVDBG_SHOW_MANUAL_OVERRIDE      0x00000002  // force show/dump regardless of dbgShowState/dbgDumpState values
#define NVDBG_SHOW_TEXTURE_RENAME       0x00080000  // prints information on texture renaming

// Bit definitions for the dbgFlush debug flags
#define NVDBG_FLUSH_PRIMITIVE           0x80000000  // flush triangles, lines, points, etc.
#define NVDBG_FLUSH_SETUP               0x40000000  // flush commands that set up / tear down HW object state
#define NVDBG_FLUSH_STATE               0x20000000  // flush DP2 commands that set render state, etc
#define NVDBG_FLUSH_2D                  0x10000000  // flush 2d operations: blits, clears, flips, etc.

// Bit definitions for the texture preview debug flags
#define NVDBG_TEXTURE_PREVIEW_BASE      0x00000001
#define NVDBG_TEXTURE_PREVIEW_MIP       0x00000002
#define NVDBG_TEXTURE_PREVIEW_CUBE      0x00000004
#define NVDBG_TEXTURE_PREVIEW_LINEAR    0x80000000  // preview linear rather than swizzled version
#define NVDBG_TEXTURE_PREVIEW_ALPHA     0x08000000  // preview the alpha values in grayscale

// Filenames for dumped data
#if 0
// multiple small logs
#define NVDBG_DUMP_RENDER_STATE_FILENAME     "\\render_state.txt"
#define NVDBG_DUMP_DX5_CLASS_STATE_FILENAME  "\\dx5_state.txt"
#define NVDBG_DUMP_SURFACE_STATE_FILENAME    "\\surface_state.txt"
#define NVDBG_DUMP_VERTICES_FILENAME         "\\vertices.txt"
#define NVDBG_DUMP_MTS_STATE_FILENAME        "\\mts_state.txt"
#define NVDBG_DUMP_DX6_CLASS_STATE_FILENAME  "\\dx6_state.txt"
#define NVDBG_DUMP_DRAWPRIM2_INFO_FILENAME   "\\drawprim2_info.txt"
#define NVDBG_DUMP_MANUAL_OVERRIDE_FILENAME  "\\manual_dump.txt"
#else
// one big log
#define NVDBG_DUMP_RENDER_STATE_FILENAME     "\\d3ddump.txt"
#define NVDBG_DUMP_DX5_CLASS_STATE_FILENAME  "\\d3ddump.txt"
#define NVDBG_DUMP_SURFACE_STATE_FILENAME    "\\d3ddump.txt"
#define NVDBG_DUMP_VERTICES_FILENAME         "\\d3ddump.txt"
#define NVDBG_DUMP_MTS_STATE_FILENAME        "\\d3ddump.txt"
#define NVDBG_DUMP_DX6_CLASS_STATE_FILENAME  "\\d3ddump.txt"
#define NVDBG_DUMP_DRAWPRIM2_INFO_FILENAME   "\\d3ddump.txt"
#define NVDBG_DUMP_MANUAL_OVERRIDE_FILENAME  "\\d3ddump.txt"
#endif

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//-------------------------------------------------------------------------

#ifdef DEBUG

    // general debugging
    extern  DWORD                   dbgShowState;
    extern  DWORD                   dbgDumpState;
    extern  DWORD                   dbgFlush;
    extern  DWORD                   dbgForceHWRefresh;

    // primary info (shared by front buffer rendering and texture previewing)
    extern  DWORD                   dbgPrimaryPitch;
    extern  DWORD                   dbgPrimaryHeight;
    extern  DWORD                   dbgPrimaryBPP;

    // front buffer rendering
    extern  BOOL                    dbgFrontRender;
    extern  CSimpleSurface          dbgFrontRenderSurface;

    // texture previewing
    extern  DWORD                   dbgTexturePreview;

#else

    #define dbgShowState            0
    #define dbgDumpState            0
    #define dbgFlush                0
    #define dbgForceHWRefresh       0

    // primary info (shared by front buffer rendering and texture previewing)
    #define dbgPrimaryPitch         0
    #define dbgPrimaryHeight        0
    #define dbgPrimaryBPP           0

    #define dbgFrontRender          FALSE
    #define dbgFrontRenderSurface   NULL

    #define dbgTexturePreview       FALSE

#endif

//-------------------------------------------------------------------------
// PROTOTYPES
//-------------------------------------------------------------------------

#ifdef DEBUG

    // printing
    void __cdecl dbgDPFAndDump                  (DWORD flag, LPSTR szFormat, ...);

    // state dumping
    void         dbgDisplayContextState         (DWORD, PNVD3DCONTEXT);
    void         dbgShowRenderStateChange       (BOOL bChanged, DWORD dwStateType, DWORD dwStateValue);
    void         dbgDisplayDrawPrimitives2Info  (BYTE,WORD);
    void         dbgDisplayVertexData           (BOOL, DWORD *);
    void         dbgDisplayLight                (LPD3DLIGHT7 pLight7);

    // state validation
    BOOL         dbgValidateControlRegisters    (PNVD3DCONTEXT);

    // texture previewing
    void         dbgTextureDisplay              (CTexture *pTexture);

    // front rendering
    void         dbgSetFrontRenderTarget        (PNVD3DCONTEXT pContext, CSimpleSurface *pSurfaceToMimic);

#else  // !DEBUG

    // printing
    #define      dbgDPFAndDump                  1 ? (void)0 : (void)

    // state dumping
    #define      dbgDisplayContextState(f,x)
    #define      dbgShowRenderStateChange(a,b,c)
    #define      dbgDisplayDrawPrimitives2Info(x,y)
    #define      dbgDisplayVertexData(a,b)
    #define      dbgDisplayLight(pLight7)

    // state validation
    #define      dbgValidateControlRegisters(noop) TRUE

    // texture previewing
    #define      dbgTextureDisplay(a)

    // front rendering
    #define      dbgSetFrontRenderTarget(a,b)

#endif

#ifdef NVSTATDRIVER

#define DX7PROPER 1

// prototypes
void __cdecl nvStatLogError(DWORD dwLevel, LPSTR szFormat, ...);

// override some stuff
#undef DPF_LEVEL
#define DPF_LEVEL nvStatLogError
#undef  dbgDisplayVertexData
#define dbgDisplayVertexData nvStatLogVertexData
#endif  // NVSTATDRIVER


//-------------------------------------------------------------------------
// MISCELLANEOUS
//-------------------------------------------------------------------------

#ifdef DEBUG

    #define dbgD3DError()  dbgError("NV D3D ERROR!");
    #define dbgFlushType(type)                                                  \
    {                                                                           \
        if (dbgFlush & type) {                                                  \
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);      \
        }                                                                       \
    }

#elif defined(NVSTATDRIVER)

    #define dbgD3DError()  DPF("NV D3D ERROR!!!");
    #define dbgFlushType(a)

#else  // !NVSTATDRIVER && !DEBUG

    #define dbgD3DError()
    #define dbgFlushType(a)

#endif  // !NVSTATDRIVER && !DEBUG


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV3DDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\arb_fifo.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** ARB Structures ****************************\
*                                                                           *
* Module: ARB_FIFO.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#ifndef _ARB_FIFO_H
#define ARB_FIFO_H

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; // cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} sim_state;

#define VIDEO		0
#define GRAPHICS	1
#define MPORT		2
#define ENGINE		3

#define GFIFO_SIZE	320 	// Graphics Fifo Sizes
#define GFIFO_SIZE_128	256 // Graphics Fifo Sizes
#define MFIFO_SIZE	120	    // MP Fifo Sizes
#define VFIFO_SIZE	256	    // Video Fifo Sizes

#define	ABS(a)	(a>0?a:-a)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // ARB_FIFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\D3DINC.H ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DINC.H                                                          *
*   NV specific direct 3d structure definitions.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Eugene Lapidous             ??/??/96 - wrote it.                    *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/

#ifndef _D3DINC_H_
#define _D3DINC_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * --------------------------------------------------------------------------
 * Data Cache macros
 * --------------------------------------------------------------------------
 */
#define PREFETCH(address)       ((volatile DWORD)*(DWORD*)(address))

/*
 * --------------------------------------------------------------------------
 * Texture heap management defines and structures.
 * --------------------------------------------------------------------------
 */
typedef struct _def_tex_heap_header TEXHEAPHEADER, *PTEXHEAPHEADER;

#define PACKCHARS(c0, c1, c2, c3)               \
    (((DWORD)(unsigned char)(c0))       |       \
     ((DWORD)(unsigned char)(c1) << 8)  |       \
     ((DWORD)(unsigned char)(c2) << 16) |       \
     ((DWORD)(unsigned char)(c3) << 24))

#define HEAP_SHARED                 0x04000000UL    // put heap in shared memory
#define HEAP_SIZE_ADJUST            0x00100000
#define HEAP_TAG_FREE               PACKCHARS('F', 'R', 'E', 'E')
#define HEAP_TAG_ALLOC              PACKCHARS('L', 'O', 'C', 'K')

struct _def_tex_heap_header
{
    DWORD           dwTag;
    DWORD           dwBlockSize;
    DWORD           dwBlockStartOffset;
    DWORD           dwReserved;
    PTEXHEAPHEADER  pNextFreeBlock;
    PTEXHEAPHEADER  pPrevFreeBlock;
    PTEXHEAPHEADER  pNextAllocBlock;
    PTEXHEAPHEADER  pPrevAllocBlock;
};

/*
 * --------------------------------------------------------------------------
 * General purpose constants
 * --------------------------------------------------------------------------
 */
#define CONTEXT_ARRAY_SIZE          64
#define CONTEXT_ARRAY_DELTA         64
#define TEXTURE_ARRAY_SIZE          256
#define TEXTURE_ARRAY_DELTA         256
#define AGPLIST_ARRAY_SIZE          256
#define AGPLIST_ARRAY_DELTA         256
#define NVD3D_DEFAULT_TL_NUM        0           // was: ((32 * 2048) / sizeof(D3DTLVERTEX))

#define MAX_STATE                   D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS                  32
#define DWORD_SHIFT                 5

// point and line sizes
#define LINE_WIDTH                  1.0f
#define HALF_LINE_WIDTH             (0.5f*LINE_WIDTH)
#define POINT_SIZE                  1.0f
#define HALF_POINT_SIZE             (0.5f*POINT_SIZE)

#define NV4_VERTEX_CACHE_SIZE       16

// define global values to be the greatest of those required by the various architectures
#if (NVARCH >= 0x020)
#define NV_CAPS_MAX_COMBINERS       KELVIN_NUM_COMBINERS
#define NV_CAPS_MAX_TEXTURES        KELVIN_NUM_TEXTURES
#define NV_CAPS_MAX_MATRICES        KELVIN_NUM_MATRICES
#define NV_CAPS_MAX_UV_SETS         KELVIN_CAPS_MAX_UV_PAIRS
#define NV_CAPS_MAX_CLIPPLANES      KELVIN_CAPS_MAX_USER_CLIP_PLANES_ALLOWED
#define NV_CAPS_MAX_STREAMS         KELVIN_CAPS_MAX_STREAMS
#define NV_CAPS_MAX_PSHADER_CONSTS  KELVIN_CAPS_MAX_PSHADER_CONSTS
#define NV_CAPS_MAX_VSHADER_TEMPS   KELVIN_CAPS_MAX_VSHADER_TEMPS
#define NV_CAPS_MAX_VSHADER_CONSTS  KELVIN_CAPS_MAX_VSHADER_CONSTS
#elif (NVARCH >= 0x010)
#define NV_CAPS_MAX_COMBINERS       CELSIUS_NUM_COMBINERS
#define NV_CAPS_MAX_TEXTURES        CELSIUS_NUM_TEXTURES
#define NV_CAPS_MAX_MATRICES        CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES
#define NV_CAPS_MAX_UV_SETS         CELSIUS_CAPS_MAX_UV_PAIRS
#define NV_CAPS_MAX_CLIPPLANES      CELSIUS_CAPS_MAX_USER_CLIP_PLANES
#define NV_CAPS_MAX_STREAMS         CELSIUS_CAPS_MAX_STREAMS
#define NV_CAPS_MAX_PSHADER_CONSTS  CELSIUS_CAPS_MAX_PSHADER_CONSTS
#define NV_CAPS_MAX_VSHADER_TEMPS   CELSIUS_CAPS_MAX_VSHADER_TEMPS
#define NV_CAPS_MAX_VSHADER_CONSTS  CELSIUS_CAPS_MAX_VSHADER_CONSTS
#else  // nv4
#define NV_CAPS_MAX_TEXTURES        2
#define NV_CAPS_MAX_STREAMS         1
#define NV_CAPS_MAX_MATRICES        NV4_CAPS_MAX_VERTEX_BLEND_MATRICES
#define NV_CAPS_MAX_UV_SETS         NV4_CAPS_MAX_UV_PAIRS
#define NV_CAPS_MAX_CLIPPLANES      NV4_CAPS_MAX_USER_CLIP_PLANES
#define NV_CAPS_MAX_PSHADER_CONSTS  0
#define NV_CAPS_MAX_VSHADER_TEMPS   0
#define NV_CAPS_MAX_VSHADER_CONSTS  0
#endif

// helper functions to cope with vertex shader programs
#define GET_LIGHTING_STATE(pContext)    \
    (pContext->pCurrentVShader->hasProgram() ? FALSE : (pContext->dwRenderState[D3DRENDERSTATE_LIGHTING]))
#define GET_VERTEXBLEND_STATE(pContext) \
    (pContext->pCurrentVShader->hasProgram() ? D3DVBLEND_DISABLE : (pContext->dwRenderState[D3DRENDERSTATE_VERTEXBLEND]))

/*
 * --------------------------------------------------------------------------
 *  Data structures.
 * --------------------------------------------------------------------------
 */

/*
 * D3D state set data.
 */
typedef struct _nv_d3d_state_set
{
    DWORD bits[MAX_STATE >> DWORD_SHIFT];
} NVD3DSTATESET;

// DP2 stateset stuff
#define DEFAULT_STATESET_SIZE     4096
#define INCREMENTAL_STATESET_SIZE 2048

typedef struct _STATESET {
    int    allocatedSize;
    int    dataSize;
    LPBYTE pData;
} STATESET;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _D3DINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\ddCapture.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: ddCapture.h
//      macros used by a capture driver (this is a local extension
//      to the shared file nvCapture.h)
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        24May00         created
//
// **************************************************************************

#ifndef _DDCAPTURE_H
#define _DDCAPTURE_H

#ifdef CAPTURE

//////////////////////////////////////////////////////////////////////////////
// override object creation
//
inline ULONG __capture_NvRmAllocObject (ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass)
{
    if (!global.b16BitCode)
    {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_OBJECT_CREATE create;
            create.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            create.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            create.dwExtensionID        = CAPTURE_XID_OBJECT_CREATE;
            create.dwClassID            = hClass;
            create.dwHandle             = hObject;
            captureLog (&create,sizeof(create));
        }
    }
    return NvRmAllocObject (hClient, hChannel, hObject, hClass);
}
#define NvRmAllocObject __capture_NvRmAllocObject   // alias to CAPTURE create

//////////////////////////////////////////////////////////////////////////////
// override second flavor of object creation
//
inline ULONG __capture_NvRmAlloc (ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms)
{
    if (!global.b16BitCode)
    {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_OBJECT_CREATE create;
            create.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            create.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            create.dwExtensionID        = CAPTURE_XID_OBJECT_CREATE;
            create.dwClassID            = hClass;
            create.dwHandle             = hObject;
            captureLog (&create,sizeof(create));
        }
    }
    return NvRmAlloc (hClient, hParent, hObject, hClass, pAllocParms);
}
#define NvRmAlloc __capture_NvRmAlloc

//////////////////////////////////////////////////////////////////////////////
// override context DMA creation
//
inline ULONG __capture_NvRmAllocContextDma (ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit)
{
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_CTXDMA_CREATE create;
        create.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        create.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        create.dwExtensionID        = CAPTURE_XID_CTXDMA_CREATE;
        create.dwHandle             = hDma;
        create.dwSize               = limit + 1;
        create.dwBaseAddress        = (DWORD)(base);

        if ((DWORD(base) >= pDriverData->BaseAddress)
         && (DWORD(base) < (pDriverData->BaseAddress + pDriverData->TotalVRAM)))
        {
            create.dwType = CAPTURE_CTXDMA_TYPE_VID;
        }
        else if (pDriverData->GARTLinearBase
              && (DWORD(base) >= pDriverData->GARTLinearBase)
              && (DWORD(base) <  (pDriverData->GARTLinearBase + pDriverData->regMaxAGPLimit + 1)))
        {
            create.dwType = CAPTURE_CTXDMA_TYPE_AGP;
        }
        else
        {
            create.dwType = CAPTURE_CTXDMA_TYPE_PCI;
        }
        captureLog (&create,sizeof(create));
    }
    return NvRmAllocContextDma (hClient, hDma, hClass, flags, base, limit);
}
#define NvRmAllocContextDma __capture_NvRmAllocContextDma

//////////////////////////////////////////////////////////////////////////////
// override object / context dma deletion
//
inline ULONG __capture_NvRmFree (ULONG hClient, ULONG hChannel, ULONG hObject)
{
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_OBJECT_FREE free;
        free.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        free.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        free.dwExtensionID        = CAPTURE_XID_OBJECT_FREE;
        free.dwHandle             = hObject;
        captureLog (&free,sizeof(free));
    }
    return NvRmFree (hClient, hChannel, hObject);
}
#define NvRmFree __capture_NvRmFree

#endif  // CAPTURE

#endif  // _DDCAPTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\d3dMath.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dMath.h                                                         *
*       header file for d3dmath.cpp                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   09Sep99     created                 *
*                                                                           *
\***************************************************************************/

#ifndef __D3DMATH_H
#define __D3DMATH_H

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------------

// constants

#define EPSILON 0.0000001f

//---------------------------------------------------------------------------

// augment D3D with some sorely missing types

typedef struct _D3DVECTOR4 {
    D3DVALUE dvX;
    D3DVALUE dvY;
    D3DVALUE dvZ;
    D3DVALUE dvW;
} D3DVECTOR4;

typedef struct _D3DMATRIX3 {
    D3DVALUE _11, _12, _13;
    D3DVALUE _21, _22, _23;
    D3DVALUE _31, _32, _33;
} D3DMATRIX3;

//---------------------------------------------------------------------------

// basic matrices and vectors

static D3DMATRIX matrixIdent =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

static D3DMATRIX matrixZero =
{
    0.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 0.0f
};

static D3DVECTOR vectorZero = {0.0f, 0.0f, 0.0f};

//---------------------------------------------------------------------------

// prototypes

float    __fastcall JBInvSqrt (const float x);
float    __fastcall nvSqrt (float x);
float    __fastcall nvInv (float x);
void     __fastcall ReverseVector3 (D3DVECTOR *out, D3DVECTOR *in);
void     __fastcall ScaleVector3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVALUE scale);
void     __fastcall AddVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2);
void     __fastcall SubtractVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2);
D3DVALUE __fastcall SquareMagnitude3 (D3DVECTOR *v);
D3DVALUE __fastcall Magnitude3 (D3DVECTOR *v);
void     __fastcall NormalizeVector3 (D3DVECTOR *v);
D3DVALUE __fastcall DotProduct3 (D3DVECTOR *v1, D3DVECTOR *v2);
void     __fastcall XformBy4x3 (D3DVECTOR *res, D3DVECTOR *v, D3DVALUE w, D3DMATRIX *m);
void     __fastcall XformVector3 (D3DVECTOR *res, D3DVECTOR *v, D3DMATRIX *m);
void     __fastcall XformVector4 (D3DVALUE *res, D3DVALUE *v, D3DMATRIX *m);
void     __fastcall MatrixProduct3x3 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b);
void     __fastcall MatrixProduct4x4 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b);
void     __fastcall MatrixTranspose4x4 (D3DMATRIX *res, D3DMATRIX *m);
int      __fastcall Inverse3x3 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize);
int      __fastcall Inverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize);
int      __fastcall STInverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src);

// other prototypes
void nvComputeBoundingBox    (BYTE *pVertices,DWORD dwCount,DWORD dwVertexStride,float *pafMinMaxInfo);
void nvComputeXfmAndOutCodes (D3DMATRIX *pXfm,float *pfVerticesIn,float *pfVerticesOut,DWORD dwCount,DWORD *pdwOutCodes);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __D3DMATH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\d3dConst.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dConst.h                                                        *
*     General constants associate with D3D                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   22June99     created                *
*                                                                           *
\***************************************************************************/

#ifndef __D3D_CONST_
#define __D3D_CONST_

//---------------------------------------------------------------------------

// global constants

// these are missing from the MS's DX8 header files

#if (DIRECT3D_VERSION == 0x0800)

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DTSS_ADDRESS 12
#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)
// end missing MS info

#endif // (DIRECT3D_VERSION == 0x0800)

// Look in D3DTYPES.H to determine what these values are.
#define D3D_RENDERSTATE_MAX     D3DRS_BLENDOP
#define D3D_DP2OP_MAX           D3DDP2OP_MULTIPLYTRANSFORM
#define D3D_TEXSTAGESTATE_MAX   D3DTSS_RESULTARG
#define D3D_TBLEND_MAX          D3DTBLEND_ADD

//---------------------------------------------------------------------------

// global helpers

// placement new and delete
inline void* operator new    (size_t nSize,void *pPlace) { return pPlace; }
//inline void  operator delete (void*,void*)               {}

//---------------------------------------------------------------------------

// global macros

#define OFFSETOF(s,m)           ((DWORD)(&(((s*)0)->m)))

// retrieve or set the pointer to the NvObject associated with a particular DDSLcl
#ifdef WINNT
#define GET_PNVOBJ(pDDSLcl)        ((CNvObject *)((pDDSLcl)->dwReserved1))
#define SET_PNVOBJ(pDDSLcl,value)  (pDDSLcl)->dwReserved1 = (DWORD)(value);
#else
// under win9x, we store NvObj pointer in GBL_MORE rather than DDSLcl b/c this field gets swapped on a flip
#define GET_PNVOBJ(pDDSLcl)        ((CNvObject *)((GET_LPDDRAWSURFACE_GBL_MORE((pDDSLcl)->lpGbl))->dwDriverReserved))
#define SET_PNVOBJ(pDDSLcl,value)  (GET_LPDDRAWSURFACE_GBL_MORE((pDDSLcl)->lpGbl))->dwDriverReserved = (DWORD)(value);
#endif

#define IS_VALID_PNVOBJ(value)     (((value) != NULL) && ((((DWORD)(value)) & MASK_FLOATING_CONTEXT_DMA_ID) != FLOATING_CONTEXT_DMA_ID))

// template classes for general purpose use
typedef void* NVPOSITION;

//---------------------------------------------------------------------------

// CNVLinkedList

template<class T,class R> class CNVLinkedList
{
protected:
    class CEntry
    {
    public:
        T       m_Object;
        CEntry *m_pNext;
        CEntry *m_pPrev;
    };

    CEntry *m_pHead;
    CEntry *m_pTail;

public:
    inline NVPOSITION getFirstPosition (void) const { return (NVPOSITION)m_pHead; }
    inline NVPOSITION getLastPosition  (void) const { return (NVPOSITION)m_pTail; }

    inline R getNextPosition (NVPOSITION& pos)
    {
        CEntry *pEntry = (CEntry*)pos;
        if (pEntry)
        {
            pos = pEntry->m_pNext;
            return pEntry->m_Object;
        }
        return NULL;
    }

    inline R getPreviousPosition (NVPOSITION& pos)
    {
        CEntry *pEntry = (CEntry*)pos;
        if (pEntry)
        {
            pos = pEntry->m_pPrev;
            return pEntry->m_Object;
        }
        return NULL;
    }

    inline int addFront (R obj)
    {
        CEntry *pEntry = new CEntry;
        if (!pEntry) return 0;
        pEntry->m_Object = obj;
        pEntry->m_pPrev  = NULL;
        pEntry->m_pNext  = m_pHead;
        if (m_pHead) m_pHead->m_pPrev = pEntry;
        m_pHead = pEntry;
        if (!m_pTail) m_pTail = pEntry;
        return 1;
    }

    inline int addBack (R obj)
    {
        CEntry *pEntry = new CEntry;
        if (!pEntry) return 0;
        pEntry->m_Object = obj;
        pEntry->m_pPrev  = m_pTail;
        pEntry->m_pNext  = NULL;
        if (m_pHead) m_pTail->m_pNext = pEntry;
        m_pTail = pEntry;
        if (!m_pHead) m_pHead = pEntry;
        return 1;
    }

    inline void remove (NVPOSITION pos)
    {
        CEntry *pEntry = (CEntry*)pos;
        if (pEntry->m_pNext) pEntry->m_pNext->m_pPrev = pEntry->m_pPrev;
                        else m_pTail = pEntry->m_pPrev;
        if (pEntry->m_pPrev) pEntry->m_pPrev->m_pNext = pEntry->m_pNext;
                        else m_pHead = pEntry->m_pNext;
        delete pEntry;
    }

    inline void removeAll (void)
    {
        while (m_pHead)
        {
            CEntry *pNext = m_pHead;
            delete m_pHead;
            m_pHead = pNext;
        }
        m_pHead = m_pTail = NULL;
    }

    inline NVPOSITION find (R obj) const
    {
        for (CEntry *pEntry = m_pHead; pEntry; pEntry = pEntry->m_pNext)
        {
            if (pEntry->m_Object == obj)
            {
                return (NVPOSITION)pEntry;
            }
        }
        return (NVPOSITION)0;
    }

    inline  CNVLinkedList (void) { m_pHead = m_pTail = NULL; }
    inline ~CNVLinkedList (void)
    {
#ifdef DEBUG
        if (m_pHead) { DPF ("Warning: CLinkedList<> not empty at destruction time"); }
#endif
    }
};

//---------------------------------------------------------------------------

// CNVArray
//    cannot store classes with constructors/destructors or with '=' operators
template<class T,class R,const int ciGrowBy = 128> class CNVArray
{
protected:
    T     *m_pData;
    DWORD  m_dwMax;
    DWORD  m_dwCount;

protected:
    void init (void)
    {
        m_pData = NULL;
        m_dwMax = m_dwCount = 0;
    }
    void grow (DWORD dwNewSize)
    {
        dwNewSize = (dwNewSize + ciGrowBy - 1) & ~(ciGrowBy - 1);
        if (dwNewSize > m_dwMax)
        {
            ReallocIPM(m_pData,sizeof(T) * dwNewSize,(void**)&m_pData);
            m_dwMax = dwNewSize;
        }
    }
    void kill (void)
    {
        if (m_pData) FreeIPM (m_pData);
        init();
    }

public:
    void append (R data)
    {
        if (m_dwCount >= m_dwMax) grow (m_dwCount + 1);
        m_pData[m_dwCount] = data;
        m_dwCount++;
    }

    void removeAll (void)
    {
        m_dwCount = 0;
    }

          DWORD getCount (void) const { return m_dwCount; }
    const T*    getData  (void) const { return m_pData; }

public:
    CNVArray  (void) { init(); }
    ~CNVArray (void) { kill(); }
};

#endif  // __D3D_CONST_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\DDHal.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: DDHal.h                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe          6/15/99 - Created                       *
*                                                                           *
\***************************************************************************/
#ifndef _DDHAL_H_
#define _DDHAL_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef WINNT
// public
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif // WINNT

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDHAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\ddSurface.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: ddSurface.h
//    Definition file for:
//       ddsurf.c
//
// **************************************************************************
//
// History:
//       Paul van der Kouwe 06/16/99 - created.
//
// **************************************************************************

#ifndef _DDSURFACE_H_
#define _DDSURFACE_H_

#ifdef __cplusplus
extern "C" {
#endif

// macros

#define SET_GBL_SURFACE_DATA(pDDSLcl, flags, bits, rmask, gmask, bmask, amask)  \
{                                                                               \
    pDDSLcl->lpGbl->ddpfSurface.dwFlags = (flags);                              \
    pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount = (bits);                         \
    pDDSLcl->lpGbl->ddpfSurface.dwRBitMask = (rmask);                           \
    pDDSLcl->lpGbl->ddpfSurface.dwGBitMask = (gmask);                           \
    pDDSLcl->lpGbl->ddpfSurface.dwBBitMask = (bmask);                           \
    pDDSLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask = (amask);                    \
}

// helper routines
#ifndef WINNT
void  getDisplayDuration (void);
#endif
BOOL  nvCalculateColorKey (DWORD *pColorKey, LPDDRAWI_DDRAWSURFACE_LCL pLcl, DWORD dwFormat);
DWORD nvCalculateSurfaceParams (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                DWORD *pFormat, BOOL *bFourCC,
                                DWORD *pWidth, DWORD *pHeight, DWORD *pDepth, DWORD *dwMultiSampleBits,
                                DWORD *pBPPRequested, DWORD *pBPPGranted,
                                DWORD *pPitch, DWORD *pSlicePitch, BOOL bComputePitch /* rather than extracting it from pDDSLcl */);

// callbacks

DWORD __stdcall DestroySurface32   (LPDDHAL_DESTROYSURFACEDATA lpDestroySurface);
DWORD __stdcall CreateSurface32    (LPDDHAL_CREATESURFACEDATA lpCreateSurface);
DWORD __stdcall CanCreateSurface32 (LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurface);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDSURFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\ddFlip.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: ddFlip.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _DDFLIP_H_
#define _DDFLIP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define FLIP_ANYSURFACE         0xFFFFFFF7         // fpVidMem parameter for updateFlipStatus

// prototypes
HRESULT __stdcall getFlipStatusPrimary (FLATPTR fpVidMem);
HRESULT __stdcall getFlipStatusOverlay (FLATPTR fpVidMem);
HRESULT __stdcall getFlipStatus        (FLATPTR fpVidMem, DWORD dwType);
DWORD   __stdcall GetFlipStatus32       (LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD   __stdcall Flip32                (LPDDHAL_FLIPDATA pfd);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDFLIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkmapi.h
 *  Content:    Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD dwFunctionNum,
    DWORD lpvInBuffer,
    DWORD cbInBuffer,
    DWORD lpvOutBuffer,
    DWORD cbOutBuffer
);


#define DXAPI_MAJORVERSION              1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI                                  0x500

typedef DWORD (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        DWORD               dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
        DWORD   ddRVal;
        DWORD   dwCaps;
        DWORD   dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
        DWORD   ddRVal;
        DWORD   dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD                      (DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE                      (DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
        DWORD   ddRVal;
        DWORD   dwStateCaps;
        DWORD   dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE                      (DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
        DWORD   dwState;
        DWORD   dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK                                   (DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
        DWORD   ddRVal;
        DWORD   dwSurfHeight;
        DWORD   dwSurfWidth;
        LONG    lSurfPitch;
        PVOID   lpSurface;
        DWORD   SurfaceCaps;
        DWORD   dwFormatFlags;
        DWORD   dwFormatFourCC;
        DWORD   dwFormatBitCount;
        union
        {
            DWORD       dwRBitMask;
            DWORD       dwYBitMask;
        };
        union
        {
            DWORD       dwGBitMask;
            DWORD       dwUBitMask;
        };
        union
        {
            DWORD       dwBBitMask;
            DWORD       dwVBitMask;
        };
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY                           (DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
        HANDLE  hDirectDraw;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP                                (DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE        (DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoSurface;
        HANDLE  hVBISurface;
        BOOL    bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE           (DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK                      (DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
        HANDLE              hDirectDraw;
        DWORD               dwEvents;
        LPDD_NOTIFYCALLBACK pfnCallback;
        DWORD               dwParam1;
        DWORD               dwParam2;
        PVOID               pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK                    (DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY                           (DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
        DWORD   ddRVal;
        BOOL    bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE                    (DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartLine;
        DWORD   dwEndLine;
        DWORD   dwCaptureEveryNFields;
        LPDD_NOTIFYCALLBACK pfnCaptureClose;
        PVOID   pContext;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
        DWORD   ddRVal;
        HANDLE  hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER                     (DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
        DWORD           dwFieldNumber;
        DWORD           bPolarity;
        LARGE_INTEGER   liTimeStamp;
        DWORD           ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
        HANDLE  hCapture;
        DWORD   dwFlags;
        PMDL    pMDL;
        PKEVENT pKEvent;
        LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY      0x0001  // lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM    0x0002  // lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT            0x0004  // invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS                  (DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB                             0x0001
#define DDSTATE_WEAVE                           0x0002
#define DDSTATE_EXPLICITLY_SET                  0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP               0x0008

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC                   0x0001
#define DDEVENT_VP_VSYNC                        0x0002
#define DDEVENT_VP_LINE                         0x0004
#define DDEVENT_PRERESCHANGE                    0x0008
#define DDEVENT_POSTRESCHANGE                   0x0010
#define DDEVENT_PREDOSBOX                       0x0020
#define DDEVENT_POSTDOSBOX                      0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC                  0x0001  // dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC                       0x0002  // dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE                        0x0004  // dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE                   0x0008  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE                  0x0010  // dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX                      0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX                     0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW                0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE                   0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT                 0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE                   0x0400  // dwParam1 = hCapture

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DDKMAPI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\ddVideo.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: ddVideo.h                                                         *
*    Definition file for:                                                   *
*       dvideo32.c                                                          *
*    Suggested new name:                                                    *
*       ddVideo.c                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _DDVIDEO_H_
#define _DDVIDEO_H_

#ifdef __cplusplus
extern "C" {
#endif

// public
DWORD __stdcall ConvertOverlay32                (LPDDRAWI_DDRAWSURFACE_LCL, BOOL waitForCompletion, LPDWORD lpDstYOffset);
DWORD __stdcall PreScaleOverlay32               (LPDDRAWI_DDRAWSURFACE_LCL);
DWORD __stdcall UpdateOverlay32                 (LPDDHAL_UPDATEOVERLAYDATA);
DWORD __stdcall SetOverlayPosition32            (LPDDHAL_SETOVERLAYPOSITIONDATA);
BOOL  __stdcall GetVideoScalerBandwidthStatus32 (DWORD, DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DDVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\dxvadefs.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dxva.h
 *
 *  Content:	DirectX Video Acceleration header file
 *
 *  Sept. 15, 2000
 *
 ***************************************************************************/

#ifndef __DIRECTX_VA__
#define __DIRECTX_VA__

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(DXVA_ModeNone,    0x1b81be00, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_A,  0x1b81be01, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_B,  0x1b81be02, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_A,  0x1b81be03, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_B,  0x1b81be04, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_C,  0x1b81be05, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_D,  0x1b81be06, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_E,  0x1b81be07, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_F,  0x1b81be08, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG1_A, 0x1b81be09, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_B, 0x1b81be0B, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_D, 0x1b81be0D, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_EncryptProt1, 0x1b81beD1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#define DXVA_RESTRICTED_MODE_UNRESTRICTED        0xFFFF
#define DXVA_RESTRICTED_MODE_H261_A              1
#define DXVA_RESTRICTED_MODE_H261_B              2
#define DXVA_RESTRICTED_MODE_H263_A              3
#define DXVA_RESTRICTED_MODE_H263_B              4
#define DXVA_RESTRICTED_MODE_H263_C              5
#define DXVA_RESTRICTED_MODE_H263_D              6
#define DXVA_RESTRICTED_MODE_H263_E              7
#define DXVA_RESTRICTED_MODE_H263_F              8
#define DXVA_RESTRICTED_MODE_MPEG1_A             9
#define DXVA_RESTRICTED_MODE_MPEG2_A             0xA
#define DXVA_RESTRICTED_MODE_MPEG2_B             0xB
#define DXVA_RESTRICTED_MODE_MPEG2_C             0xC
#define DXVA_RESTRICTED_MODE_MPEG2_D             0xD

#define DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED    0
#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

#define DXVA_NUM_TYPES_COMP_BUFFERS             16

/* values for bDXVA_Func */
#define DXVA_PICTURE_DECODING_FUNCTION        1
#define DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION   2
#define DXVA_ALPHA_BLEND_COMBINATION_FUNCTION 3
#define DXVA_PICTURE_RESAMPLE_FUNCTION        4

/* values returned from Execute command in absence of read-back */
#define DXVA_EXECUTE_RETURN_OK                  0
#define DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR    1
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF   2
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE   3
#define DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE  4


#pragma pack(push, BeforeDXVApacking, 1)


typedef struct _DXVA_ConnectMode {
  GUID guidMode;
  WORD wRestrictedMode;
} DXVA_ConnectMode, *LPDXVA_ConnectMode;


typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define readDXVA_QueryOrReplyFuncFlag(ptr)        ((*(ptr)) >> 8)

#define readDXVA_QueryOrReplyFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)
#define readDXVA_QueryOrReplyFuncFlag_LOCK(ptr)   (((*(ptr)) >> 10) & 1)
#define readDXVA_QueryOrReplyFuncFlag_BAD(ptr)    (((*(ptr)) >>  9) & 1)
#define readDXVA_QueryOrReplyFuncFlag_PLUS(ptr)   (((*(ptr)) >>  8) & 1)

#define readDXVA_QueryOrReplyFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_QueryOrReplyFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_QueryOrReplyFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_QueryOrReplyFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef DWORD DXVA_EncryptProtocolFunc, *LPDXVA_EncryptProtocolFunc;

#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST    0xFFFF00
#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL   0xFFFF08

#define readDXVA_EncryptProtocolFuncFlag(ptr)        ((*(ptr)) >> 8)
#define readDXVA_EncryptProtocolFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)

#define readDXVA_EncryptProtocolFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_EncryptProtocolFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_EncryptProtocolFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_EncryptProtocolFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef struct _DXVA_EncryptProtocolHeader {
  DXVA_EncryptProtocolFunc dwFunction;
  DWORD ReservedBits[3];
  GUID  guidEncryptProtocol;
} DXVA_EncryptProtocolHeader, *LPDXVA_EncryptProtocolHeader;

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;


/* Picture Decoding Parameters */

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;


/* Picture Resampling */

typedef struct _DXVA_PicResample {

  WORD  wPicResampleSourcePicIndex;
  WORD  wPicResampleDestPicIndex;

  WORD  wPicResampleRcontrol;
  BYTE  bPicResampleExtrapWidth;
  BYTE  bPicResampleExtrapHeight;

  DWORD dwPicResampleSourceWidth;
  DWORD dwPicResampleSourceHeight;

  DWORD dwPicResampleDestWidth;
  DWORD dwPicResampleDestHeight;

  DWORD dwPicResampleFullDestWidth;
  DWORD dwPicResampleFullDestHeight;

} DXVA_PicResample, *LPDXVA_PicResample;


#define DXVA_CHROMA_FORMAT_420 1
#define DXVA_CHROMA_FORMAT_422 2
#define DXVA_CHROMA_FORMAT_444 3

#define DXVA_PICTURE_STRUCTURE_TOP_FIELD    1
#define DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD 2
#define DXVA_PICTURE_STRUCTURE_FRAME        3

#define DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND 0
#define DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC  1

#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2  0
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263   1
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261   2

#define DXVA_SCAN_METHOD_ZIG_ZAG              0
#define DXVA_SCAN_METHOD_ALTERNATE_VERTICAL   1
#define DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL 2
#define DXVA_SCAN_METHOD_ARBITRARY            3

#define DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY 0
#define DXVA_BITSTREAM_CONCEALMENT_NEED_MILD     1
#define DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY   2
#define DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE   3

#define DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED 0
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA       1
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD     2
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD    3


/* Buffer Description Data */

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;


/* Off-Host IDCT Coefficient Data Structures */

typedef struct _DXVA_TCoef4Group {
  BYTE  TCoefIDX[4];
  SHORT TCoefValue[4];
} DXVA_TCoef4Group, *LPDXVA_TCoef4Group;

typedef struct _DXVA_TCoefSingle {
  WORD  wIndexWithEOB;
  SHORT TCoefValue;
} DXVA_TCoefSingle, *LPDXVA_TCoefSingle;

/* Macros for Reading EOB and Index Values */

#define readDXVA_TCoefSingleIDX(ptr) ((ptr)->wIndexWithEOB >> 1)
#define readDXVA_TCoefSingleEOB(ptr) ((ptr)->wIndexWithEOB & 1)

/* Macro for Writing EOB and Index Values */

#define writeDXVA_TCoefSingleIndexWithEOB(ptr, idx, eob) ((ptr)->wIndexWithEOB = ((idx) << 1) | (eob))
#define setDXVA_TCoefSingleIDX(ptr, idx) ((ptr)->wIndexWithEOB |= ((idx) << 1))
#define setDXVA_TCoefSingleEOB(ptr)      ((ptr)->wIndexWithEOB |= 1)

/* Spatial-Domain Residual Difference Blocks */

#define DXVA_USUAL_BLOCK_WIDTH   8
#define DXVA_USUAL_BLOCK_HEIGHT  8
#define DXVA_USUAL_BLOCK_SIZE   (DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT)

typedef SHORT       DXVA_Sample16[DXVA_USUAL_BLOCK_SIZE];
typedef signed char DXVA_Sample8 [DXVA_USUAL_BLOCK_SIZE];

/* Deblocking Filter Control Structure */

typedef BYTE DXVA_DeblockingEdgeControl;

typedef DXVA_DeblockingEdgeControl * LPDXVA_DeblockingEdgeControl;

/* Macros for Reading STRENGTH and FilterOn */

#define readDXVA_EdgeFilterStrength(ptr) ((*(ptr)) >> 1)
#define readDXVA_EdgeFilterOn(ptr)       ((*(ptr)) & 1)

/* Macro for Writing STRENGTH and FilterOn */

#define writeDXVA_DeblockingEdgeControl(ptr, str, fon) ((*(ptr)) = ((str) << 1) | (fon))
#define setDXVA_EdgeFilterStrength(ptr, str)           ((*(ptr)) |= ((str) << 1))
#define setDXVA_EdgeFilterOn(ptr)                      ((*(ptr)) |= 1)


/* Macroblock Control Command Data Structures */

typedef struct _DXVA_MVvalue {
  SHORT horz, vert;
} DXVA_MVvalue, *LPDXVA_MVvalue;


/* Inverse Quantization Matrices */

typedef struct _DXVA_QmatrixData {
  BYTE bNewQmatrix[4]; /* intra Y, inter Y, intra chroma, inter chroma */
  WORD Qmatrix[4][DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT];
} DXVA_QmatrixData, *LPDXVA_QmatrixData;


/* Slice Control Buffer Data */

typedef struct _DXVA_SliceInfo {
  WORD  wHorizontalPosition;
  WORD  wVerticalPosition;
  DWORD dwSliceBitsInBuffer;
  DWORD dwSliceDataLocation;
  BYTE  bStartCodeBitOffset;
  BYTE  bReservedBits;
  WORD  wMBbitOffset;
  WORD  wNumberMBsInSlice;
  WORD  wQuantizerScaleCode;
  WORD  wBadSliceChopping;
} DXVA_SliceInfo, *LPDXVA_SliceInfo;


#define DXVA_NumMV_OBMC_off_BinPBwith4MV_off    4
#define DXVA_NumMV_OBMC_off_BinPBwith4MV_on  (4+1)
#define DXVA_NumMV_OBMC_on__BinPB_off         (10)
#define DXVA_NumMV_OBMC_on__BinPB_on          (11) /* not current standards */

#define DXVA_NumBlocksPerMB_420 (4+2+0)
#define DXVA_NumBlocksPerMB_422 (4+2+2)
#define DXVA_NumBlocksPerMB_444 (4+4+4)

/* Basic form for I pictures */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_I_HostResidDiff_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  WORD  wPC_Overflow; /* zero if not overflow format */
  DWORD dwReservedBits2;
} DXVA_MBctrl_I_HostResidDiff_1;

/* Basic form for I pictures */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_I_OffHostIDCT_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  BYTE  bNumCoef[DXVA_NumBlocksPerMB_420];
} DXVA_MBctrl_I_OffHostIDCT_1;

/* Basic form for P and B pictures */
/* Should also be used for concealment MVs in MPEG-2 I pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_P_HostResidDiff_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  WORD         wPC_Overflow; /* zero if not overflow format */
  DWORD        dwReservedBits2;
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_HostResidDiff_1;

/* Basic form for P and B pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_P_OffHostIDCT_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  BYTE         bNumCoef[DXVA_NumBlocksPerMB_420];
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_OffHostIDCT_1;

/* How to load alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaLoad {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigDataType;
} DXVA_ConfigAlphaLoad, *LPDXVA_ConfigAlphaLoad;

#define DXVA_CONFIG_DATA_TYPE_IA44  0
#define DXVA_CONFIG_DATA_TYPE_AI44  1
#define DXVA_CONFIG_DATA_TYPE_DPXD  2
#define DXVA_CONFIG_DATA_TYPE_AYUV  3


/* How to combine alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaCombine {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigBlendType;
  BYTE  bConfigPictureResizing;
  BYTE  bConfigOnlyUsePicDestRectArea;
  BYTE  bConfigGraphicResizing;
  BYTE  bConfigWholePlaneAlpha;

} DXVA_ConfigAlphaCombine, *LPDXVA_ConfigAlphaCombine;

#define DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER   0
#define DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE  1


/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample {
//  BYTE bSampleAlpha8, bY_Value, bCbValue, bCrValue;
    //new in version 1.01
    BYTE bCrValue, bCbValue, bY_Value, bSampleAlpha8;
} DXVA_AYUVsample, *LPDXVA_AYUVsample;

/* Macros for IA44 alpha blending surface samples */

typedef BYTE DXVA_IA44sample, *LPDXVA_IA44sample;

#define readDXVA_IA44index(ptr) (((*(ptr)) & 0xF0) >> 4)
#define readDXVA_IA44alpha(ptr)  ((*(ptr)) & 0x0F)

#define writeDXVA_IA44(ptr, idx, alpha) ((*(ptr)) = (((idx) << 4) | (alpha)))

#define setDXVA_IA44index(ptr, idx)    ((*(ptr)) |= ((idx) << 4))
#define setDXVA_IA44alpha(ptr, alpha)  ((*(ptr)) |= (alpha))

/* Macros for AI44 alpha blending surface samples */

typedef BYTE DXVA_AI44sample, *LPDXVA_AI44sample;

#define readDXVA_AI44index(ptr)  ((*(ptr)) & 0x0F)
#define readDXVA_AI44alpha(ptr) (((*(ptr)) & 0xF0) >> 4)

#define writeDXVA_AI44(ptr, idx, alpha) ((*(ptr)) = (((alpha) << 4) | (idx)))

#define setDXVA_AI44index(ptr, idx)    ((*(ptr)) |= (idx))
#define setDXVA_AI44alpha(ptr, alpha)  ((*(ptr)) |= ((alpha) << 4))


/* Highlight data structure */

typedef struct _DXVA_Highlight {
  WORD wHighlightActive;
  WORD wHighlightIndices;
  WORD wHighlightAlphas;
  RECT HighlightRect;
} DXVA_Highlight, *LPDXVA_Highlight;

typedef BYTE DXVA_DPXD,  *LPDXVA_DPXD;
typedef WORD DXVA_DCCMD, *LPDXVA_DCCMD;

/* Alpha blend combination */

typedef struct _DXVA_BlendCombination {
  WORD wPictureSourceIndex;
  WORD wBlendedDestinationIndex;
  RECT PictureSourceRect16thPel;
  RECT PictureDestinationRect;
  RECT GraphicSourceRect;
  RECT GraphicDestinationRect;
  WORD wBlendDelay;
  BYTE bBlendOn;
  BYTE bWholePlaneAlpha;
  DXVA_AYUVsample OutsideYUVcolor;
} DXVA_BlendCombination, *LPDXVA_BlendCombination;


/* Encryption Protocol #1 Data Structure */

#define DXVA_MAX_URIsize  1024

typedef struct _DXVA_EncryptProt1Data_Sign512_Accel512 {
  DXVA_EncryptProtocolHeader header;

  DWORD  dwSigningModulusSize;  /* equal to 64 */
  BYTE   SigningModulusValue[64];
  DWORD  dwSigningExponentSize; /* equal to 64 */
  BYTE   SigningExponentValue[64];

  DWORD  dwAccelModulusSize;    /* equal to 64 */
  BYTE   AccelModulusValue[64];
  DWORD  dwAccelExponentSize;   /* equal to 64 */
  BYTE   AccelExponentValue[64];

  DWORD  dwEncryptionFrequency;

  DWORD  dwURIsize;
  WCHAR  URIstring[DXVA_MAX_URIsize];

  BYTE   Signature[64];
} DXVA_EncryptProt1Data_Sign512_Accel512,
  *LPDXVA_EncryptProt1Data_Sign512_Accel512;


#pragma pack(push, 16)


typedef DXVA_MBctrl_I_HostResidDiff_1 *
       LPDXVA_MBctrl_I_HostResidDiff_1;

typedef DXVA_MBctrl_I_OffHostIDCT_1 *
       LPDXVA_MBctrl_I_OffHostIDCT_1;

typedef DXVA_MBctrl_P_HostResidDiff_1 *
       LPDXVA_MBctrl_P_HostResidDiff_1;

typedef DXVA_MBctrl_P_OffHostIDCT_1 *
       LPDXVA_MBctrl_P_OffHostIDCT_1;


#pragma pack(pop)

/*
 * Other forms of pictures are constructed in the obvious way
 * from the above by adjusting the number of residual difference
 * blocks, the number of motion vectors per macroblock, etc.
 */

#define readDXVA_MBskipsFollowing(ptr)       (((ptr)->dwMB_SNL & 0xFF000000) >> 24)
#define readDXVA_MBdataLocation(ptr)         (((ptr)->dwMB_SNL & 0x00FFFFFF))

#define writeDXVA_MB_SNL(ptr, skips, dloc)   ((ptr)->dwMB_SNL = (((skips) << 24) | (dloc)))
#define setDXVA_MBskipsFollowing(ptr, skips) ((ptr)->dwMB_SNL |= ((skips) << 24))
#define setDXVA_MBdataLocation(ptr, dloc)    ((ptr)->dwMB_SNL |= (dloc))

#define readDXVA_MvertFieldSel_3(ptr)    (((ptr)->wMBtype & 0x8000) >> 15)
#define readDXVA_MvertFieldSel_2(ptr)    (((ptr)->wMBtype & 0x4000) >> 14)
#define readDXVA_MvertFieldSel_1(ptr)    (((ptr)->wMBtype & 0x2000) >> 13)
#define readDXVA_MvertFieldSel_0(ptr)    (((ptr)->wMBtype & 0x1000) >> 12)
#define readDXVA_ReservedBits(ptr)       (((ptr)->wMBtype & 0x0800) >> 11)
#define readDXVA_HostResidDiff(ptr)      (((ptr)->wMBtype & 0x0400) >> 10)
#define readDXVA_MotionType(ptr)         (((ptr)->wMBtype & 0x0300) >>  8)
#define readDXVA_MBscanMethod(ptr)       (((ptr)->wMBtype & 0x00C0) >>  6)
#define readDXVA_FieldResidual(ptr)      (((ptr)->wMBtype & 0x0020) >>  5)
#define readDXVA_H261LoopFilter(ptr)     (((ptr)->wMBtype & 0x0010) >>  4)
#define readDXVA_Motion4MV(ptr)          (((ptr)->wMBtype & 0x0008) >>  3)
#define readDXVA_MotionBackward(ptr)     (((ptr)->wMBtype & 0x0004) >>  2)
#define readDXVA_MotionForward(ptr)      (((ptr)->wMBtype & 0x0002) >>  1)
#define readDXVA_IntraMacroblock(ptr)    (((ptr)->wMBtype & 0x0001))

#define setDXVA_MvertFieldSel_3(ptr)     ((ptr)->wMBtype |= 0x8000)
#define setDXVA_MvertFieldSel_2(ptr)     ((ptr)->wMBtype |= 0x4000)
#define setDXVA_MvertFieldSel_1(ptr)     ((ptr)->wMBtype |= 0x2000)
#define setDXVA_MvertFieldSel_0(ptr)     ((ptr)->wMBtype |= 0x1000)
#define setDXVA_ReservedBits(ptr)        ((ptr)->wMBtype |= 0x0800)
#define setDXVA_HostResidDiff(ptr)       ((ptr)->wMBtype |= 0x0400)
#define setDXVA_MotionType(ptr, value)   ((ptr)->wMBtype |= ((value) << 8))
#define setDXVA_MBscanMethod(ptr, value) ((ptr)->wMBtype |= ((value) << 6))
#define setDXVA_FieldResidual(ptr)       ((ptr)->wMBtype |= 0x0020)
#define setDXVA_H261LoopFilter(ptr)      ((ptr)->wMBtype |= 0x0010)
#define setDXVA_Motion4MV(ptr)           ((ptr)->wMBtype |= 0x0008)
#define setDXVA_MotionBackward(ptr)      ((ptr)->wMBtype |= 0x0004)
#define setDXVA_MotionForward(ptr)       ((ptr)->wMBtype |= 0x0002)
#define setDXVA_IntraMacroblock(ptr)     ((ptr)->wMBtype |= 0x0001)

#define readDXVA_Y___0coded(ptr)        (((ptr)->wPatternCode & 0x0800) >> 11)
#define readDXVA_Y___1coded(ptr)        (((ptr)->wPatternCode & 0x0400) >> 10)
#define readDXVA_Y___2coded(ptr)        (((ptr)->wPatternCode & 0x0200) >>  9)
#define readDXVA_Y___3coded(ptr)        (((ptr)->wPatternCode & 0x0100) >>  8)
#define readDXVA_Cb__4coded(ptr)        (((ptr)->wPatternCode & 0x0080) >>  7)
#define readDXVA_Cr__5coded(ptr)        (((ptr)->wPatternCode & 0x0040) >>  6)
#define readDXVA_Cb__6coded(ptr)        (((ptr)->wPatternCode & 0x0020) >>  5)
#define readDXVA_Cr__7coded(ptr)        (((ptr)->wPatternCode & 0x0010) >>  4)
#define readDXVA_Cb__8coded(ptr)        (((ptr)->wPatternCode & 0x0008) >>  3)
#define readDXVA_Cb__9coded(ptr)        (((ptr)->wPatternCode & 0x0004) >>  2)
#define readDXVA_Cr_10coded(ptr)        (((ptr)->wPatternCode & 0x0002) >>  1)
#define readDXVA_Cr_11coded(ptr)        (((ptr)->wPatternCode & 0x0001))

#define readDXVA_Y___0oflow(ptr)        (((ptr)->wPC_Overflow & 0x0800) >> 11)
#define readDXVA_Y___1oflow(ptr)        (((ptr)->wPC_Overflow & 0x0400) >> 10)
#define readDXVA_Y___2oflow(ptr)        (((ptr)->wPC_Overflow & 0x0200) >>  9)
#define readDXVA_Y___3oflow(ptr)        (((ptr)->wPC_Overflow & 0x0100) >>  8)
#define readDXVA_Cb__4oflow(ptr)        (((ptr)->wPC_Overflow & 0x0080) >>  7)
#define readDXVA_Cr__5oflow(ptr)        (((ptr)->wPC_Overflow & 0x0040) >>  6)
#define readDXVA_Cb__6oflow(ptr)        (((ptr)->wPC_Overflow & 0x0020) >>  5)
#define readDXVA_Cr__7oflow(ptr)        (((ptr)->wPC_Overflow & 0x0010) >>  4)
#define readDXVA_Cb__8oflow(ptr)        (((ptr)->wPC_Overflow & 0x0008) >>  3)
#define readDXVA_Cb__9oflow(ptr)        (((ptr)->wPC_Overflow & 0x0004) >>  2)
#define readDXVA_Cr_10oflow(ptr)        (((ptr)->wPC_Overflow & 0x0002) >>  1)
#define readDXVA_Cr_11oflow(ptr)        (((ptr)->wPC_Overflow & 0x0001))

#pragma pack(pop, BeforeDXVApacking)

#ifdef __cplusplus
}
#endif

#endif /* __DIRECTX_VA__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\k32exp.h ===
/* 
 * K32EXP.H -- Get32ProcAddress
 * Win32 code to import by ordinal from KERNEL32.DLL in Windows 95
 *
 * Andrew Schulman
 * Senior editor, O'Reilly & Associates (Sebastopol CA)
 * andrew@ora.com
 * 
 * August 1995
 */

// KERNEL32.1 through KERNEL32.9 are all VxDCall
#define VXDCALL_ORD                 1

// found these by examining RUNDLL32.EXE
#define LOADLIBRARY16_ORD           35
#define FREELIBRARY16_ORD           36
#define GETPROCADDRESS16_ORD        37

// found these by examining WOW32.DLL
// actually, these are documented: see GENTHUNK.TXT ("Windows NT
// Generic Thunk Overview") and WOWNT32.H in Microsoft's Win32 SDK
#define WOWCallback16_ORD           54                      
#define WOWCallback16Ex_ORD         55                      
#define WOWGetVDMPointer_ORD        56                      
#define WOWHandle32_ORD             57                      
#define WOWHandle16_ORD             58                      
#define WOWGlobalAlloc16_ORD        59                      
#define WOWGlobalLock16_ORD         60                      
#define WOWGlobalUnlock16_ORD       61                      
#define WOWGlobalFree16_ORD         62                      
#define WOWGlobalAllocLock16_ORD    63                      
#define WOWGlobalUnlockFree16_ORD   64                      
#define WOWGlobalLockSize16_ORD     65                      
#define WOWYield16_ORD              66                      
#define WOWDirectedYield16_ORD      67                      
#define WOWGetVDMPointerFix_ORD     68                      
#define WOWGetVDMPointerUnfix_ORD   69                      
#define WOW32_1_ORD                 70

// found these by examining NTDLL.DLL (Win95)
#define RtlLargeIntegerAdd_ORD              72 
#define RtlEnlargedIntegerMultiply_ORD      73 
#define RtlEnlargedUnsignedMultiply_ORD     74 
#define RtlEnlargedUnsignedDivide_ORD       75 
#define RtlExtendedLargeIntegerDivide_ORD   76 
#define RtlExtendedMagicDivide_ORD          77 
#define RtlExtendedIntegerMultiply_ORD      78 
#define RtlLargeIntegerShiftLeft_ORD        79 
#define RtlLargeIntegerShiftRight_ORD       80 
#define RtlLargeIntegerArithmeticShift_ORD  81 
#define RtlLargeIntegerNegate_ORD           82 
#define RtlLargeIntegerSubtract_ORD         83 
#define RtlConvertLongToLargeInteger_ORD    84 
#define RtlConvertUlongToLargeInteger_ORD   85 

#define GETPWIN16MUTEX_ORD          93
#define ENTERSYSLEVEL_ORD           97
#define LEAVESYSLEVEL_ORD           98

// VxDCall is probably the most important undocumented Win32 API
DWORD (WINAPI *VxDCall)(DWORD srvc, DWORD eax, DWORD ecx);

// Walking VxD chain shows that these are the VxDs that provide
// Win32 services
#define VMM_ID          0x0001             // 41 services
#define REBOOT_ID       0x0009             // 2
#define VNETBIOS_ID     0x0014             // 2
#define VWIN32_ID       0x002A             // 79
#define VCOMM_ID        0x002B             // 27
#define VCOND_ID        0x0038             // 53 -- Virtual CON (Console)

// found these by examining ADVAPI32.DLL and REGSERV.EXE
// REGSERV.EXE calls these directly for remote registry services
#define RegOpenKeyEx_CALL                   0x10011
#define RegCreatKeyA_CALL                   0x10012
#define RegCloseKey_CALL                    0x10013
#define RegDeleteKey_CALL                   0x10014
#define RegSetValueA_CALL                   0x10015
#define RegDeleteValueA_CALL                0x10016
#define RegQueryValueA_CALL                 0x10017
#define RegEnumKeyA_CALL                    0x10018
#define RegQueryValueEx_CALL                0x1001A
#define RegSetValueExA_CALL                 0x1001B
#define RegFlushKey_CALL                    0x1001C
#define RegLoadKeyA_CALL                    0x10021
#define RegUnloadKeyA_CALL                  0x10022
#define RegSaveKeyA_CALL                    0x10023
#define RegRemapPreDefKey_CALL              0x10024
#define RegQueryMultipleValuesA_CALL        0x10026
#define RegReplaceKeyA_CALL                 0x10027

// two important VWIN32 services
#define VWIN32_INT21_CALL       0x2A0010
#define VWIN32_INT31_CALL       0x2A0029
#define DosCall(eax, ecx)       VxDCall(VWIN32_INT21_CALL, (eax), (ecx))
#define DPMICall(eax, ecx)      VxDCall(VWIN32_INT31_CALL, (eax), (ecx))

#if 0
// other undocumented interfaces
HINSTANCE (WINAPI *LoadLibrary16)(LPCSTR lpLibFileName);
int (WINAPI *FreeLibrary16)(HINSTANCE hModule);
FARPROC (WINAPI *GetProcAddress16)(HINSTANCE hModule, LPCSTR lpProcName);
void (WINAPI *GetpWin16Lock)(DWORD *pWin16Lock);
// int (WINAPI *_ConfirmWin16Lock)(void);  // returns current lock count
void (WINAPI *_EnterSysLevel)(DWORD lock);
void (WINAPI *_LeaveSysLevel)(DWORD lock);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\MINIVDD.H ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49
#define TURN_VGA_OFF                         50
#define TURN_VGA_ON                          51
#define SET_ADAPTER_POWER_STATE              52
#define GET_ADAPTER_POWER_STATE_CAPS         53
#define SET_MONITOR_POWER_STATE              54
#define GET_MONITOR_POWER_STATE_CAPS         55
#define NBR_MINI_VDD_FUNCTIONS_41            56

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)
//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_ENUM                            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle, or device id (1-N)
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flag
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_TEST       0x00000001


//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//          NotifyMask      - bitfield of events
//          NotifyType      - type of notify
//          NotifyProc      - notify procedure
//          NotifyData      - client data
//
//  output:
//           none
//
//  return:
//          ERROR_SUCCES
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;


//
// NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1


//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\GLOBAL.H ===
#ifndef _global_h // multiple include protection
#define _global_h

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
// All globals go into the 'global' structure. We divie the big structure up into
// banks. Every bank is a multiple of 32 bytes big. We place globals that are used
// together in inner loops in the same bank. This way we minimize pentium cache
// misses
//
// we assume that this structure starts 32-byte aligned. Will be so once all globs
// are placed here - and the C libraries do not mess with us... Look at .map output
// for alignment info
//
#pragma pack(push,1) // we control alignment

#ifdef SW_WC
#define SW_WC_LINES2FILL    48
#define SW_WC_LINESIZE      64
#define SW_WC_BYTES         (SW_WC_LINES2FILL*SW_WC_LINESIZE)
#define SW_WC_SIZE          (SW_WC_BYTES/4)     //# of DWORDS
#endif

typedef struct KATMAI_STATE
{
    // nv4/5
    float fFogC1[4];
    float fFogC2[4];
    float fFogTableDensity[4];
    float fFogTableLinearScale[4];
    float fFogTableStart[4];
    float fFogTableEnd[4];
    float fRHW[4];
    DWORD dwFogValue[4];
    float fZero[4];
    float fOne[4];
    float f255[4];
    DWORD dwMask3[4];
    // supertri
#ifdef SW_WC
    DWORD dwTriDispatch[SW_WC_SIZE];
#else
    DWORD dwTriDispatch[4];
#endif

#if (NVARCH >= 0x020)
#ifdef SW_WC
    DWORD dwKelvinTriDispatch[SW_WC_SIZE];
#else
    DWORD dwKelvinTriDispatch[4];
#endif
#endif
    struct TLVERTEX
    {
        float x,y,z,w;
        DWORD outCode;
        DWORD signOfW;
        DWORD _pad[2];
    } adwTLVertexCache[VB_CACHE_SIZE];
} KATMAI_STATE;

//---------------------------------------------------------------------------

#define SOFT_WC_SIZE    64 // must be power of 2, must be less than 120
typedef struct _GLOBALCELSIUSDATA
{
// bank
    DWORD  pContext;
    DWORD  pContext_hwState;
    DWORD  dwPrimCount;
    DWORD  pIndices;
    DWORD  pVertices;
    DWORD  dwVertexSN;
    DWORD  dwSoftWCIndex;
    DWORD  dwLoopCache;
// bank
    DWORD  dwVBIndex;
    DWORD  dwVBOffset;
    DWORD  dwVBGetOffset;
    DWORD  dwVBThreshold;
    DWORD  dwVerticesBatched;
    DWORD  dwPrimsBatched;
    DWORD  dwPrefetchBase;
    DWORD  dwPrefetchMax;
// bank
    DWORD  dwCullValue;
    DWORD  pIndexBase;          // used by inl prim & legacy
    DWORD  dwVertexStride;
    DWORD  dwIndexStride;
    DWORD  dwPrefMaxIdx;
    DWORD  dwEyeAddr;
    DWORD  dwCullAddr;
    DWORD  dwBaseVertex;
// bank
    float  pafMinInfo[4];
    float  pafMaxInfo[4];
// bank
    unsigned __int64 qwBegin3;
    unsigned __int64 qwEnd3;
    DWORD  _pad_c5[4];
// bank
    DWORD  dwOffsetXYZ;
    DWORD  dwOffsetRHW;
    DWORD  dwOffsetDiffuse;
    DWORD  dwOffsetSpecular;
    DWORD  dwOffsetNormal;
    DWORD  dwOffsetWeight;
    DWORD  _pad_c6[2];
// bank
    DWORD  dwOffsetUV[8];
// bank
    DWORD  dwSoftWCBuffer[SOFT_WC_SIZE];
} GLOBALCELSIUSDATA;

//---------------------------------------------------------------------------

#define KELVIN_MAX_REUSE 4
#define KELVIN_REUSE_MASK (KELVIN_MAX_REUSE-1)

typedef struct _GLOBALKELVINDATA
{
// bank
    DWORD  pContext;
    DWORD  pContext_kelvinState;
    DWORD  dwPrimCount;
    DWORD  pIndices;
    DWORD  pVertices;
    DWORD  dwVertexSN;
    DWORD  dwSoftWCIndex;
    DWORD  dwLoopCache;
// bank
    DWORD  dwVBIndex;
    DWORD  dwVBOffset;
    DWORD  dwVBGetOffset;
    DWORD  dwVBThreshold;
    DWORD  dwVerticesBatched;
    DWORD  dwPrimsBatched;
    DWORD  dwPrefetchBase;
    DWORD  dwPrefetchMax;
// bank
    DWORD  dwCullValue;
    DWORD  pIndexBase;          // used by inl prim & legacy
    DWORD  dwVertexStride;
    DWORD  dwIndexStride;
    DWORD  dwPrefMaxIdx;
    DWORD  dwEyeAddr;
    DWORD  dwCullAddr;
    DWORD  dwBaseVertex;
// bank
    float  pafMinInfo[4];
    float  pafMaxInfo[4];
// bank
    unsigned __int64 qwBegin;
    unsigned __int64 qwEnd;
    DWORD  _pad_c5[4];
// bank
// bank
    DWORD  dwOffsetXYZ;
    DWORD  dwOffsetRHW;
    DWORD  dwOffsetDiffuse;
    DWORD  dwOffsetSpecular;
    DWORD  dwOffsetNormal;
    DWORD  dwOffsetWeight;
    DWORD  dwOffsetPointSize;
    DWORD  _pad_c6[1];
// bank
    DWORD  dwOffsetUV[8];
// bank
    DWORD dwSoftWCBuffer[SOFT_WC_SIZE];
// bank
    DWORD   dwVertexReuse[KELVIN_MAX_REUSE];
// bank
    DWORD   dwCurrentHistoryIndex;
    DWORD   dwHistoryIndex;
    DWORD   __pad_c7[6];

} GLOBALKELVINDATA;

//---------------------------------------------------------------------------

typedef struct {
//////////
// debug and retail banks
// bank
    DWORD nvCachedPut;          // only used by inner loops
    DWORD nvCachedThreshold;    // only used by inner loops
    BYTE* dwILCData;
    DWORD dwILCCount;
    DWORD dwILCMax;
    DWORD dwCullMask1;
    DWORD dwCullMask2;
// bank
    DWORD    dwDelayCount;
    float    fPixelCount;
    double   fdMushLimitClocksPerTri;
    double   fdMushLimitClocksPerPixel;
//bank
    double   fdMushLimitClocksPerFrame;
    __int64  i64MushStart;
    DWORD    dwTriCountTotal;
    DWORD   _dwPad001[3];

// bank
    GLOBALCELSIUSDATA celsius;

// bank
    GLOBALKELVINDATA  kelvin;

    // dx5/dx6
// bank
    DWORD dwPrimCount;          // # of primitives to render
    DWORD pVertices;            // vertex list
    DWORD pIndices;             // index list (NULL for ordered prims)
    DWORD dwPrimBatchCount;     // # of prims per batch
    DWORD dwStripSense;         // strip sense (0 or 4)
    DWORD dwVertexSN;           // current vertex cache serial number
    DWORD dwVertexCount;        // vertex dispatcher vertex count
    float fCTC1;
// bank
    DWORD dwIndex0;             // )
    DWORD dwIndex1;             //  ) current triangle index
    DWORD dwIndex2;             // )
    DWORD dwVertex0;            // )
    DWORD dwVertex1;            //  ) current triangle
    DWORD dwVertex2;            // )
    DWORD dwBlendRegister;      // blend register (with spec enabled)
    DWORD dwSpecularCount;      // timeout for spec hack
// bank
    DWORD dwFlatColor;          // color used for flat shading
    DWORD dwFlatSpecular;       // specular used for flat shading
    float fRWFar;
    DWORD dwTemp;
#ifdef INSTRUMENT_INNER_LOOPS
    DWORD dwBytesCopied;
#else
    DWORD _reserved;
#endif
    DWORD dwMaxVertexOffset;    // used under NT only to validate vertices
    DWORD _pad2_3[1];
    KATMAI_STATE *pKNI;

    // bank 2.4 - note that the following variables start on the next 16-byte boundary and
    //            not neccesseraly exactly where this definition shows
    BYTE  kni[sizeof(KATMAI_STATE) + 16];
    //          - end alignment exception
    // bank 2.5
    DWORD dwVertexCacheIndex[VB_CACHE_SIZE]; // indices of cache hits
    DWORD dwVertexCache[VB_CACHE_SIZE];     // vertex cache
    // bank 2.6
    DWORD dwDXRuntimeVersion;
    BOOL  b16BitCode;                       // the current call stack has propogated from 16-bit code
    DWORD dwVertexCacheDate;
    DWORD dwSpecularState;                  // used to cache whether specular is on or off
                                            // for the specular optimzation in the inner loops (0/1)

    // pointer to GDI's display enumeration function
#ifdef WINNT
    DWORD _pad2_6[4];
#else
    BOOL   (WINAPI* pfEnumDisplayDevices)(LPCSTR, DWORD, PDISPLAY_DEVICE, DWORD);
    HANDLE (WINAPI *pfOpenVxDHandle)(HANDLE);
    DWORD _pad2_6[2];
#endif

    // banks 5-36
    DWORD adwMemCopy[256];

    // bank 37
    CNvObject                  *pNvObjectHead;
    struct _NV_OBJECT_LIST     *pNvSurfaceLists;     // list of surface handle->object lists
    struct _NV_OBJECT_LIST     *pNvPaletteLists;     // list of palette handle->object lists
    struct _NV_OBJECT_LIST     *pNvVShaderLists;     // list of vertex shader handle->object lists
    struct _NV_OBJECT_LIST     *pNvPShaderLists;     // list of pixel shader handle->object lists
    struct _NV_OBJECT_LIST     *pNvPatchLists;       // list of patch handle->object lists

    // bank 38
    double fdClockPerTri;
    double fdClockPerPixel;
    float  fTotalPixelsTimes2;
    DWORD _pad_5[3];

#if (NVARCH >= 0x010)
    PCELSIUSCOMBINERPROGRAM     celsiusCombinerProgramTable[CELSIUSCPTABLE_SIZE];
#endif // NVARCH == 0x010


} global_struc;

extern global_struc global;

//---------------------------------------------------------------------------

__forceinline void nvDelay
(
    void
)
{
    DWORD dw = global.dwDelayCount;
    __asm
    {
    push ecx
        mov ecx,[dw]
xxx:
        loop xxx
    pop ecx
    }
}

//---------------------------------------------------------------------------

// encrypted registry keys

#define NV4D3D_REG_STRING_SIZE_MAX  32

typedef char reg_entry[NV4D3D_REG_STRING_SIZE_MAX];

// keep this structure in sync with its initialization in global.cpp
typedef struct
{
    DWORD dwID[8];
    DWORD dwSize;
    /*
     * Encrypted registry key strings.
     */
    // booleans
    reg_entry szAntiAliasEnableString;             // ANTIALIASENABLE
    reg_entry szAntiAliasForceEnableString;        // ANTIALIASFORCEENABLE
    reg_entry szAntiAliasDynamicEnableString;      // ANTIALIASDYNAMICENABLE
    reg_entry szAntiAliasConvolutionFastModeString;// ANTIALIASCONVOLUTIONFASTMODE
    reg_entry szCKCompatabilityEnableString;       // CKCOMPATABILITYENABLE
    reg_entry szDirectMapEnableString;             // DIRECTMAPENABLE
    reg_entry szEnforceStrictTrilinearString;      // ENFORCESTRICTTRILINEAR
    reg_entry szFlushAfterBlitEnableString;        // FLUSHAFTERBLITENABLE
    reg_entry szFogTableString;                    // FOGTABLEENABLE
    reg_entry szForceBlitWaitFlagEnableString;     // FORCEBLITWAITFLAGENABLE
    reg_entry szLimitQueuedFBBlitsEnableString;    // LIMITQUEUEDFBBLITSENABLE
    reg_entry szLogoEnableString;                  // LOGOENABLE
#ifndef TEXFORMAT_CRD
    reg_entry szPaletteEnableString;               // PALETTEENABLE
#endif  // !TEXFORMAT_CRD
    reg_entry szSquashWString;                     // SQUASHW
    reg_entry szSceneSyncString;                   // SCENESYNC
#ifndef TEXFORMAT_CRD
    reg_entry szTextureCompressionEnableString;    // TEXTURECOMPRESSIONENABLE
#endif  // !TEXFORMAT_CRD
    reg_entry szTextureManagementEnableString;     // TEXTUREMANAGEMENTENABLE
    reg_entry szTilingString;                      // TILINGENABLE
    reg_entry szZCullEnableString;                 // ZCULLENABLE
    reg_entry szUserMipMapsString;                 // USERMIPMAPS
    reg_entry szVideoTextureString;                // VIDEOTEXTURE
    reg_entry szVS_HOS_EmulationString;            // VS_HOS_EMULATION
    reg_entry szWEnableString;                     // WENABLE
    reg_entry szZ24EnableString;                   // Z24ENABLE
    reg_entry szZCompressEnableString;             // ZCOMPRESSENABLE
    DWORD dwSyncPoint0;
    // non-boolean enumerated types
    reg_entry szAntiAliasQualityString;            // ANTIALIASQUALITY
    reg_entry szAntiAliasDynamicFPS;               // ANTIALIASDYNAMICFPS
    reg_entry szCaptureConfigString;               // CAPTURECONFIG
    reg_entry szCaptureEnableString;               // CAPTUREENABLE
    reg_entry szCKRefString;                       // CKREF
    reg_entry szAnisotropicLevelString;            // ANISOTROPICLEVEL
    reg_entry szMipMapDitherEnableString;          // MIPMAPDITHERENABLE
#ifdef TEXFORMAT_CRD
    reg_entry szSurfaceFormatsDX7String;           // SURFACEFORMATSDX7
    reg_entry szSurfaceFormatsDX8String;           // SURFACEFORMATSDX8
#endif  // TEXFORMAT_CRD
    reg_entry szTexelAlignmentString;              // TEXELALIGNMENT
    reg_entry szTextureManageStrategyString;       // TEXTUREMANAGESTRATEGY
    reg_entry szValidateZMethodString;             // VALIDATEZMETHOD
    reg_entry szVSyncModeString;                   // VSYNCMODE
    reg_entry szW16FormatString;                   // W16FORMAT
    reg_entry szW32FormatString;                   // W32FORMAT
    DWORD dwSyncPoint1;
    // non-boolean non-enumerated types
    reg_entry szAACompatibilityBitsString;         // AACOMPATIBILITYBITS
    reg_entry szAAReadCompatibilityFileString;     // AAREADCOMPATIBILITYFILE
    reg_entry szAGPTextureCutoff;                  // AGPTEXCUTOFF
    reg_entry szCapturePlayFilenum;                // D3D_REG_CAPTUREPLAYFILENUM
    reg_entry szCaptureRecordFilenum;              // D3D_REG_CAPTUREPLAYRECORDNUM
    reg_entry szD3DContextMaxString;               // D3DCONTEXTMAX
    reg_entry szD3DTextureMaxString;               // D3DTEXTUREMAX
    reg_entry szDebugLevelString;                  // DEBUGLEVEL
    reg_entry szLodBiasAdjustString;               // LODBIASADJUST
    reg_entry szMinVideoTexSizeString;             // MINVIDEOTEXSIZE
    reg_entry szPCITexHeapSizeString;              // PCITEXHEAPSIZE
    reg_entry szPerformanceStrategyOrString;       // PSOR
    reg_entry szPerformanceStrategyAndString;      // PSAND
    reg_entry szPreRenderLimitString;              // NOVSYNCPRERENDERLIMIT
    reg_entry szPushBufferSizeMaxString;           // DMAPUSHBUFFERSIZEMAX
    reg_entry szWScale16String;                    // WSCALE16
    reg_entry szWScale24String;                    // WSCALE24
    reg_entry szZBiasString;                       // ZBIAS
    DWORD dwSyncPoint2;
    // strings
    reg_entry szCapturePlayFilenameString;         // CAPTUREPLAYFILENAME
    reg_entry szCapturePlayPathString;             // CAPTUREPLAYPATH
    reg_entry szCaptureRecordFilenameString;       // CAPTURERECORDFILENAME
    reg_entry szCaptureRecordPathString;           // CAPTURERECORDPATH
    DWORD dwSyncPoint3;
} reg_struc;
extern reg_struc reg;

//---------------------------------------------------------------------------

void decryptRegistryKeys (void);


#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// this function initializes globals - see global.c
void __stdcall init_globals (void);

// GUID compare functions which can be compiled as C or CPP
#if defined(__cplusplus) && !defined(WINNT)
#define IsEqualGUID_C(rguid1, rguid2) IsEqualGUID((rguid1), (rguid2))
#define IsEqualIID_C(riid1, riid2) IsEqualIID((riid1), (riid2))
#else
#define IsEqualGUID_C(rguid1, rguid2) IsEqualGUID(&(rguid1), &(rguid2))
#define IsEqualIID_C(riid1, riid2) IsEqualIID(&(riid1), &(riid2))
#endif  //  __cplusplus

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _global_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nv4Tables.h ===
#ifndef _NV4TABLES_H
#define _NV4TABLES_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nv4tables.h                                                      *
*     Constants and macros associated with nv4tables.cpp                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)    28Oct99     created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x004)

#define DRAW_PRIM_TABLE_ENTRIES      0x800

extern DWORD dwDrawPrimitiveTable [DRAW_PRIM_TABLE_ENTRIES+4];

#define LIST_STRIDES   0x00000303
#define STRIP_STRIDES  0x01010101
#define FAN_STRIDES    0x02000001
#define LEGACY_STRIDES 0x03000404

extern DWORD nv4DP2OpToStride [D3D_DP2OP_MAX+1];

#endif  // NVARCH >= 0x010

#endif  // _NV4TABLES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvAccess.h ===
//======================================================================
// Module:		nvAccess.cpp
// Description:	Generic kernel access routines that are neutral to the calling OS
// 
//  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
//======================================================================

#ifndef NVFILE_H
#define NVFILE_H

//#include <nvprecomp.h>

#ifdef WINNT

//#define NV_USE_ZW_PFUNCS

typedef LONG NTSTATUS;
//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED

//
// Valid values for the Attributes field
//

#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_VALID_ATTRIBUTES    0x000003F2L

//
// Object Attributes structure
//

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;


typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[64];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// begin_winnt

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all


#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)


#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)

// end_winnt


//
// Define share access rights to files and directories
//

#define FILE_SHARE_READ                 0x00000001  // winnt
#define FILE_SHARE_WRITE                0x00000002  // winnt
#define FILE_SHARE_DELETE               0x00000004  // winnt
#define FILE_SHARE_VALID_FLAGS          0x00000007

//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  0x00000010 is reserved for use for the old DOS SUBDIRECTORY flag
//        and is therefore not considered valid in NT.  This flag has
//        been disassociated with file attributes since the other flags are
//        protected with READ_ and WRITE_ATTRIBUTES access to the file.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//


#define FILE_ATTRIBUTE_READONLY             0x00000001  // winnt
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  // winnt
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  // winnt
//OLD DOS VOLID                             0x00000008

#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  // winnt
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  // winnt
#define FILE_ATTRIBUTE_DEVICE               0x00000040  // winnt
#define FILE_ATTRIBUTE_NORMAL               0x00000080  // winnt

#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  // winnt
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200  // winnt
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400  // winnt
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  // winnt

#define FILE_ATTRIBUTE_OFFLINE              0x00001000  // winnt
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000  // winnt
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000  // winnt


//
//  This definition is old and will disappear shortly
//

#define FILE_ATTRIBUTE_CONTENT_INDEXED      FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

#define FILE_ATTRIBUTE_VALID_FLAGS      0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS  0x000031a7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//int 2e escape codes
#define ZWCREATEFILEFCODE 20h
#define ZWCLOSEHANDLEFCODE 18h
#define ZWWRITEFILEFCODE 0xed
#define ZWREADFILEFCODE	0xa1
#define ZWDEVICEIOCONTROLFILEFCODE 0x38
#define ZWOPENKEYCODE 0x67
#define ZWQUERYVALUECODE 0x9b
#define ZWSETVALUECODE 0xd7

#endif

BOOL NvReadFile(HANDLE hFile,                // handle to file
                LPVOID lpBuffer,             // data buffer
                DWORD nNumberOfBytesToRead,  // number of bytes to read
                LPDWORD lpNumberOfBytesRead, // number of bytes read
                LPOVERLAPPED lpOverlapped    // overlapped buffer
                );

BOOL NvWriteFile( HANDLE hFile,                    // handle to file
                LPCVOID lpBuffer,                // data buffer
                DWORD nNumberOfBytesToWrite,     // number of bytes to write
                LPDWORD lpNumberOfBytesWritten,  // number of bytes written
                LPOVERLAPPED lpOverlapped        // overlapped buffer
                );

BOOL NvCloseHandle(HANDLE h);

HANDLE NvCreateFile(LPCTSTR lpFileName,                         // file name
                   DWORD dwDesiredAccess,                      // access mode
                   DWORD dwShareMode,                          // share mode
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
                   DWORD dwCreationDisposition,                // how to create
                   DWORD dwFlagsAndAttributes,                 // file attributes
                   HANDLE hTemplateFile                        // handle to template file
                   );

BOOL NvDeviceIoControl(
                HANDLE hDevice,              // handle to device
                DWORD dwIoControlCode,       // operation control code
                LPVOID lpInBuffer,           // input data buffer
                DWORD nInBufferSize,         // size of input data buffer
                LPVOID lpOutBuffer,          // output data buffer
                DWORD nOutBufferSize,        // size of output data buffer
                LPDWORD lpBytesReturned,     // byte count
                LPOVERLAPPED lpOverlapped    // overlapped information
);


#endif

DWORD NvGetTickCount();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nv4caps.h ===
#ifndef _NV4DCAPS_H_
#define _NV4DCAPS_H_

/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DCAPS.H                                                        *
*   Define the capabilities of the NV4 D3D driver.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/26/98 - created                      *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL Capabilities
 * --------------------------------------------------------------------------
 */

/*
 * Define which fields of the D3DDEVICECAPS structure are valid.
 */
#define NV4_DEVDESC_FLAGS           D3DDD_COLORMODEL                    |   \
                                    D3DDD_DEVCAPS                       |   \
                                    D3DDD_LINECAPS                      |   \
                                    D3DDD_TRICAPS                       |   \
                                    D3DDD_DEVICERENDERBITDEPTH          |   \
                                    D3DDD_DEVICEZBUFFERBITDEPTH

/*
 * Define the color model for the D3D driver.
 */
#define NV4_COLORMODEL              D3DCOLOR_RGB

/*
 * Define the device capabilities.
 */
#define NV4_DEVCAPS_FLAGS           D3DDEVCAPS_FLOATTLVERTEX            |   \
                                    D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                    D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                    D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                    D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                    D3DDEVCAPS_DRAWPRIMITIVES2          |   \
                                    D3DDEVCAPS_DRAWPRIMITIVES2EX        |   \
                                    D3DDEVCAPS_HWRASTERIZATION

/*
 * Define the transformation capabilities.
 */
#define NV4_TRANSFORMCAPS_FLAGS     0

/*
 * Define 3D clipping capabilities.
 */
#define NV4_3DCLIPPINGCAPS          FALSE

/*
 * Define the lighting capabilities.
 */
#define NV4_LIGHTINGCAPS_FLAGS      0
#define NV4_MAX_LIGHTS              0

/*
 * Define NULL primary capabilities.
 */
#define NV4_PRIMCAPS_NULL           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

/*
 * Define the line capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_LINECAPS_MISC           D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW

/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_LINECAPS_RASTER         D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_FOGTABLE             |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_FOGRANGE             |   \
                                    D3DPRASTERCAPS_WBUFFER              |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_ZFOG			
//                                  D3DPRASTERCAPS_ANISOTROPY           |   \

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_LINECAPS_ZCMP           D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_LINECAPS_SRCBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_LINECAPS_DESTBLEND      D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_LINECAPS_ALPHACMP       D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_LINECAPS_SHADE          D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_LINECAPS_TEXTURE        D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define NV4_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_LINECAPS_TEXTUREBLEND   D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_LINECAPS_TEXTUREADDRESS D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_LINECAPS_STIPPLEWIDTH    0
#define NV4_LINECAPS_STIPPLEHEIGHT   0

/*
 * Define the triangle capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_TRICAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW

/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_TRICAPS_RASTER          D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_FOGTABLE             |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_FOGRANGE             |   \
                                    D3DPRASTERCAPS_WBUFFER              |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_ZFOG
//                                  D3DPRASTERCAPS_ANISOTROPY           |   \

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_TRICAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_TRICAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_TRICAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_TRICAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_TRICAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_TRICAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define NV4_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR            
                                    //D3DPTFILTERCAPS_MINFANISOTROPIC   
                                    //D3DPTFILTERCAPS_MAGFANISOTROPIC

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_TRICAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_TRICAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_TRICAPS_STIPPLEWIDTH    0
#define NV4_TRICAPS_STIPPLEHEIGHT   0

/*
 * Texture Ops
 */
#define NV4_CAPS_TEXTUREOPS   D3DTEXOPCAPS_DISABLE                      |   \
                              D3DTEXOPCAPS_SELECTARG1                   |   \
                              D3DTEXOPCAPS_SELECTARG2                   |   \
                              D3DTEXOPCAPS_MODULATE                     |   \
                              D3DTEXOPCAPS_MODULATE2X                   |   \
                              D3DTEXOPCAPS_MODULATE4X                   |   \
                              D3DTEXOPCAPS_ADD                          |   \
                              D3DTEXOPCAPS_ADDSIGNED                    |   \
                              D3DTEXOPCAPS_ADDSIGNED2X                  |   \
                              D3DTEXOPCAPS_ADDSMOOTH                    |   \
                              D3DTEXOPCAPS_SUBTRACT                     |   \
                              D3DTEXOPCAPS_BLENDDIFFUSEALPHA            |   \
                              D3DTEXOPCAPS_BLENDTEXTUREALPHA            |   \
                              D3DTEXOPCAPS_BLENDFACTORALPHA             |   \
                              D3DTEXOPCAPS_BLENDTEXTUREALPHAPM          |   \
                              D3DTEXOPCAPS_BLENDCURRENTALPHA            |   \
                              D3DTEXOPCAPS_PREMODULATE                  |   \
                              D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR       |   \
                              D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA       |   \
                              D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR    |   \
                              D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA

/*
 * Stencil Ops
 */
#define NV4_CAPS_STENCILOPS   D3DSTENCILCAPS_KEEP                       |   \
                              D3DSTENCILCAPS_ZERO                       |   \
                              D3DSTENCILCAPS_REPLACE                    |   \
                              D3DSTENCILCAPS_INCRSAT                    |   \
                              D3DSTENCILCAPS_DECRSAT                    |   \
                              D3DSTENCILCAPS_INVERT                     |   \
                              D3DSTENCILCAPS_INCR                       |   \
                              D3DSTENCILCAPS_DECR

/*
 * Vertex Processing Caps
 */
#define NV4_CAPS_VTXPCAPS     0

/*
 * Define the render bit depth capabilites.
 */
#define NV4_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

/*
 * Define the Z buffer bit depth capabilities.
 */
#define NV4_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

/*
 * Define the maximum execute buffer size capabilites.
 */
#define NV4_MAXBUFFERSIZE           0

/*
 * Define the maximum vertex count
 */
#define NV4_MAXVERTEXCOUNT          NVD3D_DEFAULT_TL_NUM

#define NV4_CAPS_MAX_TEXTURE_REPEAT                  0 // nv4's max tex coord is actually ~2^19, independent of texture
                                                       // size and geometry size, but apparently MS doesn't look at this
                                                       // value if D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE is set
#define NV4_CAPS_MAX_TEXTURE_ASPECT_RATIO            0
#define NV4_CAPS_MAX_ANISOTROPY                      0 // Means we support anisotropic filtering.
//#define NV4_CAPS_MAX_ANISOTROPY                      2 // Means we support anisotropic filtering.

#define NV4_CAPS_GUARD_BAND_LEFT                     -2048
#define NV4_CAPS_GUARD_BAND_TOP                      -2048
#define NV4_CAPS_GUARD_BAND_RIGHT                    2047
#define NV4_CAPS_GUARD_BAND_BOTTOM                   2047

#define NV4_CAPS_EXTENTS_ADJUST                      0
#define NV4_CAPS_MAX_UV_PAIRS                        8 // Number of texture uv's supported.
#define NV4_CAPS_FVF_CAPS                            (NV4_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define NV4_CAPS_MAX_TEXTURE_BLEND_STATES            4
#define NV4_CAPS_MAX_SIMULTANEOUS_TEXTURES           2

// DX7 stuff
#define NV4_CAPS_MAX_ACTIVE_LIGHTS                   0
#define NV4_CAPS_MAX_USER_CLIP_PLANES                0
#define NV4_CAPS_MAX_VERTEX_BLEND_MATRICES           0

#endif  // _NV4DCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvbenchmark.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvBenchmark.h
//        Prototypes and definitions for nvBenchmark.cpp utility class
//
//  History:
//        Menelaos Levas    1/30/2001
//
// **************************************************************************

#ifdef NV_PROFILE_DP2OPS

#define OUTPUT_TOTALS                   0x80000000
#define OUTPUT_ALL_DP2OPS               0x40000000
#define OUTPUT_HWSTATE_CHANGES          0x20000000

#define CLEAR_DATA                      0x08000000
#define OUTPUT_FRAMECOUNT               0x0000FFFF



class CBenchmark
{
public:
    DWORD logData(DWORD dwCommand, DWORD dwPrimCount);
    DWORD logDrawPrimitive(DWORD dwCount);
    DWORD beginHWStateChange(DWORD dwFlags, DWORD dwPut);
    DWORD endHWStateChange(DWORD dwPut);
    DWORD incActiveTextures();
    DWORD resetData();
    DWORD outputData(DWORD dwFlags);

protected:
    DWORD dwActiveTextures, dwLastPrimCount;
    DWORD dwHWStateChangeSize, dwStartPut;
    DWORD dwStateBlocks, dwDrawBlocks, dwLastType;
    DWORD dwCurrentFrame, dwHWStateChanges;
    DWORD dwDrawingCalls, dwStateCalls;
    DWORD dwDrawingPrimCount, dwStatePrimCount;
    DWORD dwTexPrims[5];
    DWORD dwHWChanged[13];
    DWORD dwStateBits[8192];
    DWORD dwCallsCountTable[D3D_DP2OP_MAX+1];
    DWORD dwPrimsCountTable[D3D_DP2OP_MAX+1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvClear.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVCLEAR.H                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)       07Jul99      created            *
*                                                                           *
\***************************************************************************/

#ifndef _NVCLEAR_H_
#define _NVCLEAR_H_

DWORD __stdcall nvClear  (LPD3DHAL_CLEARDATA);
DWORD __stdcall nvClear2 (LPD3DHAL_CLEAR2DATA pc2d);
void  nvCTDecodeBuffer   (CNvObject *pNvObj,DWORD dwAddr,DWORD dwBPP,
                          DWORD dwPitch,DWORD dwWidth,DWORD dwHeight);

#endif // _NVCLEAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvCelsiusCaps.h ===
#ifndef _NVCELSIUSCAPS_H_
#define _NVCELSIUSCAPS_H_

#if (NVARCH >= 0x010)
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusCaps.h                                                   *
*   Define the capabilities of the celsius D3D driver.                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     10Feb99     created                 *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL Capabilities
 * --------------------------------------------------------------------------
 */

/*
 * Define which fields of the D3DDEVICECAPS structure are valid.
 */
#define CELSIUS_DEVDESC_FLAGS           D3DDD_COLORMODEL                    |   \
                                        D3DDD_DEVCAPS                       |   \
                                        D3DDD_LINECAPS                      |   \
                                        D3DDD_TRICAPS                       |   \
                                        D3DDD_DEVICERENDERBITDEPTH          |   \
                                        D3DDD_DEVICEZBUFFERBITDEPTH

/*
 * Define the color model for the D3D driver.
 */
#define CELSIUS_COLORMODEL              D3DCOLOR_RGB

/*
 * Define the device capabilities.
 */
#define CELSIUS_DEVCAPS_FLAGS           D3DDEVCAPS_FLOATTLVERTEX            |   \
                                        D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                        D3DDEVCAPS_EXECUTEVIDEOMEMORY       |   \
                                        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                        D3DDEVCAPS_TLVERTEXVIDEOMEMORY      |   \
                                        D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                        D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                        D3DDEVCAPS_CANRENDERAFTERFLIP       |   \
                                        D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2          |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2EX        |   \
                                        D3DDEVCAPS_CANBLTSYSTONONLOCAL      |   \
                                        D3DDEVCAPS_PUREDEVICE               |   \
                                        D3DDEVCAPS_HWVERTEXBUFFER           |   \
                                        D3DDEVCAPS_HWINDEXBUFFER            |   \
                                        D3DDEVCAPS_HWTRANSFORMANDLIGHT      |   \
                                        D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                        D3DDEVCAPS_HWRASTERIZATION

/*
 * Define the transformation capabilities.
 */
#define CELSIUS_TRANSFORMCAPS_FLAGS     D3DTRANSFORMCAPS_CLIP

/*
 * Define 3D clipping capabilities.
 */
#define CELSIUS_3DCLIPPINGCAPS          TRUE

/*
 * Define the lighting capabilities.
 */
#define CELSIUS_LIGHTINGCAPS_FLAGS      D3DLIGHTINGMODEL_RGB                |   \
                                        D3DLIGHTCAPS_POINT                  |   \
                                        D3DLIGHTCAPS_SPOT                   |   \
                                        D3DLIGHTCAPS_DIRECTIONAL
#define CELSIUS_MAX_LIGHTS              8

/*
 * Define NULL primary capabilities.
 */
#define CELSIUS_PRIMCAPS_NULL           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

/*
 * Define the line capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define CELSIUS_LINECAPS_MISC           D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

/*
 * Raster capabilities (dwRasterCaps)
 */
#define CELSIUS_LINECAPS_RASTER         D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ZFOG

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define CELSIUS_LINECAPS_ZCMP           D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define CELSIUS_LINECAPS_SRCBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define CELSIUS_LINECAPS_DESTBLEND      D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define CELSIUS_LINECAPS_ALPHACMP       D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define CELSIUS_LINECAPS_SHADE          D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define CELSIUS_LINECAPS_TEXTURE        D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define CELSIUS_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define CELSIUS_LINECAPS_TEXTUREBLEND   D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define CELSIUS_LINECAPS_TEXTUREADDRESS D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define CELSIUS_LINECAPS_STIPPLEWIDTH    0
#define CELSIUS_LINECAPS_STIPPLEHEIGHT   0

/*
 * Define the triangle capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define CELSIUS_TRICAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

/*
 * Raster capabilities (dwRasterCaps)
 */
#define CELSIUS_TRICAPS_RASTER          D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ZFOG

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define CELSIUS_TRICAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define CELSIUS_TRICAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define CELSIUS_TRICAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define CELSIUS_TRICAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define CELSIUS_TRICAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define CELSIUS_TRICAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#define CELSIUS_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR          |   \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                        D3DPTFILTERCAPS_MAGFANISOTROPIC

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define CELSIUS_TRICAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define CELSIUS_TRICAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define CELSIUS_TRICAPS_STIPPLEWIDTH    0
#define CELSIUS_TRICAPS_STIPPLEHEIGHT   0

/*
 * Texture Ops
 */
#define CELSIUS_CAPS_TEXTUREOPS  D3DTEXOPCAPS_DISABLE                       |   \
                                 D3DTEXOPCAPS_SELECTARG1                    |   \
                                 D3DTEXOPCAPS_SELECTARG2                    |   \
                                 D3DTEXOPCAPS_MODULATE                      |   \
                                 D3DTEXOPCAPS_MODULATE2X                    |   \
                                 D3DTEXOPCAPS_MODULATE4X                    |   \
                                 D3DTEXOPCAPS_ADD                           |   \
                                 D3DTEXOPCAPS_ADDSIGNED                     |   \
                                 D3DTEXOPCAPS_ADDSIGNED2X                   |   \
                                 D3DTEXOPCAPS_SUBTRACT                      |   \
                                 D3DTEXOPCAPS_ADDSMOOTH                     |   \
                                 D3DTEXOPCAPS_BLENDDIFFUSEALPHA             |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHA             |   \
                                 D3DTEXOPCAPS_BLENDFACTORALPHA              |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHAPM           |   \
                                 D3DTEXOPCAPS_BLENDCURRENTALPHA             |   \
                                 D3DTEXOPCAPS_PREMODULATE                   |   \
                                 D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR        |   \
                                 D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA        |   \
                                 D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR     |   \
                                 D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA     |   \
                                 D3DTEXOPCAPS_DOTPRODUCT3                   |   \
                                 D3DTEXOPCAPS_MULTIPLYADD                   |   \
                                 D3DTEXOPCAPS_LERP

/*
 * Stencil Ops
 */
#define CELSIUS_CAPS_STENCILOPS  D3DSTENCILCAPS_KEEP                        |   \
                                 D3DSTENCILCAPS_ZERO                        |   \
                                 D3DSTENCILCAPS_REPLACE                     |   \
                                 D3DSTENCILCAPS_INCRSAT                     |   \
                                 D3DSTENCILCAPS_DECRSAT                     |   \
                                 D3DSTENCILCAPS_INVERT                      |   \
                                 D3DSTENCILCAPS_INCR                        |   \
                                 D3DSTENCILCAPS_DECR

/*
 * Vertex Processing Caps
 */
#define CELSIUS_CAPS_VTXPCAPS  D3DVTXPCAPS_TEXGEN                           |   \
                               /*D3DVTXPCAPS_MATERIALSOURCE7                |*/ \
                               D3DVTXPCAPS_VERTEXFOG                        |   \
                               D3DVTXPCAPS_DIRECTIONALLIGHTS                |   \
                               D3DVTXPCAPS_POSITIONALLIGHTS                 |   \
                               D3DVTXPCAPS_LOCALVIEWER

/*
 * Define the render bit depth capabilites.
 */
#define CELSIUS_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

/*
 * Define the Z buffer bit depth capabilities.
 */
#define CELSIUS_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

#endif  // NVARCH > 0x010
#endif  // _NVCELSIUSCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvblockmanager.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlockManager.cpp                                                *
*   block management/caching/renaming                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Franck Diard/Michael Conrad  21Feb2001  rel20 development            *
*                                                                           *
\***************************************************************************/


#ifdef MCFD

#if (NVARCH >= 0x04)

#include "nvprecomp.h" 
#pragma hdrstop
#endif

class CMipLevelSet;
class CBlockListHeader;
class CMipLevel;
class CTexture;
class CBlockList;
class CBlockDescriptor;


enum
{
    RENAME_POLICY_NO_COPY   = 1,            // rename if allowed
    RENAME_POLICY_COPY   = 2,            // rename if allowed and also copy contents forward
};
/*
enum
{
    ALLOCATE_SIMPLE         = 0x00000001,
    ALLOCATE_TILED          = 0x00000002,
    ALLOCATE_AS_ZBUFFER_UNC = 0x00000010,   // uncompressed z-buffer
    ALLOCATE_AS_ZBUFFER_CMP = 0x00000020,   // compressed z-buffer
    ALLOCATE_AS_ZBUFFER     = 0x00000030    // any z format
};

enum
{
    FLAG_UPTODATE           = 0x00000100,   // surface data is up to date (can be used)
    FLAG_RENDERTARGET       = 0x00000200,   // surface is a render target
    FLAG_ZBUFFER            = 0x00000400,   // surface is a zbuffer
    FLAG_DONOTOWNMEMORY     = 0x00000800,   // memory management is done by somebody else (not self)
    FLAG_TILED              = 0x00001000,   // surface was allocated in tiled memory
    FLAG_SWIZZLED           = 0x00002000,   // surface is a swizzled (used by nvSetRenderTargetDX7)
    FLAG_available          = 0x00004000,
    FLAG_HASALPHA           = 0x00008000,   // surface format has alpha
    FLAG_ISDXT              = 0x00010000,   // surface format is DXT
#ifdef  STEREO_SUPPORT
    FLAG_STEREO             = 0x00020000,   // surface is stereo
#endif  //STEREO_SUPPORT

};
typedef enum
{
    LOCK_NONE               = 0,            // reserved
    LOCK_READ               = 1,            // READ
    LOCK_WRITE              = 2,            // WRITE
}BMLockPermission;

typedef enum
{
    HEAP_LOCATION_MASK      = 0x0000001f,   // surface location - preserve order
}BMMask;
typedef enum
{
    HEAP_VID                = 0x01,
    HEAP_AGP                = 0x02,
    HEAP_PCI                = 0x04,
    HEAP_SYS                = 0x08,

    HEAP_DYNSYS             = 0x18,
    HEAP_DYNSYSBIT          = 0x10,
    HEAP_ANYWHERE           = HEAP_VID | HEAP_AGP | HEAP_PCI | HEAP_SYS | HEAP_DYNSYS,
    HEAP_NOWHERE            = 0x0,
}DWORD;
 */

extern DWORD g_adwSurfaceContextDMA[9];

inline BOOL  BMhwCanRead         (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) != CSimpleSurface::HEAP_SYS; }
inline BOOL  BMhwCanWrite        (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) == CSimpleSurface::HEAP_VID; }
inline BOOL  BMisReadCached      (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) >= CSimpleSurface::HEAP_PCI; }
inline BOOL  BMisWriteCached     (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) >= CSimpleSurface::HEAP_PCI; }
inline BOOL  BMisWriteCombined   (DWORD dwFlags)         { return (dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) <= CSimpleSurface::HEAP_AGP; }

#define MAXHEAD 4           // is there a limit here ?

BOOL GarbageCollect(DWORD Heap);

class CBlockManager
{
    friend CBlockList;
    friend CBlockDescriptor;

    //active blocks

	CBlockDescriptor * m_apVIDFirst[1];           // one heap per chip
	CBlockDescriptor * m_pAGPFirst;
	CBlockDescriptor * m_pPCIFirst;
	CBlockDescriptor * m_pSYSFirst;

    // cached block

	CBlockDescriptor * m_apVIDAllocCacheFirst[1];
	CBlockDescriptor * m_pAGPAllocCacheFirst;
	CBlockDescriptor * m_pPCIAllocCacheFirst;
	CBlockDescriptor * m_pSYSAllocCacheFirst;


    DWORD m_dwAllocatedVIDMemory;
    DWORD m_adwAllocatedVIDMemoryPerDevice[1];
    DWORD m_dwAllocatedAGPMemory;
    DWORD m_dwAllocatedPCIMemory;
    DWORD m_dwAllocatedSYSMemory;

    DWORD m_dwActiveBlocks;
    DWORD m_dwCachedBlocks;

public:

    CBlockManager();


    BOOL CBlockManager::GarbageCollect(DWORD Heaps);

    BOOL CreateBlock(CBlockList * BlockList,            // create, allocate and register a block, clone of SimpleSurface::create
        DWORD dwPitch,
        DWORD dwHeight,
        DWORD dwDepth,
        DWORD dwBPPGranted,
        DWORD dwAllowedHeaps,
        DWORD dwPreferredHeap,
        DWORD dwAllocFlags
    );

    BOOL AllocateBlock(
        CBlockDescriptor * ToFill,
        DWORD dwPitch,
        DWORD dwHeight,
        DWORD dwDepth,
        DWORD dwBPPGranted,
        DWORD dwAllowedHeaps,
        DWORD dwPreferredHeap,
        DWORD dwAllocFlags
    );

    BOOL OwnBlock(              CBlockList * BlockList,
                                DWORD dwAddress, DWORD dwPitch, DWORD dwLogHeight, 
                                DWORD dwHeapLocation, BOOL bOwnMemory );

    BOOL DisownBlock( CBlockList * BlockList);

    BOOL CreateBlock(CBlockDescriptor * ToClone);
    BOOL FreeBlock(CBlockList * BlockList, CBlockDescriptor * ToFree);
    BOOL FreeList(CBlockList * BlockList);
    BOOL Lock(CBlockList * BlockList, DWORD dwAccess, DWORD dwNewSize=-1);


private:
    BOOL AddToCachedBlockList(CBlockDescriptor * ToAdd);
    BOOL RegisterBlock(CBlockList * BlockList, CBlockDescriptor * ToAdd);
};

class CBlockDescriptor          // basically, a CSimpleSurface
{
    friend CBlockList;
    friend CBlockManager;

    DWORD   m_dwAddress;       // surface address [absolute]
    DWORD   m_dwOffset;        // surface offset [depends on dma context]
    DWORD   m_dwFlags;         // flags
    DWORD   m_dwHeap;
    DWORD   m_dwRetireDate;    // date that HW access retires
    DWORD   m_dwSize;         // size
    DWORD   m_dwAllocFlags;
    DWORD   m_dwPitch;
    DWORD   m_dwWidth;
    DWORD   m_dwHeight;        // height = 1 for vertex buffers, etc
    DWORD   m_dwDepth;         // depth = 1 for vertex buffers, etc

    CBlockList * m_pOwner; 

    CBlockDescriptor * m_pNextGlobal; // block manager use
    CBlockDescriptor * m_pPreviousGlobal; // block manager use        for debranching

	CBlockDescriptor * m_pNextRenamed; // renaming use
	CBlockDescriptor * m_pPreviousRenamed; // renaming use

public:
 


    inline BOOL  hwCanRead         (void)         const { return (BMhwCanRead(m_dwFlags)); }
    inline BOOL  hwCanWrite        (void)         const { return (BMhwCanWrite(m_dwFlags)); }
    inline BOOL  isReadCached      (void)         const { return (BMisReadCached(m_dwFlags)); }
    inline BOOL  isWriteCached     (void)         const { return (BMisWriteCached(m_dwFlags)); }
    inline BOOL  isWriteCombined   (void)         const { return (BMisWriteCombined(m_dwFlags)); }

    inline DWORD getAddress        (void)         const { return m_dwAddress; }
    inline DWORD getOffset         (void)         const { return m_dwOffset;  }
    inline DWORD getSize           (void)         const { return m_dwSize;  }

    inline DWORD getContextDMA     (void)         const { return g_adwSurfaceContextDMA[m_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK]; }
    inline DWORD getHeapLocation   (void)         const { return m_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK; }
    inline DWORD getFlags          (void)         const { return m_dwFlags; }

    BOOL IsBusy();

    CBlockDescriptor()
    {
        memset(this, 0, sizeof(CBlockDescriptor));
    }
};


class CBlockList
{
public:
    BOOL m_renaming;
    BOOL m_bOwnMemory;

	CBlockDescriptor * m_pActive;
	DWORD   m_dwNb;
	DWORD   m_dwMax;

    BOOL m_cpuLocked;
    BOOL m_gpuLocked;

    DWORD m_dwAllowedHeaps;
    DWORD m_dwPreferredHeap;
    DWORD m_dwBPPGranted;

    CBlockList(DWORD Max=6)
    {
        memset(this, 0, sizeof(CBlockList));
        m_dwMax=Max;
    }

    void  LockForGPU(DWORD dwAccess);
    void  UnlockForGPU(void);

    void  LockForCPU(DWORD dwAccess, DWORD dwRenamePolicy=RENAME_POLICY_NO_COPY);
    void  UnlockForCPU(void);

    BOOL Rename(DWORD dwRenamingCopyPolicy);

public:


    void  enableRenaming( ) {m_renaming=TRUE;};
    void  disableRenaming() {m_renaming=FALSE;};            // should cleanup


    inline DWORD modifyDDCaps (DWORD dwCaps) const
    {
        // clear all flags
        dwCaps &= ~(DDSCAPS_VIDEOMEMORY    |
                    DDSCAPS_LOCALVIDMEM    |
                    DDSCAPS_NONLOCALVIDMEM |
                    DDSCAPS_SYSTEMMEMORY);
        // put back the flags we want
        switch (m_pActive->m_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK)
        {
            case CSimpleSurface::HEAP_VID:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                break;
            case CSimpleSurface::HEAP_AGP:
            case CSimpleSurface::HEAP_PCI:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                break;
            // DDRAW just hates it if you specify the DDSCAPS_SYSTEMMEMORY flag. basically it will
            //  never call back to free surfaces. Ugghh.
            // believe it or not, it actually want the VidMem flag set!
            default:
                dwCaps |= (DDSCAPS_VIDEOMEMORY);
                break;
        }
        // return the new flags
        return (dwCaps);
    }
};



//////////////////////////// 

class CMipLevelSet
{
	void * m_data;  //pointer to the whole bitmap

	CBlockList m_blockList;   // list header of the blocks belonging to the renaming chain

	int m_pNbLevels;	   //number of items in the array
	CMipLevel * m_pLevels;     // the array  6 mip level -> new CMipLevel[6]
    BOOL m_bDirtyMipLevels;

	CTexture * m_pOwner;

	AllocateCreateVolume(DWORD dwWitdh, DWORD dwHeight, DWORD dwDepth, DWORD dwMip, DWORD SizeOfItem, DWORD dwFlags);
	AllocateCreate2DTexture(DWORD dwWitdh, DWORD dwHeight, DWORD dwMip, DWORD SizeOfItem, DWORD dwFlags);
	AllocateCreateCubeMap(DWORD dwWitdh, DWORD dwHeight, DWORD dwMip, DWORD SizeOfItem, DWORD dwFlags);

	UpdateMipMapChain(int MipLevelToExclude); //Update bitmap
	Lock(); // BM->Lock(m_blockList, rename_policy);
	UnLock();
};

class CMipLevel
{
	CMipLevelSet * m_pOwner;
	DWORD m_dwDataOffset;
	DWORD m_dwHeight;
	DWORD m_dwWidth;
	DWORD m_dwPitch;
	Lock(); // m_pOwner->Lock()
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvComp.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvComp_h
#define _nvComp_h

#ifdef __cplusplus
extern "C" {
#endif

// note: the two functions below CANNOT be used concurrently

// dx5/dx6 class
void __stdcall nvTriangleDispatch (NV_INNERLOOP_ARGLIST);
void __stdcall nvDX5TriangleSetup (PNVD3DCONTEXT, DWORD, LPWORD, LPBYTE);
void __stdcall nvDX6TriangleSetup (PNVD3DCONTEXT, DWORD, LPWORD, LPBYTE);

// fast mem copy
DWORD nvBuildCustomCopyRoutine (DWORD dwCount);
DWORD nvBuildCustomCopyRoutineMisAligned ();

#ifdef __cplusplus
}
#endif

#endif // _nvComp_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvContext.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvContext_h
#define _nvContext_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

extern "C++"
{

//---------------------------------------------------------------------------
// helpers

__forceinline DWORD swapRGB (DWORD dw) { return (dw & 0xff00ff00) | ((dw & 0x00ff0000) >> 16) | ((dw & 0x000000ff) << 16); }

//---------------------------------------------------------------------------
// nvidia mem copy

void nvMemCopyReset (void);
void nvMemCopy      (DWORD dwDest,DWORD dwSrc,DWORD dwCount);
__forceinline void nvMemCopy (void *pDest,void *pSrc,DWORD dwCount) { nvMemCopy(DWORD(pDest),DWORD(pSrc),dwCount); }

//---------------------------------------------------------------------------
// flip history

#define FLIP_HISTORY_SIZE 16  // should be power of 2
#define FLIP_HISTORY_MASK (FLIP_HISTORY_SIZE - 1)

typedef struct {
    DWORD surfacesFrom[FLIP_HISTORY_SIZE];  // circular buffer of surfaces we've flipped FROM
#ifdef CHECK_FLIP_TO
    DWORD surfacesTo[FLIP_HISTORY_SIZE];    // circular buffer of surfaces we've flipped TO
#endif
    DWORD dwIndex;                          // current buffer element
} FLIPHISTORY;

//---------------------------------------------------------------------------
// registry data

typedef struct _D3D_REGISTRYDATA
{
    // bank
    DWORD regD3DEnableBits1;
    DWORD regAntiAliasQuality;          // rel5 and later
    DWORD regColorkeyRef;
    DWORD regMipMapDitherMode;
    DWORD regTexelAlignment;
    DWORD regValidateZMethod;
    DWORD regVSyncMode;
    DWORD regW16Format;
    // bank
    DWORD regW32Format;
    DWORD regAGPTexCutOff;
    DWORD regD3DContextMax;
    DWORD regD3DTextureMax;
    DWORD regLODBiasAdjust;
    DWORD regMinVideoTextureSize;
    DWORD regPCITexHeapSize;
    DWORD regPreRenderLimit;
    // bank
    DWORD regPushBufferSizeMax;
    float regfWScale16;
    float regfWScale24;
    DWORD regAntiAliasDynamicMSpF;
    float regfZBias;
    DWORD regTextureManageStrategy;
    DWORD regAAReadCompatibilityFile;
    DWORD regDebugLevel;
    // bank
    DWORD regCaptureConfig;
    DWORD regCaptureEnable;
    DWORD regCapturePlayFilenum;
    DWORD regCaptureRecordFilenum;
    DWORD regAnisotropicLevel;
    DWORD regAACompatibilityBits;
#ifdef TEXFORMAT_CRD
    DWORD regSurfaceFormatsDX7;
    DWORD regSurfaceFormatsDX8;
#else   // !TEXFORMAT_CRD
    DWORD dwPad01[2];
#endif  // !TEXFORMAT_CRD
    // bank
    char  regszCapturePlayFilename[D3D_REG_STRING_LENGTH];
    char  regszCapturePlayPath[D3D_REG_STRING_LENGTH];
    char  regszCaptureRecordFilename[D3D_REG_STRING_LENGTH];
    char  regszCaptureRecordPath[D3D_REG_STRING_LENGTH];
} NVD3D_REGISTRYDATA;

//---------------------------------------------------------------------------
// device caps

typedef struct _NVD3D_DEVCAPS
{
#ifdef RM20
    // this padding is because the portion of VPE that lives in the RM is not quite
    // ready to switch direct7 yet
    DWORD                   paddingForVPE[272];
#else
    D3DDEVICEDESC_V1        dd1Caps;
    D3DHAL_D3DEXTENDEDCAPS  d3dExtCaps;
#endif
    D3DCAPS8                dwD3DCap8;
} NVD3D_DEVCAPS;

//---------------------------------------------------------------------------
// texture heap stuff

typedef struct _NVD3D_TEXTUREHEAPDATA
{
    DWORD dwHandle;
    DWORD dwBaseRaw;        // unaligned base address
    DWORD dwBase;           // aligned base address
    DWORD dwAllocHead;
    DWORD dwAllocTail;
    DWORD dwFreeHead;
    DWORD dwFreeTail;
    DWORD dwSize;
    // bank
    DWORD dwSizeMax;
    DWORD dwLimit;
    DWORD dwLimitMax;
    DWORD dwAllocSize;
    DWORD dwFreeSize;
    DWORD _pad[3];
} NVD3D_TEXTUREHEAPDATA;

//---------------------------------------------------------------------------
// forward declarations of things defined elsewhere

class CNvObject;
class CTexture;
class CPushBuffer;
class CVertexShader;
class CVertexBuffer;
class CReferenceCount;

#ifdef KPFS
#if (NVARCH >= 0x020)
class CKelvinProgramMan;
#endif
#endif

#ifdef NV_PROFILE_DP2OPS
class CBenchmark;
#endif

template <int cdwLogMax> class CReferenceCountMap;

//---------------------------------------------------------------------------
//
// driver context declaration
//  every instance here must preserve 32-byte alignment
//

class CDriverContext : public _GLOBALDATA
{
public:
    const enum {
        DC_ENABLESTATUS_DISABLED       = 0,   // push buffer, channels, and objects not allocated
        DC_ENABLESTATUS_ENABLED        = 1,   // push buffer, channels, and objects are allocated
        DC_ENABLESTATUS_PENDINGDISABLE = 2    // disable required at next opportunity
    };

public:
// bank
    BYTE                     pbScratchBuffer8192[8192]; // DO NOT MOVE OR RESIZE
// bank
    DWORD                    dwEnableStatus;
    DWORD                    dwEnablePixelDepth;
    DWORD                    dwAGPHeapList;
    DWORD                    dwAGPHeapListMax;
    DWORD                    dwAGPHashTableHead;
    DWORD                    dwAGPHashTable;
    DWORD                    dwAGPHashTableMax;
    BOOL                     bAGPHeapValid;
// bank
    DWORD                    dwFVFCachedType;
    DWORD                    dwCurrentBlit;             // used to count present blits to limit the number of frames we get ahead
    DWORD                    dwCurrentFlip[4];          // array of flip counts, one element per head
    DWORD                    dwCompletedFlip[4];
    BOOL                     bD3DViewVector;

#if (NVARCH >= 0x020)

#ifdef KELVIN_SEMAPHORES
    CPushBuffer              nvPusherDAC;
    CSemaphoreManager        nvSemaphoreManager;
    CFlipper                 nvFlipper;
#endif

#ifdef KPFS
    CKelvinProgramMan        nvKelvinPM;
#endif

#ifdef LPC_OPT
    DWORD dwLastDP2;
    DWORD dwThisDP2;
#endif    

#endif
    CDefaultVB               defaultVB;
    CDefaultVB               defaultSysVB;              // used to hold legacy user mode vertex data (can't this just be a CVertexBuffer?)
    CReferenceCountMap<5>   *pBlitTracker;
    FLIPHISTORY              flipHistory;

    NVD3D_REGISTRYDATA       nvD3DRegistryData;
    NVD3D_DEVCAPS            nvD3DDevCaps;

#if (NVARCH >= 0x04)
    NVD3D_TEXTUREHEAPDATA    nvD3DTexHeapData;

    D3DHAL_GLOBALDRIVERDATA  D3DGlobalDriverData;
    DWORD                    dwD3DContextCount;
    DWORD                    dwD3DTextureCount;
    DWORD                    dwAAContextCount;
    PNVD3DCONTEXT            dwContextListHead;
    PNVD3DCONTEXT            dwPreapprovedContextListHead;
    DWORD                    dwLastHWContext;           // the last d3d context for which celsius/kelvin was programmed
    DWORD                    dwOutOfContextCelsiusDirtyFlags;
#endif  // (NVARCH >= 0x04)

#ifdef NV_PROFILE_DP2OPS
    CBenchmark *pBenchmark;
#endif

    // nV logo stuff
    CNvObject               *pLogoObject;
    CTexture                *pLogoTexture;
    CVertexBuffer           *pLogoVertexBuffer;
    CVertexShader           *pLogoVertexShader;

    CTexture                *pDefaultTexture;           // Default texture rendering object.
    CTexture                *pClipPlaneTexture;         // Texture used for user clip planes

    // memory for unaligned texture access spoof
    DWORD                    dwSpareTextureAddr[2];
    DWORD                    dwSpareTextureOffset[2];

#ifdef TEXFORMAT_CRD
    // surface formats for < DX8
    DWORD                    dwSurfaceDescriptorCount;
    DDSURFACEDESC           *pSurfaceDescriptors;

    // surface formats for >= DX8
    DWORD                    dwPixelFormatCount;
    DDPIXELFORMAT           *pPixelFormats;
#endif  // TEXFORMAT_CRD

    // methods
public:
    __forceinline LPDDRAWI_DIRECTDRAW_GBL getDDGlobal (void) const { return (LPDDRAWI_DIRECTDRAW_GBL)pDriverData->dwDDGlobal; }

public:
    void create  (void);
    void destroy (void);

    // redefine 'new' for this class so that it zeroes out memory before returning it.
    // this is required because the memset can't be included in CDriverContext::CDriverContext;
    // at that point, the constructors for classes included in CDriverContext have already
    // been automatically called and we don't want to stomp on them.
    void * operator new (size_t sz)     {   void *p = new char[sz];
                                            if(p){memset(p,0,sz);}
                                            return p;   }

    // contruction
    CDriverContext  (void) {
        memset(&dwSpareTextureAddr[0],0xff,sizeof(dwSpareTextureAddr)); // Init to all 0xff (invalid addresses)
    };
    ~CDriverContext (void) {};
};

// this must be a macro so that we access the local pDriverData, if one exists, rather than the global
#define getDC() ((CDriverContext*)pDriverData)

}   // extern c++

#endif // _nvContext_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdbgsurf.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDbgSurf.cpp
//      Debug surface placement
//
// **************************************************************************
//
//  History:
//      Scott Kephart           01Dec00         NV20 development
//
// **************************************************************************


#ifdef DEBUG_SURFACE_PLACEMENT
#define CSD_MAX_BACK_BUFFERS 2
#define CSD_MAX_SURFACES 8

enum SurfDbgType {
FrontBuffer=0,
BackBuffer,
Z_Buffer,
AA_RenderTarget,
AA_Z_Buffer
};

class CSurfDebugOrder {
public:
    SurfDbgType     SurfaceType;
    CSimpleSurface  *pSurf;
    CSimpleSurface  Surf;
    bool Deleted;
    bool ReCreated;
};

#define ZTAG_MAX    1024

class CKelvinFBRegs {
public:
    DWORD nv_pfb_cfg0;
    DWORD nv_pfb_cfg1;
    DWORD nv_pfb_cstatus;
    DWORD nv_pfb_timing0;
    DWORD nv_pfb_timing1;
    DWORD nv_pfb_timing2;
    DWORD nv_pfb_tile[8];
    DWORD nv_pfb_tlimit[8];
    DWORD nv_pfb_tsize[8];
    DWORD nv_pfb_tstatus[8];
    DWORD nv_pfb_zcomp[8];
    DWORD nv_pfb_zcomp_max_tag;
    DWORD nv_pfb_zcomp_offset;
    DWORD nv_ztag0[ZTAG_MAX];
    DWORD nv_ztag1[ZTAG_MAX];
    DWORD nv_ztag2[ZTAG_MAX];
    DWORD nv_ztag3[ZTAG_MAX];
    
};

//---------------------------------------------------------------------------
class CSurfaceDebug 
{
private:
    int             FileNum;
    int             surf_cnt;
    BYTE           *pHWRegisters;
    CSurfDebugOrder Surfaces[CSD_MAX_SURFACES];
    bool            bInitialized;
    bool            bValidated;
    bool            bFileOpen;
    HANDLE          CSDFile;
    char outbuf[1024];
public:
    CSurfaceDebug() {};
    ~CSurfaceDebug() {};
    void Init();
    void Destroy();
    void DumpSurfaceInfo();
    void DumpCSimpleSurface(CSimpleSurface *p);
    void ValidateSurfacePlacement();
    void SetFrontBuffer(CSimpleSurface *pBuff);
    void SetBackBuffer(CSimpleSurface *pBuff);
    void SetZBuffer(CSimpleSurface *pBuff);
    void ReCreateZBuffer(CSimpleSurface *pBuff);
    void SetAARenderBuffer(CSimpleSurface *pBuff);
    void SetAAZBuffer(CSimpleSurface *pBuff);
    void DeleteSurface(CSimpleSurface *pBuff);
    void CaptureFBRegs();
private:
    void REG_WR32(DWORD addr, DWORD data);
    void REG_RD32(DWORD addr, DWORD &data);
    void RDI_REG_WR32(DWORD select, DWORD addr, DWORD data);
    void RDI_REG_RD32(DWORD select, DWORD addr, DWORD &data);
};
#endif //DEBUG_SURFACE_PLACEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvDefVB.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDefVB.h
//      default vertex buffer header file
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        15Jun00         creation
//
// **************************************************************************

#ifndef __NVDEFVB_H
#define __NVDEFVB_H

// forward declarations

class CVertexBuffer;
template <int cdwLogMax> class CReferenceCountMap;

//---------------------------------------------------------------------------

class CDefaultVB
{

private:
    CVertexBuffer           *m_pVertexBuffer;
    CReferenceCountMap<10>  *m_pRefCountMap;

public:
    DWORD                    m_dwCurrentOffset;
    DWORD                    m_dwTotalVerticesSincePut;

public:
    // inline functions
    inline CVertexBuffer* getVB (void)      {   return (m_pVertexBuffer);   }

    // prototypes
    BOOL  create             (DWORD dwHeap, DWORD dwSize);
    BOOL  destroy            (void);
    DWORD getHeap            (void);
    DWORD getAddress         (void);
    DWORD getSize            (void);
    DWORD getOffset          (void);
    DWORD getCachedOffset    (void);
    void  updateOffset       (DWORD dwOffset);
    void  updateMap          (void);
    DWORD waitForSpace       (int iSize, BOOL bWait);

private:
    DWORD dispatchWrapAround (int iVBOffset);

    // construction
public:
    CDefaultVB  (void);
    ~CDefaultVB (void);

    // friends
    friend void nvCelsiusILCompile_computeIndexAndOffset (DWORD dwVBStride, DWORD dwLogStride);

};

#endif  // __NVDEFVB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\NVD3DMAC.H ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvD3DMac.h
//      Define various macros used in the D3D driver.
//
//      THESE SHOULD BE STAND-ALONE MACROS. THERE SHOULD BE NO
//      DEPENDENCIES ON OTHER NV HEADER FILES!!
//
// **************************************************************************
//
//  History:
//      Charles Inman (chasi)       01/31/98 - Created.
//
// **************************************************************************

#ifndef _NVD3DMAC_H_
#define _NVD3DMAC_H_

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------------

// swap two 4-byte values using temporary storage
#define NV_SWAP_1(a,b)                      \
{                                           \
    DWORD c;                                \
    c                = *(DWORD *)(&(a));    \
    *(DWORD *)(&(a)) = *(DWORD *)(&(b));    \
    *(DWORD *)(&(b)) = c;                   \
}

// swap two 4-byte values using XORs
#define NV_SWAP_2(a,b)                      \
{                                           \
    *(DWORD *)(&(a)) ^= *(DWORD *)(&(b));   \
    *(DWORD *)(&(b)) ^= *(DWORD *)(&(a));   \
    *(DWORD *)(&(a)) ^= *(DWORD *)(&(b));   \
}

//---------------------------------------------------------------------------

// Some FP macros used in table fog. Thanks Jim!
#define FP_INV(r,p)                                     \
{                                                       \
    int _i = 2 * FP_ONE_BITS - *(int *)&(p);            \
    r = FLOAT_FROM_DWORD(_i);                           \
    r = r * (2.0f - (p) * r);                           \
}
#define FP_EXP(e,p)                                     \
{                                                       \
    int _i;                                             \
    e = -1.44269504f * (float)0x00800000 * (p);         \
    _i = (int)e + 0x3F800000;                           \
    e = FLOAT_FROM_DWORD(_i);                           \
}
#define FP_NORM_TO_BYTE(i,p)                            \
{                                                       \
    float _n = (p) + 1.0f;                              \
    (i) = *(int *)&_n;                                  \
    if ((i) >= 0x40000000)     (i) = 0xFF;              \
    else if ((i) <=0x3F800000) (i) = 0;                 \
    else (i) = ((i) >> 15) & 0xFF;                      \
}
#define FP_NORM_TO_BIT24(i,p)                           \
{                                                       \
    float _n = (p) + 1.0f;                              \
    (i) = *(int *)&_n;                                  \
    if ((i) >= 0x40000000)     (i) = 0xFF000000;        \
    else if ((i) <=0x3F800000) (i) = 0;                 \
    else (i) = ((i) << 9) & 0xFF000000;                 \
}

//---------------------------------------------------------------------------

// Fast floating point operations.

#define nvFloor(fp,fretval)                             \
{                                                       \
    int fpbits;                                         \
    int expo;                                           \
                                                        \
    if (fp < 0.0f) fp -= 0.9999999f;                    \
    fpbits = *(int *)&fp;                               \
    if ((fpbits >= 0) && (fpbits < 0x3F800000)) {       \
        fretval = 0.0f;                                 \
    }                                                   \
    else {                                              \
        expo = 150 - ((fpbits >> 23) & 0xFF);           \
        if (expo < 1) {                                 \
            fretval = fp;                               \
        }                                               \
        else {                                          \
            fpbits &= 0xFFFFFFFF << expo;               \
            fretval = FLOAT_FROM_DWORD(fpbits);         \
        }                                               \
    }                                                   \
}

//---------------------------------------------------------------------------

// D3D state macros.

#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)                                           \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state)                                          \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state)                                            \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state)                                          \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//---------------------------------------------------------------------------

// Memory management macros.

/* this is legacy (win3.1)

#define GlobalUnlockPtr32(lp)                                               \
        GlobalUnlock(GlobalHandle((LPCVOID)lp))

#define GlobalAllocPtr32(flags, cb)                                         \
        (GlobalLock(GlobalAlloc((flags), (cb))))

#define GlobalFreePtr32(lp)                                                 \
        (GlobalUnlockPtr32(lp), (BOOL)GlobalFree(GlobalHandle((LPCVOID)lp)))
*/

#define GlobalUnlockPtr32(lp)                                               \
        ((LPCVOID)lp)

#define GlobalAllocPtr32(flags, cb)                                         \
        (GlobalAlloc((flags), (cb)))

#define GlobalFreePtr32(lp)                                                 \
        ((BOOL)GlobalFree((LPCVOID)lp))


//---------------------------------------------------------------------------

// fog mode macros
// For NV4, table and vertex fog are handled identically, so reduce the two
// renderstates to one value. If both are something other than FOG_NONE,
// table fog wins
#define NV_FOG_MODE \
    (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] ?                    \
        (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader) ?                \
            pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] :          \
            (pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] ?         \
                pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] :      \
                pContext->dwRenderState[D3DRENDERSTATE_FOGVERTEXMODE])) :   \
        D3DFOG_NONE)

//---------------------------------------------------------------------------

// cull macro
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = (DWORD)(v0) + 0;                     \
    DWORD _sy0  = (DWORD)(v0) + 4;                     \
    DWORD _sx1  = (DWORD)(v1) + 0;                     \
    DWORD _sy1  = (DWORD)(v1) + 4;                     \
    DWORD _sx2  = (DWORD)(v2) + 0;                     \
    DWORD _sy2  = (DWORD)(v2) + 4;                     \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {

#define IF_NOT_CULLED_END } }

//---------------------------------------------------------------------------

#define NV_EVAL_CYLINDRICAL_WRAP(pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ)                                   \
{                                                                                                                       \
    BOOL bIndexOK; DWORD dwStream;                                                                                      \
    if (pContext->pCurrentVShader->hasProgram()) {                                                                      \
        bIndexOK = (dwTCIndex < 8) ? TRUE : FALSE;                                                                      \
    }                                                                                                                   \
    else {                                                                                                              \
        dwStream = pContext->pCurrentVShader->getVAStream (defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex]);            \
        bIndexOK = ((dwStream != CVertexShader::VA_STREAM_NONE) && (pContext->ppDX8Streams[dwStream])) ? TRUE : FALSE;  \
    }                                                                                                                   \
    if (bIndexOK) {                                                                                                     \
        bWrapU = ((pContext->dwRenderState[D3DRENDERSTATE_WRAPU]) ||                                                    \
                  (pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_0)) ? TRUE : FALSE;         \
        bWrapV = ((pContext->dwRenderState[D3DRENDERSTATE_WRAPV]) ||                                                    \
                  (pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_1)) ? TRUE : FALSE;         \
        bWrapP = ((pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_2)) ? TRUE : FALSE;         \
        bWrapQ = ((pContext->dwRenderState[D3DRENDERSTATE_WRAP0 + dwTCIndex] & D3DWRAPCOORD_3)) ? TRUE : FALSE;         \
    }                                                                                                                   \
    else {                                                                                                              \
        bWrapU = bWrapV = bWrapP = bWrapQ = FALSE;                                                                      \
    }                                                                                                                   \
}

//---------------------------------------------------------------------------

#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                             \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +       \
                                ((num) * sizeof(type)) + (extrabytes))

#define GET_FVF_POINTER(ptr, lpvert, mask, offset, index, stride)               \
    (ptr) = (BYTE *) ((((DWORD)(lpvert) + ((index) * (stride))) & (DWORD)(mask)) + (offset));

//---------------------------------------------------------------------------

/*
 * Need to make sure that an unfriendly mode switch didn't sneak and not cause
 * us to get re-enabled properly.
 */
#define DOS_FULLSCREEN_CHECK(pp)

/*
 * Set up all the current context state per call.  This should be as efficient as
 * possible as it is executed for every rendering entrypoint.
 * NB - we can't check pContext->dwRTHandle since 0 is actually valid for DX5 apps running on dx7
 */
#define NV_SET_CONTEXT(pContext,pp)                                             \
{                                                                               \
    pContext = (PNVD3DCONTEXT)((pp)->dwhContext);                               \
    if (!pContext) {                                                            \
        DPF("D3D: - Bad Context");                                              \
        (pp)->ddrval = D3DHAL_CONTEXT_BAD;                                      \
        dbgTracePop();                                                          \
        return (DDHAL_DRIVER_HANDLED);                                          \
    }                                                                           \
}

//---------------------------------------------------------------------------

/*
 * Some cool macros for use during texture swizzling.
 */
// the goal here is to interleave bits (pushing all higher order
// bits to the left as we go) until the texture width exceeds the
// height. at that point, we treat square chunks of the texture as
// swizzled 'blocks' that are indexed linearly by the higher order
// bits above those that are interleaved. (thus, we freeze the value
// of 'shift' when bit == h)

#define U_INTERLEAVE(u,uu,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    u = 0;                                                  \
    if (uu != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(w); bit <<= 1)            \
        {                                                   \
            u |= (uu & bit) << shift;                       \
            if (bit < (int)(h)) shift++;                    \
        }                                                   \
    }                                                       \
}
#define U_UNINTERLEAVE(u,uu,w,h)                            \
{                                                           \
    int bit, shift;                                         \
    u = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(w); bit << = 1)               \
    {                                                       \
        u |= (uu >> shift) & bit;                           \
        if (bit < (int)(h)) shift++;                        \
    }                                                       \
}
#define V_INTERLEAVE(v,vv,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    if (vv != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(h); bit <<= 1)            \
        {                                                   \
            if (bit < (int)(w)) shift++;                    \
            v |= (vv & bit) << shift;                       \
        }                                                   \
    }                                                       \
}
#define V_UNINTERLEAVE(v,vv,w,h)                            \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(h); bit <<= 1)                \
    {                                                       \
        if (bit < (int)(w)) shift++;                        \
        v |= (vv >> shift) & bit;                           \
    }                                                       \
}
#define U_INC_MASK(i,m,h)                                   \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1, logh++);              \
    m = ((1 << (2 * logh)) - 1);                            \
    i = (0xAAAAAAAA & m) + 1;                               \
    m = (0x55555555 & m) | (~m);                            \
}
#define U_INC2_MASK(i1,i2,m,h)                              \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1,logh++);               \
    m = ((1 << (2 * logh)) - 1);                            \
    i1 = (0xAAAAAAAA & m) + 1;                              \
    i2 = (0xAAAAAAAA & m) + 2;                              \
    m = (0x55555555 & m) | (~m);                            \
}
#define V_INC_MASK(i,m,w)                                   \
{                                                           \
    int logw;                                               \
    int ww = (int)(w) - 1;                                  \
    for (logw = 0; ww != 0; ww >>= 1, logw++);              \
    m = ((1 << (2 * logw)) - 1);                            \
    i = (0x55555555 & m) + 1;                               \
    m = (0xAAAAAAAA & m) | (~m);                            \
}
#define UV_INC(uv,i,m)      (((uv) + i) & m)
#define UV_OFFSET(uu,vv)    ((uu) | (vv))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _NVD3DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdp2help.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDP2Help.h
//      helper routines for DP2 operations
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        08Nov00         created
//
// **************************************************************************

// definitions
#define NV_NUM_UNIQUE_STREAMS(count) (((count) & 0x0000ffff) >>  0)
#define NV_NUM_SYSTEM_STREAMS(count) (((count) & 0xffff0000) >> 16)

// prototypes
void __stdcall  nvWireframeIndexedTriangle      (NV_INNERLOOP_ARGLIST);
void __stdcall  nvPointIndexedTriangle          (NV_INNERLOOP_ARGLIST);
void __stdcall  nvWireframeNonIndexedTriangle   (NV_INNERLOOP_ARGLIST);
void __stdcall  nvPointNonIndexedTriangle       (NV_INNERLOOP_ARGLIST);

void            nvCalcRWFar                     (PNVD3DCONTEXT pContext);

BOOL            nvPaletteBlt                    (CNvObject *pSrcObj, CTexture *pDstTexture);
BOOL            nvUnpalettize                   (CNvObject *pDstObj);
void            nvAutoPaletteCheckAndRevert     (CTexture* pTexture, BOOL bFullSurface);

DWORD           nvCountStreamDMAs               (PNVD3DCONTEXT pContext, DWORD dwStreamCount);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdblnd.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DBLND.H                                                        *
*   DX6 Class Blending definitions.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       09/09/98 - created.                     *
*                                                                           *
\***************************************************************************/

#ifndef _NV4DBLND_H_
#define _NV4DBLND_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Combine1 Pass Thru
 */
#define DX6TRI_COMBINE1ALPHA_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))


#define DX6TRI_COMBINE1COLOR_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Combine0 Disable
 */
#define DX6TRI_COMBINE0ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * Combine1 Disable
 */
#define DX6TRI_COMBINE1ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Default Combiner setup.
 */
#define DX6TRI_COMBINE0ALPHA_DEFAULT    DX6TRI_COMBINE0ALPHA_DISABLE

#define DX6TRI_COMBINE0COLOR_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1ALPHA_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DEFAULT    DX6TRI_COMBINE1COLOR_PASS_THRU

/*
 * Bump Mapping Combiner Setup.
 */
#define DX6TRI_COMBINE0ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED))

#define DX6TRI_COMBINE0COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2))

#define DX6TRI_COMBINE1ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECAL
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATE
 * cPix = cTex * cSrc
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALALPHA
 * cPix = ((1 - aTex) * cSrc) + (aTex * cTex)
 * aPix = aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEALPHA
 * cPix = cTex * cSrc
 * aPix = aTex * aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALMASK
 * cPix = lsb(aTex) ? cTex : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK                   \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK   DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK   DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEMASK
 * cPix = lsb(aTex) ? cTex * cSrc : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK                \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK    DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK    DX6TRI_COMBINE0COLOR_TBLEND_MODULATE

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_COPY
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_COPY    DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#define DX6TRI_COMBINE0COLOR_TBLEND_COPY    DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_ADD
 * cPix = cTex + cSrc
 * aPix = aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV4DBLND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdinc.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDINC.H                                                         *
*   NV4 specific direct 3d structure definitions.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - created.                     *
*                                                                           *
\***************************************************************************/

#ifndef _NVDINC_H_
#define _NVDINC_H_

#ifndef __cplusplus
#error C++ compiler needed
#endif

/*****************************************************************************
 * macros
 ****************************************************************************/

/*
 * Always build for D3D.
 * Always build a non-syncing driver.
 */
#define NVD3D       1
#define D3D_NOSYNC  1

// macros to push & restore current context
#define NVPUSH(pType,pPtr)        pType __##pPtr##_TempStorage__ = (pPtr);
#define NVPOP(pType,pPtr)         (pPtr) = __##pPtr##_TempStorage__;

// basically this needs to be the union of arguments required
// by all the various DP2 functions
#define NV_DP2FUNCTION_ARGLIST  PNVD3DCONTEXT        pContext,              \
                                LPD3DHAL_DP2COMMAND *ppCommands,            \
                                LPBYTE               pCommandBufferEnd,     \
                                LPDWORD              pdwDP2RStates,         \
                                DWORD                dwDP2Flags

#define NV_INNERLOOP_ARGLIST    PNVD3DCONTEXT        pContext,              \
                                DWORD                dwCount

#define NV_INNERLOOP_ARGS       pContext,                                   \
                                dwCount

typedef HRESULT (*LPNVDP2FUNCTION) (NV_DP2FUNCTION_ARGLIST);
typedef LPNVDP2FUNCTION     nvDP2FunctionTable[D3D_DP2OP_MAX+1];
typedef nvDP2FunctionTable *pnvDP2FunctionTable;

typedef DWORD (*PFNRENDERPRIMITIVEOP)         (NV_INNERLOOP_ARGLIST);
typedef void  (*LPNVINDEXEDPRIM)              (NV_INNERLOOP_ARGLIST);
typedef void  (*LPNVDRAWPRIM)                 (NV_INNERLOOP_ARGLIST);
typedef void  (__stdcall *LPNVFVFINDEXEDPRIM) (NV_INNERLOOP_ARGLIST);
typedef void  (__stdcall *LPNVFVFDRAWPRIM)    (NV_INNERLOOP_ARGLIST);

#define NV_UV_COORDINATE_COUNT_MAX  2

/*
 * --------------------------------------------------------------------------
 * Define texture heap constants
 * --------------------------------------------------------------------------
 */
#define NV_MIN_TEXTURE_SIZE                        ((1*2)*1)
#define NV_TEXTURE_PAD                             512
#define NV_TEXTURE_OFFSET_ALIGN                    255
#define NV_KELVIN_CUBEMAP_FACE_ALIGN               127            // alignment of subordinate faces -x thru -z, both compressed and not
#define NV_CELSIUS_CUBEMAP_FACE_ALIGN              127            // alignment of uncompressed subordinate faces -x thru -z
#define NV_CELSIUS_CUBEMAP_FACE_ALIGN_COMPRESSED   31             // alignment of compressed subordinate faces -x thru -z

/*
 * ScaledImageFromMemory size in limitation
 */
#define NV4_SCALED_IMAGE_CUTOFF         16

/*
 * Cache aligned inner loop context data.
 * Note also, that the hardware registers should be defined in the order that
 * they appear in the in the object class.
 */
typedef struct _def_nv_d3d_context_inner_loop
{
// bank 0       !!!Don't change bank or element ordering!!!
    /*
     * Current rendering state.
     */
    DWORD                       dwColorKey;
    DWORD                       dwTextureOffset;       // Offset within DMA context to start of texture.
    DWORD                       dwFormat;
    DWORD                       dwFilter;              // Current filtering state.
    DWORD                       dwBlend;
    DWORD                       dwControl;
    DWORD                       dwFogColor;             // Current fog color.
    DWORD                       _dwPad0[1];
} NVD3DCONTEXTINNERLOOP, *PNVD3DCONTEXTINNERLOOP;

//---------------------------------------------------------------------------

typedef struct _def_nv_d3d_texture_stage_state
{
    DWORD   dwValue[D3D_TEXSTAGESTATE_MAX+1];
    DWORD   dwHandle;      // texture handle
    DWORD   dwLODBias;     // LOD bias value to feed to HW
    D3DMATRIX mTexTransformMatrix;
} NVD3DTEXSTAGESTATE, *PNVD3DTEXSTAGESTATE;

//---------------------------------------------------------------------------

typedef struct _def_nv_d3d_multi_texture_state
{
    DWORD   dwTextureOffset[2];
    DWORD   dwTextureFormat[2];
    DWORD   dwTextureFilter[2];
    DWORD   dwCombine0Alpha;
    DWORD   dwCombine0Color;
    DWORD   dwCombine1Alpha;
    DWORD   dwCombine1Color;
    DWORD   dwCombineFactor;
    DWORD   dwBlend;
    DWORD   dwControl0;
    DWORD   dwControl1;
    DWORD   dwControl2;
    DWORD   dwFogColor;

    /*
     * The hardware requires the the UVx texture coordinates match up with
     * TEXTUREx.  i.e. tu0, tv0 are the coordinates for TEXTURE0, and tu1,
     * tv1 are the coordinates for TEXTURE1.
     * To simplify life, I am making TEXTURE0 always correspond to texture
     * stage 0, TEXTURE1 will always correspond to texture stage 1, etc.
     * However, there does not always have to be a one to one correspondence
     * to the Texture stage and the order in which the UV coordinate pairs
     * appear in the FVF Vertices.  The texture stage state defines which
     * set of UV coordinates applies to the texture in that stage.  This
     * allows for a single set of UV coordinates to be used for the multiple
     * texture stages.
     * The following offset array gives the byte offset from the start of the
     * FVF UV corrdinate pairs to the actual UV coordinates to be used for
     * a particular UVx pair.  They are initialized when the multi-texture state
     * is caclulated.
     */
    DWORD   dwUVOffset[8];

    /*
     * This flag defines if the current texture stage state is
     * valid.  This flag basicly defines whether or not multi-texturing
     * is possible with the current state.
     * This flag can be used during the ValidateTextureStageState callback
     * to report whether we can mulit-texture with the current state.
     * If the state is not valid, ddrval will contain the error that should
     * be returned during a ValidateTextureStageState callback.
     */
    BOOL    bTSSValid;
    HRESULT ddrval;
} NVD3DMULTITEXTURESTATE, *PNVD3DMULTITEXTURESTATE;

//---------------------------------------------------------------------------

// Surface clip rectangle.
typedef struct _SurfaceViewport {                   // Surface clip region
    union {
        DWORD   dwClipHorizontal;
        struct  _clip_horizontal {
            WORD    wX;                             // Surface left edge
            WORD    wWidth;                         // Surface Clip Width
        } clipHorizontal;
    };
    union {
        DWORD   dwClipVertical;
        struct  _clip_vertical {
            WORD    wY;                             // Surface top edge
            WORD    wHeight;                        // Surface Clip Height
        } clipVertical;
    };

    D3DVALUE dvMinZ;                                // Min/max of clip Volume
    D3DVALUE dvMaxZ;

    D3DVALUE dvWNear;
    D3DVALUE dvWFar;
    D3DVALUE dvRWFar;                               // Fudged reciprocal of WFar.
    D3DVALUE dvInvWFar;                             // the real reciprocal of WFar
} SurfaceViewport, *pSurfaceViewport;

//---------------------------------------------------------------------------

// vertex shader constants
typedef struct _VertexShaderConsts {
    // The zero padding is here to handle the constant addressing offsets in software
    // efficiently.  Rather than performing a bounds check upon each memory
    VSHADERREGISTER zeroPadding[128];
    VSHADERREGISTER vertexShaderConstants[NV_CAPS_MAX_VSHADER_CONSTS];
    VSHADERREGISTER zeroPadding2[128];
    VSHADERREGISTER vertexShaderTemp[NV_CAPS_MAX_VSHADER_TEMPS];
} VertexShaderConsts;

//---------------------------------------------------------------------------

// Vertex buffer offset parameters from DP2. These structure fields are used in place of passing parameters to the
// DP2 routines and to the inner loops. Sometimes the inner loops need to recalculate the offset. Passing in a precomputed
// offset made this difficult, because the inner loop did not have have access to the DP2 command.

// dwVertexBufferOffset is set in nvDrawPrimitives and nvDrawPrimitives2 and takes the place of the dwVertexBufferOffset argument
// to the DP2 routines.
//
// dwVStart is set by DP2 routines to the starting index, i.e. it's scaled by the stride of the VB. It's set to zero when not
// needed.
//
// dwTotalOffset is set by DP2 routines to be dwVertexBufferOffset + (dwVStart * Stride). Inner loops that change the stride
// of the VB must recompute this. It's provided by the DP2 routines for compatibility with the older inner loop code.

typedef struct _nv_d3d_context_dp2_param {
    DWORD           dwDP2Prim;                     // current prim
    DWORD           dwVertexBufferOffset;          // pdp2d->dwVertexOffset
    DWORD           dwVertexBufferOffsetSave;      // temp copy of pdp2d->dwVertexOffset
    DWORD           dwVStart;                      // lpPrim->wVStart
    DWORD           dwTotalOffset;                 // pdp2d->dwVertexOffset + (lpPrim->wVStart * Stride)
    DWORD           dwVertexLength;                // pdp2d->dwVertexLength;
    DWORD           dwEdgeFlags;                   // uhhh... take a wild guess
    DWORD           dwIndices;                     // address of indices (if indexed primitive, else NULL)
    DWORD           dwIndexStride;                 // index stride in bytes (2 or 4)
} NVD3DCONTEXTDP2PARAM, *PNVD3DCONTEXTDP2PARAM;

//---------------------------------------------------------------------------

typedef struct _nv_d3d_context_sysVB {
    CVertexBuffer  *pSysMemVB;
    DWORD           dwDefVBOffset;
    DWORD           dwSysMemVBStream;
    BOOL            bWriteOffset;
    BYTE            _dwPad0[3];
    DWORD           dwStreamDMACount;
    DWORD           _dwPad[3];
} NVD3DCONTEXTSYSVB, *PNVD3DCONTEXTSYSVB;

//---------------------------------------------------------------------------

typedef struct _nv_fog_data {
    DWORD           dwFogTableMode;
    float           fFogTableStart;
    float           fFogTableEnd;
    float           fFogTableDensity;
    float           fFogTableLinearScale;
} NVFOGDATA;

//---------------------------------------------------------------------------

extern "C++"
{

class CCommonState
{
public:
    enum
    {
        FOG_SOURCE_Z = 1,
        FOG_SOURCE_W = 2
    };

    // this area contains state that is common to all devices
    // this includes state for which the meaning is identical
    // as well as flags that are either identical in meaning or mutually exclusive in usage
    // when flags are neither identical nor mutually exclusive, we must ensure that they are only set for the correct class
    DWORD          dwDirtyFlags;                        // dirty state that needs to be resent to HW
    DWORD          dwStateFlags;                        // hardware state flags
    DWORD          dwTexCoordIndices;                   // texture coordinate indices used for texture unit 0 (0x0000ffff) and 1 (0xffff0000)
    DWORD          dwNumTexCoordsNeeded;                // number of texture coordinates needed for the currently set texture
    DWORD          dwNumActiveCombinerStages;           // number of enabled HW combiner stages
    DWORD          dwNextAvailableTextureUnit;          // which texture unit / combiner input will be used for the next texture
    DWORD          dwInlineVertexStride;                // stride of inline vertices (in bytes)
    DWORD          dwVertexOffset;                      // last vertex offset for whch the HW was programmed
    DWORD          dwFogSource;                         // indicates if we should use Z or W based fog
    DWORD          dwCombinerDP2Prim;                   // last DP2 Primitive for which combiners were programmed (affects point sprites)

    D3DVALUE       dvZScale;                            // the scale applied to a Z in [0...1] to make it fill the z buffer
    D3DVALUE       dvInvZScale;                         // the inverse

    CVertexShader *pVertexShader;                       // last vertex shader for which the HW was programmed

    CVertexBuffer *ppStreams          [NV_CAPS_MAX_STREAMS];         // last stream set for which hardware was programmed
    DWORD          dwTexUnitToTexStageMapping[NV_CAPS_MAX_TEXTURES]; // which D3D texture stage (if any) is being handled by this HW texture unit
    DWORD          dwTextureUnitStatus[NV_CAPS_MAX_TEXTURES];        // what is each hardware texture unit being used for?
    CTexture      *pTextureInUse      [NV_CAPS_MAX_TEXTURES];        // texture (if any) currently in use by HW texture unit i

    CSuperTri      SuperTri;

    DWORD          alphacull_mode;                                   // tracks which alpha cull mode I'm using for dirty bit checks

    DWORD          dwColorICW         [NV_CAPS_MAX_COMBINERS];       // color combiner input control words
    DWORD          dwColorOCW         [NV_CAPS_MAX_COMBINERS];       // color combiner output control words
    DWORD          dwAlphaICW         [NV_CAPS_MAX_COMBINERS];       // color combiner input control words
    DWORD          dwAlphaOCW         [NV_CAPS_MAX_COMBINERS];       // alpha combiner output control words

    D3DMATRIX      mTransform;                                       // supertri transform matrix
    DWORD          specfog_cw[2];
};

//---------------------------------------------------------------------------

class CHardwareState : public CCommonState
{
public:
#if (NVARCH >= 0x010)
    CCelsiusState celsius;
#endif // NVARCH == 0x010
#if (NVARCH >= 0x020)
    CKelvinState  kelvin;
#endif // NVARCH == 0x020
};

//---------------------------------------------------------------------------

typedef enum _D3DCONTEXTFLAGS
{
    CONTEXT_NEEDS_VTX_CACHE_FLUSH = 0x01
} D3DCONTEXTFLAGS;

// Define the context header.
typedef struct _def_nv_d3d_context
{
    // Application DX version.
    DWORD                       dwDXAppVersion;         // the application's DX version level.

    // Default texture state for this context.
    DWORD                       dwTickLastUsed;         // cheesy way of determining the active context
    DWORD                       dwLastFillColor;        // most reset fill color (used for logo clear)
    BOOL                        bClearLogo;             // TRUE if we must clear the area behind the logo

#if (NVARCH >= 0x010)
    AASTATE                     aa;
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
    CKelvinAAState              kelvinAA;
#endif  // NVARCH >= 0x010

    // palette
    DWORD                       dwTexturePaletteStagingHandle;
    DWORD                       dwTexturePaletteAddr;   // address of palette staging area
    DWORD                       dwTexturePaletteOffset; // offset of palette staging area

    CSimpleSurface             *pRenderTarget;
    DWORD                       dwRTHandle;             // cached for RT restore after mode switch
    CSimpleSurface             *pZetaBuffer;
    DWORD                       dwZBHandle;             // cached for RT restore after mode switch

    // Number of flips to allow pending before using SUPER_TRI code.
    DWORD                       dwSuperTriPendingFlips;
    DWORD                       dwSuperTriThrottle;
    DWORD                       dwSuperTriMask;

    NVD3DCONTEXTDP2PARAM        dp2;
    DWORD                       dwHWUnlockAllPending;
    DWORD                       dwFlags;
    // the following fields of this array have been superceded by equivalent fields in tssState[0].
    //      D3DRENDERSTATE_TEXTUREHANDLE    (1)
    //      D3DRENDERSTATE_TEXTUREADDRESS   (3)
    //      D3DRENDERSTATE_BORDERCOLOR      (43)
    //      D3DRENDERSTATE_TEXTUREADDRESSU  (44)
    //      D3DRENDERSTATE_TEXTUREADDRESSV  (45)
    //      D3DRENDERSTATE_MIPMAPLODBIAS    (46)
    //      D3DRENDERSTATE_ANISOTROPY       (49)
    // values for these fields are no longer saved in dwRenderState and the fields are therefore
    // liable to contain junk! the real values MUST be obtained from tssState[0].
    DWORD                       dwRenderState[D3D_RENDERSTATE_MAX+1];
    BOOL                        bStateChange;
    NVD3DSTATESET               overrides;              // Render state override bits.

    NVFOGDATA                   fogData;

    struct _def_nv_d3d_context *pContextPrev;
    struct _def_nv_d3d_context *pContextNext;

    // DX6 Texture Stage State.
    DWORD                       dwStageCount;           // Number of enabled/valid texture stages.
    BOOL                        bUseDX6Class;           // Use DX6 Multi-Texture Triangle Class.
    BOOL                        bUseTBlendSettings;     //
    DWORD                       dwTBlendCombine0Alpha;
    DWORD                       dwTBlendCombine0Color;
    NVD3DMULTITEXTURESTATE      mtsState;               // DX6 Multi-Texture Triangle State.
    NVD3DMULTITEXTURESTATE      mtsShadowState;         //  for state update optimizations

    NVD3DTEXSTAGESTATE          tssState[8];            // Texture Stage State.

    BOOL                        bStencilEnabled;        // has the stencil buffer ever been enabled?
    DWORD                       dwStencilFill;          // the last value to which the stencil buffer was filled

    DWORD                       pid;                    // Process ID
    DWORD                       dwDDLclID;              // tag for this context's DIRECTDRAW_LCL
    DWORD                       dwDDGblID;              // tag for this context's DIRECTDRAW_GBL
    CDriverContext             *pDriverData;            // this context's pDriverData
#ifdef WINNT
    PDEV                       *ppdev;
#else WINNT
    DISPDRVDIRECTXCOMMON       *pDXShare;               // this context's pDXShare
#endif

    NVLIGHTING                  lighting;               // Lighting state
    nvLight                    *pLightArray;
    DWORD                       dwLightArraySize;       // Size of the light array allocated

    D3DMATERIAL7                Material;               // the current material

    D3DMATRIX                   xfmProj;
    D3DMATRIX                   xfmView;
    D3DMATRIX                   xfmWorld[NV_CAPS_MAX_MATRICES];  // world matrices

    D3DVALUE                    ppClipPlane[D3DMAXUSERCLIPPLANES][4];

    // stateset stuff
    pnvDP2FunctionTable         pDP2FunctionTable;      // current DP2 functions (set, record, or capture)
    DWORD                       dwCurrentStateSet;
    DWORD                       dwMaxStateSetHandles;
    STATESET                   *pStateSets;

    DWORD                       dwFunctionLookup;       // Lookup index for the appropriate nv4 render function.
    NVD3DCONTEXTINNERLOOP       ctxInnerLoop;           // Context data used within inner loops.
    NVD3DCONTEXTINNERLOOP       ctxInnerLoopShadow;     // hw image of above
    CHardwareState              hwState;

    // viewport
    SurfaceViewport             surfaceViewport;

    CVertexShader              *pCurrentVShader;
    VertexShaderConsts         *pVShaderConsts;

    CPixelShader               *pCurrentPShader;
    CPixelShader               *pLastPShader;
    D3DCOLORVALUE               pixelShaderConsts[NV_CAPS_MAX_PSHADER_CONSTS];

    CVertexBuffer              *ppDX8Streams[NV_CAPS_MAX_STREAMS];   // Streams for DX8 prims, note they all use dwVertexOffsetInUse
    DWORD                       dwStreamDMACount;                    // number of unique context DMAs in 15:0, number of system streams in 31:16

    CVertexBuffer              *pIndexBuffer;                        // Index buffer for DX8 primitives

    CNvObject                  *pCelsiusPointTexture;
    DWORD                       dwPointHandle;

    NVD3DCONTEXTSYSVB           sysvb;

    PBYTE                       pVertexDataUM;
    DWORD                       dwVertexDataLengthUM;

#ifdef WINNT
    // Need this for Winnt to access the PDEV state struct maintained by display
    // driver. PDEV also contains a ptr to the GLOBALDATA struct.
    PDD_DIRECTDRAW_GLOBAL       lpDD;
#endif // #ifdef WINNT

#ifdef TEX_MANAGE
    NV_TEXMAN_DATA              texManData;  // data used by the texture manager
#endif  // TEX_MANAGE

    DWORD                       dwEarlyCopyStrategy; // ask ScottC for details
    DWORD                       dwClearCount;        // number of full clears this frame
    DWORD                       dwTotalClearCount;   // total number of clears on the primary Z surface, modulo 256
    BOOL                        bSeenTriangles;      // Have we seen any triangle calls
    BOOL                        bScaledFlatPanel;   // are we in a scaled, flat panel mode?

} NVD3DCONTEXT, *PNVD3DCONTEXT;  // struct _def_nv_d3d_context

} // extern C++

// NV_OBJECT_LIST is a list of pointers to the NV objects
// associated with a particular DIRECTDRAW_LCL. the list is indexed by the
// handles that have been associated with the objects via CreateSurfaceEx.
// we maintain a linked list of these structures for each DIRECTDRAW_GBL.

#define NV_OBJECT_LIST_SIZE_DEFAULT      128
#define NV_OBJECT_LIST_SIZE_INCREMENTAL  128

typedef struct _NV_OBJECT_LIST {
    DWORD                     dwDDLclID;     // ID tag for the DD_LCL for which this list is kept
    DWORD                     dwListSize;    // the size of the list
    CNvObject               **ppObjectList;  // the list itself (just an array)
    struct _NV_OBJECT_LIST   *pNext;         // the next list
} NV_OBJECT_LIST, *PNV_OBJECT_LIST;

/*
 * External data.
 */
extern PFNRENDERPRIMITIVEOP       pfnRenderPrimitiveOperation[];
extern PFND3DPARSEUNKNOWNCOMMAND  fnD3DParseUnknownCommandCallback;

/*
 * Texture Staging Manager Functions
 */
#define TM_STAGESPACE              (2*1024*1024) // 2048k

#define NV_PN_TEX_RETIRE           0    // depreciated in for nv_tex2
#define NV_PN_SPOOFED_FLIP_COUNT   4
#define NV_PN_TEXTURE_RETIRE       8

/*
 * Embedded Profiler Functions
 */
#ifdef NV_PROFILE

/*
 * Constants
 */
 #define NVP_E_BEGINSCENE            0 // beginscene event
 #define NVP_E_PUT                   1 // put event
 #define NVP_T_HDFLUSH               2 // hd flush time
 #define NVP_T_SCENE                 3 // scene time
 #define NVP_T_DP2                   4 // total dp2 time

#ifdef NV_PROFILE_CPULOCK
 #define NVP_T_VBDP2_LOCK            5 // dp2 exit cpu lock
 #define NVP_T_VB_LOCK               6 // D3DLockExecuteBuffer
 #define NVP_T_VB_INLINE             7 // inline VB lock
 #define NVP_T_TEX_ULS               8 // update linear surface
 #define NVP_T_TEX_USS               9 // update swizzle surface
 #define NVP_T_TEX_BLT              10 // nvTextureBlt
 #define NVP_T_TEX_LOCK             11 // nvTextureLock
 #define NVP_T_FLOAT0               12
 #define NVP_T_FLOAT1               13
#endif

#ifdef NV_PROFILE_PUSHER
 #define NVP_T_WRAPAROUND            5
 #define NVP_T_MAKESPACE             6
 #define NVP_T_ADJUST                7
 #define NVP_T_FLUSH                 8 // time spend waiting in nvPusherFlush
 #define NVP_C_PENDINGSIZE           9 // size of pending pushe buffer (at put time)
 #define NVP_C_PUT                  10
 #define NVP_C_GET                  11
 #define NVP_C_VELOCITY             12
#endif

#ifdef NV_PROFILE_CALLSTACK
 #define NVP_T_SETCELSIUSSTATE       5
 #define NVP_T_SETKELVINSTATE        6
 #define NVP_T_IDXDISPATCH           7
 #define NVP_T_ORDDISPATCH           8
#endif

#ifdef NV_PROFILE_DEFVB
 #define NVP_C_PUT                   5
 #define NVP_C_GET                   6
 #define NVP_C_FREECOUNT             7
 #define NVP_E_PRIM                  8
#endif

#ifdef NV_PROFILE_COPIES
 #define NVP_T_RENAME_AUTO_COPY      5
 #define NVP_T_LIN2SWZ2              6
 #define NVP_T_RENAME_FWD            7
#endif

/*
 * Macros
 */
#define _NVP_PUSH  __asm push eax __asm push edx __asm push ebx
#define _NVP_POP   __asm pop ebx __asm pop edx __asm pop eax
#define _NVP_SYNC  __asm xchg al,al __asm nop __asm nop
#define _NVP_RDTSC _NVP_SYNC __asm _emit 0x0f __asm _emit 0x31

#define NVP_START(_t) { nvpTime[_t]=0; NVP_RESTART(_t); }
#define NVP_RESTART(_t) { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm sub [ebx],eax __asm sbb [ebx+4],edx _NVP_POP }
#define NVP_STOP(_t)  { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm add [ebx],eax __asm adc [ebx+4],edx _NVP_POP }

extern __int64 nvpTime[256];
extern DWORD   nvpEnableBits;
extern DWORD   nvpTriPerSecWindow;

#endif // !NV_PROFILE

// nv4comp.h
typedef void (__stdcall *PFNDRAWPRIMITIVE)(DWORD dwPrimCount,LPWORD pIndices,DWORD dwStrides,LPBYTE pVertices);

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)       \
{                         \
    hr = (exp);           \
    if (hr != D3D_OK)     \
    {                     \
        return hr;        \
    }                     \
}

// FVF related macros
#define FVF_TRANSFORMED(dwFVF)          ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF)      (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
#define NV_VERTEX_TRANSFORMED(pVShader) (((pVShader->hasProgram() == FALSE) && (pVShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD))) ? TRUE : FALSE)

// page constants
#ifndef PAGE_MASK
#define PAGE_MASK   0xFFFFF000
#endif
#ifndef PAGE_SIZE
#define PAGE_SIZE   0x00001000
#endif

#endif  // _NVDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvEnable.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvEnable.h                                                        *
*    Definition file for:                                                   *
*       enablec.c and disablec.c                                            *
*    Suggested new name for combined file:                                  *
*       nvEnable.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe          6/15/99 - Created                       *
*                                                                           *
\***************************************************************************/

#ifndef _NVENABLE_H_
#define _NVENABLE_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// public
BOOL           nvEnable32                           (LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
BOOL __stdcall nvDisable32                          (void);
BOOL           nvEnableD3D                          (void);
BOOL           nvInitD3DObjects                     (void);
void           nvDisableD3D                         (void);
void           nvCreateVidHeapVarsAndPseudoNotifier (void);
BOOL           nvCreateDACObjects                   (DWORD dwChannel, DWORD dwHandle);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVENABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvFlipper.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFlipper.h
//      a flipping class, for use with kelvin-style semaphores
//      (possibly to be expanded to handle flipping more generally)
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Jun2000         created, NV20 development
//
// **************************************************************************

#ifndef __NVFLIPPER_H
#define __NVFLIPPER_H

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

#define FLIPPER_MAX_CHAIN_SIZE 16

//---------------------------------------------------------------------------

class CFlipper
{

private:

    const enum {
        SEMAPHORE_READY_FOR_RENDER  = 0,
        SEMAPHORE_READY_FOR_SCANOUT = 1,
        SEMAPHORE_FLIP_COMPLETE     = 2
    };

    CSemaphore      *m_ppSemaphores[FLIPPER_MAX_CHAIN_SIZE];
    DWORD            m_dwFlipChainSize;
    DWORD            m_dwIndex;

public:

    BOOL create     (void);
    BOOL destroy    (void);
    BOOL init       (DWORD dwChainSize);
    BOOL flip       (CPushBuffer *pPusher3D,
                     CPushBuffer *pPusherDAC,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfCurr,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfTarg,
                     BOOL bNoVSync);

    CFlipper()      {   m_dwFlipChainSize = 0;
                        m_dwIndex         = 0;    }

    ~CFlipper()     {}
};

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020
#endif  // __NVFLIPPER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvILHash.h ===
//                                                                             //
// (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved. //
//                                                                             //
////////////////////////////////// Direct 3D ////////////////////////////////////
//                                                                             //
// Module: nvILHash.h                                                          //
//   hash function for the dynamically compiled inner loops                    //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
// History:                                                                    //
//       Paul van der Kouwe 12/13/99 - created.                                //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////

#ifndef _NVILHASH_H_
#define _NVILHASH_H_

/////////////////////////////////////////////////////////////////////////////////
// structures
//
class CILHashEntry
{
private:
    DWORD         m_dwRenderClass;  // the class for which this loop was built
    DWORD         m_dwOffset;
    CILHashEntry *m_pNext;

    // common parameters
    DWORD m_dwVertexType;
    union
    {
        // NV4 unique parameters
        struct
        {
            DWORD        m_dwFLUI;
            DWORD        m_dwTextureOrder;
        };
        // celsius unique parameters
        struct
        {
            DWORD        m_dwFlags;
            DWORD        m_dwSTILFlags;
            DWORD        m_dwVertexStride;
            VASOURCEINFO m_vaSourceData[NV_CAPS_MAX_STREAMS];  // sources of the data loaded into the 16 vertex attribute registers
            DWORD        m_dwStateFlags;
            DWORD        m_dwTexUnitToTexStageMapping[2];
            DWORD        m_dwTexCoordIndices;
            DWORD        m_dwTexTransformFlags[4];
        };
    };

public:
    inline DWORD           getOffset (void)   const { return m_dwOffset; }
    inline CILHashEntry*   getNext   (void)   const { return m_pNext;    }

    // NV4 constuctor
    inline CILHashEntry
    (
        DWORD         dwFLUI,
        DWORD         dwVertexType,
        DWORD         dwTextureOrder,
        DWORD         dwOffset,
        CILHashEntry* pNext
    )
    {
        m_dwRenderClass  = NVCLASS_FAMILY_DXTRI;
        m_dwFLUI         = dwFLUI;
        m_dwVertexType   = dwVertexType;
        m_dwTextureOrder = dwTextureOrder;

        m_dwOffset       = dwOffset;
        m_pNext          = pNext;
    }

    inline BOOL match (DWORD dwFLUI, DWORD dwVertexType, DWORD dwTextureOrder) const
    {
        return (m_dwRenderClass  == NVCLASS_FAMILY_DXTRI)
            && (m_dwFLUI         == dwFLUI)
            && (m_dwVertexType   == dwVertexType)
            && (m_dwTextureOrder == dwTextureOrder);
    }

    // celsius/kelvin constructor
    inline CILHashEntry
    (
        PNVD3DCONTEXT   pContext,
        DWORD           dwClass,
        DWORD           dwFlags,
        DWORD           dwOffset,
        CILHashEntry*   pNext
    )
    {
        m_dwRenderClass = dwClass;

#if (NVARCH >= 0x020)
        if (dwClass == NVCLASS_FAMILY_KELVIN) {
            m_dwFlags           = dwFlags;
            m_dwVertexStride    = pContext->pCurrentVShader->getStride();
            m_dwSTILFlags       = pContext->hwState.SuperTri.dwSTILFlags;
            m_dwStateFlags      = pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS;
            m_dwTexCoordIndices = pContext->hwState.dwTexCoordIndices;
            nvMemCopy (m_dwTexUnitToTexStageMapping, pContext->hwState.dwTexUnitToTexStageMapping, sizeof(m_dwTexUnitToTexStageMapping));
            nvMemCopy (m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData));
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (dwClass == NVCLASS_FAMILY_CELSIUS) {
            m_dwFlags           = dwFlags;
            m_dwSTILFlags       = pContext->hwState.SuperTri.dwSTILFlags;
            m_dwVertexStride    = pContext->pCurrentVShader->getStride();
            m_dwStateFlags      = pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS;
            m_dwTexCoordIndices = pContext->hwState.dwTexCoordIndices;
            nvMemCopy (m_dwTexUnitToTexStageMapping,pContext->hwState.dwTexUnitToTexStageMapping,sizeof(m_dwTexUnitToTexStageMapping));
            nvMemCopy (m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData));
            if (m_dwStateFlags & (CELSIUS_FLAG_TEXMATRIXSWFIX(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) {
                m_dwTexTransformFlags[0] = pContext->tssState[0].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
                m_dwTexTransformFlags[1] = pContext->tssState[1].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
                m_dwTexTransformFlags[2] = pContext->tssState[2].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
                m_dwTexTransformFlags[3] = pContext->tssState[3].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];
            }
        }
        else
#endif  // NVARCH >= 0x010
        {
            DPF ("unknown class in CILHashEntry::CILHashEntry");
            dbgD3DError();
        }

        m_dwOffset       = dwOffset;
        m_pNext          = pNext;
    }

    // celsius / kelvin match function
    inline BOOL match
    (
        PNVD3DCONTEXT pContext,
        DWORD         dwClass,
        DWORD         dwFlags
    )
    const
    {
#if (NVARCH >= 0x020)
        if (m_dwRenderClass == NVCLASS_FAMILY_KELVIN) {
            return ((m_dwFlags           == dwFlags)
                 && (m_dwSTILFlags       == pContext->hwState.SuperTri.dwSTILFlags)
                 && (m_dwVertexStride    == pContext->pCurrentVShader->getStride())
                 && (m_dwStateFlags      == (pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS))
                 && (m_dwTexCoordIndices == pContext->hwState.dwTexCoordIndices)
                 && !memcmp(m_dwTexUnitToTexStageMapping, pContext->hwState.dwTexUnitToTexStageMapping, sizeof(m_dwTexUnitToTexStageMapping))
                 && !memcmp(m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData)));
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (m_dwRenderClass == NVCLASS_FAMILY_CELSIUS) {
#if 0       // SK - will re-enable this in R7 after some additional work
            // SK - todo: Simplify this further.
            if ((pContext->dwEarlyCopyStrategy) && (dwFlags & CELSIUS_ILMASK_LOOPTYPE) == CELSIUS_ILFLAG_SUPER_TRI_LIST) 
            {
                if (!(pContext->hwState.SuperTri.dwSTILFlags & NV_STILFLAG_STDEFVB)) 
                {
                    return (m_dwSTILFlags == pContext->hwState.SuperTri.dwSTILFlags);                
                }
                else
                {
                    return ((m_dwSTILFlags == pContext->hwState.SuperTri.dwSTILFlags) 
                            && (m_dwVertexStride == pContext->hwState.SuperTri.getSTLBStride()));                
                }
            }
            else 
#endif
            {
                return ((m_dwFlags           == dwFlags)
                     && (m_dwSTILFlags       == pContext->hwState.SuperTri.dwSTILFlags)
                     && (m_dwVertexStride    == pContext->pCurrentVShader->getStride())
                     && (m_dwStateFlags      == (pContext->hwState.dwStateFlags & CELSIUS_MASK_INNERLOOPUNIQUENESS))
                     && (m_dwTexCoordIndices == pContext->hwState.dwTexCoordIndices)
                     && !memcmp(m_dwTexUnitToTexStageMapping, pContext->hwState.dwTexUnitToTexStageMapping, sizeof(m_dwTexUnitToTexStageMapping))
                     && !memcmp(m_vaSourceData, pContext->pCurrentVShader->m_vaSourceData, sizeof(m_vaSourceData))
                     && (!(m_dwStateFlags & (CELSIUS_FLAG_TEXMATRIXSWFIX(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(1)))
                         ||
                         ((m_dwTexTransformFlags[0] == pContext->tssState[0].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]) &&
                          (m_dwTexTransformFlags[1] == pContext->tssState[1].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]) &&
                          (m_dwTexTransformFlags[2] == pContext->tssState[2].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]) &&
                          (m_dwTexTransformFlags[3] == pContext->tssState[3].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS]))));
            }
        }
        else
#endif  // NVARCH >= 0x010
        {
            DPF ("unknown class in CILHashEntry::match");
            dbgD3DError();
            return (FALSE);
        }
    }

};

#endif // _NVILHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvFormats.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFormats.h
//      prototypes and definitions for nvFormats.cpp
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        05Mar2001         creation
//
// **************************************************************************

#ifndef __FORMATS_H
#define __FORMATS_H

// prototypes
BOOL nvEnumerateFourCCs        (void);
BOOL nvEnumerateSurfaceFormats (void);

#endif // __FORMATS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvdp2ops.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDP2OPS.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     02June99    created                 *
*                                                                           *
\***************************************************************************/

#ifndef _NVDP2OPS_H
#define _NVDP2OPS_H

#ifdef __cplusplus
extern "C" {
#endif

extern nvDP2FunctionTable nvDP2SetFuncs;
extern nvDP2FunctionTable nvDP2RecordFuncs;
extern nvDP2FunctionTable nvDP2CaptureFuncs;

// prototypes
HRESULT nvDP2Points (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedLineList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2LineList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2LineStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedLineStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleList (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleStrip (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleFan (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleFan (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TriangleFanImm (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2LineListImm (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedTriangleList2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2IndexedLineList2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetRenderState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2NOP (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetTextureStageState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetViewport (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetWRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetZRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetPalette (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2UpdatePalette (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetMaterial (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CreateLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2Extension (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2TexBlt (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2StateSet (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetPriority (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetRenderTarget (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2Clear (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetTexLOD (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetClipPlane (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2StreamEnd (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2VolumeBlt (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2BufferBlt (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2RecordSetRenderState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetTextureStageState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetViewport (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetWRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetZRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetMaterial (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordExtension (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetClipPlane (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CaptureSetRenderState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetTextureStageState (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetViewport (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetWRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetZRange (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetMaterial (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetLight (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureExtension (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetClipPlane (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CreateVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DeleteVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetVertexShaderConst (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CreatePixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DeletePixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetPixelShader (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2SetStreamSource (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2SetStreamSourceUM (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2SetIndices (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2DrawPrimitive (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawIndexedPrimitive (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2SetPixelShaderConst (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2ClippedTriangleFan (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawPrimitive2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawIndexedPrimitive2 (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawRectSurface (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2DrawTriSurface (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2VolumeBlt (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2BufferBlt (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2RecordSetVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetStreamSource (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetIndices (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetPixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2CaptureSetVertexShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetStreamSource (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetIndices (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetPixelShader (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2CaptureSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST);

HRESULT nvDP2MultiplyTransform (NV_DP2FUNCTION_ARGLIST);
HRESULT nvDP2RecordMultiplyTransform (NV_DP2FUNCTION_ARGLIST);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVDP2OPS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvLight.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.h
//
// Direct3D Reference Transform and Lighting - Main Header File
//
///////////////////////////////////////////////////////////////////////////////

#ifndef  _REFTNL_H
#define  _REFTNL_H

#ifdef __cplusplus
extern "C" {
#endif

// Default color values that should be used when ther is no lighting and
// color in vertices provided
#define D3D_DEFAULT_DIFFUSE  0xFFFFFFFF;
#define D3D_DEFAULT_SPECULAR 0;

struct _nvLight;

//---------------------------------------------------------------------
// NVLIGHTING
// All the lighting related state clubbed together
//---------------------------------------------------------------------

typedef struct {D3DVALUE r,g,b;} RGBCOLOR;

typedef struct _NVLIGHTING
{
    // Active Light list
    struct _nvLight *pActiveLights;

    // Ambient color set by D3DRENDERSTATE_AMBIENT
    // components are all scaled to 0 - 1
    D3DCOLORVALUE dcvAmbient;

} NVLIGHTING;

//-----------------------------------------------------------------------------
//
// nvLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the ReferenceRasterizer object.
//
//-----------------------------------------------------------------------------

// nvLight flags
#define NVLIGHT_DEFINED             0x00000001  // has this light been defined?
#define NVLIGHT_ENABLED             0x00000002  // Is the light active

typedef struct _expParams
{
    D3DVALUE L;
    D3DVALUE M;
    D3DVALUE N;
} expParams, *pexpParms;

typedef struct _nvLight
{
    DWORD            dwFlags;           // see above
    struct _nvLight *pNext;             // next active light
    D3DLIGHT7        Light7;            // Light data set by the runtime (unmodified!!)
    // derived data
    D3DVECTOR        direction;         // negated a la OGL and normalized
    expParams        falloffParams;     // spotlight falloff params
    D3DVALUE         dvScale;           // spotlight scale factor
    D3DVALUE         dvW;               // spotlight direction W
} nvLight, *pnvLight;

#ifdef __cplusplus
}
#endif

#endif // _REFTNL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvHeap.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

 /********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVHEAP.H                                                          *
*   Heap allocation stuff                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        bertrem     16Jul99     created             *
*       Ben de Waal                         27Jul99     add CHeap class     *
*                                                                           *
\***************************************************************************/

#ifndef _NVHEAP_H_
#define _NVHEAP_H_

#ifndef __cplusplus
#error C++ compiler required
#endif

extern "C"
{

extern NVOS11_PARAMETERS HeapParams;

// define to disable tiled memory
//#define HEAP_DISABLE_TILING
//#define CHEAP_SANITY_CHECK      // check integrity

#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define HEAP_ALLOC_TILED_PITCH_HEIGHT        6

#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define TYPE_VERTEX                          2  // same as texture for now. differentiate later
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9
#define TYPE_DEPTH_COMPR16                   10
#define TYPE_DEPTH_COMPR32                   11

#define STATUS_SUCCESS                       (0x00000000)
#define STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define STATUS_ERROR_INVALID_OWNER           (0x00000003)

//
// Heap manager interface.
//
//extern void __stdcall NvIoControl(DWORD, PVOID);

#define DX_HEAP_ID  'NVDX'

#ifndef WINNT

// parameter values
#define NVHEAP_PURGE()                                          \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_PURGE;                           \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
}

#define NVHEAP_INFO()                                           \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_INFO;                            \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount) {  \
        pDriverData->VideoHeapOverhead = HeapParams.total - HeapParams.free; \
    }                                                           \
}

#define NVHEAP_ALLOC(sts,pvm,sz,tp)                             \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}

#define NVHEAP_ALLOC_B(sts,pvm,sz,tp)                           \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}

#define NVHEAP_ALLOC_C(sts,pvm,sz,tp)                           \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}

#ifndef HEAP_DISABLE_TILING
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp)                   \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;        \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.type     = (tp);                                 \
    HeapParams.pitch    = (pch);                                \
    HeapParams.height   = (ht);                                 \
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.address);                \
    (pch) = HeapParams.pitch;                                   \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}
#else
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp) NVHEAP_ALLOC(sts,pvm,pch,ht,tp)
#endif

#define NVHEAP_FREE(pvm)                                        \
{                                                               \
    HeapParams.hRoot = pDriverData->dwRootHandle;               \
    HeapParams.hObjectParent = NV_WIN_DEVICE;                   \
    HeapParams.function = HEAP_FREE;                            \
    HeapParams.owner    = DX_HEAP_ID;                           \
    HeapParams.offset   = (U032)(pvm) - pDriverData->BaseAddress;\
    HeapParams.status = NvRmArchHeap((ULONG) HeapParams.hRoot, (ULONG) HeapParams.hObjectParent, (ULONG) HeapParams.function, (ULONG) HeapParams.owner,HeapParams.type,HeapParams.height,HeapParams.size, (ULONG *)&HeapParams.pitch, &HeapParams.offset, &HeapParams.address, &HeapParams.limit, &HeapParams.free, &HeapParams.total); \
    pDriverData->VideoHeapFree = HeapParams.free;               \
}
#else   // WINNT

#define NVHEAP_PURGE() // NT never does a purge!

#define NVHEAP_INFO()                                           \
{                                                               \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_INFO;                            \
    HeapParams.owner    = 'NVDD';                               \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    if (pDriverData) {                                          \
        if (!pDriverData->DDrawVideoSurfaceCount)               \
        {                                                       \
            pDriverData->VideoHeapOverhead = HeapParams.total - \
            HeapParams.free - ppdev->cbGdiHeap;                 \
        }                                                       \
        ppdev->VideoHeapTotal = HeapParams.total;               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
    }                                                           \
    HeapParams.address = 0;                                     \
}


#define NVHEAP_ALLOC(sts,pvm,sz,tp)                             \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.offset);                 \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_SIZE;                  \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.size     = (sz);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = (unsigned long)(HeapParams.offset);             \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#define NVHEAP_ALLOC_B(sts,pvm,sz,tp)                           \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.offset);                 \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_SIZE;                  \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.size     = (sz);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = (unsigned long)(HeapParams.offset);             \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#define NVHEAP_ALLOC_C(sts,pvm,sz,tp)                           \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = (unsigned long)(HeapParams.offset);                 \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_SIZE;                  \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.size     = (sz);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = (unsigned long)(HeapParams.offset);             \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#ifndef HEAP_DISABLE_TILING
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp)                   \
{                                                               \
    NVOS11_PARAMETERS   HeapParams;                             \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
                                                                \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount && !ppdev->cbGdiHeap)    \
    {                                                           \
        ppdev->cbGdiHeap = ppdev->VideoHeapTotal -              \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;        \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.pitch    = (pch);                                \
    HeapParams.height   = (ht);                                 \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    (sts) = HeapParams.status;                                  \
    (pvm) = ((DWORD) HeapParams.address - (DWORD) ppdev->pjFrameBufbase);  \
                                                                \
    if (sts && ppdev->cbGdiHeap)                                \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(ppdev);                 \
        HeapParams.hRoot = ppdev->hClient;                      \
        HeapParams.hObjectParent = ppdev->hDevice;              \
        HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;    \
        HeapParams.owner    = 'NVDD';                           \
        HeapParams.type     = (tp);                             \
        HeapParams.pitch    = (pch);                            \
        HeapParams.height   = (ht);                             \
        EngDeviceIoControl(                                     \
            ppdev->hDriver,                                     \
            (DWORD)IOCTL_NV01_ARCH_HEAP,                        \
            (&pParms),                                          \
            sizeof(PVOID),                                      \
            pParms,                                             \
            sizeof(NVOS11_PARAMETERS),                          \
            &cbReturned                                         \
        );                                                      \
        (sts) = HeapParams.status;                              \
        (pvm) = ((DWORD) HeapParams.address - (DWORD) ppdev->pjFrameBufbase);  \
        pDriverData->VideoHeapFree =                            \
            ppdev->VideoHeapFree;                               \
    }                                                           \
                                                                \
    if (!(sts)) {                                               \
        (pch) = HeapParams.pitch;                               \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#else // HEAP_DISABLE_TILING
#define NVHEAP_ALLOC_TILED(sts,pvm,pch,ht,tp) NVHEAP_ALLOC(sts,pvm,pch*ht,tp)
#endif

#define NVHEAP_FREE(pvm)                                        \
{                                                               \
    NVOS11_PARAMETERS HeapParams;                               \
    PVOID pParms = (PVOID) &HeapParams;                         \
    DWORD cbReturned;                                           \
    HeapParams.hRoot = ppdev->hClient;                          \
    HeapParams.hObjectParent = ppdev->hDevice;                  \
    HeapParams.function = HEAP_FREE;                            \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.offset   = (U032)(pvm);                          \
    EngDeviceIoControl(                                         \
        ppdev->hDriver,                                         \
        (DWORD)IOCTL_NV01_ARCH_HEAP,                            \
        (&pParms),                                              \
        sizeof(PVOID),                                          \
        pParms,                                                 \
        sizeof(NVOS11_PARAMETERS),                              \
        &cbReturned                                             \
    );                                                          \
    if (!HeapParams.status) {                                   \
        ppdev->VideoHeapFree = HeapParams.free;                 \
        pDriverData->VideoHeapFree =                            \
            HeapParams.free + ppdev->cbGdiHeap;                 \
    }                                                           \
}

#endif  // WINNT

#define AGP_HEAP 0

}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CInterProcessHeap ******************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/
class CInterProcessHeap
{
    /*
     * internal flags
     */
protected:
    enum
    {
        FLAG_ALLOCATED      = 0x00000001,   // this block is allocated
        FLAG_BOUNDARY       = 0x00000002,   // start of a new block
        FLAG_16BIT          = 0x00000004,   // this block was allocated from 16 bit land

        ALIGN               = 64,           // byte alignment (power of 2)
    };

    /*
     * internal structures
     */
protected:
    struct HEADER
    {
        HEADER *pNext;          // next block
        HEADER *pNextFree;      // next free block
        HEADER *pPrev;          // prev block
        HEADER *pPrevFree;      // prev free block
        DWORD   dwFlags;        // state
        DWORD   dwUserStart;    // start of user memory
        DWORD   dwUserSize;     // size of user memory
        DWORD   dwRealSize;     // size of this block + headers
        DWORD   dwRMID;         // RM ID of mem block, only if alloc'd directly by OS
#ifdef DEBUG
        void   *pCaller;        // pointer to allocation requester
#endif
        // NOTE!!! the dwReserved entry must appear last in this structure
        DWORD   dwReserved;     // may be used by back pointer - depends on alignment
    };


    /*
     * internal members
     */
protected:
    static BOOL m_bInitialized;

protected:
    HEADER *m_pBase;            // 1st block
    HEADER *m_pBaseFree;        // 1st free block
    DWORD   m_dwRMID;
#ifndef WINNT
    DWORD   m_dwRootHandle;     // root handle
    DWORD   m_dwDeviceHandle;   // device handle
#endif

    /*
     * internal helpers
     */
protected:
    inline BOOL isBoundary (HEADER *p) const { return p->dwFlags & FLAG_BOUNDARY;     }
    inline BOOL isFree     (HEADER *p) const { return !(p->dwFlags & FLAG_ALLOCATED); }
    inline BOOL isAlloc    (HEADER *p) const { return p->dwFlags & FLAG_ALLOCATED;    }

    inline void AddToList(HEADER *pHeader) {
        pHeader->pPrev = NULL;
        pHeader->pNext = m_pBase;
        if (m_pBase) m_pBase->pPrev = pHeader;
        m_pBase = pHeader;
    }
    inline void RemoveFromList(HEADER *pHeader) {
        if (pHeader->pNext)     pHeader->pNext->pPrev = pHeader->pPrev;
        if (pHeader->pPrev)     pHeader->pPrev->pNext = pHeader->pNext;
        if (m_pBase == pHeader) m_pBase = pHeader->pNext;
    }
    inline void AddToFreeList(HEADER *pHeader) {
        pHeader->pPrevFree = NULL;
        pHeader->pNextFree = m_pBaseFree;
        if (m_pBaseFree) m_pBaseFree->pPrevFree = pHeader;
        m_pBaseFree = pHeader;
    }
    inline void RemoveFromFreeList(HEADER *pHeader) {
        if (pHeader->pNextFree)     pHeader->pNextFree->pPrevFree = pHeader->pPrevFree;
        if (pHeader->pPrevFree)     pHeader->pPrevFree->pNextFree = pHeader->pNextFree;
        if (m_pBaseFree == pHeader) m_pBaseFree = pHeader->pNextFree;
    }
    inline void CInterProcessHeap::freeBlock(HEADER *pHeader);

#ifdef CHEAP_SANITY_CHECK
           void dbgTestIntegrity (void);
#else
    inline void dbgTestIntegrity (void) const {}
#endif
    HEADER* create            (DWORD dwSize);
    void combineFreeBlocks (void);
    void releaseFreeBlocks (void);

    /*
     * public methods
     */
public:
    void  init    (void);
    void  destroy (void);
    void  checkHeapUsage (void);

#ifdef DEBUG
    void* alloc   (DWORD dwSize, void *pCaller = 0);
#else
    void* alloc   (DWORD dwSize);
#endif
    BOOL  realloc (void *pOldMem, DWORD dwNewSize, void **pNewMem);
    void  free    (void *pMemory);
};

//
// exports
//
extern CInterProcessHeap g_nvIPHeap;

inline void  InitIPM          (void)                { g_nvIPHeap.init();    }
inline void  DestroyIPM       (void)                { g_nvIPHeap.destroy(); }

inline void* AllocIPM         (DWORD dwSize)        { return g_nvIPHeap.alloc(dwSize); }
inline BOOL  ReallocIPM       (void *pOldMem, DWORD dwNewSize, void **ppNewMem) {
                                                      return g_nvIPHeap.realloc(pOldMem, dwNewSize, ppNewMem); }
inline void  FreeIPM          (void *pMemory)       { g_nvIPHeap.free(pMemory); }

//for interfacing with the vertex shader compilers
inline void* glLikeAllocIPM (void *bogus, size_t szSize) { return g_nvIPHeap.alloc((DWORD)szSize); }
inline void glLikeFreeIPM (void *bogus, void* pMemory) { g_nvIPHeap.free(pMemory); }

// all new & deletes use IPM
inline void* _cdecl operator new    (size_t nSize)  { return g_nvIPHeap.alloc(nSize); }
inline void  _cdecl operator delete (void *p)       { if (p) g_nvIPHeap.free(p);      }

// multi heap versions of new & delete
//inline void* _cdecl operator new    (size_t nSize, CInterProcessHeap* pHeap) { return pHeap->alloc(nSize); }
//inline void  _cdecl operator delete (void *p, CInterProcessHeap* pHeap)      { if (p) pHeap->free(p);      }

#endif  // _NVHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvLogo.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLogo.h                                                          *
*   NVIDIA Logo loading/drawing routines.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 05/26/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVLOGO_H_
#define _NVLOGO_H_

#ifdef __cplusplus
extern "C" {
#endif

void nvLoadLogo (void);
void nvFreeLogo (void);
void nvDrawLogo (PNVD3DCONTEXT pContext, BOOL bClear);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVLOGO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvmocomp.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       nvmocomp.h
 *  Content:    Windows98 DDraw 32 bit driver motion compensation definitions
 *
 ***************************************************************************/

#ifndef _NVMOCOMP_H_
#define _NVMOCOMP_H_

#ifdef __cplusplus
extern "C" {
#endif

// Execute functions
#define EXECUTE_MOTION_COMPENSATION                 0
#define EXECUTE_TEMPORAL_FILTER                     1
#define EXECUTE_SUBPICTURE_DECOMPRESSION            2
#define EXECUTE_SUBPICTURE_COMPOSITING              3
#define EXECUTE_DISPLAY_OVERLAY_SURFACE             4
#define EXECUTE_FORMAT_CONVERT_OVERLAY_SURFACE      5
#define EXECUTE_NON_PREBIASED_MOTION_COMPENSATION   6
#define EXECUTE_DXVA_ALPHA_BLENDING                 7

// Temporal filter options
#define TEMPORAL_FILTER_ENABLE_ON_ALL_SURFACES      0
#define TEMPORAL_FILTER_DISABLE_ON_ALL_SURFACES     1
#define TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE   128

// PictureStructure
#define PICTURE_STRUCTURE_TOP_FIELD     1
#define PICTURE_STRUCTURE_BOTTOM_FIELD  2
#define PICTURE_STRUCTURE_FRAME         3

// PictureCodingType
#define PICTURE_TYPE_I                  1
#define PICTURE_TYPE_P                  2
#define PICTURE_TYPE_B                  3

// CodedBlockPattern
#define CBP_Y0                          32
#define CBP_Y1                          16
#define CBP_Y2                          8
#define CBP_Y3                          4
#define CBP_CB                          2
#define CBP_CR                          1

// DCTType
#define DCT_FRAME                       0
#define DCT_FIELD                       1

// MacroblockType
#define MB_INTRA                        0
#define MB_MOTION_FORWARD               1
#define MB_MOTION_BACKWARD              2

// MotionType
#define FRAME_STRUCTURE_MOTION_FIELD    1       // Field prediction
#define FRAME_STRUCTURE_MOTION_FRAME    2       // Frame prediction
#define FRAME_STRUCTURE_MOTION_DP       3       // Dual prime prediction
#define FIELD_STRUCTURE_MOTION_FIELD    1       // Field prediction
#define FIELD_STRUCTURE_MOTION_16X8     2       // 16x8 prediction
#define FIELD_STRUCTURE_MOTION_DP       3       // Dual prime prediction

// CorrectionType
#define CORRECTION_FIRST_PASS           0
#define CORRECTION_OVERFLOW_PASS        1

// VertexMode
#define VERTEX_MODE_FORWARD             1
#define VERTEX_MODE_BACKWARD            2
#define VERTEX_MODE_BIDIRECTIONAL       3

// DataFormat
#define DATA_FORMAT_LUMA                        1
#define DATA_FORMAT_CHROMA                      2
#define DATA_FORMAT_CORRECTION                  3
#define DATA_FORMAT_CHROMA_CORRECTION           4
#define DATA_FORMAT_UNBIASED_CORRECTION         5
#define DATA_FORMAT_UNBIASED_CHROMA_CORRECTION  6
#define DATA_FORMAT_FOURCC_CONVERSION           7
#define DATA_FORMAT_TEMPORAL_FILTER             8
#define DATA_FORMAT_SUBPICTURE_LUMA_BLEND       9
#define DATA_FORMAT_SUBPICTURE_CHROMA_BLEND     10

#define CELSIUS_DESTINATION_VIEWPORT_XOFFSET    (2046 << 2)
// Calculated for a scale factor of 75% ((2046/0.75) << 2)
#define SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET    (10912)

// DXVA Convert Buffer
#define LOOKUP_TABLE_OFFSET         0
#define LOOKUP_TABLE_SIZE           1024L
#define MACROBLOCKS_OFFSET          1024L
#define MACROBLOCKS_SIZE            1048576L
#define CONVERT_BUFFER_SIZE         LOOKUP_TABLE_SIZE + MACROBLOCKS_SIZE

// Other DXVA Constants
#define DXVA_SUBPICTURE_WIDTH       720L
#define DXVA_SUBPICTURE_HEIGHT      576L


// PMV[r][s][t] definitions
//      index   0                                   1
//
//      r       first motion vector in macroblock   second motion vector in macroblock (also indexes 2 and 3 in dual prime)
//      s       forward motion vector               backward motion vector
//      t       horizontal component                vertical component
//


typedef struct tagNVBEGINFRAMEDATA {
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
} NVBEGINFRAMEDATA, *LPNVBEGINFRAMEDATA;


typedef unsigned long (*PFUNC)();

typedef struct tagNVMCFRAMEDATA {
  PFUNC dwMCNvExecute;
  DWORD dwMCMultiMonID;
  BYTE  bMCDestinationSurfaceIndex;
  BYTE  bMCForwardSurfaceIndex;
  BYTE  bMCBackwardSurfaceIndex;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCEndOfPicture;

  // The following are reserved for NVDS proprietary interface.
  BYTE  bReserved1;
  BYTE  bReserved2;
  BYTE  bReserved3;
  DWORD dwReserved4;

  // The following are used by our DXVA functions only.
  WORD  wDXVADecodedPictureIndex;
  WORD  wDXVAForwardRefPictureIndex;
  WORD  wDXVABackwardRefPictureIndex;
  WORD  wDXVAPicWidthInMB;
  WORD  wDXVAPicHeightInMB;
  DWORD dwDXVASubpicBuffer;
  DWORD dwDXVASubpicStride;
  RECT  rcGraphicSourceRect;
  RECT  rcGraphicDestinationRect;
  BYTE  bBlendOn;

} NVMCFRAMEDATA, *LPNVMCFRAMEDATA;


typedef struct tagNVDECODEMACROBLOCK {
  short hOffset;            // upper left macroblock coordinates in pels
  short vOffset;            // upper left macroblock coordinates in scanlines
  unsigned short firstIDCTIndex;
  BYTE DCTType;
  BYTE codedBlockPattern;
  BYTE overflowCodedBlockPattern;
  BYTE motionType;
  short PMV[2][2][2];       // contains motion vectors in half pel units
  BYTE fieldSelect[2][2];
  BYTE macroblockType;
  BYTE pad0;                // currently unused
} NVDECODEMACROBLOCK, *LPNVDECODEMACROBLOCK;


typedef struct tagNVMCDISPLAYOVERLAYDATA {
    DWORD dwMCOverlayFlags; // DDOVER_INTERLEAVED, DDOVER_BOB, etc.
    DWORD dwMCFlipFlags;    // DDFLIP_ODD, DDFLIP_EVEN, DDFLIP_WAIT, etc.
} NVMCDISPLAYOVERLAYDATA, *LPNVMCDISPLAYOVERLAYDATA;


typedef struct tagNVMCFILTERDATA {
    BYTE bMCCurrentFieldCombinationFactor;      // 0 - 100 (%)
    BYTE bMCFilterOptions;                      // 0 == default == enable on all surfaces, 1 == disable on all surfaces
} NVMCFILTERDATA, *LPNVMCFILTERDATA;            // 128 == disable on dwSurfaceIndex only


typedef struct tagNVSPDECOMPRESSDATA {
    short wSPHOffset;
    short wSPVOffset;
    short wSPWidth;
    short wSPHeight;
    BYTE bSPUpdateLookUpTable; // TRUE == look up table has changed, FALSE == no look up table change
    BYTE bSPNumberOfActiveTableEntries; // 0 == 256, else 1 - 255
    BYTE bSPFormat;             // 0 == YUV, 1 == RGB
    BYTE bSPpad1;               // currently unused
    DWORD dwSPLookUpTable[256]; // byte format in each YUV DWORD is byte0 = V, byte1 = U, byte2 = Y, byte3 = X
                                // byte format in each RGB DWORD is byte0 = B, byte1 = G, byte2 = R, byte3 = X
} NVSPDECOMPRESSDATA, *LPNVSPDECOMPRESSDATA;


typedef struct tagNVSPCOMPOSITEDATA {
    short wSPHOffset;
    short wSPVOffset;
    short wSPWidth;
    short wSPHeight;
    short wMCHOffset;
    short wMCVOffset;
    short wMCWidth;
    short wMCHeight;
    BYTE bSPCompositeWith; // Frame/Top Field/Bottom Field
    BYTE bSPRestoreImageBeforeCompositing;
} NVSPCOMPOSITEDATA, *LPNVSPCOMPOSITEDATA;


typedef struct tagNVMOCOMPPARAMS {
  unsigned long surfaceLumaPitch;
  unsigned long surfaceLumaHeight;
  unsigned long surfaceOffset;
  unsigned long surfaceChromaOffset;
  unsigned long surfaceBiasedIntraBlockOffset;
  long blockX;
  long blockY;
  long blockY2;
  long correctionY;
  short blockWidth;
  short blockHeight;
  short forwardHorizontalVector;
  short forwardVerticalVector;
  short backwardHorizontalVector;
  short backwardVerticalVector;
  BYTE forwardField;
  BYTE backwardField;
  BYTE correctionField;
  BYTE destinationField;
  BYTE currentForwardField;
  BYTE currentBackwardField;
  BYTE currentDestinationField;
  BYTE destinationFieldIs0;
  short forwardHorizontalVector2;
  short forwardVerticalVector2;
  short backwardHorizontalVector2;
  short backwardVerticalVector2;
  BYTE forwardField2;
  BYTE backwardField2;
  BYTE correctionField2;
  BYTE destinationField2;
  BYTE vertexMode;
  BYTE dataFormat;
  short celsiusDestinationViewportXOffset;
  short celsiusFieldXOffset;
} NVMOCOMPPARAMS, *LPNVMOCOMPPARAMS;


#if (NVARCH >= 0x10)

typedef void (__stdcall *PNVMCPREDFUNC)(BOOL);
typedef DWORD (__stdcall *PNVMCPREDFUNC2)(LPNVDECODEMACROBLOCK, WORD);
typedef void (__stdcall *PNVMCCORRFUNC)(void);
typedef void (__stdcall *PNVMCCORRFUNC2)(long, long);

#define nvPushMoCompQuadData(OFFSET) do { \
    nvPushData((OFFSET), texture1BlockY0 | texture1BlockX0); \
    nvPushData((OFFSET+1), texture0BlockY0 | texture0BlockX0); \
    nvPushData((OFFSET+2), blockY0 | blockX0); \
    nvPushData((OFFSET+3), texture1BlockY1 | texture1BlockX0); \
    nvPushData((OFFSET+4), texture0BlockY1 | texture0BlockX0); \
    nvPushData((OFFSET+5), blockY1 | blockX0); \
    nvPushData((OFFSET+6), texture1BlockY1 | texture1BlockX1); \
    nvPushData((OFFSET+7), texture0BlockY1 | texture0BlockX1); \
    nvPushData((OFFSET+8), blockY1 | blockX1); \
    nvPushData((OFFSET+9), texture1BlockY0 | texture1BlockX1); \
    nvPushData((OFFSET+10), texture0BlockY0 | texture0BlockX1); \
    nvPushData((OFFSET+11), blockY0 | blockX1); \
} while(0)

#define nvPushKelvinMoCompQuadData(OFFSET) do { \
    nvPushData((OFFSET), blockY0 | blockX0); \
    nvPushData((OFFSET+1), texture0BlockY0 | texture0BlockX0); \
    nvPushData((OFFSET+2), texture1BlockY0 | texture1BlockX0); \
    nvPushData((OFFSET+3), blockY1 | blockX0); \
    nvPushData((OFFSET+4), texture0BlockY1 | texture0BlockX0); \
    nvPushData((OFFSET+5), texture1BlockY1 | texture1BlockX0); \
    nvPushData((OFFSET+6), blockY1 | blockX1); \
    nvPushData((OFFSET+7), texture0BlockY1 | texture0BlockX1); \
    nvPushData((OFFSET+8), texture1BlockY1 | texture1BlockX1); \
    nvPushData((OFFSET+9), blockY0 | blockX1); \
    nvPushData((OFFSET+10), texture0BlockY0 | texture0BlockX1); \
    nvPushData((OFFSET+11), texture1BlockY0 | texture1BlockX1); \
} while(0)



#define DEFAULT_ALPHA_ICW   (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                            (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |             \
                            (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                            \
                            (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                            (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |             \
                            (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                            \
                            (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                            (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |             \
                            (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                            \
                            (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                            (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |              \
                             NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0

#define DEFAULT_COLOR_ICW   (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                            (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |            \
                            (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                            \
                            (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                            (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |            \
                            (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                            \
                            (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                            (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |            \
                            (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                            \
                            (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                            (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |             \
                             NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0

#define DEFAULT_ALPHA_OCW   (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |        \
                            (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |         \
                            (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |             \
                            (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |              \
                             NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0

#define DEFAULT_C1_COLOR_OCW (NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE << 28) |    \
                             (NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB << 27) |         \
                             (NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT << 15) |      \
                             (NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE << 14) |       \
                             (NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |    \
                             (NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |    \
                             (NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C << 8) |           \
                             (NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0 << 4) |            \
                              NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0

#define SET_LUMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_LUMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_LUMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_LUMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_LUMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_LUMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_CHROMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_CHROMA_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_UNBIASED_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000); \
        nvPushData(3, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) | \
                      (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) | \
                      (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) | \
                      (1 << 12) | \
                      (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8 << 7) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) | \
                      (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) | \
                      (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(5); \
    } \
} while(0)

#define SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)

#define SET_KELVIN_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT() do { \
    if (nvMoCompParams.dataFormat != DATA_FORMAT_UNBIASED_CHROMA_CORRECTION) { \
        nvMoCompParams.dataFormat = DATA_FORMAT_UNBIASED_CHROMA_CORRECTION; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_SURFACE_FORMAT | 0x40000); \
        nvPushData(1, (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) | \
                      (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) | \
                      (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) | \
                       NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(0) | 0x40000); \
        nvPushData(3, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B); \
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_TEXTURE_FORMAT(1) | 0x40000); \
        nvPushData(5, (1 << 16) | \
                      (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8 << 8) | \
                      (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) | \
                      (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) | \
                      (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) | \
                       NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A); \
        nvPusherAdjust(6); \
    } \
} while(0)


// NOTE: vertexSizeContext is an NV10 hardware context switching bug workaround which saves the
// current vertex size context in an unused but context switched location in the 2nd inverse
// model view matrix which the RM uses to restore this lost context data when restoring the context of this channel

#define SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BIDIRECTIONAL) { \
        unsigned long vertexSizeContext; \
        nvMoCompParams.vertexMode = VERTEX_MODE_BIDIRECTIONAL; \
        vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                            (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                            (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                            (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                            (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                            (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                            (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                            (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
        nvPushData(1, vertexSizeContext); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
        nvPushData(3, 0); \
        nvPushData(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                      (12 << 8) | \
                      (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(5, 0); \
        nvPushData(6, (12 << 8) | \
                      (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(7, 0); \
        nvPushData(8, (12 << 8) | \
                      (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(9, 4); \
        nvPushData(10, (12 << 8) | \
                      (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(11, 8); \
        nvPushData(12, (12 << 8) | \
                       (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(13, 0); \
        nvPushData(14, (12 << 8) | \
                       (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(15, 0); \
        nvPushData(16, (12 << 8) | \
                       (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(17, 0); \
        nvPushData(18, (12 << 8) | \
                       (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
        nvPusherAdjust(19); \
    } \
} while(0)

// Kelvin vertex data array slots (in order)
//
// Position
// Weight
// Normal
// Diffuse
// Specular (RGBA or BGRF in 4th component, if present)
// Fog
// Point Size
// Back Diffuse
// Back Specular
// Texture 0
// Texture 1
// Texture 2
// Texture 3
// Reserved
// Reserved
// Reserved

#define SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BIDIRECTIONAL) { \
        nvMoCompParams.vertexMode = VERTEX_MODE_BIDIRECTIONAL; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000); \
        nvPushData(1, 0); \
        nvPushData(2, 0); \
        nvPushData(3, 0); \
        nvPushData(4, 0); \
        nvPushData(5, 0); \
        nvPushData(6, 0); \
        nvPushData(7, 0); \
        nvPushData(8, 0); \
        nvPushData(9, 0); \
        nvPushData(10, 4); \
        nvPushData(11, 8); \
        nvPushData(12, 0); \
        nvPushData(13, 0); \
        nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                       NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000); \
        nvPushData(15, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(16, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(17, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(18, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(19, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(20, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(21, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(22, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(23, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(24, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(25, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(26, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(27, (12 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPusherAdjust(28); \
    } \
} while(0)

// NOTE: vertexSizeContext is an NV10 hardware context switching bug workaround which saves the
// current vertex size context in an unused but context switched location in the 2nd inverse
// model view matrix which the RM uses to restore this lost context data when restoring the context of this channel

#define SET_FORWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_FORWARD) { \
        unsigned long vertexSizeContext; \
        nvMoCompParams.vertexMode = VERTEX_MODE_FORWARD; \
        vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                            (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                            (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                            (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                            (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0 << 16) | \
                            (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                            (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                            (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
        nvPushData(1, vertexSizeContext); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
        nvPushData(3, 0); \
        nvPushData(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                      (8 << 8) | \
                      (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(5, 0); \
        nvPushData(6, (8 << 8) | \
                      (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(7, 0); \
        nvPushData(8,(8 << 8) | \
                      (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(9, 4); \
        nvPushData(10, (8 << 8) | \
                      (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(11, 0); \
        nvPushData(12, (8 << 8) | \
                       (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(13, 0); \
        nvPushData(14, (8 << 8) | \
                       (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(15, 0); \
        nvPushData(16, (8 << 8) | \
                       (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(17, 0); \
        nvPushData(18, (8 << 8) | \
                       (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
        nvPusherAdjust(19); \
    } \
} while(0)

#define SET_KELVIN_FORWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_FORWARD) { \
        nvMoCompParams.vertexMode = VERTEX_MODE_FORWARD; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000); \
        nvPushData(1, 0); \
        nvPushData(2, 0); \
        nvPushData(3, 0); \
        nvPushData(4, 0); \
        nvPushData(5, 0); \
        nvPushData(6, 0); \
        nvPushData(7, 0); \
        nvPushData(8, 0); \
        nvPushData(9, 0); \
        nvPushData(10, 4); \
        nvPushData(11, 0); \
        nvPushData(12, 0); \
        nvPushData(13, 0); \
        nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                       NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000); \
        nvPushData(15, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(16, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(17, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(18, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(19, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(20, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(21, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(22, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(23, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(24, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(25, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(26, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(27, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPusherAdjust(28); \
    } \
} while(0)

// NOTE: vertexSizeContext is an NV10 hardware context switching bug workaround which saves the
// current vertex size context in an unused but context switched location in the 2nd inverse
// model view matrix which the RM uses to restore this lost context data when restoring the context of this channel

#define SET_BACKWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BACKWARD) { \
        unsigned long vertexSizeContext; \
        nvMoCompParams.vertexMode = VERTEX_MODE_BACKWARD; \
        vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                            (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                            (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                            (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0 << 12) | \
                            (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                            (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                            (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                            (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
        nvPushData(1, vertexSizeContext); \
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + \
                      NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
        nvPushData(3, 0); \
        nvPushData(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                      (8 << 8) | \
                      (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                       NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(5, 0); \
        nvPushData(6, (8 << 8) | \
                      (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(7, 0); \
        nvPushData(8, (8 << 8) | \
                      (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
        nvPushData(9, 0); \
        nvPushData(10, (8 << 8) | \
                      (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0 << 4) | \
                       NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(11, 4); \
        nvPushData(12, (8 << 8) | \
                       (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(13, 0); \
        nvPushData(14, (8 << 8) | \
                       (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(15, 0); \
        nvPushData(16, (8 << 8) | \
                       (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
        nvPushData(17, 0); \
        nvPushData(18, (8 << 8) | \
                       (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                        NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
        nvPusherAdjust(19); \
    } \
} while(0)

#define SET_KELVIN_BACKWARD_VERTEX_ARRAY_MODE() do { \
    if (nvMoCompParams.vertexMode != VERTEX_MODE_BACKWARD) { \
        nvMoCompParams.vertexMode = VERTEX_MODE_BACKWARD; \
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                      NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000); \
        nvPushData(1, 0); \
        nvPushData(2, 0); \
        nvPushData(3, 0); \
        nvPushData(4, 0); \
        nvPushData(5, 0); \
        nvPushData(6, 0); \
        nvPushData(7, 0); \
        nvPushData(8, 0); \
        nvPushData(9, 0); \
        nvPushData(10, 0); \
        nvPushData(11, 4); \
        nvPushData(12, 0); \
        nvPushData(13, 0); \
        nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) + \
                       NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000); \
        nvPushData(15, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(16, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(17, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(18, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(19, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(20, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(21, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(22, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(23, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(24, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(25, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(26, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPushData(27, (8 << 8) | \
                       (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) | \
                        NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K); \
        nvPusherAdjust(28); \
    } \
} while(0)

//---------------------------------------------------------------------------

// global varaiables

#ifdef  DEBUG
extern unsigned long overlaySurfaceBase;
extern unsigned long moCompDebugLevel;
#endif  // DEBUG

//---------------------------------------------------------------------------

// Because of differences between the Win9X and Win2K headers...
#ifdef  WINNT
typedef DDMOCOMPBUFFERINFO  DDMCBUFFERINFO, *LPDDMCBUFFERINFO;
#endif

// prototypes

void  __stdcall nvGetMoCompDriverInfo (LPDDHAL_GETDRIVERINFODATA lpData);
DWORD __stdcall nvMoCompExecute (DWORD dwMCMultiMonID,
                                 DWORD dwFunction,
                                 LPVOID lpInputData,
                                 DWORD dwInputDataSize,
                                 DWORD dwSurfaceIndex);
DWORD __stdcall nvMoCompConvertSurfaceFormat (DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert);
DWORD __stdcall nvMoCompTemporalFilter (DWORD fpVidMem, BYTE combinationFactor);
DWORD __stdcall nvRenderCheckDecodeConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData);
DWORD __stdcall nvRenderCheckAlphaLoadConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData);
DWORD __stdcall nvRenderCheckAlphaCombineConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData);
DWORD __stdcall nvRenderGetPictureParams(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                         LPDDMCBUFFERINFO lpPictureParams);
DWORD __stdcall nvRenderDoMotionComp(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                     DWORD dwMacroblockIndex,
                                     DWORD dwDifferenceIndex);
LPBYTE __stdcall nvGetLinearAddress(LPDDRAWI_DDRAWSURFACE_LCL lpSurf);
DWORD  __stdcall nvRenderGetYUVPalette(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex);
DWORD  __stdcall nvRenderGetIA44Surface(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex);
DWORD  __stdcall nvRenderAlphaBlendCombination(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex);
DWORD  __stdcall nvDXVACompositeSubpicture(LPVOID lpInputData, DWORD dwIndex);
void   __stdcall nvUpdateDXVAIndexTable(GLOBALDATA *pDriverData);
DWORD  __stdcall nvMoCompFrameStatus(FLATPTR fpVidMem);
DWORD  __stdcall nvDXVABackEndAlphaBlend(FLATPTR fpVidMem);

#endif  // NVARCH >= 0x10

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVMOCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvObject.h ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvObject.h
//        definition of CNvObject
//
//  History:
//        Craig Duttweiler      (bertrem)      10Apr00      created
//
// **************************************************************************
#include "nvPatch.h"

// forward defintions
class CTexture;
class CVertexBuffer;
class CCommandBuffer;
class CVideoSurface;

class CNvObject
{
    //
    // constants
    //
public:
    enum
    {
        NVOBJ_UNKNOWN           = 0,
        NVOBJ_TEXTURE           = 1,
        NVOBJ_VERTEXBUFFER      = 2,
        NVOBJ_COMMANDBUFFER     = 3,
        NVOBJ_SIMPLESURFACE     = 4,
        NVOBJ_PALETTE           = 5,
        NVOBJ_VERTEXSHADER      = 6,
        NVOBJ_PIXELSHADER       = 7,
        NVOBJ_CACHEDPATCH       = 8,

        NVOBJID0                = 0x4e564944,
        NVOBJID1                = 0x420352ec,

        FLAG_CT_ENABLE          = 1,
        FLAG_CT_FLOCK           = 2,
        FLAG_CT_FBLT            = 4,
        FLAG_CT_ZLOCK           = 8,
        FLAG_CT_ZBLT            = 16,
        FLAG_CT_ZE              = 32,
        FLAG_CT_FRONT           = 64,
        FLAG_CT_DRAWPRIM        = 128,
        FLAG_CT_DBLCLEAR        = 256,

        FLAG_ALT_STENCIL_ENABLE  = 512,
        FLAG_ALT_STENCIL_BAD_SEM = 1024,
    };

    enum RTC_STATE
    {
        RTC_STATE_NONE = 0,
        RTC_START_NO_CLEAR = 1,
        RTC_START_PARTIAL = 2,
        RTC_STOP_PARTIAL = 3,
        RTC_CLEAR_FULL = 4
    };

    //
    // members
    //
protected:
// bank
    CNvObject        *m_pAttachedA;  // next attached surface on "axis 1" (used for mipmaps, flip chains)
    CNvObject        *m_pAttachedB;  // next attached surface on "axis 2" (used for cubemap faces)
    CNvObject        *m_pPrev;
    CNvObject        *m_pNext;
    DWORD             m_dwRefCount;
    void             *m_pObject;
    DWORD             m_dwClass;
// bank
    DWORD             m_dwPID;
    DWORD             m_dwDDLclID;   // a tag for the DDLcl with which this object is associated
    DWORD             m_dwHandle;    // the handle by which this object was last known (note it is not guaranteed to be currently valid!!)
    DWORD             m_dwFlags;
    BOOL              m_bDirty;      // used to indicate if the surface has been modified in CreateSurfaceEx
#ifdef WINNT
    PDD_SURFACE_LOCAL m_pDDSLcl;
#endif

    CNvObject        *m_pPalette;

    // data whose function varies depending on the type of object
    // please re-use these when possible rather than adding more fields
    DWORD             m_dwContextualValue0;   // for z-buffers: width of last RT with which associated
    DWORD             m_dwContextualValue1;   // for z-buffers: height of last RT with which associated

    DWORD             m_ContextDma;   // only used for system memory surfaces

#ifdef DEBUG
    DWORD             m_dwID[2];
#else
    DWORD             m_dwReserved[2];
#endif
    RTC_STATE         m_clrRTState;
    BOOL              m_bRTLocked;
    //
    // helpers
    //
public:
    inline BOOL isValid (void) const
    {
#ifdef DEBUG
        // readable
        if (IsBadReadPtr(this,sizeof(*this)))                   return FALSE;
        // match ID                     ss
        if ((m_dwID[0] != NVOBJID0) || (m_dwID[1] != NVOBJID1)) return FALSE;
#endif
        // valid if this instance is non NULL
        return this != NULL;
    }
    inline DWORD getClass (void) const
    {
#ifdef DEBUG
        // readable
        if (IsBadReadPtr(this,sizeof(*this)))                   return NVOBJ_UNKNOWN;
        // match ID
        if ((m_dwID[0] != NVOBJID0) || (m_dwID[1] != NVOBJID1)) return NVOBJ_UNKNOWN;
#endif
        // valid
        return this ? m_dwClass : NULL;
    }

    inline void               setObject           (DWORD dwClass, void *pObject) { m_dwClass = dwClass; m_pObject = pObject; }

    inline DWORD              getPID              (void) const { return m_dwPID; }
    inline CNvObject*         getNext             (void) const { return m_pNext; }

    inline CTexture*          getTexture          (void) const { return (CTexture*)       ((getClass() == NVOBJ_TEXTURE)       ? m_pObject : NULL); }
    inline CVertexBuffer*     getVertexBuffer     (void) const { return (CVertexBuffer*)  ((getClass() == NVOBJ_VERTEXBUFFER)  ? m_pObject : NULL); }
    inline CCommandBuffer*    getCommandBuffer    (void) const { return (CCommandBuffer*) ((getClass() == NVOBJ_COMMANDBUFFER) ? m_pObject : NULL); }
    inline CSimpleSurface*    getSimpleSurface    (void) const { return (CSimpleSurface*) ((getClass() == NVOBJ_SIMPLESURFACE) ? m_pObject : NULL); }

    // returns a pointer to the surface containing the palette information (called on the PaletteObject -- NOT the texture->paletteObject)
    inline CSimpleSurface*    getPaletteSurface   (void) const { return (CSimpleSurface*) ((getClass() == NVOBJ_PALETTE)       ? m_pObject : NULL); }

    inline CVertexShader*     getVertexShader     (void) const { return (CVertexShader*) ((getClass() == NVOBJ_VERTEXSHADER) ? m_pObject : NULL); }
    inline CPixelShader*      getPixelShader      (void) const { return (CPixelShader*)  ((getClass() == NVOBJ_PIXELSHADER)  ? m_pObject : NULL); }
    inline CPatch*            getPatch            (void) const { return (CPatch*)        ((getClass() == NVOBJ_CACHEDPATCH)  ? m_pObject : NULL); }

    inline void               setAttachedA        (CNvObject *pA)  { m_pAttachedA = pA; }
    inline CNvObject*         getAttachedA        (void) const { return (m_pAttachedA); }
    inline void               setAttachedB        (CNvObject *pB)  { m_pAttachedB = pB; }
    inline CNvObject*         getAttachedB        (void) const { return (m_pAttachedB); }

    inline void               setDDLclID          (DWORD dwID) { m_dwDDLclID = dwID; }
    inline DWORD              getDDLclID          (void) const { return (m_dwDDLclID); }

#ifdef WINNT
    inline void               setDDSLcl           (PDD_SURFACE_LOCAL pDDSLcl) { m_pDDSLcl = pDDSLcl; }
    inline PDD_SURFACE_LOCAL  getDDSLcl           (void) const { return m_pDDSLcl; }
#endif // WINNT

    inline void               setHandle           (DWORD dwH)  { m_dwHandle = dwH; }
    inline DWORD              getHandle           (void) const { return (m_dwHandle); }

    inline BOOL               hasCTEnabled        (void) const { return m_dwFlags & FLAG_CT_ENABLE; }
    inline BOOL               hasCTEnabledNotFront(void) const { return (m_dwFlags & (FLAG_CT_ENABLE | FLAG_CT_FRONT)) == FLAG_CT_ENABLE; }
    inline void               enableCT            (void)       { m_dwFlags |= FLAG_CT_ENABLE; }
    inline void               disableCT           (void)       { m_dwFlags &= ~FLAG_CT_ENABLE; }

    inline BOOL               isAltStencilEnabled       (void) const { return (m_dwFlags & FLAG_ALT_STENCIL_ENABLE); }
    inline void               tagAltStencilEnabled      (void)       { m_dwFlags |= FLAG_ALT_STENCIL_ENABLE; }
    inline void               tagAltStencilDisabled     (void)       { m_dwFlags &= ~FLAG_ALT_STENCIL_ENABLE; }
    inline BOOL               hasAltStencilBadSemantics (void) const { return (m_dwFlags & FLAG_ALT_STENCIL_BAD_SEM); }
    inline void               tagAltStencilBadSemantics (void)       { m_dwFlags |= FLAG_ALT_STENCIL_BAD_SEM; }

    inline BOOL               isCTFLock           (void) const { return m_dwFlags & FLAG_CT_FLOCK; }
    inline void               tagFLock            (void)       { m_dwFlags |= FLAG_CT_FLOCK; }

    inline BOOL               isCTFBlt            (void) const { return m_dwFlags & FLAG_CT_FBLT; }
    inline void               tagFBlt             (void)       { m_dwFlags |= FLAG_CT_FBLT; }

    inline BOOL               isCTZLock           (void) const { return m_dwFlags & FLAG_CT_ZLOCK; }
    inline void               tagZLock            (void)       { m_dwFlags |= FLAG_CT_ZLOCK; }

    inline BOOL               isCTZBlt            (void) const { return m_dwFlags & FLAG_CT_ZBLT; }
    inline void               tagZBlt             (void)       { m_dwFlags |= FLAG_CT_ZBLT; }

    inline void               tagDblClear         (void)       { m_dwFlags |= FLAG_CT_DBLCLEAR; }

    inline BOOL               hasBadCTSem         (void) const { return m_dwFlags & (FLAG_CT_ZBLT | FLAG_CT_ZLOCK | FLAG_CT_ZE | FLAG_CT_DBLCLEAR | FLAG_CT_FBLT); }
                                                                 /*| FLAG_CT_FBLT | FLAG_CT_FLOCK */

    inline BOOL               isCTDrawPrim        (void) const { return m_dwFlags & FLAG_CT_DRAWPRIM; }
    inline void               clearCTDrawPrim     (void)       { m_dwFlags &= ~FLAG_CT_DRAWPRIM; }
    inline void               setCTDrawPrim       (void)       { m_dwFlags |= FLAG_CT_DRAWPRIM; }

    inline void               setCTFront          (void)       { m_dwFlags |= FLAG_CT_FRONT; }
    inline BOOL               isCTFront           (void) const { return m_dwFlags & FLAG_CT_FRONT; }

    inline void               toggleFrontDrawPrim (void)       { m_dwFlags ^= FLAG_CT_FRONT | FLAG_CT_DRAWPRIM; }
    inline void               tagCTZE             (void)       { m_dwFlags |= FLAG_CT_ZE; }

    inline DWORD              getFlags            (void) const { return m_dwFlags; }

    inline BOOL               isDirty             (void) const { return m_bDirty;  }
    inline void               setDirty            (void)       { m_bDirty = TRUE;  }
    inline void               clearDirty          (void)       { m_bDirty = FALSE; }

    inline void               setRTLocked         (void)       { m_bRTLocked = TRUE; m_clrRTState = RTC_STATE_NONE; }
    inline bool               doClearRTAll        (void) const { return (m_clrRTState == RTC_STATE_NONE) || (m_clrRTState == RTC_CLEAR_FULL); }
    inline bool               doClearRTPartial    (void) const { return m_clrRTState == RTC_START_PARTIAL; }
    inline bool               doClearRTNone       (void) const { return (m_clrRTState == RTC_START_NO_CLEAR) || (m_clrRTState == RTC_STOP_PARTIAL); }
    inline void               adjustRTCBounds     (DWORD &y, DWORD &h) const { if (doClearRTPartial()) {y += 2*h/16; h = 14*h/16; }}
    inline void               allowClearRT        (void)       { m_clrRTState = RTC_STATE_NONE; }

    // set/access the linked palette (relevant only for CNvObjects containing textures)
    inline void               setPalette          (CNvObject *pPal)  { m_pPalette = pPal; }
    inline CNvObject*         getPalette          (void) const       { return (m_pPalette); }

    inline void               setContextDma       (DWORD dwCDma)  { m_ContextDma = dwCDma; }
    inline DWORD              getContextDma       (void) const    { return m_ContextDma; }

    inline void               setContextualValue0 (DWORD dwValue) { m_dwContextualValue0 = dwValue; }
    inline DWORD              getContextualValue0 (void) const    { return m_dwContextualValue0; }
    inline void               setContextualValue1 (DWORD dwValue) { m_dwContextualValue1 = dwValue; }
    inline DWORD              getContextualValue1 (void) const    { return m_dwContextualValue1; }

    //
    // internal helpers
    //
#ifdef DEBUG
           void dbgTestIntegrity (void);
#else
    inline void dbgTestIntegrity (void) const {}
#endif

    //
    // reference count
    //
public:
    inline DWORD reference (void) {
        DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjReference: this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
        return ++m_dwRefCount;
    }

    inline DWORD release   (void) {
        if (--m_dwRefCount){
            DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjRelease: this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
            return m_dwRefCount;
        }
        DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjRelease(Del): this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
        delete this;
        return 0;
    }

    // completely swap the contents of two NvObjects EXCEPT :
    // - pPrev and pNext, since doing so would mess up the chain
    // - reserved fields that are currently unused
    inline void swap (CNvObject *pNvObj) {
        NV_SWAP_1 (m_pAttachedA,         pNvObj->m_pAttachedA);
        NV_SWAP_1 (m_pAttachedB,         pNvObj->m_pAttachedB);
        NV_SWAP_1 (m_dwRefCount,         pNvObj->m_dwRefCount);
        NV_SWAP_1 (m_pObject,            pNvObj->m_pObject);
        NV_SWAP_1 (m_dwClass,            pNvObj->m_dwClass);
        NV_SWAP_1 (m_dwPID,              pNvObj->m_dwPID);
        NV_SWAP_1 (m_dwDDLclID,          pNvObj->m_dwDDLclID);
        NV_SWAP_1 (m_dwHandle,           pNvObj->m_dwHandle);
        NV_SWAP_1 (m_dwFlags,            pNvObj->m_dwFlags);
        NV_SWAP_1 (m_bDirty,             pNvObj->m_bDirty);
    #ifdef WINNT
        NV_SWAP_1 (m_pDDSLcl,            pNvObj->m_pDDSLcl);
    #endif
        NV_SWAP_1 (m_pPalette,           pNvObj->m_pPalette);
        NV_SWAP_1 (m_ContextDma,         pNvObj->m_ContextDma);

        NV_SWAP_1 (m_dwContextualValue0, pNvObj->m_dwContextualValue0);
        NV_SWAP_1 (m_dwContextualValue1, pNvObj->m_dwContextualValue1);

    #ifdef DEBUG
        NV_SWAP_1 (m_dwID[0],            pNvObj->m_dwID[0]);
        NV_SWAP_1 (m_dwID[1],            pNvObj->m_dwID[1]);
    #endif

        // fix up the back-pointers in the child objects
        ((CSimpleSurface *)(  this->m_pObject))->setWrapper (  this);
        ((CSimpleSurface *)(pNvObj->m_pObject))->setWrapper (pNvObj);
    }

    //
    // construction
    //
public:
    inline CNvObject (DWORD dwPID)
    {
        // sanity
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        // assign
        m_pAttachedA  = NULL;
        m_pAttachedB  = NULL;
        m_dwClass     = NVOBJ_UNKNOWN;
        m_pObject     = NULL;
        m_dwPID       = dwPID;
        m_dwDDLclID   = 0;
        m_dwHandle    = 0;
        m_dwRefCount  = 1;
        m_dwFlags     = 0;
        m_bDirty      = FALSE;
        m_pPalette    = NULL;
        m_ContextDma  = 0;
        m_dwContextualValue0 = 0;
        m_dwContextualValue1 = 0;
        m_clrRTState = RTC_STATE_NONE;
        m_bRTLocked = FALSE;

#ifdef DEBUG
        m_dwID[0]     = NVOBJID0;
        m_dwID[1]     = NVOBJID1;
#endif

        // attach to our list of all NvObjects
        m_pPrev = NULL;
        m_pNext = global.pNvObjectHead;
        if (m_pNext) m_pNext->m_pPrev = this;
        global.pNvObjectHead = this;

        // check sanity
        dbgTestIntegrity();
        if (m_pPrev) m_pPrev->dbgTestIntegrity();
        if (m_pNext) m_pNext->dbgTestIntegrity();
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        DPF_LEVEL(NVDBG_LEVEL_NVOBJ_INFO,"NVObjCreate: this = %08x handle = %08x refcount = %d\n",this,m_dwHandle, m_dwRefCount);
    }


    void CNvObject::checkClearRT (DWORD dwEarlyCopyStrategy, float *A, float *B, float *C)
    {
        float dist;
        float aa, bb, cc;
        const float epsilon = 20.0f;
        static DWORD t[5][3] ={
            {0, 0, 0},                              //RTC_STATE_NONE
            {0x412AB541, 0xC18F6038, 0xC1F25F30},   //RTC_START_NO_CLEAR
            {0xC1E02B5C, 0x41329DB7, 0xC203223C},   //RTC_START_PARTIAL
            {0x3FB8F4FF, 0xBDD35fDF, 0x41cc4DED},   //RTC_STOP_PARTIAL
            {0x4042B599, 0xC012F702, 0xC110395b}    //RTC_CELAER_FULL
        };
        static float *table[5] = {(float *) t[0], (float *) t[1], (float *) t[2], (float *) t[3], (float *) t[4] };

        if ((dwEarlyCopyStrategy != 0x34))
        {
            allowClearRT();
            return;
        }

        if (m_bRTLocked)
            m_clrRTState = RTC_CLEAR_FULL;
        else if (m_clrRTState == RTC_STATE_NONE)
        {
            m_clrRTState = RTC_START_NO_CLEAR;
        }
        else
        {
            switch (m_clrRTState) {
            case RTC_START_NO_CLEAR:
                aa = table[RTC_START_PARTIAL][0] - *A;
                aa *= aa;
                bb = table[RTC_START_PARTIAL][1] - *B;
                bb *= bb;
                cc = table[RTC_START_PARTIAL][2] - *C;
                cc *= cc;
                dist = aa + bb + cc;
                if (dist < epsilon) m_clrRTState = RTC_START_PARTIAL;
                break;
            case RTC_START_PARTIAL:
                aa = table[RTC_STOP_PARTIAL][0] - *A;
                aa *= aa;
                bb = table[RTC_STOP_PARTIAL][1] - *B;
                bb *= bb;
                cc = table[RTC_STOP_PARTIAL][2] - *C;
                cc *= cc;
                dist = aa + bb + cc;
                if (dist < epsilon) m_clrRTState = RTC_STOP_PARTIAL;
                break;
            case RTC_STOP_PARTIAL:
                aa = table[RTC_CLEAR_FULL][0] - *A;
                aa *= aa;
                bb = table[RTC_CLEAR_FULL][1] - *B;
                bb *= bb;
                cc = table[RTC_CLEAR_FULL][2] - *C;
                cc *= cc;
                dist = aa + bb + cc;
                if (dist < epsilon) m_clrRTState = RTC_CLEAR_FULL;
                break;
            case RTC_CLEAR_FULL:
                break;
            };


        }

        m_bRTLocked = FALSE;
    }



    // do NOT call delete on this object. ONLY call release()
private:
    ~CNvObject (void)
    {
        if (m_pObject != NULL)
        {
            clearReferences();

            switch (getClass()) {
                case NVOBJ_TEXTURE:
                    delete (CTexture*)m_pObject;
                    break;
                case NVOBJ_VERTEXBUFFER:
                    delete (CVertexBuffer*)m_pObject;
                    break;
                case NVOBJ_COMMANDBUFFER:
                    delete (CCommandBuffer*)m_pObject;
                    break;
                case NVOBJ_PALETTE:
                    delete (CSimpleSurface*)m_pObject;
                    break;
                case NVOBJ_VERTEXSHADER:
                    delete (CVertexShader*)m_pObject;
                    break;
                case NVOBJ_PIXELSHADER:
                    delete (CPixelShader*)m_pObject;
                    break;
                case NVOBJ_CACHEDPATCH:
                    delete (CPatch*)m_pObject;
                    break;
                case NVOBJ_SIMPLESURFACE:
                    delete (CSimpleSurface*)m_pObject;
                    break;
            }
            m_pObject = NULL;
        }

        // remove class information
        m_dwClass = NVOBJ_UNKNOWN;

        if (m_ContextDma) {
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, m_ContextDma);
        }

        // check sanity
#ifdef DEBUG
        if (m_dwRefCount)
        {
            DPF ("CNvObject deleted with non-zero ref count");
        }
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        dbgTestIntegrity();
#endif
        // free from list
        if (m_pPrev) m_pPrev->m_pNext  = m_pNext;
                else global.pNvObjectHead = m_pNext;
        if (m_pNext) m_pNext->m_pPrev  = m_pPrev;
        // check sanity
#ifdef DEBUG
        if (m_pPrev) m_pPrev->dbgTestIntegrity();
        if (m_pNext) m_pNext->dbgTestIntegrity();
        if (global.pNvObjectHead)
        {
            global.pNvObjectHead->dbgTestIntegrity();
        }
        memset (this,0xCC,sizeof(*this));
#endif
    }

    // remove all references to an object prior to deletion
    void clearReferences (void)
    {
        PNVD3DCONTEXT pContext;
        DWORD i;

        switch (getClass()) {
            case NVOBJ_VERTEXBUFFER:
                pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
                while (pContext) {
                    for (i=0; i<NV_CAPS_MAX_STREAMS; i++) {
                        if (pContext->ppDX8Streams[i] == (CVertexBuffer *)m_pObject) {
                            DPF_LEVEL (NVDBG_LEVEL_SURFACEALLOC, "active stream deleted. reference removed");
                            pContext->ppDX8Streams[i] = NULL;
                        }
                    }
                    pContext = pContext->pContextNext;
                }
                break;
            default:
                // nada
                break;
        }  // switch
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPopupList.h ===
#ifndef STEREO_POPUP_LIST_CLASS_DECL
#define STEREO_POPUP_LIST_CLASS_DECL

#include "PopupAgent.h"
#include "duma.h"

///////////////////////////////////////////////////////////
//
// popup flavours
//
///////////////////////////////////////////////////////////
class CPerfStatPopup: public CPopupAgent
{
public:
	CPerfStatPopup();
	virtual ~CPerfStatPopup();
	
};

class CStereoStatPopup: public CPopupAgent, protected STEREOSTATS  
{
public:
	CStereoStatPopup();
	virtual ~CStereoStatPopup();

	void			setContext(NVD3DCONTEXT* aContext); //overloaded: set context and update stereo stats from context
};

///////////////////////////////////////////////////////////
//
// popup controller
//
///////////////////////////////////////////////////////////
class CPopupAgentList
{
public:
//types
    struct PopupHotkeys
    {
        HOTKEY  PopupToggle;
        HOTKEY  FPStoggle;
        HOTKEY  StatsToggle;
    };

protected:
//attributes
	char			strModule[MAX_PATH];
	HMODULE			hMod;
	CPopupAgent*	popupAgentList; //root of the list
    bool            bPerfStat;      //FPS popup enabled/disabled
    bool            bStereoStat;    //Stereo statistics popup enabled/disabled
    bool            isPopupEnabled;
    PopupHotkeys    hotkeys;
//members
    void            add(CPopupAgent* next);
public:
	CPopupAgentList();
	~CPopupAgentList();
	HRESULT			create();
	HRESULT			create(const char* aModule);
	HRESULT			destroy();
    HRESULT         initHotKeys();
    HRESULT         finiHotKeys();
	HRESULT			render(NVD3DCONTEXT *pContext);
    bool&           enabled() {return isPopupEnabled;};
    void            toggle()   {isPopupEnabled = isPopupEnabled?false:true;};
    void            getOptions();
};

extern CPopupAgentList popupAgents;

#endif //STEREO_POPUP_LIST_CLASS_DECL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPalette.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPal.h
//        Prototypes and definitions for nvPallette.cpp
//
//  History:
//        Daniel Rohrer
//
// **************************************************************************
#ifndef _nvPalette_h
#define _nvPalette_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

DWORD __stdcall CreatePalette32(LPDDHAL_CREATEPALETTEDATA lpDDCreatePaletteData);
DWORD __stdcall SetEntries32(LPDDHAL_SETENTRIESDATA lpDDSetEntriesData);
DWORD __stdcall SetPalette32(LPDDHAL_SETPALETTEDATA lpDDSetPaletteData);
DWORD __stdcall DestroyPalette32(LPDDHAL_DESTROYPALETTEDATA lpDDDestroyPaletteData);

DWORD nvSetEntries( DWORD dwPaletteHandle, DWORD dwNumEntries, DWORD dwStartIndex);
DWORD nvSetPalette( DWORD, CNvObject *, CNvObject*);

#endif //__nvPalette_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPatch.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPatch.h
//      description here
//
// **************************************************************************
//
//  History:
//      Daniel ROhrer?          Jul00           DX8 development
//
// **************************************************************************

#ifndef _nvPatch_h
#define _nvPatch_h

#ifdef WINNT
#include "driver.h"
#endif
#include "nvPatchInterface.h"

#define CPATCH_DP2_BUFFER_SIZE 8000
extern NV_PATCH_BACKEND nvCelsiusImm_Backend;
extern NV_PATCH_BACKEND nvKelvinImm_Backend;

//max D3DOrder is 5 so 6x6=36 ctrl pts per patch max here.
// scratch[attribute][u][v][xyzw]

class CPatch {
    private:
        DWORD               m_dwFlags;          //
        DWORD               m_dwHandle;         //cache patch handle
        CNvObject          *m_pWrapperObject;   //

        //copy of pRSInfo data
        DWORD               m_subpatchcount;
        DWORD               m_dwHeight, m_dwWidth, m_dwOrder, m_dwStride;
        DWORD               m_dwVertexOffset;
        NV_PATCH_VERTEX_FORMAT_TYPE m_dwTypes[NV_PATCH_NUMBER_OF_ATTRIBS];

        //cached data ptrs
        FDMatrix            **m00, **m10, **m01, **m11;
        NV_PATCH_FRAC_QUAD_GUARD_INFO **guardQF;
        NV_PATCH_QUAD_INFO       **cachedQuadInfo;
        NV_PATCH_FRAC_TRI_GUARD_INFO  **guardTF;
        //temporary data ptrs -- we need to allocate a patches worth of data then free it at the end.

        NV_PATCH_INFO       m_PatchData;        //patch struct to hand to shared code

        //callback functions
        static NV_PATCH_DRIVER_CALLBACKS m_callbacks;
        static void *alloc         (void *context, size_t bytes);
        static void free           (void *context, void *ptr   );
        static void memcpy         (void *dst, const void *src, size_t size);

        void setStream      (UINT streamID, void *memptr, DWORD stride, DWORD pitch,
                             NV_PATCH_VERTEX_FORMAT_TYPE mt, UINT order);
    public:

        CPatch(CNvObject *pObj,DWORD dwHandle);
        ~CPatch(void);

        void getCachedData  (DWORD subpatch);       //copy the 'nth' subpatch FD ptrs over to m_PatchData for rendering
        void saveCachedData (DWORD subpatch);       //save the 'nth' subpatch FD ptrs from m_PatchData (i.e. cache new data)
        void freeCached();                          //free any cached data members
        BOOL allocCached(DWORD);                    //alloc space for n 'subpatches' worth of FD coeffs/guards.

        void setupStreams   (PNVD3DCONTEXT pContext);

        void copyDataToScratch(PNVD3DCONTEXT,DWORD,DWORD);
        void copyDataToScratchTri(PNVD3DCONTEXT,DWORD,DWORD);
        void convertBsplineToBezier();              //helper routines -- converts patch data inplace
        void convertCatmullRomToBezier();           //helper routines -- converts patch data inplace
        void setBasis       (NV_PATCH_BASIS_TYPE bt)    {m_PatchData.basis = bt; }
        UINT getBasis()                                 {return m_PatchData.basis; }
        NV_PATCH_INFO*      getInfo()                   { return &m_PatchData; }

        void setTessMode    (UINT rf)                   {(rf == NV_PATCH_FLAG_TESS_FRACTIONAL ? m_PatchData.flags |= NV_PATCH_FLAG_TESS_FRACTIONAL : 
                                                                                                m_PatchData.flags &= ~NV_PATCH_FLAG_TESS_MASK);}        
        void setPrimMode    (UINT rf)                   {(rf == NV_PATCH_FLAG_TYPE_TRIANGULAR ? m_PatchData.flags |= NV_PATCH_FLAG_TYPE_TRIANGULAR : 
                                                                                                m_PatchData.flags &= ~NV_PATCH_FLAG_TYPE_MASK);}        
        void setTessellation(float *segs, int flag)     { if((flag & NV_PATCH_FLAG_TYPE_MASK) == NV_PATCH_FLAG_TYPE_TRIANGULAR)
                                                          {  m_PatchData.tess.tri.n1 = segs[1]; 
                                                             m_PatchData.tess.tri.n2 = segs[2]; 
                                                             m_PatchData.tess.tri.n3 = segs[0]; }
                                                          else
                                                          {  m_PatchData.tess.tensor.nu0 = segs[0]; m_PatchData.tess.tensor.nv0 = segs[3]; 
                                                             m_PatchData.tess.tensor.nu1 = segs[2]; m_PatchData.tess.tensor.nv1 = segs[1]; }
                                                        }        
        void setOriginalTessellation(float *segs, int flag){ if((flag & NV_PATCH_FLAG_TYPE_MASK) == NV_PATCH_FLAG_TYPE_TRIANGULAR)
                                                          {  m_PatchData.originaltess.tri.n1 = segs[1]; 
                                                             m_PatchData.originaltess.tri.n2 = segs[2]; 
                                                             m_PatchData.originaltess.tri.n3 = segs[0]; }
                                                          else
                                                          {  m_PatchData.originaltess.tensor.nu0 = segs[0]; m_PatchData.originaltess.tensor.nv0 = segs[3]; 
                                                             m_PatchData.originaltess.tensor.nu1 = segs[2]; m_PatchData.originaltess.tensor.nv1 = segs[1]; }
                                                        }        
       
        //THERE ARE SIDE AFFECTS TO THIS CALL IN REGARDS TO MEMORY ALLOCATION
        void setOutputMode  (NV_PATCH_BACKEND_TYPE rf);
        void prepareBuffer  (long);                     //stream type should be set BEFORE calling this

        void setVertexOffset(DWORD dwOffset)            {m_dwVertexOffset = dwOffset;}
        void setAutoNormal  (UINT dwSrc, UINT dwDst)    {m_PatchData.srcNormal = dwSrc; m_PatchData.dstNormal = dwDst;
                                                         m_PatchData.flags |= NV_PATCH_FLAG_AUTO_NORMAL; }
        void setAutoUV      (UINT dwSrc, UINT dwDst, int i){m_PatchData.srcUV[i] = dwSrc; m_PatchData.dstUV[i] = dwDst;
                                                         m_PatchData.flags |= NV_PATCH_FLAG_AUTO_UV;}
        void  setDimension  (UINT width, UINT height)   {m_dwWidth = width; m_dwHeight = height;}
        UINT  getWidth      ()                          {return m_dwWidth;}
        UINT  getHeight     ()                          {return m_dwHeight;}
        void  setOrder      (DWORD order)               {m_dwOrder = order;}
        DWORD getOrder      ()                          {return m_dwOrder;}
        void  setStride     (DWORD stride)              {m_dwStride = stride;}
        DWORD getStride     ()                          {return m_dwStride;}
        void  setTextureOffsets(float startu, float endu,
                               float startv, float endv){ m_PatchData.startu = startu; m_PatchData.startv = startv;
                                                          m_PatchData.endu   = endu;   m_PatchData.endv   = endv; }

        float getSeg        (UINT i)                    {switch(i){
                                                            case 0: return m_PatchData.tess.tensor.nu0;
                                                            case 1: return m_PatchData.tess.tensor.nv1;
                                                            case 2: return m_PatchData.tess.tensor.nu1;
                                                            case 3: return m_PatchData.tess.tensor.nv0;
                                                            default: return 0;
                                                        }}
        void setCalc        (UINT df)                   {for(int i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++) m_PatchData.maps[i].dirtyFlags = df;}
        UINT getCalc        ()                          {return m_PatchData.maps[0].dirtyFlags;}
        void setContext     (PNVD3DCONTEXT pContext)    {m_PatchData.context = (void*)pContext;}
        void setVertexStride(int size)                  {m_PatchData.vertexSize = size;}
        unsigned char* getCachedPB()                    {return m_PatchData.cachedPB;}
        unsigned long  getCachedPBSize()                {return m_PatchData.cachedPBSize;}
        void           allocCachedPB(unsigned long dwSize){m_PatchData.cachedPB = new unsigned char[dwSize]; 
                                                         m_PatchData.cachedPBSize = dwSize;
                                                         m_PatchData.cachedPBCounter = 0;
                                                        }
        void           freeCachedPB()                   {if(m_PatchData.cachedPB) delete []m_PatchData.cachedPB; 
                                                                                  m_PatchData.cachedPB = NULL;
                                                                                  m_PatchData.cachedPBSize = 0;}        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvObjectLists.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvObjectLists.h                                                   *
*   Routines for management of NvObject lists added in DX7                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe (paulvdk)   3 Mar 2001 created                   *
*                                                                           *
\***************************************************************************/

#ifndef _NVLIST_H_
#define _NVLIST_H_

#ifdef __cplusplus
extern "C" {
#endif
    
PNV_OBJECT_LIST  nvCreateObjectList       (DWORD dwDDLclID, NV_OBJECT_LIST **ppList);
BOOL             nvDeleteObjectList       (DWORD dwDDLclID, NV_OBJECT_LIST **ppList);
PNV_OBJECT_LIST  nvFindObjectList         (DWORD dwDDLclID, NV_OBJECT_LIST **ppList);
CNvObject       *nvGetObjectFromHandle    (DWORD dwDDLclID, DWORD dwHandle, NV_OBJECT_LIST **ppList);
BOOL             nvClearObjectListEntry   (CNvObject *pObj, NV_OBJECT_LIST **ppList);
DWORD            nvAddObjectToList        (PNV_OBJECT_LIST pNvGenObjList, CNvObject *pGenObj, DWORD dwHandle);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPal.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPal.h
//        Prototypes and definitions for nvPallette.cpp
//
//  History:
//        Daniel Rohrer
//
// **************************************************************************

#ifndef __NV_PAL_H_
#define __NV_PAL_H_

PNV_OBJECT_LIST  nvCreatePaletteList            (DWORD dwDDLclID);
BOOL             nvDeletePaletteList            (DWORD dwDDLclID);
BOOL             nvExpandPaletteList            (PNV_OBJECT_LIST pNvPaletteList, DWORD dwHandle);
PNV_OBJECT_LIST  nvFindPaletteList              (DWORD dwDDLclID);
CNvObject       *nvGetPaletteFromHandle         (DWORD dwDDLclID, DWORD dwHandle);
BOOL             nvClearPaletteListEntry        (CNvObject *pObj);
DWORD            nvAddPaletteToList             (PNV_OBJECT_LIST pNvPaletteList, CNvObject *pPal, DWORD dwHandle);

#endif // __NV_PAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvprecomp.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),p
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvprecomp.h
//     headers used frequently by D3D drivers for all architectures.
//     all are included via this file to enable pre-compiling.
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler    (bertrem)   01Mar99     created
//
// **************************************************************************

#ifndef _NVPRECOMP_H
#define _NVPRECOMP_H

#include <math.h>

#include "CompileControl.h"

// include compile-time switches
#include "nvSwitches.h"

// System Stuff
//#include <windows.h>
#include <stdlib.h>
//#include <conio.h>
#ifndef WINNT
    //#include <windows.h>
    //#include <assert.h>
    //#include <wingdi.h>

    #include "ddrawi.h"
    #include "d3dhal.h"
    #include "d3d.h"
    #include "dx95type.h"
    #include "dmemmgr.h"
#else // WINNT
    #define  __NTDDKCOMP__
    //#include <d3dtypes.h>
    //#include <d3d8.h>
    //#include <ddrawint.h>
    #include <devioctl.h>
    //#include <ntddvdeo.h>
#endif

#define D3D_OK S_OK

//#include "ddkmmini.h"
// Shared NV files
#include "nvreg.h"
//#include "nvtypes.h"
//#include "nv32.h"

#ifndef WINNT
    #include "nvwin32.h"
#endif // !WINNT

#include "ddrvmem.h"
#include "nvProcMan.h"
#include "ddmini.h"
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvddobj.h"
#include "nvcm.h"
#include "nvos.h"
#include "nvPriv.h"

#ifdef WINNT
    #include "memstruc.h"
    #include "nvEscDef.h"
    #include "nvntioctl.h"
#endif // WINNT

#include "surfaces.h"
#include "nvstat.h"
#include "escape.h"
#include "nvPM.h"
#include "nvCapture.h"

// Local NV common files
// *** order sensitive ***
#include "d3dConst.h"
#include "nvDMac.h"
#include "nvD3DMac.h"
#include "nvPusher.h"
#include "nvSemaphore.h"
#include "nvFlipper.h"
#include "nvDefVB.h"

#ifdef KPFS
    #include "nvKelvinProgram.h"
#endif

#include "nvContext.h"
#include "nvTranslate.h"
#include "nvSurface.h"
#include "nvLight.h"
#include "nvBlockManager.h"
#include "nvPalette.h"
#include "nvBlit.h"
#include "nvTex.h"
#include "nvTexManage.h"
#include "nvVB.h"
#include "nv4Tables.h"
#include "nvSwiz.h"
#include "nvheap.h"
#include "d3dDebug.h"
#include "nvvxmac.h"
#include "nvtexfmt.h"
#include "nvmocomp.h"
#include "nvEnable.h"
#include "ddFlip.h"
#include "nvClear.h"
#include "ddVideo.h"
#include "DDHal.h"
#include "nvVideoPort.h"
#include "ddSurface.h"
#include "nvLogo.h"
#include "d3dMath.h"
#include "nvBenchmark.h"
#include "nvAccess.h"   //FILE abstraction



#if (NVARCH >= 0x020)
    #include "nvSuperTri.h"
    #ifndef KPFS
    #include "nvKelvinProgram.h"
    #endif
    #include "nvKelvinTables.h"
    #include "nvKelvinState.h"
    #include "nvKelvinStateHelp.h"
    #include "nvKelvinAA.h"
#endif

#if (NVARCH >= 0x010)
    #include "nvCelsiusTables.h"
    #include "nvCelsiusState.h"
    #include "nvCelsiusStateHelp.h"
    #include "nvCelsiusNvTSS.h"
    #include "nvCelsiusAA.h"
#endif // NVARCH >= 0x010

#include "d3dinc.h"
#include "nvVShad.h"
#include "nvPShad.h"
#include "nvdinc.h"
#include "nvproto.h"
#include "global.h"
#include "nvObjectLists.h"
//#include "ddCapture.h"
#include "nvComp.h"
#include "nvDP2Help.h"
#include "nvdp2ops.h"
#include "nvFormats.h"
#include "nvSurf.h"
//#include "nvPal.h"
#include "nvObject.h"
#include "nvRefCount.h"
//#include "nvTimer.h"
#include "nvStereo.h"
//#include "PopupAgent.h"

// DO NOT include x86 in the precompiled headers.  It redefines things that affect some variable
// names and thereby causes hard-to-understand compile problems.
//#include "x86.h"

// preventive logic
#undef GlobalLock
#define GlobalLock      __this_is_an_unsupported_legacy_operation__do_not_use__
#undef GlobalUnlock
#define GlobalUnlock    __this_is_an_unsupported_legacy_operation__do_not_use__

#endif // _NVPRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvPShad.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvPShad_h
#define _nvPShad_h

#ifdef __cplusplus
extern "C"
{
#endif

// Some redefines for my convenience
#define NV_MAPPING_UNSIGNED_IDENTITY  NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY
#define NV_MAPPING_UNSIGNED_INVERT    NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT
#define NV_MAPPING_EXPAND_NORMAL      NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL
#define NV_MAPPING_EXPAND_NEGATE      NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE
#define NV_MAPPING_HALF_BIAS_NORMAL   NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL
#define NV_MAPPING_HALF_BIAS_NEGATE   NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE
#define NV_MAPPING_SIGNED_IDENTITY    NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY
#define NV_MAPPING_SIGNED_NEGATE      NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE


#define NV_REG_ZERO              0x0
#define NV_REG_CONSTANT0         0x1
#define NV_REG_CONSTANT1         0x2
#define NV_REG_FOG               0x3
#define NV_REG_COLOR0            0x4
#define NV_REG_COLOR1            0x5
#define NV_REG_TEXTURE4          0x6
#define NV_REG_TEXTURE5          0x7
#define NV_REG_TEXTURE0          0x8
#define NV_REG_TEXTURE1          0x9
#define NV_REG_TEXTURE2          0xA
#define NV_REG_TEXTURE3          0xB
#define NV_REG_SPARE0            0xC
#define NV_REG_SPARE1            0xD
#define NV_REG_TEXTURE6          0xE
#define NV_REG_TEXTURE7          0xF
#define NV_REG_SPECLIT           0xE
#define NV_REG_EF_PROD           0xF
#define NV_REG_MAX              0x10

#define D3DSP_WRITEMASK_RGBA (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3)
#define D3DSP_WRITEMASK_RGB (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2)
#define D3DSP_WRITEMASK_A (D3DSP_WRITEMASK_3)
#define D3DSP_WRITEMASK_SHIFT 16

#define DRF_SHIFTMASK(x) (DRF_MASK(x) << DRF_SHIFT(x))



// Random constants
#define CELSIUS_COMBINER_STAGES   2
#define KELVIN_COMBINER_STAGES    8
#define PSHAD_MAX_COMBINER_STAGES       8

#if (NVARCH >= 0x020)
#define PSHAD_MAX_SHADER_STAGES         KELVIN_NUM_TEXTURES
#else
#define PSHAD_MAX_SHADER_STAGES         2
#endif

#define PSHAD_MAX_CONSTANTS       NV_CAPS_MAX_PSHADER_CONSTS

#define PSHAD_INSTRUCTION_ARGS DWORD stage, DWORD color, DWORD shift, DWORD sat, DWORD *dst, DWORD *src, DWORD *alpha, DWORD *map

#define PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION 7
#define PSHAD_MAX_DST_ARGS_PER_INSTRUCTION 2

#define PSHAD_COLOR 0
#define PSHAD_ALPHA 1
#define PSHAD_ICW   0
#define PSHAD_OCW   1

#define PSHAD_DEF   0   // Definition instruction
#define PSHAD_INS   1   // Regular instruction
#define PSHAD_TEX   2   // Texture addressing instruction

// For m_dwPixelShaderConstFlags
#define PSHAD_CONST_SIGNED 0x0001
#define PSHAD_CONST_LOCAL  0x0002
#define PSHAD_CONST_STAGE_SHIFT 16
#define PSHAD_CONST_STAGE_MASK  0xf
#define PSHAD_CONST_NUM_SHIFT   20
#define PSHAD_CONST_NUM_MASK  0xf


#define PSHAD_UNUSED 0xdeadbeef


#define D3DSIO_NV_MMA   59
#define D3DSIO_NV_DD    60
#define D3DSIO_NV_MD    61
#define D3DSIO_NV_MM    62
#define D3DSIO_NV_SPF   63


class CPixelShader {
protected:
    // Structure declarations

    struct SConstMapping {
        DWORD dwRegNum;
        DWORD dwMap;
        BOOL  bSigned;
        SConstMapping() { dwRegNum = PSHAD_UNUSED; }
    };

    // Data declarations

    CNvObject                   *m_pWrapperObject;
    DWORD                       m_dwHandle;
    DWORD                       m_dwCodeSize;
    DWORD                       *m_dwCodeData;

    DWORD                       m_dwStage;

	DWORD                       m_cw[PSHAD_MAX_COMBINER_STAGES][2][2];

    DWORD                       m_textureStageSwap;             // Texture stage 0 and 1 have been swapped for Celsius compatibility

    DWORD                       m_shaderStageProgram[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_shaderStageInput[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_shaderStageInputInverse[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_shaderStageInputMapping[PSHAD_MAX_SHADER_STAGES];

    DWORD                       m_dwTextureStage;
    DWORD                       m_celsiusTexStageMapping[PSHAD_MAX_SHADER_STAGES];
    DWORD                       m_texturesUsed;

    D3DCOLORVALUE               m_pixelShaderConsts[PSHAD_MAX_CONSTANTS];
    DWORD                       m_dwPixelShaderConstFlags[PSHAD_MAX_CONSTANTS];

    SConstMapping               m_dwConstMapping[8][2];

    // Method declarations

    DWORD AllocateConstRegister(DWORD dwStage, DWORD dwRegNum, BOOL bSigned, DWORD dwMap);
    DWORD ColorConvertWithMapping(D3DCOLORVALUE color, DWORD dwMap, BOOL *bSigned);

    DWORD DSTdecode(DWORD *dst, DWORD *shift, DWORD *bias, DWORD *mask, DWORD op);
    DWORD SRCdecode(DWORD *src, DWORD *rgbAlpha, DWORD *alphaAlpha, DWORD *map, DWORD op, DWORD mask, BOOL bSignedConst);

    void GetTextureRegMapping(DWORD *newoffset, DWORD offset);
    DWORD GetShaderProgram(PNVD3DCONTEXT pContext, DWORD dwStage);

    DWORD GetRGBMapping(const CTexture *);

    void DBGPrintInstruction(DWORD op, DWORD dstop, DWORD *srcop);

    void SetCombinerInput(DWORD stage, DWORD color, DWORD var, DWORD mapping, DWORD alpha, DWORD src);

    static const DWORD  PSD3DModToNVMap[];
    static const DWORD  NVMapToNVMapInvert[];
    static const DWORD  PSTypeOffsetToCombinerReg[][4];
    static const DWORD  PSInstructionType[];
    static const char * PSInstructionStrings[];
    static const char * PSProgramNames[];
    static const bool   PSShaderUsesTexture[];
    static const int    PSD3DTexToNVShader[][4];
    static const DWORD  PSNumDstRegs[];
    static const DWORD  PSNumSrcRegs[];
    static const bool   PSIsProjective[];
    static void  (CPixelShader::* const PSInstructionLUT[])(PSHAD_INSTRUCTION_ARGS);
    static const char * PSRegTypeToPrefix[];
    static const char * PSWriteMask[];

    // Instructions broken into two groups, pairable and not.  Pairable ones
    // can be doubled up in a single combiner if there are no dependencies, and
    // have an extra parameter ("side") that determines whether the AB or CD
    // half is used.
    // Note: currently, no optimizations are in place that make this distinction.
    // This should change over time.

	// Standard DX8
    void InstructionMOV(PSHAD_INSTRUCTION_ARGS);
    void InstructionMUL(PSHAD_INSTRUCTION_ARGS);
    void InstructionDP3(PSHAD_INSTRUCTION_ARGS);
    void InstructionNOP(PSHAD_INSTRUCTION_ARGS);
    void InstructionADD(PSHAD_INSTRUCTION_ARGS);
    void InstructionSUB(PSHAD_INSTRUCTION_ARGS);
    void InstructionMAD(PSHAD_INSTRUCTION_ARGS);
    void InstructionLRP(PSHAD_INSTRUCTION_ARGS);
    void InstructionCND(PSHAD_INSTRUCTION_ARGS);

	// NVIDIA internal
	void InstructionNV_MMA(PSHAD_INSTRUCTION_ARGS);
	void InstructionNV_DD (PSHAD_INSTRUCTION_ARGS);
	void InstructionNV_MD (PSHAD_INSTRUCTION_ARGS);
	void InstructionNV_MM (PSHAD_INSTRUCTION_ARGS);
    void InstructionNV_SPF(PSHAD_INSTRUCTION_ARGS);

public:

    BOOL create(PNVD3DCONTEXT pContext, DWORD dwHandle, DWORD dwCodeSize, DWORD *lpCode);
    inline DWORD getHandle() const { return m_dwHandle;  }

    BOOL needsTexCoords(DWORD dwStage) { return (m_shaderStageProgram[dwStage] != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE); }

#if (NVARCH >= 0x020)
    void setKelvinState(PNVD3DCONTEXT);
#endif
#if (NVARCH >= 0x010)
    void setCelsiusState(PNVD3DCONTEXT);
#endif

    bool stageUsesTexture(DWORD);
    DWORD isBEM(DWORD);
    DWORD isBEML(DWORD);
    DWORD getNumTexCoords(PNVD3DCONTEXT, DWORD);

    ~CPixelShader(void);
};

#ifdef __cplusplus
}
#endif

#endif // _nvPShad_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvproto.h ===
/*
 * Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV_PROTO.H                                                        *
*       Function Prototypes                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler         11Feb99           created                  *
*                                                                           *
\***************************************************************************/

#ifndef _NVPROTO_H
#define _NVPROTO_H

#ifdef __cplusplus
extern "C" {
#endif

// d3dctxt.cpp
BOOL            nvCreateContextListHeap (GLOBALDATA *pDriverData);
BOOL            nvDestroyContextListHeap (void);
DWORD __stdcall nvContextCreate (LPD3DHAL_CONTEXTCREATEDATA);
DWORD __stdcall nvContextDestroy (LPD3DHAL_CONTEXTDESTROYDATA);
DWORD __stdcall nvContextDestroyAll (LPD3DHAL_CONTEXTDESTROYALLDATA);
void            nvD3DRecover(void);
void            nvDDrawRecover(void);
DWORD __stdcall nvDestroyDDLocal (LPDDHAL_DESTROYDDLOCALDATA);
PNVD3DCONTEXT   nvGetPreapprovedContext(void);
void            nvDestroyPreapprovedContexts(void);

// d3drendr.cpp
#ifndef WINNT  // these calls are obsolete on NT (DX7)
DWORD   __stdcall nvRenderState              (LPD3DHAL_RENDERSTATEDATA);
DWORD   __stdcall nvRenderPrimitive          (LPD3DHAL_RENDERPRIMITIVEDATA);
#endif // !WINNT
DWORD   __stdcall nvSetRenderTarget          (LPD3DHAL_SETRENDERTARGETDATA);
BOOL              nvD3DClearZBuffer          (LPDDRAWI_DDRAWSURFACE_LCL, DWORD, DWORD,DWORD,DWORD,DWORD);
BOOL              nvCheckBufferCompatibility (CSimpleSurface *pRenderTarget, CSimpleSurface *pZetaBuffer,
                                              LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ, DWORD dwDXAppVersion);
DWORD             nvSetRenderTargetDX7       (PNVD3DCONTEXT pContext, DWORD dwTargetHandle, DWORD dwZBufferHandle);

// D3Dmini.cpp
extern BOOL __stdcall D3DHALCreateDriver     (LPD3DHAL_GLOBALDRIVERDATA lpGlobal,
                                              LPD3DHAL_CALLBACKS* lplpHALCallbacks,
                                              LPDDHAL_DDEXEBUFCALLBACKS* lplpBufCallbacks,
                                              GLOBALDATA* pDriverData);
// d3dstate.cpp
DWORD __stdcall nvGetDriverState(LPDDHAL_GETDRIVERSTATEDATA);
#ifndef WINNT  // these calls are obsolete on NT (DX7)
DWORD __stdcall nvGetState(LPD3DHAL_GETSTATEDATA);
#endif

DWORD __stdcall nvTextureCreate  (LPD3DHAL_TEXTURECREATEDATA);
DWORD __stdcall nvTextureDestroy (LPD3DHAL_TEXTUREDESTROYDATA);
DWORD __stdcall nvTextureSwap    (LPD3DHAL_TEXTURESWAPDATA);
DWORD __stdcall nvTextureGetSurf (LPD3DHAL_TEXTUREGETSURFDATA);

// d3dtex.cpp / nvtext.cpp
BOOL  nvPCICreateHeap  (void);
BOOL  nvPCIDestroyHeap (void);
DWORD nvPCIAlloc       (DWORD);
BOOL  nvPCIFree        (DWORD);

// nvAGP.cpp
BOOL  nvAGPCreateHeap   (void);
BOOL  nvAGPDestroyHeap  (void);
void  nvAGPResetHeap    (void);
void  nvAGPInvalidate   (void);
void* nvAGPAlloc        (DWORD dwSize);
DWORD nvAGPGetUserAddr  (DWORD dwAddr);
void  nvAGPFree         (void *pMemory);
void  nvAGPCombine      (void);
void  nvAGPReclaim      (void);
void  nvAGPGetMemory    (DWORD *pdwTotal, DWORD *pdwFree);

// dddrv32.cpp
DWORD __stdcall       GetDriverInfo32           (LPDDHAL_GETDRIVERINFODATA lpData);
DWORD __stdcall       Blit32                    (LPDDHAL_BLTDATA pbd );
DWORD                 WaitForIdle               (BOOL bWait, BOOL bUseEvent);
BOOL                  ResetTwinViewState        (GLOBALDATA *pDriverData);

#ifndef WINNT
void  __stdcall       AddModeToTable            (DDHALMODEINFO *pMode, int nXRes, int nYRes, int nBitsPerPixel);
int   __stdcall       SortDDHalModeList         (void);
DWORD __stdcall       DrawOneIndexedPrimitive32 (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
DWORD __stdcall       DrawOnePrimitive32        (LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD __stdcall       DrawPrimitives32          (LPD3DHAL_DRAWPRIMITIVESDATA);
int                   DrvCallbackFunc           (DWORD dwFunction, void *pIn, void *pOut);
BOOL                  MyExtEscape               (DWORD dwHead, int nEscapeID, int nInBytes, LPCSTR lpIn, int nOutBytes, LPSTR lpOut);
int                   getAdapterIndex           (DISPDRVDIRECTXCOMMON *pNewDXShare, DWORD *pdwRootIndex);
DISPDRVDIRECTXCOMMON* getDXShare                (DWORD dwRootHandle, DWORD dwHeadNumber);
BOOL                  nvFillAdapterTable        (void);
HDC                   nvCreateDCHandle          (DISPDRVDIRECTXCOMMON *pDXS);
void                  nvDestroyDCHandle         (HDC hDC);
DWORD __stdcall		  GetModePitch				(int nXRes, int nYRes, int nBitsPerPixel);
#endif  // !WINNT

// nvCaps.cpp
void  nvSetHardwareCaps (void);

// nvctxt.cpp
BOOL  nvSetSurfaceViewport (PNVD3DCONTEXT);
void  nvRefreshSurfaceInfo (PNVD3DCONTEXT);
BOOL  nvSetupContext       (PNVD3DCONTEXT);
void  nvInitTLData         (PNVD3DCONTEXT pContext);
#if (NVARCH >= 0x010)
void  nvInitCelsiusData    (PNVD3DCONTEXT pContext);
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
void  nvInitKelvinData     (PNVD3DCONTEXT pContext);
#endif  // NVARCH >= 0x020

// nvline.cpp
DWORD nvRenderLine                  (NV_INNERLOOP_ARGLIST);
void  nvDrawLine                    (NV_INNERLOOP_ARGLIST);
void  nvIndexedLine                 (NV_INNERLOOP_ARGLIST);
void  nvIndexedWireframeTriangle    (NV_INNERLOOP_ARGLIST);
void  nvDrawWireframeTriangle       (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawLine                 (NV_INNERLOOP_ARGLIST);
void  nvFVFIndexedLine              (NV_INNERLOOP_ARGLIST);
void  nvFVFIndexedWireframeTriangle (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawWireframeTriangle    (NV_INNERLOOP_ARGLIST);

// nvmini.cpp
void  D3DReadRegistry       (GLOBALDATA *pDriverData);
void  D3DModifyCapabilities (D3DHAL_GLOBALDRIVERDATA *pNvGlobal, GLOBALDATA *pDriverData);
BOOL  CreateItemArrays      (GLOBALDATA *pDriverData);
HKEY  OpenLocalD3DRegKey    (void);

BOOL nvReadRegistryDWORD (
#ifdef WINNT
    PDEV   *pDev,
#else
    HKEY    hKey,
#endif
    LPCTSTR lpValueName,
    LPDWORD lpData
);

// nvpoint.cpp
DWORD nvRenderPoint             (NV_INNERLOOP_ARGLIST);
void  nvDrawPointList           (NV_INNERLOOP_ARGLIST);
void  nvIndexedPointTriangle    (NV_INNERLOOP_ARGLIST);
void  nvDrawPointTriangle       (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawPointList        (NV_INNERLOOP_ARGLIST);
void  nvFVFIndexedPointTriangle (NV_INNERLOOP_ARGLIST);
void  nvFVFDrawPointTriangle    (NV_INNERLOOP_ARGLIST);

// nvprim.cpp
#ifndef WINNT
DWORD nvDrawOnePrimitive        (LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD nvDrawPrimitives          (LPD3DHAL_DRAWPRIMITIVESDATA);
DWORD nvDrawOneIndexedPrimitive (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
#endif  // !WINNT

// nvPatch.cpp
DWORD nvDrawRectSurface (PNVD3DCONTEXT pContext, DWORD dwHandle,
                         float *pfSegs, D3DRECTPATCH_INFO *pRSInfo);
DWORD nvDrawTriSurface  (PNVD3DCONTEXT pContext, DWORD dwHandle,
                         float *pfSegs, D3DTRIPATCH_INFO *pRSInfo);

// nvprim2.cpp
DWORD __stdcall nvDrawPrimitives2 (LPD3DHAL_DRAWPRIMITIVES2DATA);

// nvprof.cpp
#ifdef __cplusplus
extern "C" {
#endif
#ifdef WINNT
BOOL  __stdcall nvDeterminePerformanceStrategy (GLOBALDATA *pDriverData, PDEV* ppdev);
#else // !WINNT
BOOL  __stdcall nvDeterminePerformanceStrategy (GLOBALDATA *pDriverData);
#endif // !WINNT
void nvDetermineEarlyCopyStrategy(PNVD3DCONTEXT pContext);
#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef NV_PROFILE
void nvpCreate   (void);
void nvpDestroy  (void);
void nvpFlush    (void);
void nvpLogEvent (DWORD id);
void nvpLogCount (DWORD id,int count);
void nvpLogTime  (DWORD id,__int64 time);
void nvpSetLogPusher(bool log);
bool nvpGetLogPusher();
#endif  // NV_PROFILE

// nvscene.cpp
DWORD __stdcall nvSceneCapture (LPD3DHAL_SCENECAPTUREDATA);

// nvstate.cpp
DWORD            CTFunc                         (PNVD3DCONTEXT pContext, DWORD dw);
BOOL             nvStencilBufferExists          (PNVD3DCONTEXT pContext);
DWORD            nvTranslateLODBias             (DWORD);
void             nvSetD3DSurfaceState           (PNVD3DCONTEXT);
void             nvSetD3DSurfaceViewport        (PNVD3DCONTEXT);
void             nvSetDx5TriangleState          (PNVD3DCONTEXT);
DWORD            nvSetContextState              (PNVD3DCONTEXT pContext, DWORD, DWORD, HRESULT *);
BOOL             nvSetHardwareState             (PNVD3DCONTEXT pContext);
void             nvSetDx6MultiTextureState      (PNVD3DCONTEXT);
DWORD FAR PASCAL nvValidateTextureStageState    (LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
void             nvSetMultiTextureHardwareState (PNVD3DCONTEXT pContext);
void             cacheFogValues                 (PNVD3DCONTEXT pContext);

// nvstateset.cpp
#ifdef DEBUG
void    recordDebugMarker   (PNVD3DCONTEXT pContext);
#else
#define recordDebugMarker(a)
#endif
HRESULT recordState         (PNVD3DCONTEXT pContext, LPBYTE, DWORD);
HRESULT recordLastStateOnly (PNVD3DCONTEXT pContext, LPD3DHAL_DP2COMMAND, DWORD);
HRESULT stateSetBegin       (PNVD3DCONTEXT, DWORD);
HRESULT stateSetEnd         (PNVD3DCONTEXT);
HRESULT stateSetExecute     (PNVD3DCONTEXT, DWORD);
HRESULT stateSetCapture     (PNVD3DCONTEXT, DWORD);
HRESULT stateSetCreate      (PNVD3DCONTEXT, DWORD, D3DSTATEBLOCKTYPE);
HRESULT stateSetDelete      (PNVD3DCONTEXT, DWORD);

// nvtri.cpp
DWORD   nvRenderNoOp     (NV_INNERLOOP_ARGLIST);
DWORD   nvRenderTriangle (NV_INNERLOOP_ARGLIST);

// nvlight.cpp
HRESULT nvLightSetLight  (nvLight *, LPD3DLIGHT7);
void    nvLightEnable    (nvLight *, nvLight **);
void    nvLightDisable   (nvLight *, nvLight **);
HRESULT nvGrowLightArray (PNVD3DCONTEXT, DWORD);
BOOL    nvLightIsEnabled (nvLight *);
BOOL    nvLightIsDefined (nvLight *);

// nvRZ.cpp
BOOL            rzDetectCachingCapabilities (void);
BOOL  __stdcall rzSetAGPMTRR                (DWORD dwPhysBase,DWORD dwType);
DWORD           rzMapPhysicalToLinear       (DWORD dwPhysBase,DWORD dwLength);
BOOL            rzSetPATIndices             (DWORD dwStart,DWORD dwCount,DWORD dwValue);

#if (NVARCH >= 0x010)

// nvCelsiusAlphaCombiner.cpp
void    SetAlphaInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, BOOL bNegate);
HRESULT SelectAlphaInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal);
void    ConstructAlphaCombiners (PNVD3DCONTEXT pContext, int, int, BOOL);
void    ConstructOutputAlphaCombiners (PNVD3DCONTEXT pContext, int, int, int, int, int);

// nvCelsiusColorCombiner.cpp
void    SetColorMapping  (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwMapping);
void    SetColorInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, BOOL bNegate);
HRESULT SelectColorInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate);
BOOL    ConstructColorCombiners (PNVD3DCONTEXT pContext, int, int);
void    ConstructOutputColorCombiners (PNVD3DCONTEXT pContext, int, int, int, int, int, int, int);

// nvCelsiusPrim.cpp
void    nvCelsiusDispatchNonIndexedPrimitive      (NV_INNERLOOP_ARGLIST);
void    nvCelsiusDispatchIndexedPrimitive         (NV_INNERLOOP_ARGLIST);
void    nvCelsiusDispatchLegacyWireframePrimitive (NV_INNERLOOP_ARGLIST);

#endif  // NVARCH == 0x010

#if (NVARCH >= 0x020)
// nvKelvinAlphaCombiners.cpp
void    nvConstructKelvinAlphaCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwDXStage, BOOL bStageActive);
void    nvConstructKelvinOutputAlphaCombiners (PNVD3DCONTEXT pContext, BOOL bEnable,
                                               DWORD dwHWStage, DWORD dwDXStage,
                                               BOOL bBias, DWORD dwShift, BOOL bOutTemp);

// nvKelvinColorCombiners.cpp
BOOL    nvConstructKelvinColorCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwDXStage);
void    nvConstructKelvinOutputColorCombiners (PNVD3DCONTEXT pContext, BOOL bEnable, DWORD dwStage,
                                               BOOL bBias, DWORD dwShift, BOOL bDotAB, BOOL bDotCD, BOOL bOutTemp);

// nvKelvinPrim.cpp
void    nvKelvinDispatchNonIndexedPrimitive      (NV_INNERLOOP_ARGLIST);
void    nvKelvinDispatchIndexedPrimitive         (NV_INNERLOOP_ARGLIST);
void    nvKelvinDispatchLegacyWireframePrimitive (NV_INNERLOOP_ARGLIST);

#endif

// nvpkrnl.c (nvpe.lib)
#ifdef NVPE
void  __stdcall NVPInitialState(GLOBALDATA *pDriverData);
BOOL  __stdcall NVPIsVPEEnabled(GLOBALDATA *pDriverData, DWORD hDriver);
DWORD __stdcall NVPCleanUp(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
DWORD __stdcall NVPUpdateOverlay(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
#endif // NVPE

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _NVPROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvStereo.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: Stereo.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/08/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_H_
#define _STEREO_H_

#ifdef  STEREO_SUPPORT

#define LASER_SIGHT
#define SNAP_SHOT

#ifdef	DEBUG
#define	STEREO_DEBUG
#else
#ifdef	DEVELOP
#define	STEREO_DEBUG
#endif
#endif

#include <nvRmStereo.h>
#include "duma.h"
#include "StereoDDK.h"

#define UPTODATE_STEREO_SUPPORT (SVF_OVERANDUNDER | SVF_FRAMESEQUENTIAL)

//Eye's IDs.
#define EYE_NONE  0
#define EYE_LEFT  1
#define EYE_RIGHT 2
#define EYE_COUNT EYE_RIGHT+1

#define DEFAULT_STEREO_SEPARATION               0.08f
#define DEFAULT_STEREO_CONVERGENCE              4.0f
#define DEFAULT_STEREO_CONVERGENCE_MULTIPLIER   5.0f
#define CONVERGENCE_THRESHOLD                   0.01f

//FrustumAdjustMode values
#define NO_FRUSTUM_ADJUST                   0
#define FRUSTUM_STRETCH                     1
#define FRUSTUM_CLEAR_EDGES                 2

//PartialClearMode values
#define DO_AS_REQUESTED                     0
#define DO_A_FULL_CLEAR                     1
#define DO_NOTHING                          2

//Possible bit values in the pStereoData->dwFlags.
#define STEREO_PROJECTIONMATRIXVALID        0x00000001
#define STEREO_LOCKCACHEABLE                0x00000002
#define STEREO_FORCEDOFF                    0x00000004
#define STEREO_FORCEDTOGDI                  0x00000008
#define STEREO_LOCKACTIVE                   0x00000010
#define STEREO_LOCKINIT                     0x00000020
#define STEREO_RHWGREATERATSCREEN           0x00000040
#define STEREO_RHWEQUALATSCREEN             0x00000080
#define STEREO_RHWLESSATSCREEN              0x00000100
#define STEREO_DISALLOWED_NOT_FULL_SCREEN   0x00000200
#define STEREO_DISALLOWED_NO_RESOURCES      0x00000400
#define STEREO_DISALLOWED                   0x00000600
#define STEREO_AUTOCONVERGENCE              0x00000800
#define STEREO_DISABLETnL                   0x00001000
#define STEREO_RIGHTEYEINIT                 0x00002000
#define STEREO_FAVORSZOVERRHW               0x00004000
#define STEREO_LASERSIGHT                   0x00008000
#define STEREO_LASERGETRHWSCALE             0x00010000
#define STEREO_CLEAROCCURED                 0x00020000
#define STEREO_DEFAULTON                    0x00040000
#define STEREO_CONVERGENCE                  0x00080000
#define STEREO_CONVERGENCEMULTIPLIER        0x00100000
#define STEREO_SEPARATION                   0x00200000
#define STEREO_LASERSIGHTENABLED            0x00400000
#define STEREO_ANAGLYPH                     0x00800000
#define STEREO_GAMMACORRECTION              0x01000000
#define STEREO_MIXEDTNLS					0x02000000

#define STEREO_CUSTOMSETTINGSMASK           (STEREO_RHWGREATERATSCREEN|STEREO_RHWEQUALATSCREEN|STEREO_RHWLESSATSCREEN|STEREO_AUTOCONVERGENCE|STEREO_CONVERGENCE|STEREO_CONVERGENCEMULTIPLIER|STEREO_SEPARATION|STEREO_FAVORSZOVERRHW)      

#define STEREO_LOG_DIRECTORY		        "C:\\NVSTEREO.LOG"
#define STEREO_IMG_DIRECTORY		        "C:\\NVSTEREO.IMG"

#ifdef  LASER_SIGHT_
typedef unsigned short* (__cdecl *GetLaserSightType)    (DWORD &dwWidth, DWORD &dwHeight, COLORREF &crRef, DWORD &dwTransparency);	
typedef void            (__cdecl *ReleaseLaserSightType)(unsigned short *pusData);
#endif  //LASER_SIGHT
#ifdef  LASER_SIGHT
typedef unsigned short* (__cdecl *GetLaserSight)    (DWORD &dwWidth, DWORD &dwHeight, DWORD &dwColorKey);	
typedef void            (__cdecl *ReleaseLaserSight)(unsigned short *pusData);
#endif  //LASER_SIGHT

typedef struct _per_vertex_storage_Flip
{
    LPD3DVALUE      pVertex;
    D3DVALUE        OrigX;
    D3DVALUE        XCorrection;
} PERVERTEXSTORAGE_FLIP, *LPPERVERTEXSTORAGE_FLIP;

/*****************************************************************************
 * CVertexRegister
 * This class is used to determine which vertices are unique in a list. Required when we modify
 * post-transformed vertices for the left and right eyes.
 */
class CVertexRegister
{
    /*
     * constants
     */
public:
    enum
    {   //m_dwStage possible values.
        FIRST_EYE           = 0,
        SECOND_EYE          = 1,
        RESTORE             = 2,
    };
    /*
     * members
     */
protected:
    LPBYTE                  m_pInUse;
    DWORD                   m_dwInUseSize;
    LPPERVERTEXSTORAGE_FLIP m_VertexStorage_Flip;
    DWORD                   m_dwVertexCount;
    DWORD                   m_dwStage; // 0 - first eye, 1 - second eye, 2 - restore

    /*
     * methods
     */
public:
    inline void cleanupInUse(void)
    {
        memset ((LPVOID)m_pInUse, 0, m_dwInUseSize);
        //Pleeease don't touch m_dwStage. It lives its own life.
    }
    BOOL isInUse(DWORD dwVertex);
    BOOL isInUseTag(DWORD dwVertex);
    inline void UpdateStage(void)
    {
        if (++m_dwStage > RESTORE)
            m_dwStage = FIRST_EYE;
    }
    inline void SaveX(LPD3DVALUE pX)
    {
        m_VertexStorage_Flip[m_dwVertexCount].pVertex  = pX;
        m_VertexStorage_Flip[m_dwVertexCount].OrigX    = pX[0];
    }
    inline void SaveXCorrection_Flip(D3DVALUE XCorrection)
    {
        m_VertexStorage_Flip[m_dwVertexCount].XCorrection  = XCorrection;
        m_dwVertexCount++;
    }
    //Next functions' behaviour is based on the current stage. If stage is FIRST_EYE the function does nothing
    //and report that. The caller is responsible to fill out the m_pVertexData and next time the DoAutomaticStage
    //will take care of everything automatically.
    DWORD   DoAutomaticStage_Flip(void);

    /*
     * construction
     */
public:
    CVertexRegister (DWORD dwNumVertices);
    ~CVertexRegister (void);
};

#define	STEREO_CONFIG_ASSIST
#ifdef	STEREO_CONFIG_ASSIST
typedef struct _CONFIG_ASSIST_INFO
{
    HOTKEY      SuggestKey;
    HOTKEY      UnsuggestKey;
    HOTKEY      WriteKey;
    HOTKEY      DeleteKey;
    HOTKEY      FrustumAdjust;
    HOTKEY      ToggleAutoConvergence;
    HOTKEY      ToggleAutoConvergenceRestore;
    HOTKEY      RHWAtScreenMore;
    HOTKEY      RHWAtScreenLess;
    HOTKEY      RHWLessAtScreenMore;
    HOTKEY      RHWLessAtScreenLess;
    HOTKEY      LaserXPlusKey;
    HOTKEY      LaserXMinusKey;
    HOTKEY      LaserYPlusKey;
    HOTKEY      LaserYMinusKey;
    HOTKEY      GammaAdjustMore;
    HOTKEY      GammaAdjustLess;
    DWORD       dwFlags;

    D3DVALUE    rhwMin;
    D3DVALUE    rhwMax;
    D3DVALUE    rhwMin2D;
    D3DVALUE    rhwMax2D;
    D3DVALUE    szMin;
    D3DVALUE    szMax;
    D3DVALUE    szMin2D;
    D3DVALUE    szMax2D;

    D3DVALUE    fLastNonAutoConvergenceMultiplier;
    HANDLE      FileHandle;
    char        Buf[1024];
} CONFIG_ASSIST_INFO;
#endif //STEREO_CONFIG_ASSIST

typedef struct _STEREOSETTINGS {
    DWORD               dwFlags;
    float               fStereoSeparation;      //Half way horizontal separation if screen width is 1.0 (0.04).
    float               fScreenStereoSeparation;//Half way horizontal separation in pixels based on mode.
    float               fStereoConvergence;     //Convergence degree (in the range [0.0 - 0.15]).
    float               fPostStereoConvergence; //Convergence degree for post-transform (game specific).
    float               fPostStereoXStretch;    //Stretching of the field of view for post-transform.
    float               fPostStereoXShift;      //Shifting of the field of view for post-transform.
    float               fRHWGreaterAtScreen;    //All objects closer than this are considered to be 2D.
    float               fRHWLessAtScreen;       //All objects farther than this are considered to be 2D.
    float               fConvergenceMultiplier; //fPostStereoConvergence = fStereoConvergence*fConvergenceMultiplier
    DWORD               FrustumAdjustMode;      //Tells how to adjust frustum for possible lack of X information after eye shift.
    DWORD               PartialClearMode;       //Tells how to do a partial clear (as is, replace with a full screen clear or ignore).
    float               AutoConvergenceAdjustPace;
    float               fStereoGamma;
#ifdef  LASER_SIGHT
    float               fLaserXAdjust;
    float               fLaserYAdjust;
#endif  //LASER_SIGHT
} STEREOSETTINGS, *LPSTEREOSETTINGS;

typedef struct _STEREOHOKEYS {
    LPCHOTKEYINTERFACE  pHotKeyI;
    HOTKEY              StereoToggle;
    HOTKEY              StereoSeparationAdjustMore;
    HOTKEY              StereoSeparationAdjustLess;
    HOTKEY              StereoConvergenceAdjustMore;
    HOTKEY              StereoConvergenceAdjustLess;
} STEREOHOKEYS, *LPSTEREOHOKEYS;

typedef struct _STEREOEYE {
    D3DHAL_DP2VIEWPORTINFO  Viewport;               //Eye viewport
    D3DMATRIX               ProjMatrix;             //Eye projection matrix
} STEREOEYE, *LPSTEREOEYE;

typedef struct _STEREODATA {
    STEREOSETTINGS          StereoSettings;
    BOOL                    bStereoActivated;       //Stereo is currently activated.
    DWORD                   dwHWTnL;                //Total amount of currently allocated non transformed VBs.
    BYTE                    StereoViewerName[128];  //Stereo viewer driver name.
#ifdef  LASER_SIGHT
    BYTE                    LaserSightFile[128];    //Stereo laser sight file name.
#endif  //LASER_SIGHT
    DWORD                   dwStereoVideoMode;      //Current video mode used for stereo.
#ifdef  STEREO_VIEWER_DRV
    STEREOCAPS              StereoViewerCaps;       //Stereo viewer capabilities.
    DWORD                   dwStereoFormat;         //Method of displaying stereo.
    LPSTEREOVIEWER          pStereoViewer;          //Pointer to stereo viewer object
    HMODULE                 hStereoDrv;             //Stereo viewer driver handle.
#else   //STEREO_VIEWER_DRV==0
    DWORD                   dwStereoHWType;         //Stereo Viewer HW type.
    DWORD                   dwLineCodeColor;
	DWORD					dwLeftAnaglyphFilter;
	DWORD					dwRightAnaglyphFilter;
#endif  //STEREO_VIEWER_DRV
    float                   fFrameRHWMax;           //Closes vertex RHW for a scene.
    float                   fRHW2DDetectionMin;     //RHW far limit for 2D object detection.
    DWORD                   dwLastEye;              //The eye representing the current stereo context.
    PNVD3DCONTEXT           dwContext;
    DWORD                   StereoModeNumber;       //Video mode for which stereo had been activated
    DWORD                   dwVertexRegisterSize;   //Max # of vertices we accept.
    CVertexRegister        *pVertexRegister;        //Pointer to an object used to modify post-transformed vertices.
    LPDDRAWI_DDRAWSURFACE_LCL pLockSubstituteLcl;   //Lock substitute local for emulating front-back-z locks.
    CSimpleSurface         *pLastLockedSurface;
    LPDDRAWI_DDRAWSURFACE_LCL pLockTargetLcl;       //Our fake persistent Lcl for delayed lock processing
    DWORD                   dwSurfaceCount;         //# of stereo surfaces
    char                    bAppName[128];          //Current application name returned by GetCommandLine (might be bogus).
    char                    bAppRealName[128];      //Current application name retreived from the bAppName (if not a symbolic link).
    WORD                    SaveCurrentGamma[256*3];
    CSimpleSurface         *pRenderTargets[3];      
    NV_CFG_STEREO_PARAMS    RmStereoParams;         //Shared structure between D3D driver & resman for flipped stereo.
    STEREOHOKEYS            StereoKeys;             //Stereo control hotkeys.
    STEREOEYE               Eye[EYE_COUNT];         //Eye specific stereo data
} STEREODATA, *LPSTEREODATA;

typedef struct StereoBltPassInfo
{
    union {
        DWORD   dwDstOffset;
        DWORD   dwDstY;
        FLATPTR fpDstVidMem;
        LONG    lTop;
    };
    union {
        DWORD   dwSrcOffset;
        DWORD   dwSrcY;
        FLATPTR fpSrcVidMem;
        LONG    lBottom;
    };
    DWORD   dwPass;
} STEREOBLTPASSINFO, *LPSTEREOBLTPASSINFO;

typedef DWORD (*PSTEREOEYEFUNC)(PNVD3DCONTEXT pContext, LPBYTE pVertices, DWORD dwCount);
typedef DWORD (*PSTEREOEYEFUNCINDEX)(PNVD3DCONTEXT pContext, LPBYTE pVertices, LPBYTE pIndices, DWORD dwCount);
typedef BOOL  (*PSTEREORHWFUNC)(PNVD3DCONTEXT pContext, LPBYTE pVertices, DWORD dwCount, DWORD dwCondition);
typedef BOOL  (*PSTEREORHWFUNCINDEX)(PNVD3DCONTEXT pContext, LPBYTE pVertices, LPBYTE pIndices, DWORD dwCount, DWORD dwCondition);

extern  void                        LoadStereoRegistry(void);
extern  void                        StereoAdjustmentMonitor(PNVD3DCONTEXT pContext);
extern  void                        StereoContextCreate(void);
extern  void                        StereoContextDestroy(PNVD3DCONTEXT pContext);
extern  void                        DestroyStereo(void);
extern  LPD3DMATRIX                 SetStereoProjection(LPD3DMATRIX pMat, PNVD3DCONTEXT pContext);
extern  void                        SetupStereoContext(PNVD3DCONTEXT pContext);
extern  void                        AlternateStereoContext(PNVD3DCONTEXT pContext);
extern  DWORD                       GetStereoOffset(CSimpleSurface *pSurf);
extern  DWORD                       StereoBltAdjustParameters(SURFINFO &src, SURFINFO &dst, STEREOBLTPASSINFO &StereoBltPass);
extern  BOOL                        CreateLockSubstitute(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);
extern  BOOL                        StereoLockSubstitute(LPDDHAL_LOCKDATA lpLockData);
extern  BOOL                        StereoLockSubstituteRestore(LPDDHAL_UNLOCKDATA lpUnlockData);
extern  BOOL                        StereoLockSubstituteFlush(void);
extern  void                        StereoFlipNotify(LPDDHAL_FLIPDATA pfd);
extern  void                        StereoModeSetProcessing(void);
extern  void                        StereoModifyDDHALInfo(void);
extern  void                        StereoBackend(LPDDHAL_FLIPDATA pfd);
extern  void __cdecl                LOG(char * szFormat, ...);

#ifdef  PER_PRIMITIVE_SYNC
extern  void						StereoSync(void);
#endif	//PER_PRIMITIVE_SYNC

#ifdef  LASER_SIGHT
//extern  void                        ClearLaserSight(PNVD3DCONTEXT pContext);
#endif  //LASER_SIGHT

extern  LPSTEREODATA                pStereoData;
extern  nvDP2FunctionTable nvDP2SetFuncs_Stereo_Flip;
extern  nvDP2FunctionTable nvDP2SetFuncs_Orig;

#define NvSetStereoDataPtrFromDriverData  pStereoData=(LPSTEREODATA)pDriverData->pStereoData;

#define STEREO_ENABLED              (pStereoData) //Stereo can be potentially activated.
#define STEREO_ACTIVATED            (STEREO_ENABLED && pStereoData->bStereoActivated)
#define ORIG_VIEWPORT               (pStereoData->Eye[EYE_NONE].Viewport)
#define ORIG_PROJECTION             (pStereoData->Eye[EYE_NONE].ProjMatrix)
#define STEREO_R_US(pCtxt)          (pStereoData->dwContext==pCtxt) // BUGBUG remove me eventually
#define STEREODATA(field)           pStereoData->field

#define CREATESTEREOHOTKEY(HotKey)  CREATEHOTKEY(pStereoData->StereoKeys.pHotKeyI,HotKey)
#define DESTROYSTEREOHOTKEY(HotKey) DESTROYHOTKEY(pStereoData->StereoKeys.pHotKeyI,HotKey)
#define POLLSTEREOHOTKEY(HotKey)    POLLHOTKEY(pStereoData->StereoKeys.pHotKeyI,HotKey)
#define ENFORCEKEYBOARDFILTER()     ENFORCEFILTER(pStereoData->StereoKeys.pHotKeyI)

/*********************************************************************************************************/

#else  // !STEREO_SUPPORT

#define NvSetStereoDataPtrFromDriverData

/*********************************************************************************************************/

#endif  // !STEREO_SUPPORT

#endif  //_STEREO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\NVSTAT.h ===
/////////////////////////////////
// Header file for NVSTAT.VxD
// FileName: NVSTAT.h - created by VxDWriter

#ifndef _NVSTAT_H
#define _NVSTAT_H

#define  NVSTAT_MAJOR_VER      1	// Major version No. of VxD
#define  NVSTAT_MINOR_VER      7    // Minor version No. of VxD
#define  NVSTAT_DEVICE_ID      0x3FD5	// Device ID for this VxD
#define  NVSTAT_INIT_ORDER     UNDEFINED_INIT_ORDER	// Initialization order

enum NVSTATIOCTLS {
// WIN95 device IO Control's are +1
#ifdef _VXDLIB_H
		GETVERSION = 0,
#else
		GETVERSION = 1,
#endif
		STARTCAPTURE,
		ENDCAPTURE,
		SETCONFIGURATION,
		GETCONFIGURATION,
		SETRING3CALLBACK,		// callback when pageflip/blt happens.
		CLEARSTATISTICS,
		INITUSERMEMORY			// has to be done in context of application
};

#ifndef NVSTATNT_IOCTL
#define NVSTATNT_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_NVSTATNT, _index_, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define IOCTL_NVSTATNT_GETVERSION					NVSTATNT_IOCTL (GETVERSION)
#define IOCTL_NVSTATNT_STARTCAPTURE					NVSTATNT_IOCTL (STARTCAPTURE)
#define IOCTL_NVSTATNT_ENDCAPTURE					NVSTATNT_IOCTL (ENDCAPTURE)
#define IOCTL_NVSTATNT_SETCONFIGURATION				NVSTATNT_IOCTL (SETCONFIGURATION)
#define IOCTL_NVSTATNT_GETCONFIGURATION				NVSTATNT_IOCTL (GETCONFIGURATION)
#define IOCTL_NVSTATNT_SETRING3CALLBACK				NVSTATNT_IOCTL (SETRING3CALLBACK)
#define IOCTL_NVSTATNT_CLEARSTATISTICS				NVSTATNT_IOCTL (CLEARSTATISTICS)
#define IOCTL_NVSTATNT_INITUSERMEMORY				NVSTATNT_IOCTL (INITUSERMEMORY)

#define DRIVER_DEVICE_NAME L"NVSTAT"
#define FILE_DEVICE_NVSTATNT  0x00008400


#define	CTRLHOTKEY	(1 << 16)
#define ALTHOTKEY	(2 << 16)
#define SHIFTHOTKEY (4 << 16)

typedef enum FRAMEENDTYPE
{
	FEFLIP = 0,
	FEBEGINEND,
	FEBLIT
} FRAMEENDTYPE;

typedef enum VERTFLAGS
{
	VERTSBMASK = 1,
	VERTSNORMALMASK = 2,
	VERTSUSERUV1 = 4,
	VERTSUSERUV0 = 8,
	VERTSSPECULAR = 16,
	VERTSDIFFUSE = 32,
	VERTSXYZ = 64,
	VERTSRHW = 128
} VERTFLAGS;

#pragma pack(push,1)
typedef struct NVSTATCNF
{
	DWORD captureSize;			// capture size in bytes/ this is static
	void *captureMem;
	DWORD logSize;				// how big the memory log size is (4k chunks)
	void *logMem;				// pointer to log memory
	DWORD logHead;				// header of log buffer for wrap mode
	DWORD logTail;				// tail of log buffer for wrap mode
	DWORD logFormat;			// 0 = off, 1 = minimal, 2 = maximum (everything)
	DWORD  logFull;				// flag when circular buffer is full
	DWORD logMissed;			// number of dwords missed while log is full
	DWORD hotKey;				// LOWWORD = scan code/ HIWORD(CTRLHOTKEY | ALTHOTKEY | SHIFTHOTKEY)
	FRAMEENDTYPE fEndType;		// how to capture/ flips/blts - Begin Scene/End Scene pair
	DWORD startFrame;			// starting Frame to capture
	DWORD endFrame;				// ending frame to capture
	DWORD frameRangeEnable;
} NVSTATCNF;
#pragma pack(pop)

#include "statdef.h"

#ifndef NVSTATDRIVER
#include "basetyps.h"
#include "d3d8types.h"
#define D3D_RENDERSTATE_MAX     D3DRS_BLENDOP
#define D3D_TEXSTAGESTATE_MAX   D3DTSS_RESULTARG
#else
// include this earlier, so we can redefine dbgTracePush
#include "nvDbg.h"
#include "d3dconst.h"
#endif

#define D3D_NUM_RENDERSTATES	(D3D_RENDERSTATE_MAX+1)
#define D3D_NUM_TEXSTAGESTATES	(D3D_TEXSTAGESTATE_MAX+1)

#define DXNUMFUNCTIONS (STAT_NUM_FUNCTIONS+D3D_NUM_RENDERSTATES+D3D_NUM_TEXSTAGESTATES)

#define START_RENDER_STATE (STAT_NUM_FUNCTIONS)
#define END_RENDER_STATE (STAT_NUM_FUNCTIONS+(D3D_NUM_RENDERSTATES))

#define D3D_LOG_PARAMETERS	0x8000					// bit to set for parameters

enum {
	D3D_LOG_ERROR = DXNUMFUNCTIONS | D3D_LOG_PARAMETERS,
	D3D_LOG_PERFORMANCE,
	D3D_LOG_DX6_PRIMITIVES,
	D3D_LOG_DX5_PRIMITIVES,
	D3D_LOG_DX7_PRIMITIVES,
	D3D_LOG_DX8_PRIMITIVES,
	D3D_LOG_FRAME_END,
	D3D_PRIM_COUNT_PARMS,
	D3D_LOG_LOCK_INDEX
};

typedef enum LOGFORMATBITS
{
	LOG_NONE_BIT = 0,							// no bits set
	LOG_MINIMUM_BIT = 1,
	LOG_MEDIUM_BIT = 2,
	LOG_MAXIMUM_BIT = 4,
	LOG_PERFORMANCE_BIT = 8
} LOGFORMATBITS;

#pragma pack(push,1)
//
// ---- structure for static clock tick counters
//
typedef struct NVDXTICK
{
	DWORD captureOn;							// 0 = No Capture, >= 1 if lock count
	FRAMEENDTYPE fEndType;						// how to capture/ flips/blts - Begin Scene/End Scene pair
	DWORD frameRangeEnable;						// whether to capture between frames
	DWORD startFrame;							// which frame to turn on the capture
	DWORD endFrame;								// when to turn off the capture
	DWORD FRCount;								// incremented hit count for range of frames
	DWORD tickCount;							// Timer tick count for this frame
	DWORD curFrame;								// current frame count for direct draw
	DWORD logSize;								// how big the memory log size is (4k chunks)
	DWORD logHead;								// header of log buffer for wrap mode
	DWORD logTail;								// tail of log buffer for wrap mode
	DWORD logFormat;
	void *logMem;								// pointer to log memory, can change so this variable is duplicated
	void *userLogMem;							// user memory in case different from kernel memory
	DWORD  logFull;								// flag when circular buffer is full
	DWORD logMissed;							    // number of dwords missed while log is full
	__int64 DXAdditiveTick[DXNUMFUNCTIONS];	// all the ticks for the capture
	DWORD DXHits[DXNUMFUNCTIONS];				// number of hits for this function
} NVDXTICK;
#pragma pack(pop)

#define SCAN_SYSREQ     0x54	// default scan-code
#define VK_SYSREQ		0x2c	// windows NT uses VK Codes.
#define SCAN_BREAK		0		// ?????

// this was added so we can include this file for Ring 3 applications.
#ifdef _VXDLIB_H
// Prototype declaration(s) for Win32 device ioctl APIs(s)
W32API_PROC GetVersion;		// Declare additional prototypes here.
W32API_PROC	StartCapture;
W32API_PROC	EndCapture;
W32API_PROC	SetConfiguration;
W32API_PROC	GetConfiguration;
W32API_PROC SetRing3Callback;
W32API_PROC ClearStatistics;

#define NVSHIFTSTATE(mask, compare) ( (~((mask) | SS_Toggle_mask)) << 16 | compare)

#endif

#ifdef NVSTATDRIVER

extern NVDXTICK *DXStatTickPtr;
void __cdecl nvStatLookupIndex(char *fmt, ...);

typedef struct STATINDEX
{
	DWORD	index;
	DWORD	nParms;
	__int64 startCount;
	__int64 outsideCount;
	STATINDEX *lastStatIndex;
} STATINDEX;

#define INVALID_INDEX 0xffffffff

#undef dbgTracePush
#define dbgTracePush																						\
	static STATINDEX StatIndex = { INVALID_INDEX, 0 };	/* Create the static class */ 						\
	CStatEnd StatEnd(&StatIndex);						/* when this routine ends call ~CStatEnd */			\
	if (gNVStatIndex != &StatIndex)						/* check for recursion */							\
	{																										\
		StatIndex.lastStatIndex = gNVStatIndex;																\
		StatIndex.outsideCount = 0;						/* reset outside count to zero */					\
	}																										\
	gNVStatIndex = &StatIndex;							/* Setup global for our lookup routine */			\
	if (DXStatTickPtr && DXStatTickPtr->captureOn >= 1)	/* if we are capturing data	*/						\
	{																										\
		DXStatTickPtr->captureOn++;						/* bump up reference count */						\
		if ((StatIndex.index != INVALID_INDEX) && (StatIndex.index < STAT_NUM_FUNCTIONS)) 					\
		{												/* if not first time through */						\
			nvStatWriteLogOpCode(1, StatIndex.index);	/* call to write opcode to log memory */			\
			if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT) /* if medium logging is enabled */				\
			{																								\
				NVStatLogMedium(StatIndex.index, 0);														\
			}																								\
			else if (DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT) /* call maximum logging function */		\
			{																								\
				NVStatLogMaximum(StatIndex.index, 0);														\
			}																								\
		}																									\
		{																									\
		__asm push	eax																						\
		__asm push	ebx																						\
		__asm push	edx									/* save some register */							\
		__asm rdtsc										/* read time stamp count */							\
		__asm mov	ebx, OFFSET (StatIndex.startCount)	/* save off count into static StatIndex structure */\
		__asm mov	[ebx], eax																				\
		__asm mov	[ebx+4], edx																			\
		__asm pop	edx																						\
		__asm pop	ebx																						\
		__asm pop	eax																						\
		}																									\
	}												/* this next code replaces dbgPushTrace	with lookup */	\
	nvStatLookupIndex

extern STATINDEX *gNVStatIndex;

class CStatEnd {
public:
	STATINDEX *curSI;

	CStatEnd(STATINDEX *localSI)
	{
		curSI = localSI;
	}

	~CStatEnd()
	{
		__int64 endCount;

		// if capture is hooked up and it it is on and startCount has been initialized
		if (DXStatTickPtr && DXStatTickPtr->captureOn > 1)
		{
			__asm {
				push eax
				push ebx
				push edx
				rdtsc
				mov	dword ptr endCount, eax			/* save off end count */
				mov	dword ptr endCount+4,edx
				pop	edx
				pop	ebx
				pop	eax
			};

			if (curSI->index != INVALID_INDEX)
			{
				// turn into delta count
				endCount -= curSI->startCount;
				if (curSI->lastStatIndex != NULL)
				{
					// add our accumlated deltas to subtract out of parents
					curSI->lastStatIndex->outsideCount += endCount;
				}

				// subtract out calls to other functions we called
				endCount -= curSI->outsideCount;

				DXStatTickPtr->DXAdditiveTick[curSI->index] += endCount;
				DXStatTickPtr->DXHits[curSI->index]++;
			}

			DXStatTickPtr->captureOn--;
		}

		gNVStatIndex = curSI->lastStatIndex;
	}
};



typedef enum
{
	NVSTAT_LOCK_UNKNOWN = 0,
	NVSTAT_LOCK_PALETTE = 1,
	NVSTAT_LOCK_OPT_DEST = 2,
	NVSTAT_LOCK_VB = 3,
	NVSTAT_LOCK_AUTO_MIP = 4,
	NVSTAT_LOCK_VB_FLUSH = 5,
	NVSTAT_LOCK_UPDATE_LINEAR = 6,
	NVSTAT_LOCK_L2L_COPY = 7,
	NVSTAT_LOCK_L2O_COPY = 8,
	NVSTAT_LOCK_O2L_COPY = 9,
	NVSTAT_LOCK_O2O_COPY = 10,
	NVSTAT_LOCK_FILL_OPT = 11,
	NVSTAT_LOCK_STR_BLT = 12,
	NVSTAT_LOCK_TEX_NORMAL = 13,
	NVSTAT_LOCK_TEXMAN_EVICT = 14,
	NVSTAT_LOCK_TEXMAN_EVICT_ALL = 15,
	NVSTAT_LOCK_EXECUTE_BUFFER = 16,
	NVSTAT_LOCK_VID_TEX = 17,
	NVSTAT_LOCK_COPY_TEX = 18,
	NVSTAT_LOCK_UPDATE_OPTIMIZED = 19
} NVSTATLOCKINDEX;

extern NVSTATLOCKINDEX nvStatLockIndex;

struct _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;

void NVStatLogMedium(DWORD DXFunction, DWORD value);
void NVStatLogMaximum(DWORD DXFunction, DWORD value);
void nvStatWriteLogOpCode(DWORD nDWords, DWORD opCode);
void nvStatWriteLogData(DWORD nDWords, DWORD *theData);
BOOL nvStatCheckLogSpace(DWORD nDWords);
void __cdecl nvStatLogDwordData(DWORD parmEnum, int count, ...);
void nvStatLogVertexData(BOOL dx6, DWORD *pVertex);
void __stdcall nvCelsiusDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
void __stdcall nvKelvinDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress);

#define DDLOCKINDEX(LockIndex)				\
	nvStatLockIndex = LockIndex;

#define DDSTARTTICK(DXFunction)
#define DDENDTICK(DXFunction)


// FOffset come in one based, so decrement it.
#define DDTICKOFFSET(DXFunction, value)				\
{														\
	if (DXStatTickPtr != NULL)							\
	{													\
		if (DXFunction < (D3D_NUM_RENDERSTATES+D3D_NUM_TEXSTAGESTATES))			\
		{												\
			StatIndex.index = (DXFunction)+STAT_NUM_FUNCTIONS;	\
			if (DXStatTickPtr->captureOn >= 1)				\
			{												\
				nvStatWriteLogOpCode(1, StatIndex.index);	\
				if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT)	\
				{											\
					NVStatLogMedium(StatIndex.index, (value));	\
				}											\
				else if (DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT)	\
				{											\
					NVStatLogMaximum(StatIndex.index, (value)); \
				}											\
			}												\
		}													\
	}														\
}	

#define DDFLIPTICKS(flipType)				\
	if (DXStatTickPtr != NULL)				\
	{										\
		if (DXStatTickPtr->fEndType == flipType)	\
		{									\
			DWORD frameTickCount;			\
											\
			frameTickCount = DXStatTickPtr->tickCount;		\
			DXStatTickPtr->tickCount = NvGetTickCount();	\
			frameTickCount = DXStatTickPtr->tickCount - frameTickCount;	\
			if (DXStatTickPtr->captureOn >= 1) \
			{								\
				nvStatWriteLogOpCode(3, D3D_LOG_FRAME_END);	\
				nvStatWriteLogData(1, &frameTickCount); \
				nvStatWriteLogData(1, &(DXStatTickPtr->curFrame)); \
			}								\
			DXStatTickPtr->curFrame++;		\
		}									\
		if (DXStatTickPtr->frameRangeEnable)	\
		{									\
			if (DXStatTickPtr->captureOn == 0)	\
			{								\
				if (DXStatTickPtr->curFrame == DXStatTickPtr->startFrame)	\
					DXStatTickPtr->captureOn = 1; \
			}								\
			else							\
			{								\
				if (DXStatTickPtr->curFrame == DXStatTickPtr->endFrame)	\
				{							\
					DXStatTickPtr->captureOn = 0;	\
					DXStatTickPtr->FRCount++; \
				}							\
			}								\
		}									\
	}

#define DDFLIPINIT()						\
	if (DXStatTickPtr != NULL)				\
	{										\
		DXStatTickPtr->curFrame = 0;		\
		DXStatTickPtr->logTail = 0;			 /* reset logging */ \
	}				

#define DDSTATLOGWORDS(x, y, z)				\
	if ((DXStatTickPtr != NULL) &&			\
		((DXStatTickPtr->logFormat & (LOG_MAXIMUM_BIT | LOG_MEDIUM_BIT)) != 0))	\
	{										\
		DWORD temp;							\
		temp = (z);							\
		nvStatWriteLogOpCode(2, x);		\
		nvStatWriteLogData(1, (DWORD *)(&temp)); \
	}										\

#else

#define DDSTARTTICK(DXFunction)
#define DDENDTICK(DXFunction)
#define DDSTARTTICKO(pContext, DXFunction, FOffset)
#define DDENDTICKO(DXFunction, FOffset)
#define DDFLIPTICKS(flipType)
#define DDFLIPINIT()
#define DDSTATLOGWORDS(x, y, z)
#define DDLOCKINDEX(LockIndex)
#define DDTICKOFFSET(DXFunction, value)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSurf.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvSurf.h
//        Prototypes and definitions for nvSurf.cpp
//
//  History:
//        Craig Duttweiler      bertrem         17Aug99         created
//
// **************************************************************************

#ifndef __NV_SURF_H_
#define __NV_SURF_H_

DWORD            nvCreateSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);
DWORD            nvDeleteSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);

DWORD __stdcall  nvCreateSurfaceEx (LPDDHAL_CREATESURFACEEXDATA);

void             nvHWLockTextures   (PNVD3DCONTEXT);
void             nvHWUnlockTextures (PNVD3DCONTEXT);
void             nvHWLockStreams    (PNVD3DCONTEXT pContext, DWORD dwCount);
void             nvHWUnlockStreams  (PNVD3DCONTEXT pContext, DWORD dwCount);

#endif  // __NV_SURF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSemaphore.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSemaphore.cpp
//      a semaphore class, for use with kelvin-style semaphores
//      handles allocation and management
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        13Sep2000         created, NV20 development
//
// **************************************************************************

#ifndef __NVSEMAPHORE_H
#define __NVSEMAPHORE_H

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

//---------------------------------------------------------------------------

// forward definitions

class CSimpleSurface;
class CSemaphoreManager;

//---------------------------------------------------------------------------

class CSemaphore
{

public:
    const enum {
        SEMAPHORE_RELEASE_KELVIN_BACKEND = 1,
        SEMAPHORE_RELEASE_KELVIN_TEXTURE = 2,
        SEMAPHORE_RELEASE_DAC            = 3
    };

private:
    DWORD   m_dwValue;   // must be first
    DWORD   m_dwOffset;  // offset of this semaphore within the semphore context DMA
    BOOL    m_bInUse;
    DWORD   m_dwPad;     // semaphores must be 16-byte aligned

public:
    BOOL    acquire (DWORD dwValue, CPushBuffer *pPusher);
    BOOL    release (DWORD dwValue, CPushBuffer *pPusher);
    BOOL    release (DWORD dwValue, CPushBuffer *pPusher, DWORD dwSubCh, DWORD dwType);

    DWORD   read    (void)      { return (m_dwValue); }

    CSemaphore()    {}
    ~CSemaphore()   {}

    friend CSemaphoreManager;

};

//---------------------------------------------------------------------------

class CSemaphoreManager
{

public:

    const enum {
        SEMAPHORE_CONTEXT_DMA_IN_MEMORY   = 0xDD001E00,
        SEMAPHORE_CONTEXT_DMA_FROM_MEMORY = 0xDD001E01
    };

private:

    CSimpleSurface *m_pSemaphoreSurface;
    BYTE           *m_pSemaphoreMemory;

public:

    BOOL            create    (void);
    BOOL            destroy   (void);
    CSemaphore     *allocate  (DWORD dwInitialValue);
    BOOL            free      (CSemaphore *pSem);

    CSemaphoreManager()       {   m_pSemaphoreSurface = (CSimpleSurface *)NULL;
                                  m_pSemaphoreMemory  = NULL;
                              }

    ~CSemaphoreManager()      {}

};

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020

#endif  // __NVSEMAPHORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvsupertri.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSuperTri.h
//      SuperTri state header file
//
// **************************************************************************
//
//  History:
//      Scott Kephart           08Nov00             Kelvin Development
//
// **************************************************************************


#if (NVARCH >= 0x10)
// xPipe / Super-tri constants
#define NV_CULLFLAG_SUPERTRI            0x00000001
#define NV_CULLFLAG_MODELOK             0x00000002
#define NV_CULLFLAG_XFORMOK             0x00000004

// xPipe / Super-tri inner loop flags. These ought to be in the inner loop flags above, but we don't have enough
// flag bits.


#define NV_STILFLAG_STDEFVB             0x00000001  // default VB is used (affects supertri logic)
#define NV_STILFLAG_MODEL               0x00000002  // Model Culling
#define NV_STILFLAG_XFORM               0x00000004  // Xform / clipcheck / cull
#define NV_STILFLAG_HIBW                0x00000008  // High bandwidth mode -- check all triangles
#define NV_STILFLAG_NOCULL              0x00000010  // Disable cull-check

class CSuperTri;
class CVertexShader;

typedef bool (*PST_STRAT_FN)(CSuperTri *, DWORD dwDP2Operation, DWORD primcount, CVertexShader *pVertexShader);

class CSuperTri
{
//private:
public:
    // Number of flips to allow pending before using SUPER_TRI code.
    DWORD                       dwSuperTriPendingFlips;
    DWORD                       dwSuperTriThrottle;
    DWORD                       dwSuperTriMask;
    DWORD                       cullsign;
    D3DVECTOR4                  eye;                                 // supertri eye in model space
//bank
    DWORD                       dwCullFlags;                         // culling state flags
    DWORD                       dwSTILFlags;
    DWORD                       dwSTLBStride;
    PST_STRAT_FN                pStrategy;
    PNVD3DCONTEXT               pContext;
    DWORD                       dwNumLights;
    DWORD                       _pad0[2];
public:
    void SuperTriInit(PNVD3DCONTEXT pContext);
    __forceinline void setSuperTri() {dwCullFlags |= NV_CULLFLAG_SUPERTRI;}
    __forceinline void clrSuperTri() {dwCullFlags &= ~(NV_CULLFLAG_SUPERTRI|NV_CULLFLAG_MODELOK);}
    __forceinline bool isSuperTri() {return ((dwCullFlags & NV_CULLFLAG_SUPERTRI) != 0);}
    __forceinline void setModelCullOK() {dwCullFlags |= NV_CULLFLAG_MODELOK;}
    __forceinline void clrModelCullOK() {dwCullFlags &= ~(NV_CULLFLAG_MODELOK);}
    __forceinline bool isModelCullOK() {return (dwCullFlags & NV_CULLFLAG_MODELOK) != 0;}
    __forceinline void setXFormCullOK() {dwCullFlags |= NV_CULLFLAG_XFORMOK;}
    __forceinline void clrXFormCullOK() {dwCullFlags &= ~(NV_CULLFLAG_XFORMOK);}
    __forceinline bool isXFormCullOK() {return (dwCullFlags & NV_CULLFLAG_XFORMOK) != 0;}
    __forceinline void setFixedLBStride() {dwSTILFlags &= ~NV_STILFLAG_STDEFVB;};
    __forceinline bool isFixedLBStride() {return (dwSTILFlags & NV_STILFLAG_STDEFVB) == 0;}
    __forceinline void setVarLBStride() {dwSTILFlags |= NV_STILFLAG_STDEFVB;};
    __forceinline void setModelCull() {dwSTILFlags |= NV_STILFLAG_MODEL; dwSTILFlags &= ~NV_STILFLAG_XFORM;}
    __forceinline void clrCullILFlags() {dwSTILFlags &= ~(NV_STILFLAG_MODEL | NV_STILFLAG_XFORM | NV_STILFLAG_STDEFVB | NV_STILFLAG_HIBW | NV_STILFLAG_NOCULL);}
    __forceinline void setXformCull() {dwSTILFlags |= NV_STILFLAG_XFORM; dwSTILFlags &= ~NV_STILFLAG_MODEL;}
    __forceinline bool isModelCull() {return (dwSTILFlags & NV_STILFLAG_MODEL) != 0;}
    __forceinline bool isXFormCull() {return (dwSTILFlags & NV_STILFLAG_XFORM) != 0;}
    __forceinline void setCheckAll()  {dwSTILFlags |= NV_STILFLAG_HIBW;}
    __forceinline void clrCheckAll()  {dwSTILFlags &= ~NV_STILFLAG_HIBW;}
    __forceinline bool isCheckAll() {return (dwSTILFlags & NV_STILFLAG_HIBW) != 0;}
    __forceinline void setNoCull() {dwSTILFlags |= NV_STILFLAG_NOCULL;}
    __forceinline void clrNoCull() {dwSTILFlags &= ~NV_STILFLAG_NOCULL;}
    __forceinline bool isNoCull() {return (dwSTILFlags & NV_STILFLAG_NOCULL) != 0;}
    __forceinline void setNumLights(DWORD lights) {dwNumLights = lights;}
    __forceinline DWORD getNumLights() {return dwNumLights;}

    void setSTLBStride();

    __forceinline void setSTLBStride (DWORD stride) { dwSTLBStride = stride; }

    __forceinline DWORD getSTLBStride(){ return dwSTLBStride; }

    void setStrategy();
    __forceinline bool Strategy(DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader) { return (*pStrategy)(this, dwDP2Operation, PrimCount, pVertexShader); }
    void setEye(D3DMATRIX *MV);
    __forceinline DWORD getEyeAddr() {return (DWORD) (&eye);}
    __forceinline void setCullsign(DWORD c) {cullsign = c;}
    __forceinline DWORD getCullsignAddr() {return (DWORD) (&cullsign);}

    friend bool ST_Strat_P3(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader);
    friend bool ST_Strat_P4(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader);
    friend bool ST_Strat_Null(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSurface.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************

#ifndef _nvSurface_h
#define _nvSurface_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

extern DWORD g_adwSurfaceContextDMA[9];

//---------------------------------------------------------------------------

// class CSimpleSurface
//
// simple surface object
//  an instance will encapsulate a linear chunk of memory in any memory space.
//  it also contains HW specifics needed for HW access.
//  it is not very smart.

class CSimpleSurface
{
    // constants
public:
    enum
    {
        // used to specify where we want to allocate a surface (or'ed together)
        // or where it's currently allocated
        HEAP_LOCATION_MASK      = 0x0000001f,   // surface location - preserve order
        HEAP_VID                = 0x01,
        HEAP_AGP                = 0x02,
        HEAP_PCI                = 0x04,
        HEAP_SYS                = 0x08,
        HEAP_DYNSYS             = 0x18,
        HEAP_DYNSYSBIT          = 0x10,
        HEAP_ANYWHERE           = HEAP_VID | HEAP_AGP | HEAP_PCI | HEAP_SYS | HEAP_DYNSYS,
        HEAP_NOWHERE            = 0x0,

        FLAG_UPTODATE           = 0x00000100,   // surface data is up to date (can be used)
        FLAG_RENDERTARGET       = 0x00000200,   // surface is a render target
        FLAG_ZBUFFER            = 0x00000400,   // surface is a zbuffer
        FLAG_DONOTOWNMEMORY     = 0x00000800,   // memory management is done by somebody else (not self)
        FLAG_TILED              = 0x00001000,   // surface was allocated in tiled memory
        FLAG_SWIZZLED           = 0x00002000,   // surface is a swizzled (used by nvSetRenderTargetDX7)
        FLAG_available          = 0x00004000,
        FLAG_HASALPHA           = 0x00008000,   // surface format has alpha
        FLAG_ISDXT              = 0x00010000,   // surface format is DXT
#ifdef  STEREO_SUPPORT
        FLAG_STEREO             = 0x00020000,   // surface is stereo
        FLAG_NOTREAL            = 0x00040000,   // surface is stereo
#endif  //STEREO_SUPPORT

        // original lock parameters
        LOCK_NORMAL             = 0,            // normal access. do not rename
        LOCK_RENAME             = 1,            // rename if allowed
        LOCK_RENAME_COPY        = 3,            // rename if allowed and also copy contents forward

        LOCK_READ,                 //permissions
        LOCK_WRITE,

        LOCKED_NOT=0,               // for lock states
        LOCKED_READ=1,
        LOCKED_WRITE=2,

        // allocation flags
        ALLOCATE_SIMPLE         = 0x00000001,
        ALLOCATE_TILED          = 0x00000002,
        ALLOCATE_AS_ZBUFFER_UNC = 0x00000010,   // uncompressed z-buffer
        ALLOCATE_AS_ZBUFFER_CMP = 0x00000020,   // compressed z-buffer
        ALLOCATE_AS_ZBUFFER     = 0x00000030,   // any z format
		ALLOCATE_AS_STEREO		= 0x00000040	// stereo surface
    };

    // members
protected:
//bank
    DWORD      m_dwAddress;       // surface address [absolute]
    DWORD      m_dwOffset;        // surface offset [depends on dma context]
    DWORD      m_dwFormat;
    DWORD      m_dwBPP;           // bytes per pixel
    DWORD      m_dwBPPRequested;  // what did the app originally ask for? (not necessarily what was granted)
    DWORD      m_dwWidth;
    DWORD      m_dwHeight;        // height = 1 for vertex buffers, etc
    DWORD      m_dwDepth;         // depth = 1 for vertex buffers, etc
    DWORD      m_dwMultiSampleBits;   // number of samples per pixel
//bank
    DWORD      m_dwPitch;         // pitch = size for vertex buffers, etc.
    DWORD      m_dwSlicePitch;    // pitch of 2D slice for volume textures
    DWORD      m_dwFourCC;        // fourCC code (0 if not a fourCC surface)
    DWORD      m_dwFlags;         // flags
    DWORD      m_dwRetireDate;    // date that HW access retires
    CNvObject *m_pWrapperObject;
    DWORD      m_dwUsedMin;       // supertri only
    DWORD      m_dwUsedMax;       // supertri only
//bank
    DWORD      m_dwAllocFlags;    // our allocation flags (for debug purposes)
#ifdef  DEBUG_SURFACE_PLACEMENT
    DWORD      m_dwRMAllocFlags;  // Resman alloc flags (for debug purposes
#endif
#ifdef  STEREO_SUPPORT
    DWORD      m_dwAddressRight;  // right eye surface address [absolute]
    DWORD      m_dwOffsetRight;   // right eye surface offset [depends on dma context]
    DWORD      _dummy[5];
#else
    DWORD      _dummy[7];
#endif  //STEREO_SUPPORT
//bank

    // inline helper methods
public:
    inline BOOL  isValid           (void)         const { return m_dwAddress != 0; }
    inline BOOL  hwCanRead         (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) != HEAP_SYS; }
    inline BOOL  hwCanWrite        (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) == HEAP_VID; }
    inline BOOL  isReadCached      (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) >= HEAP_PCI; }
    inline BOOL  isWriteCached     (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) >= HEAP_PCI; }
    inline BOOL  isWriteCombined   (void)         const { return (m_dwFlags & HEAP_LOCATION_MASK) <= HEAP_AGP; }

    inline DWORD getSize           (void)         const { return (m_dwPitch * m_dwHeight); }
    inline DWORD getContextDMA     (void)         const { return g_adwSurfaceContextDMA[m_dwFlags & HEAP_LOCATION_MASK]; }
    inline DWORD getHeapLocation   (void)         const { return m_dwFlags & HEAP_LOCATION_MASK; }
    inline DWORD getOffset         (void)         const { return m_dwOffset;  }
    // Used by updateCachedValues in CVertexBuffer to mainatin a cached copy of the flags.
    // It's only added in the right places for Vertex Buffers, as well.
    inline DWORD getFlags          (void)         const { return m_dwFlags; }

    // this should only be used in DX6 DestroySurface32 to restore the surface address of the render target
    // the surface must be in video memory only
    inline void  setAddress        (DWORD dwAddress)    { m_dwAddress = dwAddress; m_dwOffset = dwAddress - pDriverData->BaseAddress; }

    inline DWORD getAddress        (void)         const { return m_dwAddress; }
#ifdef WINNT
    inline DWORD getfpVidMem       (void)         const { return ((getHeapLocation() & (HEAP_VID | HEAP_AGP)) ? m_dwOffset : m_dwAddress); }
#else
    inline DWORD getfpVidMem       (void)         const { return m_dwAddress; }
#endif // WINNT
    inline void  setPitch          (DWORD dwP)          { m_dwPitch = dwP; }
    inline DWORD getPitch          (void)         const { return (m_dwPitch); }

    inline void  setSlicePitch     (DWORD dwSP)         { m_dwSlicePitch = dwSP; }
    inline DWORD getSlicePitch     (void)         const { return (m_dwSlicePitch); }

    inline void  setWidth          (DWORD dwW)          { m_dwWidth = dwW; }
    inline DWORD getWidth          (void)         const { return (m_dwWidth); }

    inline void  setHeight         (DWORD dwH)          { m_dwHeight = dwH; }
    inline DWORD getHeight         (void)         const { return (m_dwHeight); }

    inline void  setDepth          (DWORD dwD)          { m_dwDepth = dwD; }
    inline DWORD getDepth          (void)         const { return (m_dwDepth); }

    inline void  setMultiSampleBits(DWORD dwM)          { m_dwMultiSampleBits = dwM; }
    inline DWORD getMultiSampleBits(void)         const { return (m_dwMultiSampleBits); }

    inline void  tagUpToDate       (void)               { m_dwFlags |=  FLAG_UPTODATE; }
    inline void  tagOutOfDate      (void)               { m_dwFlags &= ~FLAG_UPTODATE; }
    inline BOOL  isUpToDate        (void)         const { return m_dwFlags & FLAG_UPTODATE; }

    inline void  tagAsLinear       (void)               { m_dwFlags &= ~FLAG_SWIZZLED; }
    inline void  tagAsSwizzled     (void)               { m_dwFlags |=  FLAG_SWIZZLED; } // used to tag render targets only
    inline BOOL  isSwizzled        (void)         const { return m_dwFlags & FLAG_SWIZZLED; }

    inline void  tagAsZBuffer      (void)               { m_dwFlags |=  FLAG_ZBUFFER; }
    inline BOOL  isZBuffer         (void)         const { return m_dwFlags & FLAG_ZBUFFER; }

    inline void  tagAsOwner        (void)               { m_dwFlags &= ~FLAG_DONOTOWNMEMORY; }
    inline void  tagNotAsOwner     (void)               { m_dwFlags |=  FLAG_DONOTOWNMEMORY; }

    inline void  tagAsDynSys       (void)               { m_dwFlags &= ~HEAP_DYNSYSBIT; }
    inline void  tagNotAsDynSys    (void)               { m_dwFlags |=  HEAP_DYNSYSBIT; }

    inline BOOL  isOwner           (void)         const { return (m_dwFlags & FLAG_DONOTOWNMEMORY) == 0; }


    inline DWORD getRetireDate     (void)         const { return m_dwRetireDate; }
           BOOL  isBusy            (void)         const;
           void  reset             (void);

           void  own               (DWORD dwAddress, DWORD dwPitch, DWORD dwHeight,
                                    DWORD dwHeapLocation, BOOL bOwnMemory);
           void  disown            (void);

    // formatted surface helpers
    inline void       setWrapper       (CNvObject *nvO)         { m_pWrapperObject = nvO; }
    inline CNvObject* getWrapper       (void)             const { return (m_pWrapperObject); }

    inline void       setBPP           (DWORD dwBPP)            { m_dwBPP = dwBPP; }
    inline DWORD      getBPP           (void)             const { return (m_dwBPP); }

    inline void       setBPPRequested  (DWORD dwBPPReq)         { m_dwBPPRequested = dwBPPReq; }
    inline DWORD      getBPPRequested  (void)             const { return (m_dwBPPRequested); }

    inline void       setFormat        (DWORD dwFmt)            { m_dwFormat = dwFmt;
                                                                  // note: determination of alpha's existence in palettized
                                                                  // textures is deferred until a palette is set
                                                                  if ((dwFmt == NV_SURFACE_FORMAT_A1R5G5B5)       ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_A4R4G4B4)       ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_A8R8G8B8)       ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_X1A7R8G8B8)     ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_DXT1_A1R5G5B5)  ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_DXT23_A8R8G8B8) ||
                                                                      (dwFmt == NV_SURFACE_FORMAT_DXT45_A8R8G8B8))
                                                                  {
                                                                      m_dwFlags |= FLAG_HASALPHA;
                                                                  }
                                                                  else
                                                                  {
                                                                      m_dwFlags &= ~FLAG_HASALPHA;
                                                                  }
                                                                }
    inline DWORD      getFormat        (void)             const { return (m_dwFormat); }

    inline void       setFourCC        (DWORD dw4cc)            { m_dwFourCC = dw4cc;
                                                                  if (((dw4cc == FOURCC_DXT1) ||
                                                                       (dw4cc == FOURCC_DXT2) ||
                                                                       (dw4cc == FOURCC_DXT3) ||
                                                                       (dw4cc == FOURCC_DXT4) ||
                                                                       (dw4cc == FOURCC_DXT5)))
                                                                  {
                                                                      m_dwFlags |= FLAG_ISDXT;
                                                                  }
                                                                  else
                                                                  {
                                                                      m_dwFlags &= ~FLAG_ISDXT;
                                                                  }
                                                                }
    inline DWORD      getFourCC        (void)             const { return m_dwFourCC; }

    inline BOOL       isFourCC         (void)             const { return m_dwFourCC != 0; }
    inline BOOL       isDXT            (void)             const { return (m_dwFlags & FLAG_ISDXT) == FLAG_ISDXT; }

    inline void       tagHasAlpha      (void)                   { m_dwFlags |=  FLAG_HASALPHA; }
    inline void       tagHasNoAlpha    (void)                   { m_dwFlags &= ~FLAG_HASALPHA; }
    inline BOOL       hasAlpha         (void)             const { return (m_dwFlags & FLAG_HASALPHA) == FLAG_HASALPHA; }

    inline BOOL       hasStencil       (void)             const { return m_dwFormat == NV_SURFACE_FORMAT_Z24S8; }
    
    inline DWORD      getAllocFlags    (void)             const { return m_dwAllocFlags; }
#ifdef  DEBUG_SURFACE_PLACEMENT
    inline DWORD      getRMAllocFlags  (void)             const { return m_dwRMAllocFlags; }
#endif

    // helpers
public:
    inline void hwLock    (DWORD dwAccess) {}   // aquire hw access
           void hwUnlock  (void);               // release hw access
           void cpuLock   (DWORD dwAccess);     // aquire cpu access
    inline void cpuUnlock (void) {}             // release cpu access

    void swap (CSimpleSurface* pSurface);         // swap surface pointers

    inline DWORD modifyDDCaps (DWORD dwCaps) const
    {
        // clear all flags
        dwCaps &= ~(DDSCAPS_VIDEOMEMORY    |
                    DDSCAPS_LOCALVIDMEM    |
                    DDSCAPS_NONLOCALVIDMEM |
                    DDSCAPS_SYSTEMMEMORY);
        // put back the flags we want
        switch (m_dwFlags & HEAP_LOCATION_MASK)
        {
            case HEAP_VID:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                break;
            case HEAP_AGP:
            case HEAP_PCI:
                dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                break;
            // DDRAW just hates it if you specify the DDSCAPS_SYSTEMMEMORY flag. basically it will
            //  never call back to free surfaces. Ugghh.
            // believe it or not, it actually want the VidMem flag set!
            default:
                dwCaps |= (DDSCAPS_VIDEOMEMORY);
                break;
        }
        // return the new flags
        return (dwCaps);
    }

    // construction
public:
    BOOL create   (DWORD dwPitch, DWORD dwHeight, DWORD dwDepth, DWORD dwBPPGranted,
                   DWORD dwAllowedHeaps, DWORD dwPreferredHeap,
                   DWORD dwAllocFlags
#ifdef CAPTURE
                  ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                   );

    BOOL create   (const CSimpleSurface* pTemplateSurface
#ifdef CAPTURE
                  ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                   );

    // formatted surface create
    BOOL create   (CNvObject *pWrapperObject, DWORD dwFormat,
                   DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, DWORD dwMultiSampleBits,
                   DWORD dwBPPRequested, DWORD dwBPPGranted,
                   DWORD dwPitch, DWORD dwAllowedHeaps, DWORD dwPreferredHeap,
                   DWORD dwAllocFlags
#ifdef CAPTURE
                  ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                   );

    BOOL recreate (DWORD dwBPP);

    BOOL growBy   (DWORD dwDelta, BOOL bPreserveContents);

    BOOL destroy  (void);


#ifdef  STEREO_SUPPORT
    inline void     tagAsStereo     (void)       { m_dwFlags |=  FLAG_STEREO; }
    inline void     tagNotAsStereo  (void)       { m_dwFlags &= ~FLAG_STEREO; }
    inline void     tagNotReal      (void)       { m_dwFlags |=  FLAG_NOTREAL; }
    inline DWORD    getAddressRight (void) const { return m_dwAddressRight;  }
    inline DWORD    getOffsetRight  (void) const { return m_dwOffsetRight;  }
    inline BOOL     isStereo        (void) const { return m_dwFlags & FLAG_STEREO; }
    BOOL            createStereo    (void);
    BOOL            destroyStereo   (void);
#endif  //STEREO_SUPPORT

    inline CSimpleSurface (void)
    {
#ifdef DEBUG
        memset (this,0xcc,sizeof(*this));
#endif
        m_dwAddress = 0;
        m_dwWidth   = 0;
        m_dwHeight  = 0;
        m_dwDepth   = 0;
        m_dwMultiSampleBits = 0;
        m_dwPitch   = 0;
        m_dwFlags   = 0;
        m_dwFourCC  = 0;
        m_dwUsedMin = ~0;
        m_dwUsedMax = 0;
        m_pWrapperObject = 0; //HH
#ifdef  STEREO_SUPPORT
        m_dwAddressRight = 0;
        m_dwOffsetRight = 0;
#endif  //STEREO_SUPPORT
    }

    // assumed to be init with zeroes
    inline ~CSimpleSurface (void)
    {
        if (m_dwAddress)
        {
            destroy();
        }
    }
};

//---------------------------------------------------------------------------

// class CComplexSurface
//
// wrapper for simple surfaces that reduces CPU blocking when accessed.
//  potentially consumes tons of memory.
// only useful for textures and vertex buffers.
// cannot be instanced by itself - you have to inherit and implement
//  abstract methods.

template<int cMax> class CComplexSurface
{
    // contants
public:
    enum
    {
    FLAG_RENAME     = 0x00000001,
    FLAG_RENAME_CALL        = 0x00000002,   // rename will call user function

        RENAME_DO_NOTHING       = 0,            // rename options
        RENAME_EXTERNAL         = 1,
    };

    // types
public:
    typedef BOOL (__stdcall *PCANRENAMEPROC)(void *pContext);
    typedef void (__stdcall *PRENAMEPROC)   (void *pContext,DWORD dwOldIndex,DWORD dwNewIndex);

    // members
protected:
//bank
    DWORD           m_dwActiveSurface;      // active one
    DWORD           m_dwPreviousSurface;    // last one used
    DWORD           m_dwTotalSurfaces;      // # in use
    DWORD           m_dwFlags;
    PCANRENAMEPROC  m_pfnCanRenameProc;
    PRENAMEPROC     m_pfnRenameProc;
    void           *m_pRenameContext;
    DWORD           _pad[1];
//bank
    CSimpleSurface  m_aSurface[cMax];       // all surfaces

    // inline helpers
public:
    inline CSimpleSurface* getSurface         (DWORD dwIndex)       { return &m_aSurface[dwIndex]; }
    inline CSimpleSurface* getActiveSurface   (void)                { return &m_aSurface[m_dwActiveSurface]; }
    inline CSimpleSurface* getPreviousSurface (void)                { return &m_aSurface[m_dwPreviousSurface]; }
    inline DWORD           getTotalSurfaces   (void)          const { return m_dwTotalSurfaces; }

    inline void      reset              (void)                { for (DWORD i = getTotalSurfaces(),j = 0; i; j++,i--) m_aSurface[j].reset(); }

           void      tagRenameEnable    (DWORD           dwRenameType,
                                         DWORD           dwPreAllocCount  = 1,  // create MUST have been called before you can set this to more than 1
                                         PCANRENAMEPROC  pfnCanRenameProc = NULL,
                                         PRENAMEPROC     pfnRenameProc    = NULL,
                                         void           *pContext         = NULL);
    inline void      tagRenameDisable   (void)                { m_dwFlags &= ~FLAG_RENAME; }
    inline BOOL      canRename          (void)          const { return m_dwFlags & FLAG_RENAME; }

           void      forceRename        (DWORD dwNewSurface,DWORD dwNewAddress);

    // helpers
public:
    inline void hwLock    (DWORD dwAccess) { getActiveSurface()->hwLock (dwAccess); }
    inline void hwUnlock  (void)           { getActiveSurface()->hwUnlock(); }
           void cpuLock   (DWORD dwAccess);
    inline void cpuUnlock (void)           { getActiveSurface()->cpuUnlock(); }

    // construction
public:
    BOOL create  (CNvObject *pWrapper, DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap
#ifdef CAPTURE
                 ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
                  );
    BOOL own     (DWORD dwAddress, DWORD dwPitch, DWORD dwLogHeight, DWORD dwHeapLocation, BOOL bOwnMemory);
    BOOL disown  (void);
    BOOL swap    (CComplexSurface *pCSurf);
    BOOL destroy (void);

    CComplexSurface (void) { m_dwActiveSurface = m_dwTotalSurfaces = m_dwFlags = 0; }
};

#endif // _nvSurface_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvRefCount.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvRefCount_h
#define _nvRefCount_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

/*****************************************************************************
 * class CReferenceCount
 *
 * interface to shared reference count logic. also abstracts functionality to
 * work with pre-refcount HW.
 * NOTE: all functions work only in the context of a proper pDriverData
 */
class CReferenceCount
{
public:
    CReferenceCount::CReferenceCount() {
      m_dwRefCount            = 0xffffffff;
      m_dwHWRefCount          = 0xffffffff;
      m_dwNV4SurfaceMemory    = 0xffffffff;
      m_dwNV4SurfaceOffset    = 0xffffffff;
      m_dwLastPut             = 0xffffffff;
      m_dwLastWrap            = 0xffffffff;
      m_dwTimeOutValue        = 0xffffffff;
      m_dwTimeOutReload       = 0xffffffff;
    };
        // flags
public:
    const enum {
        // flags used to specify waiting protocol
        WAIT_COOPERATIVE = 0x01,
        WAIT_PREEMPTIVE  = 0x02,

        INC_LAZY         = 0x03,
        INC_IMMEDIATE    = 0x04
    };

    // members
private:
    DWORD       m_dwRefCount;             // the last reference count written to the HW
    DWORD       m_dwHWRefCount;           // the last reference count read from the HW
                                          // (conservative estimate, might be slightly out of date)
    DWORD       m_dwNV4SurfaceMemory;     // nv4 notifier emulation address
    DWORD       m_dwNV4SurfaceOffset;     // nv4 notifier emulation offset
    DWORD       m_dwLastPut;              // last put we wrote a notifier
    DWORD       m_dwLastWrap;             // last wrap count we wrote a notifier
    DWORD       m_dwTimeOutValue;         // # of writes to go before writing
    DWORD       m_dwTimeOutReload;        // # to reset timeout to

#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    CSemaphore *m_pSem;
#endif

    // methods
private:
    void nv4WriteCount (void);

    // write a reference count instruction
    inline void writeRefCount (void)
    {
        // write count
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
        if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
            (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
            (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
        {
            m_pSem->release (m_dwRefCount, &(getDC()->nvPusher), NV_DD_KELVIN, CSemaphore::SEMAPHORE_RELEASE_KELVIN_BACKEND);
        }
        else
#endif
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            // kelvin acts like celsius for now
            getDC()->nvPusher.push   (0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV06E_SET_REFERENCE | 0x40000);
            getDC()->nvPusher.push   (1, m_dwRefCount);
            getDC()->nvPusher.adjust (2);
        }
        else
#endif
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            getDC()->nvPusher.push   (0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV06E_SET_REFERENCE | 0x40000);
            getDC()->nvPusher.push   (1, m_dwRefCount);
            getDC()->nvPusher.adjust (2);
        }
        else {
            nv4WriteCount();
        }
        // cache current pusher values
        m_dwLastPut  = getDC()->nvPusher.getPut();
        m_dwLastWrap = getDC()->nvPusher.getWrapCount();
    }

public:
    // conditionally increment the ref count, write it, and return it
    // INC_LAZY:      we will only write the refcount if we actually pushed
    //                something since we called this or forceInc last.
    //                also - we do not write every time, but batch some up
    // INC_IMMEDIATE: force ref count to be incremented and written
    inline DWORD inc (DWORD dwIncMode)
    {
        switch (dwIncMode) {

            case INC_LAZY:

                if ((getDC()->nvPusher.getPut()       == m_dwLastPut) &&
                    (getDC()->nvPusher.getWrapCount() == m_dwLastWrap)) {
                    return m_dwRefCount;
                }

                if (m_dwTimeOutValue) {
                    m_dwTimeOutValue--;
                    // return fake retirement date. this date won't actually get
                    // written out (or occur) until a sync is forced via wait()
                    return (m_dwRefCount+1);
                }

                // reload
                m_dwTimeOutValue = m_dwTimeOutReload;

                // fall through: write next number

            case INC_IMMEDIATE:

                // increment but never allow it to be zero. zero has special meaning
                m_dwRefCount++;
                if (m_dwRefCount > 0xFFFFFFF0) {
                    // refcount is about to roll over, flush now
                    getDC()->nvPusher.start (TRUE);
                    while (read() != (m_dwRefCount-1)) {
                        nvDelay();
                    }
                    m_dwRefCount = 1;
                    DPF ("refcount wrapped. this may be buggy!");
                    nvAssert (0);
                }

                // write and return new count
                writeRefCount();
                return (m_dwRefCount);

                break;

            default:
                break;

        }  // switch

        DPF ("CReferenceCount::inc() failure");
        dbgD3DError();
        return (0);
    }

    // gets the current HW ref count
    inline DWORD read (void)
    {
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
        if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
            (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
            (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
        {
            m_dwHWRefCount = m_pSem->read();
        }
        else
#endif
        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
            (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
        {
            if (getDC()->nvPusher.isValid()) {
                m_dwHWRefCount = getDC()->nvPusher.getRefCount();
            }
            else {
                // force retirement
                m_dwHWRefCount = m_dwRefCount;
            }
        }
        else
        {
            if (m_dwNV4SurfaceOffset) {
                m_dwHWRefCount = *(DWORD*)(VIDMEM_ADDR((m_dwNV4SurfaceOffset + pDriverData->BaseAddress)));
            }
            else {
                // force retirement
                m_dwHWRefCount = m_dwRefCount;
            }
        }
        return m_dwHWRefCount;
    }

    // gets the shadowed HW ref count
    inline DWORD readShadow (void) const
    {
        return (m_dwHWRefCount);
    }

    // wait until hardware has reached the specified reference count or until we've timed out.
    // returns true if it successfully waits for the HW to catch up, FALSE if it times out
    inline BOOL wait (DWORD dwWaitMode, DWORD dwRetireDate, DWORD dwMaxDelay)
    {
#ifdef CAPTURE
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwValue              = dwRetireDate;
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
            if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
                (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
                (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
            {
                sync.dwType           = CAPTURE_SYNC3_TYPE_SEMAPHORE;
                sync.dwCtxDMAHandle   = CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY;
                sync.dwOffset         = m_pSem->m_dwOffset;
            }
            else
#endif
            if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
                (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
            {
                sync.dwType           = CAPTURE_SYNC3_TYPE_REFCOUNT;
                sync.dwCtxDMAHandle   = 0;
                sync.dwOffset         = 0;
            }
            captureLog (&sync,sizeof(sync));
        }
#endif  // CAPTURE

        if (m_dwHWRefCount >= dwRetireDate) {
            return (TRUE);
        }

        // make sure we actually call forceInc() before starting a sync loop
        if (dwRetireDate > m_dwRefCount) {
            // There are 2 situations where we expect this to happen:
            // 1) dwRetireDate contains a fake value that hasn't been sent
            //    to the HW yet. We know it is m_dwRefCount+1
            // 2) nvReset occured before surface has retired. That means m_dwRefCount=0.
            // In any of these cases the next line solves the problem.
            m_dwRefCount = dwRetireDate;
            writeRefCount();
        }

        getDC()->nvPusher.start (TRUE);

        if (!dwMaxDelay) {
            // don't delay at all. just re-read the value from the HW check it
            return ((read() >= dwRetireDate) ? TRUE : FALSE);
        }

        while (dwMaxDelay) {
            switch (dwWaitMode) {
                case WAIT_COOPERATIVE:
                    NV_SLEEP;
                    break;
                case WAIT_PREEMPTIVE:
                    nvDelay();
                    break;
                default:
                    DPF ("unknown wait flags");
                    dbgD3DError();
            }
            if (read() >= dwRetireDate) {
                return (TRUE);
            }
            dwMaxDelay--;
        }

        return (FALSE);
    }

    // wait as long as required for hardware to reach the specified reference count
    inline BOOL wait (DWORD dwWaitMode, DWORD dwRetireDate)
    {
        BOOL bDone = FALSE;
        while (!bDone) {
            bDone = wait (dwWaitMode, dwRetireDate, 1000);
        }
        return (TRUE);
    }

    // wait as long as required for hardware to reach the current reference count
    inline BOOL wait (DWORD dwWaitMode)
    {
        return (wait (dwWaitMode, m_dwRefCount));
    }

public:
    BOOL create  (DWORD dwTimeOut);
    void destroy (void);
};

/*****************************************************************************
 * class CReferenceCountMap
 *
 * object that maps refcount values on to custom values.
 */
template <int cdwLogMax> class CReferenceCountMap
{
    /*
     * members
     */
protected:
// bank
    BOOL        m_bConservative;
    DWORD       m_dwHead;
    DWORD       m_dwTail;
    DWORD       m_dwLast;
    DWORD       m_dwLast2;
    DWORD       m_dwLastPut;
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    CSemaphore *m_pSem;
    DWORD       _pad[1];
#else
    DWORD       _pad[2];
#endif

// bank
    DWORD       m_adwRefCount[1 << cdwLogMax];
// bank
    DWORD       m_adwNumber[1 << cdwLogMax];

    /*
     * methods
     */
public:
           void  put       (DWORD dwNumber);
           DWORD get       (void);
    inline DWORD getCached (void)               const { return m_dwLast; }
           BOOL  isBusy    (void);

    /*
     * construction
     */
public:
           void  create    (DWORD dwInitialNumber, BOOL bConservative);
           void  destroy   (void);
};

#endif _nvRefCount_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSwitches.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvSwitches.h
//     compile-time switches used in the D3D driver
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler    (bertrem)   15Mar00     created
//
// **************************************************************************

#ifndef NVDD32
#define NVDD32                              // so shared files know what we are talking about
#endif

//---------------------------------------------------------------------------
// general d3d and external functionality
//---------------------------------------------------------------------------

//#define DO_NOT_SUPPORT_VERTEX_BUFFERS       // define to disable d3d vb exports (we use the internal vb still)
#define HOSURF_ENABLE               // enable HOS support
//#define DX7PROPER                           // emit proper dx7 usage
//#define TEX_MANAGE                          // enable texture management
//#define MULTISTAGE_BUMPMAPPING              // enable code to detect special 4- and 8-stage TSS cases
#define CELSIUS_NVCOMBINER                  // enable special NV multi-stage combiner settings in celsius
#ifndef WINNT
#define STEREO_SUPPORT                      // enable stereo support
#endif

//---------------------------------------------------------------------------
// Release 20 functionality
//---------------------------------------------------------------------------

#ifdef WINNT
#define NV_AGP       // NVIDIA managed AGP (does not request AGP heap from MS, required for winXP dual-view)
#endif

//#define REL20

#ifdef REL20

//#define KPFS
//#define LPC_OPT

#endif // REL20



//---------------------------------------------------------------------------
// internal functionality
//---------------------------------------------------------------------------

#define HWFLIP                              // enable use of NV15 ff. HW flip
//#define KELVIN_SEMAPHORES                   // employ kelvin-style semaphores for HW flipping
//#define KELVIN_SEMAPHORES2                  // employ kelvin-style semaphores in place of ref counts / ref count maps
#define SUPERTRI                            // enable super triangle processing on real fast machines
#define CELSIUS_TEX_MATRIX_HACK             // enable workaround for broken texture matrix in nv10
#define ALPHA_CULL 3
//#define ALTERNATE_STENCIL_MODE
//#define SPOOF_KELVIN                        // pretend HW has kelvin support even tho it doesn't
// Uncomment the following line for a ~10-15% gain on DX7 on Win2K
//#define WIN2K_DX7OPT                        // enable to copy sysmem VB's to AGP for Windows 2000
#define KELVIN_CLEAR                        // clear via the kelvin class rather than through 2d classes
#define KELVIN_ILC                          // build kelvin inner loops
#define KELVIN_INLINE_REUSE                 // enable inline primitive reuse for Kelvin innerloops
//#define PROFILE_INDEX
//#define SW_WC
//#define FORCE_CT 1                          // 0 = force CT off, 1 = force CT on
//#define DISABLE_Z_COMPR                     // Disable Z compression
#define SYSVB2AGP 1                         // 0 = disable copy of system memory VB's to AGP 1 = enable.
//#define TEXFORMAT_CRD                       // improved texture format export mechanism
#define STATE_OPTIMIZE 0
#define CHECK_DUP_MATRIX 0
//#define SPOOF_ALPHA                           //create an A8R8G8B8 surface instead of an X8R8G8B8. workaround for a ms issue.
// SPOOF_ALPHA causes problems in 3DWinBench200 or WHQL
#define THREE_STAGE_ALPHA_SUPPORT              // limited three-stage alpha support

//---------------------------------------------------------------------------
// debugging and instrumentation
//---------------------------------------------------------------------------

//#define FORCE_NV10_AS_NV5                   // make NV10 be treated like an NV5
//#define VTUNE_SUPPORT
//#define INSTRUMENT_INNER_LOOPS              // capture MB/S data for inner loops
//#define NV_DISASM                           // compile with push buffer disassembling code
//#define TEX_MANAGE_TEST                     // stress the texture manager by forcing lots of allocation failures, etc.
//#define NV_NULL_DRIVER_DYNAMIC              // allowes dynamically to null out particular drawing primitives.

// null driver flavors
//#define NV_NULL_DRIVER                      // do no work in driver
//#define NV_NULL_HW_DRIVER                   // do work in driver, copy verts (if needed) but dont render geometry (hw will not T&L or rasterize - will set state)
//#define NV_NULL_FILL_DRIVER                 // zero sized triangles
//#define NV_NULL_LIGHTS_DRIVER               // turn of HW lighting
//#define NV_NULL_TEXTURE_DRIVER              // suppress all texture ops (except alloc/free)
//#define NV_NULL_BLEND                       // disable texture and alpha blending
//#define NV_NULL_TEXTURES                    // disable all texturing operations (must also enable NV_NULL_BLEND)

// locutus
//#define NV_PROFILE_CPULOCK                  // LOCUTUS 1 -> CSimpleSurface::cpuLock profiling
//#define NV_PROFILE_PUSHER                   // LOCUTUS 1 -> push buffer profiling
//#define NV_PROFILE_CALLSTACK                // LOCUTUS 1 -> breakdown of time spend in different layers of call stack
//#define NV_PROFILE_DEFVB                    // LOCUTUS 1 -> defualt VB profile
//#define NV_PROFILE_COPIES                   // LOCUTUS 1 -> check major copy routines

// nvDP2Ops profiling
//#define NV_PROFILE_DP2OPS

// texture profiling
//#define NO_TEX_BLTS                         // Do not allow texture blits/downloads
//#define NO_TEX_SWZ                          // Allow texturing downloads, but do not allow swizzling (force linear)
//#define CNT_TEX                             // Count all texture downloads

// procedure instrumentation
//#define INSTRUMENT_ALL_CALLS                // time each and every dbgTraceXXX call (only works for !DEBUG)
#define IAC_THRESHOLD           10          // time in ms to exceed before logging

// capture file creation
//#define CAPTURE

//#define FORCE_INLINE_VERTICES               // force use of inline vertices
//#define CHECK_DEPTHS                        // check that transformed z's aren't outside [0...1].

//#define DEBUG_SURFACE_PLACEMENT

//---------------------------------------------------------------------------
// switch logic
//---------------------------------------------------------------------------

#if defined(NV_PROFILE_CPULOCK) || defined(NV_PROFILE_PUSHER) || defined(NV_PROFILE_CALLSTACK) || defined(NV_PROFILE_DEFVB) || defined(NV_PROFILE_COPIES)
#define NV_PROFILE
#endif

#if defined(STEREO_SUPPORT) && defined(DEBUG)
//#define PER_PRIMITIVE_SYNC
//#define NEW_FRONT_RENDER
#endif

#ifdef WINNT
#undef CAPTURE
#endif

#ifndef WINNT
#undef WIN2K_DX7OPT
#endif

#ifdef CHECK_DEPTHS
#define FORCE_INLINE_VERTICES
#endif

#ifndef TEXFORMAT_CRD
//#define HILO_SUPPORT_DX7          // Support HILO texture formats NVHS and NVHU via dx7
#define HILO_SUPPORT_DX8          // Support HILO texture formats NVHS and NVHU via dx8
//#define NVxn_SUPPORT_DX7
#define NVxn_SUPPORT_DX8
#define DXT_SUPPORT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvTexManage.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTexManage.h
//        definitions and prototypes associated with texture management
//
//  History:
//        Craig Duttweiler      (bertrem)       3Dec99      created
//
// **************************************************************************

#ifdef TEX_MANAGE

// Texture Management Scheme Overview
// we keep multiple texture lists to allow different "classes"  of textures to be defined
// for eviction purposes. class 0 is evicted first; class N is evicted last. within each class,
// the LRU texture is evicted first and the MRU texture is evicted last. textures can be moved
// from one class to another (or entire class lists can be swapped/combined) as needed.

// the currect implementation will classify textures according to the frame in which they were
// most recently used:

// class 0 : textures used in neither the current nor previous frames
// class 1 : textures most recently used in the current frame
// class 2 : textures most recently used in the last frame

#define NV_TEXMAN_NUM_CLASSES   3
#define NV_TEXMAN_DEFAULT_CLASS 1  // the class to which new and "touched" textures get added

// eviction protocols

#define NV_TEXMAN_EVICTION_PROTOCOL_PASSIVE     0  // evict only what we can without syncing or changing contexts
#define NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE  1  // force hardware to sync and relinquish control of each texture before eviction is attempted
#define NV_TEXMAN_EVICTION_PROTOCOL_SEVERE      2  // try to evict from other contexts too
#define NV_TEXMAN_EVICTION_PROTOCOL_ANY         3  // try all protocols in order of increasing severity until eviction succeeds

typedef struct _NV_TEXMAN_DATA {

    DWORD     dwTextureListInUse;

    // pointers to the the ends of the class lists
    CTexture *pTextureLRU[NV_TEXMAN_NUM_CLASSES];
    CTexture *pTextureMRU[NV_TEXMAN_NUM_CLASSES];

    // the next texture to evict. this pointer should ALWAYS be non-NULL unless
    // all texture lists are empty and there is truly nothing to evict.
    CTexture *pTextureToEvict;

} NV_TEXMAN_DATA, *PNV_TEXMAN_DATA;

// prototypes

BOOL nvTexManageInit          (PNVD3DCONTEXT pContext);
BOOL nvTexManageAddTexture    (PNVD3DCONTEXT pContext, CTexture *pTex, DWORD dwClass);
BOOL nvTexManageRemoveTexture (CTexture *pTex);
BOOL nvTexManageAdvanceList   (PNVD3DCONTEXT pContext, DWORD dwList);
BOOL nvTexManageResetPtr      (PNVD3DCONTEXT pContext);
BOOL nvTexManageAdvancePtr    (PNVD3DCONTEXT pContext);
BOOL nvTexManageEvict         (PNVD3DCONTEXT pContext, DWORD dwProtocol);
BOOL nvTexManageEvictAll      (PNVD3DCONTEXT pContext);
BOOL nvTexManageFetch         (PNVD3DCONTEXT pContext, CTexture *pTexture);
BOOL nvTexManageTouch         (PNVD3DCONTEXT pContext, CTexture *pTexture);
BOOL nvTexManageSceneEnd      (PNVD3DCONTEXT pContext);

#endif  // TEX_MANAGE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\NVTEXFMT.H ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVTEXFMT.H                                                        *
*   Define the texture format available for the NV D3D driver.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/

#ifndef _NVTEXFMT_H_
#define _NVTEXFMT_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Define the various texture format definitions.
 * For any given hardware, the texture format definitions don't change,
 * just the formats that are available on that hardware change.
 */
/*
 * RGB 16 BPP (R5xG5xB5)
 */
#define NV_TFMT_X1R5G5B5                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                       \
      0x03E0,                                                                       \
      0x001F,                                                                       \
      0x0000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A1xR5xG5xB5)
 */
#define NV_TFMT_A1R5G5B5                                                            \
{                                                                                  \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,          /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                       \
      0x03E0,                                                                       \
      0x001F,                                                                       \
      0x8000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A4xR4xG4xB4)
 */
#define NV_TFMT_A4R4G4B4                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,          /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x0F00,                                                                       \
      0x00F0,                                                                       \
      0x000F,                                                                       \
      0xF000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP (R5xG6xB5)
 */
#define NV_TFMT_R5G6B5                                                              \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0xF800,                                                                       \
      0x07E0,                                                                       \
      0x001F,                                                                       \
      0x0000                                                                        \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (X8xR8xG8xB8)
 */
#define NV_TFMT_X8R8G8B8                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      32,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                           /* Red Component Mask */                \
      0x0000FF00,                           /* Green Component Mask */              \
      0x000000FF,                           /* Blue Component Mask */               \
      0x00000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (A8xR8xG8xB8)
 */
#define NV_TFMT_A8R8G8B8                                                            \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,          /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      32,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                           /* Red Component Mask */                \
      0x0000FF00,                           /* Green Component Mask */              \
      0x000000FF,                           /* Blue Component Mask */               \
      0xFF000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * RGB 24 BPP (R8xG8xB8)
 * Hardware doesn't actually support this.  The texture would actually
 * have to be expanded to a 32bpp X8xR8xG8xB8 format.
 * Haven't decided if I really want to do this.
 */
#define NV_TFMT_R8G8B8                                                              \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                             /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      24,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                           /* Red Component Mask */                \
      0x0000FF00,                           /* Green Component Mask */              \
      0x000000FF,                           /* Blue Component Mask */               \
      0x00000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * FFVII REQUIRES 8bit textures.  What a pain.  Of course so does PC98/PC99.
 */
#define NV_TFMT_RGB8                                                                \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_PALETTEINDEXED8,      /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      8,                                    /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00000000,                           /* Red Component Mask */                \
      0x00000000,                           /* Green Component Mask */              \
      0x00000000,                           /* Blue Component Mask */               \
      0x00000000                            /* Alpha Component Mask */              \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * 16-bit bumpmap
 * dU occupies the LSByte, dV occupies the MSByte
 */
#define NV_TFMT_BUMPMAP_DV8_DU8                                                     \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_BUMPDUDV,                        /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x000000FF,                           /* dU mask */                           \
      0x0000FF00,                           /* dV mask */                           \
      0x00000000,                           /* luminance mask */                    \
      0                                     /* unused */                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * 16-bit bumpmap with luminance
 * dU occupies the LSByte, luminance occupies the MSByte, dV is in the middle
 */
#define NV_TFMT_BUMPMAP_L6_DV5_DU5                                                  \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE,   /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      16,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x0000001F,                           /* dU mask */                           \
      0x000003E0,                           /* dV mask */                           \
      0x0000FC00,                           /* luminance mask */                    \
      0                                     /* unused */                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * 24-bit bumpmap with luminance
 * dU is in the LSByte, dV is in the second byte and luminance is in the third.
 * the MSByte is unused
 */
#define NV_TFMT_BUMPMAP_L8_DV8_DU8                                                  \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE,   /* ddpfPixelFormat.dwFlags */           \
      0,                                    /* FOURCC code */                       \
      32,                                   /* ddpfPixelFormat.dwRGBBitCount */     \
      0x000000FF,                           /* dU mask */                           \
      0x0000FF00,                           /* dV mask */                           \
      0x00FF0000,                           /* luminance mask */                    \
      0                                     /* unused */                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

/*
 * fourcc macro
 */
#define NV_TFMT_FOURCC(x)                                                           \
{                                                                                   \
    sizeof(DDSURFACEDESC),                  /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,           /* dwFlags */                           \
    0,                                      /* dwHeight */                          \
    0,                                      /* dwWidth */                           \
    0,                                      /* lPitch */                            \
    0,                                      /* dwBackBufferCount */                 \
    0,                                      /* dwZBufferBitDepth */                 \
    0,                                      /* dwAlphaBitDepth */                   \
    0,                                      /* dwReserved */                        \
    NULL,                                   /* lpSurface */                         \
    { 0, 0 },                               /* ddckCKDestOverlay */                 \
    { 0, 0 },                               /* ddckCKDestBlt */                     \
    { 0, 0 },                               /* ddckCKSrcOverlay */                  \
    { 0, 0 },                               /* ddckCKSrcBlt */                      \
    {                                                                               \
      sizeof(DDPIXELFORMAT),                /* ddpfPixelFormat.dwSize */            \
      DDPF_FOURCC,                          /* ddpfPixelFormat.dwFlags */           \
      (x),                                  /* FOURCC code */                       \
      0,                                    /* ddpfPixelFormat.dwRGBBitCount */     \
      0,                                                                            \
      0,                                                                            \
      0,                                                                            \
      0,                                                                            \
    },                                                                              \
    DDSCAPS_TEXTURE                         /* ddscaps.dwCaps */                    \
}

// FourCC formats
#define NV_TFMT_DXT1            NV_TFMT_FOURCC(FOURCC_DXT1)
#define NV_TFMT_DXT2            NV_TFMT_FOURCC(FOURCC_DXT2)
#define NV_TFMT_DXT3            NV_TFMT_FOURCC(FOURCC_DXT3)
#define NV_TFMT_DXT4            NV_TFMT_FOURCC(FOURCC_DXT4)
#define NV_TFMT_DXT5            NV_TFMT_FOURCC(FOURCC_DXT5)

// HILO formats
#define NV_TFMT_NVHU            NV_TFMT_FOURCC(FOURCC_NVHU)
#define NV_TFMT_NVHS            NV_TFMT_FOURCC(FOURCC_NVHS)

#define NV_TFMT_DX8(x,y)                                                            \
{                                                                                   \
    sizeof(DDPIXELFORMAT),                  /* ddpfPixelFormat.dwSize */            \
    DDPF_D3DFORMAT,                         /* ddpfPixelFormat.dwFlags */           \
    (x),                                    /* FOURCC code */                       \
    0,                                      /* ddpfPixelFormat.dwRGBBitCount */     \
    y,                                                                              \
    0,                                                                              \
    0,                                                                              \
    0,                                                                              \
}

#define NV_TFMT_DX8_KELVIN_MULTISAMPLE(x,y)                                                            \
{                                                                                   \
    sizeof(DDPIXELFORMAT),                  /* ddpfPixelFormat.dwSize */            \
    DDPF_D3DFORMAT,                         /* ddpfPixelFormat.dwFlags */           \
    (x),                                    /* FOURCC code */                       \
    0,                                      /* ddpfPixelFormat.dwRGBBitCount */     \
    y,                                                                              \
    (/*(1 << (D3DMULTISAMPLE_5_SAMPLES-1)) | */(1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_3_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) |        \
    ((/*(1 << (D3DMULTISAMPLE_5_SAMPLES-1)) | */(1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_3_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) << 16), \
    0,                                                                              \
    0,                                                                              \
}

#define NV_TFMT_DX8_CELSIUS_MULTISAMPLE(x,y)                                                            \
{                                                                                   \
    sizeof(DDPIXELFORMAT),                  /* ddpfPixelFormat.dwSize */            \
    DDPF_D3DFORMAT,                         /* ddpfPixelFormat.dwFlags */           \
    (x),                                    /* FOURCC code */                       \
    0,                                      /* ddpfPixelFormat.dwRGBBitCount */     \
    y,                                                                              \
    ((1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) |        \
    (((1 << (D3DMULTISAMPLE_4_SAMPLES-1)) | (1 << (D3DMULTISAMPLE_2_SAMPLES-1))) << 16), \
    0,                                                                              \
    0,                                                                              \
}

#define D3D_RENDER_TEXTURE  D3DFORMAT_OP_CUBETEXTURE |            \
                            D3DFORMAT_OP_TEXTURE     |            \
                            D3DFORMAT_OP_OFFSCREEN_RENDERTARGET

#define D3D_TEXTURE         D3DFORMAT_OP_CUBETEXTURE |           \
                            D3DFORMAT_OP_TEXTURE

#define D3D_FRONT_BUFFER    D3DFORMAT_OP_DISPLAYMODE |           \
                            D3DFORMAT_OP_3DACCELERATION

#define D3D_BACK_BUFFER     D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET

#define NV_TFMT_X1R5G5B5_DX8              NV_TFMT_DX8(D3DFMT_X1R5G5B5, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))
#define NV_TFMT_A1R5G5B5_DX8              NV_TFMT_DX8(D3DFMT_A1R5G5B5, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_TEXTURE))
#define NV_TFMT_A4R4G4B4_DX8              NV_TFMT_DX8(D3DFMT_A4R4G4B4, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_TEXTURE))
#define NV_TFMT_R5G6B5_DX8                NV_TFMT_DX8(D3DFMT_R5G6B5,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER | D3D_FRONT_BUFFER ))
#define NV_TFMT_X8R8G8B8_DX8              NV_TFMT_DX8(D3DFMT_X8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_FRONT_BUFFER | D3D_BACK_BUFFER))
#define NV_TFMT_A8R8G8B8_DX8              NV_TFMT_DX8(D3DFMT_A8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))
#define NV_TFMT_RGB8_DX8                  NV_TFMT_DX8(D3DFMT_P8, (D3DFORMAT_OP_VOLUMETEXTURE | D3D_TEXTURE))
#define NV_TFMT_BUMPMAP_DV8_DU8_DX8       NV_TFMT_DX8(D3DFMT_V8U8, D3D_TEXTURE)
#define NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8    NV_TFMT_DX8(D3DFMT_L6V5U5, D3D_TEXTURE)
#define NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8    NV_TFMT_DX8(D3DFMT_X8L8V8U8, D3D_TEXTURE)
#define NV_TFMT_DXT1_DX8                  NV_TFMT_DX8(D3DFMT_DXT1, D3D_TEXTURE)
#define NV_TFMT_DXT2_DX8                  NV_TFMT_DX8(D3DFMT_DXT2, D3D_TEXTURE)
#define NV_TFMT_DXT3_DX8                  NV_TFMT_DX8(D3DFMT_DXT3, D3D_TEXTURE)
#define NV_TFMT_DXT4_DX8                  NV_TFMT_DX8(D3DFMT_DXT4, D3D_TEXTURE)
#define NV_TFMT_DXT5_DX8                  NV_TFMT_DX8(D3DFMT_DXT5, D3D_TEXTURE)

#define NV_TFMT_NVHU_DX8                  NV_TFMT_DX8(FOURCC_NVHU, D3D_TEXTURE)
#define NV_TFMT_NVHS_DX8                  NV_TFMT_DX8(FOURCC_NVHS, D3D_TEXTURE)

#ifndef TEXFORMAT_CRD // -----------------------------------------------------

#ifdef NVxn_SUPPORT_DX7

#define NV_TFMT_NVxn \
    NV_TFMT_FOURCC(FOURCC_NVT0), \
    NV_TFMT_FOURCC(FOURCC_NVT1), \
    NV_TFMT_FOURCC(FOURCC_NVT2), \
    NV_TFMT_FOURCC(FOURCC_NVT3), \
    NV_TFMT_FOURCC(FOURCC_NVT4), \
    NV_TFMT_FOURCC(FOURCC_NVT5), \
    NV_TFMT_FOURCC(FOURCC_NVS0), \
    NV_TFMT_FOURCC(FOURCC_NVS1), \
    NV_TFMT_FOURCC(FOURCC_NVS2), \
    NV_TFMT_FOURCC(FOURCC_NVS3), \
    NV_TFMT_FOURCC(FOURCC_NVS4), \
    NV_TFMT_FOURCC(FOURCC_NVS5),

#else // NVxn_SUPPORT_DX7

#define NV_TFMT_NVxn

#endif // NVxn_SUPPORT_DX7

#ifdef NVxn_SUPPORT_DX8

#define NV_TFMT_NVxn_DX8 \
    NV_TFMT_DX8(FOURCC_NVT0, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT1, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT2, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT3, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT4, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVT5, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS0, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS1, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS2, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS3, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS4, D3D_TEXTURE), \
    NV_TFMT_DX8(FOURCC_NVS5, D3D_TEXTURE),

#else // NVxn_SUPPORT_DX8

#define NV_TFMT_NVxn_DX8

#endif // NVxn_SUPPORT_DX8

#ifdef HILO_SUPPORT_DX7
#define NV_TFMT_HILO_FORMATS              NV_TFMT_NVHU, NV_TFMT_NVHS,
#else
#define NV_TFMT_HILO_FORMATS
#endif

#ifdef HILO_SUPPORT_DX8
#define NV_TFMT_HILO_FORMATS_DX8          NV_TFMT_NVHU_DX8, NV_TFMT_NVHS_DX8,
#else
#define NV_TFMT_HILO_FORMATS_DX8
#endif

#endif  // !TEXFORMAT_CRD --------------------------------------------

#define NV_TFMT_Q8W8V8U8_DX8              NV_TFMT_DX8(D3DFMT_Q8W8V8U8, D3D_TEXTURE)

#define NV_TFMT_Z16                       NV_TFMT_DX8(D3DFMT_D16_LOCKABLE, D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24_S8                    NV_TFMT_DX8(D3DFMT_D24S8, D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24                       NV_TFMT_DX8(D3DFMT_D24X8, D3DFORMAT_OP_ZSTENCIL)

// Multisample formats
#define NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE    NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_R5G6B5,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER | D3D_FRONT_BUFFER ))
#define NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE  NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_X8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_FRONT_BUFFER | D3D_BACK_BUFFER))
#define NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE  NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_A8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))

#define NV_TFMT_Z16_KELVIN_MULTISAMPLE           NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_D16,   D3DFORMAT_OP_ZSTENCIL | D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)
#define NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE        NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_D24S8, D3DFORMAT_OP_ZSTENCIL | D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)
#define NV_TFMT_Z24_KELVIN_MULTISAMPLE           NV_TFMT_DX8_KELVIN_MULTISAMPLE(D3DFMT_D24X8, D3DFORMAT_OP_ZSTENCIL | D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)

#define NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE    NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_R5G6B5,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER | D3D_FRONT_BUFFER ))
#define NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE  NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_X8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_FRONT_BUFFER | D3D_BACK_BUFFER))
#define NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE  NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_A8R8G8B8,(D3DFORMAT_OP_VOLUMETEXTURE | D3D_RENDER_TEXTURE | D3D_BACK_BUFFER))

#define NV_TFMT_Z16_CELSIUS_MULTISAMPLE           NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_D16,   D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE        NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_D24S8, D3DFORMAT_OP_ZSTENCIL)
#define NV_TFMT_Z24_CELSIUS_MULTISAMPLE           NV_TFMT_DX8_CELSIUS_MULTISAMPLE(D3DFMT_D24X8, D3DFORMAT_OP_ZSTENCIL)

#ifdef TEXFORMAT_CRD

// moved to NvFormats.cpp

#else  // !TEXFORMAT_CRD

/*
 * Potentially need 4bpp and 8bpp palettized textures.
 */

// Define the texture formats available on NV3 hardware.
// NV_TFMT_R5G6B5 texture format should be the last format in the
// structure so it can be easily enabled/disabled at runtime.
#define NV3_TEXTURE_FORMATS                NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5

// Define the texture formats available on NV4 hardware.
#define NV4_TEXTURE_FORMATS                NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8

// Define the texture formats available in the celsius class
#define CELSIUS_TEXTURE_FORMATS            NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_DXT1,                    \
                                           NV_TFMT_DXT2,                    \
                                           NV_TFMT_DXT3,                    \
                                           NV_TFMT_DXT4,                    \
                                           NV_TFMT_DXT5,                    \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_RGB8

#define CELSIUS_TEXTURE_FORMATS_NO_DXT     NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_RGB8

#define CELSIUS_TEXTURE_FORMATS_DX8        NV_TFMT_X1R5G5B5_DX8,                    \
                                           NV_TFMT_A1R5G5B5_DX8,                    \
                                           NV_TFMT_A4R4G4B4_DX8,                    \
                                           NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_DXT1_DX8,                        \
                                           NV_TFMT_DXT2_DX8,                        \
                                           NV_TFMT_DXT3_DX8,                        \
                                           NV_TFMT_DXT4_DX8,                        \
                                           NV_TFMT_DXT5_DX8,                        \
                                           NV_TFMT_Z16_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE,      \
                                           NV_TFMT_NVxn_DX8                         \
                                           NV_TFMT_RGB8_DX8

#define CELSIUS_TEXTURE_FORMATS_NO_DXT_DX8 NV_TFMT_X1R5G5B5_DX8,                    \
                                           NV_TFMT_A1R5G5B5_DX8,                    \
                                           NV_TFMT_A4R4G4B4_DX8,                    \
                                           NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE,\
                                           NV_TFMT_BUMPMAP_DV8_DU8_DX8,             \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,          \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8,          \
                                           NV_TFMT_Z16_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_CELSIUS_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE,      \
                                           NV_TFMT_NVxn_DX8                         \
                                           NV_TFMT_RGB8_DX8

#if (NVARCH >= 0x020)

// Define the texture formats available in the kelvin class
#define KELVIN_TEXTURE_FORMATS             NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_BUMPMAP_DV8_DU8,         \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5,      \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8,      \
                                           NV_TFMT_DXT1,                    \
                                           NV_TFMT_DXT2,                    \
                                           NV_TFMT_DXT3,                    \
                                           NV_TFMT_DXT4,                    \
                                           NV_TFMT_DXT5,                    \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_HILO_FORMATS             \
                                           NV_TFMT_RGB8

#define KELVIN_TEXTURE_FORMATS_NO_DXT      NV_TFMT_X1R5G5B5,                \
                                           NV_TFMT_A1R5G5B5,                \
                                           NV_TFMT_A4R4G4B4,                \
                                           NV_TFMT_R5G6B5,                  \
                                           NV_TFMT_X8R8G8B8,                \
                                           NV_TFMT_A8R8G8B8,                \
                                           NV_TFMT_BUMPMAP_DV8_DU8,         \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5,      \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8,      \
                                           NV_TFMT_NVxn                     \
                                           NV_TFMT_HILO_FORMATS             \
                                           NV_TFMT_RGB8

#define KELVIN_TEXTURE_FORMATS_DX8         NV_TFMT_X1R5G5B5_DX8,                   \
                                           NV_TFMT_A1R5G5B5_DX8,                   \
                                           NV_TFMT_A4R4G4B4_DX8,                   \
                                           NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_BUMPMAP_DV8_DU8_DX8,            \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,         \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8,         \
                                           NV_TFMT_DXT1_DX8,                       \
                                           NV_TFMT_DXT2_DX8,                       \
                                           NV_TFMT_DXT3_DX8,                       \
                                           NV_TFMT_DXT4_DX8,                       \
                                           NV_TFMT_DXT5_DX8,                       \
                                           NV_TFMT_Z16_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE,      \
                                           NV_TFMT_Q8W8V8U8_DX8,                   \
                                           NV_TFMT_NVxn_DX8                        \
                                           NV_TFMT_HILO_FORMATS_DX8                \
                                           NV_TFMT_RGB8_DX8

#define KELVIN_TEXTURE_FORMATS_NO_DXT_DX8  NV_TFMT_X1R5G5B5_DX8,                   \
                                           NV_TFMT_A1R5G5B5_DX8,                   \
                                           NV_TFMT_A4R4G4B4_DX8,                   \
                                           NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE,  \
                                           NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE,\
                                           NV_TFMT_BUMPMAP_DV8_DU8_DX8,            \
                                           NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,         \
                                           NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8,         \
                                           NV_TFMT_Z16_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_KELVIN_MULTISAMPLE,         \
                                           NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE,      \
                                           NV_TFMT_Q8W8V8U8_DX8,                   \
                                           NV_TFMT_NVxn_DX8                        \
                                           NV_TFMT_HILO_FORMATS_DX8                \
                                           NV_TFMT_RGB8_DX8

#endif  // (NVARCH >= 0x020)

// number of 8-bit formats (common to all classes (for now at least))
#define NV_NUM_8BIT_TEXTURE_FORMATS        1

#endif  // !TEXFORMAT_CRD

#ifdef __cplusplus
}
#endif

#endif  // _NVTEXFMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvSwiz.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvSwiz_h
#define _nvSwiz_h

#ifdef __cplusplus
extern "C"
{
#else
#error C++ Compiler required
#endif

//
// forward declarations
//
class CTexture;

/*
 * exports
 */

// cpu or gpu swizzle routines
void nvSwizBlt_lin2swz (PNVD3DCONTEXT pContext, 
                        DWORD dwSrcAddr, DWORD dwSrcPitch, DWORD dwSrcSlicePitch,
                        DWORD dwSrcX,DWORD dwSrcY,DWORD dwSrcZ,
                        CTexture *pDstTexture, DWORD dwDstAddr,
                        DWORD dwDstX, DWORD dwDstY, DWORD dwDstZ,
                        DWORD dwDstLogWidth, DWORD dwDstLogHeight, DWORD dwDstLogDepth,
                        DWORD dwWidth, DWORD dwHeight, DWORD dwDepth,
                        DWORD dwBPP);

// cpu swizzle routines
void nvSwizBlt_cpu_lin2lin (DWORD dwSrcAddr,DWORD dwSrcPitch,DWORD dwSrcX,DWORD dwSrcY,
                            DWORD dwDstAddr,DWORD dwDstPitch,DWORD dwDstX,DWORD dwDstY,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

void nvSwizBlt_cpu_lin2swz (DWORD dwSrcAddr,DWORD dwSrcPitch,DWORD dwSrcX,DWORD dwSrcY,
                            DWORD dwDstAddr,DWORD dwDstX,DWORD dwDstY,DWORD dwDstLogWidth,DWORD dwDstLogHeight,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

void nvSwizBlt_cpu_swz2lin (DWORD dwSrcAddr,DWORD dwSrcX,DWORD dwSrcY,DWORD dwSrcLogWidth,DWORD dwSrcLogHeight,
                            DWORD dwDstAddr,DWORD dwDstPitch,DWORD dwDstX,DWORD dwDstY,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

void nvSwizBlt_cpu_swz2swz (DWORD dwSrcAddr,DWORD dwSrcX,DWORD dwSrcY,DWORD dwSrcLogWidth,DWORD dwSrcLogHeight,
                            DWORD dwDstAddr,DWORD dwDstX,DWORD dwDstY,DWORD dwDstLogWidth,DWORD dwDstLogHeight,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwBPP);

// gpu swizzle routines - todo
/*
void nvSwizBlt_gpu_lin2lin
*/
void nvSwizBlt_gpu_lin2swz (DWORD dwSrcOffset,DWORD dwSrcHeap,DWORD dwSrcPitch,DWORD dwSrcX,DWORD dwSrcY,
                            DWORD dwDstOffset,DWORD dwDstX,DWORD dwDstY,DWORD dwDstLogWidth,DWORD dwDstLogHeight,
                            DWORD dwWidth,DWORD dwHeight,DWORD dwFormat);

/*
void nvSwizBlt_gpu_swz2lin
*/
/*
void nvSwizBlt_gpu_swz2swz
*/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////

#define PT_8888     0
#define PT_X888     1
#define PT_4444     2
#define PT_1555     3
#define PT_X555     4
#define PT_565      5

////////////////////////////////////////////////////////////////////////////////////////

class CPaletteBuilder
{
    //
    // create palette
    //
public:
    BOOL initTable  (DWORD dwPalType);
    BOOL buildTable (DWORD dwPalType,DWORD dwSource,DWORD dwWidth,DWORD dwHeight);
    BOOL palettize  (DWORD dwPalType,BYTE *pbPalette);
    BOOL apply      (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight);
    BOOL freeTable  (DWORD dwPalType);

    //
    // depalettize
    //
public:
    BOOL depalettizeInPlace      (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwHeight,DWORD *pPalette);
    BOOL depalettizeAndDeswizzle (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight,DWORD dwDeviceMemPaletteAddr);
};

#ifdef __cplusplus
}
#endif

#endif // _nvSwiz_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvTex.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvTex_h
#define _nvTex_h

#ifndef __cplusplus
#error This file requires a C++ compiler
#endif

#include "nvUtil.h"

#define TOTAL_TEX_RENAME 8

#ifdef CNT_TEX
#define MAX_FRAME_CNT 5000
extern DWORD g_dwVidTexDL[], g_dwAgpTexDL[];
extern DWORD g_dwFrames;
#endif
//---------------------------------------------------------------------------

struct _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;

// class CTexture
//
// texture object

class CTexture
{
    // more flags
public:
    enum
    {
        FLAG_USERMIPLEVEL       = 0x80000000,   // this structure is part of a mip map chain (does not own surface)
        FLAG_PALETTIZED         = 0x40000000,   // texture is palettized
        FLAG_COMPRESSED         = 0x20000000,   // texture is compressed
        FLAG_CUBEMAP            = 0x10000000,   // texture is part of a cube map
        FLAG_VOLUMEMAP          = 0x08000000,   // texture is volumetric data
        FLAG_HASHANDLE          = 0x04000000,   // texture has a legacy handle (dx3,dx5)
        FLAG_MANAGED            = 0x02000000,   // app wants us to manage this texture
        FLAG_COLORKEY           = 0x01000000,   // has a color key
        FLAG_RENAMENOTCOPIED    = 0x00800000,   // set when a texture was just renamed and its contents is not copied over yet
        FLAG_SUBSURFDIRTY       = 0x00400000,   // a mip or cube map sub surface is dirty - force chain update in hwLock
        FLAG_AUTOPALETTIZED     = 0x00200000,   // texture is dynamically palettized by texture blit
        FLAG_UNPALETTIZED       = 0x00100000,   // flag that this serface was palettized and then converted back
    };

    // members
protected:
// bank
    CSimpleSurface                    m_surfLinear;
    CComplexSurface<TOTAL_TEX_RENAME> m_surfSwizzled;

// bank
    CTexture              *m_pBaseTexture;  // the root of the mipmap chain, or for cubemaps, the root of the +x chain. the root points to itself.
    DWORD                  m_dwLogWidth;
    DWORD                  m_dwLogHeight;
    DWORD                  m_dwLogDepth;
    DWORD                  m_dwMipMapCount;
    DWORD                  m_dwPriority;
    DWORD                  m_dwColorKey;
    DWORD                  m_dwFlags;

// bank
    DWORD                  m_dwAutoPaletteOffset; // offset to auto palette
    DWORD                  m_dwOriginalFormat;    // contains the original texture format (if auto palette converts it)

    // cube map data (common to all surfaces that are part of the same cube map)
    DWORD                  m_dwCubeMapSizeFacePadded;

    // we try to precompute and store as much HW state as possible
    DWORD                  m_dwNV056Control0;
    DWORD                  m_dwNV056Format;

#ifdef TEX_MANAGE
    // links in chains of textures used for texture management
    CTexture              *m_pNext;
    CTexture              *m_pPrev;
    PNVD3DCONTEXT          m_pContext; // the context in whose lists this texture is kept and with which it is
                                       // associated. we do our best to make these associations correctly, but
                                       // since textures exist outside of contexts, we're sometimes forced to
                                       // make arbitrary choices.
#endif

    // helpers
public:
    inline void            setBaseTexture      (CTexture *pTexture)       { m_pBaseTexture = pTexture; }
    inline CTexture*       getBaseTexture      (void)               const { return (m_pBaseTexture); }
    inline BOOL            isBaseTexture       (void)               const { return ((this==m_pBaseTexture) ? TRUE : FALSE); };

    inline void            setPriority         (DWORD dwPriority)         { m_dwPriority = dwPriority; }

    inline DWORD           getMipMapCount      (void)               const { return m_dwMipMapCount; }
    inline void            tagUserMipLevel     (void)                     { m_dwFlags |= FLAG_USERMIPLEVEL; }
    inline BOOL            isUserMipLevel      (void)               const { return ((m_dwFlags & FLAG_USERMIPLEVEL) == FLAG_USERMIPLEVEL); }

    inline void            tagPalettized       (void)                     { m_dwFlags |= FLAG_PALETTIZED; }
    inline BOOL            isPalettized        (void)               const { return ((m_dwFlags & FLAG_PALETTIZED) == FLAG_PALETTIZED); }

    // for auto-palette use
    inline void            tagAutoPalettized   (void)                     { m_dwFlags |= FLAG_AUTOPALETTIZED; }
    inline void            untagAutoPalettized (void)                     { m_dwFlags &= ~FLAG_AUTOPALETTIZED; }
    inline void            tagUnpalettized     (void)                     { m_dwFlags |= FLAG_UNPALETTIZED; }
    inline BOOL            isReused            (void)               const { return m_dwFlags & FLAG_UNPALETTIZED; }
    inline void            setOriginalFormat   (DWORD dwFormat)           { m_dwOriginalFormat = dwFormat; }
    inline DWORD           getOriginalFormat   (void)               const { return m_dwOriginalFormat; }
    inline void            resetOriginalFormat (void)                     { setFormat(m_dwOriginalFormat); }
    inline void            setAutoPaletteOffset(DWORD dwPalette)          { m_dwAutoPaletteOffset = dwPalette; }
    inline DWORD           getAutoPaletteOffset(void)               const { return m_dwAutoPaletteOffset; }
    inline BOOL            hasAutoPalette      (void)               const { return m_dwFlags & FLAG_AUTOPALETTIZED; }

    inline void            tagCubeMap          (void)                     { m_dwFlags |= FLAG_CUBEMAP; }
    inline BOOL            isCubeMap           (void)               const { return ((m_dwFlags & FLAG_CUBEMAP) == FLAG_CUBEMAP); }

    inline void            tagVolumeMap          (void)                     { m_dwFlags |= FLAG_VOLUMEMAP; }
    inline BOOL            isVolumeMap           (void)               const { return ((m_dwFlags & FLAG_VOLUMEMAP) == FLAG_VOLUMEMAP); }

    inline void            tagHasHandle        (void)                     { m_dwFlags |= FLAG_HASHANDLE; }
    inline BOOL            hasHandle           (void)               const { return ((m_dwFlags & FLAG_HASHANDLE) == FLAG_HASHANDLE); }

    inline void            tagManaged          (void)                     { m_dwFlags |= FLAG_MANAGED; }
    inline BOOL            isManaged           (void)               const { return ((m_dwFlags & FLAG_MANAGED) == FLAG_MANAGED); }

    inline void            tagRenamedNotCopied (void)                     { m_dwFlags |=  FLAG_RENAMENOTCOPIED; }
    inline void            tagRenamedAndCopied (void)                     { m_dwFlags &= ~FLAG_RENAMENOTCOPIED; }
    inline BOOL            isRenamedNotCopied  (void)               const { return ((m_dwFlags & FLAG_RENAMENOTCOPIED) == FLAG_RENAMENOTCOPIED); }

    inline void            tagSubSurfacesDirty (void)                     { m_dwFlags |=  FLAG_SUBSURFDIRTY; }
    inline void            tagSubSurfacesClean (void)                     { m_dwFlags &= ~FLAG_SUBSURFDIRTY; }
    inline BOOL            isSubSurfacesDirty  (void)               const { return ((m_dwFlags & FLAG_SUBSURFDIRTY) == FLAG_SUBSURFDIRTY); }

    inline CSimpleSurface* getSwizzled         (void)                     { return (m_surfSwizzled.getActiveSurface()); }
    inline CSimpleSurface* getPreviousSwizzled (void)                     { return (m_surfSwizzled.getPreviousSurface()); }
    inline CSimpleSurface* getLinear           (void)                     { return (&m_surfLinear); }
    inline CTexture*       getBaseTexture      (void)                     { return m_pBaseTexture; }

    inline CNvObject*      getWrapper          (void)               const { return (m_surfLinear.getWrapper()); }
    inline BOOL            hwCanWrite          (void)               const { return (m_surfLinear.hwCanWrite()); }

    inline DWORD           getSize             (void)               const { return (m_surfLinear.getSize()); }

    inline void            setWidth            (DWORD dwW)                { m_surfLinear.setWidth(dwW);
                                                                            ASM_LOG2(dwW);
                                                                            m_dwLogWidth = dwW;
                                                                            #if (NVARCH >= 0x010)
                                                                            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) calculateNV056ControlWords();
                                                                            #endif  // NVARCH >= 0x010
                                                                          }

    inline DWORD           getWidth            (void)               const { return (m_surfLinear.getWidth()); }
    inline DWORD           getLogWidth         (void)               const { return (m_dwLogWidth); }  // for DXTs, this is the UNEXPANDED width
    inline DWORD           getLogicalWidth     (void)               const { return isDXT() ? m_surfLinear.getWidth() * 4 : m_surfLinear.getWidth(); }
    inline DWORD           getLogicalLogWidth  (void)               const { return isDXT() ? (m_dwLogWidth + 2) : m_dwLogWidth; }

    inline void            setHeight           (DWORD dwH)                { m_surfLinear.setHeight(dwH);
                                                                            ASM_LOG2(dwH);
                                                                            m_dwLogHeight = dwH;
                                                                            #if (NVARCH >= 0x010)
                                                                            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) calculateNV056ControlWords();
                                                                            #endif  // NVARCH >= 0x010
                                                                          }

    inline DWORD           getHeight           (void)               const { return (m_surfLinear.getHeight()); }
    inline DWORD           getLogHeight        (void)               const { return (m_dwLogHeight); }  // for DXTs, this is the UNEXPANDED height
    inline DWORD           getLogicalHeight    (void)               const { return isDXT() ? m_surfLinear.getHeight() * 4 : m_surfLinear.getHeight(); }
    inline DWORD           getLogicalLogHeight (void)               const { return isDXT() ? (m_dwLogHeight + 2) : m_dwLogHeight; }

    inline void            setDepth            (DWORD dwD)                { m_surfLinear.setDepth(dwD);
                                                                            ASM_LOG2(dwD);
                                                                            m_dwLogDepth = dwD; }
    inline DWORD           getDepth            (void)               const { return (m_surfLinear.getDepth()); }
    inline DWORD           getLogDepth         (void)               const { return (m_dwLogDepth); }  // What does this mean for 3D DXT???
    inline DWORD           getLogicalDepth     (void)               const { return (m_surfLinear.getDepth()); }
    inline DWORD           getLogicalLogDepth  (void)               const { return (m_dwLogDepth); }

    inline DWORD           getNumTexCoords     (void)               const { return ((isVolumeMap() || isCubeMap()) ? 3 : 2); }

    inline void            setBPP              (DWORD dwBPP)              { m_surfLinear.setBPP(dwBPP); }
    inline DWORD           getBPP              (void)               const { return (m_surfLinear.getBPP()); }

    inline void            setBPPRequested     (DWORD dwBPP)              { m_surfLinear.setBPPRequested(dwBPP); }
    inline DWORD           getBPPRequested     (void)               const { return (m_surfLinear.getBPPRequested()); }

    inline void            setPitch            (DWORD dwPitch)            { m_surfLinear.setPitch(dwPitch); }
    inline DWORD           getPitch            (void)               const { return (m_surfLinear.getPitch()); }

    inline void            setSlicePitch       (DWORD dwSlicePitch)       { m_surfLinear.setSlicePitch(dwSlicePitch); }
    inline DWORD           getSlicePitch       (void)               const { return (m_surfLinear.getSlicePitch()); }

    inline void            setFormat           (DWORD dwFmt)              { m_surfLinear.setFormat(dwFmt);
                                                                            #if (NVARCH >= 0x010)
                                                                            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) calculateNV056ControlWords();
                                                                            #endif  // NVARCH >= 0x010
                                                                          }

    inline DWORD           getForma