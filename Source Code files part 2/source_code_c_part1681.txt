  pCpCmdInfo[i].SelectSymbolSet.loOffset = lTemp;
        }

        if (0 < pCInfo[i].iCmdUnselLen) {
            if (0 > (lTemp = ftell(outfile)))
                fatal("ftell");
            if (1 != fwrite(pCInfo[i].pCmdUnsel, pCInfo[i].iCmdUnselLen, 1, outfile))
                fatal("fwrite");
            pCpCmdInfo[i].UnSelectSymbolSet.dwCount = pCInfo[i].iCmdUnselLen;
            pCpCmdInfo[i].UnSelectSymbolSet.loOffset = lTemp;
        }
    }

    for (i = 0; i < (INT)Header.dwGlyphCount; i++) {

        iTemp = pGInfo[i].iCmdLen;

        pMapTable->Trans[i].ubType = pGInfo[i].jType;
        pMapTable->Trans[i].ubType &= ~MTYPE_FORMAT_MASK;

        // Currently we only support MTYPE_DIRECT and MTYPE_COMPOSE.
        
        if (1 == iTemp) {
            pMapTable->Trans[i].ubType |= MTYPE_DIRECT;
            pMapTable->Trans[i].uCode.ubCode = pGInfo[i].pCmd[0];
        }
        else if (1 < iTemp) {

            if (0 > (lTemp = ftell(outfile)))
                fatal("ftell");

            wTemp = pGInfo[i].iCmdLen;
            if (1 != fwrite(&wTemp, sizeof (wTemp), 1, outfile))
                fatal("fwrite");
            if (1 != fwrite(pGInfo[i].pCmd, iTemp, 1, outfile))
                fatal("fwrite");

            pMapTable->Trans[i].ubType |= MTYPE_COMPOSE;
            pMapTable->Trans[i].uCode.sCode =
                (SHORT)(lTemp - Header.loMapTableOffset);

            if (bVerbose) {
                fprintf(logfile, "%d -> %0x (%0x)\n",
                    (i + 1), lTemp, (lTemp - Header.loMapTableOffset));
            }
        }
    } 

    if (0 > (lTemp = ftell(outfile)))
        fatal("ftell");

    Header.dwSize = lTemp;
    pMapTable->dwSize = (lTemp - Header.loMapTableOffset);
}

VOID
undumpgtt()
{
    while (1) {

        if ('\0' == *buf) {
            if (NULL == fgets(buf, sizeof (buf), infile))
                break;
        }

        switch(*buf) {
        case ';':
            // comment lines
            *buf = '\0';
            break;
        case 'H':
            LoadHeader();
            break;
        case 'C':
            LoadCpInfo();
            break;
        case 'G':
            LoadGlyphInfo();
            break;
        default:
            fatal("unknown keyword '%c'\n", *buf);
        }
    }

    // Generate glyh run
    SortGlyphs();

    // Write data into file
    WriteHeader(TRUE);
    WriteGlyphRuns();
    WriteCpInfo(FALSE);
    WriteMapTable(FALSE);
    WriteCommands();
    WriteHeader(TRUE); // w/ correct data
    WriteCpInfo(TRUE); // w/ correct data
    WriteMapTable(TRUE); // w/ correct data

}


/*
 *    main
 */
void __cdecl
main(int argc, char *argv[])
{
    INT i, j;

    argc--, argv++;

    if (argc == 0)
        usage();

    infile = stdin;
    logfile = stdout;

    j = 0;
    for (i = 0; i < argc; i++) {

        if ('-' == argv[i][0]) {

            switch(argv[i][1]) {
            case 'v':
                bVerbose = 1;
                break;
            }
        }
        else {
            switch (j++) {
            case 0:
                if (NULL == (outfile = fopen(argv[i], "wb")))
                    fatal("can't open file \"%s\"", argv[i]);
                break;
            case 1:
                if (NULL == (infile = fopen(argv[i], "r")))
                    fatal("can't open file \"%s\"", argv[i]);
                break;
            }
        }
    }

    undumpgtt();

    fclose(outfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\data.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    data.h

Abstract:

    Interface to PPD/GPD parsers and deals with getting binary data.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/15/96 -amandan-
        Created

--*/

#include "unidrv.h"


PGPDDRIVERINFO
PGetDefaultDriverInfo(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData
    )
/*++

Routine Description:

    This function just need to get default driverinfo

Arguments:

    hPrinter   - Handle to printer.
    pRawData   - Pointer to RAWBINARYDATA

Return Value:

    Returns pUIInfo

Note:


--*/

{

    PINFOHEADER pInfoHeader;

    //
    // Set the current driver version
    //

    pInfoHeader = InitBinaryData(pRawData, NULL, NULL);

    //
    // Get GPDDRIVERINFO
    //

    if (pInfoHeader == NULL)
        return NULL;
    else
        return(OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loDriverOffset));

}



PGPDDRIVERINFO
PGetUpdateDriverInfo (
    IN  PDEV *          pPDev,
    IN  HANDLE          hPrinter,
    IN  PINFOHEADER     pInfoHeader,
    IN  POPTSELECT      pOptionsArray,
    IN  PRAWBINARYDATA  pRawData,
    IN  WORD            wMaxOptions,
    IN  PDEVMODE        pdmInput,
    IN  PPRINTERDATA    pPrinterData
    )
/*++

Routine Description:

    This function calls the parser to get the updated INFOHEADER
    for the binary data.

Arguments:

    hPrinter        Handle to printer
    pOptionsArray   pointer to optionsarray
    pRawData        Pointer to RAWBINARYDATA
    wMaxOptions     max count for optionsarray
    pdmInput        Pointer to input DEVMODE
    pPrinterData    Pointer to PRINTERDATA

Return Value:

    PINFOHEADER , NULL if failure.

Note:

    At this point the input devmode have been validated. And its option
    array is either the default or its own valid array. Don't need to check
    again in this function.

    Once completed, this function should have filled out the pOptionsArray with
    1. Combined array from PRINTERDATA and DEVMODE
    2. Resolve UI Conflicts



--*/

{
    PUNIDRVEXTRA     pdmPrivate;
    POPTSELECT       pDocOptions, pPrinterOptions;
    RECTL            rcFormImageArea;
    OPTSELECT        DocOptions[MAX_PRINTER_OPTIONS];
    OPTSELECT        PrinterOptions[MAX_PRINTER_OPTIONS];


    //
    // Check for PRINTERDATA.dwChecksum32, If matches with current binary data,
    // Use it to combine PRINTERDATA.aOptions to combined array
    //

    pPrinterOptions = pPrinterData->dwChecksum32 == pRawData->dwChecksum32 ?
                      pPrinterData->aOptions : NULL;

    if (pdmInput)
    {
        pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmInput);
        pDocOptions = pdmPrivate->aOptions;
    }
    else
        pDocOptions = NULL;

    //
    // Combine the option arrays to pOptionsArray
    // Note: pDocOptions and pPrinterOptions cannot be NULL when combining
    // options array to get snapshot.
    //

    if (pDocOptions == NULL)
    {
        if (! InitDefaultOptions(pRawData,
                                 DocOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_DOCUMENT_STICKY))
        {
            return FALSE;
        }

        pDocOptions = DocOptions;
    }

    if (pPrinterOptions == NULL)
    {
        if (! InitDefaultOptions(pRawData,
                                 PrinterOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_PRINTER_STICKY))
        {
            return FALSE;
        }

        pPrinterOptions = PrinterOptions;
    }


    CombineOptionArray(pRawData, pOptionsArray, wMaxOptions, pDocOptions, pPrinterOptions);

    if (! BMergeFormToTrayAssignments(pPDev))
    {
        ERR(("BMergeFormToTrayAssignments failed"));
    }

    //
    // Resolve any UI conflicts.
    //

    if (!ResolveUIConflicts( pRawData,
                             pOptionsArray,
                             MAX_PRINTER_OPTIONS,
                             MODE_DOCANDPRINTER_STICKY))
    {
        VERBOSE(("Resolved conflicting printer feature selections.\n"));
    }

    //
    // We are here means pOptionsArray is valid. Call parser to UpdateBinaryData
    //

    pInfoHeader = InitBinaryData(pRawData,
                                 pInfoHeader,
                                 pOptionsArray);

    //
    // Get GPDDRIVERINFO
    //

    if (pInfoHeader == NULL)
        return NULL;
    else
        return(OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loDriverOffset));

}

VOID
VFixOptionsArray(
    PDEV    *pPDev,
    PRECTL              prcFormImageArea
    )
/*++

Routine Description:

    This functions is called to propagate public devmode settings
    to the combined option array.

Arguments:

    hPrinter        Handle to printer
    pInfoHeader     Pointer to INFOHEADER
    pOptionsArray   Pointer to the options array
    pdmInput        Pointer to input devmode
    bMetric         Flag to indicate running in metric system
    prcImageArea    Returns the logical imageable area associated with the requested form

Return Value:

    None

Note:

--*/

{
    WORD    wGID, wOptID, wOption;
    HANDLE          hPrinter = pPDev->devobj.hPrinter ;
    PINFOHEADER     pInfoHeader = pPDev->pInfoHeader ;
    POPTSELECT      pOptionsArray = pPDev->pOptionsArray ;
    PDEVMODE        pdmInput = pPDev->pdm ;
    BOOL            bMetric = pPDev->PrinterData.dwFlags & PFLAGS_METRIC ;

    //
    // Validate the form-related fields in the input devmode and
    // make sure they're consistent with each other.
    //

    if (BValidateDevmodeFormFields(hPrinter, pdmInput, prcFormImageArea, NULL, 0) == FALSE)
    {
        //
        // If failed to validate the form fields, ask parser to
        // use the default
        //

        VDefaultDevmodeFormFields(pPDev->pUIInfo, pdmInput, bMetric );

        prcFormImageArea->top = prcFormImageArea->left = 0;
        prcFormImageArea->right = pdmInput->dmPaperWidth * DEVMODE_PAPER_UNIT;
        prcFormImageArea->bottom = pdmInput->dmPaperLength * DEVMODE_PAPER_UNIT;


    }

    for (wOption = 0; wOption < MAX_GID; wOption++)
    {
        switch(wOption)
        {

        case 0:
            wGID = GID_PAGESIZE;
                VFixOptionsArrayWithPaperSizeID(pPDev) ;
            continue;
            break;

        case 1:
            wGID = GID_DUPLEX;
            break;

        case 2:
            wGID = GID_INPUTSLOT;
            break;

        case 3:
            wGID = GID_MEDIATYPE;
            break;

        case 4:
            wGID = GID_COLORMODE;
            break;

        case 5:
            wGID = GID_COLLATE;
            break;

        case 6:
            wGID = GID_RESOLUTION;
            break;

        case 7:
            wGID = GID_ORIENTATION;
            break;

        default:
            continue;

        }

        ChangeOptionsViaID(pInfoHeader, pOptionsArray, wGID, pdmInput);

    }
}

PWSTR
PGetROnlyDisplayName(
    PDEV    *pPDev,
    PTRREF      loOffset,
    PWSTR       wstrBuf,
    WORD    wsize
    )

/*++


revised capabilities:
caller must pass in a local buffer to
 hold the string, the local buffer
 shall be of fixed size  say
         WCHAR   wchbuf[MAX_DISPLAY_NAME];


The return value shall be either the passed
in ptr or a ptr pointing directly to the buds
binary data.

Routine Description:

    Get a read-only copy of a display name:
    1)  if the display name is in the binary printer description data,
        then we simply return a pointer to that data.
    2)  otherwise, the display name is in the resource DLL.
        we allocate memory out of the driver's heap and
        load the string.

    Caller should  NOT attempt to free the returned pointer unless
    that pointer is one he allocated.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset

Return Value:

    Pointer to the requested display name string
    NULL if there is an error or string not found in resource.dll

--*/

{
    if (loOffset & GET_RESOURCE_FROM_DLL)
    {
        //
        // loOffset specifies a string resource ID
        // in the resource DLL
        //

        INT     iLength;

        //
        // First ensure the resource DLL has been loaded
        // and a heap has already been created
        //

        //  nah, just look here!

        //  pPDev->WinResData.hModule ;

        //
        // Load string resource into a temporary buffer
        // and allocate enough memory to hold the string
        //

//  #ifdef  RCSTRINGSUPPORT
#if 0

        if(((loOffset & ~GET_RESOURCE_FROM_DLL) >= RESERVED_STRINGID_START)
            &&  ((loOffset & ~GET_RESOURCE_FROM_DLL) <= RESERVED_STRINGID_END))
        {
            iLength = ILoadStringW(     &pPDev->localWinResData,
                (int)( loOffset & ~GET_RESOURCE_FROM_DLL),
                wstrBuf, wsize );
        }
        else
#endif

        {
            iLength = ILoadStringW(     &pPDev->WinResData,
                (int)( loOffset & ~GET_RESOURCE_FROM_DLL),
                wstrBuf, wsize );
        }




        if( iLength)
            return (wstrBuf);    //  debug check that buffer is null terminated.
        return(NULL);  //  no string was found!
    }
    else
    {
        //
        // loOffset is a byte offset from the beginning of
        // the resource data block
        //

        return OFFSET_TO_POINTER(pPDev->pUIInfo->pubResourceData, loOffset);
        //  note  wchbuf is ignored in this case.
    }
}





VOID
VFixOptionsArrayWithPaperSizeID(
    PDEV    *pPDev

    )

/*++

Routine Description:

    Fix up combined options array with paper size information from public devmode fields

Arguments:

    pci - Points to basic printer info

Return Value:

    NONE


function uses:

    UImodule                            Render Module equiv

    pci->pUIInfo                        pPDev->pUIInfo
    pci->pInfoHeader                pPDev->pInfoHeader
    pci->pdm                            pPDev->pdm
    pci->pRawData                   pPDev->pRawData
    pci->pCombinedOptions       pPDev->pOptionsArray

    MapToDeviceOptIndex
    PGetIndexedOption
    PGetReadOnlyDisplayName
    ReconstructOptionArray

--*/

{

    PFEATURE pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_PAGESIZE);
    BOOL     abEnabledOptions[MAX_PRINTER_OPTIONS];
    PDWORD   pdwPaperIndex = (PDWORD)&abEnabledOptions;
    DWORD    dwCount, dwOptionIndex, i;

    if (pFeature == NULL)
        return;

    dwCount = MapToDeviceOptIndex(pPDev->pInfoHeader,
                                  GID_PAGESIZE,
                                  pPDev->pdm->dmPaperWidth * DEVMODE_PAPER_UNIT,
                                  pPDev->pdm->dmPaperLength * DEVMODE_PAPER_UNIT,
                                  pdwPaperIndex);
    if (dwCount == 0 )
        return;

    dwOptionIndex = pdwPaperIndex[0];

    if (dwCount > 1 )
    {
        POPTION pOption;
        PCWSTR   pDisplayName;
        WCHAR   wchBuf[MAX_DISPLAY_NAME];


        for (i = 0; i < dwCount; i++)
        {
            if (pOption = PGetIndexedOption(pPDev->pUIInfo, pFeature, pdwPaperIndex[i]))
            {
                if(pOption->loDisplayName == 0xffffffff)  //use papername from EnumForms()
                {
                    PFORM_INFO_1    pForms;
                    DWORD   dwFormIndex ;

//  temp hack!!!    possibly needed for NT40 ?

//                    dwOptionIndex = pdwPaperIndex[i];
//                    break;
//  end hack.
                    // -----  the fix ------  //
                    if (pPDev->pSplForms == NULL)
                        pPDev->pSplForms = MyEnumForms(pPDev->devobj.hPrinter, 1, &pPDev->dwSplForms);

                    if (pPDev->pSplForms == NULL)
                    {
                        //   ERR(("No spooler forms.\n"));  just a heads up.
                        //   dwOptionIndex already set to safe default
                        break;
                    }

                    pForms =  pPDev->pSplForms ;
                    dwFormIndex =  ((PPAGESIZE)pOption)->dwPaperSizeID - 1 ;


                    if ( (dwFormIndex <  pPDev->dwSplForms)  &&
                        (pDisplayName = (pForms[dwFormIndex]).pName) &&
                        (_wcsicmp(pPDev->pdm->dmFormName, pDisplayName) == EQUAL_STRING) )
                    {
                        dwOptionIndex = pdwPaperIndex[i];
                        break;
                    }

                }




                else  if ( (pDisplayName = PGetROnlyDisplayName(pPDev, pOption->loDisplayName,
                    wchBuf, MAX_DISPLAY_NAME )) &&
                    (_wcsicmp(pPDev->pdm->dmFormName, pDisplayName) == EQUAL_STRING) )
                {
                    dwOptionIndex = pdwPaperIndex[i];
                    break;
                }
            }
        }   //  if name doesn't match we default to the first candidate.
    }

    ZeroMemory(abEnabledOptions, sizeof(abEnabledOptions));
    abEnabledOptions[dwOptionIndex] = TRUE;
    ReconstructOptionArray(pPDev->pRawData,
                           pPDev->pOptionsArray,
                           MAX_COMBINED_OPTIONS,
                           GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature),
                           abEnabledOptions);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\data.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    data.h

Abstract:

    data.h header file.  Interface with GPD/PPD parsers and getting
    binary data.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _DATA_H_
#define _DATA_H_

BOOL
BMergeFormToTrayAssignments(
    PDEV *
    );

PGPDDRIVERINFO
PGetDefaultDriverInfo(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData
    );

PGPDDRIVERINFO
PGetUpdateDriverInfo(
    IN  PDEV *          pPDev,
    IN  HANDLE          hPrinter,
    IN  PINFOHEADER     pInfoHeader,
    IN  POPTSELECT      pOptionsArray,
    IN  PRAWBINARYDATA  pRawData,
    IN  WORD            wMaxOptions,
    IN  PDEVMODE        pdmInput,
    IN  PPRINTERDATA    pPrinterData
    );

/* VOID
VFixOptionsArray(
    IN  HANDLE          hPrinter,
    IN  PINFOHEADER     pInfoHeader,
    OUT POPTSELECT      pOptionsArray,
    IN  PDEVMODE        pdmInput,
    IN  BOOL            bMetric,
    PRECTL              prcFormImageArea
    );
*/

VOID
VFixOptionsArray(
    PDEV    *pPDev,
    PRECTL              prcFormImageArea
    ) ;


PWSTR
PGetROnlyDisplayName(
    PDEV    *pPDev,
    PTRREF      loOffset,
    PWSTR       wstrBuf,
    WORD    wsize
    )  ;


VOID
VFixOptionsArrayWithPaperSizeID(
    PDEV    *pPDev
    ) ;

#endif  // !_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\brush.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    brush.h

Abstract:

    Brush object header file

Environment:

        Windows NT Unidrv driver

Revision History:

    05/14/96 -amandan-
        Created

--*/

#ifndef _BRUSH_H_
#define _BRUSH_H_

#define DBCACHE_INC                 16
#define DBCACHE_MAX                 256

#define DITHERED_COLOR             -1
#define BLACK_COLOR_CMD_INDEX       0
#define MAX_COLOR_SELECTION         8
#define CMD_COLORSELECTION_FIRST    CMD_SELECTBLACKCOLOR

#define BRUSH_BLKWHITE              1
#define BRUSH_SHADING               2
#define BRUSH_CROSSHATCH            3
#define BRUSH_USERPATTERN           4
#define BRUSH_PROGCOLOR             5
#define BRUSH_NONPROGCOLOR          6

typedef struct _RECTW {
    WORD    l;
    WORD    t;
    WORD    r;
    WORD    b;
    } RECTW, *PRECTW;

BOOL
Download1BPPHTPattern(
    PDEV    *pPDev,
    SURFOBJ *pso,
    DWORD   dwPatID
    );

WORD
GetBMPChecksum(
    SURFOBJ *pso,
    PRECTW  prcw
    );

LONG
FindCachedHTPattern(
    PDEV    *pPDev,
    WORD    wChecksum
    );

BOOL
BFoundCachedBrush(
    PDEV    *pPDev,
    PDEVBRUSH pDevBrush
    );

//
// The following macro return a density value from 1 to 100 where 1 is the
// lightest and 100 is darkest, it will never return 0 (WHITE) because we
// using 23r + 66g + 10b = 99w
//

#define GET_SHADING_PERCENT(dw)    (BYTE)(100-((((DWORD)RED_VALUE(dw)  * 23) + \
                                             ((DWORD)GREEN_VALUE(dw)* 66) + \
                                             ((DWORD)BLUE_VALUE(dw) * 10) + \
                                             127) / 255))

#define CACHE_CURRENT_BRUSH(pPDev, pDevBrush) \
    pPDev->GState.CurrentBrush.dwBrushType = pDevBrush->dwBrushType; \
    pPDev->GState.CurrentBrush.iColor = pDevBrush->iColor;  \



#endif // _STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\enable.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of device and surface related DDI entry points:
        DrvEnableDriver
        DrvDisableDriver
        DrvEnablePDEV
        DrvResetPDEV
        DrvCompletePDEV
        DrvDisablePDEV
        DrvEnableSurface
        DrvDisableSurface

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    03/31/97 -zhanw-
        Added OEM customization support. Hooked out all DDI drawing functions.

--*/

#include "unidrv.h"
#pragma hdrstop("unidrv.h")

//Comment out this line to disable FTRACE and FVALUE.
//#define FILETRACE
#include "unidebug.h"

#ifdef WINNT_40

DECLARE_CRITICAL_SECTION;

//
// The global link list of ref counts for currently loaded OEM render plugin DLLs
//

extern POEM_PLUGIN_REFCOUNT gpOEMPluginRefCount;

#endif // WINNT_40

//
// Our DRVFN table which tells the engine where to find the routines we support.
//

static DRVFN UniDriverFuncs[] = {
    //
    // enable.c
    //
    { INDEX_DrvEnablePDEV,          (PFN) DrvEnablePDEV         },
    { INDEX_DrvResetPDEV,           (PFN) DrvResetPDEV          },
    { INDEX_DrvCompletePDEV,        (PFN) DrvCompletePDEV       },
    { INDEX_DrvDisablePDEV,         (PFN) DrvDisablePDEV        },
    { INDEX_DrvEnableSurface,       (PFN) DrvEnableSurface      },
    { INDEX_DrvDisableSurface,      (PFN) DrvDisableSurface     },
#ifndef WINNT_40
    { INDEX_DrvDisableDriver,        (PFN)DrvDisableDriver      },
#endif
    //
    // print.c
    //
    {  INDEX_DrvStartDoc,        (PFN)DrvStartDoc               },
    {  INDEX_DrvStartPage,       (PFN)DrvStartPage              },
    {  INDEX_DrvSendPage,        (PFN)DrvSendPage               },
    {  INDEX_DrvEndDoc,          (PFN)DrvEndDoc                 },
    {  INDEX_DrvStartBanding,    (PFN)DrvStartBanding           },
    {  INDEX_DrvNextBand,        (PFN)DrvNextBand               },
    //
    // graphics.c
    //
    {  INDEX_DrvPaint,           (PFN)DrvPaint                  },  // new hook
    {  INDEX_DrvBitBlt,          (PFN)DrvBitBlt                 },
    {  INDEX_DrvStretchBlt,      (PFN)DrvStretchBlt             },
#ifndef WINNT_40
    {  INDEX_DrvStretchBltROP,   (PFN)DrvStretchBltROP          },  // new in NT5
    {  INDEX_DrvPlgBlt,          (PFN)DrvPlgBlt                 },  // new in NT5
#endif
    {  INDEX_DrvCopyBits,        (PFN)DrvCopyBits               },
    {  INDEX_DrvDitherColor,     (PFN)DrvDitherColor            },
    {  INDEX_DrvRealizeBrush,    (PFN)DrvRealizeBrush           },  // in case OEM wants
    {  INDEX_DrvLineTo,          (PFN)DrvLineTo                 },  // new hook
    {  INDEX_DrvStrokePath,      (PFN)DrvStrokePath             },  // new hook
    {  INDEX_DrvFillPath,        (PFN)DrvFillPath               },  // new hook
    {  INDEX_DrvStrokeAndFillPath, (PFN)DrvStrokeAndFillPath    },  // new hook
#ifndef WINNT_40
    {  INDEX_DrvGradientFill,    (PFN)DrvGradientFill           },  // new in NT5
    {  INDEX_DrvAlphaBlend,      (PFN)DrvAlphaBlend             },  // new in NT5
    {  INDEX_DrvTransparentBlt,  (PFN)DrvTransparentBlt         },  // new in NT5
#endif
    //
    // textout.c
    //
    {  INDEX_DrvTextOut,         (PFN)DrvTextOut                },
    //
    // escape.c
    //
    { INDEX_DrvEscape,              (PFN) DrvEscape             },
    //
    // font.c
    //
    { INDEX_DrvQueryFont,           (PFN) DrvQueryFont          },
    { INDEX_DrvQueryFontTree,       (PFN) DrvQueryFontTree      },
    { INDEX_DrvQueryFontData,       (PFN) DrvQueryFontData      },
    { INDEX_DrvGetGlyphMode,        (PFN) DrvGetGlyphMode       },
    { INDEX_DrvFontManagement,      (PFN) DrvFontManagement     },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) DrvQueryAdvanceWidths },
};

//
// Unidrv hooks out every drawing DDI to analyze page content for optimization
//
#ifndef WINNT_40
#define HOOK_UNIDRV_FLAGS   (HOOK_BITBLT |            \
                             HOOK_STRETCHBLT |        \
                             HOOK_PLGBLT |            \
                             HOOK_TEXTOUT |           \
                             HOOK_PAINT |             \
                             HOOK_STROKEPATH |        \
                             HOOK_FILLPATH |          \
                             HOOK_STROKEANDFILLPATH | \
                             HOOK_LINETO |            \
                             HOOK_COPYBITS |          \
                             HOOK_STRETCHBLTROP |     \
                             HOOK_TRANSPARENTBLT |    \
                             HOOK_ALPHABLEND |        \
                             HOOK_GRADIENTFILL)
#else
#define HOOK_UNIDRV_FLAGS   (HOOK_BITBLT |            \
                             HOOK_STRETCHBLT |        \
                             HOOK_TEXTOUT |           \
                             HOOK_PAINT |             \
                             HOOK_STROKEPATH |        \
                             HOOK_FILLPATH |          \
                             HOOK_STROKEANDFILLPATH | \
                             HOOK_LINETO |            \
                             HOOK_COPYBITS)
#endif

//
// Unidrv driver memory pool tag, required by common library headers
//

DWORD   gdwDrvMemPoolTag = '5nuD';

#if ENABLE_STOCKGLYPHSET
//
// Stock glyphset data
//

FD_GLYPHSET *pStockGlyphSet[MAX_STOCK_GLYPHSET];
HSEMAPHORE   hGlyphSetSem = NULL;

VOID FreeGlyphSet(VOID);

#endif //ENABLE_STOCKGLYPHSET


#ifdef WINNT_40 //NT 4.0

HSEMAPHORE  hSemBrushColor = NULL;

#endif //WINNT_40


//
// Forward declarations
//

PPDEV PAllocPDEVData(HANDLE);
VOID VFreePDEVData( PDEV *);
VOID VDisableSurface(PDEV *);
BPaperSizeSourceSame(PDEV * , PDEV *);
HSURF HCreateDeviceSurface(PDEV *, INT);
HBITMAP HCreateBitmapSurface(PDEV *, INT);


HINSTANCE ghInstance;


BOOL WINAPI 
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
#ifndef WINNT_40
    case DRVQUERY_USERMODE:

        ASSERT(pcbNeeded != NULL);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;
#endif

    default:

        ERR(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}

BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    PDRVENABLEDATA  pDrvEnableData
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    iEngineVersion - Specifies the DDI version number that GDI is written for
    cb - Size of the buffer pointed to by pDrvEnableData
    pDrvEnableData - Points to an DRVENABLEDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    VERBOSE(("Entering DrvEnableDriver...\n"));

    //
    // Make sure we have a valid engine version and
    // we're given enough room for the DRVENABLEDATA.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION_NT4 || cb < sizeof(DRVENABLEDATA))
    {
        ERR(("DrvEnableDriver failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }

    //
    // Fill in the DRVENABLEDATA structure for the engine.
    //

    pDrvEnableData->iDriverVersion = DDI_DRIVER_VERSION_NT4;
    pDrvEnableData->c = sizeof(UniDriverFuncs) / sizeof(DRVFN);
    pDrvEnableData->pdrvfn = UniDriverFuncs;

    #ifdef WINNT_40   // NT 4.0

    INIT_CRITICAL_SECTION();
    if (!IS_VALID_DRIVER_SEMAPHORE())
    {
        ERR(("Failed to initialize semaphore.\n"));
        SetLastError(ERROR_NO_SYSTEM_RESOURCES);
        return FALSE;
    }

    ENTER_CRITICAL_SECTION();

        gpOEMPluginRefCount = NULL;

    LEAVE_CRITICAL_SECTION();

    if (!(hSemBrushColor = EngCreateSemaphore()))
    {
        return(FALSE);
    }

    #endif //WINNT_40

    #if ENABLE_STOCKGLYPHSET

    //
    // Initialize stock glyphset data
    //

    if (!(hGlyphSetSem = EngCreateSemaphore()))
    {
        ERR(("DrvEnableDriver: EngCreateSemaphore failed.\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }
    EngAcquireSemaphore(hGlyphSetSem);
    ZeroMemory(pStockGlyphSet, MAX_STOCK_GLYPHSET * sizeof(FD_GLYPHSET*));
    EngReleaseSemaphore(hGlyphSetSem);

    #endif //ENABLE_STOCKGLYPHSET

    //
    // Perform necessary initialization if memory debug option is enabled
    //
    MemDebugInit();


    return TRUE;
}


DHPDEV
DrvEnablePDEV(
    PDEVMODE  pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjGdiInfo,
    ULONG    *pGdiInfo,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    pdm - Points to a DEVMODEW structure that contains driver data
    pLogAddress - Points to the logical address string
    cPatterns - Specifies the number of standard patterns
    phsurfPatterns - Buffer to hold surface handles to standard patterns
    cjGdiInfo - Size of GDIINFO buffer
    pGdiInfo - Points to a GDIINFO structure
    cjDevInfo - Size of DEVINFO buffer
    pDevInfo - Points to a DEVINFO structure
    hdev - GDI device handle
    pDeviceName - Points to device name string
    hPrinter - Spooler printer handle

Return Value:

    Driver device handle, NULL if there is an error

--*/

{

    PDEV   *pPDev;
    RECTL   rcFormImageArea;
    DRVENABLEDATA       ded;        // for OEM customization support
    PDEVOEM             pdevOem;
    PFN_OEMEnablePDEV   pfnOEMEnablePDEV;

    VERBOSE(("Entering DrvEnablePDEV...\n"));

    ZeroMemory(phsurfPatterns, sizeof(HSURF) * cPatterns);

    //
    // Allocate PDEV,
    // Initializes binary data,
    // Get default binary data snapshot,
    //

    if (! (pPDev = PAllocPDEVData(hPrinter)) ||
        ! (pPDev->pDriverInfo3 = MyGetPrinterDriver(hPrinter, hdev, 3)) ||
        ! (pPDev->pRawData = LoadRawBinaryData(pPDev->pDriverInfo3->pDataFile)) ||
        ! (pPDev->pDriverInfo = PGetDefaultDriverInfo(hPrinter, pPDev->pRawData) ) ||
        ! (pPDev->pInfoHeader = pPDev->pDriverInfo->pInfoHeader) ||
        ! (pPDev->pUIInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loUIInfoOffset)) )
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // Must load OEM dll's before setting devmode
    //

    if( ! BLoadAndInitOemPlugins(pPDev) ||
        ! BInitWinResData(&pPDev->WinResData, pPDev->pDriverInfo3->pDriverPath, pPDev->pUIInfo) ||
        ! (pPDev->pOptionsArray = MemAllocZ(MAX_PRINTER_OPTIONS * sizeof(OPTSELECT))))

    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // Since output is expected to follow this call,  allocate storage
    // for the output buffer.  This used to be statically allocated
    // within UNIDRV's PDEV,  but now we can save that space for INFO
    // type DCs.
    //
    //  Not!  according to Bug 150881   StartDoc and EndDoc
    //  are optional calls, but pbOBuf is required.
    //

    if( !(pPDev->pbOBuf = MemAllocZ( CCHSPOOL )) )
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }



    //
    // Use the default binary data to validate input devmode
    // and merges with the system, devmode.
    // Get printer properties.
    // and loads minidriver resource data
    //

    if (! BGetPrinterProperties(pPDev->devobj.hPrinter, pPDev->pRawData, &pPDev->PrinterData) ||
        ! BMergeAndValidateDevmode(pPDev, pdm, &rcFormImageArea))
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // get updated binary snapshot with the validated/merged devmode
    //

    if (! (pPDev->pDriverInfo = PGetUpdateDriverInfo (
                                        pPDev,
                                        hPrinter,
                                        pPDev->pInfoHeader,
                                        pPDev->pOptionsArray,
                                        pPDev->pRawData,
                                        MAX_PRINTER_OPTIONS,
                                        pPDev->pdm,
                                        &pPDev->PrinterData)))
    {
        ERR(("PGetUpdateDriverInfo failed: %d\n", GetLastError()));
        pPDev->pInfoHeader = NULL ;   //  deleted by PGetUpdateDriverInfo
        //  better fix is to pass a pointer to pPDev->pInfoHeader so     PGetUpdateDriverInfo
        //  can update the pointer immediately.
        VFreePDEVData(pPDev);
        return NULL;
    }

    if(! (pPDev->pInfoHeader = pPDev->pDriverInfo->pInfoHeader) ||
        ! (pPDev->pUIInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loUIInfoOffset)) )

    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));
        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // pPDev->pUIInfo is reset so update the winresdata pUIInfo also.
    //
    pPDev->WinResData.pUIInfo = pPDev->pUIInfo;

    //
    // Initialize the rest of PDEV and GDIINFO, DEVINFO and
    // call the Font, Raster modules to
    // initialize their parts of the PDEVICE, GDIINFO and DEVINFO
    //  Palette initialization is done by control module.
    //

    //
    // This is necessary to initialize for FMInit.
    //

    pPDev->devobj.hEngine = hdev;
    pPDev->fHooks = HOOK_UNIDRV_FLAGS;

    if (! BInitPDEV(pPDev, &rcFormImageArea )           ||
        ! BInitGdiInfo(pPDev, pGdiInfo, cjGdiInfo)      ||
        ! BInitDevInfo(pPDev, pDevInfo, cjDevInfo)      ||
        ! RMInit(pPDev, pDevInfo, (PGDIINFO)pGdiInfo)   ||
        ! VMInit(pPDev, pDevInfo, (PGDIINFO)pGdiInfo)   ||
        ! BInitPalDevInfo(pPDev, pDevInfo, (PGDIINFO)pGdiInfo) ||
        ! FMInit(pPDev, pDevInfo, (PGDIINFO)pGdiInfo))
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    FTRACE(Tracing Palette);
    FVALUE((pDevInfo->flGraphicsCaps & GCAPS_ARBRUSHTEXT), 0x%x);


    ded.iDriverVersion = PRINTER_OEMINTF_VERSION;
    ded.c = sizeof(UniDriverFuncs) / sizeof(DRVFN);
    ded.pdrvfn = (DRVFN*) UniDriverFuncs;

    //
    // Call EnablePDEV for the vector plugins. 
    // Put the return value in (((PDEVOBJ)pPDev)->pdevOEM)
    //

    HANDLE_VECTORPROCS_RET(pPDev, VMEnablePDEV, (pPDev)->pVectorPDEV,
                                            ((PDEVOBJ) pPDev,
                                            pDeviceName,
                                            cPatterns,
                                            phsurfPatterns,
                                            cjGdiInfo,
                                            (GDIINFO *)pGdiInfo,
                                            cjDevInfo,
                                            (DEVINFO *)pDevInfo,
                                            &ded) ) ;

    //
    // If there is present a vector module and it exports EnablePDEV 
    // but its EnablePDEV has failed, then we cannot continue.
    //
    if ( pPDev->pVectorProcs && 
         ( (PVMPROCS)(pPDev->pVectorProcs) )->VMEnablePDEV &&
         !(pPDev->pVectorPDEV) 
       )
    {
        ERR(("Vector Module's EnablePDEV failed \n"));
        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // Call OEMEnablePDEV entrypoint for each OEM dll
    //
    START_OEMENTRYPOINT_LOOP(pPDev)

        if (pOemEntry->pIntfOem != NULL)
        {
            if (HComOEMEnablePDEV(pOemEntry,
                                  (PDEVOBJ)pPDev,
                                  pDeviceName,
                                  cPatterns,
                                  phsurfPatterns,
                                  cjGdiInfo,
                                  (GDIINFO *) pGdiInfo,
                                  cjDevInfo,
                                  (DEVINFO *) pDevInfo,
                                  &ded,
                                  &pOemEntry->pParam) == E_NOTIMPL)
                continue;

        }
        else
        {
            if ((pfnOEMEnablePDEV = GET_OEM_ENTRYPOINT(pOemEntry, OEMEnablePDEV)))
            {
                pOemEntry->pParam = pfnOEMEnablePDEV(
                                        (PDEVOBJ) pPDev,
                                        pDeviceName,
                                        cPatterns,
                                        phsurfPatterns,
                                        cjGdiInfo,
                                        (GDIINFO *) pGdiInfo,
                                        cjDevInfo,
                                        (DEVINFO *) pDevInfo,
                                        &ded);

            }
            else
                continue;

        }

        if (pOemEntry->pParam == NULL)
        {
            ERR(("OEMEnablePDEV failed for '%ws': %d\n",
                pOemEntry->ptstrDriverFile,
                GetLastError()));

            VFreePDEVData(pPDev);
            return NULL;
        }

        //
        // Add support for OEM's 8bpp multi-level color
        //
        if (((GDIINFO *)pGdiInfo)->ulHTOutputFormat == HT_FORMAT_8BPP &&
            ((GDIINFO *)pGdiInfo)->flHTFlags & HT_FLAG_8BPP_CMY332_MASK &&
            ((GDIINFO *)pGdiInfo)->flHTFlags & HT_FLAG_USE_8BPP_BITMASK)
        {
            VInitPal8BPPMaskMode(pPDev,(GDIINFO *)pGdiInfo);
        }
        pOemEntry->dwFlags |= OEMENABLEPDEV_CALLED;

#if 0
        //
        // in the extremely simple case, OEM dll may not need to create
        // a PDEV at all.
        //

        else // OEMEnablePDEV is not exported. Error!
        {
            ERR(("OEMEnablePDEV is not exported for '%ws'\n",
                 pOemEntry->ptstrDriverFile));

            VFreePDEVData(pPDev);
            return NULL;

        }

        //
        // for every OEM DLL, OEMDisablePDEV is also a required export.
        //
        if (!GET_OEM_ENTRYPOINT(pOemEntry, OEMDisablePDEV))
        {
            ERR(("OEMDisablePDEV is not exported for '%ws'\n",
                 pOemEntry->ptstrDriverFile));

            VFreePDEVData(pPDev);
            return NULL;

        }
#endif

    END_OEMENTRYPOINT_LOOP


    //
    // Unload and free binary data allocated by the parser.
    // Will need to reload at DrvEnableSurface
    //

    VUnloadFreeBinaryData(pPDev);

    return (DHPDEV) pPDev;
}


BOOL
DrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvResetPDEV.
    Please refer to DDK documentation for more details.

Arguments:

    phpdevOld - Driver handle to the old device
    phpdevNew - Driver handle to the new device

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    PPDEV    pPDevOld, pPDevNew;
    PFN_OEMResetPDEV    pfnOEMResetPDEV;
    POEM_PLUGIN_ENTRY   pOemEntryOld;
    BOOL    bResult = TRUE;

    VERBOSE(("Entering DrvResetPDEV...\n"));

    pPDevOld = (PDEV *) dhpdevOld;
    pPDevNew = (PDEV *) dhpdevNew;

    ASSERT_VALID_PDEV(pPDevOld);
    ASSERT_VALID_PDEV(pPDevNew);

    //
    // Carry relevant information from old pdev to new pdev
    // BUG_BUG, what other information should we carry over here ?
    //

    //
    // Set the PF_SEND_ONLY_NOEJECT_CMDS flag if the only
    // thing that changed between the old and new devmode
    // require only commands that do not cause a page ejection.
    //

    //
    // Don't need to resend the page initialization iff
    // The Document has started printing AND
    // The device support DUPLEX AND
    // The Duplex option selected is DM_DUPLEX AND
    // The previous duplex option matches the current duplex option AND
    // The Paper Size, Paper Source , and Orientation is the same
    //  Due to unloading of rawbinary data and snapshot,    pPDevNew->pDuplex
    //  and other related fields are null at this time.  must use devmode.
    //



    if( (pPDevOld->fMode & PF_DOCSTARTED) &&
        (pPDevNew->pdm->dmFields & DM_DUPLEX) &&
        (pPDevOld->pdm->dmFields & DM_DUPLEX) &&
        (pPDevNew->pdm->dmDuplex != DMDUP_SIMPLEX)  &&
        (pPDevNew->pdm->dmDuplex == pPDevOld->pdm->dmDuplex) )
    {
        BOOL     bUseNoEjectSubset = TRUE ;
        COMMAND    *pSeqCmd;
        DWORD       dwCmdIndex ;

        if (!BPaperSizeSourceSame(pPDevNew,pPDevOld))
            bUseNoEjectSubset = FALSE ;

        //
        // if  orientation command is  not NO_PageEject
        //
        if( bUseNoEjectSubset  &&
            (pPDevNew->pdm->dmFields & DM_ORIENTATION) &&
             (pPDevOld->pdm->dmFields & DM_ORIENTATION) &&
             (pPDevNew->pdm->dmOrientation != pPDevOld->pdm->dmOrientation) &&
             pPDevOld->pOrientation   &&
             ((dwCmdIndex = pPDevOld->pOrientation->GenericOption.dwCmdIndex)  != UNUSED_ITEM) &&
             (pSeqCmd = INDEXTOCOMMANDPTR(pPDevOld->pDriverInfo, dwCmdIndex)) &&
             !(pSeqCmd->bNoPageEject))
                    bUseNoEjectSubset = FALSE ;

        //
        //  if  colormode command is  not NO_PageEject
        //
        if( bUseNoEjectSubset  &&
            (pPDevNew->pdm->dmFields & DM_COLOR) &&
             (pPDevOld->pdm->dmFields & DM_COLOR) &&
             (pPDevNew->pdm->dmColor != pPDevOld->pdm->dmColor)  &&
             pPDevOld->pColorMode   &&
             ((dwCmdIndex = pPDevOld->pColorMode->GenericOption.dwCmdIndex)  != UNUSED_ITEM)  &&
             (pSeqCmd = INDEXTOCOMMANDPTR(pPDevOld->pDriverInfo, dwCmdIndex)) &&
             !(pSeqCmd->bNoPageEject))
                    bUseNoEjectSubset = FALSE ;

        //check all other doc properties if you want:
        if(bUseNoEjectSubset)
            pPDevNew->fMode |= PF_SEND_ONLY_NOEJECT_CMDS;
    }

    //
    //  if Job commands already sent, don't send them again.
    //
    if( pPDevOld->fMode & PF_JOB_SENT)
        pPDevNew->fMode |= PF_JOB_SENT;

    //
    //  if Doc commands already sent, don't send them again.
    //
    if( pPDevOld->fMode & PF_DOC_SENT)
        pPDevNew->fMode |= PF_DOC_SENT;

    pPDevNew->dwPageNumber   =  pPDevOld->dwPageNumber  ;
    //  preserve pageNumber across ResetDC.

    //
    // Call Raster and Font module to carry over their stuff from old
    // pPDev to new pPDev
    //

    if (!(((PRMPROCS)(pPDevNew->pRasterProcs))->RMResetPDEV(pPDevOld, pPDevNew)) ||
        !(((PFMPROCS)(pPDevNew->pFontProcs))->FMResetPDEV(pPDevOld, pPDevNew)))   
    {
        bResult = FALSE;
    }
    
    // 
    // Also call the vector module.
    //
    if ( pPDevOld->pVectorProcs )
    {
        pPDevOld->devobj.pdevOEM = pPDevOld->pVectorPDEV;
        HANDLE_VECTORPROCS_RET( pPDevNew, VMResetPDEV, bResult,
                                            ((PDEVOBJ) pPDevOld,
                                            (PDEVOBJ) pPDevNew ) ) ;
    }

    //
    // Call OEMResetPDEV entrypoint
    //

    ASSERT(pPDevNew->pOemPlugins);
    ASSERT(pPDevOld->pOemPlugins);

    START_OEMENTRYPOINT_LOOP(pPDevNew)

        pOemEntryOld = PFindOemPluginWithSignature(pPDevOld->pOemPlugins,
                                                       pOemEntry->dwSignature);

        if (pOemEntryOld != NULL)
        {
            pPDevOld->devobj.pdevOEM = pOemEntryOld->pParam;
            pPDevOld->devobj.pOEMDM = pOemEntryOld->pOEMDM;

            if (pOemEntry->pIntfOem != NULL)
            {
                HRESULT hr;

                hr = HComOEMResetPDEV(pOemEntry,
                                      (PDEVOBJ)pPDevOld,
                                      (PDEVOBJ)pPDevNew);

                if (hr == E_NOTIMPL)
                    continue;

                if (FAILED(hr))
                {
                    ERR(("OEMResetPDEV failed for '%ws': %d\n",
                        pOemEntry->ptstrDriverFile,
                        GetLastError()));

                    bResult = FALSE;
                }

            }
            else
            {
                if (!(pfnOEMResetPDEV = GET_OEM_ENTRYPOINT(pOemEntry, OEMResetPDEV)))
                    continue;

                if (! pfnOEMResetPDEV((PDEVOBJ) pPDevOld, (PDEVOBJ) pPDevNew))
                {
                    ERR(("OEMResetPDEV failed for '%ws': %d\n",
                        pOemEntry->ptstrDriverFile,
                        GetLastError()));

                    bResult = FALSE;
                }
            }
        }
    END_OEMENTRYPOINT_LOOP

    return bResult;
}


HSURF
DrvEnableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    Handle to newly created surface, NULL if there is an error

--*/

{

    HSURF     hSurface;         // Handle to the surface
    HBITMAP   hBitmap;          // The bitmap handle
    SIZEL     szSurface;        // Device surface size
    INT       iFormat;          // Bitmap format
    ULONG     cbScan;           // Scan line byte length (DWORD aligned)
    int       iBPP;             // Bits per pel, as # of bits
    int       iPins;            // Basic rounding factor for banding size
    PDEV      *pPDev = (PDEV*)dhpdev;
    DWORD     dwNumBands;       // Number of bands to use

    PFN_OEMDriverDMS  pfnOEMDriverDMS;
    DWORD     dwHooks = 0, dwHooksSize = 0; // used to query what kind of surface should be created
    POEM_PLUGINS    pOemPlugins; // OEM Plugin Module
    PTSTR           ptstrDllName;

    DEVOBJ  DevObj;
    BOOL    bReturn = FALSE;

    VERBOSE(("Entering DrvEnableSurface...\n"));

    //
    // Reloads the binary data and reinit the offsets and pointers
    // to binary data
    //

    if (!BReloadBinaryData(pPDev))
        return NULL;

    //
    // BUG_BUG, Need to put test code here to force banding for testing purposes
    //

    szSurface.cx = pPDev->sf.szImageAreaG.cx;
    szSurface.cy = pPDev->sf.szImageAreaG.cy;

    iBPP = pPDev->sBitsPixel;

    switch (pPDev->sBitsPixel)
    {
        case 1:
            iFormat = BMF_1BPP;
            break;
        case 4:
            iFormat = BMF_4BPP;
            break;
        case 8:
            iFormat = BMF_8BPP;
            break;
        case 24:
            iFormat = BMF_24BPP;
            break;
        default:
            ERR(("Unknown sBitsPixels in DrvEnableSurface"));
            break;
    }

    //
    // Time to allocate surface bitmap
    DevObj = pPDev->devobj;
    //

    //
    // First call Vector pseudo-plugin
    //
    HANDLE_VECTORPROCS_RET( pPDev, VMDriverDMS, bReturn,
                                        ((PDEVOBJ) pPDev,
                                        &dwHooks,
                                        sizeof(DWORD),
                                        &dwHooksSize) ) ;
    {
        if ( bReturn && dwHooks)
            pPDev->fMode |= PF_DEVICE_MANAGED;
        else
            pPDev->fMode &= ~PF_DEVICE_MANAGED;
    }


                        
    // Call OEMGetInfo to find out if the Oem wants to create
    // a bitmap surface or a device surface
    pOemPlugins = pPDev->pOemPlugins;
    if (pOemPlugins->dwCount > 0)
    {
        //
        // Before the HANDLE_VECTORPROCS_RET was placed above, it made sense to initialize
        // dwHooks. But now we dont want to reinitialize it. 
        //
        // dwHooks = 0;
        dwHooksSize = 0;
        START_OEMENTRYPOINT_LOOP(pPDev)

        VERBOSE(("Getting the OEMDriverDMS address\n"));

            if (pOemEntry->pIntfOem != NULL)
            {
                HRESULT hr;

                hr = HComDriverDMS(pOemEntry,
                                      (PDEVOBJ)pPDev,
                                      &dwHooks,
                                      sizeof(DWORD),
                                      &dwHooksSize);
                //
                // We need to explicitly check for E_NOTIMPL. SUCCEEDED macro
                // will fail for this error.
                // 
                if (hr == E_NOTIMPL)
                    continue;

                if(!SUCCEEDED(hr))
                {
                    WARNING(("OEMDriverDMS returned FALSE '%ws': ErrorCode = %d\n",
                         pOemEntry->ptstrDriverFile,
                         GetLastError()));
                    dwHooks = 0;

                }
                if (dwHooks)
                   pPDev->fMode |= PF_DEVICE_MANAGED;
                else
                   pPDev->fMode &= ~PF_DEVICE_MANAGED;


            }

            else
            {
                if ((pfnOEMDriverDMS = GET_OEM_ENTRYPOINT(pOemEntry, OEMDriverDMS)))
                {
                    bReturn = pfnOEMDriverDMS((PDEVOBJ)pPDev,
                                      &dwHooks,
                                      sizeof(DWORD),
                                      &dwHooksSize);

                    if (bReturn == FALSE)
                    {
                        WARNING(("OEMDriverDMS returned FALSE '%ws': ErrorCode = %d\n",
                             pOemEntry->ptstrDriverFile,
                             GetLastError()));
                        dwHooks = 0;

                    }
                    if (dwHooks)
                       pPDev->fMode |= PF_DEVICE_MANAGED;
                    else
                       pPDev->fMode &= ~PF_DEVICE_MANAGED;
                }
            }


        END_OEMENTRYPOINT_LOOP
    }


    //
    // If the OEM Plugin Module wants a device managed surface
    // (from OEMGetInfo) - then create it.
    // Otherwise a bitmap surface is created. Note: Banding must be
    // turned off for a device surface.
    //
    if (DRIVER_DEVICEMANAGED (pPDev))   // device surface
    {
        VERBOSE(("DrvEnableSurface: creating a DEVICE surface.\n"));

        //
        // Hack for monochrome HPGL2 pseudo-plugin driver.
        // The gpd indicates the driver is monochrome, but the plugin wants the 
        // driver surface to be 24bpp color. Even though the rendering is done in monochrome,
        // but the plugin wants GDI to send it all color information. So it wants destination 
        // surface to be declared color surface. Putting color information in gpd, though simple,
        // breaks backward compatibility (e.g. if new gpd is used with old unidrv). Therefore
        // this hack. If the personality in gpd is hpgl2 and the VectorProc structure is
        // initialized (which means that Graphics Mode has been chosen as HP-GL/2 from the UI),
        // then we assume we are printing to monochrome HPGL printer.
        // Therefore for plugin's happiness we create the device managed surface 
        // as 24bpp. 
        // Question: This creates a wierd situation, where the surface is color, but 
        // unidrv thinks it is monochrome and creates palette accordingly.
        // Answer: Since all the rendering is done by the plugin and unidrv is not used,
        // I think we should be ok.
        //
        if ((pPDev->ePersonality == kHPGL2 ||
             pPDev->ePersonality == kPCLXL ) &&
             pPDev->pVectorProcs != NULL   &&
             iFormat == BMF_1BPP)
        {
            hSurface = HCreateDeviceSurface (pPDev, BMF_24BPP);
        }
        else 
        {
            hSurface = HCreateDeviceSurface (pPDev, iFormat);
        }

        // if we can't create the surface fail the call.

        if (!hSurface)
        {
            ERR(("Unidrv!DrvEnableSurface:HCreateBitmapSurface  Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }

        pPDev->hSurface = hSurface;
        pPDev->hbm = NULL;
        pPDev->pbScanBuf = NULL; // Don't need this buffer
    }
    else   // bitmap surface
    {
        //
        // Create a surface.   Try for a bitmap for the entire surface.
        // If this fails,  then switch to journalling and a somewhat smaller
        // surface.   If journalling,  we still create the bitmap here.  While
        // it is nicer to do this at DrvSendPage() time,  we do it here to
        // ensure that it is possible.  By maintaining the bitmap for the
        // life of the DC,  we can be reasonably certain of being able to
        // complete printing regardless of how tight memory becomes later.
        //
        VERBOSE(("DrvEnableSurface: creating a BITMAP surface.\n"));
        hBitmap = HCreateBitmapSurface (pPDev, iFormat);

        // if we can't create the bitmap fail the call.
        if (!hBitmap)
        {
            ERR(("Unidrv!DrvEnableSurface:HCreateBitmapSurface  Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }

        //
        // We will always use szBand to describe the bitmap surface, a band
        // could be the whole page or a part of a page.
        //

        //
        // Allocate array to represent the page in scanlines,
        // for z-ordering fix
        //

        if( (pPDev->pbScanBuf = MemAllocZ(pPDev->szBand.cy)) == NULL)
        {
            VDisableSurface( pPDev );
            return  NULL;
        }
        //
        // Allocate array to represents the page in scanlines, for erasing surface
        //

        if( (pPDev->pbRasterScanBuf = MemAllocZ((pPDev->szBand.cy / LINESPERBLOCK)+1)) == NULL)
        {
            VDisableSurface( pPDev );
            return  NULL;
        }
#ifndef DISABLE_NEWRULES
        //
        // Allocate array to store black rectangle optimization
        // Device must support rectangle commands and unidrv must dump the raster
        //
        if ((pPDev->fMode & PF_RECT_FILL) && 
            !(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS) &&
            !(pPDev->fMode2 & PF2_MIRRORING_ENABLED) &&
            ((COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)) ||
             (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL)) ||
             !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL))) &&
            (pPDev->pColorModeEx == NULL || pPDev->pColorModeEx->dwPrinterBPP))
        {
            if( (pPDev->pbRulesArray = MemAlloc(sizeof(RECTL) * MAX_NUM_RULES)) == NULL)
            {
                VDisableSurface( pPDev );
                return  NULL;
            }
        }
        else
            pPDev->pbRulesArray = NULL;
#endif
        pPDev->dwDelta = pPDev->szBand.cx / MAX_COLUMM;

        pPDev->hbm = hBitmap;
        pPDev->hSurface = NULL;

    }

    //
    // Call Raster and Font module EnableSurface for surface intialization
    //

    if ( !(((PRMPROCS)(pPDev->pRasterProcs))->RMEnableSurface(pPDev)) ||
         !(((PFMPROCS)(pPDev->pFontProcs))->FMEnableSurface(pPDev)) )
    {
        VDisableSurface( pPDev );
        return  NULL;
    }

    //
    // Now need to associate this surface with the pdev passed in at
    // DrvCompletePDev time.
    // Note: BUG_BUG, The RMInit() and FMInit() calls should have
    // initialized the pPDev->fHooks already.  All we need to do here is use it
    //

    ASSERT(pPDev->fHooks != 0);

    if (DRIVER_DEVICEMANAGED (pPDev))   // device surface
    {
        pPDev->fHooks = dwHooks;
        EngAssociateSurface (hSurface, pPDev->devobj.hEngine, pPDev->fHooks);
        return hSurface;
    }
    else
    {
#ifdef DISABLEDEVSURFACE
        EngAssociateSurface( (HSURF)hBitmap, pPDev->devobj.hEngine, pPDev->fHooks );
        pPDev->pso = EngLockSurface( (HSURF)hBitmap);
        if (pPDev->pso == NULL)
        {
            ERR(("Unidrv!DrvEnableSurface:EngLockSurface Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }
        return (HSURF)hBitmap;

#else
        HSURF hSurface;
        SIZEL szSurface;

        EngAssociateSurface( (HSURF)hBitmap, pPDev->devobj.hEngine, 0 );
        pPDev->pso = EngLockSurface( (HSURF)hBitmap);
        if (pPDev->pso == NULL)
        {
            ERR(("Unidrv!DrvEnableSurface:EngLockSurface Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }
        //
        // Create a device surface to make sure GDI always calls the driver first
        // for any drawing
        //
        hSurface = EngCreateDeviceSurface((DHSURF)pPDev, pPDev->szBand, iFormat);
        if (!hSurface)
        {
            ERR(("Unidrv!DrvEnableSurface:EngCreateDeviceSurface Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }
        // If banding is enabled mark the device surface as a banding surface
        //
        if (pPDev->bBanding)
            EngMarkBandingSurface(hSurface);

        pPDev->hSurface = hSurface;

        EngAssociateSurface( (HSURF)hSurface, pPDev->devobj.hEngine, pPDev->fHooks );

        return (HSURF)hSurface;
#endif
    }
}


VOID
DrvDisableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{

    VERBOSE(("Entering DrvDisableSurface...\n"));

    VDisableSurface( (PDEV *)dhpdev );

}


VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisablePDEV.
    Please refer to DDK documentation for more details.

    Free up all memory allocated for PDEV

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{

    PDEV    *pPDev = (PDEV *) dhpdev;

    VERBOSE(("Entering DrvDisablePDEV...\n"));

    if (!VALID_PDEV(pPDev))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return;
    }

//    ASSERT_VALID_PDEV(pPDev);

    //
    // Free up resources associated with the PDEV
    //

    FlushSpoolBuf( pPDev );  //  may need to do this per bug 250963
    VFreePDEVData(pPDev);

    #if DBG && defined(MEMDEBUG)

    //
    // If memory debug option is enabled, perform memory consistency check.
    // You can enable this during private testing to look for memory leaks.
    //

    if (giDebugLevel == 0)
        MemDebugCheck();

    #endif //DBG && defined(MEMDEBUG)

}

VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    //
    // Free everything that is allocated at DrvEnableDriver
    //

    VERBOSE(("Entering DrvDisableDriver...\n"));

    #if ENABLE_STOCKGLYPHSET
    EngAcquireSemaphore(hGlyphSetSem);
    FreeGlyphSet();
    EngReleaseSemaphore(hGlyphSetSem);
    EngDeleteSemaphore(hGlyphSetSem) ;
    #endif

    #ifdef WINNT_40

    ENTER_CRITICAL_SECTION();

        VFreePluginRefCountList(&gpOEMPluginRefCount);

    LEAVE_CRITICAL_SECTION();

    DELETE_CRITICAL_SECTION();

    #endif  // WINNT_40

    return;

}

VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCompletePDEV.
    Please refer to DDK documentation for more details.

    This function is called when the engine completed the installation of
    the physical device, some Engine functions requires the engine hdev as
    a parameter, so we save it in our PDEVICE for later use.

Arguments:

    dhpdev - Driver device handle
    hdev - GDI device handle

Return Value:

    NONE

--*/

{
    PDEV    *pPDev = (PDEV *) dhpdev;

    VERBOSE(("Entering DrvCompletePDEV...\n"));

    if (!VALID_PDEV(pPDev))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return;
    }
//    ASSERT_VALID_PDEV(pPDev);

    pPDev->devobj.hEngine = hdev;

}



PPDEV
PAllocPDEVData(
    HANDLE hPrinter
    )

/*++

Routine Description:

    Allocate a new PDEV structure

Arguments:

    hPrinter - handle to the current printer

Return Value:

    Pointer to newly allocated PDEV structure,
    NULL if there is an error

--*/

{
    PDEV  *pPDev;

    //
    // Allocate a zero-init PDEV structure and
    // mark the signature fields
    //

    ASSERT(hPrinter != NULL);

    if ((pPDev = MemAllocZ(sizeof(PDEV))) != NULL)
    {
        pPDev->pvStartSig = pPDev->pvEndSig = (PVOID) pPDev;
        pPDev->devobj.dwSize = sizeof(DEVOBJ);
        pPDev->devobj.hPrinter = hPrinter;
        //
        // set up pPDev->devobj.pPublicDM after pPDev->pdm has been set up
        // (init.c)
        //
        pPDev->ulID = PDEV_ID;
    }
    else
        ERR(("PAllocPDEVData: Memory allocation failed: %d\n", GetLastError()));

    return pPDev;
}


VOID
VFreePDEVData(
    PDEV    * pPDev
    )

/*++

Routine Description:

    Dispose of a PDEV structure

Arguments:

    pPDev - Pointer to a previously allocated PDEV structure

Return Value:

    NONE

--*/

{
    if (pPDev == NULL)
        return;

    VUnloadOemPlugins(pPDev);

    //
    // Call parser to free memory allocated for binary data
    //

    VUnloadFreeBinaryData(pPDev);

    //
    // Free other memory allocated for PDEV
    //

    if(pPDev->pSplForms)
    {
        MemFree(pPDev->pSplForms);
        pPDev->pSplForms = NULL ;
    }

    //
    //   Free the output buffer
    //

    if(pPDev->pbOBuf )
    {
        MemFree(pPDev->pbOBuf);
        pPDev->pbOBuf = NULL;
    }



    if (pPDev->pOptionsArray)
        MemFree(pPDev->pOptionsArray);

    //Unload Unidrv Module Handle, loaded for Unidrv resources
    if (pPDev->hUniResDLL)
        EngFreeModule(pPDev->hUniResDLL);
    //
    // Call Raster and Font module to clean up at DrvDisablePDEV
    //

    if (pPDev->pRasterProcs)
    {
        ((PRMPROCS)(pPDev->pRasterProcs))->RMDisablePDEV(pPDev);
    }

    if (pPDev->pFontProcs)
    {
        ((PFMPROCS)(pPDev->pFontProcs))->FMDisablePDEV(pPDev);
    }

    HANDLE_VECTORPROCS( pPDev, VMDisablePDEV, ((PDEVOBJ) pPDev)) ;
    HANDLE_VECTORPROCS( pPDev, VMDisableDriver, ()) ;

    //
    // Free the Palette data
    //
    if (pPDev->pPalData)
    {
        //
        // Free the Palette
        //
        if ( ((PAL_DATA *)pPDev->pPalData)->hPalette )
            EngDeletePalette( ((PAL_DATA *)pPDev->pPalData)->hPalette );

        if (((PAL_DATA*)(pPDev->pPalData))->pulDevPalCol)
            MemFree(((PAL_DATA*)(pPDev->pPalData))->pulDevPalCol);

        MemFree(pPDev->pPalData);
        pPDev->pPalData = NULL;
    }

    //
    // Free Resource Data
    //

    VWinResClose(&pPDev->WinResData);
    //  VWinResClose(&pPDev->localWinResData);

    //
    // Free devmode data
    //

    MemFree(pPDev->pdm);

    MemFree(pPDev->pDriverInfo3);

    if (pPDev->pbScanBuf)    // may be NULL for a device surface
    {
        MemFree(pPDev->pbScanBuf);
    }

    if (pPDev->pbRasterScanBuf)
    {
        MemFree(pPDev->pbRasterScanBuf);
    }
#ifndef DISABLE_NEWRULES
    if (pPDev->pbRulesArray)
    {
        MemFree(pPDev->pbRulesArray);
    }
#endif
    //
    // Free cached patterns
    //

    MemFree(pPDev->GState.pCachedPatterns);


    //
    // Free the PDEV structure itself
    //

    MemFree(pPDev);

}

HSURF
HCreateDeviceSurface(
    PDEV    * pPDev,
    INT       iFormat
    )

/*++

Routine Description:

    Creates a device surface and returns a handle that the driver
    will manage.

Arguments:

    pPDev - Pointer to PDEV structure
    iFormat - pixel depth of the device

Return Value:

    Handle to the surface if successful, NULL otherwise

--*/

{
    HSURF hSurface;
    SIZEL szSurface;

    ASSERT_VALID_PDEV(pPDev);

    szSurface.cx = pPDev->sf.szImageAreaG.cx;
    szSurface.cy = pPDev->sf.szImageAreaG.cy;

    hSurface = EngCreateDeviceSurface((DHSURF)pPDev, szSurface, iFormat);
    if (hSurface == NULL)
    {
        ERR(("EngCreateDeviceSurface failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return NULL;
    }

    pPDev->rcClipRgn.top = 0;
    pPDev->rcClipRgn.left = 0;
    pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
    pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;

    pPDev->bBanding = FALSE;

    pPDev->szBand.cx = szSurface.cx;
    pPDev->szBand.cy = szSurface.cy;

    return hSurface;
}

HBITMAP
HCreateBitmapSurface(
    PDEV    * pPDev,
    INT       iFormat
    )

/*++

Routine Description:

    Creates a bitmap surface and returns a handle that the driver
    will manage.

Arguments:

    pPDev - Pointer to PDEV structure
    iFormat - pixel depth of the device

Return Value:

    Handle to the bitmap if successful, NULL otherwise

--*/

{
    SIZEL     szSurface;
    HBITMAP   hBitmap;
    ULONG     cbScan;           // Scan line byte length (DWORD aligned)
    DWORD     dwNumBands;       // Number of bands to use
    int       iBPP;             // Bits per pel, as # of bits
    int       iPins;            // Basic rounding factor for banding size
    PFN_OEMMemoryUsage pfnOEMMemoryUsage;
    DWORD     dwMaxBandSize;     // Maximum size of band to use

    szSurface.cx = pPDev->sf.szImageAreaG.cx;
    szSurface.cy = pPDev->sf.szImageAreaG.cy;

    iBPP = pPDev->sBitsPixel;

    //
    // define the maximum size bitmap band we will allow
    //
    dwMaxBandSize = MAX_SIZE_OF_BITMAP;

    //
    // adjust the maximum size of the bitmap buffer based on
    // the amount of memory used by the OEM driver.
    //
    if (pPDev->pOemHookInfo && (pfnOEMMemoryUsage = (PFN_OEMMemoryUsage)pPDev->pOemHookInfo[EP_OEMMemoryUsage].pfnHook))
    {
        OEMMEMORYUSAGE MemoryUsage;
        MemoryUsage.dwPercentMemoryUsage = 0;
        MemoryUsage.dwFixedMemoryUsage = 0;
        MemoryUsage.dwMaxBandSize = dwMaxBandSize;
        FIX_DEVOBJ(pPDev,EP_OEMMemoryUsage);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                    HRESULT  hr ;
                    hr = HComMemoryUsage((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                (PDEVOBJ)pPDev,&MemoryUsage);
                    if(SUCCEEDED(hr))
                        ;  //  cool !
            }
            else
            {
                pfnOEMMemoryUsage((PDEVOBJ)pPDev,&MemoryUsage);
            }
        }


        dwMaxBandSize = ((dwMaxBandSize - MemoryUsage.dwFixedMemoryUsage) * 100) /
            (100 + MemoryUsage.dwPercentMemoryUsage);
    }
    if (dwMaxBandSize < (MIN_SIZE_OF_BITMAP*2L))
        dwMaxBandSize = MIN_SIZE_OF_BITMAP*2L;

    //
    // Create a surface.   Try for a bitmap for the entire surface.
    // If this fails,  then switch to journalling and a somewhat smaller
    // surface.   If journalling,  we still create the bitmap here.  While
    // it is nicer to do this at DrvSendPage() time,  we do it here to
    // ensure that it is possible.  By maintaining the bitmap for the
    // life of the DC,  we can be reasonably certain of being able to
    // complete printing regardless of how tight memory becomes later.
    //
    cbScan = ((szSurface.cx * iBPP + DWBITS - 1) & ~(DWBITS - 1)) / BBITS;

    //
    // Determine the number of bands to use based on the max size of
    // a band.
    //
    dwNumBands = ((cbScan * szSurface.cy) / dwMaxBandSize)+1;

    //
    // Test registry for forced number of bands for testing
    //
#if DBG
    {
        DWORD dwType;
        DWORD ul;
        int   RegistryBands;
        if( !GetPrinterData( pPDev->devobj.hPrinter, L"Banding", &dwType,
                       (BYTE *)&RegistryBands, sizeof( RegistryBands ), &ul ) &&
             ul == sizeof( RegistryBands ) )
        {
            /*   Some sanity checking:  if iShrinkFactor == 0, disable banding */
            if (RegistryBands > 0)
                dwNumBands = RegistryBands;
        }
    }
#endif
#ifdef BANDTEST
    //
    // Test code for forcing number of bands via GPD
    //
    if (pPDev->pGlobals->dwMaxNumPalettes > 0)
        dwNumBands = pPDev->pGlobals->dwMaxNumPalettes;
#endif

    //
    // Time to allocate surface bitmap
    //
    if (dwNumBands > 1 || pPDev->fMode & PF_FORCE_BANDING ||
        pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER  ||
        !(hBitmap = EngCreateBitmap( szSurface, (LONG) cbScan, iFormat, BMF_TOPDOWN|
BMF_NOZEROINIT|BMF_USERMEM, NULL )) )
    {
        //
        // The bitmap creation failed,  so we will try for smaller ones
        // until we find one that is OK OR we cannot create one with
        // enough scan lines to be useful.
        //

        //
        // Calculate the rounding factor for band shrink operations.
        // Basically this is to allow more effective use of the printer,
        // by making the bands a multiple of the number of pins per
        // pass.  In interlaced mode, this is the number of scan lines
        // in the interlaced band, not the number of pins in the print head.
        // For single pin printers,  make this a multiple of 8.  This
        // speeds up processing a little.
        //
        // If this is 1bpp we need to make the band size a multiple of the halftone
        // pattern to avoid a certain GDI bug where it doesn't correctly align
        // a pattern brush at the beginning of each band.
        //
        if (iBPP == 1 && pPDev->pResolutionEx->dwPinsPerLogPass == 1)
        {
            INT iPatID;
            if (pPDev->pHalftone)
                iPatID = pPDev->pHalftone->dwHTID;
            else
                iPatID= HT_PATSIZE_AUTO;
            if (iPatID == HT_PATSIZE_AUTO)
            {
                INT dpi = pPDev->ptGrxRes.x;
                if (dpi > pPDev->ptGrxRes.y)
                    dpi = pPDev->ptGrxRes.y;
                if (dpi >= 2400)    // 16x16 pattern
                    iPins = 16;
                else if (dpi >= 1800) // 14x14 pattern
                    iPins = 56;
                else if (dpi >= 1200) // 12x12 pattern
                    iPins = 24;
                else if (dpi >= 800)  // 10x10 pattern
                    iPins = 40;
                else
                    iPins = 8;
            }
            else if (iPatID == HT_PATSIZE_6x6_M || iPatID == HT_PATSIZE_12x12_M)
                iPins = 24;
            else if (iPatID == HT_PATSIZE_10x10_M)
                iPins = 40;
            else if (iPatID == HT_PATSIZE_14x14_M)
                iPins = 56;
            else if (iPatID == HT_PATSIZE_16x16_M)
                iPins = 16;
            else
                iPins = 8;
        }
        else
            iPins = (pPDev->pResolutionEx->dwPinsPerLogPass + BBITS - 1) & ~(BBITS - 1);

        if (dwNumBands <= 1)
            dwNumBands = SHRINK_FACTOR;

        while (1)
        {
            //
            // Shrink the bitmap each time around.  Note that we are
            // rotation sensitive.  In portrait mode,  we shrink the
            // Y coordinate, so that the bands fit across the page.
            // In landscape when we rotate,  shrink the X coordinate, since
            // that becomes the Y coordinate after transposing.
            //
            if( pPDev->fMode & PF_ROTATE )
            {
                //
                //   We rotate the bitmap, so shrink the X coordinates.
                //

                szSurface.cx = pPDev->sf.szImageAreaG.cx / dwNumBands;
                if( szSurface.cx < iPins)
                    return NULL;
                szSurface.cx += iPins - (szSurface.cx % iPins);
                cbScan = ((szSurface.cx * iBPP + DWBITS - 1) & ~(DWBITS - 1)) / BBITS;
            }
            else
            {
                //
                //  Normal operation,  so shrink the Y coordinate.
                //

                szSurface.cy = pPDev->sf.szImageAreaG.cy / dwNumBands;
                if( szSurface.cy < iPins)
                    return NULL;
                szSurface.cy += iPins - (szSurface.cy % iPins);
            }
            dwNumBands *= SHRINK_FACTOR;

            //
            // Try to allocate the bitmap surface
            //

            if (hBitmap = EngCreateBitmap( szSurface, (LONG) cbScan, iFormat, BMF_TOPDOWN|BMF_NOZEROINIT|BMF_USERMEM, NULL ))
                break;

            //
            // if we failed to allocate the bitmap surface we will give up
            // at some point if the band becomes too small
            //
            if ((cbScan * szSurface.cy / 2) < MIN_SIZE_OF_BITMAP)
                return NULL;
        }
        //
        // Success so mark the surface for banding
        //
#ifdef DISABLEDEVSURFACE
        EngMarkBandingSurface((HSURF)hBitmap);
#endif
        pPDev->bBanding = TRUE;
    }
    else
    {
        //
        // The speedy way: into a big bitmap.  Set the clipping region
        // to full size,  and the journal handle to 0.
        //

        pPDev->rcClipRgn.top = 0;
        pPDev->rcClipRgn.left = 0;
        pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
        pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;

        pPDev->bBanding = FALSE;
    }

    pPDev->szBand.cx = szSurface.cx;
    pPDev->szBand.cy = szSurface.cy;
    return hBitmap;
}

VOID
VDisableSurface(
    PDEV    * pPDev
    )

/*++

Routine Description:

    Clean up resources allocated at DrvEnableSurface and
    call Raster and Font module to clean up their internal data
    and deallocated memory associated with the surface

Arguments:

    pPDev - Pointer to PDEV structure

Return Value:

    NONE

--*/

{

    //
    // Call the Raster and Font module to free
    // rendering storage, position sorting memory etc.
    //

    ((PRMPROCS)(pPDev->pRasterProcs))->RMDisableSurface(pPDev);
    ((PFMPROCS)(pPDev->pFontProcs))->FMDisableSurface(pPDev);


    //
    // Delete the surface
    //

    if( pPDev->hbm )
    {
        //
        // unlock surface first if necessary
        //
        if (pPDev->pso)
        {
            EngUnlockSurface(pPDev->pso);
            pPDev->pso = NULL;
        }
        EngDeleteSurface( (HSURF)pPDev->hbm );
        pPDev->hbm = (HBITMAP)0;
    }

    if (pPDev->hSurface)
    {
        EngDeleteSurface (pPDev->hSurface);
        pPDev->hSurface = NULL;
    }

}


BOOL
BPaperSizeSourceSame(
    PDEV    * pPDevNew,
    PDEV    * pPDevOld
    )

/*++

Routine Description:

    This function check for the following condition:
    - paper size and souce has not changed.

Arguments:

    pPDevNew - Pointer to the new PDEV
    pPDevOld - Pointer to the old PDEV

Return Value:

    TRUE if both are unchanged, otherwise FALSE

--*/
{

//    if (pPDevNew->pdm->dmOrientation == pPDevOld->pdm->dmOrientation)
//        return FALSE;

    //
    // Check paper size, Note PDEVICE->pf.szPhysSize is in Portrait mode.
    //

    return (pPDevNew->pf.szPhysSizeM.cx == pPDevOld->pf.szPhysSizeM.cx &&
            pPDevNew->pf.szPhysSizeM.cy == pPDevOld->pf.szPhysSizeM.cy &&
            pPDevNew->pdm->dmDefaultSource == pPDevOld->pdm->dmDefaultSource
            );

}

BOOL
BMergeFormToTrayAssignments(
    PDEV    * pPDev
    )

/*++

Routine Description:

    This function reads the form to tray table and merges the values in the devmode.
Arguments:

    pPDev - Pointer to the PDEV


Return Value:

    TRUE for success, otherwise FALSE

--*/

{
    PFEATURE            pInputSlotFeature;
    DWORD               dwInputSlotIndex, dwIndex;
    POPTION             pOption;
    FORM_TRAY_TABLE     pFormTrayTable = NULL;
    PUIINFO             pUIInfo = pPDev->pUIInfo;
    POPTSELECT          pOptionArray = pPDev->pOptionsArray;
    BOOL                bFound = FALSE;
    PDEVMODE            pdm = pPDev->pdm;

    #if DBG
    PTSTR               pTmp;
    PFEATURE            pPageSizeFeature;
    DWORD               dwPageSizeIndex;
    #endif

    //
    // If there is no *InputSlot feature (which shouldn't happen),
    // simply ignore and return success
    //

    if (! (pInputSlotFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_INPUTSLOT)))
        return TRUE;

    dwInputSlotIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pInputSlotFeature);

    //
    // If the input slot is "AutoSelect", then go through
    // the form-to-tray assignment table and see if the
    // requested form is assigned to an input slot.
    //

    if (((pdm->dmFields & DM_DEFAULTSOURCE) &&
         (pdm->dmDefaultSource == DMBIN_FORMSOURCE)) &&
        (pdm->dmFormName[0] != NUL) &&
        (pFormTrayTable = PGetFormTrayTable(pPDev->devobj.hPrinter, NULL)))
    {
        FINDFORMTRAY    FindData;
        PTSTR           ptstrName;

        //
        // Find the tray name corresponding to the requested form name
        //

        RESET_FINDFORMTRAY(pFormTrayTable, &FindData);
        ptstrName = pdm->dmFormName;

        #if 0
        pTmp = pFormTrayTable;
        VERBOSE(("Looking for form [%ws] in the Form Tray Table\n",ptstrName));
        VERBOSE(("BEFORE SETTING: Value of pOptionArray[dwInputSlotIndex].ubCurOptIndex is = %d \n",pOptionArray[dwInputSlotIndex].ubCurOptIndex));
        #endif

        while (!bFound && *FindData.ptstrNextEntry)
        {
            if (BSearchFormTrayTable(pFormTrayTable, NULL, ptstrName, &FindData))
            {
                //
                // Convert the tray name to an option index
                //

                bFound = FALSE;

                //
                //Search from index 1 as the first input slot is a dummy tray
                //for DMBIN_FORMSOURCE.
                //

                for (dwIndex = 1; dwIndex < pInputSlotFeature->Options.dwCount; dwIndex++)
                {
                    pOption = PGetIndexedOption(pUIInfo, pInputSlotFeature, dwIndex);

                    if (pOption->loDisplayName & GET_RESOURCE_FROM_DLL)
                    {
                        //
                        // loOffset specifies a string resource ID
                        // in the resource DLL
                        //

                        WCHAR   wchbuf[MAX_DISPLAY_NAME];

//#ifdef  RCSTRINGSUPPORT
#if 0
                        if(((pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL) >= RESERVED_STRINGID_START)
                            &&  ((pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL) <= RESERVED_STRINGID_END))
                        {
                            if (!ILoadStringW ( &(pPDev->localWinResData),
                                       (pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL),
                                        wchbuf, MAX_DISPLAY_NAME) )
                            {
                                WARNING(("\n UniFont!BMergeFormToTrayAssignments:Input Tray Name not found in resource DLL\n"));
                                continue;
                            }
                        }

                        else
#endif

                            if (!ILoadStringW ( &(pPDev->WinResData),
                                       (pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL),
                                        wchbuf, MAX_DISPLAY_NAME) )
                        {
                            WARNING(("\n UniFont!BMergeFormToTrayAssignments:Input Tray Name not found in resource DLL\n"));
                            continue;
                        }

                         ptstrName = wchbuf;
                    }
                    else
                        ptstrName = OFFSET_TO_POINTER(pPDev->pDriverInfo->pubResourceData, pOption->loDisplayName);

                    ASSERTMSG((ptstrName && FindData.ptstrTrayName),("\n NULL Tray Name,\
                                ptstrName = 0x%p,FindData.ptstrTrayName = 0x%p\n",
                                ptstrName, FindData.ptstrTrayName ));
                    #if 0
                    VERBOSE(("\nInput Tray Name for Option %d  = %ws\n",dwIndex, ptstrName));
                    VERBOSE(("The required Tray Name = %ws\n",FindData.ptstrTrayName));
                    VERBOSE(("\tInput TrayName for FormTray table index %d = %ws\n",dwIndex, pTmp));
                    pTmp += (wcslen(pTmp) + 1);
                    VERBOSE(("\tForm Name for FormTray table index %d = %ws\n\n",dwIndex, pTmp));
                    #endif

                    if (ptstrName && (_tcsicmp(ptstrName, FindData.ptstrTrayName) == EQUAL_STRING))
                    {
                        pOptionArray[dwInputSlotIndex].ubCurOptIndex = (BYTE) dwIndex;
                        bFound = TRUE;

                        break;
                    }
                }
            }
        }

        MemFree(pFormTrayTable);
    }

    if (!bFound)
    {
        if (pFormTrayTable)
        {
            TERSE(("Form '%ws' is not currently assigned to a tray.\n",
               pdm->dmFormName));
        }

        //
        // Set the Inputbin option to default input Bin, if current value is
        // set to dummy one.
        //

        if (pOptionArray[dwInputSlotIndex].ubCurOptIndex == 0)
        {
            pOptionArray[dwInputSlotIndex].ubCurOptIndex =
                                (BYTE)pInputSlotFeature->dwDefaultOptIndex;

        }
    }

    pPDev->pdmPrivate->aOptions[dwInputSlotIndex].ubCurOptIndex   =  pOptionArray[dwInputSlotIndex].ubCurOptIndex;

    //
    //TRACE CODE
    //

    #if 0
    if (pPageSizeFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE))
        dwPageSizeIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPageSizeFeature);

    if (pdm->dmFields & DM_DEFAULTSOURCE)
    {
        VERBOSE(("DM_DEFAULTSOURCE BIT IS ON. \n"));
    }
    else
    {
        VERBOSE(("DM_DEFAULTSOURCE BIT IS OFF.\n"));
    }

    VERBOSE(("pdm->dmDefaultSource = %d\n",pdm->dmDefaultSource));
    VERBOSE(("pFormTrayTable = 0x%p\n",pFormTrayTable));
    VERBOSE(("Value of pOptionArray[dwPageSizeIndex].ubCurOptIndex = %d \n",pOptionArray[dwPageSizeIndex].ubCurOptIndex));
    VERBOSE(("AFTER SETTING:Value of pOptionArray[dwInputSlotIndex].ubCurOptIndex = %d\n",pOptionArray[dwInputSlotIndex].ubCurOptIndex));
    VERBOSE(("AFTER SETTING:Value of pdmPrivate->aOptions[dwInputSlotIndex].ubCurOptIndex = %d\n",pPDev->pdmPrivate->aOptions[dwInputSlotIndex].ubCurOptIndex));
    VERBOSE(("Value of pInputSlotFeature->dwDefaultOptIndex is %d \n",pInputSlotFeature->dwDefaultOptIndex));
    VERBOSE(("END TRACING BMergeFormToTrayAssignments.\n\n"));
    #endif

    return TRUE;
}

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\escape.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    escape.c

Abstract:

    Implementation of escape related DDI entry points:
        DrvEscape

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "unidrv.h"

// define DPRECT if you want to enable DRAWPATTERNRECT escape feature
#define DPRECT

typedef struct _POINTS {
    short   x;
    short   y;
} POINTs;

typedef struct _SHORTDRAWPATRECT {      // use 16-bit POINT structure
        POINTs ptPosition;
        POINTs ptSize;
        WORD   wStyle;
        WORD   wPattern;
} SHORTDRAWPATRECT, *PSHORTDRAWPATRECT;


ULONG
DrvEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID      *pvIn,
    ULONG       cjOut,
    PVOID      *pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEscape.
    Please refer to DDK documentation for more details.

Arguments:

    pso     - Describes the surface the call is directed to
    iEsc    - Specifies a query
    cjIn    - Specifies the size in bytes of the buffer pointed to by pvIn
    pvIn    - Points to input data buffer
    cjOut   - Specifies the size in bytes of the buffer pointed to by pvOut
    pvOut   -  Points to the output buffer

Return Value:

    Depends on the query specified by iEsc parameter

--*/

{

#define pbIn     ((BYTE *)pvIn)
#define pdwIn    ((DWORD *)pvIn)
#define pdwOut   ((DWORD *)pvOut)

    PDEV    *pPDev;
    ULONG   ulRes = 0;

    VERBOSE(("Entering DrvEscape: iEsc = %d...\n", iEsc));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMEscape,
                    PFN_OEMEscape,
                    ULONG,
                    (pso,
                     iEsc,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMEscape,
                    VMEscape,
                    ULONG,
                    (pso,
                     iEsc,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    switch( iEsc )
    {
    case  QUERYESCSUPPORT:

        //
        // Check if the specified escape code is supported
        //

        if (pvIn != NULL || cjIn >= sizeof(DWORD))
        {
            switch( *pdwIn )
            {

            case  QUERYESCSUPPORT:
            case  PASSTHROUGH:
                //
                // Always support these escapes
                //

                ulRes = 1;
                break;

            case  SETCOPYCOUNT:
                ulRes = pPDev->dwMaxCopies > 1;
                break;

#ifndef WINNT_40    // NT5
            case DRAWPATTERNRECT:
                if ((pPDev->fMode & PF_RECT_FILL) &&
                    (pPDev->dwMinGrayFill < pPDev->dwMaxGrayFill) &&
                    (pPDev->pdmPrivate->iLayout == ONE_UP) &&
                    (!(pPDev->pdm->dmFields & DM_TTOPTION) ||
                     pPDev->pdm->dmTTOption != DMTT_BITMAP) &&
                    !(pPDev->fMode2 & PF2_MIRRORING_ENABLED) &&
                    !(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS)) // else, only black fill
                {
                    if (pPDev->fMode & PF_RECTWHITE_FILL)
                        ulRes = 2;
                    else
                        ulRes = 1;
                }
                break;
#endif // !WINNT_40
            }
        }
        break;


    case  PASSTHROUGH:
        //
        // QFE fix: NT4 TTY driver compatibility.
        // There is an application that sends FF by itself.
        // We don't want to send Form Feed if application calls DrvEscape.
        //
        if (pPDev->bTTY)
        {
            pPDev->fMode2 |= PF2_PASSTHROUGH_CALLED_FOR_TTY;
        }

        if( pvIn == NULL || cjIn < sizeof(WORD) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            ERR(("DrvEscape(PASSTHROUGH): Bad input parameters\n"));
        }
        else
        {

            //
            //  Win 3.1 actually uses the first 2 bytes as a count of the
            //  number of bytes following!!!!  So, the following union
            //  allows us to copy the data to an aligned field that
            //  we use.  And thus we ignore cjIn!
            //

            union
            {
                WORD   wCount;
                BYTE   bCount[ 2 ];
            } u;

            u.bCount[ 0 ] = pbIn[ 0 ];
            u.bCount[ 1 ] = pbIn[ 1 ];

            if( u.wCount && cjIn >= (ULONG)(u.wCount + sizeof(WORD)) )
            {

                ulRes = WriteSpoolBuf( pPDev, pbIn + 2, u.wCount );
            }
            else
            {
                SetLastError( ERROR_INVALID_DATA );
                ERR(("DrvEscape: Bad data in PASSTRHOUGH.\n"));
            }
        }
        break;


    case  SETCOPYCOUNT:

        if( pdwIn && *pdwIn > 0 )
        {
            pPDev->sCopies = (SHORT)*pdwIn;

            //
            // Check whether the copy count is in printer range
            //

            if( pPDev->sCopies > (SHORT)pPDev->dwMaxCopies )
                pPDev->sCopies = (SHORT)pPDev->dwMaxCopies;

            if( pdwOut )
                *pdwOut = pPDev->sCopies;

            ulRes = 1;
        }

        break;

    case DRAWPATTERNRECT:
    {
#ifndef WINNT_40
        typedef struct _DRAWPATRECTP {
            DRAWPATRECT DrawPatRect;
            XFORMOBJ *pXFormObj;
        } DRAWPATRECTP, *PDRAWPATRECTP;
        if (pvIn == NULL || (cjIn != sizeof(DRAWPATRECT) && cjIn != sizeof(DRAWPATRECTP)))
#else
        if( pvIn == NULL || cjIn != sizeof(DRAWPATRECT))
#endif
        {
            if (pvIn && cjIn == sizeof(SHORTDRAWPATRECT)) // check for Win3.1 DRAWPATRECT size
            {
                DRAWPATRECT dpr;
                PSHORTDRAWPATRECT   psdpr = (PSHORTDRAWPATRECT)pvIn;

                if (pPDev->fMode & PF_ENUM_GRXTXT)
                {
                    //
                    // Some apps (Access 2.0, AmiPro 3.1, etc.) do use the 16-bit
                    // POINT version of DRAWPATRECT structure. Have to be compatible
                    // with these apps.
                    //
                    dpr.ptPosition.x = (LONG)psdpr->ptPosition.x;
                    dpr.ptPosition.y = (LONG)psdpr->ptPosition.y;
                    dpr.ptSize.x = (LONG)psdpr->ptSize.x;
                    dpr.ptSize.y = (LONG)psdpr->ptSize.y;
                    dpr.wStyle  = psdpr->wStyle;
                    dpr.wPattern = psdpr->wPattern;

                    ulRes = DrawPatternRect(pPDev, &dpr);
                }
            }
            else
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                ERR(("DrvEscape(DRAWPATTERNRECT): Bad input parameters.\n"));
            }
        }
        else if (pPDev->fMode & PF_ENUM_GRXTXT)
        {
            DRAWPATRECT dpr = *(PDRAWPATRECT)pvIn;
#ifndef WINNT_40     // NT 5.0
            if (pPDev->pdmPrivate->iLayout != ONE_UP && cjIn == sizeof(DRAWPATRECTP))
            {
                XFORMOBJ *pXFormObj = ((PDRAWPATRECTP)pvIn)->pXFormObj;
                POINTL PTOut[2],PTIn[2];
                PTIn[0].x = dpr.ptPosition.x + pPDev->rcClipRgn.left;
                PTIn[0].y = dpr.ptPosition.y + pPDev->rcClipRgn.top;
                PTIn[1].x = PTIn[0].x + dpr.ptSize.x;
                PTIn[1].y = PTIn[0].y + dpr.ptSize.y;
                if (!XFORMOBJ_bApplyXform(pXFormObj,
                                      XF_LTOL,
                                      2,
                                      &PTIn,
                                      &PTOut))
                {
                    ERR (("DrvEscape(DRAWPATTERNRECT): XFORMOBJ_bApplyXform failed.\n"));
                    break;
                }
                dpr.ptPosition.x = PTOut[0].x;
                dpr.ptSize.x = PTOut[1].x - PTOut[0].x;
                if (dpr.ptSize.x < 0)
                {
                    dpr.ptPosition.x += dpr.ptSize.x;
                    dpr.ptSize.x = -dpr.ptSize.x;
                }
                else if (dpr.ptSize.x == 0)
                    dpr.ptSize.x = 1;

                dpr.ptPosition.y = PTOut[0].y;
                dpr.ptSize.y = PTOut[1].y - PTOut[0].y;
                if (dpr.ptSize.y < 0)
                {
                    dpr.ptPosition.y += dpr.ptSize.y;
                    dpr.ptSize.y = -dpr.ptSize.y;
                }
                else if (dpr.ptSize.y == 0)
                    dpr.ptSize.y = 1;
            }
#endif  // !WINNT_40
            // Test whether to force minimum size = 2 pixels
            //
            if (pPDev->fMode & PF_SINGLEDOT_FILTER)
            {
                if (dpr.ptSize.y < 2)
                    dpr.ptSize.y = 2;
                if (dpr.ptSize.x < 2)
                    dpr.ptSize.x = 2;
            }
            ulRes = DrawPatternRect(pPDev, &dpr);
        }
        else
            ulRes = 1;      // no need for GDI to take any action
        break;  // case DRAWPATTERNRECT
    }
    default:
        SetLastError( ERROR_INVALID_FUNCTION );
        break;

    }

    return   ulRes;
}

ULONG
DrawPatternRect(
    PDEV *pPDev,
    PDRAWPATRECT pPatRect)
/*++
Routine Description:
    Implementation of DRAWPATTERNECT escape. Note that it is PCL-specific.

Arguments:
    pPDev    - the driver's PDEV
    pPatRect - the DRAWPATRECT structure from the app

Return Value:
    1 if successful. Otherwise, 0.
--*/
{
    WORD    wPattern, wStyle;
    RECTL    rcClip;
    COMMAND *pCmd;
    ULONG   ulRes = 0;

    if (!(pPDev->fMode & PF_RECT_FILL))
        return 0;

    wStyle = pPatRect->wStyle;
    if (!((wStyle+1) & 3))  // same as (wStyle < 0 || wStyle > 2)
        return 0;   // we support only solid fill

    // Reset the brush, before downloading rule unless we are going to use
    // a white rectangle command

    if (wStyle != 1)
        GSResetBrush(pPDev);

    //
    // clip to printable region
    //
    rcClip.left = MAX(0, pPatRect->ptPosition.x);
    rcClip.top = MAX(0, pPatRect->ptPosition.y);
    rcClip.right = MIN(pPDev->szBand.cx,
                       pPatRect->ptPosition.x + pPatRect->ptSize.x);
    rcClip.bottom = MIN(pPDev->szBand.cy,
                        pPatRect->ptPosition.y + pPatRect->ptSize.y);
    //
    // check if we end up with an empty rect. If not, put down the rule.
    //
    if (rcClip.right > rcClip.left && rcClip.bottom > rcClip.top)
    {
        DWORD dwXSize,dwYSize;
        //
        //  Move to the starting position. rcClip is in device units to
        //  which we must add the offset of the band origin
        //
        XMoveTo(pPDev, rcClip.left+pPDev->rcClipRgn.left, MV_GRAPHICS);
        YMoveTo(pPDev, rcClip.top+pPDev->rcClipRgn.top, MV_GRAPHICS);

        //
        //  The RectFill commands expect master units.
        //
        dwXSize = pPDev->dwRectXSize;
        pPDev->dwRectXSize = (rcClip.right - rcClip.left) * pPDev->ptGrxScale.x;
        dwYSize = pPDev->dwRectYSize;
        pPDev->dwRectYSize = (rcClip.bottom - rcClip.top) * pPDev->ptGrxScale.y;

        //
        // check whether the rectangle size is different and update if necessary
        //
        if (dwXSize != pPDev->dwRectXSize || 
            (!(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)) &&
            !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL))))
        {
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTWIDTH));
        }
        if (dwYSize != pPDev->dwRectYSize || 
            (!(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)) &&
            !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL))))
        {
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTHEIGHT));
        }
        //
        // range-check the pattern based upon the kind of rule.
        //
        switch (wStyle)
        {
        case 0:
            //
            // black fill, which is max gray fill unless CmdRectBlackFill exists
            //
            if (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL))
                WriteChannel(pPDev, pCmd);
            else
            {
                pPDev->dwGrayPercentage = pPDev->dwMaxGrayFill;
                WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL));
            }
            ulRes = 1;
            break;

        case 1:
            //
            // White (erase) fill
            //
            if (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL))
            {
                WriteChannel(pPDev, pCmd);
                ulRes = 1;
            }
            break;

        case 2:
            //
            // Shaded gray fill.
            //
            // If 100% black use black rectangle fill anyway
            //
            if (pPatRect->wPattern == 100 &&
                    (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)))
            {
                WriteChannel(pPDev, pCmd);
            }
            // If 0% black use white rectangle fill
            //
            else if (pPatRect->wPattern == 0 &&
                    (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL)))
            {
                WriteChannel(pPDev, pCmd);
            }
            //
            // Check for the gray range.
            //
            else
            {
                if ((wPattern = pPatRect->wPattern) < (WORD)pPDev->dwMinGrayFill)
                    wPattern = (WORD)pPDev->dwMinGrayFill;
                if (wPattern > (WORD)pPDev->dwMaxGrayFill)
                    wPattern = (WORD)pPDev->dwMaxGrayFill;
                pPDev->dwGrayPercentage = (DWORD)wPattern;
                WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL));
            }
            ulRes = 1;
            break;
        }

        //
        // update internal coordinates, if necessary. BUG_BUG, do we really need cx/cyafterfill in PDEV?
        //
        if (ulRes == 1)
        {
            if (pPDev->cxafterfill == CXARF_AT_RECT_X_END)
                XMoveTo(pPDev, pPatRect->ptSize.x,
                               MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);

            if (pPDev->cyafterfill == CYARF_AT_RECT_Y_END)
                YMoveTo(pPDev, pPatRect->ptSize.y,
                               MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);
            if (wStyle != 1)
            {
                INT i;
                BYTE ubMask = BGetMask(pPDev,&rcClip);
                for (i = rcClip.top;i < rcClip.bottom;i++)
                    pPDev->pbScanBuf[i] |= ubMask;
            }
        }
    } // if (!IsRectEmpty(&rcClip))

    return ulRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\font.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Implementation of font related DDI entry points:
        DrvQueryFont
        DrvQueryFontTree
        DrvQueryFontData
        DrvGetGlyphMode
        DrvFontManagement
        DrvQueryAdvanceWidths

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support
--*/

#include "unidrv.h"


PIFIMETRICS
DrvQueryFont(
    DHPDEV  dhpdev,
    ULONG_PTR   iFile,
    ULONG   iFace,
    ULONG_PTR  *pid
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryFont.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iFile  - Identifies the driver font file
    iFace  - One-based index of the driver font
    pid    - Points to a LONG variable for returning an identifier
             which GDI will pass to DrvFree

Return Value:

    Pointer to an IFIMETRICS structure for the given font
    NULL if there is an error

--*/

{
    PDEV *pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    UNREFERENCED_PARAMETER(iFile);
    VERBOSE(("Entering DrvQueryFont...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryFont,
                    PFN_OEMQueryFont,
                    PIFIMETRICS,
                    (dhpdev,
                     iFile,
                     iFace,
                     pid));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryFont,
                    VMQueryFont,
                    PIFIMETRICS,
                    (dhpdev,
                     iFile,
                     iFace,
                     pid));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);
    if (pFontProcs->FMQueryFont == NULL)
        return NULL;
    else
        return (pFontProcs->FMQueryFont(pPDev,
                                        iFile,
                                        iFace,
                                        pid) );

}

PVOID
DrvQueryFontTree(
    DHPDEV  dhpdev,
    ULONG_PTR   iFile,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR  *pid
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryFontTree.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iFile  - Identifies the driver font file
    iFace  - One-based index of the driver font
    iMode  - Specifies the type of information to be provided
    pid    - Points to a LONG variable for returning an identifier
             which GDI will pass to DrvFree

Return Value:

    Depends on iMode, NULL if there is an error

--*/

{

    PDEV *pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryFontTree...\n"));
    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryFontTree,
                    PFN_OEMQueryFontTree,
                    PVOID,
                    (dhpdev,
                     iFile,
                     iFace,
                     iMode,
                     pid));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryFontTree,
                    VMQueryFontTree,
                    PVOID,
                    (dhpdev,
                     iFile,
                     iFace,
                     iMode,
                     pid));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

    if (pFontProcs->FMQueryFontTree == NULL)
        return NULL;
    else
        return ( pFontProcs->FMQueryFontTree(pPDev,
                                            iFile,
                                            iFace,
                                            iMode,
                                            pid) );
}


LONG
DrvQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryFontData.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev  - Driver device handle
    pfo     - Points to a FONTOBJ structure
    iMode   - Type of information requested
    hg      - A glyph handle
    pgd     - Points to a GLYPHDATA structure
    pv      - Points to output buffer
    cjSize  - Size of output buffer

Return Value:

    Depends on iMode. FD_ERROR if there is an error

--*/

{
    PDEV *pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryFontData...\n"));
    ASSERT(pfo && VALID_PDEV(pPDev));

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryFontData,
                    PFN_OEMQueryFontData,
                    LONG,
                    (dhpdev,
                     pfo,
                     iMode,
                     hg,
                     pgd,
                     pv,
                     cjSize));


    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryFontData,
                    VMQueryFontData,
                    LONG,
                    (dhpdev,
                     pfo,
                     iMode,
                     hg,
                     pgd,
                     pv,
                     cjSize));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

    if (pFontProcs->FMQueryFontData == NULL)
        return FD_ERROR;
    else
        return (pFontProcs->FMQueryFontData(pPDev,
                                              pfo,
                                              iMode,
                                              hg,
                                              pgd,
                                              pv,
                                              cjSize) );
}

ULONG
DrvFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvFontManagement.
    Please refer to DDK documentation for more details.

Arguments:

    pso     - Points to a SURFOBJ structure
    pfo     - Points to a FONTOBJ structure
    iMode   - Escape number
    cjIn    - Size of input buffer
    pvIn    - Points to input buffer
    cjOut   - Size of output buffer
    pvOut   - Points to output buffer

Return Value:

    0x00000001 to 0x7fffffff for success
    0x80000000 to 0xffffffff for failure
    0 if the specified escape number if not supported

--*/

{
    PDEV * pPDev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryFontManagement...\n"));

    //
    // pso could be NULL in case of QUERYESCSUPPORT
    //

    if (iMode == QUERYESCSUPPORT)
    {
        //
        // we don't allow OEM dll to overwrite our font management capability.
        // By not call OEM for this escape, we are also enforcing that the OEM
        // support the same set of font management escapes as Unidrv does.
        //
        return ( *((PULONG)pvIn) == GETEXTENDEDTEXTMETRICS ) ? 1 : 0;
    }

    ASSERT(pso);
    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    ASSERT(pfo);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMFontManagement,
                    PFN_OEMFontManagement,
                    ULONG,
                    (pso,
                     pfo,
                     iMode,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMFontManagement,
                    VMFontManagement,
                    ULONG,
                    (pso,
                     pfo,
                     iMode,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    switch (iMode)
    {
    case GETEXTENDEDTEXTMETRICS:
    {
        pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

        if (pFontProcs->FMFontManagement == NULL)
            return 0;
        else
            return ( pFontProcs->FMFontManagement(pso,
                                                  pfo,
                                                  iMode,
                                                  cjIn,
                                                  pvIn,
                                                  cjOut,
                                                  pvOut) );

    }
    default:
        return 0;
    }
}

BOOL
DrvQueryAdvanceWidths(
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH *phg,
    PVOID  *pvWidths,
    ULONG   cGlyphs
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryAdvanceWidths.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev  - Driver device handle
    pfo     - Points to a FONTOBJ structure
    iMode   - Type of information to be provided
    phg     - Points to an array of HGLYPHs for which the driver will
              provide character advance widths
    pvWidths - Points to a buffer for returning width data
    cGlyphs - Number of glyphs in the phg array

Return Value:

    Depends on iMode

--*/

{
    PDEV * pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryAdvanceWidths...\n"));
    ASSERT(pfo && VALID_PDEV(pPDev));

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryAdvanceWidths,
                    PFN_OEMQueryAdvanceWidths,
                    BOOL,
                    (dhpdev,
                     pfo,
                     iMode,
                     phg,
                     pvWidths,
                     cGlyphs));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryAdvanceWidths,
                    VMQueryAdvanceWidths,
                    BOOL,
                    (dhpdev,
                     pfo,
                     iMode,
                     phg,
                     pvWidths,
                     cGlyphs));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

    if (pFontProcs->FMQueryAdvanceWidths == NULL)
        return FALSE;
    else
       return ( pFontProcs->FMQueryAdvanceWidths(pPDev,
                                                pfo,
                                                iMode,
                                                phg,
                                                pvWidths,
                                                cGlyphs) );

}

ULONG
DrvGetGlyphMode(
    DHPDEV  dhpdev,
    FONTOBJ *pfo
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvGetGlyphMode.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev  - Driver device handle
    pfo     - Points to a FONTOBJ structure

Return Value:

    The glyph mode or FO_GLYPHMODE, which is the default

--*/
{
    PDEV * pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvGetGlyphMode...\n"));
    ASSERT(pfo && VALID_PDEV(pPDev));

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMGetGlyphMode,
                    PFN_OEMGetGlyphMode,
                    ULONG,
                    (dhpdev,
                     pfo));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMGetGlyphMode,
                    VMGetGlyphMode,
                    ULONG,
                    (dhpdev,
                     pfo));


    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);
    if (pFontProcs->FMGetGlyphMode == NULL)
        return  FO_GLYPHBITS;
    else
        return ( pFontProcs->FMGetGlyphMode(pPDev, pfo) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\init.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Implemenation of the following initialization functions:
        BInitGDIInfo
        BInitDevInfo
        BInitPDEV

Environment:

    Windows NT Unidrv driver

Revision History:

    10/21/96 -amandan-
        Created

--*/

#include "unidrv.h"

INT  iHypot( INT, INT);
INT  iGCD(INT, INT);
VOID VInitFMode(PDEV *);
VOID VInitFYMove(PDEV *);
BOOL BInitOptions(PDEV *);
BOOL BInitCmdTable(PDEV *);
BOOL BInitStdTable(PDEV *);
BOOL BInitPaperFormat(PDEV *, RECTL *);
VOID VInitOutputCTL(PDEV *, PRESOLUTIONEX);
VOID VGetPaperMargins(PDEV *, PAGESIZE *, PAGESIZEEX *, SIZEL, RECTL *);
VOID  VOptionsToDevmodeFields(PDEV        *pPDev) ;



VOID VSwapL(
    long *pl1,
    long *pl2)
{
    long ltemp;

    ltemp = *pl1;
    *pl1 = *pl2;
    *pl2 = ltemp;
}

BOOL
BInitPDEV (
    PDEV        *pPDev,
    RECTL       *prcFormImageArea
    )
/*++

Routine Description:

    Initialize the PDEVICE

Arguments:

    pPDev - Points to the current PDEV structure
    pdm   - Points to the input devmode
    prcFormInageArea - pointer image area of form selected

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    pPDev->sCopies = pPDev->pdm->dmCopies;
    pPDev->pGlobals = &(pPDev->pDriverInfo->Globals);

    //
    // Initializes Options structs
    //

    if (BInitOptions(pPDev) == FALSE)
        return FALSE;


    //
    // Initializes pPDev->ptGrxRes and pPDev->ptTextRes based on the
    // current resolution selection
    //

    //
    // Initializes the graphics and text resolution of PDEV
    //

    ASSERT(pPDev->pResolution && pPDev->pResolutionEx);

    pPDev->ptGrxRes.x  =  pPDev->pResolutionEx->ptGrxDPI.x;
    pPDev->ptGrxRes.y  =  pPDev->pResolutionEx->ptGrxDPI.y;

    pPDev->ptTextRes.x =  pPDev->pResolutionEx->ptTextDPI.x;
    pPDev->ptTextRes.y =  pPDev->pResolutionEx->ptTextDPI.y;

    pPDev->ptGrxScale.x = pPDev->pGlobals->ptMasterUnits.x / pPDev->ptGrxRes.x;
    pPDev->ptGrxScale.y = pPDev->pGlobals->ptMasterUnits.y / pPDev->ptGrxRes.y;

    if (pPDev->pdm->dmOrientation == DMORIENT_LANDSCAPE)
    {
        VSwapL(&pPDev->ptGrxRes.x, &pPDev->ptGrxRes.y);
        VSwapL(&pPDev->ptTextRes.x, &pPDev->ptTextRes.y);
        VSwapL(&pPDev->ptGrxScale.x, &pPDev->ptGrxScale.y);
    }
    if (pPDev->pGlobals->ptDeviceUnits.x)
        pPDev->ptDeviceFac.x = pPDev->pGlobals->ptMasterUnits.x / pPDev->pGlobals->ptDeviceUnits.x;
    if (pPDev->pGlobals->ptDeviceUnits.y)
        pPDev->ptDeviceFac.y = pPDev->pGlobals->ptMasterUnits.y / pPDev->pGlobals->ptDeviceUnits.y;

    //
    // Init OUTPUTCTL
    //

    VInitOutputCTL(pPDev, pPDev->pResolutionEx);

    //
    // Initializes pPDev->sBitsPixel
    //

    if (pPDev->pColorModeEx != NULL)
        pPDev->sBitsPixel = (short)pPDev->pColorModeEx->dwDrvBPP;
    else
        pPDev->sBitsPixel = 1;

    //
    // Init PAPERFORMAT struct
    //

    ASSERT(pPDev->pPageSize != NULL);

    if (BInitPaperFormat(pPDev, prcFormImageArea) == FALSE)
        return FALSE;

    //
    // Initialize the amount of free memory in the device
    //

    if (pPDev->pMemOption)
    {
        pPDev->dwFreeMem = pPDev->pMemOption->dwFreeMem;
    }
    else
    {
        pPDev->dwFreeMem = 0;
    }

    //
    // Initialize the command table from the Unidrv predefined command index
    // as defined in GPD.H
    //

    if (BInitCmdTable(pPDev) == FALSE)
        return FALSE;

    //
    // Initialize the pPDev->fMode flag
    //

    VInitFMode(pPDev);

    //
    // Initialize the pPDev->fYMove flag
    //

    VInitFYMove(pPDev);

    //
    // Initialize the standard variable table in PDEVICE.
    // This table is used to access state variable controls by the driver
    //

    if (BInitStdTable(pPDev) == FALSE)
        return FALSE;

    //
    // Initialize misc. variables that need to be in pdev since
    // we unloads the binary data at DrvEnablePDEV and reloads it at
    // DrvEnableSurface
    //

    pPDev->dwMaxCopies = pPDev->pGlobals->dwMaxCopies;
    pPDev->dwMaxGrayFill = pPDev->pGlobals->dwMaxGrayFill;
    pPDev->dwMinGrayFill = pPDev->pGlobals->dwMinGrayFill;
    pPDev->cxafterfill = pPDev->pGlobals->cxafterfill;
    pPDev->cyafterfill = pPDev->pGlobals->cyafterfill;
    pPDev->dwCallingFuncID = INVALID_EP;

    return TRUE;

}

BOOL
BInitGdiInfo(
    PDEV    *pPDev,
    ULONG   *pGdiInfoBuffer,
    ULONG   ulBufferSize
    )

/*++

Routine Description:

    Initializes the GDIINFO struct

Arguments:

    pPDev - Points to the current PDEV structure
    pGdiInfoBuffer - Points to the output GDIINFO buffer passed in from GDI
    ulBufferSize - Size of the output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    GDIINFO gdiinfo;
    DEVHTINFO   DevHTInfo;

    // initialize GDIINFO structure
    //
    ZeroMemory(&gdiinfo, sizeof(GDIINFO));

    //
    //  Driver version
    //

    gdiinfo.ulVersion = UNIDRIVER_VERSION;

    if ( pPDev->pGlobals->printertype == PT_TTY)
    {
        pPDev->bTTY = TRUE;
        gdiinfo.ulTechnology = DT_CHARSTREAM;
    }
    else
    {
        pPDev->bTTY = FALSE;
        gdiinfo.ulTechnology = DT_RASPRINTER;
    }

    //
    // Width and Height of physical display in milimeters
    //

    //
    // Returning a negative number for ulHorzSize and ulVertSize means
    // the values are in micrometers. (25400 micrometer in 1 inch)
    //

    gdiinfo.ulHorzSize = (ULONG)MulDiv(-pPDev->sf.szImageAreaG.cx,
                                        25400, pPDev->ptGrxRes.x);

    gdiinfo.ulVertSize = (ULONG)MulDiv(-pPDev->sf.szImageAreaG.cy,
                                        25400, pPDev->ptGrxRes.y);

    //
    // Width and height of physical surface measured in device pixels
    //

    gdiinfo.ulHorzRes = pPDev->sf.szImageAreaG.cx;
    gdiinfo.ulVertRes = pPDev->sf.szImageAreaG.cy;

    gdiinfo.cBitsPixel = pPDev->sBitsPixel;
    gdiinfo.cPlanes = 1;
    gdiinfo.ulNumColors = (1 << gdiinfo.cBitsPixel);
#ifdef WINNT_40
    if (gdiinfo.ulNumColors > 0x7fff)
        gdiinfo.ulNumColors = 0x7fff;
#endif

    gdiinfo.flRaster = 0;

    gdiinfo.ulLogPixelsX = pPDev->ptGrxRes.x;
    gdiinfo.ulLogPixelsY  = pPDev->ptGrxRes.y;

    //
    // BUG_BUG, The FMInit() function fills out gdiinfo.flTextCaps field
    // gdiinfo.flTextCaps = pPDev->flTextCaps;
    //

    //
    //  The following are for Win 3.1 compatability.  The X and Y values
    //  are reversed.
    //

    gdiinfo.ulAspectX = pPDev->ptTextRes.y;
    gdiinfo.ulAspectY = pPDev->ptTextRes.x;
    gdiinfo.ulAspectXY = iHypot( gdiinfo.ulAspectX, gdiinfo.ulAspectY);


    //
    //   Set the styled line information for this printer
    //

    if(pPDev->ptGrxRes.x == pPDev->ptGrxRes.y)
    {
        //
        //  Special case: resolution is the same in both directions. This
        //  is typically true for laser and inkjet printers.
        //

        gdiinfo.xStyleStep = 1;
        gdiinfo.yStyleStep = 1;
        gdiinfo.denStyleStep = pPDev->ptGrxRes.x / 50;     // 50 elements per inch
        if ( gdiinfo.denStyleStep == 0 )
            gdiinfo.denStyleStep = 1;

    }
    else
    {
        //
        //  Resolutions differ,  so figure out lowest common multiple
        //

        INT   igcd;

        igcd = iGCD( pPDev->ptGrxRes.x, pPDev->ptGrxRes.y);

        gdiinfo.xStyleStep = pPDev->ptGrxRes.y / igcd;
        gdiinfo.yStyleStep = pPDev->ptGrxRes.x / igcd;
        gdiinfo.denStyleStep = gdiinfo.xStyleStep * gdiinfo.yStyleStep / 2;

    }

    //
    // Size and margins of physical surface measured in device pixels
    //

    gdiinfo.ptlPhysOffset.x = pPDev->sf.ptImageOriginG.x;
    gdiinfo.ptlPhysOffset.y = pPDev->sf.ptImageOriginG.y;

    gdiinfo.szlPhysSize.cx = pPDev->sf.szPhysPaperG.cx;
    gdiinfo.szlPhysSize.cy = pPDev->sf.szPhysPaperG.cy;


    //
    // BUG_BUG, RMInit should fill out the following fields in GDIINFO
    // gdiinfo.ciDevice
    // gdiinfo.ulDevicePelsDPI
    // gdiinfo.ulPrimaryOrder
    // gdiinfo.ulHTPatternSize
    // gdiinfo.ulHTOutputFormat
    // gdiinfo.flHTFlags
    //

    //
    // Copy ulBufferSize bytes of gdiinfo to pGdiInfoBuffer.
    //

    if (ulBufferSize != sizeof(gdiinfo))
        ERR(("Incorrect GDIINFO buffer size: %d != %d\n", ulBufferSize, sizeof(gdiinfo)));

    CopyMemory(pGdiInfoBuffer, &gdiinfo, min(ulBufferSize, sizeof(gdiinfo)));

    return TRUE;
}


BOOL
BInitDevInfo(
    PDEV        *pPDev,
    DEVINFO     *pDevInfoBuffer,
    ULONG       ulBufferSize
    )

/*++

Routine Description:

    Initialize the output DEVINFO buffer

Arguments:

    pPDev - Points to the current PDEV structure
    pDevInfoBuffer - Points to the output DEVINFO buffer passed in from GDI
    ulBufferSize - Size of the output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEVINFO devinfo;

    ZeroMemory(&devinfo, sizeof(devinfo));

    //
    // Fill in the graphics capabilities flags
    // BUBUG, RMInit() function should fill out devinfo.flGraphicsCaps
    // should fill this out later
    //

    //
    // Determine whether we should do metafile spooling or not
    //

    if( pPDev->pdmPrivate->dwFlags & DXF_NOEMFSPOOL )
        devinfo.flGraphicsCaps |= GCAPS_DONTJOURNAL;

#ifndef WINNT_40    // NT5
    if (pPDev->pdmPrivate->iLayout != ONE_UP)
        devinfo.flGraphicsCaps |= GCAPS_NUP;
#endif // !WINNT_40

    //
    // Get information about the default device font. Default size 10 point.
    //

    //
    // BUG_BUG, RMInit() should initialize the following DEVINFO fields
    //  flGraphicsCaps
    //  iDitherFormat
    //  cxDither
    //  cyDither
    //  hpalDefault
    //

    if (ulBufferSize != sizeof(devinfo))
        ERR(("Invalid DEVINFO buffer size: %d != %d\n", ulBufferSize, sizeof(devinfo)));

    CopyMemory(pDevInfoBuffer, &devinfo, min(ulBufferSize, sizeof(devinfo)));

    return TRUE;
}


BOOL
BInitCmdTable(
    PDEV        *pPDev
    )
/*++

Routine Description:

    The GPD specification defines a list of predefined command.  Each of these
    command has an enumration value as defined in CMDINDEX enumeration.
    This function will look up the indices of the predefined command and
    convert them to COMMAND pointers.

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT iCmd;

    for (iCmd = 0; iCmd < CMD_MAX; iCmd++)
    {
        //
        // CMDPOINTER will return NULL if the predefined command
        // is not supported by the device
        //

        pPDev->arCmdTable[iCmd] =  COMMANDPTR(pPDev->pDriverInfo, iCmd);
    }

    return TRUE;
}

BOOL
BInitStdTable(
    PDEV        *pPDev
    )
/*++

Routine Description:

    Initialize the array of pointers to the standard variables.  In the TOKENSTREAM
    struct, the parser will specify the actual parameter value or reference to one
    of the standard variable index defined in STDVARIABLE enumeration.  The
    driver use the pPDev->arStdPtrs to reference the actual values of the paramters,
    which are kept in various fields of the PDEVICE.

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // BUG_BUG, need to go back and fill this table out completely once
    // the FONT and RASTER PDEVICE are completely defined.
    //  note:  I could not find any uninitialized sv_fields.
    // perhaps this is too paranoid.
    //

    pPDev->arStdPtrs[SV_NUMDATABYTES]   = &pPDev->dwNumOfDataBytes;
    pPDev->arStdPtrs[SV_WIDTHINBYTES]   = &pPDev->dwWidthInBytes;
    pPDev->arStdPtrs[SV_HEIGHTINPIXELS] = &pPDev->dwHeightInPixels;
    pPDev->arStdPtrs[SV_COPIES]         = (PDWORD)&pPDev->sCopies;
    pPDev->arStdPtrs[SV_PRINTDIRECTION] = &pPDev->dwPrintDirection;
    pPDev->arStdPtrs[SV_DESTX]          = &pPDev->ctl.ptAbsolutePos.x;
    pPDev->arStdPtrs[SV_DESTY]          = &pPDev->ctl.ptAbsolutePos.y;
    pPDev->arStdPtrs[SV_DESTXREL]       = &pPDev->ctl.ptRelativePos.x;
    pPDev->arStdPtrs[SV_DESTYREL]       = &pPDev->ctl.ptRelativePos.y;
    pPDev->arStdPtrs[SV_LINEFEEDSPACING]= (PDWORD)&pPDev->ctl.lLineSpacing;
    pPDev->arStdPtrs[SV_RECTXSIZE]      = &pPDev->dwRectXSize;
    pPDev->arStdPtrs[SV_RECTYSIZE]      = &pPDev->dwRectYSize;
    pPDev->arStdPtrs[SV_GRAYPERCENT]    = &pPDev->dwGrayPercentage;
    pPDev->arStdPtrs[SV_NEXTFONTID]     = &pPDev->dwNextFontID;
    pPDev->arStdPtrs[SV_NEXTGLYPH]      = &pPDev->dwNextGlyph;
    pPDev->arStdPtrs[SV_PHYSPAPERLENGTH]= &pPDev->pf.szPhysSizeM.cy;
    pPDev->arStdPtrs[SV_PHYSPAPERWIDTH] = &pPDev->pf.szPhysSizeM.cx;
    pPDev->arStdPtrs[SV_FONTHEIGHT]     = &pPDev->dwFontHeight;
    pPDev->arStdPtrs[SV_FONTWIDTH]      = &pPDev->dwFontWidth;
    pPDev->arStdPtrs[SV_FONTMAXWIDTH]      = &pPDev->dwFontMaxWidth;
    pPDev->arStdPtrs[SV_FONTBOLD]       = &pPDev->dwFontBold;
    pPDev->arStdPtrs[SV_FONTITALIC]     = &pPDev->dwFontItalic;
    pPDev->arStdPtrs[SV_FONTUNDERLINE]  = &pPDev->dwFontUnderline;
    pPDev->arStdPtrs[SV_FONTSTRIKETHRU] = &pPDev->dwFontStrikeThru;
    pPDev->arStdPtrs[SV_CURRENTFONTID]  = &pPDev->dwCurrentFontID;
    pPDev->arStdPtrs[SV_TEXTYRES]       = &pPDev->ptTextRes.y;
    pPDev->arStdPtrs[SV_TEXTXRES]       = &pPDev->ptTextRes.x;
#ifdef BETA2
    pPDev->arStdPtrs[SV_GRAPHICSYRES]   = &pPDev->ptGrxRes.y;
    pPDev->arStdPtrs[SV_GRAPHICSXRES]   = &pPDev->ptGrxRes.x;
#endif
    pPDev->arStdPtrs[SV_ROP3]           = &pPDev->dwRop3;
    pPDev->arStdPtrs[SV_REDVALUE]               = &pPDev->dwRedValue             ;
    pPDev->arStdPtrs[SV_GREENVALUE]             = &pPDev->dwGreenValue           ;
    pPDev->arStdPtrs[SV_BLUEVALUE]              = &pPDev->dwBlueValue            ;
    pPDev->arStdPtrs[SV_PALETTEINDEXTOPROGRAM]  = &pPDev->dwPaletteIndexToProgram;
    pPDev->arStdPtrs[SV_CURRENTPALETTEINDEX]    = &pPDev->dwCurrentPaletteIndex  ;
    pPDev->arStdPtrs[SV_PATTERNBRUSH_TYPE]      = &pPDev->dwPatternBrushType;
    pPDev->arStdPtrs[SV_PATTERNBRUSH_ID]        = &pPDev->dwPatternBrushID;
    pPDev->arStdPtrs[SV_PATTERNBRUSH_SIZE]      = &pPDev->dwPatternBrushSize;
    pPDev->arStdPtrs[SV_CURSORORIGINX]  = &(pPDev->sf.ptPrintOffsetM.x);
    pPDev->arStdPtrs[SV_CURSORORIGINY]  = &(pPDev->sf.ptPrintOffsetM.y);
    pPDev->arStdPtrs[SV_PAGENUMBER]      = &pPDev->dwPageNumber;

    return TRUE;

}

BOOL
BMergeAndValidateDevmode(
    PDEV        *pPDev,
    PDEVMODE    pdmInput,
    PRECTL      prcFormImageArea
    )

/*++

Routine Description:

    Validate the input devmode and merge it with the defaults

Arguments:

    pPDev - Points to the current PDEV structure
    pdmInput - Points to the input devmode passed in from GDI
    prcImageArea - Returns the logical imageable area associated with the requested form

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PPRINTER_INFO_2 pPrinterInfo2;

    //
    // Start with the driver default devmode
    //

    pPDev->pdm = PGetDefaultDevmodeWithOemPlugins(
                        NULL,
                        pPDev->pUIInfo,
                        pPDev->pRawData,
                        (pPDev->PrinterData.dwFlags & PFLAGS_METRIC),
                        pPDev->pOemPlugins,
                        pPDev->devobj.hPrinter);

    if (pPDev->pdm == NULL)
        return FALSE;

    //
    // Merge with system default devmode. In the case where the input devmode
    // is NULL, we want to use the system default devmode.
    //

    pPrinterInfo2 = MyGetPrinter(pPDev->devobj.hPrinter, 2);

    if (pPrinterInfo2 && pPrinterInfo2->pDevMode &&
        ! BValidateAndMergeDevmodeWithOemPlugins(
                pPDev->pdm,
                pPDev->pUIInfo,
                pPDev->pRawData,
                pPrinterInfo2->pDevMode,
                pPDev->pOemPlugins,
                pPDev->devobj.hPrinter))
    {
        MemFree(pPrinterInfo2);
        return FALSE;
    }

    MemFree(pPrinterInfo2);

    //
    // Merge it with the input devmode
    //

    if (pdmInput != NULL &&
        !BValidateAndMergeDevmodeWithOemPlugins(
                        pPDev->pdm,
                        pPDev->pUIInfo,
                        pPDev->pRawData,
                        pdmInput,
                        pPDev->pOemPlugins,
                        pPDev->devobj.hPrinter))
    {
        return FALSE;
    }

    pPDev->pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pPDev->pdm);

    //
    // Validate form-related devmode fields and convert information
    // in public devmode fields to feature option indices
    //

    //
    // ChangeOptionsViaID expects a combined option array
    //

    CombineOptionArray(pPDev->pRawData,
                       pPDev->pOptionsArray,
                       MAX_PRINTER_OPTIONS,
                       pPDev->pdmPrivate->aOptions,
                       pPDev->PrinterData.aOptions
                       );

    VFixOptionsArray(    pPDev,

    /*              pPDev->devobj.hPrinter,
                     pPDev->pInfoHeader,
                     pPDev->pOptionsArray,
                     pPDev->pdm,
                     pPDev->PrinterData.dwFlags & PFLAGS_METRIC,  */

                     prcFormImageArea
                     );


    VOptionsToDevmodeFields( pPDev) ;

    SeparateOptionArray(
              pPDev->pRawData,
              pPDev->pOptionsArray,
              pPDev->pdmPrivate->aOptions,
              MAX_PRINTER_OPTIONS,
              MODE_DOCUMENT_STICKY);

    pPDev->devobj.pPublicDM = pPDev->pdm;

    return TRUE;
}



VOID
VOptionsToDevmodeFields(
    PDEV        *pPDev
    )

/*++

Routine Description:

     Convert options in pPDev->pOptionsArray into public devmode fields

Arguments:

     pPDev - Points to UIDATA structure

Return Value:

     None

--*/
{
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwGID, dwFeatureIndex, dwOptionIndex;
    PUIINFO     pUIInfo;
    PDEVMODE    pdm;

    //
    // Go through all predefine IDs and propagate the option selection
    // into appropriate devmode fields
    //

    pUIInfo = pPDev->pUIInfo;
    pdm = pPDev->pdm;

    for (dwGID=0 ; dwGID < MAX_GID ; dwGID++)
    {
        //
        // Get the feature to get the options, and get the index
        // into the option array
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwGID)) == NULL)
        {
            switch(dwGID)
            {
            case GID_RESOLUTION:
                break;   //  can't happen

            case GID_DUPLEX:

                pdm->dmFields &= ~DM_DUPLEX;
                pdm->dmDuplex = DMDUP_SIMPLEX;
                break;

            case GID_INPUTSLOT:

                pdm->dmFields  &= ~DM_DEFAULTSOURCE;
                pdm->dmDefaultSource = DMBIN_ONLYONE;
                break;

            case GID_MEDIATYPE:

                pdm->dmFields  &= ~DM_MEDIATYPE;
                pdm->dmMediaType = DMMEDIA_STANDARD;
                break;

            case GID_ORIENTATION:

                pdm->dmFields  &= ~DM_ORIENTATION;
                pdm->dmOrientation = DMORIENT_PORTRAIT;
                break;

            case GID_PAGESIZE:      //   can't happen :  required feature
                break;
            case GID_COLLATE:
                pdm->dmFields  &= ~DM_COLLATE ;
                pdm->dmCollate = DMCOLLATE_FALSE ;

                break;
            }
            continue;
        }

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pPDev->pOptionsArray[dwFeatureIndex].ubCurOptIndex;

        //
        // Get the pointer to the option array for the feature
        //

        if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) == NULL)
            continue;

        switch(dwGID)
        {
        case GID_RESOLUTION:
        {
            PRESOLUTION pRes = (PRESOLUTION)pOption;

            //
            // Get to the option selected
            //

            pdm->dmFields |= (DM_PRINTQUALITY|DM_YRESOLUTION);
            pdm->dmPrintQuality = GETQUALITY_X(pRes);
            pdm->dmYResolution = GETQUALITY_Y(pRes);

        }
            break;

        case GID_DUPLEX:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DUPLEX;
            pdm->dmDuplex = (SHORT) ((PDUPLEX) pOption)->dwDuplexID;
            break;

        case GID_INPUTSLOT:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DEFAULTSOURCE;
            pdm->dmDefaultSource = (SHORT) ((PINPUTSLOT) pOption)->dwPaperSourceID;
            break;

        case GID_MEDIATYPE:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_MEDIATYPE;
            pdm->dmMediaType = (SHORT) ((PMEDIATYPE) pOption)->dwMediaTypeID;
            break;

        case GID_ORIENTATION:

            if (((PORIENTATION) pOption)->dwRotationAngle == ROTATE_NONE)
                pdm->dmOrientation = DMORIENT_PORTRAIT;
            else
                pdm->dmOrientation = DMORIENT_LANDSCAPE;

            pdm->dmFields |= DM_ORIENTATION;
            break;

        case GID_COLLATE:
            pdm->dmFields |=  DM_COLLATE ;
            pdm->dmCollate = (SHORT) ((PCOLLATE) pOption)->dwCollateID ;

            break;
        case GID_PAGESIZE:      // taken care of by BValidateDevmodeFormFields()
                    //  which is called from init.c:VFixOptionsArray()
            break;
        }
    }
}





VOID
VInitOutputCTL(
    PDEV    *pPDev,
    PRESOLUTIONEX pResEx
)
/*++

Routine Description:

    Initializes the OUTPUTCTL struct

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    None

--*/

{

    //
    // Init currrent cursor position, desired absolute and relative pos
    //

    pPDev->ctl.ptCursor.x = pPDev->ctl.ptCursor.y = 0;
    pPDev->ctl.dwMode |= MODE_CURSOR_UNINITIALIZED;
    pPDev->ctl.ptRelativePos.x = pPDev->ctl.ptRelativePos.y = 0;
    pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptAbsolutePos.y = 0;

    //
    // Init sColor which represent last grx and text color chosen
    //

    if (pPDev->pUIInfo->dwFlags & FLAG_COLOR_DEVICE)
    {
        //
        // Force sending the color command sequence before any output
        //

        pPDev->ctl.sColor = -1;

    }
    else
    {
        //
        // The device is monochrome, don't send color command sequence
        // before output
        //

        pPDev->ctl.sColor = 0;

    }

    //
    // Init lLineSpacing, which represents the last line spacing chosen
    // init to -1 to indicate unknown state
    //

    pPDev->ctl.lLineSpacing = -1;

    //
    // Init the sBytesPerPinPass which represents the physical number
    // of bytes per row of printhead
    //

    pPDev->ctl.sBytesPerPinPass = (SHORT)((pResEx->dwPinsPerPhysPass + 7) >> 3);

}

BOOL
BInitOptions(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This function looked at the currently selected UI options (stored in
    DEVMODE and merged into combined options array - pDevice->pOptionsArray)

    It stored the option structures for predefined features in the PDEVICE
    for later access.

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    TRUE if successful and FALSE if not

--*/
{

    WORD     wGID;
    PFEATURE pFeature;
    DWORD    dwFeatureIndex;
    POPTSELECT pOptions;


    pOptions = pPDev->pOptionsArray;

    for ( wGID = 0 ; wGID < MAX_GID; wGID++)
    {

        switch (wGID)
        {
        case GID_RESOLUTION:
        {
            //
            // Required feature
            //

            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_RESOLUTION))
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);
            else
                return FALSE;

            pPDev->pResolution  = (PRESOLUTION)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);

            pPDev->pResolutionEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                         pPDev->pResolution->GenericOption.loRenderOffset);

            ASSERT(pPDev->pResolution && pPDev->pResolutionEx);

        }
            break;

        case GID_PAGESIZE:
        {
            //
            // Required feature
            //

            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_PAGESIZE))
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);
            else
                return FALSE;

            pPDev->pPageSize   = (PPAGESIZE)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);

            pPDev->pPageSizeEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                         pPDev->pPageSize->GenericOption.loRenderOffset);

            ASSERT(pPDev->pPageSize                   &&
                   pPDev->pPageSizeEx                 );

        }
            break;

        case GID_DUPLEX:
        {
            //
            // Optional
            //

            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_DUPLEX))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pDuplex     = (PDUPLEX)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pDuplex = NULL;

            }
        }
            break;

        case GID_INPUTSLOT:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_INPUTSLOT))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pInputSlot  = (PINPUTSLOT)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
                ASSERT(pPDev->pInputSlot);
#if 0
                //
                // InputSlotEx struct is deleted.
                //
                pPDev->pInputSlotEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                             pPDev->pInputSlot->GenericOption.loRenderOffset);
                ASSERT(pPDev->pInputSlotEx);
#endif

            }
            else
            {
                pPDev->pInputSlot = NULL;
//                pPDev->pInputSlotEx = NULL;

            }
        }
            break;


        case GID_MEMOPTION:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_MEMOPTION))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pMemOption   = (PMEMOPTION)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pMemOption = NULL;

            }

        }
            break;

        case GID_COLORMODE:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_COLORMODE))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pColorMode   = (PCOLORMODE)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
                pPDev->pColorModeEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                            pPDev->pColorMode->GenericOption.loRenderOffset);

            }
            else
            {
                pPDev->pColorMode = NULL;

            }
         }
            break;

        case GID_ORIENTATION:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_ORIENTATION))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pOrientation   = (PORIENTATION)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pOrientation = NULL;

            }

        }
            break;

        case GID_PAGEPROTECTION:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_PAGEPROTECTION))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pPageProtect  = (PPAGEPROTECT)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pPageProtect = NULL;

            }
        }
            break;

        case GID_HALFTONING:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_HALFTONING))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pHalftone      = (PHALFTONING)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pHalftone = NULL;

            }

        }
            break;
#if 0

        case GID_MEDIATYPE:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_MEDIATYPE))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pMediaType  = (PMEDIATYPE)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pMediaType = NULL;

            }

        }
            break;


        case GID_COLLATE:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_COLLATE))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pCollate        = PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pCollate = NULL;

            }

        }
            break;

        case GID_OUTPUTBIN:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_OUTPUTBIN))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pOutputBin   = PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pOutputBin = NULL;

            }

        }
            break;
#endif
        default:
            break;
        }

    }
    return TRUE;
}


BOOL
BInitPaperFormat(
    PDEV    *pPDev,
    RECTL   *pFormImageArea
    )

/*++

Routine Description:

    Figure out the currently selected paper size and initialize
    the PAPERFORMAT & SURFACEFORMAT structs

Arguments:

    pPDev - Pointer to PDEVICE
    pFormImageArea - Pointer to Imageable area of the form

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    The followings are assumptions made by this function regarding information
    in the parser snapshot.

    - szPaperSize in PAGESIZE is always in portrait mode.
    - szImageArea in PAGESIZE is always in portrait mode.
    - ptImageOrigin in PAGESIZE is always in portrait mode.
    - Printer cursor offset calculation is dependent of pGlobals->bRotateCoordinate.
      If this is set to TRUE, must calculate it according to the rotation angle
      specified in ORIENATION.dwRotationAngle

--*/
{
    PPAGESIZE       pPaper;
    PPAGESIZEEX     pPaperEx;
    RECTL           rcMargins, rcImgArea, rcIntersectArea;
    SIZEL           szPaperSize, szImageArea;
    PFN_OEMTTYGetInfo   pfnOemTTYGetInfo;
    DWORD           cbcNeeded;
    BOOL  bOEMinfo = FALSE ;



    //
    // Get the current selected paper size and paper source
    //

    pPaper = pPDev->pPageSize;
    pPaperEx = pPDev->pPageSizeEx;

    ASSERT(pPaper && pPaperEx);

    //
    // Convert pFormImageArea from microns to master units
    //

    pFormImageArea->left  = MICRON_TO_MASTER(pFormImageArea->left,
                                               pPDev->pGlobals->ptMasterUnits.x);

    pFormImageArea->top   = MICRON_TO_MASTER(pFormImageArea->top ,
                                               pPDev->pGlobals->ptMasterUnits.y);

    pFormImageArea->right = MICRON_TO_MASTER(pFormImageArea->right ,
                                               pPDev->pGlobals->ptMasterUnits.x);

    pFormImageArea->bottom = MICRON_TO_MASTER(pFormImageArea->bottom ,
                                               pPDev->pGlobals->ptMasterUnits.y);

    //
    // If it's a user defined paper size, use the dimensions in devmode
    // otherwise get it from the pagesize option
    //

    if (pPaper->dwPaperSizeID == DMPAPER_USER)
    {
        //
        // Need to convert from 0.1mm to micrometer
        // .1mm * 100 gives micrometer. and convert to Master unit
        //

        szPaperSize.cx =  MICRON_TO_MASTER(
                                    pPDev->pdm->dmPaperWidth * 100,
                                    pPDev->pGlobals->ptMasterUnits.x);
        szPaperSize.cy =  MICRON_TO_MASTER(
                                    pPDev->pdm->dmPaperLength * 100,
                                    pPDev->pGlobals->ptMasterUnits.y);

        // calculate szImageArea after margins
    }
    else
    {
        CopyMemory(&szPaperSize, &pPaper->szPaperSize, sizeof(SIZEL));
        CopyMemory(&szImageArea, &pPaperEx->szImageArea, sizeof(SIZEL));

        //
        // Exchange X & Y dimensions: This is used only when the paper size( like
        // envelopes) does not suit the printer's paper feeding method.
        // equivalent to PS_ROTATE in GPC
        //

        if (pPaperEx->bRotateSize)
        {
            VSwapL(&szPaperSize.cx, &szPaperSize.cy);
            VSwapL(&pFormImageArea->right, &pFormImageArea->bottom);
        }
    }

    //
    // GetPaperMargins calculates the margins based on the paper size margins,
    // forms margins, and feed margins.
    // rcMargins returned is in portrait mode
    //

    bOEMinfo = FALSE ;

    if  (pPDev->pGlobals->printertype == PT_TTY)
    {
        if (!pPDev->pOemHookInfo  ||  !(pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pOemEntry))
            return(FALSE) ;  //  TTY driver must support this function.

        FIX_DEVOBJ(pPDev, EP_OEMTTYGetInfo);

        if(pPDev->pOemEntry)
        {
            if(  ((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                            (PDEVOBJ)pPDev, OEMTTY_INFO_MARGINS, &rcMargins, sizeof(RECTL), &cbcNeeded);
                if(!SUCCEEDED(hr))
                    bOEMinfo = FALSE ;
                else
                    bOEMinfo = TRUE ;

            }
            else  if(         (pfnOemTTYGetInfo = (PFN_OEMTTYGetInfo)pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pfnHook) &&
                 (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_MARGINS, &rcMargins, sizeof(RECTL), &cbcNeeded)))
                        bOEMinfo = TRUE ;
        }
    }

    if(bOEMinfo)
    {
        //
        // Need to convert .1mm to Master Units
        //

        rcMargins.left = MICRON_TO_MASTER(rcMargins.left * 100,
                                            pPDev->pGlobals->ptMasterUnits.x);

        rcMargins.top = MICRON_TO_MASTER(rcMargins.top * 100,
                                            pPDev->pGlobals->ptMasterUnits.y);

        rcMargins.right = MICRON_TO_MASTER(rcMargins.right * 100,
                                            pPDev->pGlobals->ptMasterUnits.x);

        rcMargins.bottom = MICRON_TO_MASTER(rcMargins.bottom * 100,
                                            pPDev->pGlobals->ptMasterUnits.y);
    }
    else
    {
        VGetPaperMargins(pPDev, pPaper, pPaperEx, szPaperSize, &rcMargins);
    }

    if (pPaper->dwPaperSizeID == DMPAPER_USER)
    {
        szImageArea.cx = szPaperSize.cx - rcMargins.left - rcMargins.right;
        szImageArea.cy = szPaperSize.cy - rcMargins.top - rcMargins.bottom;
    }

    //
    // Adjust margins and szImageArea to take into account the
    // form margins, just in case the form is not a built-in form
    //

    rcImgArea.left = rcMargins.left;
    rcImgArea.top = rcMargins.top;
    rcImgArea.right = rcMargins.left + szImageArea.cx;
    rcImgArea.bottom = rcMargins.top + szImageArea.cy;

    if (!BIntersectRect(&rcIntersectArea, &rcImgArea, pFormImageArea))
        return FALSE;

    rcMargins.left = rcIntersectArea.left;
    rcMargins.top = rcIntersectArea.top;
    rcMargins.right = szPaperSize.cx - rcIntersectArea.right;
    rcMargins.bottom = szPaperSize.cy - rcIntersectArea.bottom;
    szImageArea.cx  = rcIntersectArea.right - rcIntersectArea.left;
    szImageArea.cy = rcIntersectArea.bottom - rcIntersectArea.top;

    //
    // ready to initialize PAPERFORMAT struct now
    //

    pPDev->pf.szPhysSizeM.cx = szPaperSize.cx;
    pPDev->pf.szPhysSizeM.cy = szPaperSize.cy;
    pPDev->pf.szImageAreaM.cx = szImageArea.cx;
    pPDev->pf.szImageAreaM.cy = szImageArea.cy;
    pPDev->pf.ptImageOriginM.x = rcMargins.left;
    pPDev->pf.ptImageOriginM.y = rcMargins.top;

    //
    // Now, take current orientation into consideration and set up
    // SURFACEFORMAT struct.
    // Note that pPDev->ptGrxScale has alreay been rotated to suit the orientation.
    //
    if (pPDev->pdm->dmOrientation == DMORIENT_LANDSCAPE)
    {
        pPDev->sf.szPhysPaperG.cx = szPaperSize.cy / pPDev->ptGrxScale.x;
        pPDev->sf.szPhysPaperG.cy = szPaperSize.cx / pPDev->ptGrxScale.y;

        pPDev->sf.szImageAreaG.cx = szImageArea.cy / pPDev->ptGrxScale.x;
        pPDev->sf.szImageAreaG.cy = szImageArea.cx / pPDev->ptGrxScale.y;

        //
        // 2 scenarios for landscape mode
        // CC_90, rotate CC 90 degrees, for dot matrix style printers
        // CC_270, rotate CC 270 degrees, for Laser Jet style printers
        //

        if ( pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle == ROTATE_90)
        {
            pPDev->sf.ptImageOriginG.x = rcMargins.bottom / pPDev->ptGrxScale.x;
            pPDev->sf.ptImageOriginG.y = rcMargins.left / pPDev->ptGrxScale.y;
        }
        else
        {
            pPDev->sf.ptImageOriginG.x = rcMargins.top / pPDev->ptGrxScale.x;
            pPDev->sf.ptImageOriginG.y = rcMargins.right / pPDev->ptGrxScale.y;
        }

        if (!pPDev->pOrientation  ||  pPDev->pGlobals->bRotateCoordinate == FALSE)
        {
            pPDev->sf.ptPrintOffsetM.x = pPDev->pf.ptImageOriginM.x - pPaperEx->ptPrinterCursorOrig.x;
            pPDev->sf.ptPrintOffsetM.y = pPDev->pf.ptImageOriginM.y - pPaperEx->ptPrinterCursorOrig.y;

        }
        else
        {
            if ( pPDev->pOrientation->dwRotationAngle == ROTATE_90)
            {
                pPDev->sf.ptPrintOffsetM.x =
                    rcMargins.bottom + pPaperEx->ptPrinterCursorOrig.y - pPDev->pf.szPhysSizeM.cy;
                pPDev->sf.ptPrintOffsetM.y =
                    rcMargins.left - pPaperEx->ptPrinterCursorOrig.x;
            }
            else
            {
                pPDev->sf.ptPrintOffsetM.x =
                    rcMargins.top - pPaperEx->ptPrinterCursorOrig.y;
                pPDev->sf.ptPrintOffsetM.y =
                    rcMargins.right + pPaperEx->ptPrinterCursorOrig.x - pPDev->pf.szPhysSizeM.cx;
            }

        }
    }
    else
    {
        pPDev->sf.szPhysPaperG.cx = szPaperSize.cx / pPDev->ptGrxScale.x;
        pPDev->sf.szPhysPaperG.cy = szPaperSize.cy / pPDev->ptGrxScale.y;
        pPDev->sf.szImageAreaG.cx = szImageArea.cx / pPDev->ptGrxScale.x;
        pPDev->sf.szImageAreaG.cy = szImageArea.cy / pPDev->ptGrxScale.y;

        pPDev->sf.ptImageOriginG.x = rcMargins.left / pPDev->ptGrxScale.x;
        pPDev->sf.ptImageOriginG.y = rcMargins.top / pPDev->ptGrxScale.y;

        pPDev->sf.ptPrintOffsetM.x = pPDev->pf.ptImageOriginM.x - pPaperEx->ptPrinterCursorOrig.x;
        pPDev->sf.ptPrintOffsetM.y = pPDev->pf.ptImageOriginM.y - pPaperEx->ptPrinterCursorOrig.y;

    }

    return TRUE;
}

VOID
VGetPaperMargins(
    PDEV        *pPDev,
    PAGESIZE    *pPageSize,
    PAGESIZEEX  *pPageSizeEx,
    SIZEL       szPhysSize,
    PRECTL      prcMargins

    )

/*++

Routine Description:

    Calculate the margins based on paper margins and the input slot feed margins.

Arguments:

    pPDev - Pointer to PDEVICE
    pPageSize - pointer to PAGESIZE
    pPageSizeEx - Pointer to PAGESIZEEX
    szPhysSize - physical dimensions (after applying *RotateSize?)
    prcMargins - Pointer to RECTL to hold the margins calculated

Return Value:

    None

Note:

    All margins calculations are in Portrait mode.
    The margins returned in prcMargins are in portrait mode

    Assumed that physical paper size, image area, and image origin in binary
    data are in portrait mode.

--*/
{
    if (pPageSize->dwPaperSizeID == DMPAPER_USER)
    {
        if(pPageSizeEx->strCustCursorOriginX.dwCount == 5 &&
            pPageSizeEx->strCustCursorOriginY.dwCount == 5  &&
            pPageSizeEx->strCustPrintableOriginX.dwCount == 5 &&
            pPageSizeEx->strCustPrintableOriginY.dwCount == 5  &&
            pPageSizeEx->strCustPrintableSizeX.dwCount == 5  &&
            pPageSizeEx->strCustPrintableSizeY.dwCount == 5  )  // if all parameters present...
        {
            SIZEL       szImageArea;            // *PrintableArea, for CUSTOMSIZE options
            POINT       ptImageOrigin;          // *PrintableOrigin, for CUSTOMSIZE options
            BYTE    *pInvocationStr;         //  points to parameter reference:   "%dddd"
            PARAMETER *pParameter;          //  points to parameter structure  referenced by "%dddd"
            BOOL    bMaxRepeat = FALSE;     // dummy placeholder.


            //   init standard variable for papersize!  since these are not yet initialized at this time!
            //   this implies GPD writer may only reference  the standard vars "PhysPaperLength"
            //  and   "PhysPaperWidth"   in these parameters.

            pPDev->pf.szPhysSizeM.cx = szPhysSize.cx;
            pPDev->pf.szPhysSizeM.cy = szPhysSize.cy;
            pPDev->arStdPtrs[SV_PHYSPAPERLENGTH]= &pPDev->pf.szPhysSizeM.cy;
            pPDev->arStdPtrs[SV_PHYSPAPERWIDTH] = &pPDev->pf.szPhysSizeM.cx;

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustCursorOriginX.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            pPageSizeEx->ptPrinterCursorOrig.x = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustCursorOriginY.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            pPageSizeEx->ptPrinterCursorOrig.y = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableOriginX.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            ptImageOrigin.x = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableOriginY.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            ptImageOrigin.y = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableSizeX.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            szImageArea.cx = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableSizeY.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            szImageArea.cy = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            prcMargins->left = ptImageOrigin.x;
            prcMargins->top = ptImageOrigin.y;
            prcMargins->right = szPhysSize.cx - szImageArea.cx - ptImageOrigin.x;
            prcMargins->bottom = szPhysSize.cy - szImageArea.cy - ptImageOrigin.y;
        }
        else
        {
            DWORD dwHorMargin, dwLeftMargin;

            //
            // calculate the margins and printable area based on info in pPageSizeEx
            //
            prcMargins->top = pPageSizeEx->dwTopMargin;
            prcMargins->bottom = pPageSizeEx->dwBottomMargin;

            //
            // Calculate the horizontal margin and adjust it if the user specified
            // centering the printable area along the paper path
            //
            if((DWORD)szPhysSize.cx < pPageSizeEx->dwMaxPrintableWidth)
                 dwHorMargin = 0;
             else
                 dwHorMargin = szPhysSize.cx - pPageSizeEx->dwMaxPrintableWidth;
            //
            // Determine the horizontal margins.  If they are centered,  then the
            // Left margin is simply the overall divided in two.  But,  we need to
            // consider both the printer's and form's margins,  and choose the largest.
            //
            if( pPageSizeEx->bCenterPrintArea)
                dwLeftMargin = (dwHorMargin / 2);
            else
                dwLeftMargin = 0;

            prcMargins->left = dwLeftMargin < pPageSizeEx->dwMinLeftMargin ?
                                    pPageSizeEx->dwMinLeftMargin : dwLeftMargin;

            if( dwHorMargin > (DWORD)prcMargins->left ) // still have margin to distribute
                prcMargins->right = dwHorMargin - prcMargins->left;
            else
                prcMargins->right = 0;
        }

    }
    else
    {
        prcMargins->left = pPageSizeEx->ptImageOrigin.x;
        prcMargins->top = pPageSizeEx->ptImageOrigin.y;
        prcMargins->right = szPhysSize.cx - pPageSizeEx->szImageArea.cx
                                          - pPageSizeEx->ptImageOrigin.x;
        prcMargins->bottom = szPhysSize.cy - pPageSizeEx->szImageArea.cy
                                           - pPageSizeEx->ptImageOrigin.y;

    }

    //
    // All margins are positive or zero
    //

    if( prcMargins->top < 0 )
        prcMargins->top = 0;

    if( prcMargins->bottom < 0 )
        prcMargins->bottom = 0;

    if( prcMargins->left < 0 )
        prcMargins->left = 0;

    if( prcMargins->right < 0 )
        prcMargins->right = 0;

}

VOID
VInitFYMove(
    PDEV    *pPDev
)
/*++

Routine Description:

    Initialize the fYMove flag in PDEVICE from reading the
    YMoveAttributes keyword

Arguments:

    pPDEV - Pointer to PDEVICE

Return Value:

    None

--*/
{
    PLISTNODE pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                      pPDev->pGlobals->liYMoveAttributes);
    pPDev->fYMove = 0;

    while (pListNode)
    {

        if (pListNode->dwData == YMOVE_FAVOR_LINEFEEDSPACING)
            pPDev->fYMove |= FYMOVE_FAVOR_LINEFEEDSPACING;

        if (pListNode->dwData == YMOVE_SENDCR_FIRST)
            pPDev->fYMove |= FYMOVE_SEND_CR_FIRST;

        if (pListNode->dwNextItem == END_OF_LIST)
            break;
        else
            pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                    pListNode->dwNextItem);
    }
}

VOID
VInitFMode(
    PDEV    *pPDev
)
/*++

Routine Description:

    Initialize the fMode flag in PDEVICE to reflect the settings saved
    in Devmode.dmPrivate.dwFlags AND to reflect the device capabilities

Arguments:

    pPDEV - Pointer to PDEVICE

Return Value:

    None

--*/
{
    if (pPDev->pdmPrivate->dwFlags & DXF_NOEMFSPOOL)
        pPDev->fMode |= PF_NOEMFSPOOL;

    //
    // Adjust memory for page protection only if the user selects
    // to turn on page protection and this feature exists.
    //

    if ( (pPDev->PrinterData.dwFlags & PFLAGS_PAGE_PROTECTION) &&
            pPDev->pPageProtect  &&
         (pPDev->pPageProtect->dwPageProtectID == PAGEPRO_ON) )
    {
        //
        // Look up the page protection value in the PAGESIZE struct for the
        // paper size selected
        //

        DWORD   dwPageMem = pPDev->pPageSize->dwPageProtectionMemory;

        if (dwPageMem < pPDev->dwFreeMem)
        {
            pPDev->fMode |= PF_PAGEPROTECT;
            pPDev->dwFreeMem -= dwPageMem;
        }

        ASSERT(pPDev->dwFreeMem > 0);
    }

    //
    // Check whether the device can do landscape rotation
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateRasterData == FALSE)
    {
        //
        // bRotateRasterData is set to TRUE if the device can rotate
        // graphics data.  Otherwise, the driver will have to do it.
        // PF_ROTATE is set to indicate that the driver needs to rotate
        // the graphics data, for when we do banding.
        //

        pPDev->fMode |= PF_ROTATE;

        if (pPDev->pOrientation->dwRotationAngle == ROTATE_90)
            pPDev->fMode |= PF_CCW_ROTATE90;
    }

    //
    // Init X and Y move CMD capabilities
    //

    if (pPDev->arCmdTable[CMD_XMOVERELLEFT] == NULL &&
        pPDev->arCmdTable[CMD_XMOVERELRIGHT] == NULL)
    {
        pPDev->fMode |= PF_NO_RELX_MOVE;
    }

    if (pPDev->arCmdTable[CMD_YMOVERELUP] == NULL &&
        pPDev->arCmdTable[CMD_YMOVERELDOWN] == NULL)
    {
        pPDev->fMode |= PF_NO_RELY_MOVE;
    }

    if (pPDev->arCmdTable[CMD_XMOVEABSOLUTE] == NULL &&
        pPDev->arCmdTable[CMD_XMOVERELRIGHT] == NULL)
    {
        pPDev->fMode |= PF_NO_XMOVE_CMD;
    }

    if (pPDev->arCmdTable[CMD_YMOVEABSOLUTE] == NULL &&
        pPDev->arCmdTable[CMD_YMOVERELDOWN] == NULL)
    {
        pPDev->fMode |= PF_NO_YMOVE_CMD;
    }

    if (pPDev->arCmdTable[CMD_SETRECTWIDTH] != NULL &&
        pPDev->arCmdTable[CMD_SETRECTHEIGHT] != NULL)
    {
        pPDev->fMode |= PF_RECT_FILL;
    }

    if (pPDev->arCmdTable[CMD_RECTWHITEFILL] != NULL)
        pPDev->fMode |= PF_RECTWHITE_FILL;

    //
    // Init brush selection capabilities
    //

    if (pPDev->arCmdTable[CMD_DOWNLOAD_PATTERN] )
        pPDev->fMode |= PF_DOWNLOAD_PATTERN;

    if (pPDev->arCmdTable[CMD_SELECT_PATTERN])
        pPDev->fMode |= PF_SHADING_PATTERN;

    //
    // BUG_BUG, need to get rid of CMD_WHITETEXTON, CMD_WHITETEXTOFF once
    // all the GPD changes have completed for CMD_SELECT_WHITEBRUSH, CMD_SELECT_BLACKBRUSH
    //     no harm done either way.

    if ( (pPDev->arCmdTable[CMD_SELECT_WHITEBRUSH] &&
          pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH]) ||
         (pPDev->arCmdTable[CMD_WHITETEXTON] &&
          pPDev->arCmdTable[CMD_WHITETEXTOFF]) )
        pPDev->fMode |= PF_WHITEBLACK_BRUSH;

    // 
    // Init raster mirroring flag
    //
    if (pPDev->pGlobals->bMirrorRasterPage)
        pPDev->fMode2 |= PF2_MIRRORING_ENABLED;

}


INT
iHypot(
    INT iX,
    INT iY
    )
/*++

Routine Description:

    Calculates the length of the hypotenous of a right triangle whose
    sides are passed in as parameters

Arguments:

    iX, iY - Sides of a right triangle

Return Value:

    The hypotenous of the triangle

--*/
{
    register INT  iHypo;

    INT iDelta, iTarget;

    /*
     *     Finds the hypoteneous of a right triangle with legs equal to x
     *  and y.  Assumes x, y, hypo are integers.
     *  Use sq(x) + sq(y) = sq(hypo);
     *  Start with MAX(x, y),
     *  use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the
     *  target hypotenouse.
     */

    iHypo = max( iX, iY );
    iTarget = min( iX,iY );
    iTarget = iTarget * iTarget;

    for( iDelta = 0; iDelta < iTarget; iHypo++ )
        iDelta += (iHypo << 1) + 1;


    return   iHypo;
}


INT
iGCD(
    INT i0,
    INT i1
    )
/*++

Routine Description:

    Calculates the Greatest Common Divisor. Use Euclid's algorith.

Arguments:

    i0, i1  - the first and second number

Return Value:

    The greatest common divisor

--*/
{
    int   iRem;       /* Will be the remainder */


    if( i0 < i1 )
    {
        /*   Need to interchange them */
        iRem = i0;
        i0 = i1;
        i1 = iRem;
    }

    while( iRem = (i0 % i1) )
    {
        /*   Step along to the next value */
        i0 = i1;
        i1 = iRem;
    }

    return   i1;            /*  The answer! */
}

BOOL
BIntersectRect(
    OUT PRECTL   prcDest,
    IN  PRECTL   prcRect1,
    IN  PRECTL   prcRect2
    )

/*++

Routine Description:

    Intersect the Rec1 and Rect2
    and store the result in the destination rectangle

Arguments:

    prcDest - Points to the destination rectangle
    prcSrc - Points to the source rectangle

Return Value:

    FALSE if the intersected rectangle is empty
    TRUE otherwise

--*/

{
    ASSERT(prcDest != NULL && prcRect1 != NULL && prcRect2 != NULL);

    if (prcRect1->left < prcRect2->left)
        prcDest->left = prcRect2->left;
    else
        prcDest->left = prcRect1->left;


    if (prcRect1->top < prcRect2->top)
        prcDest->top = prcRect2->top;
    else
        prcDest->top = prcRect1->top;

    if (prcRect1->right > prcRect2->right)
        prcDest->right = prcRect2->right;
    else
        prcDest->right = prcRect1->right;

    if (prcRect1->bottom > prcRect2->bottom)
        prcDest->bottom = prcRect2->bottom;
    else
        prcDest->bottom = prcRect1->bottom;

    return (prcDest->right > prcDest->left) &&
           (prcDest->bottom > prcDest->top);
}


VOID
SetRop3(
    PDEV    *pPDev,
    DWORD   dwRop3
    )
/*++

Routine Description:

    This function set the Rop3 value for the Raster and Font module

Arguments:
    pPDev   Pointer to PDEVICE
    dwRop3  Rop3 value
Return Value:

    FALSE if the intersected rectangle is empty
    TRUE otherwise

--*/

{
    ASSERT(VALID_PDEV(pPDev));

    pPDev->dwRop3 = dwRop3;

}

VOID
VUnloadFreeBinaryData(
    IN  PDEV        *pPDev
)
/*++

Routine Description:

    This function frees the binary data

Arguments:

    pPDev - Pointer to PDEV

Return Value:

    None

Note:


--*/
{
    INT iCmd;

    //
    // Call parser to free memory allocated for binary data
    //

    if (pPDev->pRawData)
        UnloadRawBinaryData(pPDev->pRawData);

    if (pPDev->pInfoHeader)
        FreeBinaryData(pPDev->pInfoHeader);

    pPDev->pRawData = NULL;
    pPDev->pInfoHeader = NULL;
    pPDev->pUIInfo = NULL;
    //
    // pPDev->pUIInfo is reset so update the winresdata pUIInfo also.
    //
    pPDev->WinResData.pUIInfo = NULL;

    pPDev->pDriverInfo = NULL;
    pPDev->pGlobals = NULL;

    for (iCmd = 0; iCmd < CMD_MAX; iCmd++)
    {
        pPDev->arCmdTable[iCmd] =  NULL;
    }

    pPDev->pOrientation =  NULL;
    pPDev->pResolution =   NULL;
    pPDev->pResolutionEx = NULL;
    pPDev->pColorMode =    NULL;
    pPDev->pColorModeEx =  NULL;
    pPDev->pDuplex =       NULL;
    pPDev->pPageSize =     NULL;
    pPDev->pPageSizeEx =   NULL;
    pPDev->pInputSlot =    NULL;
    pPDev->pMemOption =    NULL;
    pPDev->pHalftone =     NULL;
    pPDev->pPageProtect =  NULL;

}

BOOL
BReloadBinaryData(
    IN  PDEV        *pPDev
)
/*++

Routine Description:

    This function reloads the binary data and reinitializes the
    offsets and pointers for access to snapshot data

Arguments:

    pPDev - Pointer to PDEV

Return Value:

    Returns TRUE if successful, otherwise FALSE

Note:


--*/
{
    //
    // Reloads binary data and reinit data pointers
    //

    if (! (pPDev->pRawData = LoadRawBinaryData(pPDev->pDriverInfo3->pDataFile)) ||
        ! (pPDev->pInfoHeader = InitBinaryData(pPDev->pRawData, NULL, pPDev->pOptionsArray)) ||
        ! (pPDev->pDriverInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loDriverOffset)) ||
        ! (pPDev->pUIInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loUIInfoOffset)) ||
        ! (pPDev->pGlobals = &(pPDev->pDriverInfo->Globals)) )
            return FALSE;

    //
    // pPDev->pUIInfo is reset so update the winresdata pUIInfo also.
    //
    pPDev->WinResData.pUIInfo = pPDev->pUIInfo;

    //
    // Rebuilds the command table
    //

    if (BInitCmdTable(pPDev) == FALSE)
        return FALSE;

    //
    // Rebuilds all the options pointers in PDEV
    //

    if (BInitOptions(pPDev) == FALSE)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\graphics.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    graphics.c

Abstract:

    Implementation of graphics related DDI entry points:
        DrvCopyBits
        DrvBitBlt
        DrvStretchBlt
        DrvStretchBltROP
        DrvDitherColor
        DrvPlgBlt
        DrvPaint
        DrvLineTo
        DrvStrokePath
        DrvFillPath
        DrvStrokeAndFillPath
        DrvRealizeBrush
        DrvAlphaBlend
        DrvGradientFill
        DrvTransparentBlt

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support

--*/

//#define DBGNEWRULES 1

#include "unidrv.h"

VOID CheckBitmapSurface(
    SURFOBJ *pso,
    RECTL   *pRect
    )
/*++

Routine Description:

    This function checks whether the bitmap surface has
    been erased and if not it erases it. It needs to be
    called before every Drv draw function.

Arguments:

    pso     Points to surface

--*/
{
    PDEV * pPDev = (PDEV *)pso->dhpdev;
    int iWhiteIndex;

    //
    // This function should only be called from a bitmap
    // surface driver. If the driver is device managed
    // just return
    if (DRIVER_DEVICEMANAGED (pPDev))   // a device surface
    {
        WARNING(("CheckBitmapSurface is being called from a device surface driver"));
        return;
    }

    //
    // If it hasn't already been done, erase the
    // bitmap surface.
    //
    if (!(pPDev->fMode & PF_SURFACE_USED))
    {
        pPDev->fMode |= PF_SURFACE_USED;
        if (pPDev->pbRasterScanBuf == NULL)
        {
            RECTL rcPage;
            iWhiteIndex = ((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;

            rcPage.left = 0;
            rcPage.top = 0;
            rcPage.right = pPDev->szBand.cx;
            rcPage.bottom = pPDev->szBand.cy;

            EngEraseSurface( pso, &rcPage, iWhiteIndex );
            pPDev->fMode |= PF_SURFACE_ERASED;
        }
    }
#ifndef DISABLE_NEWRULES
    //
    // determine whether there are any rules that have previously been
    // detected but now need to be drawn because they overlap with this object
    //
    if (pPDev->pbRulesArray && pPDev->dwRulesCount)
    {
        DWORD i = 0;
        RECTL SrcRect;
        DWORD dwRulesCount = pPDev->dwRulesCount;
        PRECTL pRules = pPDev->pbRulesArray;
        pPDev->pbRulesArray = NULL;

        if (pRect == NULL)
        {
            SrcRect.left = SrcRect.top = 0;
            SrcRect.right = pPDev->szBand.cx;
            SrcRect.bottom = pPDev->szBand.cy;
        }
        else
        {
            SrcRect = *pRect;
            if (SrcRect.top > SrcRect.bottom)
            {
                int tmp = SrcRect.top;
                SrcRect.top = SrcRect.bottom;
                SrcRect.bottom = tmp;
            }
            if (SrcRect.top < 0)
                SrcRect.top = 0;
            if (SrcRect.bottom > pPDev->szBand.cy)
                SrcRect.bottom = pPDev->szBand.cy;
            if (SrcRect.left > SrcRect.right)
            {
                int tmp = SrcRect.left;
                SrcRect.left = SrcRect.right;
                SrcRect.right = tmp;
            }
            if (SrcRect.left < 0)
                SrcRect.left = 0;
            if (SrcRect.right > pPDev->szBand.cx)
                SrcRect.right = pPDev->szBand.cx;
        }

        // Now we loop once for every potential rule to see if the current object
        // overlaps any of them. If so we need to bitblt black into that area but we
        // try to save any of the rule that extends outside the current object.
        //        
        while (i < dwRulesCount)
        {
            PRECTL pTmp = &pRules[i];
            POINTL BrushOrg = {0,0};
            
            if (pTmp->right > SrcRect.left &&
                pTmp->left < SrcRect.right &&
                pTmp->bottom > SrcRect.top &&
                pTmp->top < SrcRect.bottom)
            {
                if (pTmp->top < SrcRect.top && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->bottom = SrcRect.top;
                    pTmp->top = SrcRect.top;
                }
                if (pTmp->bottom > SrcRect.bottom && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->top = SrcRect.bottom;
                    pTmp->bottom = SrcRect.bottom;
                }
                if (pTmp->right > SrcRect.right && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->left = SrcRect.right;
                    pTmp->right = SrcRect.right;
                }
                if (pTmp->left < SrcRect.left && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->right = SrcRect.left;
                    pTmp->left = SrcRect.left;
                }
#ifdef DBGNEWRULES                
				DbgPrint("Removed rule %u: L%u,R%u,T%u,B%u; L%u,R%u,T%u,B%u\n",
					dwRulesCount,pTmp->left,pTmp->right,pTmp->top,pTmp->bottom,
					SrcRect.left,SrcRect.right,SrcRect.top,SrcRect.bottom);
#endif                    
                CheckBitmapSurface(pPDev->pso,pTmp);
                EngBitBlt(pPDev->pso,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            pTmp,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            0x0000);    // rop4 = BLACKNESS = 0
                // 
                // if we draw this in the bitmap instead of downloading we may need
                // to download a white rectangle to erase anything else already drawn
                //
                if ((COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL)) &&
                    (pPDev->fMode & PF_DOWNLOADED_TEXT))
                {
                    INT j;
                    BYTE bMask = BGetMask(pPDev, pTmp);
                    BOOL bSendRectFill = FALSE;
                    for (j = pTmp->top; j < pTmp->bottom ; j++)
                    {
                        if (pPDev->pbScanBuf[j] & bMask)
                        {
                            bSendRectFill = TRUE;
                            break;
                        }
                    }
                    //
                    // check if we overlap with downloaded text
                    //
                    if (bSendRectFill)
                    {
                        DRAWPATRECT PatRect;
                        PatRect.wStyle = 1;     // white rectangle
                        PatRect.wPattern = 0;   // pattern not used
                        PatRect.ptPosition.x = pTmp->left;
                        PatRect.ptPosition.y = pTmp->top;
                        PatRect.ptSize.x = pTmp->right - pTmp->left;
                        PatRect.ptSize.y = pTmp->bottom - pTmp->top;
                        DrawPatternRect(pPDev,&PatRect);
                    }
                }
                dwRulesCount--;
                *pTmp = pRules[dwRulesCount];
            }
            else
                i++;
        }        
        pPDev->dwRulesCount = dwRulesCount;
        pPDev->pbRulesArray = pRules;
    }
#endif    
    //
    // if entire surface hasn't been erased then
    // we need to erase the require section
    //
    if (!(pPDev->fMode & PF_SURFACE_ERASED))
    {
        int y1,y2;
        long iScan;
        long dwWidth = pso->lDelta;
        PBYTE pBits = (PBYTE)pso->pvBits;
        if (pRect == NULL)
        {
            pPDev->fMode |= PF_SURFACE_ERASED;
            y1 = 0;
            y2 = pPDev->szBand.cy - 1;
        }
        else
        {
            if (pRect->top > pRect->bottom)
            {
                y1 = max(0,pRect->bottom);
                y2 = min (pPDev->szBand.cy-1,pRect->top);
            }
            else
            {
                y1 = max(0,pRect->top);
                y2 = min(pPDev->szBand.cy-1,pRect->bottom);
            }
        }
        y1 = y1 / LINESPERBLOCK;
        y2 = y2 / LINESPERBLOCK;
        while ( y1 <= y2)
        {
            // test whether this block has already been erased
            //
            if (pPDev->pbRasterScanBuf[y1] == 0)
            {
                // specify block as erased
                pPDev->pbRasterScanBuf[y1] = 1;
                //
                // determined erase byte
                //
                if (pPDev->sBitsPixel == 4)
                    iWhiteIndex = 0x77;
                else if (pPDev->sBitsPixel == 8)
                    iWhiteIndex = ((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;
                else
                    iWhiteIndex = 0xff;
                //
                // determine block size and erase block
                //
                iScan = pPDev->szBand.cy - (y1 * LINESPERBLOCK);
                if (iScan > LINESPERBLOCK)
                    iScan = LINESPERBLOCK;
#ifndef WINNT_40
                FillMemory (&pBits[(ULONG_PTR )dwWidth*y1*LINESPERBLOCK],
                                (SIZE_T)dwWidth*iScan,(BYTE)iWhiteIndex);
#else
                FillMemory (&pBits[(ULONG_PTR )dwWidth*y1*LINESPERBLOCK],
                                dwWidth*iScan,(BYTE)iWhiteIndex);
#endif
            }
            y1++;
        }
    }
}
#ifndef DISABLE_NEWRULES

VOID AddRuleToList(
	PDEV *pPDev,
	PRECTL pRect,
	CLIPOBJ *pco
)
/*++

Routine Description:

    This function checks whether a potential black rule needs to be clipped.

Arguments:

    pPDev
	pRect		black rule
	pco			clip object

--*/
{
        //
        // if clip rectangle then clip the rule
        //
        if (pco && pco->iDComplexity == DC_RECT)
        {
            if (pRect->left < pco->rclBounds.left)
                pRect->left = pco->rclBounds.left;
            if (pRect->top < pco->rclBounds.top)
                pRect->top = pco->rclBounds.top;
            if (pRect->right > pco->rclBounds.right)
                pRect->right = pco->rclBounds.right;
            if (pRect->bottom > pco->rclBounds.bottom)
                pRect->bottom = pco->rclBounds.bottom;
        }
#ifdef DBGNEWRULES                
		DbgPrint("New Rule %3d, L%d,R%d,T%d,B%d\n",pPDev->dwRulesCount,
			pRect->left,pRect->right,pRect->top,pRect->bottom);
#endif            
        if (pRect->left < pRect->right && pRect->top < pRect->bottom)
		{
            pPDev->dwRulesCount++;
		}
}

BOOL TestStrokeRectangle(
	PDEV *pPDev,
	PATHOBJ *ppo,
	CLIPOBJ *pco,
	LONG width
	)
/*++

Routine Description:

    This function determines whether a StrokeFillPath is actually defining 
	a rectangle that can be drawn with black rules instead.

Arguments:

    pPDev
	ppo		    path object that might be rectangle
	pco			clip object
    width       line width

--*/
{
    POINTFIX* pptfx;
    PATHDATA  PathData;
    DWORD     dwPoints = 0;
	POINTL 	  pPoints[5];

    PATHOBJ_vEnumStart(ppo);

	// if there is more than one subpath then its not a rectangle
	//
    if (PATHOBJ_bEnum(ppo, &PathData))
    {
#ifdef DBGNEWRULES                
        DbgPrint ("Unable to convert Rectangle3\n");
#endif
        return FALSE;
	}
    //
	// Begin new sub path
    //
    if ((PathData.count != 4 && (PathData.flags & PD_CLOSEFIGURE)) || 
        (PathData.count != 5 && !(PathData.flags & PD_CLOSEFIGURE)) ||
        !(PathData.flags & PD_BEGINSUBPATH) || 
        PathData.flags & PD_BEZIERS)
    {
#ifdef DBGNEWRULES                
        DbgPrint("Unable to convert Rectangle4: flags=%x,Count=%d\n",
            PathData.flags,PathData.count);
#endif            
        return FALSE;
    }	

    // Verify these are all vertical or horizontal lines only
    //
    pptfx   = PathData.pptfx;
    while (dwPoints <= 4)
    {
        if (dwPoints != 4 || PathData.count == 5)
        {		
            pPoints[dwPoints].x = FXTOL(pptfx->x);
            pPoints[dwPoints].y = FXTOL(pptfx->y);
            pptfx++;
        }
        else
        {
            pPoints[dwPoints].x = pPoints[0].x;
            pPoints[dwPoints].y = pPoints[0].y;
        }
        //
        // check for diagonal lines
        //
        if (dwPoints != 0)
        {
            if (pPoints[dwPoints].x != pPoints[dwPoints-1].x &&
            	pPoints[dwPoints].y != pPoints[dwPoints-1].y)
            {
#ifdef DBGNEWRULES                
                DbgPrint ("Unable to convert Rectangle5\n");
#endif                
                return FALSE;
            }
        }
        dwPoints++;
    }
    //
    // make sure width is at least 1 pixel
    //
    if (width <= 0)
        width = 1;
    //
    // convert rectangle edges to rules
    //
    for (dwPoints = 0;dwPoints < 4;dwPoints++)
    {
        PRECTL pRect= &pPDev->pbRulesArray[pPDev->dwRulesCount];
        pRect->left = pPoints[dwPoints].x;
        pRect->top = pPoints[dwPoints].y;
        pRect->right = pPoints[dwPoints+1].x;
        pRect->bottom = pPoints[dwPoints+1].y;
        if (pRect->left > pRect->right)
        {
            LONG temp = pRect->left;
            pRect->left = pRect->right;
            pRect->right = temp;
        }
        pRect->left -= width >> 1;
        pRect->right += width - (width >> 1);
        if (pRect->top > pRect->bottom)
        {
            LONG temp = pRect->top;
            pRect->top = pRect->bottom;
            pRect->bottom = temp;
        }
        pRect->top -= width >> 1;
        pRect->bottom += width - (width >> 1);
        AddRuleToList(pPDev,pRect,pco);

    }
    return TRUE;
}
#endif

BOOL
DrvCopyBits(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    POINTL     *pptlSrc
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Points to the Dstination surface
    psoSrc  - Points to the source surface
    pxlo    - XLATEOBJ provided by the engine
    pco     - Defines a clipping region on the Dstination surface
    pxlo    - Defines the translation of color indices
            between the source and target surfaces
    prclDst - Defines the area to be modified
    pptlSrc - Defines the upper-left corner of the source rectangle

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV * pPDev = (PDEV *)psoDst->dhpdev;

    VERBOSE(("Entering DrvCopyBits...\n"));


    //
    // Sometimes GDI calls DrvCopyBits with the destination surface
    // as STYPE_BITMAP and the source surface as STYPE_DEVICE.
    // This means GDI wants the driver to copy whats on the device surface to the 
    // Bitmap surface. For device managed surfaces, driver does not keep track of
    // what has already been drawn on the device. So either the driver can fail
    // this call, or assume that nothing was drawn on the device earlier and 
    // therefore whiten the surface.
    // In most cases, the driver fails the call, except when
    // 1. It has been told to whiten the surface 
    // 2. The destination surface is 24bpp (this condition was hit
    //    for 24bpp and thats how we can test it. We can make the solution more
    //    general for other color depths, but how do we test it...) 
    // The drawback of whitening the surface is that 
    // whatever is actually on the device surface 
    // is overwritten. To prevent this, driver sets the flag PF2_RENDER_TRANSPARENT
    // in pPDev->fMode2. This is an indication to download the bitmap in 
    // transparent mode, so that the white on the bitmap does not overwrite the 
    // destination.
    // To hit this case, print grdfil06.emf using guiman using HP5si
    // (or any model using inbox HPGL driver).
    // NOTE: GDI is planning to change the behavior for Windows XP, but if you want to 
    // see this happening, run this driver on Windows2000 machine.
    //
    if ( pPDev == NULL && 
         psoSrc && psoSrc->iType == STYPE_DEVICE  &&
         psoDst && psoDst->iType == STYPE_BITMAP ) 
        
    {
        PDEV * pPDevSrc = (PDEV *)psoSrc->dhpdev;
        if (  pPDevSrc                                &&
             (pPDevSrc->fMode2 & PF2_WHITEN_SURFACE) &&
             (psoSrc->iBitmapFormat == BMF_24BPP)  &&
              psoDst->pvBits                          && 
             (psoDst->cjBits > 0)
           )
        {
            //
            // Change the bits in the destination surface to white
            // and return TRUE.
            //
            memset(psoDst->pvBits, 0xff, psoDst->cjBits);
            pPDevSrc->fMode2     |= PF2_SURFACE_WHITENED;
            return TRUE;
        }
        return FALSE;
    }


    //
    // use driver managed surface
    //
    if (pPDev && pPDev->pso)
        psoDst = pPDev->pso;

    
    //
    // Unidrv does not allow OEM's to hook out DrvEnableSurface and it creates
    // only the bitmap surface itself.
    //
    if ( ((pPDev == 0) || (pPDev->ulID != PDEV_ID)) ||
        ((!DRIVER_DEVICEMANAGED (pPDev)) &&
         ((psoSrc->iType != STYPE_BITMAP) ||
          (psoDst->iType != STYPE_BITMAP))) )  // compatible bitmap case
    {
        return (EngCopyBits(psoDst,psoSrc,pco,pxlo,
                                prclDst,pptlSrc));
    }

    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMCopyBits,
                    PFN_OEMCopyBits,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMCopyBits,
                    VMCopyBits,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc));

    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);

        if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
        {
            if (pRasterProcs->RMCopyBits == NULL)
            {
                CheckBitmapSurface(psoDst,prclDst);
                return FALSE;
            }
            else
                return ( pRasterProcs->RMCopyBits(psoDst,
                                  psoSrc, pco, pxlo, prclDst, pptlSrc) );
        }
        else
        {
            ERR (("Device Managed Surface cannot call EngCopyBits\n"));
            return FALSE;
        }
    }
}



BOOL
DrvBitBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    POINTL     *pptlSrc,
    POINTL     *pptlMask,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrush,
    ROP4        rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Describes the target surface
    psoSrc  - Describes the source surface
    psoMask - Describes the mask for rop4
    pco     - Limits the area to be modified
    pxlo    - Specifies how color indices are translated
              between the source and target surfaces
    prclDst - Defines the area to be modified
    pptlSrc - Defines the upper left corner of the source rectangle
    pptlMask - Defines which pixel in the mask corresponds to
               the upper left corner of the source rectangle
    pbo     - Defines the pattern for bitblt
    pptlBrush - Defines the origin of the brush in the Dstination surface
    rop4    - ROP code that defines how the mask, pattern, source, and
              Dstination pixels are combined to write to the Dstination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    PDEV * pPDev = (PDEV *)psoDst->dhpdev;

    VERBOSE(("Entering DrvBitBlt...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMBitBlt,
                    PFN_OEMBitBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc,
                     pptlMask,
                     pbo,
                     pptlBrush,
                     rop4));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMBitBlt,
                    VMBitBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc,
                     pptlMask,
                     pbo,
                     pptlBrush,
                     rop4));

    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
        if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
        {
            if (pRasterProcs->RMBitBlt == NULL)
            {
                CheckBitmapSurface(psoDst,prclDst);
                return FALSE;
            }
            else
                return ( pRasterProcs->RMBitBlt(psoDst,
                                        psoSrc, psoMask, pco, pxlo, prclDst,
                                        pptlSrc,pptlMask, pbo, pptlBrush, rop4));
        }
    }
    return FALSE;
}



BOOL
DrvStretchBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    COLORADJUSTMENT *pca,
    POINTL     *pptlHTOrg,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    POINTL     *pptlMask,
    ULONG       iMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Defines the surface on which to draw
    psoSrc  - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco     - Limits the area to be modified on the Dstination
    pxlo    - Specifies how color dwIndexes are to be translated
              between the source and target surfaces
    pca     - Defines color adjustment values to be applied to the source bitmap
    pptlHTOrg - Specifies the origin of the halftone brush
    prclDst - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
            the upper left pixel in the source rectangle
    iMode   - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV * pPDev = (PDEV *)psoDst->dhpdev;

    VERBOSE(("Entering DrvStretchBlt...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStretchBlt,
                    PFN_OEMStretchBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStretchBlt,
                    VMStretchBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode));


    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);

        if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
        {
            if (pRasterProcs->RMStretchBlt == NULL)
            {
                CheckBitmapSurface(psoDst,prclDst);
                return FALSE;
            }
            else
                return ( pRasterProcs->RMStretchBlt(psoDst, psoSrc,
                             psoMask, pco, pxlo, pca,
                             pptlHTOrg, prclDst, prclSrc, pptlMask, iMode) );
        }
        else
        {
            //
            // ERR (("Device Managed Surface cannot call EngStretchBlt\n"));
            // We make an exception for StretchBlt because OEM driver may not
            // be able to handle complex clipping. In that case it may wants
            // gdi to simply the call by breaking the StretchBlt into several
            // CopyBits. So call EngStretchBlt and hope for the best.
            //
            return ( EngStretchBlt(psoDst,
                    psoSrc,
                    psoMask,
                    pco,
                    pxlo,
                    pca,
                    pptlHTOrg,
                    prclDst,
                    prclSrc,
                    pptlMask,
                    iMode) );
        }
    }
}


ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

/*++

Routine Description:

    This is the hooked brush creation function, it ask CreateHalftoneBrush()
    to do the actual work.

Arguments:

    dhpdev      - DHPDEV passed, it is our pDEV
    iMode       - Not used
    rgbColor    - Solid rgb color to be used
    pulDither   - buffer to put the halftone brush.

Return Value:

    returns halftone method, default is DCR_HALFTONE

--*/

{
    PDEV *pPDev = (PDEV *)dhpdev;

    VERBOSE(("Entering DrvDitherColor...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMDitherColor,
                    PFN_OEMDitherColor,
                    ULONG,
                    (dhpdev,
                     iMode,
                     rgbColor,
                     pulDither));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMDitherColor,
                    VMDitherColor,
                    ULONG,
                    (dhpdev,
                     iMode,
                     rgbColor,
                     pulDither));

    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
        if (pRasterProcs->RMDitherColor == NULL)
            return DCR_HALFTONE;
        else
           return ( pRasterProcs->RMDitherColor(pPDev,
                                            iMode,
                                            rgbColor,
                                            pulDither) );
    }
}

#ifndef WINNT_40

BOOL APIENTRY
DrvStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBltROP.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Specifies the target surface
    psoSrc - Specifies the source surface
    psoMask - Specifies the mask surface
    pco - Limits the area to be modified
    pxlo - Specifies how color indices are translated
        between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    prclHTOrg - Specifies the halftone origin
    prclDst - Area to be modified on the destination surface
    prclSrc - Rectangle area on the source surface
    prclMask - Rectangle area on the mask surface
    pptlMask - Defines which pixel in the mask corresponds to
        the upper left corner of the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels
    pbo - Defines the pattern for bitblt
    rop4 - ROP code that defines how the mask, pattern, source, and
        destination pixels are combined on the destination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEV *pPDev = (PDEV *)psoDst->dhpdev;
    PRMPROCS   pRasterProcs;


    VERBOSE(("Entering DrvStretchBltROP...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStretchBltROP,
                    PFN_OEMStretchBltROP,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode,
                     pbo,
                     rop4));


    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStretchBltROP,
                    VMStretchBltROP,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode,
                     pbo,
                     rop4));

    pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);

    if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
    {
        if (pRasterProcs->RMStretchBltROP == NULL)
        {
            CheckBitmapSurface(psoDst,prclDst);
            return FALSE;
        }
        else
            return ( pRasterProcs->RMStretchBltROP(psoDst, psoSrc,
                         psoMask, pco, pxlo, pca,
                         pptlHTOrg, prclDst, prclSrc, pptlMask, iMode,
                         pbo, rop4) );
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngStretchBltROP\n"));
        return FALSE;
    }
}

#endif

#ifndef WINNT_40

BOOL APIENTRY
DrvPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
/*++

Routine Description:

    Implementation of DDI entry point DrvPlgBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Defines the surface on which to draw
    psoSrc - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco - Limits the area to be modified on the Dstination
    pxlo - Specifies how color dwIndexes are to be translated
        between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    pptlBrushOrg - Specifies the origin of the halftone brush
    ppfxDest - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
        the upper left pixel in the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEV *pPDev;

    VERBOSE(("Entering DrvPlgBlt...\n"));
    ASSERT(psoDst != NULL);

    pPDev = (PDEV *)psoDst->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMPlgBlt,
                    PFN_OEMPlgBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlBrushOrg,
                     pptfixDest,
                     prclSrc,
                     pptlMask,
                     iMode));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMPlgBlt,
                    VMPlgBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlBrushOrg,
                     pptfixDest,
                     prclSrc,
                     pptlMask,
                     iMode));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        PRMPROCS   pRasterProcs;
        pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
        if (pRasterProcs->RMPlgBlt != NULL)
        {
            return ( pRasterProcs->RMPlgBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlBrushOrg,
                         pptfixDest, prclSrc, pptlMask, iMode));
        }
        else
        {
            //
            // Check whether to erase surface
            //
            CheckBitmapSurface(psoDst,NULL);

            //
            // Unidrv does not handle this call itself.
            //
            return EngPlgBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlBrushOrg,
                         pptfixDest, prclSrc, pptlMask, iMode);
        }
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngPlgBlt\n"));
        return FALSE;
    }
}
#endif

BOOL APIENTRY
DrvPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
/*++

Routine Description:

    Implementation of DDI entry point DrvPaint.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface on which to draw
    pco - Limits the area to be modified on the Dstination
    pbo - Points to a BRUSHOBJ which defined the pattern and colors to fill with
    pptlBrushOrg - Specifies the origin of the halftone brush
    mix - Defines the foreground and background raster operations to use for
          the brush

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEV *pPDev = (PDEV *)pso->dhpdev;
    PRMPROCS   pRasterProcs;

    VERBOSE(("Entering DrvPaint...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMPaint,
                    PFN_OEMPaint,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMPaint,
                    VMPaint,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {

                pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
                if (pRasterProcs->RMPaint != NULL)
                {
                        return ( pRasterProcs->RMPaint(pso, pco, pbo, pptlBrushOrg, mix));
                }
                else
                {
                        //
                        // Check whether to erase surface
                        //
                        CheckBitmapSurface(pso,&pco->rclBounds);
                        //
                        // Unidrv does not handle this call itself.
                        //
                        return EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
                }
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngPaint"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvRealizeBrush.
    Please refer to DDK documentation for more details.

Arguments:

    pbo - BRUSHOBJ to be realized
    psoTarget - Defines the surface for which the brush is to be realized
    psoPattern - Defines the pattern for the brush
    psoMask - Transparency mask for the brush
    pxlo - Defines the interpretration of colors in the pattern
    iHatch - Specifies whether psoPattern is one of the hatch brushes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV        *pPDev;
    PDEVBRUSH   pDB;


    VERBOSE(("Entering DrvRealizeBrush...\n"));
    ASSERT(psoTarget && pbo && pxlo);

    pPDev = (PDEV *) psoTarget->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoTarget = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMRealizeBrush,
                    PFN_OEMRealizeBrush,
                    BOOL,
                    (pbo,
                     psoTarget,
                     psoPattern,
                     psoMask,
                     pxlo,
                     iHatch));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMRealizeBrush,
                    VMRealizeBrush,
                    BOOL,
                    (pbo,
                     psoTarget,
                     psoPattern,
                     psoMask,
                     pxlo,
                     iHatch));

    //
    // BUG_BUG, if OEM hook out DrvRealizeBrush, how are we
    // handling dithering of solid color for pattern brush for text?
    //  Amanda says if OEM doesn't call this function or provide
    //  an equivalent when hooking out this function,  dithered text
    //  support will not work.   So maybe the OEM extensions guide
    //  should include such a warning in it.

    //
    // Handle realize brush for user defined pattern, dither solid color.
    //

    if ((iHatch >= HS_DDI_MAX)                                  &&
        (psoPattern)                                            &&
        (psoPattern->iType == STYPE_BITMAP)                     &&
        (psoTarget->iType == STYPE_BITMAP)                         &&
        (psoTarget->iBitmapFormat == psoPattern->iBitmapFormat)    &&
        (pDB = (PDEVBRUSH)BRUSHOBJ_pvAllocRbrush(pbo, sizeof(DEVBRUSH))))
    {

        WORD    wChecksum;
        LONG    lPatID;
        RECTW   rcw;

        rcw.l =
        rcw.t = 0;
        rcw.r = (WORD)psoPattern->sizlBitmap.cx;
        rcw.b = (WORD)psoPattern->sizlBitmap.cy;

        wChecksum = GetBMPChecksum(psoPattern, &rcw);

#ifndef WINNT_40
        VERBOSE (("\n\nRaddd:DrvRealizedBrush(%08lx) Checksum=%04lx, %ld x %ld [%ld]  ",
                BRUSHOBJ_ulGetBrushColor(pbo) & 0x00FFFFFF,
                wChecksum,  psoPattern->sizlBitmap.cx,
                psoPattern->sizlBitmap.cy, psoPattern->iBitmapFormat));
#endif
        if (lPatID = FindCachedHTPattern(pPDev, wChecksum))
        {
            //
            // Either need to download (<0) or already downloaded (>0)
            //

            if (lPatID < 0)
            {

                //
                // Need to download the ID now
                //

                lPatID = -lPatID;

                if (!Download1BPPHTPattern(pPDev, psoPattern, lPatID))
                {
                    return(FALSE);
                }
            }
            else if (lPatID == 0)   // Out of memory case
                return FALSE;

        }

        pDB->iColor   = lPatID;
        pbo->pvRbrush = (LPVOID)pDB;

        VERBOSE (("\nUnidrv:DrvRealizedBrush(PatID=%d)   ", pDB->iColor));

        return(TRUE);
    }

    return ( FALSE );


}


BOOL APIENTRY
DrvStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStrokePath.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Identifies the surface on which to draw
    ppo - Defines the path to be stroked
    pco - Defines the clipping path
    pbo - Specifies the brush to be used when drawing the path
    pptlBrushOrg - Defines the brush origin
    plineattrs - Defines the line attributes
    mix - Specifies how to combine the brush with the destination

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/

{
    PDEV *pPDev;

    VERBOSE(("Entering DrvStrokePath...\n"));
    ASSERT(pso);

    pPDev = (PDEV *)pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStrokePath,
                    PFN_OEMStrokePath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pbo,
                     pptlBrushOrg,
                     plineattrs,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStrokePath,
                    VMStrokePath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pbo,
                     pptlBrushOrg,
                     plineattrs,
                     mix));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
#ifndef DISABLE_NEWRULES
        //
        // check for black rectangle replacement
        //
        if (ppo->cCurves == 4 && ppo->fl == 0 &&
            pPDev->pbRulesArray && pPDev->dwRulesCount < (MAX_NUM_RULES-4) &&
            mix == (R2_COPYPEN | (R2_COPYPEN << 8)) && pbo &&
            (pco == NULL || pco->iDComplexity != DC_COMPLEX) &&
            ((pso->iBitmapFormat != BMF_24BPP &&
            pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) ||
             (pso->iBitmapFormat == BMF_24BPP &&
            pbo->iSolidColor == 0)))
        {
	        // Make sure outline doesn't use line style
	        //
	        if (!(plineattrs->fl & (LA_GEOMETRIC | LA_STYLED | LA_ALTERNATE)))
	        {
	    	    if (TestStrokeRectangle(pPDev,ppo,pco,plineattrs->elWidth.l))
		        {
		            return TRUE;
		        }
	        }
	    }
#endif
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&pco->rclBounds);

        //
        // Unidrv does not handle this call itself.
        //
        return EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs,mix);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngStrokePath"));
        return FALSE;
    }

}


BOOL APIENTRY
DrvFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvFillPath.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface on which to draw.
    ppo - Defines the path to be filled
    pco - Defines the clipping path
    pbo - Defines the pattern and colors to fill with
    pptlBrushOrg - Defines the brush origin
    mix - Defines the foreground and background ROPs to use for the brush
    flOptions - Whether to use zero-winding or odd-even rule

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/

{
    PDEV *pPDev;

    VERBOSE(("Entering DrvFillPath...\n"));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMFillPath,
                    PFN_OEMFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix,
                     flOptions));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMFillPath,
                    VMFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix,
                     flOptions));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&pco->rclBounds);

        //
        // Unidrv does not handle this call itself.
        //
        return EngFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngFillPath"));
        return FALSE;
    }


}


BOOL APIENTRY
DrvStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStrokeAndFillPath.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface on which to draw
    ppo - Describes the path to be filled
    pco - Defines the clipping path
    pxo - Specifies the world to device coordinate transformation
    pboStroke - Specifies the brush to use when stroking the path
    plineattrs - Specifies the line attributes
    pboFill - Specifies the brush to use when filling the path
    pptlBrushOrg - Specifies the brush origin for both brushes
    mixFill - Specifies the foreground and background ROPs to use
        for the fill brush

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvFillAndStrokePath...\n"));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStrokeAndFillPath,
                    PFN_OEMStrokeAndFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pboStroke,
                     plineattrs,
                     pboFill,
                     pptlBrushOrg,
                     mixFill,
                     flOptions));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStrokeAndFillPath,
                    VMStrokeAndFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pboStroke,
                     plineattrs,
                     pboFill,
                     pptlBrushOrg,
                     mixFill,
                     flOptions));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&pco->rclBounds);

        //
        // Unidrv does not handle this call itself.
        //
        return EngStrokeAndFillPath(pso, ppo, pco, pxo, pboStroke, plineattrs,
                                    pboFill, pptlBrushOrg, mixFill, flOptions);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngStrokeAndFillPath"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvLineTo.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface on which to draw
    pco - Defines the clipping path
    pbo - Defines the brush used to draw the line
    x1,y1 - Specifies the line's starting point
    x2,y2 - Specifies the line's ending point
    prclBounds - Defines a rectangle that bounds the unclipped line.
    mix - Specifies the foreground and background ROP

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/
{
    PDEV         *pPDev;
    RECTL        DstRect;

    VERBOSE(("Entering DrvLineTo...\n"));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMLineTo,
                    PFN_OEMLineTo,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     x1,
                     y1,
                     x2,
                     y2,
                     prclBounds,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMLineTo,
                    VMLineTo,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     x1,
                     y1,
                     x2,
                     y2,
                     prclBounds,
                     mix));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        DstRect.top = min(y1,y2);
        DstRect.bottom = max(y1,y2);
        DstRect.left = min(x1,x2);
        DstRect.right = max(x1,x2);
#ifndef DISABLE_NEWRULES
        //
        // check for black rectangle replacement
        //
        if (pPDev->pbRulesArray && (pPDev->dwRulesCount < MAX_NUM_RULES) &&
            (x1 == x2 || y1 == y2) &&
            mix == (R2_COPYPEN | (R2_COPYPEN << 8)) && pbo &&
            (pco == NULL || pco->iDComplexity != DC_COMPLEX) &&
            ((pso->iBitmapFormat != BMF_24BPP &&
            pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) ||
            (pso->iBitmapFormat == BMF_24BPP &&
            pbo->iSolidColor == 0)))
        {
            PRECTL pRect = &pPDev->pbRulesArray[pPDev->dwRulesCount];
            *pRect = DstRect;
            if (x1 == x2)
                pRect->right++;
            else if (y1 == y2)
                pRect->bottom++;
            AddRuleToList(pPDev,pRect,pco);
            return TRUE;
        }
#endif
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&DstRect);

        //
        // Unidrv does not handle this call itself.
        //
        return EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngLineTo"));
        return FALSE;
    }
}

#ifndef WINNT_40

BOOL APIENTRY
DrvAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvAlphaBlend.
    Please refer to DDK documentation for more details.

Arguments:

    psoDest  - Defines the surface on which to draw
    psoSrc  - Defines the source
    pco     - Limits the area to be modified on the Destination
    pxlo    - Specifies how color dwIndexes are to be translated
              between the source and target surfaces
    prclDest - Defines the area to be modified on the Destination surface
    prclSrc - Defines the area to be copied from the source surface
    BlendFunction - Specifies the blend function to be used

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvAlphaBlend...\n"));

    pPDev = (PDEV *) psoDest->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDest = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMAlphaBlend,
                    PFN_OEMAlphaBlend,
                    BOOL,
                    (psoDest,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDest,
                     prclSrc,
                     pBlendObj));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMAlphaBlend,
                    VMAlphaBlend,
                    BOOL,
                    (psoDest,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDest,
                     prclSrc,
                     pBlendObj));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(psoDest,prclDest);

        //
        // Unidrv does not handle this call itself.
        //
        return EngAlphaBlend(psoDest,
                             psoSrc,
                             pco,
                             pxlo,
                             prclDest,
                             prclSrc,
                             pBlendObj);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngAlphaBlend"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvGradientFill.
    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvGradientFill...\n"));

    pPDev = (PDEV *) psoDest->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDest = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMGradientFill,
                    PFN_OEMGradientFill,
                    BOOL,
                    (psoDest,
                     pco,
                     pxlo,
                     pVertex,
                     nVertex,
                     pMesh,
                     nMesh,
                     prclExtents,
                     pptlDitherOrg,
                     ulMode));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMGradientFill,
                    VMGradientFill,
                    BOOL,
                    (psoDest,
                     pco,
                     pxlo,
                     pVertex,
                     nVertex,
                     pMesh,
                     nMesh,
                     prclExtents,
                     pptlDitherOrg,
                     ulMode));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(psoDest,prclExtents);

        //
        // Unidrv does not handle this call itself.
        //
        return EngGradientFill(psoDest,
                               pco,
                               pxlo,
                               pVertex,
                               nVertex,
                               pMesh,
                               nMesh,
                               prclExtents,
                               pptlDitherOrg,
                               ulMode);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngGradientFill"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvTransparentBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Defines the surface on which to draw
    psoSrc  - Defines the source
    pco     - Limits the area to be modified on the Destination
    pxlo    - Specifies how color dwIndexes are to be translated
              between the source and target surfaces
    prclDst - Defines the area to be modified on the Destination surface
    prclSrc - Defines the area to be copied from the source surface
    iTransColor - Specifies the transparent color

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvTransparentBlt...\n"));

    pPDev = (PDEV *) psoDst->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMTransparentBlt,
                    PFN_OEMTransparentBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     prclSrc,
                     iTransColor,
                     ulReserved));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMTransparentBlt,
                    VMTransparentBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     prclSrc,
                     iTransColor,
                     ulReserved));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(psoDst,prclDst);

        //
        // Unidrv does not handle this call itself.
        //
        return EngTransparentBlt(psoDst,
                                 psoSrc,
                                 pco,
                                 pxlo,
                                 prclDst,
                                 prclSrc,
                                 iTransColor,
                                 ulReserved);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngTransparentBlt"));
        return FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\oemkm.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    oemkm.c

Abstract:

    Kernel mode support for OEM plugins

Environment:

    Windows NT Unidrv driver

Revision History:

    04/01/97 -zhanw-
        Adapted from Pscript source

--*/

#include "unidrv.h"

#ifdef WINNT_40

//
// The global link list of ref counts for currently loaded OEM render plugin DLLs
//

POEM_PLUGIN_REFCOUNT gpOEMPluginRefCount;

static const CHAR szDllInitialize[] = "DllInitialize";

#endif // WINNT_40

//
// Unidrv specific OEM entrypoints
//
// NOTE: Please keep this in sync with indices defined in printer5\inc\oemutil.h!!!
//

static CONST PSTR OEMUnidrvProcNames[MAX_UNIDRV_ONLY_HOOKS] = {
    "OEMCommandCallback",
    "OEMImageProcessing",
    "OEMFilterGraphics",
    "OEMCompression",
    "OEMHalftonePattern",
    "OEMMemoryUsage",
    "OEMDownloadFontHeader",
    "OEMDownloadCharGlyph",
    "OEMTTDownloadMethod",
    "OEMOutputCharStr",
    "OEMSendFontCmd",
    "OEMTTYGetInfo",
    "OEMTextOutAsBitmap",
    "OEMWritePrinter",
};


static CONST PSTR COMUnidrvProcNames[MAX_UNIDRV_ONLY_HOOKS] = {
    "CommandCallback",
    "ImageProcessing",
    "FilterGraphics",
    "Compression",
    "HalftonePattern",
    "MemoryUsage",
    "DownloadFontHeader",
    "DownloadCharGlyph",
    "TTDownloadMethod",
    "OutputCharStr",
    "SendFontCmd",
    "TTYGetInfo",
    "TextOutAsBitmap",
    "WritePrinter",

};

//
// OEM plugin helper function table
//

static const DRVPROCS OEMHelperFuncs = {
    (PFN_DrvWriteSpoolBuf)      WriteSpoolBuf,
    (PFN_DrvXMoveTo)            XMoveTo,
    (PFN_DrvYMoveTo)            YMoveTo,
    (PFN_DrvGetDriverSetting)   BGetDriverSettingForOEM,
    (PFN_DrvGetStandardVariable) BGetStandardVariable,
    (PFN_DrvUnidriverTextOut)   FMTextOut,
    (PFN_DrvWriteAbortBuf)      WriteAbortBuf,
};


INT
IMapDDIIndexToOEMIndex(
    ULONG ulDdiIndex
    )

/*++

Routine Description:

    Maps DDI entrypoint index to OEM entrypoint index

Arguments:

    ulDdiIndex - DDI entrypoint index

Return Value:

    OEM entrypoint index corresponding to the specified DDI entrypoint index
    -1 if the specified DDI entrypoint cannot be hooked out by OEM plugins

--*/

{
    static const struct {
        ULONG   ulDdiIndex;
        INT     iOemIndex;
    }
    OemToDdiMapping[] =
    {
        INDEX_DrvRealizeBrush,            EP_OEMRealizeBrush,
        INDEX_DrvDitherColor,             EP_OEMDitherColor,
        INDEX_DrvCopyBits,                EP_OEMCopyBits,
        INDEX_DrvBitBlt,                  EP_OEMBitBlt,
        INDEX_DrvStretchBlt,              EP_OEMStretchBlt,
#ifndef WINNT_40
        INDEX_DrvStretchBltROP,           EP_OEMStretchBltROP,
        INDEX_DrvPlgBlt,                  EP_OEMPlgBlt,
        INDEX_DrvTransparentBlt,          EP_OEMTransparentBlt,
        INDEX_DrvAlphaBlend,              EP_OEMAlphaBlend,
        INDEX_DrvGradientFill,            EP_OEMGradientFill,
#endif
        INDEX_DrvTextOut,                 EP_OEMTextOut,
        INDEX_DrvStrokePath,              EP_OEMStrokePath,
        INDEX_DrvFillPath,                EP_OEMFillPath,
        INDEX_DrvStrokeAndFillPath,       EP_OEMStrokeAndFillPath,
        INDEX_DrvPaint,                   EP_OEMPaint,
        INDEX_DrvLineTo,                  EP_OEMLineTo,
        INDEX_DrvStartPage,               EP_OEMStartPage,
        INDEX_DrvSendPage,                EP_OEMSendPage,
        INDEX_DrvEscape,                  EP_OEMEscape,
        INDEX_DrvStartDoc,                EP_OEMStartDoc,
        INDEX_DrvEndDoc,                  EP_OEMEndDoc,
        INDEX_DrvNextBand,                EP_OEMNextBand,
        INDEX_DrvStartBanding,            EP_OEMStartBanding,
        INDEX_DrvQueryFont,               EP_OEMQueryFont,
        INDEX_DrvQueryFontTree,           EP_OEMQueryFontTree,
        INDEX_DrvQueryFontData,           EP_OEMQueryFontData,
        INDEX_DrvQueryAdvanceWidths,      EP_OEMQueryAdvanceWidths,
        INDEX_DrvFontManagement,          EP_OEMFontManagement,
        INDEX_DrvGetGlyphMode,            EP_OEMGetGlyphMode,
    };

    INT iIndex;
    INT iLimit = sizeof(OemToDdiMapping) / (sizeof(INT) * 2);

    for (iIndex=0; iIndex < iLimit; iIndex++)
    {
        if (OemToDdiMapping[iIndex].ulDdiIndex == ulDdiIndex)
            return OemToDdiMapping[iIndex].iOemIndex;
    }

    return -1;
}



BOOL
BLoadAndInitOemPlugins(
    PDEV    *pPDev
    )

/*++

Routine Description:

    Get information about OEM plugins associated with the current device
    Load them into memory and call OEMEnableDriver for each of them

Arguments:

    pPDev - Points to our device data structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFN_OEMEnableDriver pfnOEMEnableDriver;
    DRVENABLEDATA       ded;
    DWORD               dwCount;
    INT                 iIndex;
    PDRVFN              pdrvfn;
    OEMPROC             oemproc;

    //
    // Load OEM plugins into memory
    //

    pPDev->devobj.pDrvProcs = (PDRVPROCS) &OEMHelperFuncs;

    if (! (pPDev->pOemPlugins = PGetOemPluginInfo(pPDev->devobj.hPrinter,
                                                  pPDev->pDriverInfo3->pDriverPath,
                                                  pPDev->pDriverInfo3)) ||
        ! BLoadOEMPluginModules(pPDev->pOemPlugins))
    {
        return FALSE;
    }

    //
    // Init pdriverobj to point to devobj for OEM to access private setting
    //

    pPDev->pOemPlugins->pdriverobj = &pPDev->devobj;

    //
    // If there is no OEM plugin, return success
    //

    if (pPDev->pOemPlugins->dwCount == 0)
        return TRUE;

    //
    // Call OEM plugin's OEMEnableDriver entrypoint
    // and find out if any of them has hook out DDI entrypoints
    //

    pPDev->pOemHookInfo = MemAllocZ(sizeof(OEM_HOOK_INFO) * MAX_OEMHOOKS);

    if (pPDev->pOemHookInfo == NULL)
        return FALSE;

    START_OEMENTRYPOINT_LOOP(pPDev)
    // this macro defined in oemkm.h in conjunction with its partner  END_OEMENTRYPOINT_LOOP,
    // acts like a for() loop initializing and incrementing pOemEntry each pass through the
    //  loop.

        ZeroMemory(&ded, sizeof(ded));

        //
        // COM Plug-in case
        //
        if (pOemEntry->pIntfOem != NULL)
        {
            HRESULT hr;

            hr = HComOEMEnableDriver(pOemEntry,
                                     PRINTER_OEMINTF_VERSION,
                                     sizeof(ded),
                                     &ded);

            if (hr == E_NOTIMPL)
                goto UNIDRV_SPECIFIC;

            if (FAILED(hr))
            {
                ERR(("OEMEnableDriver failed for '%ws': %d\n",
                     pOemEntry->ptstrDriverFile,
                     GetLastError()));

                break;
            }
        }
        //
        // Non-COM Plug-in case
        //
        else
        {
            if (!(pfnOEMEnableDriver = GET_OEM_ENTRYPOINT(pOemEntry, OEMEnableDriver)))
                goto UNIDRV_SPECIFIC;

            //
            // Call OEM plugin's entrypoint
            //

            if (! pfnOEMEnableDriver(PRINTER_OEMINTF_VERSION, sizeof(ded), &ded))
            {
                ERR(("OEMEnableDriver failed for '%ws': %d\n",
                    pOemEntry->ptstrDriverFile,
                    GetLastError()));

                break;
            }
            //
            // Verify the driver version    (do this only if not COM)
            //

            if (ded.iDriverVersion != PRINTER_OEMINTF_VERSION)
            {
                ERR(("Invalid driver version for '%ws': 0x%x\n",
                    pOemEntry->ptstrDriverFile,
                    ded.iDriverVersion));

                break;
            }
        }

        pOemEntry->dwFlags |= OEMENABLEDRIVER_CALLED;


        //
        // Check if OEM plugin has hooked out any DDI entrypoints
        //

        for (dwCount=ded.c, pdrvfn=ded.pdrvfn; dwCount-- > 0; pdrvfn++)
        {
            if ((iIndex = IMapDDIIndexToOEMIndex(pdrvfn->iFunc)) >= 0)
            {
                if (pPDev->pOemHookInfo[iIndex].pfnHook != NULL)
                {
                    WARNING(("Multiple hooks for entrypoint: %d\n"
                            "    %ws\n"
                            "    %ws\n",
                            iIndex,
                            pOemEntry->ptstrDriverFile,
                            pPDev->pOemHookInfo[iIndex].pOemEntry->ptstrDriverFile));
                }
                else
                {
                    pPDev->pOemHookInfo[iIndex].pfnHook = (OEMPROC) pdrvfn->pfn;
                    pPDev->pOemHookInfo[iIndex].pOemEntry = pOemEntry;
                }
            }
        }

        //
        // check if OEM plugin has any Unidrv-specific callbacks exported
        //

UNIDRV_SPECIFIC:
    for (dwCount = 0; dwCount < MAX_UNIDRV_ONLY_HOOKS; dwCount++)
    {
        oemproc = NULL;

        if(pOemEntry->pIntfOem)   //  is this a COM component, do special processing
        {
            if(S_OK == HComGetImplementedMethod(pOemEntry, COMUnidrvProcNames[dwCount]) )
                oemproc  = (OEMPROC)pOemEntry;
                        //  note oemproc/pfnHook only used as a BOOLEAN in COM path code.
                        //  do not use pfnHook to call a COM function!  we will use
                        //   ganeshp's wrapper functions (declared in unidrv2\inc\oemkm.h)  to do this.
        }
        else if (pOemEntry->hInstance != NULL)
                oemproc = (OEMPROC) GetProcAddress(pOemEntry->hInstance,
                                        OEMUnidrvProcNames[dwCount])  ;

        if(oemproc)
        {
            //
            // check if another OEM has already hooked out this function.
            // If so, ignore this one.
            //
            iIndex = dwCount + EP_UNIDRV_ONLY_FIRST;
            if (pPDev->pOemHookInfo[iIndex].pfnHook != NULL)
            {
                WARNING(("Multiple hooks for entrypoint: %d\n"
                         "    %ws\n"
                         "    %ws\n",
                         iIndex,
                         pOemEntry->ptstrDriverFile,
                         pPDev->pOemHookInfo[iIndex].pOemEntry->ptstrDriverFile));
            }
            else
            {
                DWORD   dwSize;
                HRESULT hr;

                pPDev->pOemHookInfo[iIndex].pfnHook = oemproc;
                pPDev->pOemHookInfo[iIndex].pOemEntry = pOemEntry;

                //
                // Set WritePrinter flag (OEMWRITEPRINTER_HOOKED).
                // Plug-in DLL needs to return S_OK with pBuff = NULL, size = 0,
                // and pdevobj = NULL.
                //
                if (iIndex == EP_OEMWritePrinter)
                {
                    hr = HComWritePrinter(pOemEntry,
                                          NULL,
                                          NULL,
                                          0,
                                          &dwSize);

                    if (hr == S_OK)
                    {
                        //
                        // Set WritePrinter hook flag in plug-in info.
                        //
                        pOemEntry->dwFlags |= OEMWRITEPRINTER_HOOKED;

                        //
                        // Set WritePrinter hook flag in UNIDRV PDEV.
                        //
                        pPDev->fMode2 |= PF2_WRITE_PRINTER_HOOKED;
                    }
                }
            }
        }
    }

    END_OEMENTRYPOINT_LOOP

    //
    // cache callback function ptrs
    //
    pPDev->pfnOemCmdCallback =
        (PFN_OEMCommandCallback)pPDev->pOemHookInfo[EP_OEMCommandCallback].pfnHook;

    return TRUE;
}


VOID
VUnloadOemPlugins(
    PDEV    *pPDev
    )

/*++

Routine Description:

    Unload OEM plugins and free all relevant resources

Arguments:

    pPDev - Points to our device data structure

Return Value:

    NONE

--*/

{
    PFN_OEMDisableDriver pfnOEMDisableDriver;
    PFN_OEMDisablePDEV   pfnOEMDisablePDEV;

    if (pPDev->pOemPlugins == NULL)
        return;

    //
    // Call OEMDisablePDEV for all OEM plugins, if necessary
    //

    START_OEMENTRYPOINT_LOOP(pPDev)

        if (pOemEntry->dwFlags & OEMENABLEPDEV_CALLED)
        {
            if (pOemEntry->pIntfOem != NULL)
            {
                (VOID)HComOEMDisablePDEV(pOemEntry, (PDEVOBJ)pPDev);
            }
            else
            {
                if (pfnOEMDisablePDEV = GET_OEM_ENTRYPOINT(pOemEntry, OEMDisablePDEV))
                {
                    pfnOEMDisablePDEV((PDEVOBJ) pPDev);
                }
            }
        }

    END_OEMENTRYPOINT_LOOP

    //
    // Call OEMDisableDriver for all OEM plugins, if necessary
    //

    START_OEMENTRYPOINT_LOOP(pPDev)

        if (pOemEntry->dwFlags & OEMENABLEDRIVER_CALLED)
        {
            if (pOemEntry->pIntfOem != NULL)
            {
                (VOID)HComOEMDisableDriver(pOemEntry);
            }
            else
            {
                if ((pfnOEMDisableDriver = GET_OEM_ENTRYPOINT(pOemEntry, OEMDisableDriver)))
                {
                    pfnOEMDisableDriver();
                }
            }
        }

    END_OEMENTRYPOINT_LOOP

    MemFree(pPDev->pOemHookInfo);
    pPDev->pOemHookInfo = NULL;

    VFreeOemPluginInfo(pPDev->pOemPlugins);
    pPDev->pOemPlugins = NULL;
}



BOOL
BGetDriverSettingForOEM(
    PDEV    *pPDev,
    PCSTR   pFeatureKeyword,
    PVOID   pOutput,
    DWORD   cbSize,
    PDWORD  pcbNeeded,
    PDWORD  pdwOptionsReturned
    )

/*++

Routine Description:

    Provide OEM plugins access to driver private settings

Arguments:

    pDev - Points to our device data structure
    pFeatureKeyword - Specifies the keyword the caller is interested in
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Returns the expected size of output buffer
    pdwOptionsReturned - Returns the number of options selected

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ULONG_PTR    dwIndex;
    BOOL    bResult;

    ASSERT_VALID_PDEV(pPDev);

    //
    // This is not very portable: If the pointer value for pFeatureKeyword
    // is less than 0x10000, we assume that the pointer value actually
    // specifies a predefined index.
    //

    //  ASSERT(sizeof(pFeatureKeyword) == sizeof(DWORD));   changed for sundown

    dwIndex = (ULONG_PTR) pFeatureKeyword;

    if (dwIndex >= OEMGDS_MIN_DOCSTICKY && dwIndex < OEMGDS_MIN_PRINTERSTICKY)
    {
        bResult = BGetDevmodeSettingForOEM(
                        pPDev->pdm,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else if (dwIndex >= OEMGDS_MIN_PRINTERSTICKY && dwIndex < OEMGDS_MAX)
    {
        bResult = BGetPrinterDataSettingForOEM(
                        &pPDev->PrinterData,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else
    {
        bResult = BGetGenericOptionSettingForOEM(
                        pPDev->pUIInfo,
                        pPDev->pOptionsArray,
                        pFeatureKeyword,
                        pOutput,
                        cbSize,
                        pcbNeeded,
                        pdwOptionsReturned);
    }

    return bResult;
}


BOOL
BGetStandardVariable(
    PDEV    *pPDev,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Provide OEM plugins access to driver private settings

Arguments:

    pDev - Points to our device data structure
    dwIndex - an index into the arStdPtr array defined in pdev.h and gpd.h
    pBuffer - the data is returned in this buffer
    cbSize - size of the pBuffer
    pcbNeeded - number of bytes actually written into pBuffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    bResult = FALSE;
    DWORD   dwData;

    if (dwIndex >= SVI_MAX)  // how could a DWORD be < 0?
    {
        ERR(("Index must be >= 0 or < SVI_MAX \n"));
        return( FALSE);
    }
    else
    {
        if(!pcbNeeded)
        {
            ERR(("pcbNeeded must not be NULL \n"));
            return( FALSE);
        }
        *pcbNeeded = sizeof(dwData);
        if(!pBuffer)
            return(TRUE);
        if(*pcbNeeded > cbSize)
            return(FALSE);

        dwData = *(pPDev->arStdPtrs[dwIndex]);
        memcpy( pBuffer, &dwData, *pcbNeeded );
        bResult = TRUE;
    }

    return bResult;
}





BOOL
BGetGPDData(
    PDEV    *pPDev,
    DWORD       dwType,     // Type of the data
    PVOID         pInputData,   // reserved. Should be set to 0
    PVOID          pBuffer,     // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    )

/*++

Routine Description:

    Provide OEM plugins access to GPD data.

Arguments:

    pDev - Points to our device data structure
    dwType,     // Type of the data
        at this time
        #define         GPD_OEMCUSTOMDATA       1
            pInputData will be ignored.

        In NT6, we will
        #define         GPD_OEMDATA 2
        at which time the caller will supply pInputData
        which points to a data specifier , catagory or label.
        (Specifics to be determined when we get there.)


    pInputData   -  reserved. Should be set to 0
    pBuffer - the data is returned in this buffer
    cbSize - size of the pBuffer
    pcbNeeded - number of bytes actually written into pBuffer

Return Value:

    TRUE if successful, FALSE if there is an error or dwType not
    supported

--*/

{
    BOOL    bResult = FALSE;
    DWORD   dwData;

    if(!pcbNeeded)
    {
        ERR(("pcbNeeded must not be NULL \n"));
        return( FALSE);
    }
    switch(dwType)
    {
        case    GPD_OEMCUSTOMDATA:
            *pcbNeeded = pPDev->pGlobals->dwOEMCustomData ;

            if( !pBuffer)
            {
               return TRUE;  //  all goes well.
            }

            if(*pcbNeeded > cbSize)
                return FALSE ;  // caller supplied buffer too small.

            CopyMemory(pBuffer,
                       pPDev->pGlobals->pOEMCustomData,
                       *pcbNeeded);


            return TRUE;  //  all goes well.

            break;
        default:
            break;
    }

    return  bResult  ;
}


#ifdef WINNT_40


PVOID
DrvMemAllocZ(
    ULONG   ulSize
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    return(MemAllocZ(ulSize));
}



VOID
DrvMemFree(
    PVOID   pMem
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   MemFree(pMem);
}


LONG
DrvInterlockedIncrement(
    PLONG  pRef
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{


    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);

}


LONG
DrvInterlockedDecrement(
    PLONG  pRef
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();

    return (*pRef);

}


BOOL
BHandleOEMInitialize(
    POEM_PLUGIN_ENTRY   pOemEntry,
    ULONG               ulReason
    )

/*++

Routine Description:

    Manage reference counting for OEM render plugin DLLs to determine
    when plugin's DLLInitliaze() should be called.

    This function is supported only for NT4 kernel mode render plugin
    DLLs because only in that situation plugin needs to use kernel
    semaphore to implement COM's AddRef and Release.
    
    If the plugin DLL is loaded for the first time, call its
    DLLInitialize(DLL_PROCESS_ATTACH) so it can initialize its
    semaphore.
    
    If the plugin DLL is unloaded by its last client, call its
    DLLInitialize(DLL_PROCESS_DETACH) so it can delete its
    semaphore.

Arguments:

    pOemEntry - Points to information about the OEM plugin
    ulReason - either DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH

Return Value:

    TRUE is succeeded, FALSE otherwise.

--*/

{
    LPFNDLLINITIALIZE pfnDllInitialize;
    BOOL              bCallDllInitialize;
    BOOL              bRetVal = TRUE;

    if (pOemEntry->hInstance &&
        (pfnDllInitialize = (LPFNDLLINITIALIZE)GetProcAddress(
                                        (HMODULE) pOemEntry->hInstance,
                                        (CHAR *)  szDllInitialize)))
    {
        switch (ulReason) {

            case DLL_PROCESS_ATTACH:

                ENTER_CRITICAL_SECTION();

                //
                // Managing the global ref count link list must be done
                // inside critical section.
                //

                bCallDllInitialize = BOEMPluginFirstLoad(pOemEntry->ptstrDriverFile,
                                                         &gpOEMPluginRefCount);

                LEAVE_CRITICAL_SECTION();

                if (bCallDllInitialize)
                {
                    //
                    // The render plugin DLL is loaded for the first time.
                    //

                    bRetVal = pfnDllInitialize(ulReason);
                }

                break;

            case DLL_PROCESS_DETACH:

                ENTER_CRITICAL_SECTION();

                //
                // Managing the global ref count link list must be done
                // inside critical section.
                //

                bCallDllInitialize = BOEMPluginLastUnload(pOemEntry->ptstrDriverFile,
                                                          &gpOEMPluginRefCount);

                LEAVE_CRITICAL_SECTION();
              
                if (bCallDllInitialize)
                {
                    //
                    // The render plugin DLL is unloaded by its last client.
                    //

                    bRetVal = pfnDllInitialize(ulReason);
                }

                break;

            default:

                ERR(("BHandleOEMInitialize is called with an unknown ulReason.\n"));
                break;
        }
    }

    return bRetVal;
}

#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\init.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Unidrv intialization related function header file

Environment:

    Windows NT Unidrv driver

Revision History:

    10/21/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _INIT_H_
#define _INIT_H_

#define MICRON_TO_PIXEL(micron, dpi) MulDiv(micron, dpi, 25400)
#define MICRON_TO_MASTER(size_in_micron, MU) MulDiv(size_in_micron, MU, 25400)
#define MASTER_TO_MICRON(size_in_master, MU) MulDiv(size_in_master, 25400, MU)

BOOL
BInitPDEV (
    PDEV        *pPDev,
    RECTL       *prcFormImageArea
    );


BOOL
BInitGdiInfo(
    PDEV    *pPDev,
    ULONG   *pGdiInfoBuffer,
    ULONG   ulBufferSize
    );

BOOL
BInitDevInfo(
    PDEV        *pPDev,
    DEVINFO     *pDevInfoBuffer,
    ULONG       ulBufferSize
    );

BOOL
BMergeAndValidateDevmode(
    PDEV        *pPDev,
    PDEVMODE    pdmInput,
    PRECTL      prcFormImageArea
    );

BOOL
BInitPalDevInfo(
    PDEV *pPDev,
    DEVINFO *pdevinfo,
    GDIINFO *pGDIInfo
    );

VOID
VLoadPal(
    PDEV   *pPDev
    );

VOID VInitPal8BPPMaskMode(
    PDEV   *pPDev,
    GDIINFO *pGDIInfo
    );

BOOL
BReloadBinaryData(
    PDEV   *pPDev
    );

VOID
VUnloadFreeBinaryData(
    PDEV   *pPDev
    );

#endif  // !_INIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\intfuni.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    intfuni.cpp

Abstract:

    Interface implementation of Windows NT unidriver OEM rendering plugins

Environment:

    Windows NT Unidriver.

Revision History:

    01/18/98 -ganeshp-
        Initial framework.

--*/

#define INITGUID
#include    "unidrv.h"

#ifdef WINNT_40


#include "cppfunc.h"
#undef InterlockedIncrement
#undef InterlockedDecrement

#define InterlockedIncrement(x) DrvInterlockedIncrement(x)
#define InterlockedDecrement(x) DrvInterlockedDecrement(x)

int __cdecl _purecall (void)
{
    return FALSE;
}
#endif // WINNT_40


#pragma     hdrstop("unidrv.h")
#include    "prcomoem.h"

//
// List all of the supported OEM plugin interface IIDs from the
// latest to the oldest, that's the order our driver will QI OEM
// plugin for its supported interface.
//
// DON"T remove the last NULL terminator.
//

static const GUID *PrintOemUni_IIDs[] = {
    &IID_IPrintOemUni2,
    &IID_IPrintOemUni,
    NULL
};

//
// Component
//

class CPrintOemDriver : public IPrintOemDriverUni
{
    //
    // IUnknown implementation
    //

    STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Interface IPrintOemDriverUni implementation
    //

    STDMETHODIMP DrvGetDriverSetting(PVOID   pdriverobj,
                                     PCSTR   Feature,
                                     PVOID   pOutput,
                                     DWORD   cbSize,
                                     PDWORD  pcbNeeded,
                                     PDWORD  pdwOptionsReturned);

    STDMETHODIMP DrvWriteSpoolBuf(PDEVOBJ     pdevobj,
                                  PVOID       pBuffer,
                                  DWORD       cbSize,
                                  OUT DWORD   *pdwResult);

    //
    // Cursor movement helper functions.
    //

    STDMETHODIMP DrvXMoveTo(PDEVOBJ    pdevobj,
                            INT        x,
                            DWORD      dwFlags,
                            OUT INT    *piResult);

    STDMETHODIMP DrvYMoveTo(PDEVOBJ    pdevobj,
                            INT        y,
                            DWORD      dwFlags,
                            OUT INT    *piResult);

    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHODIMP DrvGetStandardVariable(PDEVOBJ     pdevobj,
                                        DWORD       dwIndex,
                                        PVOID       pBuffer,
                                        DWORD       cbSize,
                                        PDWORD      pcbNeeded);

    //
    // Unidrv specific.  To Provide OEM plugins access to GPD data.
    //

    STDMETHODIMP DrvGetGPDData(PDEVOBJ     pdevobj,
    DWORD       dwType,     // Type of the data
    PVOID       pInputData, // reserved. Should be set to 0
    PVOID       pBuffer,    // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    );

    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHODIMP DrvUniTextOut(SURFOBJ    *pso,
                               STROBJ     *pstro,
                               FONTOBJ    *pfo,
                               CLIPOBJ    *pco,
                               RECTL      *prclExtra,
                               RECTL      *prclOpaque,
                               BRUSHOBJ   *pboFore,
                               BRUSHOBJ   *pboOpaque,
                               POINTL     *pptlBrushOrg,
                               MIX         mix);

    STDMETHODIMP DrvWriteAbortBuf(PDEVOBJ     pdevobj,
                                  PVOID       pBuffer,
                                  DWORD       cbSize,
                                  DWORD       dwWait);

public:

    //
    // Constructor
    //

    CPrintOemDriver() : m_cRef(0) {}

private:

    long m_cRef;

};


STDMETHODIMP CPrintOemDriver::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPrintOemDriverUni)
    {
        *ppv = static_cast<IPrintOemDriverUni *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPrintOemDriver::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPrintOemDriver::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CPrintOemDriver::DrvGetDriverSetting(PVOID   pdriverobj,
                                                  PCSTR   Feature,
                                                  PVOID   pOutput,
                                                  DWORD   cbSize,
                                                  PDWORD  pcbNeeded,
                                                  PDWORD  pdwOptionsReturned)
{
    if (BGetDriverSettingForOEM((PDEV *)pdriverobj,
                                Feature,
                                pOutput,
                                cbSize,
                                pcbNeeded,
                                pdwOptionsReturned))
        return S_OK;

    return E_FAIL;
}

STDMETHODIMP CPrintOemDriver::DrvWriteSpoolBuf(PDEVOBJ     pdevobj,
                                               PVOID       pBuffer,
                                               DWORD       cbSize,
                                               OUT DWORD   *pdwResult)
{
    DWORD dwI;
    POEM_PLUGIN_ENTRY pOemEntry;

    //
    // OEM plug-ins may not call back to DrvWriteSpoolBuf during the
    // WritePrinter hook.
    //
    if (((PDEV*)pdevobj)->fMode2 & PF2_CALLING_OEM_WRITE_PRINTER)
        return E_FAIL;

    if (*pdwResult = WriteSpoolBuf((PDEV *)pdevobj, (PBYTE)pBuffer, cbSize))
    {
        return S_OK;
    }

    *pdwResult = 0;

    return E_FAIL;
}


STDMETHODIMP CPrintOemDriver::DrvWriteAbortBuf(PDEVOBJ     pdevobj,
                                               PVOID       pBuffer,
                                               DWORD       cbSize,
                                               DWORD       dwWait)
{
    DWORD dwI;
    POEM_PLUGIN_ENTRY pOemEntry;

    //
    // OEM Plug-ins may not call back to DrvWriteAbortBuf during the
    // WritePrinter hook.
    //
    if (((PDEV*)pdevobj)->fMode2 & PF2_CALLING_OEM_WRITE_PRINTER)
        return E_FAIL;

    WriteAbortBuf((PDEV *)pdevobj, (PBYTE)pBuffer, cbSize, dwWait) ;
    return S_OK;    // no failure condition
}

//
// Cursor movement helper functions.
//
STDMETHODIMP CPrintOemDriver::DrvXMoveTo(PDEVOBJ     pdevobj,
                                         INT         x,
                                         DWORD       dwFlags,
                                         OUT INT     *piResult)
{
    *piResult = XMoveTo((PDEV *)pdevobj, x, dwFlags);

    return S_OK;

}

STDMETHODIMP CPrintOemDriver::DrvYMoveTo(PDEVOBJ     pdevobj,
                                         INT         y,
                                         DWORD       dwFlags,
                                         OUT INT     *piResult)
{
    *piResult = YMoveTo((PDEV *)pdevobj, y, dwFlags);

    return S_OK;

}

//
// Unidrv specific. To get the standard variable value.
//

STDMETHODIMP CPrintOemDriver::DrvGetStandardVariable(PDEVOBJ     pdevobj,
                                                     DWORD       dwIndex,
                                                     PVOID       pBuffer,
                                                     DWORD       cbSize,
                                                     PDWORD      pcbNeeded)
{
    if (BGetStandardVariable((PDEV *)pdevobj, dwIndex, pBuffer,
                             cbSize, pcbNeeded))
        return S_OK;

    return E_FAIL;
}

//
// Unidrv specific.  To Provide OEM plugins access to GPD data.
//

STDMETHODIMP CPrintOemDriver::DrvGetGPDData(PDEVOBJ     pdevobj,
    DWORD       dwType,     // Type of the data
    PVOID       pInputData, // reserved. Should be set to 0
    PVOID       pBuffer,    // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    )

{
    if (BGetGPDData((PDEV *)pdevobj,     dwType,
                    pInputData,    pBuffer,    cbSize,  pcbNeeded  ))
        return S_OK;

    return E_FAIL;
}

//
// Unidrv specific. To do the TextOut.
//

STDMETHODIMP CPrintOemDriver::DrvUniTextOut(SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlBrushOrg,
                                            MIX         mix)
{

    if (FMTextOut(pso, pstro, pfo,pco, prclExtra, prclOpaque,
                  pboFore, pboOpaque, pptlBrushOrg, mix))
    {
        return S_OK;

    }

    return E_FAIL;
}

//
// Creation function
//

extern "C" IUnknown* DriverCreateInstance()
{
    IUnknown* pI = static_cast<IPrintOemDriverUni *>(new CPrintOemDriver);

    if (pI != NULL)
        pI->AddRef();

    return pI;
}

extern "C"   HRESULT  HDriver_CoCreateInstance(
    IN REFCLSID     rclsid,
    IN LPUNKNOWN    pUnknownOuter,
    IN DWORD        dwClsContext,
    IN REFIID       riid,
    IN LPVOID       *ppv,
    IN HANDLE       hInstance
    );

//
// Get OEM plugin interface and publish driver helper interface
//

extern "C" BOOL BGetOemInterface(POEM_PLUGIN_ENTRY   pOemEntry)
{
    IUnknown  *pIDriverHelper = NULL;
    HRESULT   hr;

    //
    // QI to retrieve the latest interface OEM plugin supports
    //

    if (!BQILatestOemInterface(pOemEntry->hInstance,
                               CLSID_OEMRENDER,
                               PrintOemUni_IIDs,
                               &(pOemEntry->pIntfOem),
                               &(pOemEntry->iidIntfOem)))
    {
        ERR(("BQILatestOemInterface failed\n"));
        return FALSE;
    }

    //
    // If QI succeeded, pOemEntry->pIntfOem will have the OEM plugin
    // interface pointer with ref count 1.
    //

    //
    // Publish driver's helper function interface
    //

    if ((pIDriverHelper = DriverCreateInstance()) == NULL)
    {
        ERR(("DriverCreateInstance failed\n"));
        goto fail_cleanup;
    }

    //
    // As long as we define new OEM plugin interface by inheriting old ones,
    // we can always cast pIntfOem into pointer of the oldest plugin interface
    // (the base class) and call PublishDriverInterface method.
    //
    // Otherwise, this code needs to be modified when new interface is added.
    //

    hr = ((IPrintOemUni *)(pOemEntry->pIntfOem))->PublishDriverInterface(pIDriverHelper);

    //
    // OEM plugin should do QI in their PublishDriverInterface, so we need to release
    // our ref count of pIDriverHelper.
    //

    pIDriverHelper->Release();

    if (FAILED(hr))
    {
        ERR(("PublishDriverInterface failed\n"));
        goto fail_cleanup;
    }

    return TRUE;

    fail_cleanup:

    //
    // If failed, we need to release the ref count we hold on pOemEntry->pIntfOem,
    // and set pIntfOem to NULL to indicate no COM interface is available.
    //

    ((IUnknown *)(pOemEntry->pIntfOem))->Release();
    pOemEntry->pIntfOem = NULL;

    return FALSE;
}

//
// CALL_INTRFACE macros
//
#define CALL_INTRFACE(MethodName, pOemEntry, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUni)) \
    { \
        return ((IPrintOemUni *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    else if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUni2)) \
    { \
        return ((IPrintOemUni2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

#define CALL_INTRFACE2(MethodName, pOemEntry, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUni2)) \
    { \
        return ((IPrintOemUni2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

//  add additional  else if (IsEqualGUID(&pOemEntry->iidIntfOem, &IID_IPrintOemUni2))\
//   sections as needed as more interfaces are defined to   CALL_INTRFACE macro.

extern "C" HRESULT HComOEMGetInfo(POEM_PLUGIN_ENTRY   pOemEntry,
                                  DWORD  dwMode,
                                  PVOID  pBuffer,
                                  DWORD  cbSize,
                                  PDWORD pcbNeeded)
{
    CALL_INTRFACE(GetInfo, pOemEntry, (dwMode, pBuffer, cbSize, pcbNeeded));
}

extern "C" HRESULT HComOEMDevMode(POEM_PLUGIN_ENTRY   pOemEntry,
                                  DWORD               dwMode,
                                  POEMDMPARAM         pOemDMParam)
{
    CALL_INTRFACE(DevMode, pOemEntry, (dwMode, pOemDMParam));
}

extern "C" HRESULT HComOEMEnableDriver(POEM_PLUGIN_ENTRY   pOemEntry,
                                       DWORD               DriverVersion,
                                       DWORD               cbSize,
                                       PDRVENABLEDATA      pded)
{
    CALL_INTRFACE(EnableDriver, pOemEntry, (DriverVersion, cbSize, pded));
}

extern "C" HRESULT HComOEMDisableDriver(POEM_PLUGIN_ENTRY   pOemEntry)
{
    CALL_INTRFACE(DisableDriver, pOemEntry, ());
}

extern "C" HRESULT HComOEMEnablePDEV(POEM_PLUGIN_ENTRY pOemEntry,
                                     PDEVOBJ           pdevobj,
                                     PWSTR             pPrinterName,
                                     ULONG             cPatterns,
                                     HSURF            *phsurfPatterns,
                                     ULONG             cjGdiInfo,
                                     GDIINFO          *pGdiInfo,
                                     ULONG             cjDevInfo,
                                     DEVINFO          *pDevInfo,
                                     DRVENABLEDATA    *pded,
                                     PDEVOEM          *pDevOem)
{
    CALL_INTRFACE(EnablePDEV, pOemEntry, (pdevobj,
                                          pPrinterName,
                                          cPatterns,
                                          phsurfPatterns,
                                          cjGdiInfo,
                                          pGdiInfo,
                                          cjDevInfo,
                                          pDevInfo,
                                          pded,
                                          pDevOem));
}

extern "C" HRESULT HComOEMDisablePDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj
    )
{
    CALL_INTRFACE(DisablePDEV, pOemEntry, (pdevobj));
}

extern "C" HRESULT HComOEMResetPDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobjOld,
    PDEVOBJ               pdevobjNew
    )
{
    CALL_INTRFACE(ResetPDEV, pOemEntry, (pdevobjOld, pdevobjNew));
}


extern "C" HRESULT HComGetImplementedMethod(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PSTR                  pMethodName
    )
{
    CALL_INTRFACE(GetImplementedMethod, pOemEntry, (pMethodName));
}

//
// OEMDriverDMS - UNIDRV only,
//

extern "C" HRESULT HComDriverDMS(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PVOID                 pDevObj,
    PVOID                 pBuffer,
    WORD                  cbSize,
    PDWORD                pcbNeeded
    )
{
    CALL_INTRFACE(DriverDMS, pOemEntry, (pDevObj, pBuffer, cbSize, pcbNeeded));
}


//
// OEMCommandCallback - UNIDRV only,
//

extern "C" HRESULT HComCommandCallback(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    DWORD                 dwCallbackID,
    DWORD                 dwCount,
    PDWORD                pdwParams,
    OUT INT               *piResult
    )
{
    CALL_INTRFACE(CommandCallback, pOemEntry, (pdevobj,
                                               dwCallbackID, 
                                               dwCount,
                                               pdwParams,
                                               piResult));
}


//
// OEMImageProcessing - UNIDRV only,
//

extern "C" HRESULT HComImageProcessing(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pSrcBitmap,
    PBITMAPINFOHEADER       pBitmapInfoHeader,
    PBYTE                   pColorTable,
    DWORD                   dwCallbackID,
    PIPPARAMS               pIPParams,
    OUT PBYTE               *ppbResult
    )
{
    CALL_INTRFACE(ImageProcessing, pOemEntry,
                  (pdevobj,
                   pSrcBitmap,
                   pBitmapInfoHeader,
                   pColorTable,
                   dwCallbackID,
                   pIPParams,
                   ppbResult));


}

//
// OEMFilterGraphics - UNIDRV only,
//

extern "C" HRESULT HComFilterGraphics(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pBuf,
    DWORD                   dwLen
    )
{
    CALL_INTRFACE(FilterGraphics, pOemEntry,
                  (pdevobj,
                   pBuf,
                   dwLen));

}

//
// OEMCompression - UNIDRV only,
//

extern "C" HRESULT HComCompression(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pInBuf,
    PBYTE                   pOutBuf,
    DWORD                   dwInLen,
    DWORD                   dwOutLen,
    OUT INT                 *piResult
    )
{
    CALL_INTRFACE(Compression, pOemEntry,
                  (pdevobj,
                   pInBuf,
                   pOutBuf,
                   dwInLen,
                   dwOutLen,
                   piResult));

}


//
// OEMHalftone - UNIDRV only
//

extern "C" HRESULT HComHalftonePattern(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pHTPattern,
    DWORD                   dwHTPatternX,
    DWORD                   dwHTPatternY,
    DWORD                   dwHTNumPatterns,
    DWORD                   dwCallbackID,
    PBYTE                   pResource,
    DWORD                   dwResourceSize
    )
{
    CALL_INTRFACE(HalftonePattern, pOemEntry,
                  (pdevobj,
                   pHTPattern,
                   dwHTPatternX,
                   dwHTPatternY,
                   dwHTNumPatterns,
                   dwCallbackID,
                   pResource,
                   dwResourceSize));

}


//
// OEMMemoryUsage - UNIDRV only,
//

extern "C" HRESULT HComMemoryUsage(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    POEMMEMORYUSAGE         pMemoryUsage
    )
{
    CALL_INTRFACE(MemoryUsage, pOemEntry,
                  (pdevobj,
                   pMemoryUsage));

}

//
// OEMTTYGetInfo - UNIDRV only
//

extern "C" HRESULT HComTTYGetInfo(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    DWORD                   dwInfoIndex,
    PVOID                   pOutputBuf,
    DWORD                   dwSize,
    DWORD                   *pcbcNeeded
    )
{
    CALL_INTRFACE(TTYGetInfo, pOemEntry,
                  (pdevobj,
                   dwInfoIndex,
                   pOutputBuf,
                   dwSize,
                   pcbcNeeded));

}


//
// OEMDownloadFontheader - UNIDRV only
//

extern "C" HRESULT HComDownloadFontHeader(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    )
{
    CALL_INTRFACE(DownloadFontHeader, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   pdwResult));

}

//
// OEMDownloadCharGlyph - UNIDRV only
//

extern "C" HRESULT HComDownloadCharGlyph(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    HGLYPH                  hGlyph,
    PDWORD                  pdwWidth,
    OUT DWORD               *pdwResult
    )
{
    CALL_INTRFACE(DownloadCharGlyph, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   hGlyph,
                   pdwWidth,
                   pdwResult));

}


//
// OEMTTDownloadMethod - UNIDRV only
//

extern "C"HRESULT HComTTDownloadMethod(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    )
{
    CALL_INTRFACE(TTDownloadMethod, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   pdwResult));

}

//
// OEMOutputCharStr - UNIDRV only
//

extern "C" HRESULT HComOutputCharStr(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    DWORD                   dwType,
    DWORD                   dwCount,
    PVOID                   pGlyph
    )
{
    CALL_INTRFACE(OutputCharStr, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   dwType,
                   dwCount,
                   pGlyph));

}


//
// OEMSendFontCmd - UNIDRV only
//


extern "C" HRESULT HComSendFontCmd(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    PFINVOCATION            pFInv
    )
{
    CALL_INTRFACE(SendFontCmd, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   pFInv));

}

//
// OEMTextOutAsBitmap - UNIDRV only
//

HRESULT HComTextOutAsBitmap(
    POEM_PLUGIN_ENTRY       pOemEntry,
    SURFOBJ                 *pso,
    STROBJ                  *pstro,
    FONTOBJ                 *pfo,
    CLIPOBJ                 *pco,
    RECTL                   *prclExtra,
    RECTL                   *prclOpaque,
    BRUSHOBJ                *pboFore,
    BRUSHOBJ                *pboOpaque,
    POINTL                  *pptlOrg,
    MIX                     mix
    )
{
    CALL_INTRFACE(TextOutAsBitmap, pOemEntry,
                  (pso,
                   pstro,
                   pfo,
                   pco,
                   prclExtra,
                   prclOpaque,
                   pboFore,
                   pboOpaque,
                   pptlOrg,
                   mix
                   ));

}

extern "C" HRESULT HComWritePrinter(POEM_PLUGIN_ENTRY pOemEntry,
                                    PDEVOBJ           pdevobj,
                                    PVOID             pBuf,
                                    DWORD             cbBuffer,
                                    PDWORD            pcbWritten)
{
    CALL_INTRFACE2(WritePrinter, pOemEntry,
                   (pdevobj,
                    pBuf,
                    cbBuffer,
                    pcbWritten));
}

extern "C" ULONG ReleaseOemInterface(POEM_PLUGIN_ENTRY   pOemEntry)
{


#ifdef WINNT_40

    HRESULT hr;

    if (IsEqualGUID(&pOemEntry->iidIntfOem, &IID_IPrintOemUni)) \
    {
        hr = ((IPrintOemUni *)(pOemEntry)->pIntfOem)->Release();
    }

#else // WINNT_40

    CALL_INTRFACE(Release, pOemEntry,
                    ());

#endif  // WINNT_40

    return 0;
}

#if CODE_COMPLETE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\palette.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    Palette.c

Abstract:

    Implementation of the Palette Management.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/03/97 -ganeshp-
        Created

--*/



#include "unidrv.h"
#pragma hdrstop("unidrv.h")

//Comment out this line to disable FTRACE and FVALUE.
//#define FILETRACE
#include "unidebug.h"

/* Local Function prototypes */
LONG
LSetupPalette (
    PDEV        *pPDev,
    PAL_DATA    *pPD,
    DEVINFO     *pdevinfo,
    GDIINFO     *pGDIInfo
    );


BOOL
BInitPalDevInfo(
    PDEV *pPDev,
    DEVINFO *pdevinfo,
    GDIINFO *pGDIInfo
    )
/*++

Routine Description:
    This function is called to setup the device caps, gdiinfo for
    the palette information for this printer.

Arguments:
    pPDev           Pointer to PDEV structure
    pDevInfo        Pointer to DEVINFO structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    PAL_DATA   *pPD;
    PCOLORMODEEX pColorModeEx = pPDev->pColorModeEx;
    LONG lRet = 0;      //Default is failure.
    PCOMMAND pCmd;
    DWORD    dwCommandIndex;

    //
    // allocate palette structure  and zero initialized, so that all the palette entires
    // default to Black.
    //
    if( !(pPD = (PAL_DATA *)MemAllocZ( sizeof( PAL_DATA ) )) )
    {
        ERR(("Unidrv!BInitPalDevInfo: Memory allocation for PALDATA Failed.\n"));
        goto ErrorExit;
    }

    pPDev->pPalData = pPD;

    if (!pColorModeEx)   //If no colormode, assume Monochrome.
    {
        //
        // Hardcode PCL-XL palette
        //
        // We need to disable Color Management tab in Printer Properties.
        // With out ColorMode in GPD, we need to set palette size here for XL.
        //
        if ( pPDev->ePersonality == kPCLXL )
        {
            pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP | PDF_PALETTE_FOR_OEM_24BPP;
            pPD->wPalDev = 0;

            pdevinfo->cxDither = pdevinfo->cyDither = 0;
            pdevinfo->iDitherFormat = BMF_24BPP;
        }
        else
        {
            /*
             *   Monochrome printer,  so there are only 2 colours,  black
             *  and white.  It would be nice if the bitmap was set with
             *  black as 1 and white as 0.  HOWEVER,  there are presumptions
             *  all over the place that 0 is black.  SO,  we set them to
             *  the preferred way,  then invert before rendering.
             */

            pPD->fFlags   |=  PDF_PALETTE_FOR_1BPP;
            lRet = LSetupPalette(pPDev, pPD, pdevinfo, pGDIInfo);

            if( lRet < 1 )
            {
                ERR(("Unidrv!BInitPalDevInfo:LSetupPalette for monochrome failed, returns %ld\n", lRet ));
                goto ErrorExit;
            }
        }
    }
        else   //Explicit ColorMode  structure
    {
        if ((pColorModeEx->dwDrvBPP != pColorModeEx->dwPrinterBPP) &&
            (pColorModeEx->dwDrvBPP != 4 || pColorModeEx->dwPrinterBPP != 1 ||
             (pColorModeEx->dwPrinterNumOfPlanes != 3 &&
               pColorModeEx->dwPrinterNumOfPlanes != 4)))
        {
            //
            // OEM wants to do the dump themselves so just create
            // a palette based on the DrvBPP
            //
            pPD->wPalDev =  1;

            switch(pColorModeEx->dwDrvBPP)
            {
                case 1:
                    pPD->fFlags   |=  PDF_PALETTE_FOR_1BPP;
                    break;
                case 4:
                    pPD->fFlags   |=  PDF_PALETTE_FOR_4BPP;
                    break;
                case 8:
                    pPD->fFlags   |=  PDF_PALETTE_FOR_8BPP;
                    break;
                case 24:
                    if (pColorModeEx->bPaletteProgrammable)
                        pPD->wPalDev = min((WORD)pColorModeEx->dwPaletteSize,PALETTE_MAX-PALETTE_SIZE_24BIT);
                    pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP | PDF_PALETTE_FOR_OEM_24BPP;
                    break;
                default:
                    //
                    // BUG_BUG, do we need to handle the 16 and 32 bpp as well?
                    //  Alvin says no one has made such a request.
                    //
                    ERR(("Unidrv!BInitPalDevInfo:OEM dump, Format %d BPP not supporteds \n", pColorModeEx->dwDrvBPP));
                    goto ErrorExit;
            }

            //
            //     already opened and assigned to Ganeshp
            // BUG_BUG, Hack for Minidrivers with dump functionality.
            // This is a hack to fix the palette code for minidrivers, which
            // implement ImageProcessing. In this case we need a separate
            // Palette cache for device.In currunt implementation we have only
            // one palette cache which is also used for GDI palette. We need to
            // separate GDI palette and device palette. Because in case the
            // the OEM does the dump, we don't download the GDI palette to
            // the printer. But the cacheing code searches the common palette.
            // Because of this we don't select the colors correctly. For example
            // a input red color gets selects as index 1, even thoug index 1 is
            // not programmed to be read.
            // A complete solution at this point is risky, so we will use the
            // existing code for palettes smaller than GDI palette. For this we
            // create a device palette with just 1 entry, which will get
            // reprogrammed,if the input color is different. This is little
            // inefficeint but require much smaller change.
            //
            //


        }
        else
        {
            // Initialize to default palette size.
            if (pColorModeEx->bPaletteProgrammable)
                pPD->wPalDev =   (WORD)pColorModeEx->dwPaletteSize;
            else
                pPD->wPalDev =  PALETTE_SIZE_DEFAULT;

            // If rastermode is indexed we have to use GDI. Else a custom
            // (preferably VGA) palette will be downloaded. If the PaletteProgrammable
            // flag is set, the palette has to be downloaded. We already know which
            // palette has to be downloaded.

            if ( (pColorModeEx->dwRasterMode == RASTMODE_INDEXED) &&
                (pColorModeEx->bPaletteProgrammable) )
            {
                if (COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY) )
                {
                    pPD->fFlags   |=  PDF_DOWNLOAD_GDI_PALETTE;
                }
                else
                {
                    ERR(("Unidrv!BInitPalDevInfo:NO command to download Programmable Palette\n"));
                    goto ErrorExit;

                }

            }


            if (pColorModeEx->dwPrinterNumOfPlanes == 1)
            {
                //
                // If the Source Bitmap format is also  8 Bit, Then we have
                // to download the palette.So the PaletteSize has to atleast
                // PALETTE_SIZE_8BIT.
                //

                if ( (pColorModeEx->dwPrinterBPP == 8) &&
                    (pColorModeEx->dwDrvBPP == 8) )
                {
                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_8BIT)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_8BIT\n"));
                        goto ErrorExit;

                    }
                    else
                        pPD->fFlags   |=  PDF_PALETTE_FOR_8BPP;

                }
                else if ((pColorModeEx->dwPrinterBPP == 24) &&
                        (pColorModeEx->dwDrvBPP == 24))
                {

                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_24BIT &&
                        pColorModeEx->dwPaletteSize != 1)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_24BIT\n"));
                        goto ErrorExit;

                    }
                    else
                        pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP;
                }
                else if ((pColorModeEx->dwPrinterBPP == 1) &&
                        (pColorModeEx->dwDrvBPP == 1))
                {

                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_1BIT)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_1BIT\n"));
                        goto ErrorExit;

                    }
                    else
                        pPD->fFlags   |=  PDF_PALETTE_FOR_1BPP;
                }

            }
            else
            {
                if ( ((pColorModeEx->dwPrinterNumOfPlanes == 3) ||
                    (pColorModeEx->dwPrinterNumOfPlanes == 4)) &&
                    (pColorModeEx->dwDrvBPP > 1) )
                    pPD->fFlags   |=  PDF_PALETTE_FOR_4BPP;

                // Planer mode. Which may be indexed by Plane.In that case we need
                // to setup the Palette. So the PaletteSize must be atleast PALETTE_SIZE_4BIT.
                if (pPD->fFlags & PDF_DOWNLOAD_GDI_PALETTE)
                {
                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_3BIT)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_4BIT\n"));
                        goto ErrorExit;

                    }
                    else
                    {
                        // In planer mode we only provide programmable palette
                        // support for 3planes.

                        if (pColorModeEx->dwPrinterNumOfPlanes < 4 )
                        {
                            if( !(pPD->pulDevPalCol =
                                (ULONG *)MemAllocZ( pPD->wPalDev * sizeof( ULONG ))) )
                            {
                                ERR(("Unidrv!BInitPalDevInfo: Memory allocation for Device Palette Failed.\n"));
                                goto ErrorExit;
                            }

                        }
                        else
                        {
                            ERR(("Unidrv!BInitPalDevInfo:Can't download Palette for more that 3 Planes.\n"));
                            goto ErrorExit;
                        }

                    }
                }

            }
        }

        lRet = LSetupPalette(pPDev, pPD, pdevinfo, pGDIInfo);

        if( lRet < 1 )
        {
            ERR(("Unidrv!BInitPalDevInfo:LSetupPalette failed, returns %ld\n", lRet ));
            goto ErrorExit;
        }


        // If Palette is not programmable set it to the same as wPalGdi.

        if (pColorModeEx->bPaletteProgrammable)
        {
            if ( COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY))
                pPDev->fMode |= PF_ANYCOLOR_BRUSH;

            //
            // The Palette is divided in to two parts. One non programmable and other
            // programmable. The wPalGdi part of the palette is non programmable. The
            // palette indexes between wPalGdi and wPalDev is programable. If both are
            // same then we have to use the WHITE entry of the palette to program the
            // color.
            //

            if (pPD->wPalDev <= pPD->wPalGdi && !(pPD->fFlags & PDF_PALETTE_FOR_OEM_24BPP))
            {
                //Use the WHITE One to programme a color.
                pPD->wIndexToUse = INVALID_INDEX;
                pPD->fFlags |= PDF_USE_WHITE_ENTRY;
                FTRACE(White palatte entry will be used for programming color);

            }
            else
                pPD->wIndexToUse = (WORD)pPD->wPalGdi;

        }
        else
            pPD->wPalDev = pPD->wPalGdi;

        //Find out when to download the Palette.dwCount for Invocation has Comand Index.

        pPD->fFlags |= PDF_DL_PAL_EACH_PAGE; //Default for palette Download is each Page.

        if (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEDEF)) //If the Command exist check the order dependency.
        {
            if (pCmd->ordOrder.eSection == SS_PAGESETUP)
                goto  PALETTE_SEQUENCE_DETERMINED ;   //  default is ok.
            else if ((pCmd->ordOrder.eSection == SS_DOCSETUP)  ||
                (pCmd->ordOrder.eSection == SS_JOBSETUP))
            {
                pPD->fFlags |= PDF_DL_PAL_EACH_DOC;  //For SS_JOBSETUP or SS_DOCSETUP
                pPD->fFlags &= ~PDF_DL_PAL_EACH_PAGE;
                goto  PALETTE_SEQUENCE_DETERMINED ;
            }
            //  otherwise let ColorMode command determine when to init Palette.
        }

        // dwCount have index to the ColorMode Command. Get the command pointer.
        dwCommandIndex = pPDev->pColorMode->GenericOption.dwCmdIndex;
        pCmd = INDEXTOCOMMANDPTR(pPDev->pDriverInfo, dwCommandIndex) ;


        if (pCmd) //If the Command exist check the order dependency.
        {
            if ( (pCmd->ordOrder.eSection == SS_PAGEFINISH) ||
                      (pCmd->ordOrder.eSection == SS_DOCFINISH) ||
                      (pCmd->ordOrder.eSection == SS_JOBFINISH) )
            {
                ERR(("Unidrv!BInitPalDevInfo:Wrong Section for ColorMode Command, Verify GPD\n"));
                goto ErrorExit;

            }
            else if (pCmd->ordOrder.eSection != SS_PAGESETUP)
            {
                pPD->fFlags |= PDF_DL_PAL_EACH_DOC;  //For SS_JOBSETUP or SS_DOCSETUP
                pPD->fFlags &= ~PDF_DL_PAL_EACH_PAGE;
            }

        }
        else
        {
            //
            // No Command for colormode so assume to download palette on each
            // page. The exception is monochrome 1 bit mode, as most printers
            // default to this mode, so no command is needed.
            //
            if ( pPDev->pColorModeEx->bColor || pColorModeEx->dwDrvBPP != 1)
                WARNING(("Unidrv!BInitPalDevInfo:No Command to select the ColorMode\n" ));
        }

PALETTE_SEQUENCE_DETERMINED:

        // In Planer index mode, that device palette may not be same as GDI Palette.
        // So ask the raster module to fill the device paletter based upon the Plane
        // order.

        if (pPD->pulDevPalCol && !RMInitDevicePal(pPDev,pPD))
        {
            ERR(("Unidrv!BInitPalDevInfo:RMInitDevicePal Failed to init device palette\n"));
            goto ErrorExit;
        }

    }


    //Now Set various common fields in  devinfo and gdiinfo.
    if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
        pdevinfo->hpalDefault = EngCreatePalette( PAL_RGB,
                                                0, 0,   0, 0, 0 );
    else
        pdevinfo->hpalDefault = EngCreatePalette( PAL_INDEXED,
                                                pPD->wPalGdi, pPD->ulPalCol,
                                                                0, 0, 0 );

    //
    // Save the Palette Handle. We will need this to delete the palette.
    //
    pPD->hPalette = pdevinfo->hpalDefault;

    if (pdevinfo->hpalDefault == (HPALETTE) NULL)
    {
        ERR(("Unidrv!BInitPalDevInfo: NULL palette.\n"));
        goto ErrorExit;
    }
    pGDIInfo->ulNumPalReg = pPD->wPalGdi;

    //
    // For  Monochrome mode, enable dither text only on 600 higher resolution 
    // printer and in non N-UP mode.
    // For Color mode, enable dither text only on 300 higher resolution printer 
    // and in non N-UP mode.
    // The threshold values, 600 dpi for mono and 300 dpi for color,
    // were determined not theoritically, but through try-and-erro procedure.
    // We don't know for sure that these values are perfectly value in all
    // situations.
    //
    // Now new GPD keyword "TextHalftoneThreshold is available.
    // If GPD file sets a value for the new keyword and the current resolution
    // is the same as dwTextHalftoneThreshold or greater, set GCAPS_ARBRUSHTEXT 
    //
    if (pPDev->pGlobals->dwTextHalftoneThreshold)
    {
        if (pPDev->ptGrxRes.x >= (LONG)pPDev->pGlobals->dwTextHalftoneThreshold
#ifndef WINNT_40
                && ( pPDev->pdmPrivate->iLayout == ONE_UP ))
#endif
        {
            pdevinfo->flGraphicsCaps  |= GCAPS_ARBRUSHTEXT ;
        }
    }
    else
    {
        if (pPD->fFlags & PDF_PALETTE_FOR_1BPP)
        {
            //
            // Monochrome
            //
            if (( pPDev->ptGrxRes.x >= 600 &&
                  pPDev->ptGrxRes.y >= 600 )
#ifndef WINNT_40
                && ( pPDev->pdmPrivate->iLayout == ONE_UP )
#endif
               )
                pdevinfo->flGraphicsCaps  |= GCAPS_ARBRUSHTEXT ;
        }
        else
        {
            //
            // Color
            //
            if (( pPDev->ptGrxRes.x >= 300 &&
                  pPDev->ptGrxRes.y >= 300 )
#ifndef WINNT_40
                && ( pPDev->pdmPrivate->iLayout == ONE_UP )
#endif
               )
                pdevinfo->flGraphicsCaps  |= GCAPS_ARBRUSHTEXT ;
        }
    }



    return TRUE;

    ErrorExit:
    if (pPD)
    {
        if (pPD->pulDevPalCol)
            MemFree(pPD->pulDevPalCol);
        MemFree(pPD);
        pPDev->pPalData = NULL;
    }
    return FALSE;
}


LONG
LSetupPalette (
    PDEV        *pPDev,
    PAL_DATA    *pPD,
    DEVINFO     *pdevinfo,
    GDIINFO     *pGDIInfo
    )
 /*++
 Routine Description:
    LSetupPalette
        Function to read in the 256 color palette from GDI into the
        palette data structure in Dev Info.

 Arguments:
    pPD         : Pointer to PALDATA.
    pdevinfo    : DEVINFO  pointer.
    pGDIInfo    : GDIINFO Pointer.

Return Value:
    The number of colors in the palette. Returns 0 if the call fails.

Note:

    4/7/1997 -ganeshp-
        Created it.
--*/
{

    long    lRet = 0;
    int     _iI;


    if (pPD->fFlags & PDF_PALETTE_FOR_1BPP)
    {
        /*
         *   Monochrome printer,  so there are only 2 colours,  black
         *  and white.  It would be nice if the bitmap was set with
         *  black as 1 and white as 0.  HOWEVER,  there are presumptions
         *  all over the place that 0 is black.  SO,  we set them to
         *  the preferred way,  then invert before rendering.
         */

        lRet = pPD->wPalGdi        = 2;
        pPD->ulPalCol[ 0 ]         = RGB(0x00, 0x00, 0x00);
        pPD->ulPalCol[ 1 ]         = RGB(0xff, 0xff, 0xff);
        pPD->iWhiteIndex           = 1;
        pPD->iBlackIndex           = 0;

        pdevinfo->iDitherFormat    = BMF_1BPP;    /* Monochrome format */
        pdevinfo->flGraphicsCaps  |= GCAPS_FORCEDITHER;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

        if ( COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY))
        {
            pPDev->fMode |= PF_ANYCOLOR_BRUSH;
        }
        //Set the monochrome brush attributes.
        //CODE_COMPLETE VSetMonochromeBrushAttributes(pPDev);

    }
    else if (pPD->fFlags & PDF_PALETTE_FOR_4BPP)
    {
        /*
         *   We appear to GDI as an RGB surface, regardless of what
         *  the printer is.  CMY(K) printers have their pallete
         *  reversed at rendering time.  This is required for Win 3.1
         *  compatability and many things assume an RGB palette, and
         *  break if this is not the case.
         *
         *          DC_PRIMARY_RGB
         * ------------------------------------------
         * Index 0 = Black
         * Index 1 = Red
         * Index 2 = Green
         * Index 3 = Yellow
         * Index 4 = Blue
         * Index 5 = Magenta
         * Index 6 = Cyan
         * Index 7 = White
         *--------------------------------------------
         * Bit 0   = Red
         * Bit 1   = Green
         * Bit 2   = Blue
         *
         *   If a separate black dye is available,  this can be arranged
         * to fall out at transpose time - we have a slightly different
         * transpose table to do the work.
         */

        /*
         *    Many apps and the engine presume an RGB colour model, so
         *  we pretend to be one!  We invert the bits at render time.
         */

        pPD->iWhiteIndex = 7;
        pPD->iBlackIndex = 0;

        /*
         *      Set the palette colours.  Remember we are only RGB format.
         *  NOTE that gdisrv requires us to fill in all 16 entries,
         *  even though we have only 8.  So the second 8 are a duplicate
         *  of the first 8.
         */
        pPD->ulPalCol[ 0 ] = RGB( 0x00, 0x00, 0x00 );
        pPD->ulPalCol[ 1 ] = RGB( 0xff, 0x00, 0x00 );
        pPD->ulPalCol[ 2 ] = RGB( 0x00, 0xff, 0x00 );
        pPD->ulPalCol[ 3 ] = RGB( 0xff, 0xff, 0x00 );
        pPD->ulPalCol[ 4 ] = RGB( 0x00, 0x00, 0xff );
        pPD->ulPalCol[ 5 ] = RGB( 0xff, 0x00, 0xff );
        pPD->ulPalCol[ 6 ] = RGB( 0x00, 0xff, 0xff );
        pPD->ulPalCol[ 7 ] = RGB( 0xff, 0xff, 0xff );
        //
        // These palette entries will cause really light
        // colors to map to the correct color instead of white
        pPD->ulPalCol[ 8 ] = RGB( 0xef, 0xef, 0xef );
        pPD->ulPalCol[ 9 ] = RGB( 0xff, 0xe7, 0xe7 );
        pPD->ulPalCol[10 ] = RGB( 0xe7, 0xff, 0xe7 );
        pPD->ulPalCol[11 ] = RGB( 0xf7, 0xf7, 0xdf );
        pPD->ulPalCol[12 ] = RGB( 0xe7, 0xe7, 0xff );
        pPD->ulPalCol[13 ] = RGB( 0xf7, 0xdf, 0xf7 );
        pPD->ulPalCol[14 ] = RGB( 0xdf, 0xf7, 0xf7 );
        pPD->ulPalCol[15 ] = RGB( 0xff, 0xff, 0xff );

        lRet = pPD->wPalGdi        = 16;
        pdevinfo->iDitherFormat    = BMF_4BPP;
        pdevinfo->flGraphicsCaps  |= GCAPS_FORCEDITHER;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_4BPP;

    }
    else if (pPD->fFlags & PDF_PALETTE_FOR_8BPP)
    {

        // 8 Bit Mode.

        PALETTEENTRY  pe[ 256 ];      /* 8 bits per pel - all the way */
        FillMemory (pe, sizeof (pe), 0xff);
#ifndef WINNT_40
        if (pPDev->pColorModeEx->bColor == FALSE)
        {
            HT_SET_BITMASKPAL2RGB(pe);
            lRet = HT_Get8BPPMaskPalette(pe,TRUE,0x0,10000,10000,10000);
        }
        else
#endif
            lRet = HT_Get8BPPFormatPalette(pe,
                                      (USHORT)pGDIInfo->ciDevice.RedGamma,
                                      (USHORT)pGDIInfo->ciDevice.GreenGamma,
                                      (USHORT)pGDIInfo->ciDevice.BlueGamma );
    #if PRINT_INFO
        DbgPrint("RedGamma = %d, GreenGamma = %d, BlueGamma = %d\n",(USHORT)pGDIInfo->ciDevice.RedGamma, (USHORT)pGDIInfo->ciDevice.GreenGamma, (USHORT)pGDIInfo->ciDevice.BlueGamma);
    #endif

        if( lRet < 1 )
        {
            ERR(( "Unidrv!LSetupPalette:HT_Get8BPPFormatPalette returns %ld\n", lRet ));
            return(0);
        }
        /*
         *    Convert the HT derived palette to the engine's desired format.
         */

        for( _iI = 0; _iI < lRet; _iI++ )
        {
            pPD->ulPalCol[ _iI ] = RGB( pe[ _iI ].peRed,
                                        pe[ _iI ].peGreen,
                                        pe[ _iI ].peBlue );
        #if  PRINT_INFO
            DbgPrint("Palette entry %d= (r = %d, g = %d, b = %d)\n",_iI,pe[ _iI ].peRed, pe[ _iI ].peGreen, pe[ _iI ].peBlue);

        #endif

        }

        pPD->wPalGdi               = (WORD)lRet;
        pdevinfo->iDitherFormat    = BMF_8BPP;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_8BPP;

#ifndef WINNT_40
        if (pPDev->pColorModeEx->bColor == FALSE)
        {
            pGDIInfo->flHTFlags |= HT_FLAG_USE_8BPP_BITMASK;
            pPD->fFlags |= PDF_PALETTE_FOR_8BPP_MONO;
            if (HT_IS_BITMASKPALRGB(pe))
            {
#if DBGROP
                DbgPrint ("New 8BPP GDI monochrome mode\n");            
#endif                
                pGDIInfo->flHTFlags |= HT_FLAG_INVERT_8BPP_BITMASK_IDX;
                pPD->iBlackIndex = 0;
                pPD->iWhiteIndex = 255;
            }
            else
            {
#if DBGROP
                DbgPrint ("Old 8BPP GDI monochrome mode\n");
#endif                
                pPDev->fMode2 |= PF2_INVERTED_ROP_MODE;
                pPD->ulPalCol[255] = RGB (0x00, 0x00, 0x00);
                pPD->iBlackIndex = 255;
                pPD->ulPalCol[ 0 ] = RGB (0xff, 0xff, 0xff);
                pPD->iWhiteIndex = 0;
            }
        }
        else
#endif
        {
            // Make the 0 index white as most of the printers do ZERO_FILL.
            pPD->ulPalCol[ 7 ]      = RGB (0x00, 0x00, 0x00);
            pPD->iBlackIndex        = 7;
            pPD->ulPalCol[ 0 ]      = RGB (0xff, 0xff, 0xff);
            pPD->iWhiteIndex        = 0;
        }
    }
    else if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
    {
        // we fill the palette entries with -1, so that we know which
        // index is programmed.

        pPD->wPalGdi               = PALETTE_SIZE_24BIT;
        pPD->iWhiteIndex           = 0x00ffffff;
        pdevinfo->iDitherFormat    = BMF_24BPP;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
        FillMemory( pPD->ulPalCol, (PALETTE_MAX * sizeof(ULONG)), 0xff );

        //
        // Fix the first seven colors to primary colors. Render modules
        // assume that index 7 is black.
        //

        pPD->ulPalCol[ 0 ]      = RGB (0xff, 0xff, 0xff);
        pPD->ulPalCol[ 1 ]      = RGB( 0xff, 0x00, 0x00 );
        pPD->ulPalCol[ 2 ]      = RGB( 0x00, 0xff, 0x00 );
        pPD->ulPalCol[ 3 ]      = RGB( 0xff, 0xff, 0x00 );
        pPD->ulPalCol[ 4 ]      = RGB( 0x00, 0x00, 0xff );
        pPD->ulPalCol[ 5 ]      = RGB( 0xff, 0x00, 0xff );
        pPD->ulPalCol[ 6 ]      = RGB( 0x00, 0xff, 0xff );
        pPD->ulPalCol[ 7 ]      = RGB (0x00, 0x00, 0x00);

        lRet = 1;

    }
    else
        ERR(( "Unidrv!LSetupPalette:Unknown Palette Format\n"));

    return lRet;
}

VOID VInitPal8BPPMaskMode(
    PDEV   *pPDev,
    GDIINFO *pGdiInfo
    )
/*++
Routine Description:
    Updates the driver palette if an OEM has requested 8bpp color mask mode.

Arguments:
    pPDev    Pointer to PDEV
    pGDIInfo Pointer to GDIINFO

Return Value:
    Nothing

Note:

    10/23/2000 -alvins-
        Created it.
--*/

{
        ULONG i,lRet;
        PAL_DATA *pPD = (PAL_DATA *)pPDev->pPalData;
        PALETTEENTRY  pe[256];
            
        FillMemory (pe, sizeof (pe), 0xff);
        //
        // only request inverted palette if requested by OEM
        //
        if (pGdiInfo->flHTFlags & HT_FLAG_INVERT_8BPP_BITMASK_IDX)
        {
            HT_SET_BITMASKPAL2RGB(pe);
        } 
        //
        // Get color mask palette and map to internal format
        //   
        lRet = HT_Get8BPPMaskPalette(pe,TRUE,(BYTE)(pGdiInfo->flHTFlags >> 24),10000,10000,10000);
        for( i = 0; i < lRet; i++ )
        {
            pPD->ulPalCol[i] = RGB( pe[i].peRed,pe[i].peGreen,pe[i].peBlue );
        }
        //
        // test whether inverted palette is active
        //
        if (HT_IS_BITMASKPALRGB(pe))
        {
            pPD->iBlackIndex = 0;
            pPD->iWhiteIndex = 255;
        }
        else
        {
            pPDev->fMode2 |= PF2_INVERTED_ROP_MODE;
            pPD->iBlackIndex = 255;
            pPD->iWhiteIndex = 0;
        }                        
}

VOID
VLoadPal(
    PDEV   *pPDev
    )
/*++
Routine Description:
    Download the palette to the printer if the colormode has programmable
    palette. Takes the colors from PALDATA which was setup during DrvEnablePDEV.

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    Nothing

Note:

    4/7/1997 -ganeshp-
        Created it.
--*/

{
    /*
     *   Program the palette according to PCL5 spec.
     *   The syntax is Esc*v#a#b#c#I
     *      #a is the first color component
     *      #b is the second color component
     *      #c is the third color component
     *      #I assigns the color to the specified palette index number
     *   For example, Esc*v0a128b255c5I assigns the 5th index
     *   of the palette to the color 0, 128, 255
     *
     */


    PAL_DATA    *pPD;
    INT         iEntriesToProgram, iI;
    ULONG       *pPalette;

    pPD = pPDev->pPalData;

    if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
    {
        FillMemory( pPD->ulPalCol, (PALETTE_MAX * sizeof(ULONG)), 0xff );

        //
        // Fix the first seven colors to primary colors. Render modules
        // assume that index 7 is black.
        //

        pPD->ulPalCol[ 0 ]      = RGB (0xff, 0xff, 0xff);
        pPD->ulPalCol[ 1 ]      = RGB( 0xff, 0x00, 0x00 );
        pPD->ulPalCol[ 2 ]      = RGB( 0x00, 0xff, 0x00 );
        pPD->ulPalCol[ 3 ]      = RGB( 0xff, 0xff, 0x00 );
        pPD->ulPalCol[ 4 ]      = RGB( 0x00, 0x00, 0xff );
        pPD->ulPalCol[ 5 ]      = RGB( 0xff, 0x00, 0xff );
        pPD->ulPalCol[ 6 ]      = RGB( 0x00, 0xff, 0xff );
        pPD->ulPalCol[ 7 ]      = RGB (0x00, 0x00, 0x00);
    }

    if (pPD->fFlags & PDF_DOWNLOAD_GDI_PALETTE)
    {


        if (pPD->wPalDev > PALETTE_MAX)
        {
            WARNING(("Unidrv!vLoadPal: Invalid number of palette entries to program\n"));
            pPD->wPalDev = PALETTE_MAX;
        }
        if (pPD->pulDevPalCol)
            pPalette = pPD->pulDevPalCol;
        else if (pPD->fFlags & PDF_PALETTE_FOR_OEM_24BPP)
            pPalette = &pPD->ulPalCol[PALETTE_SIZE_24BIT];
        else
            pPalette = pPD->ulPalCol;


        if (pPD->fFlags & PDF_PALETTE_FOR_8BPP)
            iEntriesToProgram = min(256,pPD->wPalDev);
        else
            iEntriesToProgram = min(pPD->wPalDev,pPD->wPalGdi);

        // Start palette definition.

        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEDEF));

        // if only one entry, program it to black
        //
        if (iEntriesToProgram == 1)
        {
            pPDev->dwRedValue = RED_VALUE(RGB_BLACK_COLOR);
            pPDev->dwGreenValue = GREEN_VALUE(RGB_BLACK_COLOR);
            pPDev->dwBlueValue = BLUE_VALUE(RGB_BLACK_COLOR);
            pPDev->dwPaletteIndexToProgram = 0;
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY));
        }
        else
        {
            // Download each palette entry.
            for( iI = 0; iI < iEntriesToProgram; ++iI )
            {
                //pPDev->dwRedValue =RED_VALUE ((pPD->ulPalCol [iI] ^ 0x00FFFFFF));
                //pPDev->dwGreenValue = GREEN_VALUE ((pPD->ulPalCol [iI] ^ 0x00FFFFFF));
                //pPDev->dwBlueValue =  BLUE_VALUE ((pPD->ulPalCol [iI] ^ 0x00FFFFFF));

                pPDev->dwRedValue =RED_VALUE((pPalette[iI]));
                pPDev->dwGreenValue = GREEN_VALUE((pPalette[iI]));
                pPDev->dwBlueValue =  BLUE_VALUE((pPalette[iI]));
                pPDev->dwPaletteIndexToProgram = iI;

                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY));
            }

        }

        // Send End Palette definition command.
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_ENDPALETTEDEF));

    }


    return;
}

BOOL
BSelectProgrammableBrushColor(
    PDEV   *pPDev,
    ULONG   Color
    )
/*++
Routine Description:
    Sets the brush color to give color.
Arguments:
    pPDev   Pointer to PDEV
    Color   Input Color to select. If it's -1 that means restore the palette
            to original state.

Return Value:
    TRUE for success and FALSE for failure or if the palette can't be programmed.

Note:

    4/9/1997 -ganeshp-
        Created it.
--*/

{
    INT         iIndex;
    INT         iPaletteEntryToSelect;
    PAL_DATA    *pPD;
    BOOL        bProgramEntry = FALSE;
    BOOL        bSelectEntry  = TRUE;
    ULONG       *pPalette;
    INT         iWhiteIndex;


    FTRACE(TRACING  BSelectProgrammableBrushColor);
    FVALUE(Color,0x%x);

    if (pPDev->fMode & PF_ANYCOLOR_BRUSH)
    {
        pPD = pPDev->pPalData;

        if (pPD->pulDevPalCol)
            pPalette = pPD->pulDevPalCol;
        else if (pPD->fFlags & PDF_PALETTE_FOR_OEM_24BPP)
            pPalette = &pPD->ulPalCol[PALETTE_SIZE_24BIT];
        else
            pPalette = pPD->ulPalCol;

        //
        // iWhiteIndex in 24 bit mode is set to the real color (0x00FFFFFF) and
        // not the index. We need to take care of this case. In this mode
        // white is programmed in 0 index, so we will use this number instead
        // of pPD->iWhiteIndex.
        //

        if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
            iWhiteIndex = 0;
        else
            iWhiteIndex =  pPD->iWhiteIndex;
        FVALUE(iWhiteIndex,%d);

        // Check for Black or white color. As we can directly select the colors.
        // Also check if the White index has to be reprogrammed.
        // This should be done for non 24 bit mode.

        if (Color == INVALID_COLOR)
        {
            // Set the BrushColor to invalid,so that next time we always
            // program the input color.

            pPDev->ctl.ulBrushColor = Color;

            if ( pPDev->fMode & PF_RESTORE_WHITE_ENTRY )  //Special restore case.
            {
                iPaletteEntryToSelect = (pPD->pulDevPalCol) ?
                                        pPD->wIndexToUse : iWhiteIndex;
                bProgramEntry = TRUE;
                bSelectEntry  = FALSE;
                pPDev->fMode &= ~PF_RESTORE_WHITE_ENTRY; //Clear the Flag.
                Color = RGB_WHITE_COLOR;
                FTRACE(Restoring White Entry);
            }
            else
                return TRUE; //Don't do any thing if color is -1 and flag is not set.

        }

        if( (Color != INVALID_COLOR) && (ULONG)Color != pPDev->ctl.ulBrushColor )
        {
            iPaletteEntryToSelect = pPD->wIndexToUse;

            // Search the Palette for the color unless palette size is 1

            if (pPD->wPalDev == 1)
            {
                bProgramEntry = TRUE;
                pPD->wIndexToUse = iIndex = 0;
            }
            else
            {
                for (iIndex = 0; iIndex < pPD->wPalDev; iIndex++ )
                {
                    if (pPalette[iIndex] == Color) //Color is matched.
                    {
                        FTRACE(Color is found in palette.);
                        FVALUE(iIndex,%d);

                        break;
                    }
                }

            }

            //Check if there was a match in the palette. If there is no match
            //then programme a entry else use the matched one.

            if (iIndex == pPD->wPalDev) //No Match
            {
                FTRACE(Color is not found in palette.Programme the Palette.);

                bProgramEntry = TRUE;
                if (!(pPD->fFlags & PDF_USE_WHITE_ENTRY))
                {
                    FTRACE(Palette has spare entries to programme);

                    iPaletteEntryToSelect = (pPD->wIndexToUse < pPD->wPalDev) ?
                                            pPD->wIndexToUse :
                                            (pPD->wIndexToUse = pPD->wPalGdi );
                    pPD->wIndexToUse++;

                }
                else // Use White Entry to reprogramme the color
                {
                    FTRACE(Palette does not have spare entries to program.);
                    FTRACE(Using White entry to program.);

                    pPDev->fMode |= PF_RESTORE_WHITE_ENTRY;

                    //If initialized use it else find white.
                    if (pPD->wIndexToUse != INVALID_INDEX)
                        iPaletteEntryToSelect = pPD->wIndexToUse;
                    else if (pPD->pulDevPalCol) //If there is a separate device pal use it.
                    {
                        //Remember the White Index.
                        for (iIndex = 0; iIndex < pPD->wPalDev; iIndex++ )
                        {
                            if (pPalette[iIndex] == RGB_WHITE_COLOR)
                            {
                                pPD->wIndexToUse =
                                iPaletteEntryToSelect = iIndex;
                                break;
                            }
                        }
                        if (iIndex == pPD->wPalDev)  //No White Found,use the Last entry.
                        {
                            WARNING(("Unidrv!BSelectBrushColor: No White entry in device Palette.\n"));
                            pPD->wIndexToUse =
                            iPaletteEntryToSelect = iIndex -1;
                        }
                    }
                    else
                        pPD->wIndexToUse =
                        iPaletteEntryToSelect = min((PALETTE_MAX-1),iWhiteIndex);
                }

                FVALUE(pPD->wIndexToUse,%d);
            }
            else  //Color is Matched.
                iPaletteEntryToSelect = iIndex;

            FVALUE(iPaletteEntryToSelect,%d);
            ASSERTMSG((iPaletteEntryToSelect < PALETTE_MAX),("\n iPaletteEntryToSelect should always be less than PALETTE_MAX.\n"));
        }
        else
            bSelectEntry = FALSE; //The color is already selected.

        //If we have to program a palette entry, do it now.
        if (bProgramEntry)
        {
            //
            // Make sure that we don't overrun the palette.
            //
            if (iPaletteEntryToSelect >= PALETTE_MAX)
                iPaletteEntryToSelect = PALETTE_MAX-1;

            pPDev->dwRedValue = RED_VALUE (Color);
            pPDev->dwGreenValue = GREEN_VALUE (Color);
            pPDev->dwBlueValue =  BLUE_VALUE (Color);
            pPDev->dwPaletteIndexToProgram = iPaletteEntryToSelect;
            pPalette[iPaletteEntryToSelect] = Color;
            if(COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEREDEF))
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEREDEF));
            if(COMMANDPTR(pPDev->pDriverInfo, CMD_REDEFINEPALETTEENTRY))
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_REDEFINEPALETTEENTRY));
            else
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY));
            if(COMMANDPTR(pPDev->pDriverInfo, CMD_ENDPALETTEREDEF))
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_ENDPALETTEREDEF));

        }

        //Now Select the color.
        if (bSelectEntry)
        {
            pPDev->dwCurrentPaletteIndex = iPaletteEntryToSelect;
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTPALETTEENTRY));
            //Set the BrushColor to new color.
            pPDev->ctl.ulBrushColor = Color;

        }
        FTRACE(End Tracing BSelectProgrammableBrushColor\n);

        return TRUE;
    }
    return FALSE;

}


VOID
VResetProgrammableBrushColor(
    PDEV   *pPDev
    )
/*++
Routine Description:
    Reset the programmable palette and select the default color.
Arguments:
    pPDev   Pointer to PDEV

Return Value:
    None

Note:

    4/28/1997 -ganeshp-
        Created it.
--*/

{
    PAL_DATA    *pPD;

    pPD = pPDev->pPalData;
    if (pPDev->fMode & PF_ANYCOLOR_BRUSH)
    {
        // Special restore case.
        if ( pPDev->fMode & PF_RESTORE_WHITE_ENTRY )
            BSelectProgrammableBrushColor(pPDev, INVALID_COLOR);

        // Select the black. We should actualy select the default palette color.
        // But GPD doesn't have any entries for that.

        if ((INT)pPDev->ctl.ulBrushColor != RGB_BLACK_COLOR)
            BSelectProgrammableBrushColor(pPDev, RGB_BLACK_COLOR);

    }

}

DWORD
ConvertRGBToGrey(
    DWORD   Color
    )

/*++

Routine Description:

    This function converts an RGB value to grey

Arguments:

    Color       - Color to be checked

Return Value:

    DWORD       - grey scale RGB color

Revision History:


--*/

{
//
// convert RGB value to grey scale intensity using sRGB or NTSC values
#ifndef SRGB
    INT iIntensity = ((RED_VALUE(Color) * 54) +
                      (GREEN_VALUE(Color) * 183) +
                      (BLUE_VALUE(Color) * 19)) / 256;
#else
    INT iIntensity = ((RED_VALUE(Color) * 77) +
                      (GREEN_VALUE(Color) * 151) +
                      (BLUE_VALUE(Color) * 28)) / 256;
#endif
    return (RGB(iIntensity,iIntensity,iIntensity));
}


DWORD
BestMatchDeviceColor(
    PDEV    *pPDev,
    DWORD   Color
    )

/*++

Routine Description:

    This function find the best pen color index for the RGB color

Arguments:

    pPDev       - Pointer to our PDEV

    Color       - Color to be checked

Return Value:

    LONG        - Pen Index, this function assume 0 is always white and 1 up
                  to the max. pen is defined

Author:

    08-Feb-1994 Tue 00:23:36 created  -by-  Daniel Chou (danielc)

    23-Jun-1994 Thu 14:00:00 updated  -by-  Daniel Chou (danielc)
        Updated for non-white pen match

Revision History:


--*/

{
    UINT    Count;
    UINT    RetIdx;
    PAL_DATA    *pPD;

    pPD = pPDev->pPalData;
    RetIdx = pPD->iBlackIndex; //Default to black.

    if (Count = (UINT)(pPD->wPalGdi))
    {
        LONG    LeastDiff;
        LONG    R;
        LONG    G;
        LONG    B;
        UINT    i;
        LPDWORD pPal      = (LPDWORD)pPD->ulPalCol;
        //
        // find closest intensity match since this is monochrome mapping
        //
        if (pPD->fFlags & PDF_PALETTE_FOR_8BPP_MONO)
            Color = ConvertRGBToGrey(Color);
        //
        // find closest color using least square distance in RGB
        //

        LeastDiff = (3 * (256 * 256));
        R         = RED_VALUE(Color);
        G         = GREEN_VALUE(Color);
        B         = BLUE_VALUE(Color);

        for (i = 0; i < Count; i++, pPal++) {

            LONG    Temp;
            LONG    Diff;
            DWORD   Pal;

            Pal = *pPal;

            if (Color == 0x00FFFFFF) {

                //
                // White Color we want to exact match
                //

                if (Color == Pal) {
                    RetIdx = i;
                    break;
                }

            }
            else if (Pal != 0x00FFFFFF) {

                //
                // The Color is not white, so map to one of non-white color
                //

                Temp  = R - (LONG)RED_VALUE(Pal);
                Diff  = Temp * Temp;

                Temp  = G - (LONG)GREEN_VALUE(Pal);
                Diff += Temp * Temp;

                Temp  = B - (LONG)BLUE_VALUE(Pal);
                Diff += Temp * Temp;

                if (Diff < LeastDiff) {

                    RetIdx = i;

                    if (!(LeastDiff = Diff)) {

                        //
                        // We have exact match
                        //

                        break;
                    }
                }
            }
        }
    }

    return((DWORD)RetIdx);
}

#if CODE_COMPLETE
VOID
VSetMonochromeBrushAttributes(
    PDEV   *pPDev
    )
/*++
Routine Description:
    This routine sets the monochrome brush attributes.

Arguments:
    pPDev   Pointer to PDEV

Note:

    4/21/1997 -ganeshp-
        Created it.
--*/
{
    PAL_DATA    *pPD = pPDev->pPalData;

    if (pPD)
    {
        // Check if the printer supports Fill rectangle command or not. We also
        // check for min and max gray level. Min should be less than max.
        if ( COMMANDPTR(pPDev->pDriverInfo,CMD_SELECTGRAYPATTERN) &&
             (pPDev->pGlobals->dwMinPatternGrayLevel <
              pPDev->pGlobals->dwMaxPatternGrayLevel) )
        {
            pPDev->fMode |= PF_GRAY_BRUSH;

            // If White is not supported by gray level command, check if a
            // separate command for white text simulation or not.

            if ( (pPDev->pGlobals->dwMinPatternGrayLevel > 0)
            {
                //
                // If the device doesn't support white as grey level
                // then some other command has to be used for white.
                // check if there is CMD_WHITEPATTERN command or not.
                // If the device doesn't have this command, try for
                // font simulation WHITE_TEXT_ON command.
                //

                if (COMMANDPTR(pPDev->pDriverInfo,CMD_SELECTWHITEPATTERN))
                    pPD->fFlags |= PDF_USE_WHITE_PATTERN;

                /***TODEL****
                else if (COMMANDPTR(pPDev->pDriverInfo,CMD_WHITETEXTON))
                    pPD->fFlags |= PDF_USE_WHITE_TEXT_ON_SIM;
                ****TODEL****/
            }
            if ( (pPDev->pGlobals->dwMaxGrayFill < 100)
            {
                //
                // If the device doesn't support black as grey level
                // then some other command has to be used for black.
                // check if there is CMD_BLACKPATTERN command or not.
                // If the device doesn't have this command, try for
                // font simulation WHITE_TEXT_OFF command.
                //

                if (COMMANDPTR(pPDev->pDriverInfo,CMD_WHITEPATTERN))
                    pPD->fFlags |= PDF_USE_BLACK_PATTERN;
                /***TODEL****
                else if (COMMANDPTR(pPDev->pDriverInfo,CMD_WHITETEXTON))
                    pPD->fFlags |= PDF_USE_WHITE_TEXT_OFF_SIM;
                ****TODEL****/
            }
        }

    }
    else
    {
        ASSERTMSG(FALSE,("\n VSetMonochromeBrushAttributes pPDev->pPalData in NULL!!.\n"));
    }

}

BOOL
BInitPatternScope(
    PDEV   *pPDev
    )
/*++
Routine Description:
    Initialize the  scope of the pattern/brush. This is necessary
Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    4/22/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet = TRUE;
    PLISTNODE   pListNode;
    PAL_DATA    *pPD = pPDev->pPalData;


    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liPatternScopeList ) )
    {
        while (pListNode)
        {
            // Check the pattern scope and set the corresponding bit in fScope.
            switch (pListNode->dwData)
            {
            case PATTERN_SCOPE_TEXT:
                pPD->fScope |= PDS_TEXT;
                break;
            case PATTERN_SCOPE_VECTOR:
                pPD->fScope |= PDS_VECTOR;
                break;
            case PATTERN_SCOPE_RASTER:
                pPD->fScope |= PDS_RASTER;
                break;
            case PATTERN_SCOPE_RECTFILL:
                pPD->fScope |= PDS_RECTFILL;
                break;
            case PATTERN_SCOPE_LINE:
                pPD->fScope |= PDS_LINE;
                break;
            default:
                ERR(("Unidrv!BInitPatternScope: Wrong value in PatternScope List\n"));
                bRet = FALSE;
                break;

            }
            if (bRet)
                pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
            else
                break; //Error
        }
    }

    return bRet;
}

BOOL
BSelectMonochromeBrush(
    PDEV   *pPDev,
    ULONG   Color
    )
/*++
Routine Description:
    Sets the brush color to give color.
Arguments:
    pPDev   Pointer to PDEV
    Color   Input Color to select. If it's -1 that means restore the palette
            to original state.

Return Value:
    TRUE for success and FALSE for failure or if the palette can't be programmed.

Note:

    4/9/1997 -ganeshp-
        Created it.
--*/

{
    INT         iIndex;
    INT         iPaletteEntryToSelect;
    PAL_DATA    *pPD;
    BOOL        bProgramEntry = FALSE;
    BOOL        bSelectEntry  = TRUE;
    ULONG       *pPalette;
}
#endif //CODE_COMPLETE

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\move2.c ===
notes, comments on existing code and
outline of rewritten moveto commands
which are coordinate independent.


INT
MoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the X position along the logical (GDIs) X axis.
    This function will emit whatever command is needed to accomplish this
    regardless of the printer's coordinate system.

    I must recast the Xmoveto and Ymoveto commands into this new
    paradigm because I want to support font rotations using the
    PrintDirection command.

    Assumptions:


    when making an absolute move, set both standard variables for
    x and y.   don't know why, maybe for those printers that have
    only a moveXandY command.

     MV_PHYSICAL is not supported.   Only mv to cursor origin is supported.

    unidrv5 code assumes if no absolute moves exist, the
    default cursor position at StartPage time is the cursor origin.

    the supplied movement commands are sufficient to
    move the cursor anywhere within the specified imageable area.

    the default font is always currently selected.       So iDefWidth is correct.

    unless overridden explictly by GPD, abs x, y move cannot accept a negative value.

    rel x, y moves only accept a positive value, so if in reality they accept
    both positive and negative, the negative command must be
    treated as a separate  command in the opposite direction which prepends
    the negative sign in the specification of the command parameter.

    unidrv5 code assumes if there is no explicit relative left move command,
    you cannot move left.  Which means the rel right move command is assumed
    to accept only non-negative values.

    If only one relative move command direction exists, that direction
    is assumed to be right.

    Use linefeed spaceing only for positive movements along the y - direction.
    and then only if fYMove & FYMOVE_FAVOR_LINEFEEDSPACING


        the data tree is not fully populated.
        We only know the cursor and Imageable origin for
        the two major orientations (Portrait and Landscape).
        If we wander from that, using PrintDirection, we must
        restrict ourselves to relative moves.

        The input (requested move) coordinate system will be the
        current GDI coordinates.
        see  (pPDev->pOrientation->dwRotationAngle == ROTATE_90,
            ROTATE_NONE, etc)

        The working coordinate system will be the imageable
        area in Portrait orientation.   This is because there are
        values that are invariant in this system:
        Xmoveunits and Ymoveunits.   We will keep the errors
        during and beyond any temp rotations using PrintDirection.

        Making the transformation to the working CS:

        need the dimensions of the imageable area  in Portrait orientation

        the input cannot ever be specified wrt cursor origin, since
        that makes no sense when the driver is rotating.
        So why would the code ever what to do something different
        depending on who is rotating?   Why would the code
        ever care about where the cursor origin is?

        ok, the only time the driver cares is becuase the printer
        expects the cursor to be at x=0 or y=0 prior to doing something
        like emitting a line of graphics or selecting a font.
        So just define a special flag MV_CURSOR_ZERO  that causes this to happen.
        (if <cr> takes us to cursor origin, fine do that, else convert to
        logical coordinates and let rest of code handle it.)
        Is there such an entity as a cursor origin if there is no
        abs move command to get there?


        now need to know what commands are available, capabilities
        (can accept negative args?  move unit, move direction -
        up, down, right , left wrt a portrait page)
        and for absolute commands, where the location of their
        origin is.    Note this is dependent on pPDev->pGlobals->bRotateCoordinate,
        pPDev->pOrientation->dwRotationAngle   and PrintDirection.

        How to characterize a printers movement commands for each
        of the printers major orientations.

        For each supported orientation:
        (portrait is always supported,  others only if bRotateCoordinate == TRUE.)
        The current snapshot should supply cursor origin, imageable origin
        so I can compute the cursorOffset wrt imageable origin.
        Also look at imageable area, so we know if cursor move command
        is valid.

        List of absolute cursor move commands and allowed range (neg supported?)
          place in a table with directions.
        List of relative move commands and and allowed range (neg supported?)

        dir     abs     relative           last resort    (use only if printdir = 0)
        -----------------------------------------
        x                                            spaces
        -y
        -x                                       <cr>
        y                                           linefeed

        the array accepts either a command index or ptr,
        a NULL indicator for not supported
        and  USE_NEG  which means use the opposite directions move command
        with a negative argument.
        note the dir is wrt Portrait orientation.

        such a table exists for portrait (initialized directly from gpd)
        then one is synthesized for each supported orientation.
        then one is created on the fly starting from the current supported
        orientation  if PrintDirection is not zero.
        Just shift each relative cmd  entry up for each 90 deg change in the
        print direction.     Set all abs entries to NULL.

        The GPD will have a new keyword NEG_ALLOWED  for the abs and
        relative move commands.

        CR and other ways to move the cursor will be assumed to be available
        in all supported orientations.


        these values don't necessarily change as the print direction changes:

        *XMoveThreshold  (0 , * or inbetween)
        *YMoveThreshold  (0 , * or inbetween)    (when to use abs instead of relative)
        *X, YMoveUnit  always referenced to the portrait page.
            (should really be referred to as ScanDirMoveUnit, and FeedDirMoveUnit)


        I then choose the 'best' command to move the cursor
        to its requested position.

    flowchart please, are there bad combinations and hidden assumptions?
    how are quantization errors handled and physical and logical cursor
    positions updated?


     more special cases:

     MV_UPDATE:  at least quantize to moveUnits before storing new cursor
        position.
     MV_RELATIVE:  this means movement is relative to current logical cursor
        position,  doesn't mean use relative move commands.


      logic tree:

      convert imageable coordinates to cursor origin coordinates.
      determine direction we want to move
      check existence of abs and relative commands.


      initialization:

    if  we are in a non-zero PrintDirection and uninit flag is set, emit an assert.
    the print direction should never be changed before initializing
    the cursor's position. (what if there are no initialization commands?)

      if abs commands exist AND They can get us to the specified
      position just emit the abs command and clear the uninit flag.

      else emit abs command to set both X and Y axis to cursor 0. and
      clear the uninit flag.

      if no abs commands exist, emit <cr> and set cursor position
      to (cursor or image org , 0)  clear the uninit flag.
      even though not strictly correct.

      now drop into the relative move portion to attempt to finish the move.
      if no dedicated relative move command exists in the desired direction,
      check and see if sending <cr> causes a movment in that direction
      if so send <cr> and goto top of paragraph.
      check to see if sending filler (spaces, nulls) causes a movment in that direction.
      if so send them.



      cursor origin?   should a command be emitted to set the printer to
        this position?   or should we assume y = 0 (cursor position)
        and emit  <cr> and we know that will take us to either imageable
        origin or cursor origin.

      after the first move follow this formula:

      abs move  unless desired relative move exists
        and is favored.
      if abs move wasn't used, use relative move.
      as implemented above.


       logic for last resort moves:
        if <CR> needed:
            emit <cr>  calculate remaining move needed
        if  spaces needed (pos x direction and over the theshold)
            emit correct number of spaces
            calculate remaining move
        if nulls needed
            emit correct number of nulls
            update actual  and logical     cur position
            no need to calulate remaining move.  nothing else to be done.

        if(linefeed needed)

Arguments:

    pPDev - Pointer to PDEVICE struct
    iXIn  - Number of units to move in X direction
    fFlag - Specifies the different X move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/




/* -------  current code with comments  ------------ */

INT
XMoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the X position along the X axis.
    what is the definition of X axis?  it is the printer's
    logical x-axis.  If the printer has a Landscape or Printing Direction command
    these will change the logical x-axis.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iXIn  - Number of units to move in X direction
    fFlag - Specifies the different X move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{
    int   iX, iFineValue, iDiff = 0;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    int iScale;

    //
    // If the position is given in graphics units, convert to master units
    //
    // ptGrxScale has been adjusted to suit the current orientation.
    //

    //*\\  ok, this makes sense if X and Y moveto is swapped
    //  by caller if driver does the rotation.

    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
            //*\\  is driver performing the Landscape rotation?
        iScale = pPDev->ptGrxScale.y;  //*\\  driver is
    else
        iScale = pPDev->ptGrxScale.x;  //*\\  printer is

    if ( fFlag & MV_GRAPHICS )  //*\\  iXin  is in graphics units
    {
        iXIn = (iXIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iX = iXIn;

    //
    // Basically, only adjust if we are doing absolute move
    //


//*\\  MV_PHYSICAL  means iXIn is wrt to cursor origin not imageable origin.
//*\\  sometimes used by render code to go to cursor origin.

    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iX += pPDev->sf.ptPrintOffsetM.x;

//*\\  convert iX to cursor cooridinates.   note sf.ptPrintOffsetM
//*\\   is defined as  ImageableOrigin - CursorOrigin


    //
    // If it's a relative move, update iX (iX will be the absolute position)
    // to reflect the current cursor position

//*\\  note cursor position (ctl.ptCursor) is always wrt the cursor origin.

    if ( fFlag & MV_RELATIVE )
        iX += pPDev->ctl.ptCursor.x;

//*\\   iX represents the cursor position wrt the cursor origin after
//*\\   the specified move has been executed.

    //
    // Update, only update our current cursor position and return
    // Do nothing if the XMoveTo cmd is called to move to the current position.
    //

    if ( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptCursor.x = iX;
        return 0;
    }

    if ( pPDev->ctl.ptCursor.x == iX )
        return 0;


    //
    // If iX is zero and pGlobals->cxaftercr does not have
    // CXCR_AT_GRXDATA_ORIGIN set, then we send CR and reset our
    // cursor position to 0, which is the printable x origin
    //
    //*\\  ignore above comment there is no  CXCR_AT_GRXDATA_ORIGIN
    //*\\  only  at cursor origin or imageable origin.
    //  if cursor is requested to move to its origin and a <cr> will take it
    //  to the origin,  issue the <cr>.

    if (iX == 0 && (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN ||
            pPDev->sf.ptPrintOffsetM.x == 0))
    {
        pPDev->ctl.ptCursor.x = 0;
        WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));
        return 0;
    }

    //
    // Check whether we any X move cmd, PF_NO_XMOVE_CMD is set if we did
    // not see any relative or absolute x move cmds
    //

    if( pPDev->fMode & PF_NO_XMOVE_CMD)
    {
        //
        // There is no X move command(abs or relative), so we'll have to simulate
        // using blanks or null graphics data (0)
        //

        //
        // We *assume* that when XMoveto is called, the current font is always
        // the default font IF the printer has no X movement command.
        //

        int     iRelx = iX - pPDev->ctl.ptCursor.x ;
        int     iDefWidth;

        //
        // Convert to Master Units
        //

        //
        // BUG_BUG, Double check that we can use Default Font here when
        // we have a custom TTY driver
        //


        if ( iRelx < 0 )
        {
            if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                iRelx = iX;
            else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
            {
                ASSERT(pPDev->pGlobals->bRotateCoordinate==FALSE);
                //*\\  this means if the printer has no X move commands
                //  it had better not claim it can perform coordinate rotations.

                iRelx = iX - pPDev->pf.ptImageOriginM.x;     >>>wrong!!!!<<<
            }

            WriteChannel( pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN ));
        }

        //
        // Simulate X Move, algorithm is that we always send a blank space
        // for every character width, and send graphics null data for
        // the remainder.
        //

//*\\  potential bugs:  what if a different font is selected?
//*\\  font width wasn't originally specified in resolution units
//*\\  so ganesh does a rounding operation.  This may not agree
//*\\  with the printers idea of the font width. (x-advance)

//*\\  why isn't requested position tracked?  Imagine the cursor only moves
//*\\  in units of 2 master units, a series of 10 1 unit relative move to commands should
//*\\  result in the cursor moving 10 units using 5 actual moves of 2 units each.


//*\\ the assumption here is iRelx is always positive.
//  this should be ok, since if there are no dedicated
//  movement commands, and the makeshift commands used
//  can only move to the right, there is no way to access
//  any region to the left of the cursor origin (accessed via <cr>).


        iDefWidth = pPDev->ptDefaultFont.x * iScale;
        if (iDefWidth)
        {
            while( iRelx >= iDefWidth )
            {
                WriteSpoolBuf( pPDev, (LPSTR)" ", 1 );
                iRelx -= iDefWidth;
            }
        }
        else
            TERSE (("XMoveTo: iDefWidth = 0\n"));


        //
        // Send the remaining partial space  via FineXMoveTo.
        //

        iDiff = iRelx;
        fFlag |= MV_FINE;    // Use graphics mode to reach point

    }
    else
    {
        DWORD dwTestValue  = abs(iX - pPDev->ctl.ptCursor.x);
        COMMAND *pCmd;

        //
        // X movement commmands are available,  so use them.
        // We need to decide here whether relative or absolute command
        // are favored

        //
        // General assumption: if dwTestValue > dwXMoveThreshold,
        // absolute command will be favored
        //

        //
        // BUG_BUG, if we are stripping blanks, we need to check whether
        // it's legal to move in Graphics mode.  If it's not, we have
        // to get out of graphics mode before moving.
        //

        //   buggy!,  buggy!  buggy!
        //*\\  avoid using absolute moves for negative values?
        //  yet its ok to use negative values the first time?
        //  what happens if  negative abs move is the only way
        //  to reach that portion of the printable area?
        //  if you set dwXMoveThreshold to a non-zero value,
        //  you had better have relative movement commands
        //


        if (((pPDev->ctl.dwCursorMode & CURSOR_X_UNINITIALIZED) ||
            (dwTestValue > pPDev->pGlobals->dwXMoveThreshold &&
            iX > 0)) &&
            (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVEABSOLUTE)) != NULL)
        {
            //
            // if the move units are less (coarser) than the master units then we need to
            // check whether the new position will end up being the same as the
            // original position. If so, no point in sending another command.
            //

            //  I think ptDeviceFac is the number of master units covered
            //  by one move unit.

            if (!(pPDev->ctl.dwCursorMode & CURSOR_X_UNINITIALIZED) &&
                (pPDev->ptDeviceFac.x > 1) &&
                ((iX - (iX % pPDev->ptDeviceFac.x)) == pPDev->ctl.ptCursor.x))
                //*\\  I would have rewritten the last condition as:
                //  (iX / pPDev->ptDeviceFac.x == pPDev->ctl.ptCursor.x / pPDev->ptDeviceFac.x)
                //    ptCursor is the quantized cursor position in master units, not
                //  where the app expects the cursor to be.
            {
                iDiff = iX - pPDev->ctl.ptCursor.x;   //  having the caller keep track of
                // this is just plain wrong.  you know it will be dropped.  since one
                // caller cannot transfer the error to the next caller.
            }
            else
            {

                //*\\  what is this:   ctl.ptAbsolutePos  ?  this is the standard variable
                //*\\  why isn't ctl.ptCursor updated ?   it is at the very end of this function.

                pPDev->ctl.ptAbsolutePos.x = iX;
                //
                // 3/13/97 ZhanW
                // set up DestY as well in case it's needed (ex. FE printers).
                // In that case, truncation error (iDiff) is not a concern.
                // This is for backward compatibility with FE Win95 and FE NT4
                // minidrivers.
                //

                //*\\  note:  WriteChannel returns amount moved in
                //  device units which can be converted to master units
                //  by multiplying by      pPDev->ptDeviceFac.x

                pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y;
                iDiff = WriteChannelEx(pPDev,
                                   pCmd,
                                   pPDev->ctl.ptAbsolutePos.x,
                                   pPDev->ptDeviceFac.x);

                if (pPDev->ctl.dwCursorMode & CURSOR_X_UNINITIALIZED)
                    pPDev->ctl.dwCursorMode &= ~CURSOR_X_UNINITIALIZED;
            }
        }
        else   // code assumes relative moves exist if iX is negative
        {
            //
            // Use relative command to send move request
            //

            INT iRelRightValue = 0;

            if( iX < pPDev->ctl.ptCursor.x )      // when is ptCursor initialized?  to (0,0) at DrvStartPage().
                //  what command actually ensured the cursor was set to (0,0)?
                //  absolutely none - its should be part of the StartPage command.
                //  If the printer has no absolute movement command,
                //  the StartPage command should include a command to set
                //  the cursor to position (0,0).  If the cursor position cannot
                //  be set to (0,0), then this code is invalid.
            {
                //
                // Relative move left
                //

                if (pCmd = COMMANDPTR(pDrvInfo,CMD_XMOVERELLEFT))
                {
                    //
                    // Optimize to avoid sending 0-move cmd.
                    //

                    //  note all args for relative moves are positive.

                    if ((pPDev->ctl.ptRelativePos.x =
                         pPDev->ctl.ptCursor.x - iX) < pPDev->ptDeviceFac.x)
                        iDiff = pPDev->ctl.ptRelativePos.x;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                    iDiff = -iDiff;
                }
                else
                {
                    //
                    // No Relative left move cmd, use <CR> to reach start
                    // Will try to use relative right move cmd to send later
                    //  assumption is if no rel left move command exists,
                    //  printing in the negative quadrant is impossible.
                    //  because abs moves are never used even if they
                    //  accept  negative args.

                    WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));

                    if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                        iRelRightValue = iX;  //*\\  what if this value is negative?
                    else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
                    {
                        ASSERT(pPDev->pGlobals->bRotateCoordinate==FALSE);
                        //  assumes printers that support relative right, but not left
                        //  move commands
                        //  do not rotate the cooridinate system.   Kind of strange?
                        //  this is regardless of whether they support abs move.

                        iRelRightValue = iX - pPDev->pf.ptImageOriginM.x;
                    }
                }
            }
            else
            {
                //
                // Relative right move
                // UNIITIALZIED is an invalid position, set to zero
                //

                iRelRightValue = iX - pPDev->ctl.ptCursor.x;
            }

            if( iRelRightValue > 0 )
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVERELRIGHT))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.x = iRelRightValue) <
                        pPDev->ptDeviceFac.x)
                        iDiff = iRelRightValue;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                }
                else
                    iDiff = iRelRightValue;  //*\\  that's it?  no attempt to move cursor?
            }
        }
    }


    //
    // Peform fine move command
    //

    if ( (fFlag & MV_FINE) && iDiff > 0 )
        iDiff = FineXMoveTo( pPDev, iDiff );

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptCursor.x = iX -  iDiff ;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    if (pPDev->fMode & PF_RESELECTFONT_AFTER_XMOVE)
    {
        VResetFont(pPDev);
    }

    return( iDiff);
}

INT
YMoveTo(
    PDEV    *pPDev,
    INT     iYIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the Y position.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iYIn  - Number of units to move in Y direction
    fFlag - Specifies the different Y move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{

    INT   iY, iDiff = 0;
    DWORD dwTestValue;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    COMMAND *pAbsCmd;
    INT iScale;

    //
    // Convert to Master Units if the given units is in Graphics Units
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.x;
    else
        iScale = pPDev->ptGrxScale.y;

    if ( fFlag & MV_GRAPHICS )
    {
        iYIn = (iYIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iY = iYIn;

    //
    // Basically, only adjust if we are doing absolute move
    //
    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iY += pPDev->sf.ptPrintOffsetM.y;

    //
    // Adjust iY to be the absolute position
    //

    if( fFlag & MV_RELATIVE )
        iY += pPDev->ctl.ptCursor.y;

    //
    // Update, only update our current cursor position and return
    // Do nothing if the YMoveTo cmd is called to move to the current position.
    //

    if( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptCursor.y = iY;
        return 0;
    }

    if( pPDev->ctl.ptCursor.y == iY )
        return 0;

    //
    // General assumption: if dwTestValue > dwYMoveThreshold,
    // absolute Y move command will be favored. Also, for iY < 0,
    // use relative command since some printers like old LaserJet have
    // printable area above y=0 accessable only through relative move cmds.
    //

    //
    // BUG_BUG, if we are stripping blanks, we need to check whether
    // it's legal to move in Graphics mode.  If it's not, we have
    // to get out of graphics mode before moving.
    //


    dwTestValue = abs(iY - pPDev->ctl.ptCursor.y);

    if (((pPDev->ctl.dwCursorMode & CURSOR_Y_UNINITIALIZED) ||
        (dwTestValue > pPDev->pGlobals->dwYMoveThreshold &&
        iY > 0)) &&
        (pAbsCmd = COMMANDPTR(pDrvInfo, CMD_YMOVEABSOLUTE)) != NULL)
    {

        //!  if  neg move is the first one, then an absolute move
        //  is issued even though the code explicitly says this is
        //  a Bad thing.
        //  if there are no relative commands and a negative move
        //  is specified, bad things will happen.

        //
        // if the move units are less than the master units then we need to
        // check whether the new position will end up being the same as the
        // original position. If so, no point in sending another command.
        //
        if (!(pPDev->ctl.dwCursorMode & CURSOR_Y_UNINITIALIZED) &&
            (pPDev->ptDeviceFac.y > 1) &&
            ((iY - (iY % pPDev->ptDeviceFac.y)) == pPDev->ctl.ptCursor.y))
        {
            iDiff = iY - pPDev->ctl.ptCursor.y;
        }
        else
        {
            pPDev->ctl.ptAbsolutePos.y = iY;
            pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x;
            iDiff = WriteChannelEx(pPDev,
                               pAbsCmd,
                               pPDev->ctl.ptAbsolutePos.y,
                               pPDev->ptDeviceFac.y);

            if (pPDev->ctl.dwCursorMode & CURSOR_Y_UNINITIALIZED)
                pPDev->ctl.dwCursorMode &= ~CURSOR_Y_UNINITIALIZED;
        }
    }
    else
    {
        //
        // Use Relavite Y-move commands
        //

        //
        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR
        // before each line-spacing command
        //

        //  what does this mean?  that the cursor must be at x=0
        //  before doing a y-move?   or  a <cr> must be sent
        //  before doing a y-move?
        //  if the latter, calling XMoveTo does not ensure the <cr>
        //  is sent.   First, the x pos may already be 0 or
        //  an absolute X move command may be used  as would
        // be the case if the distance moved exceeded the threshold.

        if ( pPDev->fYMove & FYMOVE_SEND_CR_FIRST )
            XMoveTo( pPDev, 0, MV_PHYSICAL );

        //
        //  Use line spacing if that is preferred
        //


        if ( (pPDev->fYMove & FYMOVE_FAVOR_LINEFEEDSPACING) &&
             iY - pPDev->ctl.ptCursor.y > 0  &&
             pPDev->arCmdTable[CMD_SETLINESPACING] != NULL &&
             pPDev->arCmdTable[CMD_LINEFEED] != NULL )
        {
            INT      iLineSpacing;
            DWORD    dwMaxLineSpacing = pPDev->pGlobals->dwMaxLineSpacing;

            while ( dwTestValue )
            {
                iLineSpacing =(INT)(dwTestValue > dwMaxLineSpacing ?
                                        dwMaxLineSpacing : dwTestValue);

                if (pPDev->ctl.lLineSpacing == -1 ||       <== meaningless check.
                    iLineSpacing != pPDev->ctl.lLineSpacing )
                {
                    pPDev->ctl.lLineSpacing = iLineSpacing;
                    WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_SETLINESPACING));
                }

                //
                // Send the LF
                //

                WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_LINEFEED));
                dwTestValue -= (DWORD)iLineSpacing;
            }
        }
        else
        {
            //
            // Use relative command
            //

            PCOMMAND pCmd;

            if ( iY <= pPDev->ctl.ptCursor.y )
            {
                //
                // If there is no RELATIVE UP cmd, do nothing and return
                //

                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELUP))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.y =
                         pPDev->ctl.ptCursor.y - iY) < pPDev->ptDeviceFac.y)
                         iDiff = pPDev->ctl.ptRelativePos.y;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                    iDiff = -iDiff;
                }
                else
                    // Do nothing since we can't simulate it
                    iDiff =  (iY - pPDev->ctl.ptCursor.y );
                //  my interpretation of iDiff is you add iDiff to
                // the printers cursor position to get where
                // you really wanted to be.
            }
            else
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELDOWN))
                {
                    pPDev->ctl.ptRelativePos.y = iY - pPDev->ctl.ptCursor.y;

                    //
                    // optimize to avoid 0-move cmd
                    //
                    if (pPDev->ctl.ptRelativePos.y < pPDev->ptDeviceFac.y)
                        iDiff = pPDev->ctl.ptRelativePos.y;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                }
                else        // can't move at all.
                    iDiff = (iY - pPDev->ctl.ptCursor.y );
            }
        }
    }

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptCursor.y = iY - iDiff;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    return (iDiff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\physical.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    Support the following functions related to sending data to the printer
    and print head movements, cursor control.

        WriteSpoolBuf
        WriteAbortBuf
        FlushSpoolBuf
        WriteChannel
        WriteChannelEx
        XMoveTo
        YMoveTo

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

--*/
#include "unidrv.h"

static  int itoA(  LPSTR , int );
INT IGetNumParameter( BYTE *, INT);
BOOL BUniWritePrinter(
    IN PDEV*  pPDev,
    IN LPVOID pBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcbWritten);

#define  DELTA_X  (pPDev->dwFontWidth/2)
#define  DELTA_Y  (dwMaxLineSpacing /5)


WriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    )
/*++

Routine Description:

    This is an intermediate routine for Unidrv to send characters to
    the printer via the spooler.  All characters must be sent through
    the WriteSpool( ) call.  WriteSpoolBuf is internal so that Unidrv
    can buffer up short command streams before calling WriteSpool.
    This routine also checks for error flags returned from WriteSpool.

Arguments:

    pPDev - Pointer to PDEVICE struct
    pbBuf - Pointer to buffer containing data to be sent
    iCount - Count of number of bytes to send

Return Value:

    The number of bytes sent to the printer

--*/

{
    DWORD dw;

    //
    // Check for aborted output
    //

    if( pPDev->fMode & PF_ABORTED )
        return   0;

    //
    // If the output buffer cannot accomodate the current request,
    // flush the content of the buffer first.
    //

    if( (pPDev->iSpool)   &&  (pPDev->iSpool + iCount > CCHSPOOL ))
    {
        if( !FlushSpoolBuf( pPDev ) )
        {
            WriteAbortBuf(pPDev, pPDev->pbOBuf, pPDev->iSpool, 0) ;
            pPDev->iSpool = 0;
            return  0;   // at least send previously cached stuff.
        }
    }

    //
    // Check whether request is larger than output buffer, if so, skip buffering
    // and write directly to spooler.
    //

    if( iCount >= CCHSPOOL )
    {
        if( !BUniWritePrinter( pPDev, pbBuf, iCount, &dw ) )
        {
            pPDev->iSpool = 0;
            pPDev->fMode |= PF_ABORTED;
            iCount = 0;
        }
    }
    else
    {
        //
        // buffer up the output
        //

        if( pPDev->pbOBuf  == NULL)
                return  0;


        CopyMemory( pPDev->pbOBuf + pPDev->iSpool, pbBuf, iCount );
        pPDev->iSpool += iCount;
    }


    return iCount;
}

VOID  WriteAbortBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount,
    DWORD       dwWait
    )
{
    DWORD   dwCount;
    HMODULE   hInst ;
    typedef   BOOL    (*PFNFLUSHPR)( HANDLE   hPrinter,
          LPVOID   pBuf,
          DWORD    cbBuf,
          LPDWORD pcWritten,
          DWORD    cSleep)  ;
    PFNFLUSHPR     pFlushPrinter ;

    //
    // Call FlushPrinter only if there is no plugin hooking WritePrinter .
    // One of plug-ins hooks WritePrinter, the plug-in need to call FlushPrinter.
    // In that case, UNIDRV should not call FlushPrinter.
    //
    if( pPDev->fMode & PF_ABORTED &&
        !(pPDev->fMode2 & PF2_WRITE_PRINTER_HOOKED))
    {
#ifdef  WINNT_40
        ;   //  Pretend we flushed
#else
        TCHAR   szPath[MAX_PATH+16];

        if (GetSystemDirectory(szPath, MAX_PATH))
        {
            lstrcat(szPath, TEXT("\\winspool.drv"));

            if((hInst = LoadLibrary(szPath))   &&
                (pFlushPrinter = (PFNFLUSHPR)GetProcAddress(hInst, "FlushPrinter")))
            {
                BOOL bRet;
                do 
                {
                    bRet = (*pFlushPrinter)(pPDev->devobj.hPrinter, pbBuf, iCount, &dwCount, dwWait);
                    pbBuf += dwCount;
                    iCount -= dwCount;
                } while (bRet && iCount > 0 && dwCount > 0);
            }
            if(hInst)
                FreeLibrary(hInst);
        }
#endif
    }
}

BOOL
FlushSpoolBuf(
    PDEV    *pPDev
    )
/*++

Routine Description:

    This function flush our internal buffer.

Arguments:

    pPDev - Pointer to PDEVICE struct

Return Value:

    TRUE if successful , otherwise FALSE

--*/
{

    DWORD   dwCount;
    //
    // Check for aborted output
    //

    if( pPDev->fMode & PF_ABORTED )
        return   0;


    //
    // Write the data out
    //

    if( pPDev->iSpool )
    {
        if ( !BUniWritePrinter(pPDev, pPDev->pbOBuf, pPDev->iSpool, &dwCount) )
        {
            pPDev->fMode |= PF_ABORTED;
            return  FALSE;
        }
        pPDev->iSpool = 0;
    }
    return  TRUE;
}


INT
XMoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the X position.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iXIn  - Number of units to move in X direction
    fFlag - Specifies the different X move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{
    int   iX, iFineValue, iDiff = 0;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    int iScale;

    //
    // If the position is given in graphics units, convert to master units
    //
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.y;
    else
        iScale = pPDev->ptGrxScale.x;

    if ( fFlag & MV_GRAPHICS )
    {
        iXIn = (iXIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iX = iXIn;

    //
    // Basically, only adjust if we are doing absolute move
    //

    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iX += pPDev->sf.ptPrintOffsetM.x;

    //
    // If it's a relative move, update iX (iX will be the absolute position)
    // to reflect the current cursor position
    //

    if ( fFlag & MV_RELATIVE )
        iX += pPDev->ctl.ptCursor.x;


    //By definition a negative absolute move relative to Imageable origin
    //is not allowed.   But the MV_FORCE_CR  flag bypasses this check.
    if(!(fFlag & MV_FORCE_CR)  &&  (iX - pPDev->sf.ptPrintOffsetM.x < 0))
        iX = pPDev->sf.ptPrintOffsetM.x ;


    //
    // Update, only update our current cursor position and return
    // Do nothing if the XMoveTo cmd is called to move to the current position.
    //

    if ( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x = iX;
        return 0;
    }

    if( fFlag & MV_SENDXMOVECMD )
        pPDev->ctl.dwMode |= MODE_CURSOR_X_UNINITIALIZED;

    if (!(pPDev->ctl.dwMode & MODE_CURSOR_X_UNINITIALIZED)   &&   pPDev->ctl.ptCursor.x == iX )
        return 0;


    //
    // If iX is zero and pGlobals->cxaftercr does not have
    // CXCR_AT_GRXDATA_ORIGIN set, then we send CR and reset our
    // cursor position to 0, which is the printable x origin
    //

    if (iX == 0 && (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN ||
            pPDev->sf.ptPrintOffsetM.x == 0))
    {
        pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x = 0;
        WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));
        pPDev->ctl.dwMode &= ~MODE_CURSOR_X_UNINITIALIZED;
        return 0;
    }

    //
    // Check whether we any X move cmd, PF_NO_XMOVE_CMD is set if we did
    // not see any relative or absolute x move cmds
    //

    if( pPDev->fMode & PF_NO_XMOVE_CMD)
    {
        //
        // There is no X move command(abs or relative), so we'll have to simulate
        // using blanks or null graphics data (0)
        //

        //
        // We assume that when XMoveto is called, the current font is always
        // the default font IF the printer has no X movement command.
        //

        int     iRelx = iX - pPDev->ctl.ptCursor.x ;
        int     iDefWidth;

        //
        // Convert to Master Units
        //

        //
        // BUG_BUG, Double check that we can use Default Font here when
        // we have a custom TTY driver
        //  seems to work so far.
        //


        if ( iRelx < 0   &&  (!pPDev->bTTY  ||  (DWORD)(-iRelx) > DELTA_X ))
        {
            if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                iRelx = iX;
            else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
            {
                //  printing offset is only available in the callers
                //  cooridinates so if the move is being performed
                //  in different coordinates, the offset will be wrong.
                ASSERT(!pPDev->pOrientation  ||  pPDev->pOrientation->dwRotationAngle == ROTATE_NONE  ||
                        pPDev->pGlobals->bRotateCoordinate == TRUE) ;

                iRelx = iX - pPDev->sf.ptPrintOffsetM.x;
            }

            WriteChannel( pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN ));
        }

        //
        // Simulate X Move, algorithm is that we always send a blank space
        // for every character width, and send graphics null data for
        // the remainder, in the case of TTY we skip the remaining graphics that
        // cannot be sent within a space character width.
        //

        iDefWidth = pPDev->dwFontWidth ;
        if (iDefWidth)
        {

            while(iRelx >= iDefWidth)
            {
                WriteSpoolBuf( pPDev, (LPSTR)" ", 1 );
                iRelx -= iDefWidth;
            }
        }
        else
            TERSE (("XMoveTo: iDefWidth = 0\n"));


        //
        // Send the remaining partial space  via FineXMoveTo.
        //

        if (!pPDev->bTTY)
        {
            iDiff = iRelx;
            fFlag |= MV_FINE;    // Use graphics mode to reach point
        }

    }
    else
    {
        DWORD dwTestValue  = abs(iX - pPDev->ctl.ptCursor.x);
        COMMAND *pCmd;

        //
        // X movement commmands are available,  so use them.
        // We need to decide here whether relative or absolute command
        // are favored

        //
        // General assumption: if dwTestValue > dwXMoveThreshold,
        // absolute command will be favored
        //

        //
        // BUG_BUG, if we are stripping blanks, we need to check whether
        // it's legal to move in Graphics mode.  If it's not, we have
        // to get out of graphics mode before moving.
        // Graphics module is responsible for keeping track
        // of these things, and appearently so far, things work, so
        // this is neither a bug  nor a feature request at this time.
        //

        if (((pPDev->ctl.dwMode & MODE_CURSOR_X_UNINITIALIZED) ||
            ((dwTestValue > pPDev->pGlobals->dwXMoveThreshold ) &&
             iX >= 0) ||
            !COMMANDPTR(pDrvInfo, CMD_XMOVERELRIGHT)) &&
            (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVEABSOLUTE)) != NULL)
        {
            //
            // if the move units are less than the master units then we need to
            // check whether the new position will end up being the same as the
            // original position. If so, no point in sending another command.
            //
            if (!(pPDev->ctl.dwMode & MODE_CURSOR_X_UNINITIALIZED) &&
                (pPDev->ptDeviceFac.x > 1) &&
                ((iX - (iX % pPDev->ptDeviceFac.x)) == pPDev->ctl.ptCursor.x))
            {
                iDiff = iX - pPDev->ctl.ptCursor.x;
            }
            else
            {
                // check whether the no absolute move left flag is set. If set we need
                // to send a CR before doing the absolute move.
                //
                if (iX < pPDev->ctl.ptCursor.x && pPDev->pGlobals->bAbsXMovesRightOnly)
                {
                    WriteChannel( pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN ));
                }
                pPDev->ctl.ptAbsolutePos.x = iX;
                //
                // 3/13/97 ZhanW
                // set up DestY as well in case it's needed (ex. FE printers).
                // In that case, truncation error (iDiff) is not a concern.
                // This is for backward compatibility with FE Win95 and FE NT4
                // minidrivers.
                //
                pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y;
                iDiff = WriteChannelEx(pPDev,
                                   pCmd,
                                   pPDev->ctl.ptAbsolutePos.x,
                                   pPDev->ptDeviceFac.x);

            }
        }
        else
        {
            //
            // Use relative command to send move request
            //

            INT iRelRightValue = 0;

            if( iX < pPDev->ctl.ptCursor.x )
            {
                //
                // Relative move left
                //

                if (pCmd = COMMANDPTR(pDrvInfo,CMD_XMOVERELLEFT))
                {
                    //
                    // Optimize to avoid sending 0-move cmd.
                    //
                    if ((pPDev->ctl.ptRelativePos.x =
                         pPDev->ctl.ptCursor.x - iX) < pPDev->ptDeviceFac.x)
                        iDiff = pPDev->ctl.ptRelativePos.x;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                    iDiff = -iDiff;
                }
                else
                {
                    //
                    // No Relative left move cmd, use <CR> to reach start
                    // Will try to use relative right move cmd to send later
                    //

                    WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));

                    if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                        iRelRightValue = iX;
                    else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
                    {
                        //  moveto code cannot handle case where printer cannot
                        //  rotate its coordinate system, and we are in landscape mode
                        //  and we are using relative move commands.
                        ASSERT(!pPDev->pOrientation  ||  pPDev->pOrientation->dwRotationAngle == ROTATE_NONE  ||
                                pPDev->pGlobals->bRotateCoordinate == TRUE) ;

                        iRelRightValue = iX - pPDev->sf.ptPrintOffsetM.x;
                    }
                }
            }
            else
            {
                //
                // Relative right move
                // UNIITIALZIED is an invalid position, set to zero
                //

                iRelRightValue = iX - pPDev->ctl.ptCursor.x;
            }

            if( iRelRightValue > 0 )
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVERELRIGHT))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.x = iRelRightValue) <
                        pPDev->ptDeviceFac.x)
                        iDiff = iRelRightValue;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                }
                else
                    iDiff = iRelRightValue;
            }
        }
    }


    //
    // Peform fine move command
    //

    if ( (fFlag & MV_FINE) && iDiff > 0 )
        iDiff = FineXMoveTo( pPDev, iDiff );

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x = iX -  iDiff ;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    if (pPDev->fMode & PF_RESELECTFONT_AFTER_XMOVE)
    {
        VResetFont(pPDev);
    }

    pPDev->ctl.dwMode &= ~MODE_CURSOR_X_UNINITIALIZED;
    return( iDiff);
}

INT
YMoveTo(
    PDEV    *pPDev,
    INT     iYIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the Y position.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iYIn  - Number of units to move in Y direction
    fFlag - Specifies the different Y move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{

    INT   iY, iDiff = 0;
    DWORD dwTestValue;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    COMMAND *pAbsCmd;
    INT iScale;

    //
    // Convert to Master Units if the given units is in Graphics Units
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.x;
    else
        iScale = pPDev->ptGrxScale.y;

    if ( fFlag & MV_GRAPHICS )
    {
        iYIn = (iYIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iY = iYIn;

    //
    // Basically, only adjust if we are doing absolute move
    //
    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iY += pPDev->sf.ptPrintOffsetM.y;

    //
    // Adjust iY to be the absolute position
    //

    if( fFlag & MV_RELATIVE )
        iY += pPDev->ctl.ptCursor.y;

    //
    // Update, only update our current cursor position and return
    // Do nothing if the YMoveTo cmd is called to move to the current position.
    //

    if( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y = iY;
        return 0;
    }


    if( fFlag & MV_SENDYMOVECMD )
        pPDev->ctl.dwMode |= MODE_CURSOR_Y_UNINITIALIZED;

    if(!(pPDev->ctl.dwMode  & MODE_CURSOR_Y_UNINITIALIZED)   &&  pPDev->ctl.ptCursor.y == iY )
        return 0;

    //
    // General assumption: if dwTestValue > dwYMoveThreshold,
    // absolute Y move command will be favored. Also, for iY < 0,
    // use relative command since some printers like old LaserJet have
    // printable area above y=0 accessable only through relative move cmds.
    //

    //
    // BUG_BUG, if we are stripping blanks, we need to check whether
    // it's legal to move in Graphics mode.  If it's not, we have
    // to get out of graphics mode before moving.
    // Graphics module is responsible for keeping track
    // of these things, and appearently so far, things work, so
    // this is neither a bug  nor a feature request at this time.
    //


    dwTestValue = abs(iY - pPDev->ctl.ptCursor.y);

    if (((pPDev->ctl.dwMode & MODE_CURSOR_Y_UNINITIALIZED) ||
        (dwTestValue > pPDev->pGlobals->dwYMoveThreshold &&
        iY >= 0)) &&
        (pAbsCmd = COMMANDPTR(pDrvInfo, CMD_YMOVEABSOLUTE)) != NULL)
    {
        //
        // if the move units are less than the master units then we need to
        // check whether the new position will end up being the same as the
        // original position. If so, no point in sending another command.
        //
        if (!(pPDev->ctl.dwMode & MODE_CURSOR_Y_UNINITIALIZED) &&
            (pPDev->ptDeviceFac.y > 1) &&
            ((iY - (iY % pPDev->ptDeviceFac.y)) == pPDev->ctl.ptCursor.y))
        {
            iDiff = iY - pPDev->ctl.ptCursor.y;
        }
        else
        {
            pPDev->ctl.ptAbsolutePos.y = iY;
            pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x;
            iDiff = WriteChannelEx(pPDev,
                               pAbsCmd,
                               pPDev->ctl.ptAbsolutePos.y,
                               pPDev->ptDeviceFac.y);
        }
    }
    else
    {
        DWORD dwSendCRFlags = 0;
        //
        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR 
        // before each line-spacing command
        //
        if (pPDev->fYMove & FYMOVE_SEND_CR_FIRST)
        {
            if ((pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN))
                dwSendCRFlags = MV_PHYSICAL | MV_FORCE_CR;
            else
                dwSendCRFlags = MV_PHYSICAL;
                //  in this case CR takes you to Printable origin so
                //  MV_PHYSICAL  flag should not appear.
                //  This is a bug, but we won't fix it till something
                //  breaks.  Too risky.  !!!! Bug_Bug !!!!
        }
        
        //
        // Use Relative Y-move commands
        //


        //
        //  Use line spacing if that is preferred
        //


        if ( ((pPDev->bTTY) ||
              (pPDev->fYMove & FYMOVE_FAVOR_LINEFEEDSPACING &&
               pPDev->arCmdTable[CMD_SETLINESPACING] != NULL) ) &&
             (iY - pPDev->ctl.ptCursor.y > 0)                   &&
             (pPDev->arCmdTable[CMD_LINEFEED] != NULL)
           )
        {
            INT      iLineSpacing;
            DWORD    dwMaxLineSpacing = pPDev->pGlobals->dwMaxLineSpacing;

            if (pPDev->bTTY  &&  (INT)dwTestValue > 0)
            {      //  [Peterwo] here's a  hack I tried that ensures that any request for a Y-move results
                   //  in at least one CR being sent. It  doesn't work, because bRealrender
                   //  code sends Y move commands of one scanline  each,  resulting in
                   //  one line feed per scanline.
                   //                if( (INT)dwTestValue < dwMaxLineSpacing)
                   //                     dwTestValue = dwMaxLineSpacing;
                   //
                   //  if you don't send anything, leave diff undisturbed
                   //  so the error can accumulate otherwise many small
                   //  cursor movements will not accumulate to cause one
                   //  occasional actual movement.

                    //
                    // For TTY driver we round up the input value one fifth of
                    // line spacing. This is required for not sending too many
                    // line feeds for small Y movements.
                    //
                    DWORD   dwTmpValue;

                     dwTmpValue = ((dwTestValue + DELTA_Y) / dwMaxLineSpacing) * dwMaxLineSpacing;
                     if (dwTmpValue)
                     {
                         dwTestValue = dwTmpValue ;
                     }
            }
            while ( (INT)dwTestValue > 0)
            {
                if (pPDev->bTTY)
                {
                    iLineSpacing = dwMaxLineSpacing;
                    if (dwTestValue < (DWORD)iLineSpacing)
                    {
                        iDiff = dwTestValue;
                        break;
                    }
                    if ( dwSendCRFlags )
                    {
                        XMoveTo( pPDev, 0, dwSendCRFlags );
                        dwSendCRFlags = 0;
                    }
                }
                else
                {
                    iLineSpacing =(INT)(dwTestValue > dwMaxLineSpacing ?
                                        dwMaxLineSpacing : dwTestValue);
                    //
                    // new code to handle positioning error when linespacingmoveunit doesn't
                    // equal master units
                    if (pPDev->pGlobals->dwLineSpacingMoveUnit > 0)
                    {
                        DWORD dwScale = pPDev->pGlobals->ptMasterUnits.y / pPDev->pGlobals->dwLineSpacingMoveUnit;
                        
                        // optimize to avoid 0-move cmd when move unit is less than master units
                        //
                        if (dwTestValue < dwScale)
                        {
                            iDiff = dwTestValue;
                            break;
                        }
                        // Modify line spacing to be multiple of moveunit
                        //
                        iLineSpacing -= (iLineSpacing % dwScale);
                    }
                    if ( dwSendCRFlags )
                    {
                        XMoveTo( pPDev, 0, dwSendCRFlags );
                        dwSendCRFlags = 0;
                    }
                        
                    if (pPDev->ctl.lLineSpacing == -1 ||
                            iLineSpacing != pPDev->ctl.lLineSpacing )
                    {
                        pPDev->ctl.lLineSpacing = iLineSpacing;
                        WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_SETLINESPACING));
                    }
                }

                //
                // Send the LF
                //

                WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_LINEFEED));
                dwTestValue -= (DWORD)iLineSpacing;
            }
        }
        else
        {
            //
            // Use relative command
            //

            PCOMMAND pCmd;

            if ( iY <= pPDev->ctl.ptCursor.y )
            {
                //
                // If there is no RELATIVE UP cmd, do nothing and return
                //

                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELUP))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.y =
                         pPDev->ctl.ptCursor.y - iY) < pPDev->ptDeviceFac.y)
                         iDiff = pPDev->ctl.ptRelativePos.y;
                    else
                    {
                        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR
                        // before each line-spacing command
                        //
                        if ( dwSendCRFlags )
                            XMoveTo( pPDev, 0, dwSendCRFlags );

                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                    }
                    iDiff = -iDiff;
                }
                else
                    // Do nothing since we can't simulate it
                    iDiff =  (iY - pPDev->ctl.ptCursor.y );

            }
            else
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELDOWN))
                {
                    pPDev->ctl.ptRelativePos.y = iY - pPDev->ctl.ptCursor.y;

                    //
                    // optimize to avoid 0-move cmd
                    //
                    if (pPDev->ctl.ptRelativePos.y < pPDev->ptDeviceFac.y)
                        iDiff = pPDev->ctl.ptRelativePos.y;
                    else 
                    {
                        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR
                        // before each line-spacing command
                        //
                        if ( dwSendCRFlags )
                            XMoveTo( pPDev, 0, dwSendCRFlags );

                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                    }
                }
                else
                    iDiff = (iY - pPDev->ctl.ptCursor.y );
            }
        }
    }

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y = iY - iDiff;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    pPDev->ctl.dwMode &= ~MODE_CURSOR_Y_UNINITIALIZED;
    return (iDiff);
}


INT
FineXMoveTo(
    PDEV    *pPDev,
    INT     iX
    )
/*++

Routine Description:

    This function is called to make microspace justification.
    It is only called when the normal x movement commands cannot
    move the cursor to the asking position.  For example,
    resolution is 180 DPI, x move command is 1/120".  To move
    by 4 pixels in 180 DPI, CM_XM_RIGHT is sent with parameter = 2
    (1/120") then one graphics pixel is sent (1/180).
    4/180 = 2/120 + 1/180.
    'iX' is always in MasterUnits.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iX    - Amount to move in Master Units

Return Value:

    The difference between the requested move and actual move

--*/

{
    INT iDiff;
    INT iScale;

    //
    // Don't do micro justification in graphics mode for device that
    // set x position at leftmost position on page after printing a
    // block of data OR Y position auto move to next Y row after priting
    // block of data.
    //

    if (pPDev->pGlobals->cxafterblock == CXSBD_AT_CURSOR_X_ORIGIN ||
        pPDev->pGlobals->cxafterblock == CXSBD_AT_GRXDATA_ORIGIN  ||
        pPDev->pGlobals->cyafterblock == CYSBD_AUTO_INCREMENT)
        return iX;

    //
    // Convert Master units to Graphic units
    //
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.y;
    else
        iScale = pPDev->ptGrxScale.x;

    iDiff = iX % iScale;
    iX /= iScale;

    if (iX > 0 )
    {
        INT iMaxBuf, iTmp;
        BYTE    rgch[ CCHMAXBUF ];

        //
        // Send the command, to send one block of data to the printer.
        // Init the state variable first.
        //

        //
        // BUG_BUG, how does this code work??
        // What should we send for CMD_SENDBLOCKDATA?
        //

        //
        // BUG_BUG, May be we should send BEGINGRAPHICS and ENDGRAPHICS later
        //

        pPDev->dwNumOfDataBytes = iX;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SENDBLOCKDATA));

        iMaxBuf = CCHMAXBUF - (CCHMAXBUF % pPDev->ctl.sBytesPerPinPass);
        iX *= pPDev->ctl.sBytesPerPinPass;

        //
        // Send out null graphics data, zeroes.
        //

        ZeroMemory( rgch, iX > CCHMAXBUF ? iMaxBuf : iX );

        for ( ; iX > 0; iX -= iTmp)
        {
            iTmp = iX > iMaxBuf ? iMaxBuf : iX;

            //
            // BUG_BUG, OEMCustomization code might want to hook
            // out this graphics move.    Make this a bug when
            //  someone asks for it.
            //
            WriteSpoolBuf(pPDev, rgch, iTmp);

        }
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_ENDBLOCKDATA));

        return iDiff;
    }

    return iDiff;
}

INT
WriteChannel(
    PDEV    *pPDev,
    COMMAND *pCmd
    )
/*++

Routine Description:

    This routine performs the following tasks:
    - Parse through the cmd invocation str and build a CMDPARAM struct
      for every %dddd encountered.
    - Call IProcessTokenStream to calculate the arToken value of the parameter.
    - Check for lMin and lMax in PARAMETER struct and send the command
      multiple times, if necessary(MaxRepeat was seen).
    - Call SendCmd to send the command to the printer.

Arguments:

    pPDev - Pointer to PDEVICE struct
    pCmd  - Pointer to command struct to send, used for sending sequence section cmds
            and predefined Unidrv commands

Return Value:

    The last value send to the printer

--*/
#define MAX_NUM_PARAMS 16
{
    BYTE    *pInvocationStr;
    CMDPARAM *pCmdParam, *pCmdParamHead;
    INT     i, iParamCount, iStrCount, iLastValue = 0, iRet;
    PARAMETER *pParameter;
    BOOL    bMaxRepeat = FALSE;
    CMDPARAM arCmdParam[MAX_NUM_PARAMS];

    if (pCmd == NULL)
    {
        TERSE(("WriteChannel - Command PTR is NULL.\n"))
        return (NOOCD);
    }
    //
    // first check if this command requires callback
    //
    if (pCmd->dwCmdCallbackID != NO_CALLBACK_ID)
    {
        PLISTNODE   pListNode;
        DWORD       dwCount = 0;    // count of parameters used
        DWORD       adwParams[MAX_NUM_PARAMS];  // max 16 params for each callback

        if (!pPDev->pfnOemCmdCallback)
            return (NOOCD);
        //
        // check if this callback uses any parameters
        //
        pListNode = LISTNODEPTR(pPDev->pDriverInfo, pCmd->dwStandardVarsList);
        while (pListNode)
        {
            if (dwCount >= MAX_NUM_PARAMS)
            {
                ASSERTMSG(FALSE,("Command callback exceeds # of parameters limit.\n"));
                return (NOOCD);
            }

            adwParams[dwCount++] = *(pPDev->arStdPtrs[pListNode->dwData]);

            if (pListNode->dwNextItem == END_OF_LIST)
                break;
            else
                pListNode = LISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
        }

        FIX_DEVOBJ(pPDev, EP_OEMCommandCallback);

        iRet = 0;

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                    HRESULT  hr ;
                    hr = HComCommandCallback((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                (PDEVOBJ)pPDev, pCmd->dwCmdCallbackID, dwCount, adwParams, &iRet);
                    if(SUCCEEDED(hr))
                        ;  //  cool !
            }
            else
            {
                iRet = (pPDev->pfnOemCmdCallback)((PDEVOBJ)pPDev, pCmd->dwCmdCallbackID,
                                        dwCount, adwParams);
            }
        }

        return iRet ;
    }

    //
    // no cmd callback. Process the string.
    //
    pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pCmd->strInvocation.loOffset);
    iStrCount = pCmd->strInvocation.dwCount;

    pCmdParam = pCmdParamHead = arCmdParam;
    iParamCount = 0;
    //
    // Process the parameter from the invocation str.
    //

    for (i= 0; i < iStrCount; i++)
    {
        if (pInvocationStr[i] == '%')
        {
            if (pInvocationStr[i + 1] == '%')
            {
                //
                // Do nothing, just skip %%
                //

                i += 1;
            }
            else
            {
                //
                // Build a list of CMDPARAM, one for each %dddd encounter
                // in cmd invocation string.
                //

                BYTE  *pCurrent = pInvocationStr + i + 1;

                //
                // Increment the parameter count
                //

                iParamCount++;
                
                if (iParamCount > MAX_NUM_PARAMS)
                {
                    ASSERT (iParamCount <= MAX_NUM_PARAMS);
                    return (NOOCD);
                }

                //
                // Copy the 4 character that represent to parameter index from cmd str
                // pInvocationStr + i points to %, pInvocationStr + i + 1 points
                // to first digit of param index
                //

                pParameter = PGetParameter(pPDev, pCurrent);

                //
                // Initialize CMDPARAM for SendCmd
                //

                //
                // IProcessTokenStream calculate the integer value parameter
                // from the token stream in PARAMETER, bMaxRepeat is set
                // to TRUE if OP_MAX_REPEAT operator was encountered.
                //

                pCmdParam->iValue = IProcessTokenStream(pPDev,
                                                        &pParameter->arTokens,
                                                        &bMaxRepeat);

                //
                // Save the last value calculated (will only be used by XMoveTo and YMoveTo)
                // which assumes there is only one paramter per move command
                //

                iLastValue = pCmdParam->iValue;

                pCmdParam->dwFormat = pParameter->dwFormat;
                pCmdParam->dwDigits = pParameter->dwDigits;
                pCmdParam->dwFlags  = pParameter->dwFlags;

                //
                // Check for dwFlags PARAM_FLAG_MIN_USED and PARAM_FLAG_MAX_USED
                //

                if (pCmdParam->dwFlags & PARAM_FLAG_MIN_USED &&
                    pCmdParam->iValue < pParameter->lMin)
                {
                    pCmdParam->iValue = pParameter->lMin;
                }

                if (pCmdParam->dwFlags & PARAM_FLAG_MAX_USED &&
                    !bMaxRepeat &&
                    pCmdParam->iValue > pParameter->lMax)
                {
                    pCmdParam->iValue = pParameter->lMax;

                }

                //
                // Move to next paramter
                //
                pCmdParam++;
            }
        }
    }

    //
    // We are here means have a list of CMD parameter, pointed to by
    // pCmdParamHead, one for each
    // %dddd encountered, in the order they were encountered in invocation string

    //
    // MAJOR ASSUMPTION, GPD specification specifies that
    // only ONE parameter is valid for commands that use OP_MAX_REPEAT operator
    // So assume only one here (pCmdParamHead and pParameter are valid).
    //

    if (bMaxRepeat && pCmdParamHead->dwFlags & PARAM_FLAG_MAX_USED &&
                pCmdParamHead->iValue > pParameter->lMax)
    {
        INT iRemainder, iRepeat;

        ASSERT(iParamCount == 1);

        iRemainder = pCmdParamHead->iValue % pParameter->lMax;
        iRepeat = pCmdParamHead->iValue / pParameter->lMax;

        while (iRepeat--)
        {
            pCmdParamHead->iValue = pParameter->lMax;
            SendCmd(pPDev, pCmd, pCmdParamHead);
        }

        //
        // Send remainder
        //
        if (iRemainder > 0)
        {
            pCmdParamHead->iValue = iRemainder;
            SendCmd(pPDev, pCmd, pCmdParamHead);
        }
    }
    else
    {
        //
        // Send the command to the printer
        // SendCmd will process the command and format the parameters
        // in the order encounter in the invocation string
        //

        SendCmd(pPDev, pCmd, pCmdParamHead);
    }

    return (iLastValue);
}

INT
WriteChannelEx(
    PDEV    *pPDev,
    COMMAND *pCmd,
    INT     iRequestedValue,
    INT     iDeviceScaleFac
    )
/*++

Routine Description:

    This routine performs the following tasks:
    - Call WriteChannel to write the command and get the
      value of the last paramter calculated for the cmd.
    - Use device factor to convert device units returned from WriteChannel to
      master units
    - Take the difference between requested and actual value

Arguments:

    pPDev - Pointer to PDEVICE struct
    pCmd  - Pointer to command struct to send, used for sending sequence section cmds
            and predefined Unidrv commands
    iRequestedValue - Value of requested move command in Master units
    iDeviceScaleFac - Scale factor to convert Device units to Master units

Return Value:

    The difference between actual value and requested value in Master units

Note:

    This function is only called only by XMoveTo and YMoveTo and assumes
    that all move commands have only one parameter.

--*/

{
    INT iActualValue;

    //
    // Get the device unit returned from WriteChannel and convert it
    // to Master units based on the scale factor passed in
    // Scale = Master/Device.
    //

    iActualValue = WriteChannel(pPDev, pCmd);
    iActualValue *= iDeviceScaleFac;

    return (iRequestedValue - iActualValue);

}

PPARAMETER
PGetParameter(
    PDEV    *pPDev,
    BYTE    *pInvocationStr
    )
/*++

Routine Description:

    This routine get the parameter index from pInvocationStr passed in and
    return the PARAMETER struct associated with the index

Arguments:

    pPDev   - Pointer to PDEVICE struct
    pInvocationStr  - Pointer Invocation str containing the index

Return Value:

    Pointer to PARAMETER struct associated with the index specified in
    the invocation string.

Note:

    Parameter index is the 4 bytes pointed to by pInvocationStr

--*/
{

    BYTE  arTemp[5];
    INT   iParamIndex;
    PARAMETER   *pParameter;

    //
    // Copy the 4 character that represent to parameter index from cmd str
    // pInvocationStr
    //

    strncpy(arTemp, pInvocationStr, 4);
    arTemp[4] = '\0';
    iParamIndex = atoi(arTemp);
    pParameter = PARAMETERPTR(pPDev->pDriverInfo, iParamIndex);

    ASSERT(pParameter != NULL);

    return (pParameter);
}

VOID
SendCmd(
    PDEV    *pPDev,
    COMMAND *pCmd,
    CMDPARAM *pParam
    )
/*++

Routine Description:

    This routine is called by WriteChannel to write one command to the
    printer via. WriteSpoolBuf.  WriteChannel passes a pointer to an array
    of CMDPARAM.  Each CMDPARAM describes the parameter for each %dddd
    encounter in cmd invocation string (the CMDPARAM is sorted in the order
    encountered).

Arguments:

    pPDev   - Pointer to PDEVICE struct
    pCmd    - Pointer to COMMAND struct
    pParam  - Pointer to and array CMDPARAM struct, containing everything needed to format
              the parameter

Return Value:

    None

--*/
{
    INT     iInput, iOutput;            // Used to index through input and output buffers
    BYTE    arOutputCmd[CCHMAXBUF];     // Output buffer to send to printer
    PBYTE   pInputCmd;                  // Pointer to Cmd invocation str.

    //
    // Get the command invocation string
    //

    pInputCmd = CMDOFFSET_TO_PTR(pPDev, pCmd->strInvocation.loOffset);
    iOutput = 0;

    //
    // Go through all the bytes in the invocation string and transfer them
    // to the output buffer.  Replace %dddd with format value calculated
    // and %% with %.
    //

    for (iInput = 0; iInput < (INT)pCmd->strInvocation.dwCount; iInput++)
    {
        if (pInputCmd[iInput] == '%' )
        {

            if (pInputCmd[iInput + 1] == '%')
            {
                //
                // %% equals '%', skip over marker %%
                //

                arOutputCmd[iOutput++] = '%';
                iInput += 1;

            }
            else
            {
                INT     iValue;
                DWORD   dwFlags, dwDigits, dwFormat;

                //
                // Skip over the marker % and dddd for %dddd found in invocation str.
                // Skip 4 bytes (%dddd)
                //

                iInput += 4;

                dwDigits = pParam->dwDigits;
                dwFlags =  pParam->dwFlags;
                dwFormat = pParam->dwFormat;
                iValue = pParam->iValue;
                pParam++;

                //
                // Format the parameter according the the dwFormat specified in PARAMETER struct
                //

                switch (dwFormat)
                {

                //
                // case 'd':  parameter as decimal number
                // case 'D':  same as case 'd' with + sign if value > 0
                // case 'c':  parameter as a single character
                // case 'C':  parameter as character plus '0'
                // case 'f':  parameter as decinal number with decimal point inserted
                //            before the second digit from the right.
                // case 'l':  parameter as word LSB first
                // case 'm':  parameter as word MSB first
                // case 'q':  parameter as Qume method, 1/48" movements
                // case 'g':  parameter as 2 *abs(param) + is_negative(param)
                // case 'n':  Canon integer encoding
                // case 'v':  NEC VFU encoding
                // case '%':  print a %

                    case 'D':
                        if (iValue > 0)
                            arOutputCmd[iOutput++] = '+';
                        //
                        // Fall through
                        //

                    case 'd':
                        if (dwDigits > 0 && dwFlags & PARAM_FLAG_FIELDWIDTH_USED)
                        {
                            //
                            // Temp call to get the number of digits for the iValue
                            //

                            int iParamDigit = itoA(arOutputCmd + iOutput, iValue);

                            for ( ; iParamDigit < (INT)dwDigits; iParamDigit++)
                            {
                                //
                                // Zero pads
                                //
                                arOutputCmd[iOutput++] = '0';
                            }
                        }
                        iOutput += itoA( arOutputCmd + iOutput, iValue);
                        break;

                    case 'C':
                        iValue += '0';

                        //
                        // Fall through
                        //

                    case 'c':
                        arOutputCmd[iOutput++] = (BYTE)iValue;
                        break;

                    case 'f':
                    {
                        int x, y, i;
                        BYTE arTemp[CCHMAXBUF];
                        LPSTR  pCurrent = arOutputCmd + iOutput;

                        x = iValue /100;
                        y = iValue % 100;

                        iOutput += itoA(pCurrent, x);
                        strcat(pCurrent, ".");
                        i = itoA(arTemp, y);

                        //
                        // Take care of the case where the mod yields 1 digit, pad a zero
                        //

                        if (i < 2)
                            strcat(pCurrent, "0");

                        strcat(pCurrent, arTemp);

                        //
                        // Increment iOutput to include the 2 digits after the
                        // decimal and the "."
                        //

                        iOutput += 3;
                    }
                        break;

                    case 'l':
                        arOutputCmd[iOutput++] = (BYTE)iValue;
                        arOutputCmd[iOutput++] = (BYTE)(iValue >> 8);
                        break;

                    case 'm':
                        arOutputCmd[iOutput++] = (BYTE)(iValue >> 8);
                        arOutputCmd[iOutput++] = (BYTE)iValue;
                        break;


                    case 'q':
                        arOutputCmd[ iOutput++ ] = (BYTE)(((iValue >> 8) & 0xf) + '@');
                        arOutputCmd[ iOutput++ ] = (BYTE)(((iValue >> 4) & 0xf) + '@');
                        arOutputCmd[ iOutput++ ] = (BYTE)((iValue & 0xf) + '@');
                        break;

                    case 'g':
                    {
                        if (iValue >= 0)
                            iValue = iValue << 1;
                        else
                            iValue = ((-iValue) << 1) + 1;

                        while (iValue >= 64)
                        {
                            arOutputCmd[iOutput++] = (char)((iValue & 0x003f) + 63);
                            iValue >>= 6;
                        }
                        arOutputCmd[iOutput++] = (char)(iValue + 191);

                    }
                        break;

                    case 'n':
                    {
                        WORD absParam = (WORD)abs(iValue);
                        WORD absTmp;

                        if (absParam <= 15)
                        {
                            arOutputCmd[iOutput++] = 0x20
                                        | ((iValue >= 0)? 0x10:0)
                                        | (BYTE)absParam;
                        }
                        else if (absParam <= 1023)
                        {
                            arOutputCmd[iOutput++] = 0x40
                                        | (BYTE)(absParam/16);
                            arOutputCmd[iOutput++] = 0x20
                                        | ((iValue >= 0)? 0x10:0)
                                        | (BYTE)(absParam % 16);
                        }
                        else
                        {
                            arOutputCmd[iOutput++] = 0x40
                                        | (BYTE)(absParam / 1024);
                            absTmp        = absParam % 1024;
                            arOutputCmd[iOutput++] = 0x40
                                        | (BYTE)(absTmp / 16);
                            arOutputCmd[iOutput++] = 0x20
                                        | ((iValue >= 0)? 0x10:0)
                                        | (BYTE)(absTmp % 16);
                        }
                    }
                        break;

                    case 'v':
                        //
                        // NEC VFU(Vertical Format Unit)
                        //
                        // VFU is a command to specify a paper size
                        // (the length of form feed for the NEC 20PL dotmatrix
                        // printer.
                        //
                        // On NEC dotmatrix printer, 1 line is 1/6 inch.
                        // If you want to specify N line paper size,
                        // you need to send GS, N+1 Data and RS.
                        //
                        //  GS (0x1d)
                        //  TOF Data (0x41, 0x00)
                        //      Data (0x40, 0x00)
                        //      Data (0x40, 0x00)
                        //      Data (0x40, 0x00)
                        //      ..
                        //      ..
                        //      Data (0x40, 0x00)
                        //  TOF Data (0x41, 0x00)
                        //  RS (0x1e)
                        //
                        arOutputCmd[iOutput++] = 0x1D;
                        arOutputCmd[iOutput++] = 0x41;
                        arOutputCmd[iOutput++] = 0x00;
                        while(--iValue > 0)
                        {
                            if( iOutput >= CCHMAXBUF - 5)
                            {
                                WriteSpoolBuf( pPDev, arOutputCmd, iOutput  );
                                iOutput = 0;
                            }

                            arOutputCmd[iOutput++] = 0x40;
                            arOutputCmd[iOutput++] = 0x00;
                        }
                        arOutputCmd[iOutput++] = 0x41;
                        arOutputCmd[iOutput++] = 0x00;
                        arOutputCmd[iOutput++] = 0x1E;
                        break;

                    default:
                        break;

                }
            }
        }
        else
        {
            //
            // Copy the input to output and increment the output count
            //

            arOutputCmd[iOutput++] = pInputCmd[iInput];

        }

        //
        // Write output cmd buffer out to spool buffer in the case
        // where it full or nearly full (2/3 full)
        //

        if( iOutput >= (2 * sizeof( arOutputCmd )) / 3  )
        {
            WriteSpoolBuf( pPDev, arOutputCmd, iOutput  );
            iOutput = 0;
        }
    }

    //
    // Write the data to spool buffer
    //

    if ( iOutput > 0  )
        WriteSpoolBuf( pPDev, arOutputCmd, iOutput );


    return;
}

INT
IProcessTokenStream(
    PDEV            *pPDev,
    ARRAYREF        *pToken ,
    PBOOL           pbMaxRepeat
    )
/*++

Routine Description:

    This function process a given token stream and calculate the value
    for the command parameter.

Arguments:

    pPDev   - Pointer to PDEVICE
    pToken  - Pointer to an array of TOKENSTREAM representing the operands
              and operators for RPN calc.  pToken->dwCount is the number of
              TOKENSTREAM in the array.  pToken->loOffset is the index
              to the first TOKENSTREAM in the array.
    pbMaxRepeat - Indicates a max repeat operator was seen in token stream

Return Value:

    The calculated value, always an INT and set pbMaxRepeat TRUE if
    the OP_MAX_REPEAT operator was seen.

--*/

{
    INT     iRet = 0, sp = 0;
    INT     arStack[MAX_STACK_SIZE];
    DWORD   dwCount = pToken->dwCount;
    TOKENSTREAM * ptstrToken = TOKENSTREAMPTR(pPDev->pDriverInfo, pToken->loOffset);


    *pbMaxRepeat = FALSE;

    while (dwCount--)
    {
        switch(ptstrToken->eType)
        {
            case OP_INTEGER:
                if (sp >= MAX_STACK_SIZE)
                    goto ErrorExit;

                arStack[sp++] = (INT)ptstrToken->dwValue;
                break;

            case OP_VARI_INDEX:
                // dwValue is the index to standard variable list
                if (sp >= MAX_STACK_SIZE)
                    goto ErrorExit;

                arStack[sp++] = (INT)*(pPDev->arStdPtrs[ptstrToken->dwValue]);
                break;

            case OP_MIN:
                if (--sp <= 0)
                    goto ErrorExit;

                if (arStack[sp-1] > arStack[sp])
                    arStack[sp-1] = arStack[sp];
                break;

            case OP_MAX:
                if (--sp <= 0)
                    goto ErrorExit;

                if (arStack[sp-1] < arStack[sp])
                    arStack[sp-1] = arStack[sp];
                break;

            case OP_ADD:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] += arStack[sp];
                break;

            case OP_SUB:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] -= arStack[sp];
                break;

            case OP_MULT:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] *= arStack[sp];
                break;

            case OP_DIV:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] /= arStack[sp];
                break;

            case OP_MOD:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] %= arStack[sp];
                break;

            case OP_MAX_REPEAT:
                //
                // If pbMaxRepeat is TRUE, can only send the parameters in
                // increment of lMax repeat value or smaller,  set in Parameter list until
                //

                *pbMaxRepeat = TRUE;
                break;

            case OP_HALT:
                if (sp == 0)
                    goto ErrorExit;

                iRet = arStack[--sp];
                break;

            default:
                VERBOSE (("IProcessTokenStream - unknown command!"));
                break;
        }
        ptstrToken++;
    }

    return (iRet);

ErrorExit:
    ERR(("IProcessTokenStream, invalid stack pointer"));
    return 0;
}

static  int
itoA( LPSTR buf, INT n )
{
    int     fNeg;
    int     i, j;

    if( fNeg = (n < 0) )
        n = -n;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    if( fNeg )
        buf[i++] = '-';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}

BOOL
BUniWritePrinter(
    IN PDEV*  pPDev,
    IN LPVOID pBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcbWritten)
{
    DWORD dwCount;
    BOOL bReturn = FALSE;

    //
    // Is there any plug-in that hooks WritePrinter?
    // If there is, the plug-in need to take care of all output.
    // Call plug-in's WritePrinter method.
    //
    if(pPDev->pOemEntry && pPDev->fMode2 & PF2_WRITE_PRINTER_HOOKED)
    {
        START_OEMENTRYPOINT_LOOP(pPDev);

            //
            //  OEM plug in uses COM and function is implemented.
            //
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )
            {
                //
                // Call only the first available WritePrinter method in
                // multiple plug-ins.
                //

                if (pOemEntry->dwFlags & OEMWRITEPRINTER_HOOKED)
                {
                    HRESULT  hr;

                    //
                    // WritePrinter is supported by this plug-in DLL.
                    // Plug-in's WritePrinter should not return E_NOTIMPL or
                    // E_NOTINTERFACE.
                    //
                    pPDev->fMode2 |= PF2_CALLING_OEM_WRITE_PRINTER;
                    hr = HComWritePrinter((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                          (PDEVOBJ)pPDev,
                                          pBuf,
                                          cbBuf,
                                          pcbWritten);
                    pPDev->fMode2 &= ~PF2_CALLING_OEM_WRITE_PRINTER;

                    //
                    // If Plug-in's WritePrinter succeeded, return TRUE.
                    //
                    if(SUCCEEDED(hr))
                    {
                        //
                        // If the method is called and succeeded, return TRUE.
                        //
                        bReturn = TRUE;
                        break;
                    }
                    else
                    {
                        //
                        // If WritePrinter method failed, break.
                        //
                        bReturn = FALSE;
                        break;
                    }
                }
            }

        END_OEMENTRYPOINT_LOOP;

        if (pPDev->pVectorProcs != NULL)
        {
            pPDev->devobj.pdevOEM = pPDev->pVectorPDEV;
        }
    }
    //
    // If there is no WritePrinter hook, call spooler API WritePrinter.
    //
    else
    {
       bReturn = WritePrinter(pPDev->devobj.hPrinter,
                              pBuf,
                              cbBuf,
                              pcbWritten)
               && cbBuf == *pcbWritten; 
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\physical.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    physical.h

Abstract:

    physical.c header file

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _PHYSICAL_H_
#define _PHYSICAL_H_


#define MAX_STACK_SIZE  100
#define CMDOFFSET_TO_PTR(pPDev, loOffset) \
        (pPDev->pDriverInfo->pubResourceData + loOffset)

typedef struct _CMDPARAM {
    DWORD           dwFormat;           // Specifies the format of the parameter
    DWORD           dwDigits;           // Specifies the number of digits to be
                                        // emmitted, this is only valid if the
                                        // format is "D" or "d" AND dwFlags has
                                        // PARAM_FLAG_FIELDWIDTH_USED
    DWORD           dwFlags;            // Flags for parameters, which action to carray out:
                                        // PARAM_FLAG_MIN_USED
                                        // PARAM_FLAG_MAX_USED
                                        // PARAM_FLAG_FIELDWIDTH_USED
    INT             iValue;             // Value calculated from arToken in PARAMETER struct

} CMDPARAM, * PCMDPARAM;


VOID
SendCmd(
    PDEV    *pPDev,
    COMMAND *pCmd,
    CMDPARAM *pParam
    );

INT
IProcessTokenStream(
    PDEV            *pPDev,
    ARRAYREF        *pToken ,
    PBOOL           pbMaxRepeat
    );

INT
FineXMoveTo(
    PDEV    *pPDev,
    INT     iX
    );

PPARAMETER
PGetParameter(
    PDEV    *pPDev,
    BYTE    *pInvocationStr
    );

#endif // _PHYSICAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\state.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    state.c

Abstract:

    Printer graphics state tracking.
    Implemenation of

    GSRealizeBrush
    GSUnRealizeBrush
    GSSelectBrush
    GSResetBrush

Environment:

    Windows NT Unidrv driver

Revision History:

    04/29/97 -amandan-
        Created

--*/

#include "unidrv.h"

#ifdef WINNT_40   // NT 4.0

extern HSEMAPHORE   hSemBrushColor;
LPDWORD      pBrushSolidColor = NULL;


DWORD
GetBRUSHOBJRealColor(
    PDEV        *pPDev,
    BRUSHOBJ    *pbo
    )

/*++

Routine Description:

    Given a BRUSHOBJ Gets the original color ofthe brush using DrvDitherColor.


Arguments:

    pPDev - Pointer to PDEV
    pbo - Pointer to BRUSHOBJ

Return Value:

    Original RGB color

Note:


--*/

{
    DWORD   SolidColor;


    if ((SolidColor = pbo->iSolidColor) == 0xFFFFFFFF)
    {

        SolidColor = 0;

        EngAcquireSemaphore(hSemBrushColor);

        pBrushSolidColor = &SolidColor;
        BRUSHOBJ_pvGetRbrush(pbo);

        EngReleaseSemaphore(hSemBrushColor);

    }
    else
    {
         ERR(( "GetBRUSHOBJRealColor: Should not be Called for mapped color\n" ));
         SolidColor = 0;
    }

    return(SolidColor);

}

#endif //WINNT_40

ULONG GetRGBColor(PDEV *, ULONG);


PDEVBRUSH
GSRealizeBrush(
    IN OUT  PDEV        *pPDev,
    IN      SURFOBJ     *pso,
    IN      BRUSHOBJ    *pbo
    )
/*++

Routine Description:

    Given a BRUSHOBJ perform one of the following:

    Color Printer:
    1. Programmable Palette
    2. Non-Programmable Palette

    Monochrome Printer:
    1. User defined pattern, only if brush is pattern brush
    2. Shading Patterns , only if brush is pattern brush
    3. Maps to black/white brush
    4. Maps to black

Arguments:

    pPDev - Pointer to PDEV
    pso - Pointer to SURFOBJ
    pbo - Pointer to BRUSHOBJ

Return Value:

    PDEVBRUSH if successful, otherwise NULL

Note:

    It's up to the caller to call GSUnRealizeBrush to free brushes

--*/

{

    ULONG ulColor = pbo->iSolidColor;
    PDEVBRUSH   pDevBrush;
    BOOL        bPatternBrush = FALSE;

    //
    // Allocate memory for Brush, deallocation is done in GSUnRealizeBrush
    //

    if ((pDevBrush = MemAllocZ(sizeof(DEVBRUSH))) == NULL)
        return NULL;

    if (pso->iBitmapFormat != BMF_24BPP &&
          pbo->iSolidColor != DITHERED_COLOR)
    {
        //
        // Index case
        // pbo->iSolidColor holds the Index, Map index to RGB color
        //

        ulColor = GetRGBColor(pPDev, pbo->iSolidColor);
    }
    //
    // TBD: BUG_BUG NT4 - needs to be fixed
    //   no NT4 bugs will be fixed unless necessary.
    //


    if (pbo->iSolidColor == DITHERED_COLOR)
    {
        //
        // Pattern Brush, get the color
        //

        #ifndef WINNT_40 //NT 5.0

        ulColor = BRUSHOBJ_ulGetBrushColor(pbo);
        
        // BUG_BUG: Unidrv currently doesn't handle the case where the brush is
        // a non-solid brush (return -1). The HPGL / PCL-XL implementations will require
        // this so we will merge that implementation when it is complete. 
        if (ulColor != -1)
            ulColor &= 0x00FFFFFF;

        #else // NT 4.0

        ulColor  = GetBRUSHOBJRealColor(pPDev, pbo);

        #endif //!WINNT_40


        bPatternBrush = TRUE;
    }



    //
    // ulColor should always be RGB color by the time we get here
    //

    if ((pso->iBitmapFormat == BMF_1BPP) )
    {
        //
        // Monochrome case
        // Download user define pattern or select intensity for
        // non-solid brush ONLY.  Otherwise, map it to black or white.
        //
        //
        if ((pPDev->fMode & PF_DOWNLOAD_PATTERN) && bPatternBrush)
        {
            PDEVBRUSH pDB;

            // Support user defined pattern, iColor will hold the pattern ID

            if ((pDB = (PDEVBRUSH)BRUSHOBJ_pvGetRbrush(pbo)) == NULL)
            {
                WARNING(("BRUSHOBJ_pvGetRBrush failed"));
                return NULL;
            }

            pDevBrush->dwBrushType = BRUSH_USERPATTERN;
            pDevBrush->iColor = pDB->iColor;

        }
        else if ((pPDev->fMode & PF_SHADING_PATTERN) && bPatternBrush)
        {
            // Support shading pattern, iColor holds %of gray

            pDevBrush->dwBrushType = BRUSH_SHADING;
            pDevBrush->iColor = GET_SHADING_PERCENT(ulColor);
        }
        else if (pPDev->fMode & PF_WHITEBLACK_BRUSH)
        {
            // Support black/white brush commands, iColor will hold RBG color
            // We are here means solid color brush, and for monochrome
            // it can be either black or white.  If it's indexed, we
            // have taken care of mapping index to RGB color already
            //

            pDevBrush->dwBrushType = BRUSH_BLKWHITE;
            pDevBrush->iColor = ulColor;

        }
        else
        {
            //
            // Map to black
            //

            pDevBrush->dwBrushType = BRUSH_BLKWHITE;
            pDevBrush->iColor = RGB_BLACK_COLOR;

        }

    }
    else if (pPDev->fMode & PF_ANYCOLOR_BRUSH )
    {
        //
        // Programmable
        //

        pDevBrush->dwBrushType = BRUSH_PROGCOLOR;
        pDevBrush->iColor = ulColor;

    }
    else
    {
        //
        // Non-Programmable
        //

        pDevBrush->dwBrushType = BRUSH_NONPROGCOLOR;

        //
        // Since ulColor is RGB color, need to map it to the nearest
        // color in the fixed palette.
        // iColor will hold the index of the color
        //
        if (pbo->iSolidColor == DITHERED_COLOR)
            pDevBrush->iColor = BestMatchDeviceColor(pPDev,(DWORD)ulColor);
        else
            pDevBrush->iColor = pbo->iSolidColor;
    }

    //
    // Save the brush to the Realized Brush linked list
    //

    if (pPDev->GState.pRealizedBrush == NULL)
    {
        pDevBrush->pNext = NULL;
        pPDev->GState.pRealizedBrush = pDevBrush;
    }
    else
    {
        pDevBrush->pNext = pPDev->GState.pRealizedBrush;
        pPDev->GState.pRealizedBrush = pDevBrush;
    }

    return pDevBrush;
}

VOID
GSUnRealizeBrush(
    IN      PDEV    *pPDev
    )
/*++

Routine Description:

    Deallocate memory for the realized brush

Arguments:

    pPDev   Pointer to PDEV

Return Value:

    None

--*/
{

    PDEVBRUSH pDevBrush = pPDev->GState.pRealizedBrush;

    VERBOSE(("GSUnRealizeBrush \n"));

    while(pPDev->GState.pRealizedBrush !=NULL)
    {
        pDevBrush = pPDev->GState.pRealizedBrush;
        pPDev->GState.pRealizedBrush = pDevBrush->pNext;
        MemFree(pDevBrush);
    }

    pPDev->GState.pRealizedBrush = NULL;
}

BOOL
GSSelectBrush(
    IN      PDEV        *pPDev,
    IN      PDEVBRUSH   pDevBrush
    )
/*++

Routine Description:

    Given a pDevBrush, select the brush.

Arguments:

    pPDev - Pointer to PDEV
    pDevBrush - Pointer to DEVBRUSH

Return Value:

    TRUE if sucessful, otherwise FALSE

--*/

{
    BOOL bIndexedColor = FALSE;

    //
    // Find Cached Brush, if the current selected brush matches
    // the caller request, do nothing.
    //

    if (BFoundCachedBrush(pPDev, pDevBrush))
        return TRUE;

    switch(pDevBrush->dwBrushType){

        case BRUSH_PROGCOLOR:
        {
            VERBOSE(("Using Programmable RGB Color \n"));

            if (((PAL_DATA *)pPDev->pPalData)->fFlags & PDF_PALETTE_FOR_8BPP_MONO)
                pDevBrush->iColor = ConvertRGBToGrey(pDevBrush->iColor);

            if ( !BSelectProgrammableBrushColor(pPDev, pDevBrush->iColor) )
            {
                WARNING(("\nCan't Select the brush color for RGB = 0x%x\n",pDevBrush->iColor));
                pDevBrush->iColor = BestMatchDeviceColor(pPDev, pDevBrush->iColor);
                bIndexedColor = TRUE;
            }
        }
            //
            // Let it fall thru to catch the indexed case
            //

        case BRUSH_NONPROGCOLOR:
        {
            if (bIndexedColor || pDevBrush->dwBrushType == BRUSH_NONPROGCOLOR)
            {
                INT iCmd;

                VERBOSE(("Using Non Programmable Indexed Color"));

                //
                // If this color is not supported, use the default color: black.
                //

                pDevBrush->iColor &= (MAX_COLOR_SELECTION - 1);   /* 16 entry palette wrap around */

                //
                // If there is no command to set the color, map to black.
                //
                if(COMMANDPTR(pPDev->pDriverInfo, CMD_COLORSELECTION_FIRST + pDevBrush->iColor) == NULL)
                    pDevBrush->iColor = BLACK_COLOR_CMD_INDEX;

                iCmd = CMD_COLORSELECTION_FIRST + pDevBrush->iColor;
                WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, iCmd));
            }

        }
            break;

        case BRUSH_USERPATTERN:
        {
            VERBOSE(("Selecting user defined pattern brush"));

            //
            // The pattern ID, is stored in pDevBrush->iColor
            //

            pPDev->dwPatternBrushType = BRUSH_USERPATTERN;
            pPDev->dwPatternBrushID = pDevBrush->iColor;

            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECT_PATTERN));
        }
            break;

        case BRUSH_SHADING:
        {

            VERBOSE(("Selecting shading pattern brush"));

            //
            // The gray level (expressed as intensity) is stored in
            // pDevBrush->iColor
            //

            //
            // Update standard variable for brush selection command
            //

            pPDev->dwPatternBrushType = BRUSH_SHADING;
            pPDev->dwPatternBrushID = pDevBrush->iColor;
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECT_PATTERN));

        }
            break;

        case BRUSH_BLKWHITE:
        {
            INT iCmd;


            if (pDevBrush->iColor == RGB_WHITE_COLOR)
            {
                VERBOSE(("Selecting white brush"));

                //
                // BUG_BUG, need to remove the CMD_WHITETEXTON and CMD_WHITETEXTOFF
                // once all GPD changes have been made for BLACKBRUSH, WHITEBRUSH
                //     doesn't hurt to leave it in.

                if (pPDev->arCmdTable[CMD_SELECT_WHITEBRUSH])
                    iCmd = CMD_SELECT_WHITEBRUSH;
                else
                    iCmd = CMD_WHITETEXTON;
            }
            else
            {
                //
                // Black - standard text color
                //

                VERBOSE(("Selecting black brush"));

                //
                // BUG_BUG, need to remove the CMD_WHITETEXT_ON and CMD_WHITETEXT_OFF
                // once all GPD changes have been made for BLACKBRUSH, WHITEBRUSH
                //     doesn't hurt to leave it in.
                //

                if (pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH])
                    iCmd = CMD_SELECT_BLACKBRUSH;
                else
                    iCmd = CMD_WHITETEXTOFF;
            }

            //
            //   Set the desired colour !
            //

            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, iCmd));
        }
            break;
    }

    //
    // Cached the brush
    //

    CACHE_CURRENT_BRUSH(pPDev, pDevBrush)

    return TRUE;
}


VOID
GSResetBrush(
    IN OUT  PDEV        *pPDev
    )
/*++

Routine Description:

    Select the default brush

Arguments:

    pPDev - Pointer to PDEV

Return Value:

    None

--*/

{

    DEVBRUSH DeviceBrush;
    PDEVBRUSH pDevBrush = &DeviceBrush;
    PAL_DATA    *pPD;
    pPD = pPDev->pPalData;


    if (pPD->fFlags & PDF_PALETTE_FOR_1BPP)
    {
        //
        // Monochrome case. Select black brush
        //

        pDevBrush->dwBrushType = BRUSH_BLKWHITE;
        pDevBrush->iColor = RGB_BLACK_COLOR;

        if (BFoundCachedBrush(pPDev, pDevBrush))
            return;

        //
        // BUG_BUG, need to remove the CMD_WHITETEXT_ON and CMD_WHITETEXT_OFF
        // once all GPD changes have been made
        //     doesn't hurt to leave it in.
        //
        if (pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH])
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECT_BLACKBRUSH));
        else
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_WHITETEXTOFF));

    }
    else if (pPDev->fMode & PF_ANYCOLOR_BRUSH )
    {
        //
        // Programmable
        //

        pDevBrush->dwBrushType = BRUSH_PROGCOLOR;
        pDevBrush->iColor = RGB_BLACK_COLOR;

        VResetProgrammableBrushColor(pPDev);

    }
    else
    {
        //
        // Non-Programmable
        //

        pDevBrush->dwBrushType = BRUSH_NONPROGCOLOR;
        pDevBrush->iColor = ((PAL_DATA*)(pPDev->pPalData))->iBlackIndex;

        if (BFoundCachedBrush(pPDev, pDevBrush))
            return;

        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SELECTBLACKCOLOR));

    }

    CACHE_CURRENT_BRUSH(pPDev, pDevBrush)

}


ULONG
GetRGBColor(
    IN      PDEV        *pPDev,
    IN      ULONG       ulIndex
    )
/*++

Routine Description:

    Given an Indexed color, map to an RGB color

Arguments:

    pPDev - Pointer to PDEV
    pDevBrush - Pointer to DEVBRUSH

Return Value:

    TRUE if sucessful, otherwise FALSE

--*/

{

    // If the index is invalid, map to Black.
    if (ulIndex > PALETTE_MAX)
    {
        ERR(( "GSSelectBrush: Bad input Color Index\n" ));
        ulIndex = ((PAL_DATA*)(pPDev->pPalData))->iBlackIndex;
    }

    return( ((PAL_DATA *)(pPDev->pPalData))->ulPalCol[ulIndex]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\print.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Implementation of document and page related DDI entry points:
        DrvStartDoc
        DrvEndDoc
        DrvStartPage
        DrvSendPage
        DrvNextBand
        DrvStartBanding

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "unidrv.h"

//
// Forward declaration for local functions
//

VOID VEndPage ( PDEV *);
BOOL BEndDoc  ( PDEV *, SURFOBJ *, FLONG flags);
VOID VSendSequenceCmd(PDEV *, DWORD);


BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    pDocName - Specifies a Unicode document name
    jobId - Identifies the print job

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV *pPDev = (PDEV*)pso->dhpdev;

    VERBOSE(("Entering DrvStartDoc...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStartDoc,
                    PFN_OEMStartDoc,
                    BOOL,
                    (pso,
                     pDocName,
                     jobId));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStartDoc,
                    VMStartDoc,
                    BOOL,
                    (pso,
                     pDocName,
                     jobId));

    //
    // We might get a DrvResetPDEV before this and get another DrvStartDoc
    // without a DrvEndDoc so check for that condition and call BEndDoc
    // to clean up the previous instance before continuing.
    //

    if (pPDev->fMode & PF_DOC_SENT)
    {
        BEndDoc(pPDev, pso, 0);       // this flag also suppresses
                        // emission of EndDoc commands to the printer
                        // since they may cause a page ejection and
                        //  we are only interested in freeing memory and
                        //  performing pdev cleanup at this point.
        pPDev->fMode &= ~PF_DOC_SENT;
    }
    else
        pPDev->dwPageNumber = 1 ;  // first page of document


    //
    // Call Raster and Font module
    //

    if (!(((PRMPROCS)(pPDev->pRasterProcs))->RMStartDoc(pso, pDocName, jobId)) ||
        !(((PFMPROCS)(pPDev->pFontProcs))->FMStartDoc(pso, pDocName, jobId)) )
    {
        return FALSE;
    }

    //
    // Send JobSetup and DocSetup Sequence Cmds at DrvStartPage instead
    // of here since the driver can get a new DrvStartDoc after each
    // DrvResetPDEV
    //

    return  TRUE;

}

BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;
    PAL_DATA   *pPD = pPDev->pPalData;

    VERBOSE(("Entering DrvStartPage...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStartPage,
                    PFN_OEMStartPage,
                    BOOL,
                    (pso));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStartPage,
                    VMStartPage,
                    BOOL,
                    (pso));

    //
    // clear flags at start of page
    //
    pPDev->fMode &= ~(PF_SURFACE_USED | PF_SURFACE_ERASED);
    pPDev->fMode &= ~PF_DOWNLOADED_TEXT;

    //
    // only a bitmap surface driver needs to have a band
    //
    if (!DRIVER_DEVICEMANAGED (pPDev))
    {
        ZeroMemory(pPDev->pbScanBuf, pPDev->szBand.cy);
        ZeroMemory(pPDev->pbRasterScanBuf, (pPDev->szBand.cy / LINESPERBLOCK)+1);
#ifndef DISABLE_NEWRULES
        pPDev->dwRulesCount = 0;        
#endif
    }

    //
    // Send JobSetup, DocSetup cmd and Download the Palette if necessary.
    //


            if (!(pPDev->fMode & PF_JOB_SENT))
            {
                VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwJobSetupIndex);
                pPDev->fMode |= PF_JOB_SENT;
            }
            if (!(pPDev->fMode & PF_DOC_SENT))
            {
                VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwDocSetupIndex);
                pPDev->fMode |= PF_DOC_SENT;   // this flag is cleared
                                                                            //  by StartDoc
                //
                // PF_DOCSTARTED - Signify DrvStartDoc is called, for DrvResetPDEV
                //    this flag is cleared only at EndJob.

                pPDev->fMode |= PF_DOCSTARTED;

            }
            pPDev->fMode &= ~PF_SEND_ONLY_NOEJECT_CMDS ;

            if ( (pPD->fFlags & PDF_DL_PAL_EACH_DOC) &&
                 (!DRIVER_DEVICEMANAGED (pPDev)) )
            {
                VLoadPal(pPDev);
            }

    //
    // Set PF_ENUM_GRXTXT
    //

    pPDev->fMode |= PF_ENUM_GRXTXT;

    //
    // Call Raster and Font module.
    //

    if ( !( ((PRMPROCS)(pPDev->pRasterProcs))->RMStartPage(pso) ) ||
         !( ((PFMPROCS)(pPDev->pFontProcs))->FMStartPage(pso) ))
    {
        return FALSE;
    }

    //
    // BUG_BUG, should we check for PF_SEND_ONLY_NOEJECT_CMDS here?
    // Assumes that GPD writer does not put page ejection code
    // in PageSetup Cmds since we might get a ResetPDEV between pages.
    // This bit is set when we get DrvResetPDev where we are doing duplexing
    // and paper size and source, and orienation is the same.  Detecting this
    // condition allows us to skip page ejection cmds or any cmds that
    // could cause page ejection but if the GPD writer does not put page
    // ejection code in PageSetup cmd, we are OK.
    //   If pageSetup commands  caused pages to be ejected, we would
    //  always get one or more blank pages for every one that was printed.
    //  this is a needless concern.
    //

    // initialize the cursor position at the start of each page
    //
    pPDev->ctl.ptCursor.x = pPDev->ctl.ptCursor.y = 0;
    pPDev->ctl.dwMode |= MODE_CURSOR_UNINITIALIZED;    // both X & Y

    //
    // Send PageSetup sequence Cmds
    //

    VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwPageSetupIndex);


    //Download the Palette if necessary.
    if ( (pPD->fFlags & PDF_DL_PAL_EACH_PAGE) &&
         (!DRIVER_DEVICEMANAGED (pPDev)) )
    {
        VLoadPal(pPDev);
    }

    //
    // Set the current position to some illegal position, so that
    // we make no assumptions about where we are
    //

    //
    // Flush the spool buffer with the setup commands to give serial printers
    // a head start on loading paper and cleaning their jets.
    //
    if (pPDev->pGlobals->printertype == PT_SERIAL)
        FlushSpoolBuf (pPDev);

    return  TRUE;
}

BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvSendPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    bRet = FALSE;
    PDEV *  pPDev = (PDEV *)pso->dhpdev;

    VERBOSE(("Entering DrvSendPage...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMSendPage,
                    PFN_OEMSendPage,
                    BOOL,
                    (pso));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMSendPage,
                    VMSendPage,
                    BOOL,
                    (pso));

    //Reset the brush, before calling render module.
    GSResetBrush(pPDev);

    switch( pso->iType )
    {

    case  STYPE_BITMAP:
        //
        // Engine managed bitmap
        //

        //
        // Call Raster and Font module
        //

        if ( !(((PRMPROCS)(pPDev->pRasterProcs))->RMSendPage(pso)) ||
             !(((PFMPROCS)(pPDev->pFontProcs))->FMSendPage(pso) ) )
        {
            return FALSE;
        }

        //
        // VEndPage should take care of sending PageFinish sequence Cmds
        //

        VEndPage( pPDev );

        bRet = TRUE;

        break;

    case STYPE_DEVICE:
        //
        // Device managed surface
        //

        VERBOSE(("DrvSendPage: pso->iType == STYPE_DEVICE \n" ));
        //
        // Call Raster and Font module if needed.
        //


        //
        // VEndPage should take care of sending PageFinish sequence Cmds
        //

        VEndPage( pPDev );

        bRet = TRUE;

        break;

    default:

        VERBOSE(("DrvSendPage: pso->iType is unknown \n"));
        break;

    }

    return  bRet;

}

BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEndDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    flags - A set of flag bits

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;

    VERBOSE(("Entering DrvEndDoc...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // if we've detected an aborted job because WritePrinter has failed we will set the
    // ED_ABORTDOC flag for the OEM plugins since GDI only sets this for direct printing
    //
    if (pPDev->fMode & PF_ABORTED)
        flags |= ED_ABORTDOC;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMEndDoc,
                    PFN_OEMEndDoc,
                    BOOL,
                    (pso,
                     flags));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMEndDoc,
                    VMEndDoc,
                    BOOL,
                    (pso,
                     flags));

    pPDev->fMode &= ~PF_DOC_SENT;
    //  we are going to send the EndDoc commands to the printer.

    return ( BEndDoc(pPDev, pso, flags) );

}

BOOL
DrvNextBand(
        SURFOBJ *pso,
        POINTL *pptl
        )

/*++

Routine Description:

        Implementation of DDI entry point DrvNextBand.
        Please refer to DDK documentation for more details.

Arguments:

        pso - Defines the surface object
        pptl - Pointer to origin of next band (to return to GDI)

Return Value:

        TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;
    BOOL    bMore, bRet;

    VERBOSE(("Entering DrvNextBand...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMNextBand,
                    PFN_OEMNextBand,
                    BOOL,
                    (pso,
                     pptl));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMNextBand,
                    VMNextBand,
                    BOOL,
                    (pso,
                     pptl));

    //Reset the brush, before calling render module.

    GSResetBrush(pPDev);

    //
    // Call Raster and Font module
    //

    if (! (((PRMPROCS)(pPDev->pRasterProcs))->RMNextBand(pso, pptl)) ||
        ! (((PFMPROCS)(pPDev->pFontProcs))->FMNextBand(pso, pptl)) )
    {
        return FALSE;
    }

    //
    // Clear the band surface, szBand is in Graphic units
    //
    pPDev->fMode &= ~(PF_SURFACE_USED | PF_SURFACE_ERASED);
    pPDev->fMode &= ~PF_DOWNLOADED_TEXT;

    if (!DRIVER_DEVICEMANAGED (pPDev))   // bitmap surface
    {
        ZeroMemory(pPDev->pbScanBuf, pPDev->szBand.cy);
        ZeroMemory(pPDev->pbRasterScanBuf, (pPDev->szBand.cy / LINESPERBLOCK)+1);
#ifndef DISABLE_NEWRULES
        pPDev->dwRulesCount = 0;        
#endif
    }

    //
    // If PF_REPLAY_BAND is set, then replay the last band enumerate to
    // GDI
    //

    if (pPDev->fMode & PF_REPLAY_BAND)
    {

        pptl->x = pPDev->rcClipRgn.left;
        pptl->y = pPDev->rcClipRgn.top;

        VERBOSE(("DrvNextBand: Next Band is %d , %d \n", pptl->x, pptl->y));

        pPDev->fMode &= ~PF_REPLAY_BAND;

        return TRUE;

    }

    switch( pPDev->iBandDirection )
    {

    case  SW_DOWN:
        //
        // Moving down the page
        //

        pPDev->rcClipRgn.top += pPDev->szBand.cy;
        pPDev->rcClipRgn.bottom += pPDev->szBand.cy;

        //
        // Make sure we do not run off the bottom
        //

        bMore = pPDev->rcClipRgn.top < pPDev->sf.szImageAreaG.cy;

        if( pPDev->rcClipRgn.bottom > pPDev->sf.szImageAreaG.cy )
        {
            //
            // Partial band
            //

            pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;
        }

        break;

    case  SW_RTOL:
        //
        // LaserJet style, RTOL
        //

        pPDev->rcClipRgn.left -= pPDev->szBand.cx;
        pPDev->rcClipRgn.right -= pPDev->szBand.cx;

        bMore = pPDev->rcClipRgn.right > 0;
        //
        // if the left position is negative that is
        // what must be reported to GDI to render the
        // band correctly so we don't change the clip region.
        //
        break;

    case  SW_LTOR:
        //
        // Dot matrix, left to right
        //

        pPDev->rcClipRgn.left += pPDev->szBand.cx;
        pPDev->rcClipRgn.right += pPDev->szBand.cx;

        bMore = pPDev->rcClipRgn.left < pPDev->sf.szImageAreaG.cx;

        if( pPDev->rcClipRgn.right > pPDev->sf.szImageAreaG.cx )
        {
            //
            // Partial band
            //

            pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
        }

        break;

    case  SW_UP:
            //
            // Moving up the page
            //

            pPDev->rcClipRgn.top -= pPDev->szBand.cy;
            pPDev->rcClipRgn.bottom -= pPDev->szBand.cy;

            //
            // Make sure we do not run off the top
            //
            bMore = pPDev->rcClipRgn.bottom > 0 ;


            if( pPDev->rcClipRgn.top < 0 )
            {
                //
                // Partial band
                //

                pPDev->rcClipRgn.top = 0;
            }

            break;


    default:

        VERBOSE((" DrvNextBand, unknown banding direction \n"));
        return(FALSE);

    }

    if( bMore )
    {
        pptl->x = pPDev->rcClipRgn.left;
        pptl->y = pPDev->rcClipRgn.top;

        VERBOSE(("DrvNextBand: Next Band is %d , %d \n", pptl->x, pptl->y));
    }
    else
    {
        //
        // No more band for the page, send the page to printer
        //

        if ( !(((PRMPROCS)(pPDev->pRasterProcs))->RMSendPage(pso)) ||
             !(((PFMPROCS)(pPDev->pFontProcs))->FMSendPage(pso)) )
        {
            bRet = FALSE;

        }
        else
            bRet = TRUE;

        //
        // Send PageFinish sequence commands
        //

        VEndPage( pPDev );
        pptl->x = pptl->y = -1;

        return(bRet);
    }

    return(TRUE);

}

BOOL
DrvStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartBanding.
    Please refer to DDK documentation for more details.
    Note: DrvStartBanding is called to prepare the driver
    for banding, call only once per page (not at everyband!!)

Arguments:

    pso - Defines the surface object
    pptl - Pointer to origin of next band (to return to GDI)

Return Value:

    Fill out pptl to contain the origin of the first band

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;

    VERBOSE(("Entering DrvStartBanding...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStartBanding,
                    PFN_OEMStartBanding,
                    BOOL,
                    (pso,
                     pptl));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStartBanding,
                    VMStartBanding,
                    BOOL,
                    (pso,
                     pptl));

    //
    // Set PF_ENUM_GRXTXT
    //

    pPDev->fMode |= PF_ENUM_GRXTXT;
    pPDev->fMode &= ~(PF_SURFACE_USED | PF_SURFACE_ERASED);
    pPDev->fMode &= ~PF_DOWNLOADED_TEXT;

    if (!DRIVER_DEVICEMANAGED (pPDev))   // bitmap surface
    {
        ZeroMemory(pPDev->pbScanBuf, pPDev->szBand.cy);
        ZeroMemory(pPDev->pbRasterScanBuf, (pPDev->szBand.cy / LINESPERBLOCK)+1);
#ifndef DISABLE_NEWRULES
        pPDev->dwRulesCount = 0;        
#endif
    }

    //
    //
    // Call Raster and Font module
    //

    if (! (((PRMPROCS)(pPDev->pRasterProcs))->RMStartBanding(pso, pptl)) ||
        ! (((PFMPROCS)(pPDev->pFontProcs))->FMStartBanding(pso, pptl)) )
    {
        return FALSE;
    }


    if( pPDev->fMode & PF_ROTATE )
    {
        pPDev->rcClipRgn.top = 0;
        pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;

        if( pPDev->fMode & PF_CCW_ROTATE90 )
        {
            //
            //   LaserJet style rotation
            //


            if( //  if duplexing is enabled...
                (pPDev->pdm->dmFields & DM_DUPLEX) &&
                (pPDev->pdm->dmDuplex == DMDUP_VERTICAL)  &&

                    !(pPDev->dwPageNumber % 2)  &&
                pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER)
            {
                pPDev->rcClipRgn.left = 0;
                pPDev->rcClipRgn.right = pPDev->szBand.cx;
                pPDev->iBandDirection = SW_LTOR;
            }
            else
            {
                pPDev->rcClipRgn.left = pPDev->sf.szImageAreaG.cx - pPDev->szBand.cx;
                pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
                pPDev->iBandDirection = SW_RTOL;
            }
        }
        else
        {
            //
            //  Dot matrix style rotation
            //

            if( //  if duplexing is enabled...
                (pPDev->pdm->dmFields & DM_DUPLEX) &&
                (pPDev->pdm->dmDuplex == DMDUP_VERTICAL)  &&

                    !(pPDev->dwPageNumber % 2)  &&
                pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER)
            {
                pPDev->rcClipRgn.left = pPDev->sf.szImageAreaG.cx - pPDev->szBand.cx;
                pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
                pPDev->iBandDirection = SW_RTOL;
            }
            else
            {
                pPDev->rcClipRgn.left = 0;
                pPDev->rcClipRgn.right = pPDev->szBand.cx;
                pPDev->iBandDirection = SW_LTOR;
            }
        }
    }
    else
    {
        pPDev->rcClipRgn.left = 0;
        pPDev->rcClipRgn.right = pPDev->szBand.cx;

        if( //  if duplexing is enabled...
            (pPDev->pdm->dmFields & DM_DUPLEX) &&
            (pPDev->pdm->dmDuplex == DMDUP_VERTICAL)  &&

                !(pPDev->dwPageNumber % 2)  &&
            pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER)
        {
            pPDev->rcClipRgn.top = pPDev->sf.szImageAreaG.cy - pPDev->szBand.cy;
            pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy ;
            pPDev->iBandDirection = SW_UP;
        }
        else
        {
            pPDev->rcClipRgn.top = 0;
            pPDev->rcClipRgn.bottom = pPDev->szBand.cy;
            pPDev->iBandDirection = SW_DOWN;
        }
    }

    pptl->x = pPDev->rcClipRgn.left;
    pptl->y = pPDev->rcClipRgn.top;

    return TRUE;
}

VOID
VEndPage (
    PDEV *pPDev
    )
/*++

Routine Description:

    This function is called when the page has been rendered.  Mainly used to
    complete the page printing process.  Called at DrvSendPage or at
    DrvNextBand and no more band to process for the page or at
    DrvEndDoc where the job is aborted.

Arguments:

    pPDev - Pointer to PDEVICE

Return Value:

    None

--*/
{

    //
    // Eject the page for device that use FF to eject a page, else
    // move the cursor to the bottom of the page.
    //

    if (pPDev->pGlobals->bEjectPageWithFF == TRUE)
    {
        if ( !(pPDev->bTTY) ||
              pPDev->fMode2 & PF2_DRVTEXTOUT_CALLED_FOR_TTY   ||
             !(pPDev->fMode2 & PF2_PASSTHROUGH_CALLED_FOR_TTY)  )
        {
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_FORMFEED));
            if (pPDev->fMode & PF_RESELECTFONT_AFTER_FF)
            {
                VResetFont(pPDev);
            }
        }
    }
    else
    {
        //
        // Note: sf.szImageAreaG.cx and sf.szImageAreaG.cy are swapped already
        // if the page is printed in landscape mode.  Need to unswap it
        // for moving the cursor to the end of the page
        //

        INT       iYEnd;                // Last scan line on page


        iYEnd = pPDev->pdm->dmOrientation == DMORIENT_LANDSCAPE ?
                    pPDev->sf.szImageAreaG.cx : pPDev->sf.szImageAreaG.cy;

        YMoveTo(pPDev, iYEnd, MV_GRAPHICS);
    }


    //
    // Send PageFinish sequence Cmds
    //

    VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwPageFinishIndex);

    //
    // Reset and and free up realized brush for this page
    //

    GSResetBrush(pPDev);
    GSUnRealizeBrush(pPDev);

    FlushSpoolBuf( pPDev );
    pPDev->dwPageNumber++ ;

    //
    // Clear PF2_XXX_TTY flags
    //
    pPDev->fMode2 &= ~( PF2_DRVTEXTOUT_CALLED_FOR_TTY |
                        PF2_PASSTHROUGH_CALLED_FOR_TTY );

}

BOOL
BEndDoc (
    PDEV *pPDev,
    SURFOBJ *pso,
    FLONG   flags
    )
/*++

Routine Description:

    This function can be called from two places - DrvEndDoc and DrvStartDoc.
    In the case of a DrvResetPDEV, the driver might get another DrvStartDoc
    without a DrvEndDoc.  So need to check for previous DrvStartDoc and call
    VEndDoc to clean up previous instance before initializing the new one.

Arguments:

    pPDev - Pointer to PDEVICE
    pso   - Pointer to surface object
    flags - EndDoc flags from DrvEndDoc, zero if called from DrvStartDoc

Return Value:

    TRUE for success and FALSE for failure

--*/
{

    //
    // Call Raster and Font module for cleaning up
    //

    if (! (((PRMPROCS)(pPDev->pRasterProcs))->RMEndDoc(pso, flags)) ||
        ! (((PFMPROCS)(pPDev->pFontProcs))->FMEndDoc(pso, flags)) )
    {
        return FALSE;
    }

    //
    // If the job is aborted, send the
    // PageFinish sequence Cmds (via. VEndPage)
    //

    if( flags & ED_ABORTDOC )
        VEndPage( pPDev);
    //
    // Send DocFinish, JobFinish sequence Cmds
    //

    // flag is cleared if called from  DrvEndDoc, this is the only time we
    //  should actually send the EndDoc commands to the printer.

    if (!(pPDev->fMode & PF_DOC_SENT))
    {
        if (pPDev->fMode & PF_DOCSTARTED)
        {
            VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwDocFinishIndex);
            //  print state has been forgotten, All start doc commands must be resent.
            pPDev->fMode &= ~PF_DOCSTARTED;
        }
        if (pPDev->fMode & PF_JOB_SENT)
        {
            VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwJobFinishIndex);
            pPDev->fMode &= ~PF_JOB_SENT;
        }
    }

    FlushSpoolBuf( pPDev );

    //
    // Clear the PF_DOCSTARTED, PF_FORCE_BANDING,
    // PF_ENUM_TEXT, PF_ENUM_GRXTXT, PF_REPLAY_BAND flags
    //


    pPDev->fMode &= ~PF_FORCE_BANDING;
    pPDev->fMode &= ~PF_ENUM_TEXT;
    pPDev->fMode &= ~PF_ENUM_GRXTXT;
    pPDev->fMode &= ~PF_REPLAY_BAND;

    return  TRUE;
}



VOID
VSendSequenceCmd(
    PDEV        *pPDev,
    DWORD       dwSectionIndex
    )
/*++

Routine Description:

    This function is called to send a sequence of commands to the printer.

Arguments:

    pPDev - Pointer to PDEVICE
    dwSectionIndex - specifies the index into the command array
                     for one of the following seq section.
        SS_JOBSETUP,
        SS_DOCSETUP,
        SS_PAGESETUP,
        SS_PAGEFINISH,
        SS_DOCFINISH,
        SS_JOBFINISH,

Return Value:

    None

Note:
    There are two types of command supported by the driver:
    - Predefined Commands, these commands are predefined in GPD specification
      and assigned an COMMAND ID (as enumerated in CMDINDEX).

    - Sequence Commands, these commands are not predefined.  They are
      commands that the GPD writer define to configure commands.

    - DT_LOCALLISTNODE is only used to hold a list of sequence commands

--*/
{

    LISTNODE   *pListNode;
    COMMAND    *pSeqCmd;

    //
    // Get the first node in the list
    //

    pListNode = LOCALLISTNODEPTR(pPDev->pDriverInfo, dwSectionIndex);

    while( pListNode )
    {
        //
        // Get pointer to command pointer using pListNode->dwData, which is
        // the index into the command array
        //

        pSeqCmd = INDEXTOCOMMANDPTR(pPDev->pDriverInfo, pListNode->dwData);


        //
        // Send the sequence command - but only if page ejection is
        //  not currently suppressed or this command does not
        //  cause a page to be ejected.
        //


        if(!(pPDev->fMode & PF_SEND_ONLY_NOEJECT_CMDS)  ||
                    (pSeqCmd->bNoPageEject))
                WriteChannel(pPDev, pSeqCmd);

        //
        // Get the next command in the list or exit if it's the end of list
        //

        if (pListNode->dwNextItem == END_OF_LIST)
            break;
        else
            pListNode = LOCALLISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);

    }
}

BYTE
BGetMask(
    PDEV *  pPDev,
    RECTL * pRect
    )
/*++

Routine Description:

    Given a rectangle, calculate the mask for determining the
    present of text, for z-ordering fix

Arguments:

    pPDev - Pointer to PDEVICE
    pRect - Pointer to rectangle defining the clip box for
            text or graphics

Return Value:

    None

Note:

    First mark all columm as dirty then work from the left and the right
    to figure out which one should be cleared.

--*/
{

    BYTE bMask = 0xFF;
    INT  i, iRight;

    iRight = MAX_COLUMM -1;

    if(! (pRect && pPDev->pbScanBuf && pRect->left <= pRect->right) )
        return 0;

    for (i = 0; i < MAX_COLUMM ; i++)
    {
        if (pRect->left >= (LONG)(pPDev->dwDelta * (i+1)) )
            bMask &= ~(1 << i);
        else
            break;
    }

    for (i = iRight; i >= 0; i--)
    {
        if (pRect->right < (LONG)(pPDev->dwDelta * i ))
            bMask &= ~(1 << i);
        else
            break;
    }

    return bMask;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\unidrv.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    unidrv.h

Abstract:

    Unidrv driver main header file. All other header files should
    be included in this for precompiled headers to work.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

        dd-mm-yy -author-
                description

--*/


#ifndef _UNIDRV_H_
#define _UNIDRV_H_

#include "lib.h"
#include "unilib.h"
#include "gpd.h"
#include "mini.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "data.h"
#include "init.h"
#include "physical.h"
#include "common.h"
#include "fontif.h"
#include "rasterif.h"
#include "state.h"
#include "brush.h"
#include "vectorif.h"

#endif  // !_UNIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\control\textout.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    textout.c

Abstract:

    Implementation of text output related DDI entry points:
        DrvTextOut

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "unidrv.h"

BOOL
DrvTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvTextOut.
    Please refer to DDK documentation for more details.

Arguments:

    pso     - Defines the surface on which to be written.
    pstro   - Defines the glyphs to be rendered and their positions
    pfo     - Specifies the font to be used
    pco     - Defines the clipping path
    prclExtra  - A NULL-terminated array of rectangles to be filled
    prclOpaque - Specifies an opaque rectangle
    pboFore    - Defines the foreground brush
    pboOpaque  - Defines the opaque brush
    pptlOrg    - Pointer to POINT struct , defining th origin
    mix        - Specifies the foreground and background ROPs for pboFore

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV * pPDev;
    PFMPROCS    pFontProcs;

    VERBOSE(("Entering DrvTextOut...\n"));
    ASSERT(pso && pstro && pfo);

    pPDev = (PDEV *)pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // QFE Fix for TTY driver.
    // Set flag if DrvTextOut DDI is called.
    //
    if (pPDev->bTTY)
    {
        pPDev->fMode2 |= PF2_DRVTEXTOUT_CALLED_FOR_TTY;
    }

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMTextOut,
                    PFN_OEMTextOut,
                    BOOL,
                    (pso,
                     pstro,
                     pfo,
                     pco,
                     prclExtra,
                     prclOpaque,
                     pboFore,
                     pboOpaque,
                     pptlOrg,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMTextOut,
                    VMTextOut,
                    BOOL,
                    (pso,
                     pstro,
                     pfo,
                     pco,
                     prclExtra,
                     prclOpaque,
                     pboFore,
                     pboOpaque,
                     pptlOrg,
                     mix));

    pFontProcs = (PFMPROCS)pPDev->pFontProcs;
    if ( pFontProcs->FMTextOut == NULL)
    {
        CheckBitmapSurface(pso,&pstro->rclBkGround);
        return FALSE;
    }
    else
        return (pFontProcs->FMTextOut(pso, pstro, pfo, pco, prclExtra,
                                        prclOpaque, pboFore, pboOpaque,
                                        pptlOrg, mix) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\bmpdload.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    bmpdload.c

Abstract:

    Implementation of True Type Download as Bitmap routines.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/06/97 -ganeshp-
        Created

--*/

//
//This line should be before the line including font.h.
//Comment out this line to disable FTRC and FTST macroes.
//
//#define FILETRACE

#include "font.h"


BOOL
BFreeTrueTypeBMPPFM(
    PFONTMAP pfm
    )
/*++
Routine Description:
    Frees a downloded font's PFM.
Arguments:
    pfm   Pointer to Fontmap

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/6/1997 -ganeshp-
        Created it.
--*/
{
    if (pfm)
    {
        MemFree(pfm);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



DWORD
DwTrueTypeBMPGlyphOut(
    TO_DATA *pTod
)
 /*++
 Routine Description:
    This functions outputs the downloaded glyphs. All the information is stored
    in TOD

 Arguments:
     pTod   TextOut Data.

Return Value:
    Number of Glyph outputed. O for ERROR.

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    DWORD      dwNumGlyphsPrinted;     // Glyphs Printed
    DWORD      dwCurrGlyphIndex;       // Current Glyph to print.
    DWORD      dwGlyphsToPrint;        // Number of Glyphs to print.
    DWORD      dwCopyOfGlyphsToPrint;  // Copy of dwGlyphsToPrint
    GLYPHPOS   *pgp;                   // Glyph position array.
    PDEV       *pPDev;                 // Our PDEV.
    PDLGLYPH   pdlGlyph;               // Download Glyph information
    INT        iX,  iY;                // X and Y position of Glyphs.
    POINTL     ptlRem;                 // Remainder of XoveTo and YMoveTo.
    BOOL       bSetCursorForEachGlyph; // X and Y position should be set if TRUE

    //
    // Local Initialization.
    //
    dwCurrGlyphIndex        = pTod->dwCurrGlyph;
    dwCopyOfGlyphsToPrint   =
    dwGlyphsToPrint         = pTod->cGlyphsToPrint;
    dwNumGlyphsPrinted      = 0;
    pgp                     = pTod->pgp;
    pPDev                   = pTod->pPDev;
    iX                      = pTod->pgp->ptl.x;
    iY                      = pTod->pgp->ptl.y;

    FTRC(\n********TRACING DwTrueTypeBMPGlyphOut ***********\n);
    FTST(dwCurrGlyphIndex,%d);
    FTST(dwGlyphsToPrint,%d);

    //
    // Set the cursor to first glyph if not already set.
    //
    if ( !(pTod->flFlags & TODFL_FIRST_GLYPH_POS_SET) )
    {

        VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

        //
        // We need to handle the return value. Devices with resoloutions finer
        // than their movement capability (like LBP-8 IV) get into a knot here,
        // attempting to y-move on each glyph. We pretend we got where we
        // wanted to be.
        //

        pPDev->ctl.ptCursor.x += ptlRem.x;
        pPDev->ctl.ptCursor.y += ptlRem.y ;

        //
        // Now set the flag.
        //
        pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;
    }

    //
    // Now start printing. The printing should be optimised for default
    // placement. In this case we assume that GDI has placed the glyphs
    // based upon their width and we don't need to update our cursor pos
    // after every glyph. we print all the glyphs and then move the cursor
    // to the last glyph position. If we know the width of the downloaded
    // glyph then we will update position the cursor at the end of the
    // glyphs box else we will just move to the last glyph cursor position.
    //
    // If the default placement is not set then we print a glyph and move. If
    // we know the width we do some optimization. we find out the new cursor
    // position, by adding the glyph width. If the new position matches that of
    // the next glyph we just update our cursor position else we move to the
    // the next glyph position.
    //

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    while (dwGlyphsToPrint)
    {
        pdlGlyph    = pTod->apdlGlyph[dwCurrGlyphIndex];

        if (bSetCursorForEachGlyph)
        {

            //
            // If we are printing top to down or right to left we need to
            // set the position.
            //

            if( pTod->flAccel & SO_VERTICAL )
            {
                //
                // When we are printing veritcal, only Y changes.X position is
                // same for all glyphs.
                //

                iX  = pTod->ptlFirstGlyph.x;
                iY  = pgp[dwNumGlyphsPrinted].ptl.y;

            }
            else if ( (pTod->flAccel & SO_HORIZONTAL) &&
                      (pTod->flAccel & SO_REVERSED) )
            {
                //
                // This is the Horizental reversed case(Right to Left). In this
                // case only x position changes.Y is set to first glyph's Y.
                //

                iX  = pgp[dwNumGlyphsPrinted].ptl.x;
                iY  = pTod->ptlFirstGlyph.y;

            }
            else
            {
                //
                // The Glyphs are not placed at default positions.Each glyph has
                // explicit X and Y.So we need to move.
                //

                iX  = pgp[dwNumGlyphsPrinted].ptl.x;
                iY  = pgp[dwNumGlyphsPrinted].ptl.y;
            }
            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

        }


        //
        // Default placement or we have moved to the correct position. Now Just
        // print the Glyph.
        //

        if ( !BPrintADLGlyph(pPDev, pTod, pdlGlyph) )
        {
            ERR(("UniFont:DwTrueTypeBMPGlyphOut:BPrintADLGlyph Failed\n"));
            goto ErrorExit;
        }

        //
        // If for each glyph, cursor has to be set, then update cursor position.
        // This may result in fewer Movement command, because if the next
        // glyph's position is at the updated cursor, we will not send any
        // Movement command.
        //

        if( pTod->flAccel & SO_VERTICAL )
            iY += pdlGlyph->wWidth;
        else
            iX  += pdlGlyph->wWidth;

        if (bSetCursorForEachGlyph)
        {
            //
            // If for each glyph, the cursor position has to be set, then iX
            // and iY are already updated. So just use them.
            //

            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE | MOVE_UPDATE, &ptlRem);

        }
        else if (dwGlyphsToPrint == 1) //Last Glyph
        {
            //
            // Set the cursor to the end of the last glyph. Only the X position
            // has to be updated. This has to be done only for default
            // placement, as for non default placement case, we update cursor
            // position after printing the glyph.For default placement use the
            // cursor position of the last glyph.In TextOut Call, for default
            // placement, we have already computed the position for each glyph.
            //

            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE | MOVE_UPDATE, &ptlRem);
        }

        //
        // Update the counters.
        //
        dwGlyphsToPrint--;
        dwNumGlyphsPrinted++;
        dwCurrGlyphIndex++;
    }



    //
    // If no failure then we would have printed all the glyphs.
    //
    ASSERTMSG( (dwNumGlyphsPrinted   == dwCopyOfGlyphsToPrint),
                ("UniFont:DwTrueTypeBMPGlyphOut: All glyphs are not printed"));

    FTRC(After Printing The values are:\n);
    FTST(dwGlyphsToPrint,%d);
    FTST(dwNumGlyphsPrinted,%d);
    FTST(dwCopyOfGlyphsToPrint,%d);
    FTST(dwCurrGlyphIndex,%d);

    ErrorExit:

    FTRC(********END TRACING DwTrueTypeBMPGlyphOut ***********\n);

    return    dwNumGlyphsPrinted;

}

BOOL
BSelectTrueTypeBMP(
    PDEV        *pPDev,
    PFONTMAP    pFM,
    POINTL*     pptl
)
 /*++
 Routine Description:
    To Select a TrueType Downloaded as Bitmap Font.
 Arguments:
     pPDev   Pointer to PDEV
     pDM     fontmap pointer.
     pptl    Point Size of the font, Not used.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet;
    //
    // Local Initialization.
    //
    bRet = FALSE;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        /*
         *  Call BSendFont to download the installed softfont.
         */

        if( !BSendDLFont( pPDev, pFM ) )
            return  FALSE;

        /*
         * Can now select the font:  this is done using a specific
         * ID.  The ID is stored in the FONTMAP structure. The calling
         * function has updated the standard variable so just send
         * CMD_SELECTFONTID command.
         */

        BUpdateStandardVar(pPDev, pFM, 0, 0, STD_CFID );
        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTID));
        bRet = TRUE;
    }


    return bRet;
}

BOOL
BDeselectTrueTypeBMP(
    PDEV        *pPDev,
    PFONTMAP    pFM
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet;
    COMMAND     *pCmd;

    //
    // Local Initialization.
    //
    bRet = FALSE;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        /*
         * Can now select the font:  this is done using a specific
         * ID.  The ID is stored in the FONTMAP structure. The calling
         * function has updated the standard variable so just send
         * CMD_SELECTFONTID command.
         */

        pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_DESELECTFONTID);

        if (pCmd)
        {
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_CFID);
            WriteChannel(pPDev,pCmd );
        }

        bRet = TRUE;
    }


    return bRet;

}

DWORD
DwDLTrueTypeBMPHeader(
    PDEV *pPDev,
    PFONTMAP pFM
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pFM     FontMap for All Font information

Return Value:
    This function returns the memory used to download this font.
    If this function fails, this function has to return 0,

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    DWORD      dwMem;

    //
    // Local Initialization.
    //

    dwMem = DwDLPCLHeader(pPDev, pFM->pIFIMet, pFM->ulDLIndex );

    return    dwMem;

}


DWORD
DwDLTrueTypeBMPGlyph(
    PDEV            *pPDev,
    PFONTMAP        pFM,
    HGLYPH          hGlyph,
    WORD            wDLGlyphId,
    WORD            *pwWidth
    )
/*++
Routine Description:

Arguments:
    pPDev       Pointer to PDEV
    pFM         FontMap data
    hGlyph      Handle to the Glyph.
    wDLGlyphId  Downloaded Glyph Id.
    pwWidth     Width of the Glyph. Update this parameter.

Return Value:
    The memory used to download thsi glyph.

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    DWORD           dwMem;
    TO_DATA         *pTod;
    GLYPHDATA       *pgd;
    PFONTMAP_TTB    pFMTB;
    DL_MAP          *pdm;

    //
    // Initialize Local Variables
    //

    dwMem       = 0;
    pTod        = PFDV->ptod;
    pgd         = NULL;
    pFMTB       = pFM->pSubFM;
    pdm         = pFMTB->u.pvDLData;;

    //
    // Check the Set FontID flag. If this flag is set that means the
    // CMD_SETFONTID command is send and we don't  need to set it again.
    // Else we should send this command as PCL glyph downloding needs this
    // command to be sent, before we download any glyph.
    //

    if (!(PFDV->flFlags & FDV_SET_FONTID))
    {
        pFM->ulDLIndex = pdm->wCurrFontId;
        BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_NFID);
        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
        PFDV->flFlags  |= FDV_SET_FONTID;

    }

    BUpdateStandardVar(pPDev, pFM, wDLGlyphId, 0, STD_GL);

    if( !FONTOBJ_cGetGlyphs( pTod->pfo, FO_GLYPHBITS, (ULONG)1,
                                                &hGlyph, &pgd ) ||
        !(*pwWidth = (WORD)IDLGlyph( pPDev, wDLGlyphId, pgd, &dwMem )) )
    {

        ERR(("Unifont!DwDLTrueTypeBMPGlyph: Downloading Glyph Failed\n"));
        return  0;
    }

    //
    //  Update memory consumption usage
    //
    ((PFONTMAP_TTB)pFM->pSubFM)->dwDLSize += dwMem;

    return    dwMem;

}


BOOL
BCheckCondTrueTypeBMP(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pso,
    IFIMETRICS  *pifi
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     FONTOBJ to download
    pso     StringObj
    pifi    IFI mertics.


Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    INT         iFontIndex;
    DL_MAP      *pdm;
    PFONTPDEV   pFontPDev;
    INT         iGlyphsDL;
    DWORD       cjMemUsed;
    BOOL        bRet;

    //
    // Local variables initialization.
    //
    iFontIndex = PtrToLong(pfo->pvConsumer) - 1;
    pFontPDev = PFDV;
    bRet = FALSE;

    if (pdm = PGetDLMapFromIdx (pFontPDev, iFontIndex))
    {
        //
        // Trunction may have happened.We won't download if the number glyphs
        // or Glyph max size are == MAXWORD.
        //

        if ( (pdm->cTotalGlyphs != MAXWORD) &&
             (pdm->wMaxGlyphSize != MAXWORD) &&
             (pdm->wFirstDLGId != MAXWORD) &&
             (pdm->wLastDLGId != MAXWORD) )
        {
            /*
             * Must now decide whether to download this font or not. This is
             * a guess work. We should try to findout the memory consumption.
             * Check on memory usage.  Assume all glyphs are the largest size:
             * this is pessimistic for a proportional font, but safe, given
             * the vaguaries of tracking memory usage.
             */

            ASSERTMSG((pdm->cTotalGlyphs && pdm->wMaxGlyphSize),\
                      ("pdm->cTotalGlyphs = %d, pdm->wGlyphMaxSize = %d\n",\
                      pdm->cTotalGlyphs,pdm->wMaxGlyphSize));

            iGlyphsDL = min( (pdm->wLastDLGId - pdm->wFirstDLGId),
                             pdm->cTotalGlyphs );

            cjMemUsed = iGlyphsDL * pdm->wMaxGlyphSize;

            if( !(pifi->flInfo & FM_INFO_CONSTANT_WIDTH) )
            {
                /*
                 *   If this is a proportionally spaced font, we should reduce
                 *  the estimate of memory size for this font.  The reason is
                 *  that the above estimate is the size of the biggest glyph
                 *  in the font.  There will (for Latin fonts, anyway) be many
                 *  smaller glyphs,  some much smaller.
                 */

                cjMemUsed /= PCL_PITCH_ADJ;
            }

            /*
             * We only download if the memory used for this font is less than
             * available memory.
             */

            if( (pFontPDev->dwFontMemUsed + cjMemUsed) > pFontPDev->dwFontMem )
            {
                WARNING(("UniFont!BCheckCondTrueTypeBMP:Not Downloading the font:TOO BIG for download\n"));
            }
            else
                bRet = TRUE;

        }
    }
    return bRet;
}



FONTMAP *
InitPFMTTBitmap(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    )
/*++
Routine Description:
    This routine initializes the True Type downloaded(as bitmap) font's PFM.
Arguments:
    pPDev       Pointer to PDEV
    pFontObj    FontObj pointer.

Return Value:
    Pointer to FONTMAP for success and NULL for failure.

Note:

    6/6/1997 -ganeshp-
        Created it.
--*/

{
    PFONTMAP     pfm;
    DWORD        dwSize;

    dwSize = sizeof(FONTMAP) + sizeof(FONTMAP_TTB);

    if ( pfm = MemAlloc( dwSize ) )
    {
        ZeroMemory(pfm, dwSize);
        pfm->dwSignature = FONTMAP_ID;
        pfm->dwSize      = sizeof(FONTMAP);
        pfm->dwFontType  = FMTYPE_TTBITMAP;
        pfm->pSubFM      = (PVOID)(pfm+1);
        pfm->ulDLIndex   = (ULONG)-1;

        //
        // These two entries are meaningless.
        //
        pfm->wFirstChar  = 0;
        pfm->wLastChar   = 0xffff;

        pfm->pfnGlyphOut           = DwTrueTypeBMPGlyphOut;
        pfm->pfnSelectFont         = BSelectTrueTypeBMP;
        pfm->pfnDeSelectFont       = BDeselectTrueTypeBMP;
        pfm->pfnDownloadFontHeader = DwDLTrueTypeBMPHeader;
        pfm->pfnDownloadGlyph      = DwDLTrueTypeBMPGlyph;
        pfm->pfnCheckCondition     = BCheckCondTrueTypeBMP;
        pfm->pfnFreePFM            = BFreeTrueTypeBMPPFM;

    }

    return pfm;

}

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\ctt2rle.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    ctt2rle.c

Abstract:

     Convert Win 3.1 CTT CTT_WTYPE_DIRECT format tables to NT 4.0  RLE spec.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/10/97 -ganeshp-
        Created

--*/

#include "font.h"


/*
 *   Some useful definitions for memory sizes and masks.
 */


#define DW_MASK    (DWBITS - 1)
#define OVERFLOW_SZ   sizeof( WORD )

NT_RLE  *
PNTRLE1To1(
    IN BOOL  bSymbolCharSet,
    int      iFirst,
    int      iLast
    )
/*++
Routine Description:
    Generates a simple mapping format for the RLE stuff.  This is
    typically used for a printer with a 1:1 mapping to the Windows
    character set.

Arguments:
    iFirst  The lowest glyph in the range.
    iLast   The last glyph in the range (inclusive).

Return Value:
    Address of NT_RLE structure allocated from heap;  NULL on failure.

Note:

    2/10/1997 -ganeshp-
        Created it.
--*/

{

    /*
     *    Operation is simple.   We create a dummy CTT that is a 1:1 mapping,
     *  then call the conversion function to generate the correct values.
     */

    int      iI;        /* Loop index */
    int      iMax;      /* Find the longest data length for CTT_WTYPE_COMPOSE */
    int      cHandles;  /* The number of handles we need */
    int      cjExtra;   /* Extra storage needed for offset modes */
    int      cjTotal;   /* Total amount of storage to be requested */
    int      iIndex;    /* Index we install in the HGLYPH for widths etc */
    int      cRuns;     /* Number of runs we create */
    NT_RLE  *pntrle;    /* Allocated memory, and returned to caller */
    UHG    uhg;         /* Clearer (?) access to HGLYPH contents */

    HGLYPH  *phg;       /* For working through the array of HGLYPHS */

    BYTE    *pb;        /* Current address in overflow area */
    BYTE    *pbBase;    /* Start of overflow area containing data */

    WCRUN   *pwcr;      /* Scanning the run data */

    DWORD   *pdwBits;   /* For figuring out runs */
    DWORD    cdwBits;   /* Size of this area */
    DWORD    cbWch;

    BOOL     bInRun;    /* For processing run accumulations */

    BYTE     ajAnsi[ 256 ];

    WCHAR    wchMin;           /* Find the first unicode value */
    WCHAR    wchMax;           /* Find the last unicode value */
    WCHAR    awch[ 512 ];      /* Converted array of points */

    ASSERT(iFirst == 0x20 && iLast == 0xFF);

    cHandles = iLast - iFirst + 1;

    if( cHandles > 256 )
        return  NULL;      /* This code does not handle that situation */

    cjExtra = 0;           /* Presume no extra storage required */

    /*
     *   We need to figure out how many runs are required to describe
     *  this font.  First obtain the correct Unicode encoding of these
     *  values,  then examine them to find the number of runs, and
     *  hence much extra storage is required.
     */

    ZeroMemory(awch, sizeof(awch));

    for( iI = 0; iI < cHandles; ++iI )
        ajAnsi[ iI ] = (BYTE)(iI + iFirst);

    #ifndef WINNT_40 //NT 5.0

    //
    // force Windows ANSI codepage
    //
    if( -1 == (cbWch = EngMultiByteToWideChar(1252,
                                              awch,
                                              (ULONG)(cHandles * sizeof(WCHAR)),
                                              (PCH) ajAnsi,
                                              (ULONG) cHandles)))
    {
        #if DBG
        DbgPrint( "EngMultiByteToWideChar failed \n");
        #endif
        return NULL;
    }
    cHandles = cbWch;

    #else // NT 4.0
    EngMultiByteToUnicodeN(awch,cHandles * sizeof(WCHAR),NULL,ajAnsi,cHandles);
    #endif //!WINNT_40


    /*
     *  Find the largest Unicode value, then allocate storage to allow us
     *  to  create a bit array of valid unicode points.  Then we can
     *  examine this to determine the number of runs.
     */

    if (bSymbolCharSet)
    {
        for (iI = 0; iI < NUM_OF_SYMBOL; iI ++)
        {
            awch[cHandles + iI] = SYMBOL_START + iI;
        }

        cHandles += NUM_OF_SYMBOL;
    }

    for( wchMax = 0, wchMin = 0xffff, iI = 0; iI < cHandles; ++iI )
    {
        //
        // Bugfix: Euro currency symbol doesn't print.
        // Euro currency symbols Unicode is U+20AC. NLS Unicode to Multibyte
        // table converts 0x80 (Multi byte) to U+20AC. We have to exclude
        // 0x80 from ASCII table. So that we don't substitute U+20AC with
        // device font 0x80.
        //
        if (awch[ iI ] == 0x20ac)
            continue;

        if( awch[ iI ] > wchMax )
            wchMax = awch[ iI ];

        if( awch[ iI ] < wchMin )
            wchMin = awch[ iI ];
    }

    /*
     *    Note that the expression 1 + wchMax IS correct.   This comes about
     *  from using these values as indices into the bit array,  and that
     *  this is essentially 1 based.
     */

    cdwBits = (1 + wchMax + DWBITS - 1) / DWBITS * sizeof( DWORD );

    if( !(pdwBits = (DWORD *)MemAllocZ(cdwBits )) )
    {
        return  NULL;     /*  Nothing going */
    }

    /*
     * Set bits in this array corresponding to Unicode code points
     */

    for( iI = 0; iI < cHandles; ++iI )
    {
        if (awch[ iI ] == 0x20ac)
            continue;

        pdwBits[ awch[ iI ] / DWBITS ] |= (1 << (awch[ iI ] & DW_MASK));
    }

    /*
     *     Now we can examine the number of runs required.  For starters,
     *  we stop a run whenever a hole is discovered in the array of 1
     *  bits we just created.  Later we MIGHT consider being a little
     *  less pedantic.
     */

    bInRun = FALSE;
    cRuns = 0;                 /* None so far */

    for( iI = 1; iI <= (int)wchMax; ++iI )
    {
        if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
        {
            /*
             * Not in a run: is this the end of one?
             */
            if( !bInRun )
            {
                /*
                 * It's time to start one
                 */
                bInRun = TRUE;
                ++cRuns;
            }
        }
        else
        {
            if( bInRun )
            {
                /*   Not any more!  */
                bInRun = FALSE;
            }
        }
    }


    cjTotal = sizeof( NT_RLE ) +
              (cRuns - 1) * sizeof( WCRUN ) +
              cHandles * sizeof( HGLYPH ) +
              cjExtra;

    //
    // Allocate Real NTRLE
    //
    if( !(pntrle = (NT_RLE *)MemAllocZ( cjTotal )) )
    {
        MemFree((LPSTR)pdwBits );

        return  pntrle;
    }

    //
    // For calculating offsets, we need these addresses
    //

    pbBase = (BYTE *)pntrle;

    //
    // FD_GLYPHSET contains the first WCRUN data structure,
    // so that cRun - 1 is correct.
    //
    phg = (HGLYPH *)(pbBase + sizeof( NT_RLE ) + (cRuns - 1) * sizeof( WCRUN ));
    pb = (BYTE *)phg + cHandles * sizeof( HGLYPH );

    pntrle->wType    = RLE_DIRECT;
    pntrle->bMagic0  = RLE_MAGIC0;
    pntrle->bMagic1  = RLE_MAGIC1;
    pntrle->cjThis   = cjTotal;
    pntrle->wchFirst = wchMin;          /* Lowest unicode code point */
    pntrle->wchLast  = wchMax;           /* Highest unicode code point */

    pntrle->fdg.cjThis = sizeof( FD_GLYPHSET ) + (cRuns - 1) * sizeof( WCRUN );
    pntrle->fdg.cGlyphsSupported = cHandles;
    pntrle->fdg.cRuns = cRuns;

    pntrle->fdg.awcrun[ 0 ].wcLow = pntrle->wchFirst;
    pntrle->fdg.awcrun[ 0 ].cGlyphs = (WORD)cHandles;
    pntrle->fdg.awcrun[ 0 ].phg = (HGLYPH*)((BYTE *)phg - pbBase);

    /*
     *   We now wish to fill in the awcrun data.  Filling it in now
     *  simplifies operations later on.  Now we can scan the bit array
     *  data, and so easily figure out how large the runs are and
     *  where abouts a particular HGLYPH is located.
     */

    bInRun = FALSE;
    cRuns = 0;                 /* None so far */
    iMax = 0;                  /* Count glyphs for address arithmetic */

    for( iI = 1; iI <= (int)wchMax; ++iI )
    {
        if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
        {
            /*
             * Not in a run: is this the end of one?
             */
            if( !bInRun )
            {
                /*
                 * It's time to start one
                 */
                bInRun = TRUE;
                pntrle->fdg.awcrun[ cRuns ].wcLow = (WCHAR)iI;
                pntrle->fdg.awcrun[ cRuns ].cGlyphs = 0;
                pntrle->fdg.awcrun[ cRuns ].phg = (HGLYPH*)((PBYTE)(phg + iMax) - pbBase);
            }
            pntrle->fdg.awcrun[ cRuns ].cGlyphs++;     /*  One more */
            ++iMax;
        }
        else
        {
            if( bInRun )
            {
                /*   Not any more!  */
                bInRun = FALSE;
                ++cRuns;             /* Onto the next structure */
            }
        }
    }

    if( bInRun )
        ++cRuns;                     /* It has finished now */

    /*
     *    Now go fill in the array of HGLYPHS.  The actual format varies
     *  depending upon the range of glyphs,  and upon the CTT format.
     */

    for( iIndex = 0, iI = iFirst;  iI <= iLast; ++iI, ++iIndex )
    {

        WCHAR  wchTemp;  /* For Unicode mapping */

        /*
         *    Need to map this BYTE value into the appropriate WCHAR
         *  value,  then look for the location of the phg that fits.
         */

        wchTemp = awch[ iIndex ];

        if (wchTemp == 0x20ac)
            continue;

        phg = NULL;                            /* Flag that we failed */
        pwcr = pntrle->fdg.awcrun;

        for( iMax = 0; iMax < cRuns; ++iMax )
        {
            if( pwcr->wcLow <= wchTemp &&
                (pwcr->wcLow + pwcr->cGlyphs) > wchTemp )
            {
                /*
                 * Found the range,  so now select the slot
                 */
                if (pwcr->phg)
                    phg = (HGLYPH*)((ULONG_PTR)pbBase + (ULONG_PTR)pwcr->phg) + wchTemp - pwcr->wcLow;
                else
                    phg = NULL;

                break;
            }
            ++pwcr;
        }

        if( phg == NULL )
            continue;             /* Should not happen */

        uhg.rd.b0     = *((PBYTE)&iI);
        uhg.rd.b1     = 0;
        uhg.rd.wIndex = (WORD)iIndex;
        *phg = uhg.hg;
    }

    if (bSymbolCharSet)
    {
        pwcr = pntrle->fdg.awcrun;

        phg = NULL;

        for ( iMax = 0; iMax < cRuns; ++iMax)
        {
            if (SYMBOL_START == pwcr->wcLow)
            {
                /*
                 * Found the range,  so now select the slot
                 */
                if (pwcr->phg)
                    phg = (HGLYPH*)((ULONG_PTR)pbBase + (ULONG_PTR)pwcr->phg);
                else
                    phg = NULL;

                break;
            }

            ++pwcr;
        }

        if (phg)
        {
            for (iI = SYMBOL_START; iI <= SYMBOL_END; iI ++, iIndex++, phg++)
            {
                uhg.rd.b0     = *((PBYTE)&iI);
                uhg.rd.b1     = 0;
                uhg.rd.wIndex = (WORD)iIndex;
                *phg = uhg.hg;
            }
        }
    }

    //
    // Error check
    //
    if( (pb - pbBase) > cjTotal )
    {
        ERR(( "Rasdd!ctt2rle: overflow of data area: alloc %ld, used %ld\n", cjTotal, pb - pbBase ));
    }

    MemFree( (LPSTR)pdwBits );

    return   pntrle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\dlutils.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    dlutils.c

Abstract:

    Download Modules utilts functions.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/02/97 -ganeshp-
        Created

--*/

#include "font.h"

#define HASH(num,tablesize)     (num % tablesize)


PDLGLYPH
PDLGNewGlyph (
    DL_MAP     *pDL
    )
/*++

Routine Description:


Arguments:

    pDL     Pointer to DownloadMap for the downloaded font.

Return Value:

    Pointer to the new DLGLYPH for success and NULL for failure.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    GLYPHTAB    *pGlyphTab;
    PDLGLYPH    pDLGlyph = NULL;

    if (pGlyphTab = pDL->GlyphTab.pGLTNext)
    {
        //
        //Go to the end of the List.
        //
        while (pGlyphTab && !pGlyphTab->cEntries)
            pGlyphTab = pGlyphTab->pGLTNext;
    }
    //
    //Allocate a new Chunk, if we need a new one.
    //
    if (!pGlyphTab)
    {
        INT cEntries = pDL->cHashTableEntries / 2; // Half the size of hash table.

        if (pGlyphTab = (GLYPHTAB *)MemAllocZ( sizeof(GLYPHTAB) +
                                               cEntries * sizeof(DLGLYPH) ))
        {
            PVOID pTemp;

            //
            //Skip the header.
            //
            pGlyphTab->pGlyph = (PDLGLYPH)(pGlyphTab + 1);
            pGlyphTab->cEntries = cEntries;

            //
            //Add in the begining of the list.
            //
            pTemp = pDL->GlyphTab.pGLTNext;
            pDL->GlyphTab.pGLTNext = pGlyphTab;
            pGlyphTab->pGLTNext = pTemp;
        }
        else
            ERR(("Unifont!PDLGNewGlyph:Can't Allocate the Glyph Chunk.\n"));
    }

    //
    //If the chunk has available entries, return the new pointer.
    //
    if (pGlyphTab && pGlyphTab->cEntries)
    {
        pDLGlyph = pGlyphTab->pGlyph;
        pGlyphTab->pGlyph++;
        pGlyphTab->cEntries--;
    }
    //
    // Initialize the hTTGlyphs to Invalid.
    //
    if (NULL != pDLGlyph)
        pDLGlyph->hTTGlyph = HGLYPH_INVALID;

    return pDLGlyph;
}

PDLGLYPH
PDLGHashGlyph (
    DL_MAP     *pDL,
    HGLYPH      hTTGlyph
    )
/*++

Routine Description:
    This routine searches the Hash table for a given Glyph. If the
    Glyph is not found in the Has table it creats an entry and add
    that into the list. The new entry is not filled.

Arguments:

    pDL         Pointer to DownloadMap Structure for the downloaded font.
    hTTGlyph    True Type Glyph Handle.

Return Value:
    Pointer to the DLGLYPH for success and NULL for failure.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    INT         iHashedEntry;
    BOOL        bFound;
    PDLGLYPH    pDLHashedGlyph = NULL,
                pDLG           = NULL;

    if (pDL->cHashTableEntries)
    {
        //
        // Hashing is done on TT handle.
        //
        iHashedEntry  =  HASH(hTTGlyph,pDL->cHashTableEntries);
        pDLG = pDLHashedGlyph = pDL->GlyphTab.pGlyph + iHashedEntry;

        //
        //Proceed if the pointer is valid
        //
        if (pDLHashedGlyph)
        {
            //
            // Check if this is the Glyph we are interested in.
            //  We should test if this glyph is new glyph or not.
            //
            if (!GLYPHDOWNLOADED(pDLHashedGlyph) )
            {
                //
                // If this is a new glyph which is not downloaded then return
                // this pointer.
                //
                bFound = TRUE;


            }
            else if (pDLHashedGlyph->hTTGlyph != hTTGlyph)
            {
                pDLG = pDLHashedGlyph->pNext;
                bFound = FALSE;

                //
                // Not the same Glyph, It's a Collision. Search the Linked list.
                //
                while (pDLG)
                {
                    if (pDLG->hTTGlyph == hTTGlyph)
                    {
                        bFound = TRUE;
                        break;
                    }
                    else
                        pDLG = pDLG->pNext;

                }
                //
                // If the Glyph is found in the linked list, return the pointer;
                // else create a new Glyph and add at the linked list. We add in
                // the begining.
                //

                if (!bFound)
                {
                    if ( pDLG = PDLGNewGlyph(pDL) )
                    {
                        PDLGLYPH pTemp;

                        //
                        // Don't Fill  in the Glyph. All the fields are set
                        // by the DownLoad Glyph function.
                        //

                        //
                        // Add the New Glyph at the begining of the list.
                        //
                        pTemp = pDLHashedGlyph->pNext;
                        pDLHashedGlyph->pNext = pDLG;
                        pDLG->pNext = pTemp;

                    }
                    else
                    {
                        pDLG = NULL;
                        ERR(("Unifont!PDLGHashGlyph:Can't Create the Glyph.\n"));
                    }
                }

            }

        }
    }
    ASSERTMSG(pDLG,("Unifont!PDLGHashGlyph:ERROR Null Hashed Glyph.\n"));
    return pDLG;
}

DL_MAP_LIST *
PNewDLMapList()
/*++
Routine Description:
    Allocate and initialise a new DL_MAP_LIST structure.  These
    are placed in a linked list (by our caller).

Arguments: None

Return Value:
    The address of the structure,  or NULL on failure.

Note:

    3/5/1997 -ganeshp-
        Created it.
--*/
{

    DL_MAP_LIST   *pdml;


    /*
     *    Little to do:  if we can allocate the storage, then set it to 0.
     */

    if( pdml = (DL_MAP_LIST *)MemAllocZ(sizeof( DL_MAP_LIST ) ) )
        return  pdml;
    else
        return NULL;
}

DL_MAP *
PNewDLMap (
    PFONTPDEV     pFontPDev,
    INT           *iFontIndex
    )
/*++

Routine Description:
    This routine return a new DL_MAP pointer.

Arguments:

    pFontPDev           Font Modules's PDEV.
    iFontIndex          Index of the new DL_MAP. The index is used to
                        identify the downloaded font.Filled by this function.
                        Zero is first index.
Return Value:

    Pointer to DL_MAP for success and NULL for failure
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    DL_MAP_LIST  *pdml;          // The linked list of font information
    DL_MAP       *pdm;           // Individual map element

    pdml = pFontPDev->pvDLMap;
    *iFontIndex = 0;
    pdm         = NULL;

    //
    // If no DL List, create one.
    //
    if( pdml == NULL )
    {
        //
        // None there,  so create an initial one.
        //
        if( pdml = PNewDLMapList() )
        {
            pFontPDev->pvDLMap = pdml;
        }
        else
        {
            ERR(("Unifont!PNewDLMap(1):Can't Allocate the DL_MAP_LIST Chunk.\n"));
        }

    }
    //
    // The list should be not null. else return NULL.
    //
    if (pdml)
    {
        for( pdml = pFontPDev->pvDLMap; pdml->pDMLNext; pdml = pdml->pDMLNext )
        {
            //
            // While looking for the end,  also count the number we pass.
            //
            *iFontIndex += pdml->cEntries;
        }

        if( pdml->cEntries >= DL_MAP_CHUNK )
        {
            if( !(pdml->pDMLNext = PNewDLMapList()) )
            {
                ERR(("Unifont!PNewDLMap(2):Can't Allocate the DL_MAP_LIST Chunk.\n"));
                return  NULL;
            }
            //
            // The new current model.
            //
            pdml = pdml->pDMLNext;
            //
            // Add in the full one.
            //
            *iFontIndex += DL_MAP_CHUNK;
        }

        pdm = &pdml->adlm[ pdml->cEntries ];
        //
        // Increment the iFontIndex first as the it is 0 based.
        // For 1st entry the index will be 0.
        //
        *iFontIndex += pdml->cEntries;
        pdml->cEntries++;
    }
    return pdm;
}


VOID
VFreeDLMAP (
    DL_MAP   *pdm
    )
/*++

Routine Description:
    This function fress DL_MAP structure contents - but NOT the map.

Arguments:

    pdm  Pointer to  DL_MAP structure whose contents has to be freed.

Return Value:

    Nothing.

Note:

    01/15/97 -ganeshp-
        Created it.
--*/
{

    FONTMAP    *pFM;
    PVOID       pTemp;
    GLYPHTAB    *pGT;
    ULONG_PTR     iTTUniq;


    /*
     *   Simply free the storage contained within the FONTMAP structure.
     */

    if (pdm )
    {
        if (pFM = pdm->pfm)
        {
            //
            // Try to Free what we allocated.
            //
            MEMFREEANDRESET((LPSTR)pFM->pIFIMet );

            if (pFM->pfnFreePFM)
            {
                //
                // Free The pfm by calling the helper function.
                //
                pFM->pfnFreePFM(pFM);
            }
            else
            {
                ERR(("UniFont!VFreeDLMAP: NUll pfnFreePFM function pointer, Can't free pFM\n"));

                //
                // Try to Free what we know about.
                //
                MemFree( (LPSTR)pFM);
            }
        }


        //
        // Free the Glyph Table.
        //
        pGT = pdm->GlyphTab.pGLTNext;

        while (pGT)
        {
            pTemp = pGT->pGLTNext;
            MemFree((LPSTR)pGT);
            pGT = pTemp;

        }

        //
        // Now free the base hash table.
        //
        MEMFREEANDRESET( (LPSTR)pdm->GlyphTab.pGlyph );


        //
        // Zero the memory and make cGlyphs to -1 so that it's not used.
        // Save the iTTUniq for future reference.
        //
        iTTUniq     = pdm->iTTUniq;
        ZeroMemory(pdm, sizeof(DL_MAP));
        pdm->iTTUniq = iTTUniq;
        pdm->cGlyphs = -1;

    }

    return;
}

VOID
VFreeDL(
    PDEV  *pPDev
    )
/*++

Routine Description:
    Function to free up all the downloaded information.  Basically
    work through the list,  calling VFreeDLMAP for each entry.

Arguments:

    pPDev   Access to our data.

Return Value:

    Nothing.

Note:

    01/15/97 -ganeshp-
        Created it.
--*/
{

    DL_MAP_LIST     *pdml;                 /* The linked list of font information */
    PFONTPDEV       pFontPDev = PFDV;        /* It's used a few times */


    if( pdml = pFontPDev->pvDLMap )
    {
        /*
         *    There is downloaded data,  so off we go.
         */

        INT      iI;

        /*
         *    Scan through each of the arrays of header data.
         */

        while( pdml )
        {

            DL_MAP_LIST  *pdmlTmp = NULL;

            /*
             *    Scan through each entry in the array of header data.
             */

            for( iI = 0; iI < pdml->cEntries; ++iI )
                VFreeDLMAP( &pdml->adlm[ iI ] );

            pdmlTmp = pdml;
            //
            // Remember the next one
            //
            pdml = pdml->pDMLNext;

            MemFree((LPSTR)pdmlTmp);

        }
    }
    //
    //  Reset Download specific variables.
    //
    pFontPDev->pvDLMap = NULL;
    pFontPDev->iNextSFIndex = pFontPDev->iFirstSFIndex;
    pFontPDev->iUsedSoftFonts = 0;
    pFontPDev->ctl.iFont = INVALID_FONT;
    pFontPDev->ctl.iSoftFont = -1;

    return;

}

DL_MAP *
PGetDLMapFromIdx (
    PFONTPDEV   pFontPDev,
    INT         iFontIndex
    )
/*++

Routine Description:
    This routine return a  DL_MAP pointer, given it's index..

Arguments:
    pFontPDev           Font PDEV.
    iFontIndex          Index of the  DL_MAP. The index is used to
                        identify the downloaded font. Zero is first index.
Return Value:

    Pointer to DL_MAP for success and NULL for failure
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    DL_MAP_LIST  *pdml;          // The linked list of font information
    DL_MAP       *pdm;           // Individual map element

    pdml = pFontPDev->pvDLMap;
    pdm  = NULL;

    //
    // If the index is negative that means this is a new font. So we should
    // search sequentially.
    //
    if (iFontIndex < 0)
        return NULL;

    //
    // The list should be not null. else return NULL.
    //
    while( pdml )
    {
       //
       // Is this chunk the one containing the entry?
       //
       if( iFontIndex >= pdml->cEntries )
       {
           //
           // Not this one, so onto the next.
           //
           iFontIndex -= pdml->cEntries;

           pdml = pdml->pDMLNext;
       }
       else
       {
           //
           // We got it!
           //
           pdm = &pdml->adlm[ iFontIndex ];

           break;
       }
    }

    return pdm;
}


BOOL
BSameDLFont (
    PFONTPDEV       pFontPDev,
    FONTOBJ         *pfo,
    DL_MAP          *pdm
    )
/*++

Routine Description:
    This routine finds out if input DL_MAP represents the FONTOBJ or not.

Arguments:

    pFontPDev           Font Modules's PDEV.
    pfo                 FontObj.
    pdm                 Individual download map element.

Return Value:

    TRUE if DL_MAP represents FONTOBJ else FALSE.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    //
    // The checks are different for download TT as outline and download
    // as TT OutLine. For Download a Bitmap we check iUniq and for download
    // as TT Outline we have to use iTTUniq. If the same printer can support
    // both format we may download the font as any one of the format.
    //

    FONTMAP *pfm = pdm->pfm;

    if (pfm)
    {
        if (pfm->dwFontType == FMTYPE_TTBITMAP)
        {
            return ((pdm->iUniq == pfo->iUniq) && (pdm->iTTUniq == pfo->iTTUniq));
        }
        else if (pfm->dwFontType == FMTYPE_TTOUTLINE)
        {
            //
            // The truetype font is equivalent if the iTTUniq is the same *and*
            // the font-type field matches.
            //
            PFONTMAP_TTO pFMTTO = (PFONTMAP_TTO) pdm->pfm->pSubFM;
            return (pdm->iTTUniq == pfo->iTTUniq) &&
                   (pFMTTO->flFontType == pfo->flFontType);
        }
        else
        if (pfm->dwFontType == FMTYPE_TTOEM)
        {
            PFONTMAP_TTOEM  pTTOEM = pfm->pSubFM;
            ASSERT(pTTOEM);

            //
            // TrueType Outline for OEM
            //
            if (pTTOEM->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
            {
                return (pdm->iTTUniq == pfo->iTTUniq) &&
                       (pTTOEM->flFontType == pfo->flFontType);
            }
            else
            //
            // Bitmap for OEM
            //
            if (pTTOEM->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
            {
                return ((pdm->iUniq == pfo->iUniq) &&
                        (pdm->iTTUniq == pfo->iTTUniq));
            }
        
        }
    }

    return FALSE;

}

DL_MAP *
PGetDLMap (
    PFONTPDEV       pFontPDev,
    FONTOBJ         *pfo
    )
/*++

Routine Description:
    This routine searches a FontObj in DL_MAP_LIST.If the FONTOBJ is found
    (Means this font has been downloaded), then this function return the
    DL_MAP pointer. If FONTOBJ can't be found (New font which is not
    downloaded), a new DL_MAP * is returned. In Case of error we return
    NULL. In that case we shouldn't download. A Bad DL_MAP is marked  by
    having cGlyphs value to -1. This function will also set pvConsumer field
    of pfo, if a new DL_MAP is returned.
Arguments:

    pFontPDev           Font Modules's PDEV.
    pfo                 FontObj.

Return Value:

    Pointer to DL_MAP for success and NULL if no match.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    DL_MAP      *pdm;           // Individual download map element.
    BOOL        bFound;         // The font is found or not in the list.
    INT         iFontIndex;     // Download Font Index in DL_MAP List.

    //
    // All we have to do is look into the DL_MAP list and find a DL_MAP with
    // same signature. For optimization purposes we tag the pvConsumer field
    // with the FontIndex, which is index into the list. For example for first
    // downloaded font pvConsumer is set to 1. As pvConsumer field is not
    // cached for each DC, we will use this field with caution. So if pvConsumer
    // is > 0, then we get the DL_MAP using pvConsumer and then check iUniq and
    // iTTUniq. We only use the DL_MAP if these fields also match. Else we do
    // an exausitive linear search in DL_MAP list. This approach will optimize
    // for normal printing, because most of the time only one job is getting
    // printed.
    //

    bFound  = FALSE;

    if( iFontIndex = PtrToLong(pfo->pvConsumer) )
    {
        /*
         *   As we control the pvConsumer field,  we have the choice
         *   of what to put in there.  SO,  we decide as follows:
         *    > 0 - index into our data structures for good DL_MAP.
         *      0 - virgin data,  so look to see what to do.
         *    < 0 - Index into our data str for Bad FONT. NO download.
         *          In this case cGlyphs field is -1.
         */

        if( iFontIndex < 0 )
        {
            //
            // This seems like a bad font. In that case verify.
            // Make the fontIndex +ve and 0 Based.
            //
            iFontIndex = (-iFontIndex);
            --iFontIndex;
        }
        else
        {
            //
            //  pvConsumer is 1 based.
            //
            --iFontIndex;

        }

        if ( pdm = PGetDLMapFromIdx (pFontPDev, iFontIndex))
        {
            //
            //  Do not process this one, if we had encountered problem in past.
            // Make sure that the we are dealing with same TT font.
            //
            if (pdm->cGlyphs == -1 && (pdm->iTTUniq == pfo->iTTUniq))
            {
                //
                // Set the pvConsumer to a -ve index. make it 1 based first.
                //
                pfo->pvConsumer = (PLONG_PTR)IntToPtr((-(iFontIndex +1)));
                return NULL;
            }

            //
            // We have found a DL_MAP for this font. So now verify it.
            //
            if ( BSameDLFont (pFontPDev, pfo, pdm ) )
            {
                //
                // This DL_MAP matches the font. So return the pointer.
                //

                bFound = TRUE;
            }

        }

    }

    //
    // If the font is not cached, search sequentially through the list.
    //
    if (!bFound)
    {
        DL_MAP_LIST     *pdml;   // The linked list of font information
        INT             iI;

        //
        // This case happens when the pvConsumer field is not correct
        // for this DC. The GDI doesn't gaurantee that the pvConsumer
        // will be reset for each job.So we need to do a linear search.
        //

        pdml = pFontPDev->pvDLMap;

        iFontIndex = 1;

        while (pdml)
        {

            for( iI = 0; iI < pdml->cEntries; ++iI )
            {
                pdm = &pdml->adlm[ iI ];
                if ( BSameDLFont (pFontPDev, pfo, pdm ) )
                {
                    //
                    // This DL_MAP matches the font. So return the pointer.
                    // we also need to reset pvConsumer. iFontIndex is
                    // one base same as pvConsumer.
                    //

                    bFound = TRUE;
                    pfo->pvConsumer = (PLONG_PTR)IntToPtr(iFontIndex);
                    break;
                }
                iFontIndex++;

            }
            //
            // Check if we have found the correct font or not.
            //
            if (bFound)
                break;
            else
                pdml = pdml->pDMLNext;
        }
    }

    //
    // Both cached and sequential search failed. So this is a new one.
    // Try downloading.
    //
    if (!bFound)
    {
        INT         iFontIndex;     // Download Font Index in DL_MAP List.

        //
        // The fontobj doesn't match the DL_MAP, or this is a new font.
        // So get a new one.
        //

        if (!(pdm =   PNewDLMap (pFontPDev,&(iFontIndex)) ))
        {
            ERR(("UniFont!PGetDLMap:Can't Create a new DL_MAP.\n"));
            iFontIndex = -1;
        }
        //
        // FontIndex returned by PNewDLMap is 0 based, but pvConsumer is one
        // base. So add one.
        //
        pfo->pvConsumer = (PLONG_PTR)IntToPtr((iFontIndex + 1));
    }

    return pdm;
}


BOOL
BInitDLMap (
    PDEV            *pPDev,
    FONTOBJ         *pfo,
    DL_MAP          *pdm
    )
/*++

Routine Description:
    Initializes a DL_MAP structure.

Arguments:
    pPDev               Pointer to PDEV.
    pfo                 FontObj.
    pdm                 DL_MPA to be initialized.

Return Value:

    TRUE  success and FALSE for failure.
Note:

    06/09/97 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet = FALSE;
    DWORD       iGlyphPerSoftFont; // Total number of glyph per downloaded font.
    FONTINFO    fi;           // Details about this font.
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    INT         iDL_ID;

    pdm->iUniq              = pfo->iUniq;
    pdm->iTTUniq            = pfo->iTTUniq;

    FONTOBJ_vGetInfo( pfo, sizeof( fi ), &fi );
    //
    // Trunction may happen. But we are fine. We won't download if the number
    // glyphs or  max size are more than MAXWORD.
    //

    pdm->cTotalGlyphs = (WORD)fi.cGlyphsSupported;
    pdm->wMaxGlyphSize = (WORD)fi.cjMaxGlyph1;


    //
    // In GPD if the DLSymbolSet has valid value, then we have to set
    // the Min and Max Glyph IDs, using the Symbol Set, else we will use
    // the GPD entries,dwMinGlyphID and dwMaxGlyphID.
    //
    if (pPDev->pGlobals->dlsymbolset != UNUSED_ITEM)
    {
        if (pPDev->pGlobals->dlsymbolset == DLSS_PC8)
        {
            //
            // Symbol Set is DLSS_PC8.
            //

            pdm->wNextDLGId    =
            pdm->wFirstDLGId   =  32;
            pdm->wLastDLGId    =  255;

        }
        else
        {
            //
            // Symbol Set is DLSS_ROMAN8.
            //

            pdm->wNextDLGId    =
            pdm->wFirstDLGId   =  33;
            pdm->wLastDLGId    =  127;
        }
    }
    else
    {
        //
        // DLsymbolset Not defined. Use Min and Max Glyph Ids.
        //
        pdm->wFirstDLGId        = pdm->wNextDLGId
                                = (WORD)pPDev->pGlobals->dwMinGlyphID;
        pdm->wLastDLGId         = (WORD)pPDev->pGlobals->dwMaxGlyphID;

        if( !(pFontPDev->flFlags & FDV_ROTATE_FONT_ABLE ))
        {
            //
            // If the printer can't rotate font then we assume that it only
            // supports Roman 8 limited character set. This hack is needed for
            // old PCL printers.
            //
            pdm->wFirstDLGId        = pdm->wNextDLGId
                                    = 33;
            pdm->wLastDLGId         = 127;

        }


    }

    //
    // Find out that font is bounded or not. We do this by finding out
    // how many glyphs we can download per soft font. Add 1 as range is
    // inclusive.
    //

    iGlyphPerSoftFont =  (pdm->wLastDLGId - pdm->wFirstDLGId) +1;

    if (iGlyphPerSoftFont < MIN_GLYPHS_PER_SOFTFONT)
    {
        //
        // This is an error condition. Basically we don't want to download
        // if there are less than 64 glyphs per downloaded font.return FALSE.
        //
        ERR(("UniFont:BInitDLMap:Can't download any glyph,bad GPD values\n"));
        goto ErrorExit;;
    }
    else
    {
        //
        // There are more than  64 glyphs per downloded font. So find out
        // if it's bounded or unbounded. If the number of Glyphs is >255
        // then the font is unbounded else it's bounded.
        //
        if (iGlyphPerSoftFont > 255)
           pdm->wFlags             |=  DLM_UNBOUNDED;
        else
            pdm->wFlags            |=  DLM_BOUNDED;

    }

    if( (iDL_ID = IGetDL_ID( pPDev )) < 0 )
    {
        //
        //  We have run out of soft fonts - must not use any more.
        //
        ERR(("UniFont:BInitDLMap:Can't download Font, No IDs available\n"));
        goto ErrorExit;;
    }

    pdm->wBaseDLFontid = (WORD)iDL_ID;

    //
    // Hashtable is allocated based upon the number of Glyphs in the font.
    //
    if (pdm->cTotalGlyphs >= 1024)
        pdm->cHashTableEntries = HASHTABLESIZE_3;
    else if (pdm->cTotalGlyphs >= 512)
        pdm->cHashTableEntries = HASHTABLESIZE_2;
    else
        pdm->cHashTableEntries = HASHTABLESIZE_1;

    //
    // Now allocate the Glyph Table. We only allocate the hash table.
    //
    if (pdm->GlyphTab.pGlyph = (DLGLYPH *)MemAllocZ(
                               pdm->cHashTableEntries * sizeof(DLGLYPH)) )
    {
        INT     iIndex;
        PDLGLYPH pGlyph;

        //
        // Set the hTTGlyph to HGLYPH_INVALID as 0 is a valid handle for HGLYPH.
        // Also set the cGlyphs(Number of downloded Glyphs) to 0.
        //
        pGlyph = pdm->GlyphTab.pGlyph;
        for (iIndex = 0; iIndex < pdm->cHashTableEntries; iIndex++,pGlyph++)
            pGlyph->hTTGlyph = HGLYPH_INVALID;

        bRet = TRUE;
    }
    else
    {
        //
        // Error case. DL_MAP will be freeed by the caller, IDownloadFont.
        //
        ERR(("UniFont:BInitDLMap:Can't Allocate Glyph Hash table\n"));
    }


    ErrorExit:
    return bRet;
}


INT
IGetDL_ID(
    PDEV    *pPDev
    )
/*++
Routine Description:
     Returns the font index to use for the next download font.  Verifies
     that the number is within range.

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    Font index if OK,  else -1 on error (over limit).

Note:

    3/5/1997 -ganeshp-
        Created it.
--*/

{
    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    INT       iSFIndex;

    if( pFontPDev->iNextSFIndex > pFontPDev->iLastSFIndex ||
        pFontPDev->iUsedSoftFonts >= pFontPDev->iMaxSoftFonts )
    {
        ERR(( "softfont limit reached (%d/%d, %d/%d)\n",
                   pFontPDev->iNextSFIndex, pFontPDev->iLastSFIndex,
                   pFontPDev->iUsedSoftFonts, pFontPDev->iMaxSoftFonts ));
        return  -1;                     /*  Too many - stop now */
    }

    /*
     *   We'll definitely use this one,  so add to the used count.
     */

    pFontPDev->iUsedSoftFonts++;
    iSFIndex = pFontPDev->iNextSFIndex++;

    return   iSFIndex;
}

BOOL
BPrintADLGlyph(
    PDEV        *pPDev,
    TO_DATA     *pTod,
    PDLGLYPH    pdlGlyph
    )
/*++
Routine Description:
This functions output a single downloaded Glyph.

Arguments:
 pPDev      Unidriver PDEV
 pTod       Textout Data.
 pdlGlyph   Download Glyph information


Return Value:
TRUE for success and FALSE for failure.

Note:

8/12/1997 -ganeshp-
    Created it.
--*/
{
    FONTMAP         *pFM;       // FontMap of interest
    DL_MAP          *pdm;       // Details of this downloaded font.
    FONTPDEV        *pFontPDev; // Font PDev.
    BOOL            bRet;       // Return Value of this function.
    WORD            wDLGlyphID;  // Downloaded Glyph ID.

    //
    // Make sure that parameters are valid.
    //
    if (NULL == pPDev   ||
        NULL == pTod    ||
        NULL == pdlGlyph )
    {
        return FALSE;
    }

    //
    // Initialize locals
    //
    bRet        = TRUE;
    pFontPDev   = PFDV;
    pFM         = pTod->pfm;
    wDLGlyphID  = pdlGlyph->wDLGlyphID;

    //
    // Get pdm
    //
    if (pFM->dwFontType == FMTYPE_TTOUTLINE)
    {
        PFONTMAP_TTO pFMTO = (PFONTMAP_TTO) pFM->pSubFM;
        pdm = (DL_MAP*) pFMTO->pvDLData;
    }
    else if (pFM->dwFontType == FMTYPE_TTBITMAP)
    {
        PFONTMAP_TTB pFMTB = (PFONTMAP_TTB) pFM->pSubFM;
        pdm = pFMTB->u.pvDLData;
    }
    else if (pFM->dwFontType == FMTYPE_TTOEM)
    {
        PFONTMAP_TTOEM pFMTOEM = (PFONTMAP_TTOEM) pFM->pSubFM;
        pdm = pFMTOEM->u.pvDLData;
    }
    else
    {
        ASSERTMSG(FALSE, ("Incorrect font type %d in BPrintADLGlyph.\n",
            pFM->dwFontType));
        pdm = NULL;
        bRet = FALSE;
    }

    //
    // Before sending a glyph we have to make sure that this glyph is in
    // selected soft font. We have to do this only for segmented fonts, i.e
    // multiple softfonts for one system fonts. If BaseFontId is not same as
    // CurrFontId, that means the font has atleat two softfonts associated.
    // Then we need to check for currently selected SoftFont. If the fontid of
    // the glyph is different that the selected one, we need to select the new
    // softfontid.
    //
    // GLYPH_IN_NEW_SOFTFONT is defined as :
    // if ( (pdm->wFlags & DLM_BOUNDED) &&
    //     (pdm->wBaseDLFontid != pdm->wCurrFontId) &&
    //     (pdlGlyph->wDLFontId != (WORD)(pFontPDev->ctl.iSoftFont)) )
    //

    if (bRet && GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph))
    {
        //
        // Need to select the new softfont.We do this by setting pfm->ulDLIndex
        // to new softfontid.
        //

        pFM->ulDLIndex = pdlGlyph->wDLFontId;
        BNewFont(pPDev, pTod->iFace, pFM, 0);
    }

    //
    // The Soft font selection is done. So now sent the downloaded Glyph Id.
    // We have to be a bit careful about the size of the Glyph ID. If the
    // Glyphs ID is less than 256, then we need to send a BYTE else a WORD.
    //

    if (bRet)
    {
        if (wDLGlyphID > 0xFF)
        {
            //
            // Send as WORD.
            //

            SWAB (wDLGlyphID);

            bRet = WriteSpoolBuf( pPDev, (BYTE*)&wDLGlyphID, sizeof( wDLGlyphID ) )
	                    == sizeof( wDLGlyphID );

        }
        else
        {
            //
            // Send as Byte.
            //

            BYTE   bData;

            bData = (BYTE)wDLGlyphID;

            bRet = WriteSpoolBuf( pPDev, &bData, sizeof( bData ) ) ==
	                             sizeof( bData );
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\download.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:
       download.c

Abstract:

   Functions associated with downloading fonts to printers.  This
   specifically applies to LaserJet style printers.  There are really
   two sets of functions here:  those for downloading fonts supplied
   by the user (and installed with the font installer), and those
   we generate internally to cache TT style fonts in the printer.


Environment:

    Windows NT Unidrv driver

Revision History:

    01/11/97 -ganeshp-
        Created

--*/

#include "font.h"

#define DL_BUF_SZ       4096          /* Size of data chunks for download */

//
//   Local function prototypes.
//


IFIMETRICS*
pGetIFI(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    BOOL    bScale
    );

BOOL
BDownLoadAsTT(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    );

BOOL
BDownLoadAsBmp(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    );

BOOL
BDownLoadOEM(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT       iMode
    );
//
// Macro Definition.
//
#ifdef WINNT_40

#else

#endif //WINNT_40
#define GETWIDTH(pPtqD) ((pPtqD->x.HighPart + 8) / 16)

//
// Main functions
//


BOOL
BDLSecondarySoftFont(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pstro,
    DL_MAP      *pdm
    )
/*++
Routine Description:
    This routine download the secondary soft font. If the True type font has
    more Glyphs that what we can download in soft font then we download a
    secondary font after we use all the glyphs in the current soft font. This
    function also sets the new soft font index(pFM->ulDLIndex) to be used.

Arguments:
    pPDev       Pointer to PDEV
    pfo         The font of interest.
    pdm         Individual download font map element

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet;
    FONTMAP     *pFM;

    //
    // Initialization of Locals .
    //
    bRet   = FALSE;
    pFM = pdm->pfm;


    //
    // PFM->ulDLIndex is used to download new soft font and is set in following
    // download functions.
    //
    if (pFM->dwFontType == FMTYPE_TTBITMAP)
    {
        if (!BDownLoadAsBmp(pPDev, pfo, pstro,pdm,DL_SECONDARY_SOFT_FONT) )
        {
            ERR(("UniFont!BDLSecondarySoftFont:BDownLoadAsBmp Failed\n"));
            goto ErrorExit;

        }

    }
    else if (pFM->dwFontType == FMTYPE_TTOUTLINE)
    {
        if (!BDownLoadAsTT(pPDev, pfo, pstro,pdm,DL_SECONDARY_SOFT_FONT) )
        {
            ERR(("UniFont!BDLSecondarySoftFont:BDownLoadAsTT Failed\n"));
            goto ErrorExit;

        }

    }

    else if (pFM->dwFontType == FMTYPE_TTOEM)
    {
        if (!BDownLoadOEM(pPDev, pfo, pstro,pdm,DL_SECONDARY_SOFT_FONT) )
        {
            ERR(("UniFont!BDLSecondarySoftFont:BDownLoadAsOEM Failed\n"));
            goto ErrorExit;

        }
    }
    //
    // Reset the iSoftfont to -1, so that we send select font command, before
    // outputting the Character.
    //
    PFDV->ctl.iSoftFont = -1;

    bRet = TRUE;

    ErrorExit:
    return bRet;
}


BOOL
BDownloadGlyphs(
    TO_DATA  *ptod,
    STROBJ   *pstro,
    DL_MAP   *pdm
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pdm     DL_MAP struct, all about downloading is in this structure.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    PDEV        *pPDev;             // Our PDevice
    FONTOBJ     *pfo;               // Font OBJ
    GLYPHPOS    *pgp;               // Value passed from gre
    FONTMAP     *pFM;               // Font's details
    ULONG       cGlyphs;            // Number of glyphs to process
    ULONG       cGlyphIndex;        // Index to the current glyph.
    WORD        wWidth;             // Width of the Glyph.
    BOOL        bMore;              // Getting glyphs from engine loop
    PDLGLYPH    *ppdlGlyph;         // array of DLGLYPHs pointers.
    DWORD       dwMem;              // Memory require to download the glyph.
    DWORD       dwTotalEnumGlyphs;
    POINTQF     *pPtqD;             // Advance Width Array.
    BOOL        bRet;               // Return Value
    PWCHAR      pwchUnicode;

    //
    // Initialize Local variables.
    //
    pPDev  = ptod->pPDev;
    pfo    = ptod->pfo;
    pFM    = ptod->pfm;
    dwTotalEnumGlyphs =
    cGlyphs           =
    cGlyphIndex       =
    dwMem             = 0;
    pPtqD             = NULL;

    ASSERTMSG((pPDev && pfo && pstro && pFM),\
              ("\nUniFont!BDownloadGlyphs: Wrong values in ptod.\n"));

    bRet   = FALSE;

    //
    // Allocate the array for DLGLYPHs.
    //
    if (!( ppdlGlyph = MemAllocZ( pstro->cGlyphs * sizeof(DLGLYPH *)) ))
    {
        ERR(("UniFont:BDownloadGlyphs: MemAlloc for ppdlGlyph failed\n"));
        goto ErrorExit;
    }

    ptod->apdlGlyph = ppdlGlyph;

    //
    // First Job is to do the enumeration of the glyphs. and then
    // start downloading.
    //

    #ifndef WINNT_40  // NT 5.0

    if (pPtqD = MemAllocZ( pstro->cGlyphs * sizeof(POINTQF)) )
    {
        //
        // Memory Allocation succeded for width array. So call GDI to get
        // the width.
        //
        if (!STROBJ_bGetAdvanceWidths(pstro, 0,  pstro->cGlyphs, pPtqD))
        {
            ERR(("UniFont:BDownloadGlyphs: STROBJ_bGetAdvanceWidths failed\n"));
            goto ErrorExit;
        }
    }
    else
    {
        ERR(("UniFont:BDownloadGlyphs:Memory allocation for width array failed\n"));
        goto ErrorExit;
    }

    #endif //!WINNT_40

    pwchUnicode = pstro->pwszOrg;
    STROBJ_vEnumStart(pstro);

    do
    {
        #ifndef WINNT_40  // NT 5.0

        bMore = STROBJ_bEnumPositionsOnly( pstro, &cGlyphs, &pgp );

        #else             // NT 4.0

        bMore = STROBJ_bEnum( pstro, &cGlyphs, &pgp );

        #endif //!WINNT_40

        dwTotalEnumGlyphs += cGlyphs;

        while ( cGlyphs )
        {

            PDLGLYPH pdlg;
            HGLYPH hTTGlyph;

            #ifdef WINNT_40    // NT 4.0

            GLYPHDATA *pgd;

            if( !FONTOBJ_cGetGlyphs( ptod->pfo, FO_GLYPHBITS, (ULONG)1,
                                                  &pgp->hg, &pgd ) )
            {
               ERR(( "UniFont:BDownloadGlyphs:FONTOBJ_cGetGlyphs fails\n" ))
               goto ErrorExit;
            }
            pPtqD = &(pgd->ptqD);

            #endif //WINNT_40

            hTTGlyph = pgp->hg;
            //
            // search the Glyph in hash table.
            //
            pdlg = *ppdlGlyph = PDLGHashGlyph (pdm,hTTGlyph );

            if (pdlg)
            {
                //
                // We have got a valid Glyph. Check if this is already
                // downloaded or not.
                //
                if (!GLYPHDOWNLOADED(pdlg))
                {
                    //
                    // If the glyph is not downloaded,then fill Glyph structure
                    // and download the Glyph.
                    //

                    if (pdm->wFlags & DLM_UNBOUNDED)
                    {
                        //
                        // Unbounded font. We just have to make sure that
                        // download glyphID is valid. If it's not valid then
                        // we fail the call.
                        //
                        if (pdm->wNextDLGId > pdm->wLastDLGId)
                        {
                            ERR(("UniFont:BDownloadGlyphs:Unbounded Font,no more Glyph Ids\n"));
                            goto ErrorExit;

                        }
                        //
                        // Fill in the Glyph structure. We only set wDLGlyphID.
                        // The new Glyph definition has FontId also. So set that
                        // one also.
                        //
                        pdlg->wDLGlyphID = pdm->wNextDLGId;
                        pdlg->wDLFontId = pdm->wBaseDLFontid;

                    }
                    else
                    {
                        //
                        // Bounded font. It's a bit tricky. We have to do the
                        // same test for avaiable Glyph IDs. If there is no more
                        // glyph Ids, then we have to download a secondary
                        // soft font and reset the cGlyphs and wNextDlGId.
                        //
                        if (pdm->wNextDLGId > pdm->wLastDLGId)
                        {
                            if ( BDLSecondarySoftFont(pPDev, pfo, pstro,pdm) )
                            {
                                //
                                // Reset the Glyph Ids values.
                                //
                                pdm->wNextDLGId =  pdm->wFirstDLGId;
                                pdm->wCurrFontId = (WORD)pdm->pfm->ulDLIndex;

                            }
                            else
                            {
                                //
                                // Failure case. Fail the Call.
                                //
                                ERR(("UniFont:BDownloadGlyphs:Bounded Font,Sec. Font DL failed\n"));
                                goto ErrorExit;
                            }
                        }
                        //
                        // Set the Glyph ID and Font ID in the DLGLYPH.
                        //
                        pdlg->wDLFontId  = pdm->wCurrFontId;
                        pdlg->wDLGlyphID = pdm->wNextDLGId;

                    }

                    //
                    // All error checkings are done, so download now. Set the
                    // width to zero and then pass the address to downloading
                    // function. The downloading function should fill a width
                    // value else it remains zero.
                    //

                    if (pFM->ulDLIndex == -1)
                    {
                        ASSERTMSG(FALSE, ("pFM->ulDLIndex == -1") );
                        goto ErrorExit;
                    }

                    pdlg->wWidth = 0;
                    pdlg->wchUnicode = *(pwchUnicode + cGlyphIndex);
                    wWidth = 0;

                    dwMem = pFM->pfnDownloadGlyph(pPDev, pFM, hTTGlyph,
                                                  pdlg->wDLGlyphID, &wWidth);
                    if (dwMem)
                    {
                        //
                        // All success in downloading the glyph.Mark it
                        // downloaded. This is done by setting the  hTTGlyph to
                        // True Type Glyph Handle.
                        //
                        pdlg->hTTGlyph = hTTGlyph;

                        //
                        // If the download function returns the width use it,
                        // else use the width from GDI.
                        //

                        if (wWidth)
                            pdlg->wWidth = wWidth;
                        else
                        {
                            #ifndef WINNT_40 //NT 5.0

                            pdlg->wWidth = (WORD)GETWIDTH((pPtqD + cGlyphIndex));

                            #else // NT 4.0

                            pdlg->wWidth = GETWIDTH(pPtqD);

                            #endif //!WINNT_40

                        }

                        pdm->cGlyphs++;
                        pdm->wNextDLGId++;

                        //
                        // Update memory consumption before return.
                        //
                        PFDV->dwFontMemUsed += dwMem;
                    }
                    else
                    {
                        //
                        // Failure case. Fail the Call.
                        //
                        ERR(("UniFont:BDownloadGlyphs:Glyph Download failed\n"));
                        goto ErrorExit;

                    }
                }
                else // Glyph is already downloaded.
                {
                    //
                    // If Glyph is already downloaded and we are downloading as
                    // TT outline we need to update the width to current point
                    // size.
                    //

                    if( (pFM->dwFontType == FMTYPE_TTOUTLINE) ||
                        ( (pFM->dwFontType == FMTYPE_TTOEM) &&
                          (((PFONTMAP_TTOEM)(pFM->pSubFM))->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
                        )
                      )
                    {
                        #ifndef WINNT_40 //NT 5.0

                        pdlg->wWidth = (WORD)GETWIDTH((pPtqD + cGlyphIndex));

                        #else // NT 4.0

                        pdlg->wWidth = GETWIDTH(pPtqD);

                        #endif //!WINNT_40

                    }

                }

                pgp++;
                ppdlGlyph++;
                cGlyphIndex++;
                cGlyphs --;
            }
            else
            {
                ERR(("UniFont:BDownloadGlyphs: PDLGHashGlyph failed\n"));
                goto ErrorExit;

            }
        }

    } while( bMore );

    if (dwTotalEnumGlyphs != pstro->cGlyphs)
    {
        ERR(("UniFont:BDownloadGlyphs: STROBJ_bEnum failed to enumurate all glyphs\n"));
        goto ErrorExit;
    }

    bRet = TRUE;
    //
    // ReSet the pFM->ulDLIndex to first Glyph's softfont ID.
    //
    pFM->ulDLIndex = (pdm->wFlags & DLM_UNBOUNDED)?
                     (pdm->wBaseDLFontid):
                     (ptod->apdlGlyph[0]->wDLFontId);

    ErrorExit:
    //
    // If there is a failure then free the DLGLYPH array.
    //
    if (!bRet && ptod->apdlGlyph)
    {
        MEMFREEANDRESET(ptod->apdlGlyph );

    }

    #ifndef WINNT_40   // NT 5.0

    MEMFREEANDRESET(pPtqD );

    #endif //!WINNT_40

    return bRet;
}

BOOL
BDownLoadOEM(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT       iMode
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     The font of interest.
    pstro   The "width" of fixed pitch font glyphs.
    pdm     Individual download font map element

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    PI_UNIFONTOBJ pUFObj;
    PFONTMAP_TTOEM  pfmTTOEM;        // Bitmap download fontmap.
    IFIMETRICS   *pIFI;
    PFONTPDEV     pFontPDev;
    PFONTMAP      pfm;

    DWORD  dwMem;

    //
    // Initialize local variables.
    //
    pFontPDev = pPDev->pFontPDev;
    pUFObj    = pFontPDev->pUFObj;
    dwMem     = 0;

    //
    // Get FONTMAP
    //

    if (iMode == DL_BASE_SOFT_FONT)
    {
        pdm->pfm =
        pfm      = PfmInitPFMOEMCallback(pPDev, pfo);
    }
    else
    {
        pfm = pdm->pfm;
        ASSERTMSG((pfm),("NULL pFM for Secondary Font"));
    }

    if (!pUFObj || !pfm)
    {
        return FALSE;
    }

    if (pfm)
    {
        if (iMode == DL_BASE_SOFT_FONT)
        {
            pfm->pIFIMet =
            pIFI         = pGetIFI(pPDev, pfo, TRUE);
        }
        else
        {
            pIFI = pfm->pIFIMet;
        }

        if (pUFObj->dwFlags & (UFOFLAG_TTDOWNLOAD_BITMAP|
                               UFOFLAG_TTDOWNLOAD_TTOUTLINE) &&
            pIFI)
        {
            if (iMode == DL_BASE_SOFT_FONT)
            {
                pdm->cGlyphs = -1;

                if (pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
                {
                    if (pstro->ulCharInc == 0)
                    {
                        return FALSE;
                    }

                    pIFI->fwdMaxCharInc   =
                    pIFI->fwdAveCharWidth = (FWORD)pstro->ulCharInc;
                }

                pfm->wFirstChar = 0;
                pfm->wLastChar  = 0xffff;

                pfm->wXRes = (WORD)pPDev->ptGrxRes.x;
                pfm->wYRes = (WORD)pPDev->ptGrxRes.y;

                if (!pFontPDev->flFlags & FDV_ALIGN_BASELINE)
                    pfm->syAdj = pIFI->fwdWinAscender;

                pfm->flFlags = FM_SENT | FM_SOFTFONT | FM_GEN_SFONT;

                if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
                    pfm->flFlags |= FM_SCALABLE;

                pfm->ulDLIndex = pdm->wCurrFontId = pdm->wBaseDLFontid;
                pfmTTOEM = pfm->pSubFM;
                pfmTTOEM->u.pvDLData = pdm;

            }
            else
            {
                //
                // Things are different for Secondary Download.Get a new ID.
                //

                if( (pfm->ulDLIndex = IGetDL_ID( pPDev )) == -1 )
                {
                    ERR(( "UniFont!BDownLoadAsBmp:Out of Soft Font Limit,- FONT NOT DOWNLOADED\n"));
                    return FALSE;
                }


            }

            //
            // Send the SETFONTID command. This commands assigns the id to the
            // font being downloaded.
            //


            if( (dwMem = pfm->pfnDownloadFontHeader( pPDev, pfm)) == 0 )
            {
                //
                // Failed to download font header.
                //
                ERR(("UniFont!BDownloadAsOEM:pfnDownloadFontHeader failed.\n"));
                return FALSE;
            }
            else
            {
                //
                // Adjust the Memory
                //
                pFontPDev->dwFontMemUsed += dwMem;

                if (iMode == DL_BASE_SOFT_FONT)
                {
                    pfm->dwFontType = FMTYPE_TTOEM;
                    pdm->cGlyphs = 0;
                    pfmTTOEM->dwDLSize = dwMem;
                }
            }
        }
    }

    return TRUE;

}

BOOL
BDownLoadAsTT(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     The font of interest.
    pstro   The "width" of fixed pitch font glyphs.
    pdm     Individual download font map element
    iMode   Mode of downloading, primary or secondary.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    FONTMAP      *pFM;          // The FONTMAP structure we build up
    BOOL         bRet;          // The value we return
    PFONTPDEV    pFontPDev;     // Font Modules's PDEV
    IFIMETRICS   *pIFI;         // IFI metrics for this font.
    PFONTMAP_TTO pfmTTO;        // Bitmap download fontmap.
    DWORD         dwMem;        // For recording memory consumption

    //
    // Initialize the Local Variables.
    //

    pFontPDev = pPDev->pFontPDev;
    bRet = FALSE;
    dwMem = 0;

    //
    // First Initialize the FontMap.
    //
    if (iMode == DL_BASE_SOFT_FONT)
    {
        pFM = InitPFMTTOutline(pPDev,pfo);
        pdm->pfm = pFM;
    }
    else
    {
        pFM = pdm->pfm;
        ASSERTMSG((pFM),("\nUniFont!BDownLoadAsTT:NULL pFM for Secondary Font"));
    }

    if ( pFM )
    {

        //
        // Check if we can download the font or not, using the present available
        // memory.
        //

        if (iMode == DL_BASE_SOFT_FONT)
        {
            pFM->pIFIMet =
            pIFI         = pGetIFI( pPDev, pfo, FALSE );
        }
        else
        {
            pIFI = pFM->pIFIMet;
        }

        if ( pIFI && pFM->pfnCheckCondition(pPDev,pfo,pstro,pIFI) )
        {
            //
            // There is enough memory to download. So prepare to download.
            // The first step is to get the IFIMETRICS and validate it.
            //

            if (iMode == DL_BASE_SOFT_FONT)
            {

                //
                // Initialize to not download.After successful download we
                // set cGlyphs to 0.
                //
                pdm->cGlyphs = -1;

                if( pIFI->flInfo & FM_INFO_CONSTANT_WIDTH )
                {
                    //
                    // Fixed pitch fonts are not handled.Fixed
                    // pitch fonts should be downloaded as bitmap only.
                    // So return Error.
                    //

                    WARNING(( "UniFont!BDownLoadAsTT:Fixded Pitch Font are not downloaded as Outlie.\n"));
                    goto ErrorExit;

                }

                pFM->wFirstChar = 0;
                pFM->wLastChar = 0xffff;
                pFM->wXRes = (WORD)pPDev->ptGrxRes.x;
                pFM->wYRes = (WORD)pPDev->ptGrxRes.y;
                if( !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
                    pFM->syAdj = pIFI->fwdWinAscender;
                pFM->flFlags = FM_SENT | FM_SOFTFONT |
                               FM_GEN_SFONT | FM_SCALABLE;

                //
                //  wBaseDLFontid is already initialized by BInitDLMap function.
                //
                pFM->ulDLIndex  = pdm->wCurrFontId = pdm->wBaseDLFontid;

                //
                // Initialize the TT Outline specific fields.
                //

                pfmTTO = pFM->pSubFM;
                pfmTTO->pvDLData = pdm;
            }
            else
            {
                //
                // Things are different for Secondary Download. We have to get
                // a new fontID.
                //

                if( (pFM->ulDLIndex = IGetDL_ID( pPDev )) == -1 )
                {
                    ERR(( "UniFont!BDownLoadAsTT:Out of Soft Font Limit,- FONT NOT DOWNLOADED\n"));
                    goto ErrorExit;
                }


            }

            //
            // Send the SETFONTID command. This commands assigns the id to the
            // font being downloaded. And set the flag that this command is
            // already sent. We need to send this command while downloading
            // glyphs also. The download glyph code will check this flag, and
            // send the command only if not sent ( which will happen next time,
            // when same font is used).
            //

            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
            pFontPDev->flFlags  |= FDV_SET_FONTID;

            if( (dwMem = pFM->pfnDownloadFontHeader( pPDev, pFM)) == 0 )
            {
                //
                // Some sort of hiccup while downloading the header.So fail.
                //
                ERR(("UniFont!BDownLoadAsBmp:Err while downloading header,- FONT NOT DOWNLOADED\n"));
                goto ErrorExit;

            }
            //
            // Update memory consumption before return.
            //
            pFontPDev->dwFontMemUsed += dwMem;

            if (iMode == DL_BASE_SOFT_FONT)
            {
                //
                // Successful download.So mark it current.
                //
                pFM->dwFontType = FMTYPE_TTOUTLINE;

                //
                //  Set cGlyphs to 0 to mark that font is Downloaded OK.
                //

                pdm->cGlyphs = 0;

            }

        }
        else
        {
            ERR(( "UniFont!BDownLoadAsTT:NULL IFI or pfnCheckCondition failed.\n") );
            goto ErrorExit;
        }
    }
    else
    {
        //
        // The PFM could not be found or created for this truetype font.
        // Return FALSE to allow some other rendering method to occur.
        //
        WARNING(( "UniFont!BDownLoadAsTT:Fontmap couldn't be created or found.\n") );
        goto ErrorExit;
    }
    //
    // All success, so return TRUE;
    //
    bRet = TRUE;
    ErrorExit:
    return bRet;
}

BOOL
BDownLoadAsBmp(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     The font of interest.
    pstro   The "width" of fixed pitch font glyphs.
    pdm     Individual download font map element
    iMode   Mode of downloading, primary or secondary.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    FONTMAP      *pFM;          // The FONTMAP structure we build up
    BOOL         bRet;          // The value we return
    PFONTPDEV    pFontPDev;     // Font Modules's PDEV
    IFIMETRICS   *pIFI;         // IFI metrics for this font.
    PFONTMAP_TTB pfmTTB;        // Bitmap download fontmap.
    DWORD         dwMem;        // For recording memory consumption

    //
    // Initialize the Local Variables.
    //

    pFontPDev = pPDev->pFontPDev;
    bRet = FALSE;
    dwMem = 0;

    //
    // First Initialize the FontMap.
    //
    if (iMode == DL_BASE_SOFT_FONT)
    {
        pFM = InitPFMTTBitmap(pPDev,pfo);
        pdm->pfm = pFM;
    }
    else
    {
        pFM = pdm->pfm;
        ASSERTMSG((pFM),("\nUniFont!BDownLoadAsBmp:NULL pFM for Secondary Font"));
    }

    if ( pFM )
    {

        //
        // Check if we can download the font or not, using the present available
        // memory.
        //

        if (iMode == DL_BASE_SOFT_FONT)
        {
            pFM->pIFIMet =
            pIFI         = pGetIFI( pPDev, pfo, TRUE );
        }
        else
        {
            pIFI = pFM->pIFIMet;
        }

        if ( pIFI && pFM->pfnCheckCondition(pPDev,pfo,pstro,pIFI) )
        {
            //
            // There is enough memory to download. So prepare to download.
            // The first step is to get the IFIMETRICS and validate it.
            //

            if (iMode == DL_BASE_SOFT_FONT)
            {

                //
                // Initialize to not download.After successful download we
                // set cGlyphs to 0.
                //
                pdm->cGlyphs = -1;

                if( pIFI->flInfo & FM_INFO_CONSTANT_WIDTH )
                {
                    //
                    // Fixed pitch fonts are handled a little differently.Fixed
                    // pitch fonts should be downloaded as bitmap only.
                    //

                    if( pstro->ulCharInc == 0 )
                    {
                        ERR(( "UniFont!BDownLoadAsBmp:Fixed pitch font,ulCharInc == 0 - FONT NOT DOWNLOADED\n"));
                        goto ErrorExit;
                    }

                    pIFI->fwdMaxCharInc = (FWORD)pstro->ulCharInc;
                    pIFI->fwdAveCharWidth = (FWORD)pstro->ulCharInc;
                }

                pFM->wFirstChar = 0;
                pFM->wLastChar = 0xffff;
                pFM->wXRes = (WORD)pPDev->ptGrxRes.x;
                pFM->wYRes = (WORD)pPDev->ptGrxRes.y;
                if( !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
                    pFM->syAdj = pIFI->fwdWinAscender;
                pFM->flFlags = FM_SENT | FM_SOFTFONT | FM_GEN_SFONT;

                //
                //  wBaseDLFontid is already initialized by BInitDLMap function.
                //
                pFM->ulDLIndex  = pdm->wCurrFontId = pdm->wBaseDLFontid;

                //
                // Initialize the TT Bitmap specific fields.
                //

                pfmTTB = pFM->pSubFM;
                pfmTTB->u.pvDLData = pdm;
            }
            else
            {
                INT iID = IGetDL_ID( pPDev );

                //
                // Things are different for Secondary Download.Get a new ID.
                //

                if( iID < 0 )
                {
                    ERR(( "UniFont!BDownLoadAsBmp:Out of Soft Font Limit,- FONT NOT DOWNLOADED\n"));
                    goto ErrorExit;
                }
                pFM->ulDLIndex  = iID;


            }

            //
            // Send the SETFONTID command. This commands assigns the id to the
            // font being downloaded. And set the flag that this command is
            // already sent. We need to send this command while downloading
            // glyphs also. The download glyph code will check this flag, and
            // send the command only if not sent ( which will happen next time,
            // when same font is used).
            //

            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
            pFontPDev->flFlags  |= FDV_SET_FONTID;

            if( (dwMem = pFM->pfnDownloadFontHeader( pPDev, pFM)) == 0 )
            {
                //
                // Some sort of hiccup while downloading the header.So fail.
                //
                ERR(( "UniFont!BDownLoadAsBmp:Err while downloading header,- FONT NOT DOWNLOADED\n") );
                goto ErrorExit;

            }
            //
            // Update memory consumption before return.
            //
            pFontPDev->dwFontMemUsed += dwMem;

            if (iMode == DL_BASE_SOFT_FONT)
            {
                //
                // Successful download.So mark it current.
                //
                pFM->dwFontType = FMTYPE_TTBITMAP;

                //
                //  Set cGlyphs to 0 to mark that font is Downloaded OK.
                //

                pdm->cGlyphs = 0;

                pfmTTB->dwDLSize = dwMem;

            }

        }
        else
        {
            ERR(( "UniFont!BDownLoadAsBmp:NULL IFI or pfnCheckCondition failed.\n") );
            goto ErrorExit;
        }
    }
    //
    // All success. So return TRUE
    //
    bRet = TRUE;
    ErrorExit:
    return bRet;
}


INT
IDownloadFont(
    TO_DATA  *ptod,
    STROBJ   *pstro,
    INT      *piRot
    )
/*++
Routine Description:
    This function downloads the font and the glyphs. If the font is
    already downloaded, it uses that. It goes through all the glyphs
    and downloads the new one. This function also intializes pfm, iFace
    and apdlGlyph members of TO_DATA.

Arguments:
    ptod    TextOut Data pointer to fill the DLGLYPH array.
    pstro   The "width" of fixed pitch font glyphs.
    piRot   Rotation angle in multiple 90 degree.This is output param
            and used by textout call to set the text rotation.

Return Value:
    Download font index if font is/can be downloaded; else < 0.
    The index is 0 based, i.e first downloaded font has index 0.

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{

    DL_MAP          *pdm;          // Individual download font map element
    INT             iRet;          // The value we return: # of entry
    PFONTPDEV       pFontPDev;     // Font Modules's PDEV
    BOOL            bError;        // Set if we have an error.
    PDEV            *pPDev;        // Pdev
    FONTOBJ         *pfo;          // FontOBJ to be used

    //
    // Initialization of Local Variables.
    // Default for iRet is Failure set to -1.
    //

    iRet = -1;
    bError = FALSE;
    pPDev  = ptod->pPDev;
    pfo    = ptod->pfo;

    pFontPDev = pPDev->pFontPDev;

    /*
     * FIRST test is to check for font rotations.  If there is any,
     * we do NOT download this font, as the complications of keeping
     * track with how (or if) the printer allows it are far too great,
     * and, in any event,  it is not likely to gain us much, given the
     * relative infrequency of this event. Also check to see if the
     * printer can rotate fonts or not.
     *
     */

    //
    // Use &pFontPDev->ctl to set correct font size. Also check the rotation.
    //
    *piRot = ISetScale( &pFontPDev->ctl, FONTOBJ_pxoGetXform( pfo ), FALSE , (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

    if(!(pFontPDev->dwSelBits & FDH_PORTRAIT) )
            return  -1;

    //
    // Printer can't rotate text
    //
    if ((!(pFontPDev->flText & (TC_CR_ANY|TC_CR_90)) ||
        (NULL == COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION) &&
         NULL == COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION)))
         && *piRot)
        return -1;
    
    //
    // Printer can rotate 90 rotation
    //
    if ((!(pFontPDev->flText & TC_CR_90) ||
         NULL == COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION))
        && *piRot / 5 != 0)
        return  -1;


    //
    // Get the DL_MAP for this FONTOBJ. The functions sets pvConsumer to
    // 1 based the font index.
    //

    if (pdm = PGetDLMap (pFontPDev,pfo))
    {
        //
        // Given a DL_MAP, Check if it is downloaded or not. If the
        // DL_MAP.cGlyphs > 0 and DL_MAP.pfm is not NULL then this
        // font is downloaded.
        // If This font is Downloaded, return the index. The index
        // is saved in pvConsumer, which is one based. We convert it
        // to zero based.
        //

        iRet = (INT)PtrToLong(pfo->pvConsumer) - 1;


        if (! (FONTDOWNLOADED(pdm)) )
        {
            //
            // Font is a not downloaded. So start the process of downloading.
            // The first job is to fill the DL_MAP structure.
            //
            if (BInitDLMap(pPDev,pfo,pdm))
            {
                //
                // Check what method is preferred to download the font. Try the
                // preferred method first and then the other method.If OEM
                // handles the download then call the OEM download routine.
                //

                if (pFontPDev->flFlags & FDV_DLTT_OEMCALLBACK)
                {
                    //
                    // OEM download.
                    //

                    if (!BDownLoadOEM(pPDev, pfo, pstro, pdm, DL_BASE_SOFT_FONT))
                    {
                        ERR(("UniFont!IDownloadFont:BDownLoadOEM Failed!!\n"));
                        bError = TRUE;
                        iRet = -1;
                        VFreeDLMAP(pdm);
                        pdm->cGlyphs = 0;

                    }

                }
                else
                {
                    if (pFontPDev->flFlags & FDV_DLTT_ASTT_PREF)
                    {
                        //
                        // Try downloading the Bitmap as True Type Outline.
                        //
                        //

                        if (!BDownLoadAsTT(pPDev,pfo,pstro,pdm,DL_BASE_SOFT_FONT))
                        {
                            //
                            // If download as TT fails, we should try to download as
                            // Bitmap. So we free the allocated buffers and then
                            // mark the DL_MAP as new, by setting cGlyphs to 0.
                            //

                            WARNING(("UniFont!IDownloadFont:BDownLoadAsTT Failed\n"));

                            iRet = -1;
                            VFreeDLMAP( pdm );
                            pdm->cGlyphs  = 0;

                            //
                            // Decrement the Font id as we haven't downloaded the
                            // font yet. So reuse it.
                            //

                            pFontPDev->iUsedSoftFonts--;
                            pFontPDev->iNextSFIndex--;

                        }

                    }
                    if ((pFontPDev->flFlags & FDV_DLTT_BITM_PREF) ||
                        ((pFontPDev->flFlags & FDV_DLTT_ASTT_PREF) && (iRet < 0)) )
                    {
                        //
                        // If Downlaod as TT Ouline failed, then try to download as
                        // bitmap. So initialize the DL_MAP again.
                        //
                        if (iRet == -1)
                        {
                            if (!BInitDLMap(pPDev,pfo,pdm))
                            {
    //
    // BInitDLMap Failed
    //
    ERR(("UniFont!IDownloadFont:BInitDLMap Failed for Bitmap Download\n"));
    bError = TRUE;
                            }

                        }

                        if (!bError)
                        {
                            //
                            // If the preffered format is Bitmap or we have incountered
                            // an error while downloading as TT outline; then we try to
                            // download as Bitmap. Reset iRet to Font Index.
                            //

                            iRet = (INT)PtrToLong(pfo->pvConsumer) - 1;
                            if (!BDownLoadAsBmp(pPDev,pfo,pstro,pdm,DL_BASE_SOFT_FONT))
                            {
    ERR(("UniFont!IDownloadFont:BDownLoadAsBmp Failed\n"));
    bError = TRUE;

                            }

                        }
                    }

                    //
                    // 300 dpi mode. We disabled TT downloading if text and graphics
                    // resolutions are not same in intrface.c.
                    //
                    if (!(pFontPDev->flFlags & FDV_DLTT_BITM_PREF) &&
                        !(pFontPDev->flFlags & FDV_DLTT_ASTT_PREF)  )
                        bError = TRUE;
                }

            }
            else
            {
                //
                // BInitDLMap Failed
                //
                ERR(("UniFont!IDownloadFont:BInitDLMap Failed\n"));
                bError = TRUE;
            }

        }

        if  ( pdm != NULL &&
              pdm->pfm != NULL &&
              pdm->pfm->dwFontType == FMTYPE_TTOUTLINE &&
              NONSQUARE_FONT(pFontPDev->pxform))
        {
            //
            // There could be one font, which is scaled differently.
            // PCL5e can't scale x and y independently.
            // Need to print as graphics.
            // So we only set iRet.
            //
            WARNING(("UniFont!IDownloadFont:Err in downloading Glyphs\n"));
            iRet = -1;
        }

        //
        // Now we are done with downloading. if iRet is >= 0 (successful
        // downloading), then try downloading all the glyphs.
        // bDownloadGlyphs will also set download glyph array, apdlGlyph.
        //

        if ((iRet >= 0)  && !bError )
        {
            VERBOSE(("\nUniFont!IDownloadFont:Font downloaded successfully\n"));
            ptod->pfm = pdm->pfm;
            //
            // iFace is -ve to identify that this is a TT SoftFont.
            //
            ptod->iFace = -iRet;

            //
            // OEM callback initialization
            //
            if (pFontPDev->pUFObj)
            {
                PFONTMAP_TTOEM pFMOEM;

                //
                // Make sure that this PFM is for OEM.
                //
                if (ptod->pfm->dwFontType == FMTYPE_TTOEM)
                {
                        pFMOEM = (PFONTMAP_TTOEM) ptod->pfm->pSubFM;
                            pFMOEM->flFontType = pfo->flFontType;
                }

                pFontPDev->pUFObj->ulFontID = ptod->pfm->ulDLIndex;

                //
                // Initialize UFOBJ TrueType font bold/italic simulation
                //
                if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
                {
                    if (pfo->flFontType & FO_SIM_BOLD)
                        pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_BOLD_SIM;


                    if (pfo->flFontType & FO_SIM_ITALIC)
                        pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_ITALIC_SIM;


                    if (NULL != pFontPDev->pIFI &&
                        '@' == *((PBYTE)pFontPDev->pIFI + pFontPDev->pIFI->dpwszFamilyName))

                    {
                        pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_VERTICAL;

                    }
                }
            }

            //
            // Now we are downloading the glyphs, So select the font. This is
            // done by calling BNewFont.
            //
            BNewFont(pPDev, ptod->iFace, ptod->pfm, 0);

            if ( !BDownloadGlyphs(ptod, pstro, pdm ))
            {
                //
                // There is some error in downloading Glyphcs. So don't
                // download. But this not an error. So we only set iRet.
                //
                WARNING(("UniFont!IDownloadFont:Err in downloading Glyphs\n"));
                iRet = -1;
            }
        }

    }

    if (bError)
    {
        //
        // There is some error. So free everything. If pvConsumer is positive
        // then make it negative, to mark it bad.
        //
        if (pfo->pvConsumer > 0)
        {
            pfo->pvConsumer = (PINT_PTR)(-(INT_PTR)pfo->pvConsumer);
        }

        VFreeDLMAP( pdm );
        iRet = -1;

    }
    //
    // Clear the Set Font ID flag. This flag is set per textout
    //
    pFontPDev->flFlags &= ~FDV_SET_FONTID;

    return iRet;

}


#define CONVERT_COUNT   7

IFIMETRICS  *
pGetIFI(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    BOOL    bScale
    )
/*++
Routine Description:
    Given a pointer to a FONTOBJ,  return a pointer to the IFIMETRICS
    of the font.  If this is a TT font,  the metrics will be converted
    with current scaling information.  The IFIMETRICS data is allocated
    on the heap,  and it is the caller's repsonsibility to free it.

Arguments:

    pPDev    pointer to PDEVICE
    pfo      FONTOBJ,The font of interest
    bScale   TRUE for scaling IFIMETRICS else FALSE

Return Value:
    address of IFIMETRICS,  else NULL for failure.

Note:

    3/5/1997 -ganeshp-
        Created it.
--*/

{
    IFIMETRICS  *pIFI;      /* Obtained from engine */
    IFIMETRICS  *pIFIRet;   /* Returned to caller */
    XFORMOBJ    *pxo;       /* For adjusting scalable font metrics */


    POINTL       aptlIn[ CONVERT_COUNT ];       /* Input values to xform */
    POINTL       aptlOut[ CONVERT_COUNT ];      /* Output values from xform */

    pIFI = ((FONTPDEV*)pPDev->pFontPDev)->pIFI;

    if( pIFI == NULL )
        return  NULL;       /* May happen when journalling is in progress */

    /*
     *   We need to make a copy of this,  since we are going to clobber it.
     * This may not be required if we are dealing with a bitmap font, but
     * it is presumed most likely to be a TrueType font.
     */

    if( pIFIRet = (IFIMETRICS *)MemAllocZ(pIFI->cjThis ) )
    {
        /*
         *   First copy the IFIMETRICS as is.  Then,  if a scalable font,
         * we need to adjust the various sizes with the appropriate
         * transform.
         */
        CopyMemory( pIFIRet, pIFI, pIFI->cjThis );


        if( bScale                                      &&
            (pIFIRet->flInfo &
            (FM_INFO_ISOTROPIC_SCALING_ONLY       |
             FM_INFO_ANISOTROPIC_SCALING_ONLY     |
             FM_INFO_ARB_XFORMS))                       &&
            (pxo = FONTOBJ_pxoGetXform( pfo )))
        {
            /*
             *   Scalable,  and transform available,  so go do the
             * transformations to get the font size in device pels.
             *
             ***********************************************************
             *   ONLY SOME FIELDS ARE TRANSFORMED, AS WE USE ONLY A FEW.
             ***********************************************************
             */

            ZeroMemory( aptlIn, sizeof( aptlIn ) );         /* Zero default */

            aptlIn[ 0 ].y = pIFI->fwdTypoAscender;
            aptlIn[ 1 ].y = pIFI->fwdTypoDescender;
            aptlIn[ 2 ].y = pIFI->fwdTypoLineGap;
            aptlIn[ 3 ].x = pIFI->fwdMaxCharInc;
            aptlIn[ 4 ].x = pIFI->rclFontBox.left;
            aptlIn[ 4 ].y = pIFI->rclFontBox.top;
            aptlIn[ 5 ].x = pIFI->rclFontBox.right;
            aptlIn[ 5 ].y = pIFI->rclFontBox.bottom;
            aptlIn[ 6 ].x = pIFI->fwdAveCharWidth;

            /*
             *    Perform the transform,  and verify that there is no
             *  rotation component.  Return NULL (failure) if any of
             *  this fails.
             */

            if( !XFORMOBJ_bApplyXform( pxo, XF_LTOL, CONVERT_COUNT,
                                                     aptlIn, aptlOut )
#if 0
                ||
                aptlOut[ 0 ].x || aptlOut[ 1 ].x ||
                aptlOut[ 2 ].x || aptlOut[ 3 ].y 
#endif
              )
            {
                MemFree((LPSTR)pIFIRet );

                return  NULL;
            }

            /*   Simply install the new values into the output IFIMETRICS */

            pIFIRet->fwdTypoAscender  = (FWORD) aptlOut[0].y;
            pIFIRet->fwdTypoDescender = (FWORD) aptlOut[1].y;
            pIFIRet->fwdTypoLineGap   = (FWORD) aptlOut[2].y;

            pIFIRet->fwdWinAscender   =  pIFIRet->fwdTypoAscender;
            pIFIRet->fwdWinDescender  = -pIFIRet->fwdTypoDescender;

            pIFIRet->fwdMacAscender   = pIFIRet->fwdTypoAscender;
            pIFIRet->fwdMacDescender  = pIFIRet->fwdTypoDescender;
            pIFIRet->fwdMacLineGap    = pIFIRet->fwdTypoLineGap;

            pIFIRet->fwdMaxCharInc = (FWORD)aptlOut[3].x;

            /*
             *    PCL is fussy about the limits of the character cell.
             *  We allow some slop here by expanding the rclFontBox by
             *  one pel on each corner.
             */
            pIFIRet->rclFontBox.left = aptlOut[ 4 ].x - 1;
            pIFIRet->rclFontBox.top = aptlOut[ 4 ].y + 1;
            pIFIRet->rclFontBox.right = aptlOut[ 5 ].x + 1;
            pIFIRet->rclFontBox.bottom = aptlOut[ 5 ].y - 1;
            pIFIRet->fwdAveCharWidth = (FWORD)aptlOut[ 6 ].x;

            VERBOSE(("\n UniFont!pGetIFI:pIFI->fwdTypoAscender = %d,pIFI->fwdTypoDescender = %d\n",pIFI->fwdTypoAscender,pIFI->fwdTypoDescender));
            VERBOSE(("UniFont!pGetIFI:pIFI->fwdWinAscender = %d, pIFI->fwdWinDescender = %d\n", pIFI->fwdWinAscender,pIFI->fwdWinDescender ));
            VERBOSE(("UniFont!pGetIFI:pIFI->rclFontBox.top = %d,pIFI->rclFontBox.bottom = %d\n", pIFI->rclFontBox.top, pIFI->rclFontBox.bottom));
            VERBOSE(("UniFont!pGetIFI: AFTER SCALING THE FONT\n"));
            VERBOSE(("UniFont!pGetIFI:pIFIRet->fwdTypoAscender = %d,pIFIRet->fwdTypoDescender = %d\n",pIFIRet->fwdTypoAscender,pIFIRet->fwdTypoDescender));
            VERBOSE(("UniFont!pGetIFI:pIFIRet->fwdWinAscender = %d, pIFIRet->fwdWinDescender = %d\n", pIFIRet->fwdWinAscender,pIFIRet->fwdWinDescender ));
            VERBOSE(("UniFont!pGetIFI:pIFIRet->rclFontBox.top = %d,pIFIRet->rclFontBox.bottom = %d\n", pIFIRet->rclFontBox.top, pIFIRet->rclFontBox.bottom));

        }
    }

    return  pIFIRet;

}

#undef    CONVERT_COUNT

BOOL
BSendDLFont(
    PDEV     *pPDev,
    FONTMAP  *pFM
    )
/*++
Routine Description:
    Called to download an existing softfont.  Checks to see if the
    font has been downloaded,  and if so,  does nothing.  Otherwise
    goes through the motions of downloading.

Arguments:
    pPDev   Pointer to PDEV
    pFM     The particular font of interest.

Return Value:
       TRUE/FALSE;  FALSE only if there is a problem during the load.

Note:

    3/4/1997 -ganeshp-
        Created it.
--*/

{

    FONTMAP_DEV *pFMDev;
    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    PDATA_HEADER pDataHeader;
    PBYTE        pDownloadData;
    DWORD        dwLeft;               // Bytes remaining to send
    /*
     *   First see if it has already been downloaded!
     */

    if( pFM->flFlags &  (FM_SENT | FM_GEN_SFONT) )
        return  TRUE;

    pFMDev = (PFONTMAP_DEV)pFM->pSubFM;

    if (!(pDataHeader = FIGetVarData( pFontPDev->hUFFFile, pFMDev->dwResID)) ||
        pDataHeader->dwSignature != DATA_VAR_SIG ||
        pDataHeader->dwDataSize == 0 )
        return FALSE;

    dwLeft = pDataHeader->dwDataSize;
    pDownloadData = ((PBYTE)pDataHeader + pDataHeader->wSize);

    /*
     *    Check if there is memory to fit this font.  These are all
     *  approximations,  but it is better than running out of memory
     *  in the printer.
     */

    if( (pFontPDev->dwFontMemUsed + PCL_FONT_OH + dwLeft) > pFontPDev->dwFontMem )
        return  FALSE;

    /*
     *    Time to be serious about downloading.  UniDrive provides some
     * of the control stuff we need.  As well, we need to select an ID.
     * The font itself is memory mapped,  so we need only to shuffle it
     * off to WriteSpoolBuf().
     */

    pFM->ulDLIndex = IGetDL_ID( pPDev );     /* Down load index to use */

    if( pFM->ulDLIndex == -1 )
        return   FALSE;                   /* Have run out of slots! */

    /*
     *   Downloading is quite simple.  First send an identifying command
     * (to label the font for future selection) and then copy the font
     * data (in the *.fi_ file) to the printer.
     */

    BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD|STD_NFID);
    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID) );

    while( dwLeft )
    {

        DWORD    cjSize;             /*  Number of bytes to send */

        cjSize = min( dwLeft, DL_BUF_SZ );

        if( WriteSpoolBuf( pPDev, pDownloadData, cjSize ) != (int)cjSize )
        {
            break;
        }

        if( pPDev->fMode & PF_ABORTED )
            break;

        dwLeft -= cjSize;
        pDownloadData += cjSize;
    }

    /*
     *   If dwLeft is 0,  then everything completed as expected.  Under these
     *  conditions, we flag the data as having been sent, and thus available
     *  for use.   Even if we failed,  we should assume we have consumed
     *  all the font's memory and adjust our records accordingly.
     */

    if( dwLeft == 0 )
        pFM->flFlags |= FM_SENT;             /* Now done */

    /*
     *   Account for memory used by this font.
     */

    pFontPDev->dwFontMemUsed += PCL_FONT_OH + pDataHeader->dwDataSize;

    return  dwLeft == 0;

}


DWORD
DwGetTTGlyphWidth(
    FONTPDEV *pFontPDev,
    FONTOBJ  *pfo,
    HGLYPH   hTTGlyph)
/*++
Routine Description:

Arguments:
    pFontPDev Font  PDevice
    pfo       Fontobj
    hTTGlyph  Glyph handle

Return Value:
    Character width

Note:

--*/
{
    DLGLYPH *pdlg;
    DL_MAP  *pdm;
    DWORD    dwRet;

    if (!pfo || !pFontPDev)
        return 0;

    if (!(pdm = PGetDLMap (pFontPDev,pfo)) ||
        !(pdlg = PDLGHashGlyph (pdm, hTTGlyph)))
    {
        dwRet = 0;
    }
    else
    {
        dwRet = pdlg->wWidth;
    }


    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fileio.h ===
/************************** Module Header ***********************************
 * fileio.h
 *      Function Prototypes for File I/O in Kernel mode.
 *
 * NOTE:  these functions perform File read, seek operations.
 *
 * Copyright (C) 1991 - 1999  Microsoft Corporation
 *
 ****************************************************************************/

#define         CURRENTFILEPTR(pFile)  (LPVOID)((LPBYTE)(pFile->pvFilePointer)\
                                                + pFile->dwCurrentByteOffset)

#define         ENDOFFILEPTR(pFile)       ( pFile->pvFilePointer + \
                                            pFile->dwTotalSize )

#define         STARTFILEPTR(pFile)     ( pFile->pvFilePointer )

#define         STARTFILEOFFSETPTR(pFile,offset) ( pFile->pvFilePointer + \
                                                    offset )

#define         NUMBYTESREMAINING(pFile) ( pFile->dwTotalSize - \
                                             pFile->dwCurrentByteOffset )

#define         UPDATECURROFFSET(pFile,offset) (pFile->dwCurrentByteOffset +=\
                                                offset )

#define         DRV_FILE_BEGIN       0

#define         DRV_FILE_CURRENT     1

#define         INVALID_HANDLE_VALUE (HANDLE)-1

typedef struct _MAPFILE
{
    HANDLE   hHandle;  /* Handle to the file, returned by EngLoadModule */
    DWORD    dwTotalSize;  /* Total Size of the file, as returned by
                            * EngMapModule.
                            */
    DWORD    dwCurrentByteOffset; /* Current Byte Offset in the file.
                                   * Updated after each read and DrvSetFile-
                                   * Pointer.
                                   */
    PVOID    pvFilePointer;       /* Start of the file pointer, as returned
                                   * EngMapModule
                                   */
    struct _MAPFILE *pNext;           /* Next File Pointer.*/

}MAPFILE, * PMAPFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fileio.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fileio.c

Abstract:

    Functions to file operations in Kernel Mode. These functions perform
    File open. read, seek operations

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

--*/



#include        "font.h"


HANDLE
DrvOpenFile (
    PWSTR pwstrFileName,          /* File to Open */
    PDEV   *pPDev                /* Pointer to PDEV */
    )
/*++

Routine Description:

    Open a file in readmode and updates the file pointers

Arguments:

    PWSTR: pwstrFileName  Name of printer data file.
    PDEV: pPDev       Pointer to PDEV

    Return Value:

    Handle to a the File on success else NULL;

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    PMAPFILE pFile ;

    /* Allocate the file pointer */
    if ( pFile = MemAllocZ( sizeof(MAPFILE) ))
    {
        memset(pFile,0, sizeof(MAPFILE));


        /* Open the file using EngLoadModule and EngmapMoodule */
        if( !(pFile->hHandle = EngLoadModule(pwstrFileName)) )
        {
            MemFree( pFile);
            return INVALID_HANDLE_VALUE;

        }

        if (!(pFile->pvFilePointer = EngMapModule( pFile->hHandle,
                                        &(pFile->dwTotalSize))) )
        {
            MemFree( pFile);
            return INVALID_HANDLE_VALUE;
        }

        /* Add the new File struct at the begining of the list */
        if (pPDev->pFileList)
        {
            pFile->pNext = (PMAPFILE)(pPDev->pFileList);
            pPDev->pFileList = pFile;
        }
        else
        {
            pPDev->pFileList = pFile;
        }

        return pFile->hHandle;
    }
    else
    {
        return INVALID_HANDLE_VALUE ;
    }
}


BOOL
DrvReadFile (
    HANDLE   hFile,             /* Handle to the file */
    LPVOID   lpBuffer,          /* Buffer to Fill */
    DWORD    nNumBytesToRead,   /* Number of Bytes to Read */
    LPDWORD  lpNumBytesRead,    /* Number of Bytes Read */
    PDEV     *pPDev             /* Pointer to PDEV */
)
/*++

Routine Description:

    Read a file and updates the file pointers

Arguments:

    HANDLE   hFile;             Handle to the file
    LPVOID   lpBuffer;          Buffer to Fill
    DWORD    nNumBytesToRead;   Number of Bytes to Read
    LPDWORD  lpNumBytesRead     Number of Bytes Read. DrvReadFile sets this
                                value to zero before doing any work.
    PDEV     *pPDev             Pointer to PDEV

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    PMAPFILE pFile  = pPDev->pFileList;
    LPBYTE lpSrcBuffer =  NULL;
    BOOL bRet = FALSE;

    *lpNumBytesRead =  0;

    /* No file list, so error */
    if (!pFile)
    {
        RIP(("ReadFile: Bad File Handle.\n"));
        goto DrvReadFileExit;
    }

    /* Find the Handle in the list. */
    while ( pFile && (pFile->hHandle != hFile) )
        pFile = pFile->pNext;

    /* If the Hnadle is not present in the list, Error */
    if (!pFile)
    {
        RIP(("ReadFile: File Handle not in the list.\n"));
        goto DrvReadFileExit;
    }

    /* A good handle, so try to read */

    /* Check if the remaining bytes is less that the requested one */
    if ( NUMBYTESREMAINING(pFile) <  nNumBytesToRead )
    {
        WARNING(("DrvReadFile:Number of bytes to read is less than remaining bytes \n"));
        *lpNumBytesRead =  NUMBYTESREMAINING(pFile);
    }
    else
    {
        /* There are sufficient number of bytes to read
         * so read and update the values in _MAPFILE struct
         */

        *lpNumBytesRead = nNumBytesToRead;
    }

    lpSrcBuffer = CURRENTFILEPTR(pFile);
    UPDATECURROFFSET(pFile,*lpNumBytesRead);

    memcpy(lpBuffer,lpSrcBuffer,*lpNumBytesRead);

    bRet = TRUE;

    DrvReadFileExit:
    return bRet;

}


DWORD
DrvSetFilePointer (
    HANDLE   hFile,
    LONG     iDistanceToMove,
    DWORD    dwMoveMethod,
    PDEV     *pPDev
    )
/*++

Routine Description:

    updates the file pointers

Arguments:

    HANDLE   hFile;             Handle to the file
    LONG     iDistanceToMove;   Specifies the number of Bytes to move the file
                                pointer. A positive value move the pointer
                                Forward and a negative value moves it backward.
    DWORD    dwMoveMethod;      Specifies the starting point for file pointer
                                move. It should be either DRV_FILE_BEGIN or
                                DRV_FILE_CURRENT.
    PDEV     *pPDev             Pointer to PDEV



    Return Value:

    If the function succeeds the return value is current byte offset of
    the file pointer. Otherwise it returns -1. For extended error call
    GetLastError.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    PMAPFILE pFile  = pPDev->pFileList;
    int iRet = -1;

    /* No file list, so error */
    if (!pFile)
    {
        RIP(("ReadFile: Bad File Handle.\n"));
        goto DrvSetFilePointerExit;
    }

    /* Find the Handle in the list. */
    while ( pFile && (pFile->hHandle != hFile) )
        pFile = pFile->pNext;

    /* If the Hnadle is not present in the list, Error */
    if (!pFile)
    {
        RIP(("ReadFile: File Handle not in the list.\n"));
        goto DrvSetFilePointerExit;
    }

    /* A good handle, so try to move */
    switch (dwMoveMethod)
    {
    case DRV_FILE_BEGIN:
        if ( iDistanceToMove < 0)
        {
            RIP(("DrvSetFilePointer:Can't Move Negative Distance from Begining\n"));
            goto DrvSetFilePointerExit;
        }
        else /* Set the current Offset to Start */
            pFile->dwCurrentByteOffset = 0;
        break;

    case DRV_FILE_CURRENT:
        if ( (iDistanceToMove < 0) &&
                        (pFile->dwCurrentByteOffset < (DWORD)(-iDistanceToMove)) )
        {
            RIP(("DrvSetFilePointer:Negative Distance is more than curr offset\n"));
            goto DrvSetFilePointerExit;
        }
        else if ( (iDistanceToMove > 0) &&
                    ( NUMBYTESREMAINING(pFile)  <  (DWORD)iDistanceToMove ) )
        {
            RIP(("DrvReadFile:Number of bytes to move is less than remaining bytes \n"));
            goto DrvSetFilePointerExit;
        }

        break;

    default:
        RIP(("DrvSetFilePointer:Bad Move Method\n"));
        goto DrvSetFilePointerExit;
    }

    UPDATECURROFFSET(pFile,iDistanceToMove);
    iRet = pFile->dwCurrentByteOffset;

    DrvSetFilePointerExit:
    return iRet;
}


BOOL
DrvCloseFile (
    HANDLE   hFile,          /* Handle to the file */
    PDEV    *pPDev           /* Pointer to PDEV for file List */
    )
/*++

Routine Description:

    This routine Closes the file

Arguments:

    HANDLE   hFile;             Handle to the file
    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    PMAPFILE pFile  = pPDev->pFileList;
    PMAPFILE pTmpFile  = NULL;
    BOOL bRet = FALSE;

    /* No file list, so error */
    if (!pFile)
    {
        RIP(("ReadFile: Bad File Handle.\n"));
        goto DrvCloseFileExit;
    }

    /* Find the Handle in the list. */
    while ( pFile && (pFile->hHandle != hFile) )
    {
        pTmpFile = pFile;
        pFile = pFile->pNext;
    }

    /* If the Hnadle is not present in the list, Error */
    if (!pFile)
    {
        RIP(("ReadFile: File Handle not in the list.\n"));
        goto DrvCloseFileExit;
    }

    /* A good handle, so try to free/close */
    if ( !pTmpFile ) /* First element of the list */
    {
        pPDev->pFileList = pFile->pNext;
    }
    else
    {
        pTmpFile->pNext = pFile->pNext;
    }

    EngFreeModule(pFile->hHandle);
    MemFree(pFile);
    bRet = TRUE;

    DrvCloseFileExit:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmcallbk.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmcallbk.h

Abstract:

    The font module callback helper functions

Environment:

    Windows NT Unidrv driver

Revision History:

    03/31/97 -eigos-
        Created

--*/


typedef struct _I_UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;
    IFIMETRICS *pIFIMetrics;
    PFNGETINFO  pfnGetInfo;

    FONTOBJ    *pFontObj;
    STROBJ     *pStrObj;
    struct _FONTMAP  *pFontMap;
    struct _PDEV *pPDev;
    POINT       ptGrxRes;
    VOID       *pGlyph;
    struct _DLGLYPH   **apdlGlyph;
    DWORD       dwNumInGlyphTbl;
} I_UNIFONTOBJ, *PI_UNIFONTOBJ;

BOOL
UNIFONTOBJ_GetInfo(
    IN  PUNIFONTOBJ pUFObj,
    IN  DWORD       dwInfoID,
    IN  PVOID       pData,
    IN  DWORD       dwDataSize,
    OUT PDWORD      pcNeeded);

VOID
VUFObjFree(
    IN struct _FONTPDEV  *pFontPDev);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\dloadpcl.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:
       dloadpcl.c

Abstract:

   Functions associated with downloading fonts to printers.  This
   specifically applies to LaserJet style printers.  There are really
   two sets of functions here:  those for downloading fonts supplied
   by the user (and installed with the font installer), and those
   we generate internally to cache TT style fonts in the printer.


Environment:

    Windows NT Unidrv driver

Revision History:

    03/06/97 -ganeshp-
        Created

--*/

#include "font.h"

#define     PCL_MAX_FONT_HEADER_SIZE      32767
#define     PCL_MAX_CHAR_HEADER_SIZE      32767

#if PRINT_INFO
void vPrintPCLCharHeader(CH_HEADER);
void vPrintPCLFontHeader(SF_HEADER20);
void vPrintPCLChar(char *, WORD, WORD);
#endif


DWORD
DwDLPCLHeader(
    PDEV        *pPDev,
    IFIMETRICS  *pifi,
    INT         id
    )
/*++
Routine Description:
    Given the IFIMETRICS of the font,  and it's download ID,  create
    and send off the download font header.

Arguments:
    pPDev       Pointer to PDEV
    pifi;       IFIMETRICS of this font
    id;         Font Selection ID

Return Value:
    The memory used fo this font.

Note:

    3/6/1997 -ganeshp-
        Created it.
--*/

{
    INT             cjSend;       /* Number of bytes to send down */
    SF_HEADER20     sfh;              /* Structure to send down */
    BYTE            aPCLFontHdrCmd[20];
    INT             iFontHdrCmdLen = 0;
    WORD            wSymSet;
    BYTE            bFontType;
    PFONTPDEV       pFontPDev = pPDev->pFontPDev;


    /*
     *   No major brainwork here.  Basically need to map from IFIMETRICS
     *  to HP's font header structure, swap the bytes, then send it off.
     *  We should be consistent with the (inverse) mapping applied by
     *  the font installer.
     *    NOTE that we use the larger of the 2 headers.  Should this
     *  printer not use the additional resolution fields,  we ignore
     *  that part of the structure.
     */


#if PRINT_INFO
    WCHAR * pwch;
    pwch = (WCHAR *)((BYTE *)pifi + pifi->dpwszFaceName);
    DbgPrint("\nRasdd!iDLHeader:Dumping font,Name is %ws\n",pwch);
#endif


    ZeroMemory( &sfh, sizeof( sfh ) );          /* Safe default values */

    /*
     *   Fill in the structure:  easy to do, and many of the fields
     * are irrelevant anyway,  since the font is selected by ID, and
     * NOT on its attributes.
     */

    if( (pPDev->pGlobals->fontformat == FF_HPPCL))
    {
        sfh.wSize = cjSend = sizeof( SF_HEADER );
        sfh.bFormat = PCL_FM_ORIGINAL;
    }
    else
    {
        /*   Extended format:  allows for resolution */
        sfh.wSize = cjSend = sizeof( SF_HEADER20 );
        sfh.bFormat = PCL_FM_RESOLUTION;
        sfh.wXResn = (WORD)pPDev->ptGrxRes.x;
        sfh.wYResn = (WORD)pPDev->ptGrxRes.y;
    }


    if( pPDev->pGlobals->dlsymbolset == UNUSED_ITEM )
    {
        /*
         *  GPD file doesn't define a symbols set for downloaded fonts.
         *  Now we have a bit of a hack.  Early LaserJets are limited to
         *  the Roman 8 symbol set, which basically allows 0x20 - 0x7f,
         *  and 0xa0 to 0xfe.   We do not have any information which tells
         *  us the capability of this printer.  So we have a compromise:
         *  use the "Can rotate device fonts" flag as an indicator.  If
         *  this bit is set,  we assume the PC-8 symbol set is OK,  otherwise
         *  use Roman 8.  This is a slightly pessimistic assumption, since
         *  we use the LaserJet Series II in Roman 8 mode, when PC-8
         *  is just fine.
         */

        if( pFontPDev->flFlags & FDV_ROTATE_FONT_ABLE )
        {
            //
            // PC-8,  the large symbol set
            // PC-8: 10U -> 341 [ = 10 * 32 + 'U' - 64 ]
            // 8 bit font
            //

            bFontType = PCL_FT_PC8;
            wSymSet = 341;
        }
        else
        {
            //
            // The Roman 8 limited character set
            // Roman 8, 8U -> 277 [ = 8 * 32 + 'U' - 64]
            // Limited 8 bit font
            //

            bFontType = PCL_FT_8LIM;
            wSymSet = 277;
        }
    }
    else
    {
        //
        // Explicit Symbol Set defined in GPD, So use it.
        //

        if( pPDev->pGlobals->dlsymbolset == DLSS_ROMAN8 )
        {
            /*
             * The Roman 8 limited character set. Limited 8 bit font.
             *  Roman 8, 8U -> 277 [ = 8 * 32 + 'U' - 64]
             */

            bFontType = PCL_FT_8LIM;
            wSymSet = 277;       /* */
        }
        else
        {
            /*
             *  PC-8,  the large symbol set. 8 bit font
             *  PC-8: 10U -> 341 [ = 10 * 32 + 'U' - 64 ]
             */

            bFontType = PCL_FT_PC8;
            wSymSet = 341;
        }

    }

    sfh.bFontType = bFontType;
    sfh.wSymSet = wSymSet;


#if PRINT_INFO
    DbgPrint("\nRasdd!iDLHeader:pifi->rclFontBox.top = %d,pifi->fwdWinAscender = %d\n",
             pifi->rclFontBox.top, pifi->fwdWinAscender);

    DbgPrint("UniFont!iDLHeader:pifi->fwdWinDescender = %d, pifi->rclFontBox.bottom = %d\n",
             pifi->fwdWinDescender, pifi->rclFontBox.bottom);
#endif

    sfh.wBaseline = (WORD)max( pifi->rclFontBox.top, pifi->fwdWinAscender );
    sfh.wCellWide = (WORD)max( pifi->rclFontBox.right - pifi->rclFontBox.left + 1,
                                           pifi->fwdAveCharWidth );
    sfh.wCellHeight = (WORD)(1+ max(pifi->rclFontBox.top,pifi->fwdWinAscender) -
                        min( -pifi->fwdWinDescender, pifi->rclFontBox.bottom ));

    sfh.bOrientation = 0; //Set the Orientation to 0 always, else it won't work.

    sfh.bSpacing = (pifi->flInfo & FM_INFO_CONSTANT_WIDTH) ? 0 : 1;

    sfh.wPitch = 4 * pifi->fwdAveCharWidth;      // PCL quarter dots

    sfh.wHeight = 4 * sfh.wCellHeight;
    sfh.wXHeight = 4 * (pifi->fwdWinAscender / 2);

    sfh.sbWidthType = 0;                        // Normal weight
    sfh.bStyle = pifi->ptlCaret.x ? 0 : 1;      // Italic unless upright
    sfh.sbStrokeW = 0;
    sfh.bTypeface = 0;
    sfh.bSerifStyle = 0;
    sfh.sbUDist = -1;                           // Next 2 are not used by us
    sfh.bUHeight = 3;
    sfh.wTextHeight = 4 * (pifi->fwdWinAscender + pifi->fwdWinDescender);
    sfh.wTextWidth  = 4 * pifi->fwdAveCharWidth;

    sfh.bPitchExt = 0;
    sfh.bHeightExt = 0;

    iDrvPrintfA( sfh.chName, "Cache %d", id );       // Something obvious

#if PRINT_INFO
    vPrintPCLFontHeader(sfh);
#endif
    /*
     *   Do the switch:  little endian to 68k big endian.
     */

    SWAB( sfh.wSize );
    SWAB( sfh.wBaseline );
    SWAB( sfh.wCellWide );
    SWAB( sfh.wCellHeight );
    SWAB( sfh.wSymSet );
    SWAB( sfh.wPitch );
    SWAB( sfh.wHeight );
    SWAB( sfh.wXHeight );
    SWAB( sfh.wTextHeight );
    SWAB( sfh.wTextWidth );
    SWAB( sfh.wXResn );
    SWAB( sfh.wYResn );

    if (cjSend > PCL_MAX_FONT_HEADER_SIZE)
        return 0;
    else
    {
        ZeroMemory( aPCLFontHdrCmd, sizeof( aPCLFontHdrCmd ) );
        iFontHdrCmdLen = iDrvPrintfA( aPCLFontHdrCmd, "\x1B)s%dW", cjSend );
        if( WriteSpoolBuf( pPDev, aPCLFontHdrCmd, iFontHdrCmdLen ) != iFontHdrCmdLen )
            return  0;

    }

    if( WriteSpoolBuf( pPDev, (BYTE *)&sfh, cjSend ) != cjSend )
        return  0;

    return  PCL_FONT_OH;
}

INT
IDLGlyph(
    PDEV        *pPDev,
    int         iIndex,
    GLYPHDATA   *pgd,
    DWORD       *pdwMem
    )
/*++
Routine Description:
   Download the Char bitmap etc. for the glyph passed to us.

Arguments:
    pPDev   Pointer to PDEV
    iIndex  Which glyph this is
    pgd     Details of the glyph
    pdwMem  Add the amount of memory used to this.

Return Value:
    Character width;  < 1 is an error.

Note:

    3/6/1997 -ganeshp-
        Created it.
--*/

{
    /*
     *    Two basic steps:   first is to generate the header structure
     *  and send that off,  then send the actual bitmap data.  The only
     *  complication happens if the download data exceeds 32,767 bytes
     *  of glyph image.  This is unlikely to happen, but we should
     *  be prepared for it.
     */

    int             cbLines;    /* Bytes per scan line (sent to printer) */
    int             cbTotal;    /* Total number of bytes to send */
    int             cbSend;     /* If size > 32767; send in chunks */
    GLYPHBITS       *pgb;       /* Speedier access */
    CH_HEADER       chh;        /* The initial, main header */
    BYTE            aPCLCharHdrCmd[20];
    INT             iCharHdrCmdLen = 0;

    PFONTPDEV       pFontPDev = pPDev->pFontPDev;

    ASSERTMSG(pgd, ("UniFont!IDLGlyph:pgd is NULL.\n"));

    ZeroMemory( &chh, sizeof( chh ) );           /* Safe initial values */

    chh.bFormat = CH_FM_RASTER;
    chh.bContinuation = 0;
    chh.bDescSize = sizeof( chh ) - sizeof( CH_CONT_HDR );
    chh.bClass = CH_CL_BITMAP;

    chh.bOrientation = 0; //Set the Orientation to 0 always, else it won't work.

    pgb = pgd->gdf.pgb;

    chh.sLOff = (short)pgb->ptlOrigin.x;
    chh.sTOff = (short)-pgb->ptlOrigin.y;
    chh.wChWidth = (WORD)pgb->sizlBitmap.cx;       /* Active pels */
    chh.wChHeight = (WORD)pgb->sizlBitmap.cy;      /* Scanlines in bitmap */
    chh.wDeltaX = (WORD)((pgd->ptqD.x.HighPart + 3) >> 2);     /* 28.4 ->14.2 */

    #if PRINT_INFO
       DbgPrint("UniFont!IDLGlyph:Value of (pgd->ptqD.x.HighPart ) is %d\n",
       (pgd->ptqD.x.HighPart ) );
       DbgPrint("UniFont!IDLGlyph:Value of pgb->sizlBitmap.cx is %d\n",
       pgb->sizlBitmap.cx );
       DbgPrint("UniFont!IDLGlyph:Value of pgb->sizlBitmap.cy is %d\n",
       pgb->sizlBitmap.cy );

       vPrintPCLCharHeader(chh);
       vPrintPCLChar((char*)pgb->aj,(WORD)pgb->sizlBitmap.cy,(WORD)pgb->sizlBitmap.cx);
    #endif

    /*
     *   Calculate some sizes of bitmaps:  coming from GDI, going to printer.
     */

    cbLines = (chh.wChWidth + BBITS - 1) / BBITS;
    cbTotal = sizeof( chh ) + cbLines * pgb->sizlBitmap.cy;

    /*   Do the big endian shuffle */
    SWAB( chh.sLOff );
    SWAB( chh.sTOff );
    SWAB( chh.wChWidth );
    SWAB( chh.wChHeight );
    SWAB( chh.wDeltaX );

    // If the char is a pseudo one don't download it.
    if ( !(pgd->ptqD.x.HighPart) )
    {

    #if PRINT_INFO
       DbgPrint("\nRasdd!IDLGlyph:Returning 0 for fake char\n");
    #endif
        return 0;
    }

    /*
     *    Presume that data is less than the maximum, and so can be
     *  sent in one hit.  Then loop on any remaining data.
     */

    cbSend = min( cbTotal, PCL_MAX_CHAR_HEADER_SIZE );

    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETCHARCODE));

    ASSERT(cbSend <= PCL_MAX_CHAR_HEADER_SIZE);

    ZeroMemory( aPCLCharHdrCmd, sizeof( aPCLCharHdrCmd ) );
    iCharHdrCmdLen = iDrvPrintfA( aPCLCharHdrCmd, "\x1B(s%dW", cbSend );
    PRINTVAL(iCharHdrCmdLen,%d);
    if( WriteSpoolBuf( pPDev, aPCLCharHdrCmd, iCharHdrCmdLen ) != iCharHdrCmdLen )
        return  0;

    if( WriteSpoolBuf( pPDev, (BYTE *)&chh, sizeof( chh ) ) != sizeof( chh ))
        return  0;

    /*   Sent some,  so reduce byte count to compensate */
    cbSend -= sizeof( chh );
    cbTotal -= sizeof( chh );

    cbTotal -= cbSend;                   /* Adjust for about to send data */
    if( WriteSpoolBuf( pPDev, pgb->aj, cbSend ) != cbSend )
        return  0;

    if( cbTotal > 0 )
    {
#if  DBG
        DbgPrint( "UniFont!IDLGlyph: cbTotal != 0:  NEEDS SENDING LOOP\n" );
#endif
        return  0;
    }

    *pdwMem += cbLines * pgb->sizlBitmap.cy;        /* Bytes used, roughly */

    return   (SWAB( chh.wDeltaX ) + 3) >> 2;   /* PCL is in quarter dots! */
}

#if PRINT_INFO
void vPrintPCLCharHeader(chh)
CH_HEADER    chh;
{
    DbgPrint("\nDUMPING FONT PCL GLYPH DESCRIPTOR\n");
    if(chh.bFormat == CH_FM_RASTER)
        DbgPrint("Value of chh.bFormat is CH_FM_RASTER\n");
    DbgPrint("Value of chh.bContinuation is %d \n",chh.bContinuation);
    DbgPrint("Value of chh.bDescSize is %d \n",chh.bDescSize);
    if(chh.bClass == CH_CL_BITMAP)
        DbgPrint("Value of chh.bClass is CH_CL_BITMAP \n");
    DbgPrint("Value of chh.bOrientation is %d \n",chh.bOrientation);
    DbgPrint("Value of chh.sLOff is %u \n",chh.sLOff);
    DbgPrint("Value of chh.sTOff is %u \n",chh.sTOff);
    DbgPrint("Value of chh.wChWidth is %u \n",chh.wChWidth);
    DbgPrint("Value of chh.wChHeight is %u \n",chh.wChHeight);
    DbgPrint("Value of chh.wDeltaX is %u \n",chh.wDeltaX);
}

void vPrintPCLFontHeader(sfh)
SF_HEADER20  sfh;
{
    DbgPrint("\nDUMPING FONT PCL FONT DESCRIPTOR\n");
    DbgPrint("Value of sfh.wSize is %d \n",sfh.wSize);

    if(sfh.bFormat == PCL_FM_RESOLUTION)
        DbgPrint("Value of sfh.bFormat is PCL_FM_RESOLUTION\n");
    else if (sfh.bFormat == PCL_FM_ORIGINAL)
        DbgPrint("Value of sfh.bFormat is PCL_FM_ORIGINAL\n");

    DbgPrint("Value of sfh.wXResn is %d \n",sfh.wXResn);
    DbgPrint("Value of sfh.wYResn is %d \n",sfh.wYResn);

    if(sfh.bFontType == PCL_FT_PC8)
        DbgPrint("Value of sfh.bFontType is PCL_FT_PC8\n");
    else if (sfh.bFontType == PCL_FT_8LIM)
        DbgPrint("Value of sfh.bFontType is PCL_FT_8LIM\n");

    DbgPrint("Value of sfh.wSymSet is %d \n",sfh.wSymSet);
    DbgPrint("Value of sfh.wBaseline is %d \n",sfh.wBaseline);
    DbgPrint("Value of sfh.wCellWide is %d \n",sfh.wCellWide);
    DbgPrint("Value of sfh.wCellHeight is %d \n",sfh.wCellHeight);
    DbgPrint("Value of sfh.bOrientation is %d \n",sfh.bOrientation);
    DbgPrint("Value of sfh.bSpacing is %d \n",sfh.bSpacing);
    DbgPrint("Value of sfh.wPitch is %d \n",sfh.wPitch);

    DbgPrint("Value of sfh.wHeight is %d \n",sfh.wHeight);
    DbgPrint("Value of sfh.wXHeight is %d \n",sfh.wXHeight);

    DbgPrint("Value of sfh.sbWidthType is %d \n",sfh.sbWidthType);
    DbgPrint("Value of sfh.bStyle is %d \n",sfh.bStyle);
    DbgPrint("Value of sfh.sbStrokeW is %d \n",sfh.sbStrokeW);
    DbgPrint("Value of sfh.bTypeface is %d \n",sfh.bTypeface);
    DbgPrint("Value of sfh.bSerifStyle is %d \n",sfh.bSerifStyle);
    DbgPrint("Value of sfh.sbUDist is %d \n",sfh.sbUDist);
    DbgPrint("Value of sfh.bUHeight is %d \n",sfh.bUHeight);
    DbgPrint("Value of sfh.wTextHeight is %d \n",sfh.wTextHeight);
    DbgPrint("Value of sfh.wTextWidth  is %d \n",sfh.wTextWidth);

    DbgPrint("Value of sfh.bPitchExt  is %d \n",sfh.bPitchExt);
    DbgPrint("Value of sfh.bHeightExt is %d \n",sfh.bHeightExt);

}

void vPrintPCLChar(pGlyphBits,wHeight,wWidth)
char * pGlyphBits;
WORD wHeight;
WORD wWidth;
{
    int iIndex1, iIndex2;
    char cMaskBits[8] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
    unsigned char bBitON;

    DbgPrint("\nDUMPING THE GLYPH BITS\n");
    for(iIndex1 = 0;iIndex1 < wHeight; iIndex1++)
    {
        for(iIndex2 = 0;iIndex2 < wWidth; iIndex2++)
        {
            bBitON = (pGlyphBits[iIndex2 / 8] & cMaskBits[iIndex2 % 8]);

            if (bBitON)
                DbgPrint("*");
            else
                DbgPrint("0");

            //if(!(iIndex2%8))
                //DbgPrint("%x ",(unsigned char)(*(pGlyphBits+(iIndex2/8))) );
            //DbgPrint("%x ",(unsigned char)(bBitON >> (7-(iIndex2%8))) );

        }
        pGlyphBits+= (wWidth+7) / 8;
        DbgPrint("\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\download.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    download.h

Abstract:

     Information required to download fonts to a printer:  either an
     existing softfont,  or cacheing of GDI fonts (esp. TT).

Environment:

    Windows NT Unidrv driver

Revision History:

    12/23/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _DOWNLOAD_H

#define _DOWNLOAD_H

//
//  GLYPHLIST structure. This structure hold the start and end glyph ids.
//
#define     INVALIDGLYPHID          0xffffffff
#define     HASHTABLESIZE_1         257        //Used if NumGlyphs is < 512
#define     HASHTABLESIZE_2         521        //Used if NmGlyhs is >= 512 && < 1024
#define     HASHTABLESIZE_3         1031       //Used if NmGlyhs is >= 1024

//
// Hash Table entry for glyphs. The entry has basically TT Glyph Handle and
// Downloaded FontIds and DL glyph ID. The hash table is an array of these
// entries. In the case of a Hit a new entry will be added as linked list
// off that entry.
//

typedef struct _DLGLYPH       //Size is 16 Bytes.
{
    HGLYPH              hTTGlyph;     // GDI glyph handle.
    WORD                wDLFontId;    // DL Font index. Bounded Fonts.
    WORD                wDLGlyphID;   // Download Glyph ID of unbounded fonts.
    WORD                wWidth;       // Width of the Glyph.
    WCHAR               wchUnicode;    // Reserved for padding.
    struct  _DLGLYPH    *pNext;       // Next Glyph
}DLGLYPH, *PDLGLYPH;

// The Glyphs are stored in Chunks, to optimize on allocation and
// deallocations.The first chunk is the base chunk and used as Hash table.
// The subsequent chunks are allocated when a collision occurs in the hash
// table. All the non base chunks has half the number of Glyphs as that of
// base chunk (cEntries is intialized to cHashTableEntries/2). The base hash
// table is dl_map.GlyphTab.pGlyph. we should free this pointer for base chunk.
// Base hash table is allocated in BInitDLMAP() function, which initialize the
// DL_MAP.

typedef  struct  _GLYPHTAB
{
    struct _GLYPHTAB   *pGLTNext;  // Next Chunk of Glyphs
    PDLGLYPH            pGlyph;    // Pointer to Next Glyph.
    INT                 cEntries;  // Number of Entries Remaining.
                                   // Not Used in Base Chunk.

}GLYPHTAB;

//
//   The DL_MAP structure provides a mapping between the iUniq value in
//  FONTOBJs and our internal information.  Basically, we need to decide
//  whether we have seen this font before,  and if so, whether it was
//  downloaded or left as a GDI font.
//

//
//  NOTE:  The cGlyphs field has another use.  It is used to mark a bad DL_MAP.
//  If it is -1, then this DL_MAP shouldn't be used. All other fields  will
//  be set to 0.
//


typedef  struct _DL_MAP
{
    ULONG       iUniq;              // FONTOBJ.iUniq
    ULONG_PTR    iTTUniq;            // FONTOBJ.iTTUniq
    SHORT       cGlyphs;            // Num of DL glyphs with current softfont
    WORD        cTotalGlyphs;       // Total Number of glyphs with this TT font
    WORD        wMaxGlyphSize;      // NumBytes in the bitmap for largest Glyph
    WORD        cHashTableEntries;  // Number of entries in the HASH table.
    WORD        wFirstDLGId;        // Start DL Glyph ID.
    WORD        wLastDLGId;         // End ID of the List. -1 if no END id
    WORD        wNextDLGId;         // Next DL Glyph ID to be downloaded.
    WORD        wBaseDLFontid;      // Downloaded Base font Id.
    WORD        wCurrFontId;        // Current Font ID to be used.
    WORD        wFlags;             // Different Flags.
    FONTMAP     *pfm;               // The real down load info
    GLYPHTAB    GlyphTab;           // Glyph Hash Table.It's Linked
                                    // list of Glyph Chunks.
}  DL_MAP;

//
// DL_MAP flags.
//
#define     DLM_BOUNDED         0x0001          // Soft font is bounded.
#define     DLM_UNBOUNDED       0x0002          // Soft font is unbounded.

//
//    The above is formed into an array of DL_MAP_CHUNK entries,  and this
//  group of storage is linked into a linked list of such entries. Typically,
//  there will be only one,  however we can cope with more.
//

#define  DL_MAP_CHUNK       8

typedef  struct  _DML
{

    struct _DML   *pDMLNext;                // An array of map information
    INT      cEntries;                      // Next in our chain, 0 in last
    DL_MAP   adlm[ DL_MAP_CHUNK ];          // Number of valid entries.

}  DL_MAP_LIST;



/*
 *   We need to map glyph handles to byte to send to printer.  We are given
 * the glyph handle, but need to send the byte instead.
 */

typedef  struct
{
    HGLYPH   hg;               /* The glyph to print */
    WCHAR    wchUnicode;
    int      iByte;            /* What to send to the printer */
} HGLYPH_MAP;


/*
 *   Random constants.
 */

#define PCL_FONT_OH      2048          /* Overhead bytes per download font */
#define PCL_PITCH_ADJ       2          /* Adjustment factor for proportional */

/*
 * macros
 */
#define     SWAPW(a)        (USHORT)(((BYTE)((a) >> 8)) | ((BYTE)(a) << 8))
#define     SWAPWINC(a)     SWAPW(*(a)); a++
#define     FONTDOWNLOADED(pdm) ( ((pdm)->pfm) && \
                               ((pdm)->pfm->flFlags &  \
                               (FM_SENT | FM_GEN_SFONT)) )
#define     GLYPHDOWNLOADED(pdlg) ( ((pdlg)->hTTGlyph != HGLYPH_INVALID) )

//
// Download Mode to identity base softfont or secondary soft font downloading.
//

#define     DL_BASE_SOFT_FONT           1
#define     DL_SECONDARY_SOFT_FONT      2

#define     MIN_GLYPHS_PER_SOFTFONT     64  // Minimum glyphs per softfont


#endif _DOWNLOAD_H //!_DOWNLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmcallbk.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmcallbk.c

Abstract:

    The font module callback helper functions

Environment:

    Windows NT Unidrv driver

Revision History:

    03/31/97 -eigos-
        Created

--*/

#include "font.h"

#define CALL_OEMOUTPUTCHARSTR(type, count, startpoint) \
    if(bCOMInterface) \
    { \
        HComOutputCharStr((POEM_PLUGIN_ENTRY)pPDev->pOemEntry, \
                        &pPDev->devobj, \
                        (PUNIFONTOBJ)pUFObj, \
                        (type), \
                        (count), \
                        (startpoint)); \
    } \
    else \
    { \
        if (pfnOEMOutputCharStr) \
        pfnOEMOutputCharStr(&pPDev->devobj, \
                            (PUNIFONTOBJ)pUFObj, \
                            (type), \
                            (count), \
                            (startpoint)); \
    }

#define GET_CHARWIDTH(width, pfontmap, hg) \
    if (pfontmap->flFlags & FM_WIDTHRES) \
    { \
        if (!(width = IGetUFMGlyphWidth(pPDev, pfontmap, hg))) \
            width = (INT)pIFIMet->fwdAveCharWidth; \
    } \
    else \
    { \
        if (pTrans[hg - 1].ubType & MTYPE_DOUBLE) \
            width = pIFIMet->fwdMaxCharInc; \
        else \
            width = pIFIMet->fwdAveCharWidth; \
    } \
    if (pfontmap->flFlags & FM_SCALABLE) \
    { \
        width = LMulFloatLong(&pFontPDev->ctl.eXScale,width); \
    }

//
// Local functions' prototype definition
//

WCHAR
WGHtoUnicode(
    DWORD     dwNumOfRuns,
    PGLYPHRUN pGlyphRun,
    HGLYPH    hg);

//
// UNIFONTOBJ callback interface
//

BOOL
UNIFONTOBJ_GetInfo(
    IN  PUNIFONTOBJ pUFObj,
    IN  DWORD       dwInfoID,
    IN  PVOID       pData,
    IN  DWORD       dwDataSize,
    OUT PDWORD      pcbNeeded)
/*++

Routine Description:

    Implementation of UNIFONTOBJ GetInfo function
    Please refer to DDK

Arguments:

    pUFOBj - a pointer to UNIFONTOBJ
    dwInfoID - Function ID
    pData - a pointer to data structure according to dwInfoID
    dwDataSize - size of pData
    pcbNeeded - DWORD buffer to return the necessary size of pData

Return Value:

    TRUE if successful, otherwise FALSE.

Note:


--*/
{
    PI_UNIFONTOBJ        pI_UFObj = (PI_UNIFONTOBJ)pUFObj;

    GETINFO_GLYPHSTRING* pGlyphString;
    GETINFO_GLYPHBITMAP* pGlyphBitmap;
    GETINFO_GLYPHWIDTH*  pGlyphWidth;
    GETINFO_STDVAR*      pStdVar;

    PFONTPDEV   pFontPDev;
    PUNI_GLYPHSETDATA  pGlyphData;
    PTRANSDATA  pTrans, pTransOut, pTransOutStart;
    PMAPTABLE   pMapTable;
    PGLYPHRUN   pGlyphRun;

    HGLYPH *pHGlyph;
    PDLGLYPH *apdlGlyph;
    PBYTE  pbString, pbOutput;
    LONG  *plWidth, lBuffSize;
    DWORD  *pGlyphID, dwI, dwJ;
    WCHAR  *pUnicode;
    DWORD   dwNumOfVar, dwCount, dwSVID, dwNumOfRuns, dwBuffSize;
    BOOL    bRet;

    static STDVARIABLE FontStdVariable[FNT_INFO_MAX] = {
        SV_PRINTDIRECTION,
        SV_GRAYPERCENT,
        SV_NEXTFONTID,
        SV_NEXTGLYPH,
        SV_FONTHEIGHT,
        SV_FONTWIDTH,
        SV_FONTBOLD,
        SV_FONTITALIC,
        SV_FONTUNDERLINE,
        SV_FONTSTRIKETHRU,
        SV_CURRENTFONTID,
        SV_TEXTYRES,
        SV_TEXTXRES,
        SV_FONTMAXWIDTH };

    //
    // Error check
    //
    if (!pI_UFObj )
    {
        ERR(("UNIFONTOBJ_GetInfo(): pUFObj is NULL.\n"));
        return FALSE;
    }

    if (!pData)
    //
    // pData == NULL case
    // Return the necessary buffer size
    //
    {
        bRet = TRUE;

        if (!pcbNeeded)
        {
            ERR(("UNIFONTOBJ_GetInfo(): pData and pcbNeed is NULL.\n"));
            bRet = FALSE;
        }
        else
        {
            switch (dwInfoID)
            {
            case UFO_GETINFO_FONTOBJ:
                *pcbNeeded = sizeof(GETINFO_FONTOBJ);
                break;
            case UFO_GETINFO_GLYPHSTRING:
                *pcbNeeded = sizeof(GETINFO_GLYPHSTRING);
                break;
            case UFO_GETINFO_GLYPHBITMAP:
                *pcbNeeded = sizeof(GETINFO_GLYPHBITMAP);
                break;
            case UFO_GETINFO_GLYPHWIDTH:
                *pcbNeeded = sizeof(GETINFO_GLYPHWIDTH);
                break;
            case UFO_GETINFO_MEMORY:
                *pcbNeeded = sizeof(GETINFO_MEMORY);
                break;
            case UFO_GETINFO_STDVARIABLE:
                *pcbNeeded = sizeof(GETINFO_STDVAR);
                break;
            default:
                *pcbNeeded = 0;
                bRet = FALSE;
                VERBOSE(("UNIFONTOBJ_GetInfo(): Invalid dwInfoID.\n"));
                break;
            }
        }
    }
    else
    {
        bRet = FALSE;

        //
        // ERROR CHECK LIST
        // (A) Data structure size check
        //     GETINFO_FONTOBJ
        //     GETINFO_GLYPHYSTRING
        //     GETINFO_GLYPHBITMAP
        //     GETINFO_GLYPHWIDTH
        //     GETINFO_MEORY
        //     GETNFO_STDVARIABLE
        // (B) Necessary data pointer check
        //     e.g. pI_UFObj->XXXX
        //
        switch (dwInfoID)
        {
        case UFO_GETINFO_FONTOBJ:

            //
            // Return FONTOBJ data in GETINFO_FONTOBJ
            //     typedef struct _GETINFO_FONTOBJ {
            //        DWORD    dwSize;   // Size of this structure
            //        FONTOBJ *pFontObj; // Pointer to the FONTOBJ
            //     } GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;
            //
            // ERROR CHECK
            // (A) and (B)
            // (B) pI_UFObj->pFontObj
            //
            if (((GETINFO_FONTOBJ*)pData)->dwSize != sizeof(GETINFO_FONTOBJ) || !pI_UFObj->pFontObj)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pData or pUFObj is invalid.\n"));
                break;
            }

            ((GETINFO_FONTOBJ*)pData)->pFontObj = pI_UFObj->pFontObj;
            bRet = TRUE;
            break;

        case UFO_GETINFO_GLYPHSTRING:
            //
            // Return glyph string
            //
            //     typedef struct _GETINFO_GLYPHSTRING {
            //         DWORD dwSize;    // Size of this structure
            //         DWORD dwCount;   // Count of glyphs in pGlyphIn
            //         DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
            //         PVOID pGlyphIn;  // Pointer to the input glyph string
            //         DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
            //         PVOID pGlyphOut; // Pointer to the output glyph string
            //         DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
            //     } GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;
            //
            //
            //  OutputGlyph callback function receives
            //          1. GLYPH HANLDE for Device font
            //          2. GLYPH ID for TrueType font
            //
            //  In TYPE_GLYPHHANDLE (Device font)
            //      Out TYPE_UNICODE
            //          TYPE_TRANSDATA
            //
            //  In TYPE_GLYPHID (TrueType font)
            //      Out TYPE_UNICODE
            //      Out TYPE_GLYPHHANDLE
            //
            //  <Special case for TYPE_GLYPHHANDLE -> TYPE_TRANSDATA conversion>
            //  TRANSDATA could have MTYPE_COMPOSE so that UNIDRV doesn't know the size of output buffer.
            //  At the first call, a minidriver sets 0 to dwGlyphOutSize.
            //  Then UNIDRV returns necessary buffer size in dwGlyphOutSize.
            //  At the second call, a minidriver allocates memory, set the pointer of it to pGlyphOut,
            //  and set the size to dwGlyphOutSize.
            //
            //

            pGlyphString = pData;
            dwCount = pGlyphString->dwCount;

            if (!dwCount)
            {
                //
                // No operation is necessary.
                //
                break;
            }

            //
            // ERROR CHECK (A)
            // pGlyphString
            //
            if ( !pGlyphString->pGlyphIn                             ||
                    pGlyphString->dwTypeOut != TYPE_TRANSDATA &&
                    !pGlyphString->pGlyphOut                         )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pData is invalid.\n"));
                break;
            }

            //
            // Now we support type size of GETINFO_GLYPHSTRING.
            // This is a bug backward compatibility.
            // Before beta 3 GETINFO_GLYPHSTRING didn't have dwGlyphOutSize.
            // Now we have new data structure but don't change the name of
            // structure.
            //
            if (!(
                  (pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING)) ||
                  (pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING) - sizeof(DWORD))
                 )
               )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pData is invalid.\n"));
                break;
            }

            //
            // ERROR CHECK (B)
            // pI_UFObj->pFontMap
            // pI_UFObj->pPDev
            //
            if (!pI_UFObj->pFontMap || !pI_UFObj->pPDev)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pUFObj is invalid.\n"));
                break;
            }

            switch(pGlyphString->dwTypeIn)
            {
            case TYPE_GLYPHHANDLE:

                //
                // Device font case
                //

                if ( pI_UFObj->pFontMap->dwFontType == FMTYPE_DEVICE )
                {
                    pHGlyph     = pGlyphString->pGlyphIn;
                    pGlyphData  = ((PFONTMAP_DEV)pI_UFObj->pFontMap->pSubFM)->pvNTGlyph;
                    dwNumOfRuns = pGlyphData->dwRunCount;

                    switch(pGlyphString->dwTypeOut)
                    {
                    case TYPE_UNICODE:
                        pUnicode = pGlyphString->pGlyphOut;
                        pGlyphRun = GET_GLYPHRUN(pGlyphData);

                        while (dwCount--)
                        {
                            *pUnicode++ = WGHtoUnicode(dwNumOfRuns,
                                                       pGlyphRun,
                                                       *pHGlyph++);
                        }
                        bRet = TRUE;
                        break;

                    case TYPE_TRANSDATA:
                        pTransOutStart = pTransOut = pGlyphString->pGlyphOut;
                        pMapTable = GET_MAPTABLE(pGlyphData);
                        pTrans    = pMapTable->Trans;
                        dwBuffSize = pGlyphString->dwGlyphOutSize;

                        //
                        // New version of GETINFO_GLYPYSTRING
                        //
                        if ( pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING) )
                        {
                            if (0 == dwBuffSize)
                            {
                                while (dwCount --)
                                {
                                    if (!(pTrans[*pHGlyph - 1].ubType & MTYPE_COMPOSE))
                                    {
                                        dwBuffSize += sizeof(TRANSDATA);
                                    }
                                    else
                                    {
                                        pbString =  (PBYTE)pMapTable + pTrans[*pHGlyph - 1].uCode.sCode;
                                        dwBuffSize += sizeof(TRANSDATA) + *(PWORD)pbString + sizeof(WORD);
                                    }

                                    pHGlyph++;
                                }
                                pGlyphString->dwGlyphOutSize = dwBuffSize;
                            }
                            else
                            {
                                //
                                // Initialize the MTYPE_COMPOSE buffer
                                //
                                pbOutput = (PBYTE)pTransOutStart + dwCount * sizeof(TRANSDATA);

                                lBuffSize = dwBuffSize - dwCount * sizeof(TRANSDATA);

                                if (lBuffSize < 0 || NULL == pTransOut)
                                {
                                    break;
                                }
                                else
                                {
                                    bRet = TRUE;
                                    while (dwCount --)
                                    {
                                        *pTransOut = pTrans[*pHGlyph - 1];

                                        if (pTrans[*pHGlyph - 1].ubType & MTYPE_COMPOSE)
                                        {
                                            pbString =  (PBYTE)pMapTable + pTrans[*pHGlyph - 1].uCode.sCode;
                                            if (lBuffSize >= *(PWORD)pbString)
                                            {
                                                pTransOut->uCode.sCode = (SHORT)(pbOutput - (PBYTE)pTransOutStart);
                                                CopyMemory(pbOutput, pbString, *(PWORD)pbString + sizeof(WORD));
                                                pbOutput += *(PWORD)pbString + sizeof(WORD);

                                                lBuffSize -= *(PWORD)pbString + sizeof(WORD);
                                            }
                                            else
                                            {
                                                bRet = FALSE;
                                                break;
                                            }
                                        }

                                        pTransOut ++;
                                        pHGlyph ++;
                                    }
                                }
                            }
                        }
                        //
                        // New version of GETINFO_GLYPYSTRING
                        //
                        else if ( pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING) - sizeof(DWORD) )
                        {
                            pTransOut = pGlyphString->pGlyphOut;
                            pMapTable = GET_MAPTABLE(pGlyphData);
                            pTrans    = pMapTable->Trans;

                            while (dwCount --)
                            {
                                *pTransOut++ = pTrans[*pHGlyph++ - 1];
                            }
                            bRet = TRUE;
                        }
                        break;

                    default:
                        break;
                    }
                }
                break;

            case TYPE_GLYPHID:
                //
                // TrueType font case
                //

                pGlyphID = (PDWORD)pGlyphString->pGlyphIn;
                apdlGlyph = pI_UFObj->apdlGlyph;

                if (!apdlGlyph)
                {
                    ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHSTRING): pUFObj is not correct.\n"));
                    break;
                }

                if (pI_UFObj->pFontMap->dwFontType == FMTYPE_TTOEM)
                {
                    switch (pGlyphString->dwTypeOut)
                    {
                    case TYPE_UNICODE:
                        pUnicode = pGlyphString->pGlyphOut;
                        while (dwCount--)
                        {
                            *pUnicode = 0;
                            for (dwI = 0; dwI < pI_UFObj->dwNumInGlyphTbl; dwI++, apdlGlyph++)
                            {
                                if ((*apdlGlyph)->wDLGlyphID == (0x0ffff & *pGlyphID))
                                {
                                    *pUnicode = (*apdlGlyph)->wchUnicode;
                                    break;
                                }
                            }
                            pGlyphID ++;
                            pUnicode ++;
                        }
                        bRet = TRUE;
                        break;

                    case TYPE_GLYPHHANDLE:
                        pHGlyph = pGlyphString->pGlyphOut;
                        while (dwCount--)
                        {
                            *pHGlyph = 0;
                            for (dwI = 0; dwI < pI_UFObj->dwNumInGlyphTbl; dwI++, apdlGlyph++)
                            {
                                if ((*apdlGlyph)->wDLGlyphID == (0x0ffff & *pGlyphID))
                                {
                                    *pHGlyph = (*apdlGlyph)->hTTGlyph;
                                    break;
                                }
                            }
                            pGlyphID ++;
                            pHGlyph ++;
                        }
                        bRet = TRUE;
                        break;
                    }
                }
                break;
            }
            break;

        case UFO_GETINFO_GLYPHBITMAP:
            //
            // Return Glyph Bitmap
            //
            // typedef struct _GETINFO_GLYPHBITMAP {
            //     DWORD       dwSize;    // Size of this structure
            //     HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
            //     GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
            // } GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;
            //

            pGlyphBitmap = pData;

            //
            // Error check (A) and (B)
            // (B) pI_UFObj->pFontObj
            //
            if (!pI_UFObj->pFontObj || pGlyphBitmap->dwSize != sizeof(GETINFO_GLYPHBITMAP))
                break;

            if (FONTOBJ_cGetGlyphs(pI_UFObj->pFontObj,
                               FO_GLYPHBITS,
                               1,
                               &pGlyphBitmap->hGlyph,
                               &pGlyphBitmap->pGlyphData)        )
            {
                bRet = TRUE;
            }
            break;

        case UFO_GETINFO_GLYPHWIDTH:
            //
            // Return glyph width.
            //
            // typedef struct _GETINFO_GLYPHWIDTH {
            //     DWORD dwSize;  // Size of this structure
            //     DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
            //     DWORD dwCount; // Count of glyph in pGlyph
            //     PVOID pGlyph;  // Pointer to a glyph string
            //     PLONG plWidth; // Pointer to the buffer of width table.
            //                    // Minidriver has to prepare this.
            // } GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;
            //
            pGlyphWidth = pData;

            //
            // Error check (A)
            //
            if ((pGlyphWidth->dwSize != sizeof(GETINFO_GLYPHWIDTH))||
                !(plWidth  = pGlyphWidth->plWidth)                 ||
                !(pGlyphID = pGlyphWidth->pGlyph)                   )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHWIDTH): pData is not correct.\n"));
                break;
            }

            //
            // Error check (B)
            // pI_UFObj->pPDev
            // pI_UFObj->pFontObj
            //
            if (!pI_UFObj->pPDev)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHWIDTH): pUFObj is not correct.\n"));
                break;
            }

            switch(pGlyphWidth->dwType)
            {
            case TYPE_GLYPHID:
                if (pUFObj->dwFlags & UFOFLAG_TTFONT)
                {
                    HGLYPH hGlyph;

                    if (!pI_UFObj->pFontObj)
                    {
                        ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHWIDTH): UNIDRV needs FONTOBJ. This must be white text case!\n"));
                        break;
                    }

                    for (dwI = 0, pGlyphID = pGlyphWidth->pGlyph;
                         dwI < pGlyphWidth->dwCount;
                         dwI ++, pGlyphID ++, plWidth++)
                    {
                        apdlGlyph = pI_UFObj->apdlGlyph;

                        for (dwJ = 0;
                             dwJ < pI_UFObj->dwNumInGlyphTbl;
                             dwJ++ , apdlGlyph++)
                        {
                            if ((*apdlGlyph)->wDLGlyphID == (0x0ffff & *pGlyphID))
                            {
	hGlyph = (*apdlGlyph)->hTTGlyph;
	break;
                            }
                        }
                        *plWidth= DwGetTTGlyphWidth(pI_UFObj->pPDev->pFontPDev,
                                                    pI_UFObj->pFontObj,
                                                    hGlyph);
                    }
                    bRet = TRUE;
                }
                break;

            case TYPE_GLYPHHANDLE:
                if (!(pUFObj->dwFlags & UFOFLAG_TTFONT))
                {
                    for (dwI = 0,pHGlyph = pGlyphWidth->pGlyph;
                         dwI < pGlyphWidth->dwCount;
                         dwI ++, pHGlyph++, plWidth++)
                    {
                        *plWidth = IGetUFMGlyphWidthJr(&pI_UFObj->ptGrxRes,
                                                       pI_UFObj->pFontMap,
                                                       *pHGlyph);
                    }
                    bRet = TRUE;
                }
                break;

            }
            break;

        case UFO_GETINFO_MEMORY:
            //
            // Retuen available memory on the printer.
            //
            // typedef struct _GETINFO_MEMORY {
            //     DWORD dwSize;
            //     DWORD dwRemainingMemory;
            // } GETINFO_MEMORY, PGETINFO_MEMROY;

            //
            // Error check (A)
            //
            if (((GETINFO_MEMORY*)pData)->dwSize != sizeof(GETINFO_MEMORY))
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_MEMORY): pData is not correct.\n"));
                break;
            }

            //
            // Error check (B)
            // pI_UFObj->pPDev
            // pI_UFObj->pPDev->pFontPDev
            //
            if (!pI_UFObj->pPDev || !(pFontPDev = pI_UFObj->pPDev->pFontPDev))
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_MEMORY): pUFObj is not correct.\n"));
                break;
            }

            ((GETINFO_MEMORY*)pData)->dwRemainingMemory = pFontPDev->dwFontMem;
            bRet = TRUE;
            break;

        case UFO_GETINFO_STDVARIABLE:
            //
            // Return standard variables
            //
            //typedef struct _GETINFO_STDVAR {
            //    DWORD dwSize;
            //    DWORD dwNumOfVariable;
            //    struct {
            //        DWORD dwStdVarID;
            //        LONG  lStdVariable;
            //    } StdVar[1];
            //} GETINFO_STDVAR, *PGETINFO_STDVAR;
            //
            //
            // FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
            // FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
            // FNT_INFO_NEXTFONTID           2 // NextfontID
            // FNT_INFO_NEXTGLYPH            3 // NextGlyph
            // FNT_INFO_FONTHEIGHT           4 // FontHeight
            // FNT_INFO_FONTWIDTH            5 // FontWidth
            // FNT_INFO_FONTBOLD             6 // FontBold
            // FNT_INFO_FONTITALIC           7 // FontItalic
            // FNT_INFO_FONTUNDERLINE        8 // FontUnderline
            // FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
            // FNT_INFO_CURRENTFONTID       10 // Current
            // FNT_INFO_TEXTYRES            11 // TextYRes
            // FNT_INFO_TEXTXRES            12 // TextXRes
            // FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
            //

            pStdVar = pData;


            //
            // Error check (A)
            //
            if (    (pStdVar->dwSize != sizeof(GETINFO_STDVAR) +
                     ((dwNumOfVar = pStdVar->dwNumOfVariable) - 1) * 2 * sizeof(DWORD))
               )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETIFNO_STDVARIABLE): pData is incorrect.\n"));
                break;
            }

            //
            // Error check (B)
            // pI_UFObj->pPDev
            //
            if (!pI_UFObj->pPDev)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_STDVARIABLE): pUFObj is not correct.\n"));
                break;
            }

            bRet = TRUE;
            while (dwNumOfVar--)
            {
                dwSVID =
                    FontStdVariable[pStdVar->StdVar[dwNumOfVar].dwStdVarID];

                if (dwSVID > SV_MAX)
                {
                    bRet = FALSE;
                    ERR(("UFONTOBJ_GetInfo(UFO_GETIFNO_STDVARIABLE): pData is incorrect.\n"));
                    break;
                }
                pStdVar->StdVar[dwNumOfVar].lStdVariable = *(pI_UFObj->pPDev->arStdPtrs[dwSVID]);
            }
            break;

        default:
            VERBOSE(("UNIFONTOBJ_GetInfo(): Invalid dwInfoID.\n"));
            break;
        }
    }

    return bRet;
}

//
// Font module FONTMAP functions
//

DWORD
DwOutputGlyphCallback(
    TO_DATA *pTod)
/*++

Routine Description:

    Implementation of OEM OutpuotGlyphCallback calling routine for FONTMAP dispatch routine

Arguments:

    pTod - a pointer to TO_DATA.

Return Value:

    The number of glyph printed.

Note:


--*/
{
    PFN_OEMOutputCharStr pfnOEMOutputCharStr;
    PI_UNIFONTOBJ pUFObj;
    IFIMETRICS   *pIFIMet;
    PFONTPDEV     pFontPDev;
    PDEV         *pPDev;
    PUNI_GLYPHSETDATA  pGlyphData;
    PTRANSDATA    pTrans;
    PMAPTABLE     pMapTable;
    COMMAND      *pCmd, *pCmdSingle, *pCmdDouble;
    FONTMAP      *pFontMap;
    GLYPHPOS     *pgp;
    PDLGLYPH      pdlGlyph;
    POINTL        ptlRem;
    DWORD         dwI, dwCount;
    PDWORD        pdwGlyph, pdwGlyphStart;
    INT           iXInc, iYInc;
    BOOL          bSetCursorForEachGlyph, bPrint, bNewFontSelect, bCOMInterface;

    bCOMInterface = FALSE;

    pPDev     = pTod->pPDev;
    ASSERT(pPDev)

    pFontPDev = pPDev->pFontPDev;
    ASSERT(pFontPDev)

    pFontMap  = pTod->pfm;
    pUFObj    = (PI_UNIFONTOBJ)pFontPDev->pUFObj;
    ASSERT(pFontMap && pUFObj)

    pIFIMet = pFontMap->pIFIMet;
    ASSERT(pIFIMet)

    pfnOEMOutputCharStr = NULL;

    if ( pPDev->pOemHookInfo &&
        (pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook))
    {
        FIX_DEVOBJ(pPDev, EP_OEMOutputCharStr);
        if( pPDev->pOemEntry && ((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )
        {
            bCOMInterface = TRUE;
        }
        else
        {
            pfnOEMOutputCharStr = (PFN_OEMOutputCharStr)pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook;
        }
    }
    else if (pPDev->ePersonality != kPCLXL)
    {
        ERR(("DwOutputGlyphCallback: OEMOutputCharStr callback is not supported by a minidriver."));
        return 0;
    }

    //
    // Error exit
    //
    if (pFontMap->flFlags & FM_IFIVER40 || pUFObj->pGlyph == NULL)
    {
        ERR(("DwOutputGlyphCallback: pUFObj->pGlyph is NULL."));
        return 0;
    }

    //
    // OEMOutputCharStr passes two type of glyph string.
    // TYPE_GLYPHID for TrueType font
    // TYPE_GLYPHHANDLE for Device font
    //

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    pdwGlyphStart =
    pdwGlyph = (PDWORD)pUFObj->pGlyph;
    pgp    = pTod->pgp;

    pUFObj->pFontMap = pFontMap;

    if (pUFObj->dwFlags & UFOFLAG_TTFONT)
    {
        DWORD    dwCurrGlyphIndex = pTod->dwCurrGlyph;
        PFONTMAP_TTOEM pFMOEM = (PFONTMAP_TTOEM) pFontMap->pSubFM;
        DL_MAP   *pdm = pFMOEM->u.pvDLData;

        ASSERT(pTod->apdlGlyph);

        if (bSetCursorForEachGlyph)
        {
            for (dwI = 0;
                 dwI < pTod->cGlyphsToPrint;
                 dwI++, pgp++, dwCurrGlyphIndex++)
            {
                pdlGlyph = pTod->apdlGlyph[dwCurrGlyphIndex];
                if (!pdlGlyph)
                {
                    //
                    // pFM->pfnDownloadGlyph could fail by some reason.
                    // Eventually apdlGlyph is not initialized by download.c
                    //
                    ERR(("DwOutputGlyphCallback: pTod->apdlGlyph[dwCurrGlyphIndex] is NULL."));
                    continue;
                }

                if (GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph))
                {
                    //
                    // Need to select the new softfont.
                    // We do this by setting pfm->ulDLIndex
                    // to new softfontid.
                    //

                    pUFObj->ulFontID =
                    pFontMap->ulDLIndex = pdlGlyph->wDLFontId;
                    BNewFont(pPDev, pTod->iFace, pFontMap, 0);
                }

                VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

                HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
                                                            (PUNIFONTOBJ)pUFObj,
                                                            TYPE_GLYPHID,
                                                            1,
                                                            &(pdlGlyph->wDLGlyphID)))
                else

                CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHID, 1, &(pdlGlyph->wDLGlyphID));

                //
                // Update position
                //
                VSetCursor( pPDev,
                            pdlGlyph->wWidth,
                            0,
                            MOVE_RELATIVE|MOVE_UPDATE,
                            &ptlRem);

            }
        }
        else
        {
            VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

            dwI = 0;
            dwCount = 0;
            bNewFontSelect = FALSE;

            do
            {
                for (; dwI < pTod->cGlyphsToPrint; pdwGlyph++, dwCount++, pgp++, dwI++, dwCurrGlyphIndex++)
                {
                    pdlGlyph = pTod->apdlGlyph[dwCurrGlyphIndex];

                    if (0 == pgp->hg)
                    {
                        //
                        // UNIDRV returns 1 for the first glyph handle
                        // in FD_GLYPHSET.
                        // However, GDI could pass zero in hg.
                        // We need to handle this GDI error properly.
                        continue;
                    }

                    if (!pdlGlyph)
                    {
                        //
                        // pFM->pfnDownloadGlyph could fail by some reason.
                        // Eventually apdlGlyph is not initialized by download.c
                        //
                        ERR(("DwOutputGlyphCallback: pTod->apdlGlyph[dwCurrGlyphIndex++] is NULL."));
                        continue;
                    }

                    *pdwGlyph = pdlGlyph->wDLGlyphID;

                    if (GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph))
                    {
                        //
                        // Need to select the new softfont.
                        // We do this by setting pfm->ulDLIndex
                        // to new softfontid.
                        //

                        pFontMap->ulDLIndex = pdlGlyph->wDLFontId;
                        bNewFontSelect = TRUE;
                        break;
                    }
                }

                if (dwCount > 0)
                {
                    HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
                                                                (PUNIFONTOBJ)pUFObj,
                                                                TYPE_GLYPHID,
                                                                dwCount,
                                                                pdwGlyphStart))
                    else
                    CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHID, dwCount, pdwGlyphStart);

                    //
                    // Update position
                    //
                    pgp --;
                    VSetCursor( pPDev,
                                pgp->ptl.x + pdlGlyph->wWidth,
                                pgp->ptl.y,
                                MOVE_ABSOLUTE|MOVE_UPDATE,
                                &ptlRem);
                    dwCount = 0;
                }

                if (bNewFontSelect)
                {
                    dwCount = 1;
                    *pdwGlyphStart = *pdwGlyph;
                    pdwGlyph = pdwGlyphStart + 1;
                    pUFObj->ulFontID = pFontMap->ulDLIndex;

                    BNewFont(pPDev, pTod->iFace, pFontMap, 0);
                    bNewFontSelect = FALSE;
                }

            } while (dwCount > 0);

        }

        pgp --;
        if (NULL != pdlGlyph)
        {
            iXInc = pdlGlyph->wWidth;
        }
        else
        {
            iXInc = 0;
        }
    }
    else // Device Font
    {
        pGlyphData  = ((PFONTMAP_DEV)pFontMap->pSubFM)->pvNTGlyph;
        pMapTable   = GET_MAPTABLE(pGlyphData);
        pTrans      = pMapTable->Trans;
        pCmdSingle  = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTSINGLEBYTEMODE);
        pCmdDouble  = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTDOUBLEBYTEMODE);

        if (bSetCursorForEachGlyph)
        {
            for (dwI = 0; dwI < pTod->cGlyphsToPrint; dwI ++, pgp ++)
            {
                //
                // UNIDRV returns 1 for the first glyph handle in FD_GLYPHSET.
                // However, GDI could pass zero in hg.
                // We need to handle this GDI error properly.
                // 
                if (0 == pgp->hg)
                {
                    continue;
                }

                VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

                if (
                    (pCmdSingle)                                &&
                    (pTrans[pgp->hg - 1].ubType & MTYPE_SINGLE) &&
                    !(pFontPDev->flFlags & FDV_SINGLE_BYTE)
                   )
                {
                    WriteChannel( pPDev, pCmdSingle );
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE;
                }
                else
                if (
                    (pCmdDouble)                                  &&
                    (pTrans[pgp->hg - 1].ubType & MTYPE_DOUBLE) &&
                    !(pFontPDev->flFlags & FDV_DOUBLE_BYTE)
                   )
                {
                    WriteChannel( pPDev, pCmdDouble );
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_SINGLE_BYTE;
                }


                HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
                                                            (PUNIFONTOBJ)pUFObj,
                                                            TYPE_GLYPHHANDLE,
                                                            1,
                                                            &(pgp->hg)))
                else
                CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHHANDLE, 1, &(pgp->hg));

                //
                // Update position
                //
                GET_CHARWIDTH(iXInc, pFontMap, pgp->hg);

                VSetCursor( pPDev,
                            iXInc,
                            0,
                            MOVE_RELATIVE|MOVE_UPDATE,
                            &ptlRem);
            }
        }
        else // Default Placement
        {
            bPrint  = FALSE;
            dwCount = 0;
            VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

            for (dwI = 0; dwI < pTod->cGlyphsToPrint; dwI ++, pgp ++, pdwGlyph ++, dwCount++)
            {
                *pdwGlyph = pgp->hg;

                //
                // Single/Double byte mode switch
                //

                if (pCmdSingle &&
                    (pTrans[*pdwGlyph - 1].ubType & MTYPE_SINGLE) &&
                    !(pFontPDev->flFlags & FDV_SINGLE_BYTE)  )
                {

                    pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
                    pCmd = pCmdSingle;
                    bPrint = TRUE;
                }
                else
                if (pCmdDouble &&
                    (pTrans[*pdwGlyph - 1].ubType & MTYPE_DOUBLE)   &&
                    !(pFontPDev->flFlags & FDV_DOUBLE_BYTE) )
                {
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_SINGLE_BYTE;
                    pCmd = pCmdDouble;
                    bPrint = TRUE;
                }


                if (bPrint)
                {
                    if (dwI != 0)
                    {
                        HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
		    (PUNIFONTOBJ)pUFObj,
		    TYPE_GLYPHHANDLE,
		    dwCount,
		    pdwGlyphStart))
                        else
                        CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHHANDLE, dwCount, pdwGlyphStart);

                        //
                        // Update position
                        //
                        GET_CHARWIDTH(iXInc, pFontMap, pgp->hg);
                        VSetCursor( pPDev,
                                    iXInc,
                                    0,
                                    MOVE_RELATIVE|MOVE_UPDATE,
                                    &ptlRem);

                        dwCount = 0;
                        pdwGlyphStart = pdwGlyph;
                    }

                    WriteChannel(pPDev, pCmd);
                    bPrint = FALSE;
                }
            }

            HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
	                        (PUNIFONTOBJ)pUFObj,
	                        TYPE_GLYPHHANDLE,
	                        dwCount,
	                        pdwGlyphStart))
            else
            CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHHANDLE, dwCount, pdwGlyphStart);

        }


        //
        // Output may have successed, so update the position.
        //

        pgp --;

        GET_CHARWIDTH(iXInc, pFontMap, pgp->hg);

        VSetCursor( pPDev,
                    pgp->ptl.x + iXInc,
                    pgp->ptl.y,
                    MOVE_ABSOLUTE|MOVE_UPDATE,
                    &ptlRem);
    }


    return pTod->cGlyphsToPrint;

}

BOOL
BFontCmdCallback(
    PDEV     *pdev,
    PFONTMAP  pFM,
    POINTL   *pptl,
    BOOL      bSelect)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling sub routine for FONTMAP dispatch routine

Arguments:

    pdev - a pointer to PDEV
    pFM - a pointer to FONTMAP
    pptl - a pointer to POINTL which has the height and with of font
    bSelect - Boolean to send selection/deselection command

Return Value:

    TRUE if successful, otherwise FALSE.

Note:


--*/
{
    PFN_OEMSendFontCmd  pfnOEMSendFontCmd;
    FONTPDEV           *pFontPDev;
    PFONTMAP_DEV        pfmdev;
    FINVOCATION         FInv;

    ASSERT(pdev && pFM);

    if (pdev->pOemHookInfo &&
        (pfnOEMSendFontCmd = (PFN_OEMSendFontCmd)pdev->pOemHookInfo[EP_OEMSendFontCmd].pfnHook) ||
       (pdev->ePersonality == kPCLXL))
    {
        pFontPDev = pdev->pFontPDev;
        pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE | FDV_SINGLE_BYTE;

        if (pFM->dwFontType == FMTYPE_DEVICE)
        {
            pfmdev    = pFM->pSubFM;
            pfmdev->ulCodepageID = (ULONG)-1;
            pFontPDev->pUFObj->pFontMap = pFM;

            if (pFM->flFlags & FM_IFIVER40)
            {
                if (bSelect)
                {
                    FInv.dwCount    = pfmdev->cmdFontSel.pCD->wLength;
                    FInv.pubCommand = pfmdev->cmdFontSel.pCD->rgchCmd;
                }
                else
                {
                    FInv.dwCount    = pfmdev->cmdFontDesel.pCD->wLength;
                    FInv.pubCommand = pfmdev->cmdFontDesel.pCD->rgchCmd;
                }
            }
            else
            {
                if (bSelect)
                {
                    FInv.dwCount    = pfmdev->cmdFontSel.FInv.dwCount;
                    FInv.pubCommand = pfmdev->cmdFontSel.FInv.pubCommand;
                }
                else
                {
                    FInv.dwCount    = pfmdev->cmdFontDesel.FInv.dwCount;
                    FInv.pubCommand = pfmdev->cmdFontDesel.FInv.pubCommand;
                }
            }
        }
        else
        if (pFM->dwFontType == FMTYPE_TTOEM)
        {
            //
            // Initialize UNIFONTOBJ
            //
            pFontPDev->pUFObj->ulFontID = pFM->ulDLIndex;
            pFontPDev->pUFObj->pFontMap = pFM;

            //
            // Initialize FInv
            //
            FInv.dwCount = sizeof(ULONG);
            FInv.pubCommand = (PBYTE)&(pFontPDev->pUFObj->ulFontID);
        }



        HANDLE_VECTORPROCS(pdev, VMSendFontCmd, ((PDEVOBJ)pdev,
                                                 (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                 &FInv))
        else
        {
            FIX_DEVOBJ(pdev, EP_OEMSendFontCmd);
            if (pdev->pOemEntry)
            {
    
                if(((POEM_PLUGIN_ENTRY)pdev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                {
                        HRESULT  hr ;
                        hr = HComSendFontCmd((POEM_PLUGIN_ENTRY)pdev->pOemEntry,
                                      &pdev->devobj, (PUNIFONTOBJ)pFontPDev->pUFObj,
                                      &FInv);
                        if(SUCCEEDED(hr))
                            ;  //  cool !
                }
                else
                {
					if (NULL != pfnOEMSendFontCmd)
					{
						pfnOEMSendFontCmd(&pdev->devobj,
										  (PUNIFONTOBJ)pFontPDev->pUFObj,
										  &FInv);
					}
                }
            }
        }

    }

    return TRUE;
}

BOOL
BSelectFontCallback(
    PDEV   *pdev,
    PFONTMAP  pFM,
    POINTL *pptl)
/*++

Routine Description:

    Implementation of OEM SendFontCMd calling routine for FONTMAP dispatch routine

Arguments:

    pTod - a pointer to TO_DATA.

Return Value:

    The number of glyph printed.

Note:


--*/
{
    return BFontCmdCallback(pdev, pFM, pptl, TRUE);
}

BOOL
BDeselectFontCallback(
    PDEV     *pdev,
    PFONTMAP pFM)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling routine for FONTMAP dispatch routine

Arguments:

    pTod - a pointer to TO_DATA.

Return Value:

    The number of glyph printed.

Note:


--*/
{

    return BFontCmdCallback(pdev, pFM, NULL, FALSE);
}


DWORD
DwDLHeaderOEMCallback(
    PDEV *pPDev,
    PFONTMAP pFM)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling routine for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pFM - a pointer to FONTMAP

Return Value:


Note:


--*/
{
    PFN_OEMDownloadFontHeader pfnOEMDownloadFontHeader;
    PFONTPDEV pFontPDev;
    DWORD dwMem = 0;

    //
    // Should not be NULL
    //
    ASSERT(pPDev && pFM);

    pFontPDev = pPDev->pFontPDev;
    pfnOEMDownloadFontHeader = NULL;

    if ( pPDev->pOemHookInfo &&
        (pfnOEMDownloadFontHeader = (PFN_OEMDownloadFontHeader)
         pPDev->pOemHookInfo[EP_OEMDownloadFontHeader].pfnHook) ||
        (pPDev->ePersonality == kPCLXL))
    {
        HRESULT  hr ;

        if (pFontPDev->pUFObj == NULL)
        {
            //
            // This should not happen. pUFObj must be initialized.
            //
            ERR(("DwDLHeaderOEMCallback: pFontPDev->pUFObj is NULL"));
            return 0;
        }

        pFontPDev->pUFObj->pFontMap = pFM;
        pFontPDev->pUFObj->ulFontID = pFM->ulDLIndex;
        BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_NFID);
        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));

        HANDLE_VECTORPROCS(pPDev, VMDownloadFontHeader, ((PDEVOBJ)pPDev,
                                                         (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                         &dwMem))
        else
        {
            FIX_DEVOBJ(pPDev, EP_OEMDownloadFontHeader);
            if (pPDev->pOemEntry)
            {
    
                if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                {
                        hr = HComDownloadFontHeader((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                    &pPDev->devobj, (PUNIFONTOBJ)pFontPDev->pUFObj, &dwMem);
                        if(SUCCEEDED(hr))
                            ;  //  cool !
                }
                else if (pfnOEMDownloadFontHeader)
                {
                    dwMem = pfnOEMDownloadFontHeader(&pPDev->devobj,
                                                     (PUNIFONTOBJ)pFontPDev->pUFObj);
                }
            }
        }


    }

    return dwMem;
}

DWORD
DwDLGlyphOEMCallback(
    PDEV            *pPDev,
    PFONTMAP        pFM,
    HGLYPH          hGlyph,
    WORD            wDLGlyphId,
    WORD            *pwWidth)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling routine for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pFM - a pointer to FONTMAP

Return Value:


Note:


--*/
{
    PFN_OEMDownloadCharGlyph pfnOEMDownloadCharGlyph;
    PI_UNIFONTOBJ pUFObj;
    PFONTPDEV pFontPDev;
    DL_MAP   *pdm;
    DWORD     dwMem;
    INT       iWide;

    //
    // There values have to be non-NULL.
    //
    ASSERT(pPDev && pFM);

    dwMem     = 0;
    iWide     = 0;
    pFontPDev = pPDev->pFontPDev;
    pUFObj    = pFontPDev->pUFObj;
    pdm       =  ((PFONTMAP_TTOEM)pFM->pSubFM)->u.pvDLData;
    pfnOEMDownloadCharGlyph = NULL;

    //
    // There values have to be non-NULL.
    //
    ASSERT(pFontPDev && pUFObj && pdm);

    if ( pPDev->pOemHookInfo &&
        (pfnOEMDownloadCharGlyph = (PFN_OEMDownloadCharGlyph)
         pPDev->pOemHookInfo[EP_OEMDownloadCharGlyph].pfnHook) ||
        (pPDev->ePersonality == kPCLXL))
    {
        HRESULT  hr ;

        if (!(PFDV->flFlags & FDV_SET_FONTID))
        {
            pFM->ulDLIndex = pdm->wCurrFontId;
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_NFID);
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
            PFDV->flFlags  |= FDV_SET_FONTID;

        }

        BUpdateStandardVar(pPDev, pFM, wDLGlyphId, 0, STD_GL);

        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETCHARCODE));

        pUFObj->pFontMap = pFM;
        pUFObj->ulFontID = pFM->ulDLIndex;

        HANDLE_VECTORPROCS(pPDev, VMDownloadCharGlyph, ((PDEVOBJ)pPDev,
                                                        (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                        hGlyph,
                                                        (PDWORD)&iWide,
                                                        &dwMem))
        else
        {
            FIX_DEVOBJ(pPDev, EP_OEMDownloadCharGlyph);
            if (pPDev->pOemEntry)
            {
    
                if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                {
                        hr = HComDownloadCharGlyph((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                                    &pPDev->devobj,
                                                    (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                    hGlyph,
                                                    (PDWORD)&iWide, &dwMem);
                        if(SUCCEEDED(hr))
                            ;  //  cool !
                }
                else if (pfnOEMDownloadCharGlyph)
                {
                    dwMem = pfnOEMDownloadCharGlyph(&pPDev->devobj,
                                                    (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                    hGlyph,
                                                    (PDWORD)&iWide);
                }
            }
        }


        ((PFONTMAP_TTOEM)pFM->pSubFM)->dwDLSize += dwMem;
        *pwWidth = (WORD)iWide;
    }

    return dwMem;
}

BOOL
BCheckCondOEMCallback(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pso,
    IFIMETRICS  *pifi
    )
/*++

Routine Description:

    Implementation of CheckConditon for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pfo - a pointer to FONTOBJ
    pso - a pointer to STROBJ
    pifi - a pointer to IFIMETRICS

Return Value:


Note:


--*/
{
    PFONTPDEV     pFontPDev;
    PI_UNIFONTOBJ pUFObj;

    ASSERT(pPDev);

    pFontPDev = pPDev->pFontPDev;
    pUFObj = pFontPDev->pUFObj;

    if (pUFObj->dwFlags & UFOFLAG_TTFONT)
        return TRUE;
    else
        return FALSE;
}

BOOL
BSelectTrueTypeOutline(
    PDEV     *pPDev,
    PFONTMAP pFM,
    POINTL  *pptl)
{
    BOOL bRet = FALSE;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        if (BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_CFID ) &&
            BFontCmdCallback(pPDev, pFM, pptl, TRUE)                   )
            bRet = TRUE;
    }

    return bRet;
}

BOOL
BDeselectTrueTypeOutline(
    PDEV     *pPDev,
    PFONTMAP pFM)
{
    BOOL bRet = FALSE;

    DWORD dwFlags;
    PFONTPDEV       pFontPDev = pPDev->pFontPDev;
    PFONTMAP_TTOEM pFMOEM = (PFONTMAP_TTOEM) pFM->pSubFM;

    //
    // Deselect case. We need to reinitialize UFObj
    // 
    dwFlags = ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags;
    ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags = pFMOEM->dwFlags;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        if (BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_CFID ) &&
            BFontCmdCallback(pPDev, pFM, NULL, 0)                      )
            bRet = TRUE;
    }

    //
    // Restore the current dwFlags in UFOBJ
    //
    ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags = dwFlags;

    return bRet;
}


BOOL
BOEMFreePFMCallback(
    PFONTMAP pfm)
/*++

Routine Description:

    Implementation of PFM Free function for FONTMAP dispatch routine

Arguments:

    pFM - a pointer to FONTMAP

Return Value:


Note:


--*/

{
    ASSERT(pfm);

    if (pfm)
    {
        if (pfm->pIFIMet)
            MemFree(pfm->pIFIMet);

        MemFree(pfm);
        return TRUE;
    }
    else
        return FALSE;
}

PFONTMAP
PfmInitPFMOEMCallback(
    PDEV    *pPDev,
    FONTOBJ *pfo)
/*++

Routine Description:

    Implementation of PfmInit for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pfo - a pointer to FONTOBJ

Return Value:

    A pointer to FONTMAP

Note:


--*/
{
    PFONTPDEV       pFontPDev;
    PFONTMAP        pfm;
    DWORD           dwSize;

    ASSERT(pPDev && pfo);

    pFontPDev = pPDev->pFontPDev;
    dwSize    = sizeof(FONTMAP) + sizeof(FONTMAP_TTOEM);

    if (pfm = MemAlloc(dwSize))
    {
        PFONTMAP_TTOEM pFMOEM;

        ZeroMemory(pfm, dwSize);
        pfm->dwSignature = FONTMAP_ID;
        pfm->dwSize      = sizeof(FONTMAP);
        pfm->dwFontType  = FMTYPE_TTOEM;
        pfm->pSubFM      = (PVOID)(pfm+1);

        pfm->wFirstChar  = 0;
        pfm->wLastChar   = 0xffff;

        pfm->wXRes = (WORD)pPDev->ptGrxRes.x;
        pfm->wYRes = (WORD)pPDev->ptGrxRes.y;

        pfm->pIFIMet    =   pFontPDev->pIFI;
        pfm->ulDLIndex  =   (ULONG)-1;

        if (!(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
        {
            pfm->syAdj = ((IFIMETRICS*)pfm->pIFIMet)->fwdWinAscender;
        }

        if (pPDev->pOemHookInfo &&
                pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook ||
            (pPDev->ePersonality == kPCLXL)
        )
            pfm->pfnGlyphOut           = DwOutputGlyphCallback;
        else
            pfm->pfnGlyphOut           = DwTrueTypeBMPGlyphOut;

        if (pPDev->ePersonality == kPCLXL)
        {
            pfm->pfnSelectFont         = BSelectTrueTypeOutline;
            pfm->pfnDeSelectFont       = BDeselectTrueTypeOutline;
        }
        else
        if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
        {
            pfm->pfnSelectFont         = BSelectTrueTypeOutline;
            pfm->pfnDeSelectFont       = BDeselectTrueTypeOutline;
        }
        else
        if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
        {
            pfm->pfnSelectFont         = BSelectTrueTypeBMP;
            pfm->pfnDeSelectFont       = BDeselectTrueTypeBMP;
        }

        pfm->pfnDownloadFontHeader = DwDLHeaderOEMCallback;
        pfm->pfnDownloadGlyph      = DwDLGlyphOEMCallback;
        pfm->pfnCheckCondition     = BCheckCondOEMCallback;
        pfm->pfnFreePFM            = BOEMFreePFMCallback;

        pFMOEM = (PFONTMAP_TTOEM) pfm->pSubFM;
        pFMOEM->dwFlags = ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags;
        pFMOEM->flFontType = pfo->flFontType;
        if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
        {
            if (pfo->flFontType & FO_SIM_BOLD)
                pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_BOLD_SIM;

            if (pfo->flFontType & FO_SIM_ITALIC)
                pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_ITALIC_SIM;

            if (NULL != pFontPDev->pIFI &&
                '@' == *((PBYTE)pFontPDev->pIFI + pFontPDev->pIFI->dpwszFamilyName))
            {
                pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_VERTICAL;
            }
        }
    }
    else
    {
        ERR(("PfmInitPFMOEMCallback: MemAlloc failed.\n"));
    }

    return pfm;

}

//
// Misc functions
//


VOID
VUFObjFree(
    IN FONTPDEV* pFontPDev)
/*++

Routine Description:

    UFObj(UNIFONTOBJ) memory free function

Arguments:

    pFontPDev - a pointer to FONTPDEV.

Return Value:


Note:

--*/
{
    PI_UNIFONTOBJ pUFObj = pFontPDev->pUFObj;

    ASSERT(pFontPDev);

    pUFObj = pFontPDev->pUFObj;

    if (pUFObj && pUFObj->pGlyph)
        MemFree(pUFObj->pGlyph);

    pFontPDev->pUFObj = NULL;
}

WCHAR
WGHtoUnicode(
    DWORD     dwNumOfRuns,
    PGLYPHRUN pGlyphRun,
    HGLYPH    hg)
/*++

Routine Description:

    Character coversion function from HGLYPH to Unicode.

Arguments:

    dwNumOfRuns - number of run in pGlyphRun
    pGlyphRun - a pointer to glyph run
    hd - HGLYPH

Return Value:

    Unicode character

Note:

--*/
{
    DWORD  dwI;
    HGLYPH hCurrent = 1;
    WCHAR  wchChar = 0;

    ASSERT(pGlyphRun);

    for( dwI = 0;  dwI < dwNumOfRuns; dwI ++, pGlyphRun ++)
    {
        if (hCurrent <= hg && hg < hCurrent + pGlyphRun->wGlyphCount)
        {
            wchChar = (WCHAR)(pGlyphRun->wcLow + hg - hCurrent);
            break;
        }
        hCurrent += pGlyphRun->wGlyphCount;
    }

    return  wchChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmdevice.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontmap.h

Abstract:

    Unidrv FONTMAP and related infor header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05-19-97 -eigos-
        Created

    dd-mm-yy -author-
        description

--*/

#ifndef _FMDEVICE_
#define _FMDEVICE_

PFNGLYPHOUT  PfnDevGlyphOut;
PFNSELFONT   PfnDevSelFont;
PFNDESELFONT PfnDevDeSelFont;

#endif // !_FMDEVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmdebug.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:
    Routines For Font debugging support.This file should be the last in SOURCES.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

--*/
#if DBG

#ifndef PUBLIC_GDWDEBUGFONT
#define PUBLIC_GDWDEBUGFONT
#endif //PUBLIC_GDWDEBUGFONT

#include "font.h"

BYTE *gcstrflInfo[] = {"FM_INFO_TECH_TRUETYPE",
                       "FM_INFO_TECH_BITMAP",
                       "FM_INFO_TECH_STROKE",
                       "FM_INFO_TECH_OUTLINE_NOT_TRUETYPE",
                       "FM_INFO_ARB_XFORMS",
                       "FM_INFO_1BPP",
                       "FM_INFO_4BPP",
                       "FM_INFO_8BPP",
                       "FM_INFO_16BPP",
                       "FM_INFO_24BPP",
                       "FM_INFO_32BPP",
                       "FM_INFO_INTEGER_WIDTH",
                       "FM_INFO_CONSTANT_WIDTH",
                       "FM_INFO_NOT_CONTIGUOUS",
                       "FM_INFO_TECH_MM",
                       "FM_INFO_RETURNS_OUTLINES",
                       "FM_INFO_RETURNS_STROKES",
                       "FM_INFO_RETURNS_BITMAPS",
                       "FM_INFO_UNICODE_COMPLIANT",
                       "FM_INFO_RIGHT_HANDED",
                       "FM_INFO_INTEGRAL_SCALING",
                       "FM_INFO_90DEGREE_ROTATIONS",
                       "FM_INFO_OPTICALLY_FIXED_PITCH",
                       "FM_INFO_DO_NOT_ENUMERATE",
                       "FM_INFO_ISOTROPIC_SCALING_ONLY",
                       "FM_INFO_ANISOTROPIC_SCALING_ONLY",
                       "FM_INFO_MM_INSTANCE",
                       "FM_INFO_FAMILY_EQUIV",
                       "FM_INFO_DBCS_FIXED_PITCH",
                       "FM_INFO_NONNEGATIVE_AC",
                       "FM_INFO_IGNORE_TC_RA_ABLE",
                       "FM_INFO_TECH_TYPE1"};

VOID
VDbgDumpUCGlyphData(
    FONTMAP   *pFM
    )
/*++

Routine Description:
    Dumps the Font's Glyph Data.

Arguments:
    pFM             FONTMAP struct of the Font about for which information is
                    desired.

Return Value:
    None

Note:
    12-30-96: Created it -ganeshp-

--*/
{

    /*  Enable this code to print out your data array */

    HGLYPH      *phg;
    ULONG       cRuns;
    FD_GLYPHSET *pGLSet;       /* Base of returned data */
    PWSTR       pwszFaceName;
    IFIMETRICS  *pIFI;          /* For convenience */

    if ( gdwDebugFont & DBG_FD_GLYPHSET )
    {
        if (!pFM || !(pFM->pIFIMet) || !(((PFONTMAP_DEV)pFM->pSubFM)->pUCTree))
        {
            WARNING(("One of pFM/pFM->pIFIMet/pFM->pSubFM->pUCTree is NULL"));
            return;
        }

        pIFI = pFM->pIFIMet;
        pwszFaceName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName  );
        pGLSet = ((PFONTMAP_DEV)pFM->pSubFM)->pUCTree;

        DbgPrint( "UniFont!VDumpUCGlyphData: pwszFaceName = %ws: FD_GLYPHSET:\n", pwszFaceName );
        DbgPrint( " cjThis = %ld, flAccel = 0x%lx, Supp = %ld, cRuns = %ld\n",
            pGLSet->cjThis, pGLSet->flAccel, pGLSet->cGlyphsSupported,
            pGLSet->cRuns );

        /*  Loop through the WCRUN structures  */
        for( cRuns = 0; cRuns < pGLSet->cRuns; cRuns++ )
        {
            int   i;

            DbgPrint( "+Run %d:\n", cRuns );
            DbgPrint( " wcLow = %d, cGlyphs = %d, phg = 0x%lx\n",
                    pGLSet->awcrun[ cRuns ].wcLow, pGLSet->awcrun[ cRuns ].cGlyphs,
                    pGLSet->awcrun[ cRuns ].phg );

            phg = pGLSet->awcrun[ cRuns ].phg;

            /*    List the glyph handles for this run */

            for( i = 0; i < 256 && i < pGLSet->awcrun[ cRuns ].cGlyphs; i++ )
            {
                DbgPrint( "0x%4lx, ",  *phg++ );
                if( ((i + 1) % 8) == 0 )
                    DbgPrint( "\n" );
            }
            DbgPrint( "\n" );
        }

    }


}

VOID
VDbgDumpGTT(
     PUNI_GLYPHSETDATA pGly)
{
    if ( gdwDebugFont & DBG_UNI_GLYPHSETDATA )
    {
        PUNI_CODEPAGEINFO pCP;
        PGLYPHRUN         pGlyphRun;
        PMAPTABLE         pMapTable;
        TRANSDATA        *pTrans;
        DWORD             dwI;
        WORD              wSize, wJ;
        PBYTE             pCommand;

        pCP       = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);
        pGlyphRun = (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);
        pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
        pTrans    = pMapTable->Trans;

        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("G L Y P H S E T   D A T A   F I L E\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("GLYPHSETDATA\n");
        DbgPrint("GLYPHSETDATA.dwSize              : %d\n", pGly->dwSize);
        DbgPrint("             dwVersion           : %d.%d\n", (pGly->dwVersion) >>16,
                                                     0x0000ffff&pGly->dwVersion);
        DbgPrint("             dwFlags             : %d\n", pGly->dwFlags);
        DbgPrint("             lPredefinedID       : %d\n", pGly->lPredefinedID);
        DbgPrint("             dwGlyphCount        : %d\n", pGly->dwGlyphCount);
        DbgPrint("             dwRunCount          : %d\n", pGly->dwRunCount);
        DbgPrint("             loRunOffset         : 0x%x\n", pGly->loRunOffset);
        DbgPrint("             dwCodePageCount     : %d\n", pGly->dwCodePageCount);
        DbgPrint("             loCodePageOffset    : 0x%x\n", pGly->loCodePageOffset);
        DbgPrint("             loMapTableOffset    : 0x%x\n", pGly->loMapTableOffset);

        DbgPrint("\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("CODEPAGEINFO\n");
        for (dwI = 0; dwI < pGly->dwCodePageCount; dwI ++)
        {
            DbgPrint ("UNI_CODEPAGEINFO[%d].dwCodePage                = %d\n",
                dwI, pCP->dwCodePage);
            DbgPrint ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount   = %d\n",
                dwI, pCP->SelectSymbolSet.dwCount);
            if (pCP->SelectSymbolSet.dwCount &&
                pCP->SelectSymbolSet.loOffset  )
                DbgPrint ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command   = %s\n", dwI, (PBYTE)pCP+pCP->SelectSymbolSet.loOffset);
            DbgPrint ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount = %d\n",
                dwI, pCP->UnSelectSymbolSet.dwCount);
            if (pCP->UnSelectSymbolSet.dwCount &&
                pCP->UnSelectSymbolSet.loOffset  )
                DbgPrint ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command   = %s\n", dwI, (PBYTE)pCP+pCP->UnSelectSymbolSet.loOffset);
            pCP++;
        }

        pGlyphRun =
                (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);

        DbgPrint("\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("GLYPHRUN\n");
        for (dwI = 0; dwI < pGly->dwRunCount; dwI ++)
        {
             DbgPrint("GLYPHRUN[%2d].wcLow       = 0x%-4x ",
                 dwI, pGlyphRun->wcLow);
             DbgPrint("GLYPHRUN[%2d].wGlyphCount = %d\n",
                 dwI, pGlyphRun->wGlyphCount);
             pGlyphRun++;
        }

        pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
        pTrans    = pMapTable->Trans;

        DbgPrint("\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("MAPTABLE\n");
        DbgPrint("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
        DbgPrint("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

        #if 0
        for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
        {
            DbgPrint("MAPTABLE.pTrans[%5d].ubCodePageID = %d ",
                dwI, pTrans[dwI].ubCodePageID);
            DbgPrint("MAPTABLE.pTrans[%5d].ubType       = %d ",
                dwI, pTrans[dwI].ubType);
            switch(pTrans[dwI].ubType)
            {
            case MTYPE_DIRECT:
                DbgPrint("MAPTABLE.pTrans[%5d].ubCode       = 0x%02x\n",
                    dwI, pTrans[dwI].uCode.ubCode);
                break;
            case MTYPE_PAIRED:
                DbgPrint("MAPTABLE.pTrans[%5d].ubPairs[0]   = 0x%02x ",
                    dwI, pTrans[dwI].uCode.ubPairs[0]);
                DbgPrint("MAPTABLE.pTrans[%5d].ubPairs[1]   = 0x%02x ",
                    dwI, pTrans[dwI].uCode.ubPairs[1]);
                break;
            case MTYPE_COMPOSE:
                    DbgPrint("MAPTABLE.pTrans[%5d].sCode        = 0x%02x ",
                        dwI, pTrans[dwI].uCode.sCode);
                    pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                    wSize = *(WORD*)pCommand;
                    pCommand += 2;
                    DbgPrint("Size                                = 0x%d ", wSize);
                    DbgPrint("Command                             = 0x");
                    for (wJ = 0; wJ < wSize; wJ ++)
                    {
                        DbgPrint("%02x",pCommand[wJ]);
                    }
                    DbgPrint("\n");
                break;
            }
        }
        #endif
    }
}


VOID
VDbgDumpFONTMAP(
    FONTMAP *pFM)
{
}

VOID
VDbgDumpIFIMETRICS(
    IFIMETRICS *pIFI)
{
    PWSTR   pwszFamilyName;
    PWSTR   pwszStyleName;
    PWSTR   pwszFaceName;
    PWSTR   pwszUniqueName;
    DWORD   dwI;

    if ( gdwDebugFont & DBG_IFIMETRICS )
    {
        pwszFamilyName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFamilyName);
        pwszStyleName  = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszStyleName) ;
        pwszFaceName   = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName)  ;
        pwszUniqueName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszUniqueName);

        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("IFIMETRICS\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("IFIMETIRCS.cjThis               = %-#8lx\n" , pIFI->cjThis );
        DbgPrint("IFIMETIRCS.cjIfiExtra           = %-#8lx\n" , pIFI->cjIfiExtra);
        DbgPrint("IFIMETIRCS.pwszFamilyName       = \"%ws\"\n", pwszFamilyName );

        if( pIFI->flInfo & FM_INFO_FAMILY_EQUIV )
        {
            while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            {
                DbgPrint("                               \"%ws\"\n", pwszFamilyName );
            }
        }
        DbgPrint("IFIMETRICS.pwszStyleName        = \"%ws\"\n", pwszStyleName);
        DbgPrint("IFIMETRICS.pwszFaceName         = \"%ws\"\n", pwszFaceName);
        DbgPrint("IFIMETRICS.pwszUniqueName       = \"%ws\"\n", pwszUniqueName);
        DbgPrint("IFIMETRICS.dpFontSim            = %-#8lx\n" , pIFI->dpFontSim);
        DbgPrint("IFIMETRICS.lEmbedId             = %d\n", pIFI->lEmbedId);
        DbgPrint("IFIMETRICS.lItalicAngle         = %d\n", pIFI->lItalicAngle);
        DbgPrint("IFIMETRICS.lCharBias            = %d\n", pIFI->lCharBias);
        DbgPrint("IFIMETRICS.dpCharSets           = %d\n", pIFI->dpCharSets);
        DbgPrint("IFIMETRICS.jWinCharSet          = %04x\n", pIFI->jWinCharSet);
        DbgPrint("IFIMETRICS.jWinPitchAndFamily   = %04x\n", pIFI->jWinPitchAndFamily);
        DbgPrint("IFIMETRICS.usWinWeight          = %d\n", pIFI->usWinWeight);
        DbgPrint("IFIMETRICS.flInfo               = %-#8lx\n", pIFI->flInfo);

        for( dwI = 0; dwI < 32; dwI ++ )
        {
            if (pIFI->flInfo & (0x00000001 << dwI))
            {
                DbgPrint("                                  %s\n", gcstrflInfo[dwI]);
            }
        }
        DbgPrint("IFIMETRICS.fsSelection          = %-#6lx\n", pIFI->fsSelection);
        DbgPrint("IFIMETRICS.fsType               = %-#6lx\n", pIFI->fsType);
        DbgPrint("IFIMETRICS.fwdUnitsPerEm        = %d\n", pIFI->fwdUnitsPerEm);
        DbgPrint("IFIMETRICS.fwdLowestPPEm        = %d\n", pIFI->fwdLowestPPEm);
        DbgPrint("IFIMETRICS.fwdWinAscender       = %d\n", pIFI->fwdWinAscender);
        DbgPrint("IFIMETRICS.fwdWinDescender      = %d\n", pIFI->fwdWinDescender);
        DbgPrint("IFIMETRICS.fwdMacAscender       = %d\n", pIFI->fwdMacAscender);
        DbgPrint("IFIMETRICS.fwdMacDescender      = %d\n", pIFI->fwdMacDescender);
        DbgPrint("IFIMETRICS.fwdMacLineGap        = %d\n", pIFI->fwdMacLineGap);
        DbgPrint("IFIMETRICS.fwdTypoAscender      = %d\n", pIFI->fwdTypoAscender);
        DbgPrint("IFIMETRICS.fwdTypoDescender     = %d\n", pIFI->fwdTypoDescender);
        DbgPrint("IFIMETRICS.fwdTypoLineGap       = %d\n", pIFI->fwdTypoLineGap);
        DbgPrint("IFIMETRICS.fwdAveCharWidth      = %d\n", pIFI->fwdAveCharWidth);
        DbgPrint("IFIMETRICS.fwdMaxCharInc        = %d\n", pIFI->fwdMaxCharInc);
        DbgPrint("IFIMETRICS.fwdCapHeight         = %d\n", pIFI->fwdCapHeight);
        DbgPrint("IFIMETRICS.fwdXHeight           = %d\n", pIFI->fwdXHeight);
        DbgPrint("IFIMETRICS.fwdSubscriptXSize    = %d\n", pIFI->fwdSubscriptXSize);
        DbgPrint("IFIMETRICS.fwdSubscriptYSize    = %d\n", pIFI->fwdSubscriptYSize);
        DbgPrint("IFIMETRICS.fwdSubscriptXOffset  = %d\n", pIFI->fwdSubscriptXOffset);
        DbgPrint("IFIMETRICS.fwdSubscriptYOffset  = %d\n", pIFI->fwdSubscriptYOffset);
        DbgPrint("IFIMETRICS.fwdSuperscriptXSize  = %d\n", pIFI->fwdSuperscriptXSize);
        DbgPrint("IFIMETRICS.fwdSuperscriptYSize  = %d\n", pIFI->fwdSuperscriptYSize);
        DbgPrint("IFIMETRICS.fwdSuperscriptXOffset= %d\n", pIFI->fwdSuperscriptXOffset);
        DbgPrint("IFIMETRICS.fwdSuperscriptYOffset= %d\n", pIFI->fwdSuperscriptYOffset);
        DbgPrint("IFIMETRICS.fwdUnderscoreSize    = %d\n", pIFI->fwdUnderscoreSize);
        DbgPrint("IFIMETRICS.fwdUnderscorePosition= %d\n", pIFI->fwdUnderscorePosition);
        DbgPrint("IFIMETRICS.fwdStrikeoutSize     = %d\n", pIFI->fwdStrikeoutSize);
        DbgPrint("IFIMETRICS.fwdStrikeoutPosition = %d\n", pIFI->fwdStrikeoutPosition);
        DbgPrint("IFIMETRICS.chFirstChar          = %-#4x\n", (int) (BYTE) pIFI->chFirstChar);
        DbgPrint("IFIMETRICS.chLastChar           = %-#4x\n", (int) (BYTE) pIFI->chLastChar);
        DbgPrint("IFIMETRICS.chDefaultChar        = %-#4x\n", (int) (BYTE) pIFI->chDefaultChar);
        DbgPrint("IFIMETRICS.chBreakChar          = %-#4x\n", (int) (BYTE) pIFI->chBreakChar);
        DbgPrint("IFIMETRICS.wcFirsChar           = %-#6x\n", pIFI->wcFirstChar);
        DbgPrint("IFIMETRICS.wcLastChar           = %-#6x\n", pIFI->wcLastChar);
        DbgPrint("IFIMETRICS.wcDefaultChar        = %-#6x\n", pIFI->wcDefaultChar);
        DbgPrint("IFIMETRICS.wcBreakChar          = %-#6x\n", pIFI->wcBreakChar);
        DbgPrint("IFIMETRICS.ptlBaseline          = {%d,%d}\n", pIFI->ptlBaseline.x, pIFI->ptlBaseline.y);
        DbgPrint("IFIMETRICS.ptlAspect            = {%d,%d}\n", pIFI->ptlAspect.x,pIFI->ptlAspect.y );
        DbgPrint("IFIMETRICS.ptlCaret             = {%d,%d}\n", pIFI->ptlCaret.x,pIFI->ptlCaret.y );
        DbgPrint("IFIMETRICS.rclFontBox           = {%d,%d,%d,%d}\n",
                                                  pIFI->rclFontBox.left,
                                                  pIFI->rclFontBox.top,
                                                  pIFI->rclFontBox.right,
                                                  pIFI->rclFontBox.bottom);
        DbgPrint("IFIMETRICS.achVendId            = \"%c%c%c%c\"\n",
                                                   pIFI->achVendId[0] ,
                                                   pIFI->achVendId[1],
                                                   pIFI->achVendId[2],
                                                   pIFI->achVendId[3] );
        DbgPrint("IFIMETRICS.cKerningPairs        = %d\n", pIFI->cKerningPairs);
        DbgPrint("IFIMETRICS.ulPanoseCulture      = %-#8lx\n", pIFI->ulPanoseCulture);
        DbgPrint("\n");
    }

}


VOID
VPrintString(
    STROBJ     *pstro
    )
{
    if ( gdwDebugFont & DBG_TEXTSTRING )
    {
        #define MAXTXTBUFSIZE     81

        WCHAR       awchBuf[MAXTXTBUFSIZE];
        ULONG       cGlyphsPrinted;

        cGlyphsPrinted = min(pstro->cGlyphs,MAXTXTBUFSIZE-1);
        wcsncpy( awchBuf, pstro->pwszOrg,cGlyphsPrinted);
        awchBuf[cGlyphsPrinted] = NUL;
        DbgPrint("\nTextOut cGlyphs = %d. First %d chars are:\n",
                pstro->cGlyphs,cGlyphsPrinted);
        DbgPrint("%ws\n",awchBuf);

        #undef MAXTXTBUFSIZE
    }
}
#undef PUBLIC_GDWDEBUGFONT //Only in this file.
#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmmacro.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

     fmmacro.h

Abstract:

    Font module main macro header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    11/18/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _FMMACRO_H
#define _FMMACRO_H

/* Debugging macroes specific to Font Module */

#if DBG    // Check Build

/* Error handling macroes */
#define ERREXIT(ErrString)       { ERR((ErrString));goto ErrorExit;}

#else  // Free Build

/* Error handling macroes */
#define ERREXIT(ErrString)     { goto ErrorExit;}

#endif // if DBG


/* Macroes */
#define ARF_IS_NULLSTRING(String)   ((String).dwCount == 0)
#define BUFFSIZE                    1024
#define PFDV                       ((PFONTPDEV)(pPDev->pFontPDev))
#define POINTEQUAL(pt1,pt2)         ((pt1.x == pt2.x) && (pt1.y == pt2.y))

#define VALID_FONTPDEV(pfontpdev) \
        ( (pfontpdev) && ((pfontpdev)->dwSignature == FONTPDEV_ID) )

#define MEMFREEANDRESET(ptr)  { if (ptr) MemFree( (LPSTR)ptr ); ptr = NULL; }
#define  SIZEOFDEVPFM()        (sizeof( FONTMAP ) + sizeof(FONTMAP_DEV))

#if 0
#define NO_ROTATION(xform)      (                                        \
                                  (FLOATOBJ_EqualLong(&(xform.eM12), 0) && \
                                   FLOATOBJ_EqualLong(&(xform.eM21), 0) ) || \
                                  (FLOATOBJ_EqualLong(&(xform.eM11), 0) && \
                                   FLOATOBJ_EqualLong(&(xform.eM22), 0) )\
                                )
#else
#define NO_ROTATION(xform)   ( \
        FLOATOBJ_EqualLong(&(xform.eM12), 0) && \
        FLOATOBJ_EqualLong(&(xform.eM21), 0)  && \
        FLOATOBJ_GreaterThanLong(&(xform.eM11),0) && \
        FLOATOBJ_GreaterThanLong(&(xform.eM22),0) \
                                )
#endif

#define GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph) \
                        (                              \
                        (pdm->wFlags & DLM_BOUNDED) && \
                        (pdm->wBaseDLFontid != pdm->wCurrFontId) && \
                        (pdlGlyph->wDLFontId != (WORD)(pFontPDev->ctl.iSoftFont)) \
                        )

#define     SET_CURSOR_FOR_EACH_GLYPH(flAccel)    \
                        (                       \
                        (!(flAccel & SO_FLAG_DEFAULT_PLACEMENT)) ||  \
                        ( flAccel & SO_VERTICAL )                ||  \
                        ( flAccel & SO_REVERSED )                    \
                        )

#define     SET_CURSOR_POS(pPDev,pgp,flAccel) \
                        if (!(flAccel & SO_FLAG_DEFAULT_PLACEMENT)) \
                           XMoveTo(pPDev, pgp->ptl.x, MV_GRAPHICS|MV_FINE)

//
// Cursor Move type
//

#define     MOVE_RELATIVE       0x0001
#define     MOVE_ABSOLUTE       0x0002
#define     MOVE_UPDATE         0x0004


/* Defines for Floating point numbers */

#if defined(_X86_) && !defined(USERMODE_DRIVER)

#define FLOATL_0_0      0               // 0.0 in IEEE floating point format
#define FLOATL_00_001M  0xAE000000      // -00.000976625f
#define FLOATL_00_001   0x2E000000      // 00.000976625f
#define FLOATL_00_005   0x3ba3d70a      // 00.005f
#define FLOATL_00_005M  0xbba3d70a      // -00.005f
#define FLOATL_00_50    0x3F000000      // 00.50f in IEEE floating point format
#define FLOATL_00_90    0x3f666666      // 00.90f in IEEE floating point format
#define FLOATL_1_0      0x3F800000      // 1.0f in IEEE floating point format
#define FLOATL_1_0M     0xBF800000      // -1.0f in IEEE floating point format
#define FLOATL_72_00    0x42900000      // 72.00f in IEEE floating point format
#define FLOATL_72_31    0x42909EB8      // 72.31f in IEEE floating point format

#define FLOATL_PI      0x40490fdb      // 3.14159265358979f

#else //RISC

#define FLOATL_0_0      0.0f
#define FLOATL_00_001M  -0.001f
#define FLOATL_00_001   0.001f
#define FLOATL_00_005M  -0.005f
#define FLOATL_00_005   0.005f
#define FLOATL_00_50    0.5f
#define FLOATL_00_90    0.9f
#define FLOATL_1_0      1.0f
#define FLOATL_1_0M     -1.0f
#define FLOATL_72_00    72.00f
#define FLOATL_72_31    72.31f

#define FLOATL_PI      3.14159265358979f
#endif _X86_

#define SYMBOL_START 0xf020
#define SYMBOL_END   0xf0ff
#define NUM_OF_SYMBOL SYMBOL_END - SYMBOL_START + 1

#define EURO_CUR_SYMBOL 0x20ac

#define IS_SYMBOL_CHARSET(pfm) (pfm->pIFIMet->jWinCharSet == 0x02)

BOOL
NONSQUARE_FONT(
    PXFORML pxform);

#endif  // !_FMMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmfnprot.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmfnprot.h

Abstract:

    Font module main Function prototype header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    11/18/96 -ganeshp-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FMFNPROT_H
#define _FMFNPROT_H

//
// Interface functions
//

//
// Defined in fmtxtout.c
//

BOOL
FMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

BOOL
BPlayWhiteText(
    PDEV  *pPDev
    );

//
// GlyphOut function Prototype
//
typedef BOOL
(*pfnBOutputGlyph)(
    PDEV      *pPDev,
    HGLYPH    hg,
    FONTMAP   *pFM,
    INT       iXIn
    );


//
// Defined in fontddi.c
//
BOOL
FMResetPDEV(
    PDEV  *pPDevOld,
    PDEV  *pPDevNew
    );


VOID
FMDisablePDEV(
    PDEV *pPDev
    );

VOID
FMDisableSurface(
    PDEV *pPDev
    );

BOOL
FMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    );

BOOL
FMStartPage(
    SURFOBJ *pso
    );

BOOL
FMSendPage(
    SURFOBJ *pso
    );

BOOL
FMEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    );

BOOL
FMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL
FMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL
FMEnableSurface(
    PDEV *pPDev
    );


//
// Defined in intrface.c
//

BOOL
BInitDeviceFontsFromGPD(
    PDEV    *pPDev
    );

BOOL
BInitFontPDev(
    PDEV    *pPDev
    );

INT
IGetMaxFonts(
    PDEV    *pPDev
    );

BOOL
BBuildFontCartTable(
    PDEV    *pPDev
    );

BOOL
BRegReadFontCarts(
PDEV        *pPDev
    ) ;

BOOL
BBuildFontMapTable(
    PDEV     *pPDev
    ) ;

VOID
VSetFontID(
    DWORD   *pdwOut,
    PFONTLIST pFontList
    );


VOID
VLogFont(
    POINT    *pptGrxRes,
    LOGFONT  *pLF,
    FONTMAP  *pFM
);

BOOL
BInitTextFlags(
    PDEV    *pPDev
    );

BOOL
BInitGDIInfo(
    GDIINFO  *pGDIInfo,
    PDEV     *pPDev
    );

//
// Defined in fminit.c
//

INT
IInitDeviceFonts(
    PDEV    *pPDev
    );

BOOL
BFillinDeviceFM(
    PDEV       *pPDev,
    FONTMAP    *pfm,
    int         iIndex
    );


BOOL
BGetOldFontInfo(
    FONTMAP   *pfm,
    BYTE      *pRes
    );

BOOL
BFMSetupXF(
    FONTMAP   *pfm,
    PDEV      *pPDev,
    INT        iIndex
    );

BOOL
BIFIScale(
    FONTMAP   *pfm,
    INT       xdpi,
    INT       ydpi
    );

VOID
VFillinGlyphData(
    PDEV      *pPDev,
    FONTMAP   *pfm
    );

BOOL
BGetNewFontInfo(
    FONTMAP   *pfm,
    BYTE      *pRes
    );

PUNI_GLYPHSETDATA
PNTGTT1To1(
    IN DWORD dwCodepage,
    IN BOOL  bSymbolCharSet,
    IN INT   iFirst,
    IN INT   iLast
    );

NT_RLE  *
PNTRLE1To1(
    IN BOOL  bSymbolCharSet,
    int      iFirst,
    int      iLast
    );

//
// Defined in  fileio.c
//
HANDLE
DrvOpenFile
(
    PWSTR pwstrFileName,
    PDEV   *pPDEV
);

BOOL
DrvReadFile
(
    HANDLE   hFile,
    LPVOID   lpBuffer,
    DWORD    nNumBytesToRead,
    LPDWORD  lpNumBytesRead,
    PDEV     *pPDev
);

DWORD
DrvSetFilePointer
(
    HANDLE   hFile,
    LONG     iDistanceToMove,
    DWORD    dwMoveMethod,
    PDEV     *pPDev
);


BOOL
DrvCloseFile
(
    HANDLE   hFile,
    PDEV    *pPDEV
);

//
// Defined in fontread.c
//

INT
IFIOpenRead(
    FI_MEM  *pFIMem,
    PWSTR    pwstrName,
    PDEV    *pPDev
    );

BOOL
BFINextRead(
    FI_MEM   *pFIMem
    ) ;

int
IFIRewind(
    FI_MEM   *pFIMem
    );

BOOL
BFICloseRead(
    FI_MEM  *pFIMem,
    PDEV    *pPDev
    );

//
// Defined in xtrafont.c
//

int
IXtraFonts(
PDEV    *pPDev
    );

BOOL
BGetXFont(
    PDEV  *pPDev,
    int    iIndex
    );

void
VXFRewind(
    PDEV   *pPDev
    );


//
// Defined in FontFree.c
//

VOID
VFontFreeMem(
    PDEV   *pPDev
    );

//
// Defined in posnsort.c
//
BOOL
BCreatePS(
    PDEV  *pPDev
    );

VOID
VFreePS(
    PDEV  *pPDev
    );

BOOL
BAddPS(
    PSHEAD  *pPSH,
    PSGLYPH *pPSGIn,
    INT      iyVal,
    INT      iyMax
    );

INT
ISelYValPS(
    PSHEAD  *pPSH,
    int     iyVal
    );

PSGLYPH  *
PSGGetNextPSG(
    PSHEAD  *pPSH
    );

//
// Defined in download.c
//

BOOL
BSendDLFont(
    PDEV     *pPDev,
    FONTMAP  *pFM
    );

INT
IDownloadFont(
    TO_DATA  *ptod,
    STROBJ   *pstro,
    INT      *piRot
    );

INT
IHG2Index(
    TO_DATA   *pTOD
    );

DWORD
DwGetTTGlyphWidth(
    FONTPDEV *pFontPDev,
    FONTOBJ  *pfo,
    HGLYPH    hGlyph);

//
// Defined in dloadpcl.c
//
DWORD
DwDLPCLHeader(
    PDEV        *pPDev,
    IFIMETRICS  *pifi,
    int         id
    );

INT
IDLGlyph(
    PDEV        *pPDev,
    int         iIndex,
    GLYPHDATA   *pgd,
    DWORD       *pdwMem
    );

//
// Defined in qeryfont.c
//
PIFIMETRICS
FMQueryFont(
    PDEV    *pPDev,
    ULONG_PTR   iFile,
    ULONG   iFace,
    ULONG_PTR *pid
    );

ULONG
FMGetGlyphMode(
    PDEV    *pPDev,
    FONTOBJ *pfo
    );

LONG
FMQueryFontData(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA   *pgd,
    PVOID       pv,
    ULONG       cjSize
    );


//
// Defined in qfontdat.c
//
PVOID
FMQueryFontTree(
    PDEV    *pPDev,
    ULONG_PTR iFile,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    );

VOID  *
PVGetUCGlyphSetData(
    PDEV   *pPDev,
    UINT    iFace
    );

VOID  *
PVGetUCRLE(
    PDEV   *pPDev,
    FONTMAP   *pFM
    );

VOID  *
PVGetUCFD_GLYPHSET(
    PDEV   *pPDev,
    FONTMAP   *pFM
    );

VOID  *
PVGetUCKernPairData(
    PDEV   *pPDev,
    UINT    iFace
    );

VOID  *
PVUCKernPair(
    PDEV   *pPDev,
    FONTMAP   *pFM
    );

//
// Defined in fntmanag.c
//
ULONG
FMFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    );

//
// Defined in qadvwdth.c
//
BOOL
FMQueryAdvanceWidths(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH *phg,
    PVOID  *pvWidths,
    ULONG   cGlyphs
    );

//
// Defined in fonts.c
//
FONTMAP *
PfmGetIt(
    PDEV *pPDev,
    INT   iIndex);

FONTMAP *
PfmGetDevicePFM(
    PDEV *pPDev,
    INT   iIndex);

FONTMAP *
PfmGetDevicePFM(
    PDEV   *pPDev,
    INT     iIndex
    );

BOOL
BNewFont(
    PDEV    *pPDev,
    INT      iNewFont,
    PFONTMAP pfm,
    DWORD    dwFontAttrib
    );

BOOL
BGetPSize(
    FONTPDEV    *pFontPDev,
    POINTL      *pptl,
    FWORD        fwdUnitsPerEm,
    FWORD        fwdAveCharWidth
    );


BOOL
BSelectFont(
    PDEV     *pPDev,
    FONTMAP  *pFM,
    POINTL   *pptl
    );

BOOL BSelScalableFont(
    PDEV    *pPDev,
    POINTL  *pptl,
    FONTMAP *pFM
    );

INT
IFont100toStr(
    BYTE   *pjOut,
    int     iVal
    );

INT
ISetScale(
    FONTCTL     *pctl,
    XFORMOBJ    *pxo,
    BOOL        bIntellifont,
    BOOL        bAnyRotation
);

VOID
VSetRotation(
    FONTPDEV    *pFontPDev,
    int        iRot
    );

INT
IGetGlyphWidth(
    PDEV    *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    );

LONG
LMulFloatLong(
    PFLOATOBJ pfo,
    LONG l);

INT
IGetUFMGlyphWidth(
    PDEV     *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    );

INT
IGetUFMGlyphWidthJr(
    POINT    *pptGrxRes,
    FONTMAP  *pFM,
    HGLYPH     hg
    );

VOID
VSetCursor(
    IN  PDEV   *pPDev,
    IN  INT     iX,
    IN  INT     iY,
    IN  WORD    wMoveType,
    OUT POINTL *pptlRem
    );

//
// ttdload.c  !!!TODO
//

BOOL BGetTTPointSize(
    PDEV    *pPDev,
    POINTL  *pptl,
    FONTMAP *pfm
    );

BOOL BTTSelScalableFont(
    PDEV    *pPDev,
    POINTL  *pptl,
    FONTMAP *pfm
    );

BOOL
BSetFontAttrib(
    PDEV  *pPDev,
    DWORD  dwPrevAttrib,
    DWORD  dwAttrib,
    BOOL   bReset);

BOOL
BGetStockGlyphset(
    IN  PDEV    *pPDev,
    OUT VOID  **ppvFDGlyphset,
    IN  SHORT   sResID);


HGLYPH
HDefaultGH(
    PFONTMAP pfm);

BOOL
BUpdateStandardVar(
    PDEV    *pPDev,
    PFONTMAP pFontMap,
    INT      iGlyphIndex,
    DWORD    dwFontAtt,
    DWORD    dwFlags);

#define STD_ALL         0x00000FFF
#define STD_STD         0x0000007F
#define STD_TT          0x00000380
#define STD_GL          0x00000001
#define STD_FH          0x00000002
#define STD_FW          0x00000004
#define STD_FB          0x00000008
#define STD_FI          0x00000010
#define STD_FU          0x00000020
#define STD_FS          0x00000040
#define STD_NFID        0x00000080
#define STD_CFID        0x00000100
#define STD_PRND        0x00000200

//
// oldfonts.c
//

BOOL
BRLEOutputGlyph(
    TO_DATA *pTod
    );

BOOL
BRLESelectFont(
    PDEV     *pPDev,
    PFONTMAP  pFM,
    POINTL   *pptl);

BOOL
BRLEDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM);


INT
IGetIFIGlyphWidth(
    PDEV    *pPDev,
    FONTMAP *pFM,
    HGLYPH   hg);

BOOL
BSelectNonScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

BOOL
BSelectPCLScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

BOOL
BSelectCapslScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

BOOL
BSelectPPDSScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

//
// newfonts.c
//
BOOL
BGTTOutputGlyph(
    TO_DATA *pTod);

BOOL
BGTTSelectFont(
    PDEV     *pPDev,
    PFONTMAP  pFM,
    POINTL   *pptl);

BOOL
BGTTDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM);

//
// fmcallbk.c
//
DWORD
DwOutputGlyphCallback(
    TO_DATA *pTod);

BOOL
BSelectFontCallback(
    PDEV     *pdev,
    PFONTMAP  pFM,
    POINTL   *pptl);

BOOL
BDeselectFontCallback(
    PDEV     *pdev,
    PFONTMAP pFM);

PFONTMAP
PfmInitPFMOEMCallback(
    PDEV    *pPDev,
    FONTOBJ *pfo);

//
// Inerface functions for FontMap initialization.
//

//
// Defined in bmpdload.c
//
FONTMAP *
InitPFMTTBitmap(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    );

//
// Defined in truetype.c
//
FONTMAP *
InitPFMTTOutline(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    );

BOOL
bTTSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
        IN POINTL *pptl
        );

BOOL
bTTDeSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
        );

DWORD
dwTTDownloadFontHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    );

DWORD
dwTTDownloadGlyph(
    IN PDEV     *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH   hGlyph,
    WORD        wDLGlyphId,
    WORD        *pwWidth
    );

DWORD
dwTTGlyphOut(
    TO_DATA *pTod
    );

BOOL
bTTCheckCondition(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pstro,
    IFIMETRICS  *pifi
    );

BOOL
bTTFreeMem(
    IN OUT PFONTMAP pFM
    );

//
// dlutils.c
//

PDLGLYPH
PDLGHashGlyph (
    DL_MAP     *pDL,
    HGLYPH      hTTGlyph
    );
VOID
VFreeDLMAP (
    DL_MAP   *pdm
    );

VOID
VFreeDL(
    PDEV  *pPDev
    );

DL_MAP *
PGetDLMap (
    PFONTPDEV       pFontPDev,
    FONTOBJ         *pfo
    );

BOOL
BInitDLMap (
    PDEV            *pPDev,
    FONTOBJ         *pfo,
    DL_MAP          *pdm
    );

INT
IGetDL_ID(
    PDEV * );

DL_MAP *
PGetDLMapFromIdx (
    PFONTPDEV   pFontPDev,
    INT         iFontIndex
    ) ;

BOOL
BPrintADLGlyph(
    PDEV        *pPDev,
    TO_DATA     *pTod,
    PDLGLYPH    pdlGlyph
    );

//
// TrueTypeBMP module interface prototype. bmpdload.c
//

BOOL
BFreeTrueTypeBMPPFM(
    PFONTMAP pfm
    );

BOOL
BCheckCondTrueTypeBMP(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pso,
    IFIMETRICS  *pifi
    );

BOOL
BSelectTrueTypeBMP(
    PDEV        *pPDev,
    PFONTMAP    pFM,
    POINTL*     pptl
    );

BOOL
BDeselectTrueTypeBMP(
    PDEV            *pPDev,
    FONTMAP         *pfm
    );

DWORD
DwTrueTypeBMPGlyphOut(
    TO_DATA *pTod
    );

DWORD
DwDLTrueTypeBMPHeader(
    PDEV     *pPDev,
    PFONTMAP pFM
    );

DWORD
DwDLTrueTypeBMPGlyph(
    PDEV            *pPDev,
    PFONTMAP        pFM,
    HGLYPH          hGlyph,
    WORD            wDLGlyphId,
    WORD            *pwWidth
    );
#endif  // !_FMFNPROT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fminit.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fminit.c

Abstract:

    Font Module: device font intialization modules.

Environment:

    Windows NT Unidrv driver

Revision History:

    11/28/96 -ganeshp-
        Created

--*/

#include "font.h"

//
// Forward declarations
//

INT
IFontID2Index( FONTPDEV   *pFontPDev,
    int        iID
    );

VOID
VLoadDeviceFontsResDLLs(
    PDEV        *pPDev
    );

DWORD
CopyMemoryRLE(
    PVOID pvData,
    PBYTE pubSrc,
    DWORD dwSize
    );

//
// Functions
//

INT
IInitDeviceFonts (
    PDEV    *pPDev
    )
/*++

Routine Description:

    Doing the actual grovelling around for font data.  We have a bit
    array of available fonts (created above),  so we use that as the
    basis of filling in the rest of the information.


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    The number of fonts available.
Note:
    11-27-96: Created it -ganeshp-

--*/
{
    INT         iIndex;      // Loop index
    INT         cBIFonts;    // Fonts built in to mini-driver
    INT         cXFonts = 0; // Non-minidriver font count
    INT         cFonts;      // Total number of fonts

    //TODEL BOOL bExpand; Set when font derivatives are available.

    FONTMAP     *pfm;        // Create this data

    PFONTPDEV    pFontPDev = pPDev->pFontPDev;

    //
    //    So how many fonts do we have?   Count them so that we can allocate
    //  storage for the array of FONTMAPs.
    //

    cBIFonts = pFontPDev->iDevFontsCt;

    if (!pFontPDev->hUFFFile)
#ifdef KERNEL_MODE
        pFontPDev->hUFFFile = FIOpenFontFile(pPDev->devobj.hPrinter, pPDev->devobj.hEngine, NULL);
#else
        pFontPDev->hUFFFile = FIOpenFontFile(pPDev->devobj.hPrinter, NULL);
#endif

    if (pFontPDev->hUFFFile)
        cXFonts = FIGetNumFonts(pFontPDev->hUFFFile);
    else
        cXFonts = 0;

    pFontPDev->iSoftFontsCt = cXFonts;

    //
    // Allocate enough memory to hold font map table.
    //

    cFonts = cBIFonts + cXFonts;

    pfm = (FONTMAP *)MemAllocZ( cFonts * SIZEOFDEVPFM() );
    if( pfm == 0 )
    {
        //
        // Failed to allocate memory
        //

        cFonts = cBIFonts = cXFonts = 0;
        ERR(("Failed to allocate memory"));
    }
    else
    {
        pFontPDev->pFontMap = pfm;

        //
        //  Select the first font as the default font,  just in case the
        // value is not initialised in the loop below.
        //

        pFontPDev->pFMDefault = pfm;

        //
        //   Continue only if there are device fonts.
        //
        if( cFonts )
        {

            //
            //   Initialize the default font:  we always do this now, as it is
            //  required to return the default font at DrvEnablePDEV time,
            //  and it is also simpler for us.
            //

            iIndex = IFontID2Index( pFontPDev, pFontPDev->dwDefaultFont );

            if( iIndex >= 0 && iIndex < cFonts )
            {
                // Found the default font ID,  so now set up details

                pfm = (PFONTMAP)( (PBYTE)pFontPDev->pFontMap
                    + SIZEOFDEVPFM() * iIndex);


                //
                // Index returned by IFontID2Index is 0 based. So no need to
                // Convert it to 0 based.
                // BFillinDeviceFM assumes it to be 0 based.
                //
                if( BFillinDeviceFM( pPDev, pfm, iIndex) )
                {
                    pFontPDev->pFMDefault = pfm;
                }
                else
                {
                    WARNING(("BFillinDeviceFM Fails\n"));
                    cFonts = cBIFonts = cXFonts = 0;
                }

            }
            else
                WARNING(("No Default Font Using first as default\n"));

            //
            //   Fill in some default font sensitive numbers!
            //

            pfm->flFlags |= FM_DEFAULT;

            //
            //  Set the size of the default font
            //
            if (pfm->pIFIMet)
            {
                pPDev->ptDefaultFont.y = ((IFIMETRICS *)pfm->pIFIMet)->fwdWinAscender/2;
                pPDev->ptDefaultFont.x = ((IFIMETRICS *)pfm->pIFIMet)->fwdAveCharWidth;
            }
            else
            {
                ERR(("Bad IFI Metrics Pointer\n"));
                cFonts = cBIFonts = cXFonts = 0;
            }
        }
    }

    //
    // Check for error condition. If an error has occured set devfont to 0
    //
    if (!cFonts)
    {
        pFontPDev->iDevFontsCt    =
        pFontPDev->iDevResFontsCt =
        pFontPDev->iSoftFontsCt   = 0;
    }

    //
    // Now load any alternate resource DLLs from where device font has to be
    // loaded. This is necessary now because snapshot will be unloaded after
    // DrvEnablePDev and WinResData.pUIInfo will be invalid. Because of this
    // DLL load will fail.
    //
    VLoadDeviceFontsResDLLs(pPDev);

    pPDev->iFonts = cFonts;               /* As many as we got */

    return    cFonts;

}


BOOL
BFillinDeviceFM(
    PDEV        *pPDev,
    FONTMAP     *pfm,
    int          iIndex
    )
/*++

Routine Description:

     Fill in (most) of the FONTMAP structure passed in.   The data is
     obtained from either the minidriver resources or from from the
     font installer file.  The only part we do not set is the NTRLE
     data,  as that is a little more complex.

Arguments:

    pPDev  -    Pointer to PDEV.
    pfm    -    The FONTMAP structure to fill in
    iIndex -    The 0 based index of the font to fill in

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-04-96: Created it -ganeshp-
--*/
{

    PFONTPDEV    pFontPDev;           /* More specific data */
    PFONTMAP_DEV pfmdev;
    RES_ELEM     ResElem;             /* For manipulating resource data */

    pFontPDev = pPDev->pFontPDev;

    pfm->dwSignature = FONTMAP_ID;
    pfm->dwSize      = sizeof(FONTMAP);
    pfm->dwFontType  = FMTYPE_DEVICE;
    pfm->pSubFM      = (PFONTMAP_DEV)(pfm+1);
    pfmdev           = pfm->pSubFM;

    /*
     *   Activity depends upon whether we have an internal or
     * external font. Externals are softfonts,  other than GDI downloaded.
     */

    if( iIndex < pFontPDev->iDevFontsCt )
    {
        DWORD  dwFont;                 /* Convert index to resource number */

        /*  Get the font ID for this index  */

        dwFont = pFontPDev->FontList.pdwList[iIndex];

        //
        // Check the Font Format of the resource. The new font IFI is stored
        // with RC_UFM tag. The old one was stored using RC_FONT.
        //
        if( BGetWinRes( &(pPDev->WinResData), (PQUALNAMEEX)&dwFont, RC_FONT, &ResElem ) )
        {
            pfm->flFlags |= FM_IFIVER40;

            if( !BGetOldFontInfo( pfm, ResElem.pvResData ) )
                return   FALSE;
        }
        else
        if(BGetWinRes( &(pPDev->WinResData),(PQUALNAMEEX)&dwFont,RC_UFM,&ResElem) )
        {
            if ( !BGetNewFontInfo(pfm, ResElem.pvResData) )
                return FALSE;

            if (pPDev->bTTY)
                ((FONTMAP_DEV*)pfm->pSubFM)->ulCodepage = pFontPDev->dwTTYCodePage;
        }
        else
        {
            ERR(("Can't Load the font data for res_id= %d\n", dwFont));
            return   FALSE;
        }

        //
        // Create the data we need. Unidrv5 only supports NT specific data.
        //


        pfmdev->dwResID = dwFont;

    }
    else
    {
        INT iFont = iIndex - pFontPDev->iDevFontsCt;

        /*
         * This must be an external font,  so we need to call the
         * code that understands how external font files are built.
         */

        if( !BFMSetupXF( pfm, pPDev, iFont ) )
            return   FALSE;

        pfmdev->dwResID = iFont;
    }

    /*
     *   If needed, scale the numbers to fit the desired resolution.
     */
    if( !BIFIScale( pfm, pPDev->ptGrxRes.x, pPDev->ptGrxRes.y ) )
        return   FALSE;

    /*
     *   Miscellaneous FM fields that can now be filled in.
     */

    pfm->wFirstChar = ((IFIMETRICS *)pfm->pIFIMet)->wcFirstChar;
    pfm->wLastChar  = ((IFIMETRICS *)pfm->pIFIMet)->wcLastChar;

    /*
     *   If this is an outline font,  then mark it as scalable. This
     *  piece of information is required at font selection time.
     */

    if (((IFIMETRICS *)pfm->pIFIMet)->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
        pfm->flFlags |= FM_SCALABLE;

    /*
     *    Select the translation table for this font.  If it is zero,
     * then use the default translation table,  contained in ModelData.
     */

    if( pfmdev->sCTTid == 0 )
        pfmdev->sCTTid = (SHORT)pFontPDev->sDefCTT;

    /*
     *   Some printers output the character with the cursor positioned
     * at the baseline,  others with it located at the top of the
     * character cell.  We store the needed offset in the FONTMAP
     * data,  to simplify life during output.  The data returned by
     * DrvQueryFontData is relative to the baseline.  For baseline
     * based fonts,  we need do nothing.  For top of cell fonts,
     * the fwdWinAscender value needs to be SUBTRACTED from the Y position
     * to determine the glyph's location on the page.
     */

    //
    // Set for non-scalable font
    // This value has to be scaled for scalable device font.
    //
    if( !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
        pfm->syAdj = -((IFIMETRICS *)(pfm->pIFIMet))->fwdWinAscender;
    else
        pfm->syAdj = 0;             /* There is none */


    /*
     *   Dot matrix printers also do funny things with double high
     * characters.  To handle this, the GPC spec contains a move
     * amount to add to the Y position before printing with these
     * characters.  There is also the adjustment for position
     * movement after printing.
     */

    pfmdev->sYAdjust = (SHORT)(pfmdev->sYAdjust * pPDev->ptGrxRes.y / pfm->wYRes);
    pfmdev->sYMoved  = (SHORT)(pfmdev->sYMoved  * pPDev->ptGrxRes.y / pfm->wYRes);

    //
    // Funciton pointer initialization.
    //
    pfm->pfnDownloadFontHeader = NULL;
    pfm->pfnDownloadGlyph      = NULL;
    pfm->pfnCheckCondition     = NULL;


    //
    // PCL-XL hack
    //
    if (pPDev->ePersonality == kPCLXL)
    {
        pfm->pfnGlyphOut     = DwOutputGlyphCallback;
        pfm->pfnSelectFont   = BSelectFontCallback;
        pfm->pfnDeSelectFont = BDeselectFontCallback;
    }
    else
    if( pfm->flFlags & FM_IFIVER40 )
    {
        pfm->pfnGlyphOut     = BRLEOutputGlyph;
        pfm->pfnSelectFont   = BRLESelectFont;
        pfm->pfnDeSelectFont = BRLEDeselectFont;
    }
    else
    {
        pfm->pfnGlyphOut     = BGTTOutputGlyph;
        pfm->pfnSelectFont   = BGTTSelectFont;
        pfm->pfnDeSelectFont = BGTTDeselectFont;
    }

    if (pfm->flFlags & FM_SOFTFONT)
    {
        pfm->pfnSelectFont   = BSelectTrueTypeBMP;
    }

    if (pPDev->pOemHookInfo)
    {
        if (pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook)
        {
            pfm->pfnGlyphOut     = DwOutputGlyphCallback;
        }

        if (pPDev->pOemHookInfo[EP_OEMSendFontCmd].pfnHook)
        {
            pfm->pfnSelectFont   = BSelectFontCallback;
            pfm->pfnDeSelectFont = BDeselectFontCallback;
        }
    }

    if (pfm->flFlags & FM_SCALABLE)
    {
        switch (pfmdev->wDevFontType)
        {
        case DF_TYPE_HPINTELLIFONT:
        case DF_TYPE_TRUETYPE:
            pfmdev->pfnDevSelFont =  BSelectPCLScalableFont;
            break;

        case DF_TYPE_PST1:
            pfmdev->pfnDevSelFont =  BSelectPPDSScalableFont;
            break;

        case DF_TYPE_CAPSL:
            pfmdev->pfnDevSelFont =  BSelectCapslScalableFont;
            break;
        }
    }
    else
    {
        pfmdev->pfnDevSelFont = BSelectNonScalableFont;
    }

    //
    // Get Glyph data (RLE/GTT)
    //

    VFillinGlyphData( pPDev, pfm );

    return   TRUE;
}


BOOL
BFMSetupXF(
    FONTMAP   *pfm,
    PDEV      *pPDev,
    INT        iIndex
    )
/*++

Routine Description:

       Function to setup the FONTMAP data for an external font.  We take the
       next entry in the file, which is presumed to have been rewound
       before we start being called.


Arguments:

    pfm   - Pointer to FONTMAP.
    pPDev - Pointer to PDEV.
    iIndex - Index of the font.

    Return Value:

    TRUE  - for success
    FALSE - for EOF

Note:
    12-05-96: Created it -ganeshp-
--*/
{
    FONTPDEV     *pFontPDev = pPDev->pFontPDev;
    UFF_FONTDIRECTORY *pFontDir;
    DATA_HEADER  *pDataHeader;
    FONTMAP_DEV  *pFMSub;
    BOOL          bRet;

    //
    //   Not much to do.  We basically need to convert the offsets in
    // the FONTMAP in the file (mapped into memory) into absolute
    // addresses so that the remainder of the driver is ignorant of
    //  We also set some flags to make it clear
    // what type of font and memory we are.
    //

    if (!(pDataHeader = FIGetFontData(pFontPDev->hUFFFile, iIndex)))
    {
        ERR(( "FIGetFontData returns FALSE!!\n" ));
        return  FALSE;
    }

    pFMSub = pfm->pSubFM;
    if (pFontDir = FIGetFontDir(pFontPDev->hUFFFile))
    {
        pFMSub->pFontDir = pFontDir + iIndex;
    }

    //
    // Check if this is a cartridge font and set flag
    //
    if (!pFMSub->pFontDir->offCartridgeName)
        pfm->flFlags |= FM_SOFTFONT;

    pfm->flFlags |= FM_EXTERNAL;

    switch (pDataHeader->dwSignature)
    {
    case DATA_IFI_SIG:
        pfm->flFlags |= FM_GLYVER40 | FM_IFIVER40;
        BGetOldFontInfo(pfm, (PBYTE)pDataHeader + pDataHeader->wSize);
        bRet = TRUE;
        break;

    case DATA_UFM_SIG:
        BGetNewFontInfo(pfm, (PBYTE)pDataHeader + pDataHeader->wSize);
        bRet = TRUE;
        break;

    default:
        bRet = FALSE;
        break;
    }

    return  bRet;
}

//
// Misc functions
//

#define XSCALE( x )     (x) = (FWORD)((( x ) * xdpi + iXDiv / 2) / iXDiv)
#define YSCALE( y )     (y) = (FWORD)((( y ) * ydpi + iYDiv / 2) / iYDiv)
#define YSCALENEG( y )     (y) = (FWORD)((( y ) * ydpi - iYDiv / 2) / iYDiv)

BOOL
BIFIScale(
    FONTMAP   *pfm,
    INT       xdpi,
    INT       ydpi
    )
/*++

Routine Description:

    Scale the IFIMETRICS fields to match the device resolution.  The
    IFIMETRICS are created using the device's master units,  which
    may not correspond with the resolution desired this time around.
    If they are different,  then we adjust.  May also need to allocate
    memory,  because resource data cannot be written to.


Arguments:

    pfm - Pointer to FONTMAP.
    xdpi - Selcted X Graphics Resolution.
    ydpi - Selcted Y Graphics Resolution.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-05-96: Created it -ganeshp-
--*/
{
    IFIMETRICS   *pIFI;

    int     iXDiv,  iYDiv;              /* Used in scaling */

    pIFI = pfm->pIFIMet;

    if (NULL == pIFI)
    {
        return FALSE;
    }

    if( (int)pfm->wXRes != xdpi || (int)pfm->wYRes != ydpi )
    {
        /*  Need to scale,  so need memory to create writeable version */
        BYTE  *pbMem;           /* For convenience */


        if( pfm->flFlags & FM_IFIRES )
        {
            /*
             *   The data is in a resource,  so we need to do something
             * civilised: copy the data to memory that can be written.
             */

            if( pbMem = MemAllocZ( pIFI->cjThis ) )
            {
                /*   Got the memory,  so copy it and off we go  */

                CopyMemory( pbMem, (BYTE *)pIFI, pIFI->cjThis );

                pIFI = (IFIMETRICS *)pbMem;

                pfm->pIFIMet = pIFI;
                pfm->flFlags &= ~FM_IFIRES;              /* No longer */
            }
            else
                return   FALSE;
        }

        if( (int)pfm->wXRes != xdpi )
        {
            /*  Adjust the X values,  as required */

            if( !(iXDiv = pfm->wXRes) )
                iXDiv = xdpi;           /* Better than div by 0 */

            XSCALE( pIFI->fwdMaxCharInc );
            XSCALE( pIFI->fwdAveCharWidth );
            XSCALE( pIFI->fwdSubscriptXSize );
            XSCALE( pIFI->fwdSubscriptXOffset );
            XSCALE( pIFI->fwdSuperscriptXSize );
            XSCALE( pIFI->fwdSuperscriptXOffset );
            XSCALE( pIFI->ptlAspect.x );
            XSCALE( pIFI->rclFontBox.left );
            XSCALE( pIFI->rclFontBox.right );

            if (pIFI->dpFontSim)
            {
                PTRDIFF    dpTmp;
                FONTDIFF* pFontDiff;
                FONTSIM*  pFontSim;

                pFontSim = (FONTSIM*) ((PBYTE) pIFI + pIFI->dpFontSim);

                if (dpTmp = pFontSim->dpBold)
                {
                    pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);

                    XSCALE( pFontDiff->fwdMaxCharInc );
                    XSCALE( pFontDiff->fwdAveCharWidth );
                }
                if (dpTmp = pFontSim->dpItalic)
                {
                    pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);

                    XSCALE( pFontDiff->fwdMaxCharInc );
                    XSCALE( pFontDiff->fwdAveCharWidth );
                }
                if (dpTmp = pFontSim->dpBoldItalic)
                {
                    pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);

                    XSCALE( pFontDiff->fwdMaxCharInc );
                    XSCALE( pFontDiff->fwdAveCharWidth );
                }
            }
        }

        if( (int)pfm->wYRes != ydpi )
        {
            /*
             *    Note that some of these numbers are negative,  and so
             *  we need to round them correctly - i.e. subtract the rounding
             *  factor to move the value further from 0.
             */

            int   iPixHeight;



            if( !(iYDiv = pfm->wYRes) )
                iYDiv = ydpi;

            /*  Adjust the Y values,  as required */

            /*
             *     NOTE:   simply scaling will NOT produce the same values
             *  as Win 3.1  This is because of what gets rounded.  Win 3.1
             *  does not have the WinDescender field,  but calculates it
             *  from dfPixHeight and dfAscent AFTER THESE HAVE BEEN SCALED
             *  (INCLUDING ROUNDING!!).   To emulate that,  we calculate
             *  the  dfPixHeight value,  then scale that and dfAscent to
             *  allow us to "properly" calculate WinDescender.  This stuff
             *  is needed for Win 3.1 compatability!
             */

            YSCALE( pIFI->fwdUnitsPerEm );

            iPixHeight = pIFI->fwdWinAscender + pIFI->fwdWinDescender;
            YSCALE( iPixHeight );
            YSCALE( pIFI->fwdWinAscender );

            pIFI->fwdWinDescender = iPixHeight - pIFI->fwdWinAscender;

            YSCALE( pIFI->fwdMacAscender );
            pIFI->fwdMacDescender  = -pIFI->fwdWinDescender;

            YSCALE( pIFI->fwdMacLineGap );

            YSCALE( pIFI->fwdTypoAscender );
            YSCALE( pIFI->fwdTypoDescender );
            YSCALE( pIFI->fwdTypoLineGap);

            YSCALE( pIFI->fwdCapHeight );
            YSCALE( pIFI->fwdXHeight );

            YSCALE( pIFI->fwdSubscriptYSize );
            YSCALENEG( pIFI->fwdSubscriptYOffset );
            YSCALE( pIFI->fwdSuperscriptYSize );
            YSCALE( pIFI->fwdSuperscriptYOffset );

            YSCALE( pIFI->fwdUnderscoreSize );
            if( pIFI->fwdUnderscoreSize == 0 )
                pIFI->fwdUnderscoreSize = 1;    /* In case it vanishes */

            YSCALENEG( pIFI->fwdUnderscorePosition );
            if( pIFI->fwdUnderscorePosition == 0 )
                pIFI->fwdUnderscorePosition = -1;

            YSCALE( pIFI->fwdStrikeoutSize );
            if( pIFI->fwdStrikeoutSize == 0 )
                pIFI->fwdStrikeoutSize = 1;     /* In case it vanishes */

            YSCALE( pIFI->fwdStrikeoutPosition );

            YSCALE( pIFI->ptlAspect.y );
            YSCALE( pIFI->rclFontBox.top );
            YSCALE( pIFI->rclFontBox.bottom );

#undef  XSCALE
#undef  YSCALE
#undef  YSCALENEG

        }
    }

    return  TRUE;
}

HANDLE
HLoadUniResDll(PDEV *pPDev)
{
    PWSTR  pwstrTmp, pwstrResFileName, pwstrDrvName;
    HANDLE hHandle;



    if (pPDev->pDriverInfo3)
        pwstrDrvName = pPDev->pDriverInfo3->pDriverPath;
    else
        return NULL;

    pwstrResFileName = MemAlloc((1 + wcslen(pwstrDrvName)) * sizeof(WCHAR));

    if (pwstrResFileName == NULL)
        return NULL;

    wcscpy(pwstrResFileName, pwstrDrvName);

#ifdef WINNT_40
    if (!(pwstrTmp = wcsstr(pwstrResFileName, TEXT("UNIDRV4.DLL"))))
#else
    if (!(pwstrTmp = wcsstr(pwstrResFileName, TEXT("UNIDRV.DLL"))))
#endif
    {
        MemFree(pwstrResFileName);
        return NULL;
    }

    *pwstrTmp = '\0';
    wcscat(pwstrResFileName, TEXT("unires.dll"));

    hHandle = EngLoadModule(pwstrResFileName);
#ifdef DBG
    if (!hHandle)
    {
        ERR(("UNIDRV: Failed to load UNIRES.DLL\n"));
    }
#endif

    MemFree(pwstrResFileName);

    return hHandle;

}


VOID
VFillinGlyphData(
    PDEV      *pPDev,
    FONTMAP   *pfm
    )
/*++

Routine Description:

    Provide the RLE data required for this font.  Basically look to see
    if some other font has this RLE data already loaded; if so,  then
    point to that and return.    Otherwise,  load the resource etc.


Arguments:

    pPDev - Pointer to PDEV.
    pfm   - The FONTMAP whose Gyphy Translation data is required

    Return Value:

    Nothing

Note:
    12-05-96: Created it -ganeshp-
--*/
{
    int      iIndex;         /* Scan the existing array */
    short    sCurVal;        /* Speedier access */
    BOOL     bSymbol;
    DWORD     dwCurVal;
    PQUALNAMEEX pQualName = (PQUALNAMEEX)&dwCurVal;

    PVOID     pvData;        /* The FD_GLYPHSET format we want */
    FONTMAP  *pfmIndex;      /* Speedy scanning of existing list */
    FONTMAP_DEV *pfmdev, *pfmdevIndex;

    FONTPDEV  *pFontPDev;       /* More specialised data */

    TRACE(\nUniFont!VFillinGlyphData:START);

    pvData = NULL;           /* In case Nothing we can do!  */
    pfmdev = pfm->pSubFM;
    bSymbol = IS_SYMBOL_CHARSET(pfm);

    /*
     *  First step is to look through the existing FONTMAP array,  and
     *  if we find one with the same sCTTid and same format as us,  use it!
     *  Otherwise,we need to load the resource and do it the hard way!
     */

    pFontPDev = pPDev->pFontPDev;

    if (pfm->flFlags & FM_EXTERNAL)
    {
        sCurVal = pfmdev->pFontDir->sGlyphID;
    }
    else
    {
        //
        // Minidriver Resource case.
        // RLE/GTT file must be in the same DLL as IFI/UFM is.
        //
        //
        // Convert the resource ID to fully qualied ID. The format is
        // OptionID.ResFeatureID.ResourceID. Get the option and feature ID from
        // fontmap dwRes
        //
        pQualName->wResourceID  = sCurVal = pfmdev->sCTTid;
        pQualName->bFeatureID   = pfmdev->QualName.bFeatureID;
        pQualName->bOptionID    = pfmdev->QualName.bOptionID;
    }

    pfmIndex = pFontPDev->pFontMap;

    for( iIndex = 0;
         iIndex < pPDev->iFonts;
         ++iIndex, pfmIndex = (PFONTMAP)((PBYTE)pfmIndex + SIZEOFDEVPFM()) )
    {
        pfmdevIndex = (PFONTMAP_DEV) pfmIndex->pSubFM;

        if( (pfmdevIndex                   &&
             pfmdevIndex->pvNTGlyph)       &&
             pfmIndex->pIFIMet             &&
             (pfmdevIndex->sCTTid == sCurVal)  &&
             ((pfmIndex->flFlags & FM_IFIVER40) ==
                            (pfm->flFlags & FM_IFIVER40)) &&
             ((pfmIndex->flFlags & FM_EXTERNAL) ==
                            (pfm->flFlags & FM_EXTERNAL)) &&
             pfm->pIFIMet->jWinCharSet ==
                 pfmIndex->pIFIMet->jWinCharSet )
        {
            //
            // Found it, so use that address!!
            //
            pfmdev->pvNTGlyph = pfmdevIndex->pvNTGlyph;

            //
            //Mark the flag for Glyph Data Format.
            //
            if (pfmIndex->flFlags & FM_GLYVER40)
                pfm->flFlags |= FM_GLYVER40;

            if (bSymbol)
            {
                pfm->wLastChar  = SYMBOL_END;

                if (!(pfm->flFlags & FM_IFIRES))
                    pfm->pIFIMet->wcLastChar = SYMBOL_END;
            }

            TRACE(Using a Already Loaded Translation Table.)
            PRINTVAL((pfm->flFlags & FM_GLYVER40), 0X%x);
            PRINTVAL((pfm->flFlags & FM_IFIVER40), 0X%x);
            TRACE(UniFont!VFillinGlyphData:END\n);

            return;
        }
    }


    /*
     *    Do it the hard way - load the resource, convert as needed etc.
     */


    if( sCurVal < 0 )
    {
        /* Use Predefined resource */

        DWORD  dwSize;                         /* Data size of resource */
        int    iRCType;
        HMODULE hUniResDLL;
        BYTE  *pb;

        if (!pPDev->hUniResDLL)
            pPDev->hUniResDLL = HLoadUniResDll(pPDev);

        hUniResDLL = pPDev->hUniResDLL;

        /*
         *   These are resources we have,  so we need to use
         *  the normal resource mechanism to get the data.
         */

        ASSERTMSG( hUniResDLL,("UNIDRV!vFillinGlyphData - Null Module handle \n"));
        //VERBOSE(("Using prdefined Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));
        PRINTVAL( (LONG)sCurVal, %ld );

        //
        // Load the old format RLE if the font format is NT40.
        // Otherwise, New Format PreDefined Glyph Data.
        //
        if ( hUniResDLL )
        {
            if (pfm->flFlags & FM_IFIVER40)
            {
                iRCType = RC_TRANSTAB;
            }
            else
            {
                iRCType = RC_GTT;
            }

            pb = EngFindResource( hUniResDLL, (-sCurVal), iRCType, &dwSize );

            if( pb )
            {
                if (pfm->flFlags & FM_IFIVER40)
                {
                    NT_RLE_res *pntrle_res = (NT_RLE_res*)pb;
                    dwSize = sizeof(NT_RLE) +
                             (pntrle_res->fdg_cRuns - 1) * sizeof(WCRUN) +
                             pntrle_res->cjThis - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;

                    if( !(pvData = (VOID *)MemAllocZ( dwSize )) ||
                        dwSize != CopyMemoryRLE( pvData, pb, dwSize )   )
                    {
                        MemFree(pvData);
                        pvData = NULL;
                        ERR(("\n!!!UniFont!VFillinGlyphData:MemAllocZ Failed.\
                             \nFontID = %d,Name = %ws,CTTid = %d\n\n",pfmdev->dwResID,\
                             (PBYTE)pfm->pIFIMet + pfm->pIFIMet->dpwszFaceName,(-sCurVal)));
                    }

                    pfm->flFlags |= FM_GLYVER40;
                }
                else
                {
                    if( pvData = (VOID *)MemAllocZ( dwSize ) )
                        CopyMemory( pvData, pb, dwSize );
                    else
                    {
                        ERR(("\n!!!UniFont!VFillinGlyphData:MemAllocZ Failed.\
                             \nFontID = %d,Name = %ws,CTTid = %d\n\n",pfmdev->dwResID,\
                             (PBYTE)pfm->pIFIMet + pfm->pIFIMet->dpwszFaceName,(-sCurVal)));
                    }
                }

                /* This One wil be freed when done */
                pfm->flFlags |= FM_FREE_GLYDATA;

            }
            else
            {
                ERR(("\n!!!UniFont!VFillinGlyphData:EngFindResource Failed\n"));
            }
        }

    }
    else if( pfm->flFlags & FM_EXTERNAL)
    {
        PDATA_HEADER pDataHeader;

        pDataHeader = FIGetGlyphData(pFontPDev->hUFFFile, sCurVal);
        if (pDataHeader)
            pvData = (PBYTE)pDataHeader + pDataHeader->wSize;
    }
    else
    {
        /* Use Minidriver Resources */

        RES_ELEM  re;           /* Resource summary */

        /*
         *   First step:  locate the resource,  then grab some
         *  memory for it,  copy data across.The minidriver trans
         *  table can be in two formats. NT 4.0 resource uses
         *  RC_TRANSTAB tag and the new one uses RC_GTT tag. So
         *  try using both of the and set the flFlag accordingly.
         *  If FM_GLYVER40 is off that means the resource is new
         *  format and On means old format.
         */

        if ( BGetWinRes( &(pPDev->WinResData), pQualName, RC_GTT, &re ) )
        {
            pvData = re.pvResData;
            //VERBOSE(("Using New Format Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));

        }
        else if( BGetWinRes( &(pPDev->WinResData), pQualName, RC_TRANSTAB, &re ) )
        {
            NT_RLE_res *pntrle_res = (NT_RLE_res*)re.pvResData;
            DWORD dwSize = sizeof(NT_RLE) +
                     (pntrle_res->fdg_cRuns - 1) * sizeof(WCRUN) +
                     pntrle_res->cjThis - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;

            if( !(pvData = (VOID *)MemAllocZ( dwSize )) ||
                dwSize != CopyMemoryRLE( pvData, (PBYTE)pntrle_res, dwSize )   )
            {
                MemFree(pvData);
                pvData = NULL;
                ERR(("\n!!!UniFont!VFillinGlyphData:MemAllocZ Failed.\
                     \nFontID = %d,Name = %ws,CTTid = %d\n\n",pfmdev->dwResID,\
                     (PBYTE)pfm->pIFIMet + pfm->pIFIMet->dpwszFaceName,(-sCurVal)));
            }

            if (pvData)
            {
                pfm->flFlags |= FM_FREE_GLYDATA;
            }

            pfm->flFlags |= FM_GLYVER40;
            //VERBOSE(("Using Old Format Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));
        }
        else
            pvData = NULL;           /* No translation data! */

    }

    if( pvData == NULL )
    {
        /*
         *   Presume this to mean that no translation is required.
         *  We build a special RLE table for this,  to make life
         *  easier for us.
         */
        //VERBOSE(("No specific Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));

        if (pfm->flFlags & FM_IFIVER40)
        {
            pvData = PNTRLE1To1(bSymbol, 0x20, 0xff );
            pfm->flFlags |= FM_GLYVER40;
            TRACE(\tUsing OLD Format default Translation);
        }
        else //New Format
        {
            pvData = PNTGTT1To1(pfmdev->ulCodepage, bSymbol, 0x20, 0xff);
            TRACE(\tUsing NEW Format default Translation);
        }

        if (pvData)
        {
            pfm->flFlags |= FM_FREE_GLYDATA; /* This one will be freed when done */
            if (bSymbol)
            {
                pfm->wLastChar  = SYMBOL_END;
                if (!(pfm->flFlags & FM_IFIRES))
                    pfm->pIFIMet->wcLastChar = SYMBOL_END;
            }
        }
        else
            WARNING(("vFillInRLE - pvData was NULL\n"));
    }

    PRINTVAL((pfm->flFlags & FM_GLYVER40), 0X%x);
    PRINTVAL((pfm->flFlags & FM_IFIVER40), 0X%x);

    pfmdev->pvNTGlyph = pvData;          /* Save it for posterity */

    TRACE(UniFont!VFillinGlyphData:END\n);

    return ;
}

INT
IFontID2Index(
    FONTPDEV   *pFontPDev,
    int        iID
    )
/*++

Routine Description:

    Turns the given font ID into an index into the resource data.  The
    Font ID is a sequential number,  starting at 1, which the engine
    uses to reference our fonts.


Arguments:

    pFontPDev               For Access to device font resID list.
    iID                     The font resource ID whose index is required

Return Value:

    0 based font index,  else -1 on error.

    Note:
    11-27-96: Created it -ganeshp-

--*/
{


    int      iFontIndex;



    /*
     *  Just go through the font list. When a match is found return the index.
     */


    for( iFontIndex = 0; iFontIndex < pFontPDev->iDevFontsCt; iFontIndex++)
    {
        if( pFontPDev->FontList.pdwList[iFontIndex] == (DWORD)iID)
        {
            //
            // This function returns 0 based font index.
            //
            return iFontIndex;
        }
    }

    /*
     *    We get here when we fail to match the desired ID.  This should
     *  never happen!
     */
    return  -1;


}

VOID
VLoadDeviceFontsResDLLs(
    PDEV        *pPDev
    )
/*++

Routine Description:
      This routine loads all the DLLs which has device fonts. This is needed as
      snapshot is unloaded after DrvEnablePDEV. So in Drv Calls for font query
      pPDev->UIInfo will be NULL and BGetWinRes will fail.


Arguments:

    pPDev  - Pointer to PDEV.

Return Value:

    None

    Note:
    11-06-98: Created it -ganeshp-

--*/
{


    INT         iFontIndex;
    DWORD       dwFontResID;
    PQUALNAMEEX pQualifiedID;
    FONTPDEV    *pFontPDev;
    RES_ELEM    ResElem;

    pFontPDev    = pPDev->pFontPDev;
    pQualifiedID = (PQUALNAMEEX)&dwFontResID;

    /*
     * Just go through the font list and load each one of them if they are
     * from other resource DLL.
     */


    for( iFontIndex = 0; iFontIndex < pFontPDev->iDevFontsCt; iFontIndex++)
    {
        dwFontResID = pFontPDev->FontList.pdwList[iFontIndex];

        //
        // Check if this font is from root resource DLL. If yes then goto
        // next one.
        //
        if (pQualifiedID->bFeatureID == 0 && (pQualifiedID->bOptionID & 0x7f) == 0)
            continue;
        else
        {
            //
            // This font is not from root resource DLL so load it. We don't need
            // to look for error as we are only interested in loading the DLL.
            //
            BGetWinRes( &(pPDev->WinResData), (PQUALNAMEEX)&dwFontResID, RC_FONT, &ResElem );
        }
    }



}

DWORD
CopyMemoryRLE(
    PVOID pvData,
    PBYTE pubSrc,
    DWORD dwSize)
{
    NT_RLE_res *pntrle_res;
    NT_RLE     *pntrle;
    HGLYPH     *pHGlyph;     
    DWORD       dwOutSize = 0;
    DWORD       dwRestOfData;
    DWORD       dwSubtractNT_RLE_Header;

    ULONG ulI;

    if (pvData == NULL ||
        pubSrc == NULL  )
        return 0;

    pntrle_res = (NT_RLE_res*)pubSrc;
    pntrle     = (NT_RLE*)pvData;

    //
    // Copy first 12 bytes.
    // struct {
    //     WORD wType;
    //     BYTE bMagic0;
    //     BYTE bMagic1;
    //     DWORD cjThis;
    //     WORD wchFirst;
    //     WORD wchLast;
    //
    if (dwSize < dwOutSize + 12)
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < 12\n"));
        return 0;
    }

    CopyMemory(pntrle, pntrle_res, 12);
    dwOutSize += offsetof(NT_RLE, fdg);

    //
    // FD_GLYPHSET
    // On IA64 machine, a padding DWORD is inserted before FD_GLYPHSET.
    // 
    if (dwSize < dwOutSize + sizeof(FD_GLYPHSET) - sizeof(WCRUN))
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < sizeof(NT_RLE)\n"));
        return 0;
    }

    pntrle->fdg.cjThis           = offsetof(FD_GLYPHSET, awcrun) +
                                   pntrle_res->fdg_cRuns * sizeof(WCRUN);
    pntrle->fdg.flAccel          = pntrle_res->fdg_flAccel;
    pntrle->fdg.cGlyphsSupported = pntrle_res->fdg_cGlyphSupported;
    pntrle->fdg.cRuns            = pntrle_res->fdg_cRuns;
    dwOutSize += sizeof(FD_GLYPHSET) - sizeof(WCRUN);

    pHGlyph                      = (HGLYPH*)((PBYTE)pntrle + sizeof(NT_RLE) +
                                  (pntrle_res->fdg_cRuns - 1) * sizeof(WCRUN));

    //
    // WCRUN
    //
    if (dwSize < dwOutSize + sizeof(WCRUN) * pntrle_res->fdg_cRuns)
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < sizeof(WCRUN)\n"));
        return 0;
    }

    dwOutSize += sizeof(WCRUN) * pntrle_res->fdg_cRuns;

    //
    // NT_RLE bug workaround.
    // Some of *.RLE files have an offset from the top of NT_RLE to HGLYPH array in FD_GLYPHSET.WCRUN.phg.
    // phg needs to have an offset from the top of FD_GLYPHSET to HGLYPH array.
    //
    // Check if the offset to the last HGLYPH is larger than the whole size of memory allocation.
    // If it is, it means the offset is from the top of NT_RLE. We need to subtract offsetof(NT_RLE< fdg),
    // the size of NT_RLE header.
    //
    if (pntrle_res->fdg_wcrun_awcrun[pntrle_res->fdg_cRuns - 1].dwOffset_phg +
        sizeof(HGLYPH) * (pntrle_res->fdg_wcrun_awcrun[pntrle_res->fdg_cRuns - 1].cGlyphs - 1)
         >= dwSize - offsetof(NT_RLE, fdg))
    {
        dwSubtractNT_RLE_Header = offsetof(NT_RLE, fdg);
    }
    else
    {
        dwSubtractNT_RLE_Header = 0;
    }
 
    //
    // IA64 fix. WCRUN has the pointer to HGLYPH. The size of pointer is 8 on IA64 or 4 on X86.
    // We need to adjust phg, depending on the platform.
    // The padding DWORD before FD_GLYPHSET don't have to be considered. phg has an offset from top of FD_GLYPHSET
    // to the HGLYPH array.
    //
    for (ulI = 0; ulI < pntrle_res->fdg_cRuns; ulI ++)
    {
        pntrle->fdg.awcrun[ulI].wcLow   = pntrle_res->fdg_wcrun_awcrun[ulI].wcLow;
        pntrle->fdg.awcrun[ulI].cGlyphs = pntrle_res->fdg_wcrun_awcrun[ulI].cGlyphs;
        pntrle->fdg.awcrun[ulI].phg     = (HGLYPH*)IntToPtr(pntrle_res->fdg_wcrun_awcrun[ulI].dwOffset_phg +
                                          pntrle_res->fdg_cRuns * (sizeof(HGLYPH*) - sizeof(DWORD)) - dwSubtractNT_RLE_Header);
    }

    //
    // HGLYPH and offset data
    //
    if (dwSize < dwOutSize + sizeof(HGLYPH) * pntrle_res->fdg_cGlyphSupported)
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < HGLYLH array\n"));
        return 0;
    }

    if (dwSubtractNT_RLE_Header)
    {
        dwRestOfData = pntrle_res->cjThis - offsetof(NT_RLE_res, fdg_wcrun_awcrun) - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;
    }
    else
    {
        dwRestOfData = pntrle_res->cjThis - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;
    }
    dwOutSize += dwRestOfData;

    CopyMemory(pHGlyph, (PBYTE)pntrle_res + pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg, dwRestOfData);

    if (pntrle_res->wType == RLE_LI_OFFSET)
    {
        WORD wDiff = (WORD)(pntrle_res->fdg_cRuns * (sizeof(HGLYPH*) - sizeof(DWORD)));
        for (ulI = 0; ulI < pntrle_res->fdg_cGlyphSupported; ulI++, pHGlyph++)
        {
            ((RLI*)pHGlyph)->wOffset += wDiff;
        }
    }

    return dwOutSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmtxtout.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    textout.c

Abstract:

    The FMTextOut() function - the call used to output Text.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/16/97 -ganeshp-
        Created

--*/

//
//This line should be before the line including font.h.
//Comment out this line to disable FTRC and FTST macroes.
//
//#define FILETRACE

#include "font.h"

/*
 *   Some clipping constants.  With a complex clip region,  it is desirable
 *  to avoid enumerating the clip rectangles more than once.  To do so,
 *  we have a bit array, with each bit being set if the glyph is inside
 *  the clipping region,  cleared if not.  This allows us to obtain a
 *  set of glyphs,  then determine whether they are printed when the clip
 *  rectangles are enumerated.   Finally,  use the bit array to stop
 *  printing any glyphs outside the clip region.  This is slightly heavy
 *  handed for the simple case.
 */

#define RECT_LIMIT        100    // Clipping rectangle max

#define DC_TC_BLACK     0       /* Fixed Text Colors in 4 bit mode */
#define DC_TC_MAX       8       /* used for 16 colour palette wrap around */

#define CMD_TC_FIRST    CMD_SELECTBLACKCOLOR

// For Dithered Color BRUSHOBJ.iSolidColor is -1.
#define DITHERED_COLOR   -1

//Various TextOut specific flags.
#define    TXTOUT_CACHED        0x00000001 // Text is cached and printed after graphics.
#define    TXTOUT_SETPOS        0x00000002 // True if cursor position to be set.
#define    TXTOUT_FGCOLOR       0x00000004 // Device can paint the text.
#define    TXTOUT_COLORBK       0x00000008 // For z-ordering fixes
#define    TXTOUT_NOTROTATED    0x00000010 // Set if Text is not rotated.
#define    TXTOUT_PRINTASGRX    0x00000020 // Set if Text should be printed as
                                           // Graphics.
#define    TXTOUT_DMS           0x00000040 // Set if Device Managed surface
#define    TXTOUT_90_ROTATION   0x00000080 // Set if font is 90-rotated.

#define     DEVICE_FONT(pfo, tod) ( (pfo->flFontType & DEVICE_FONTTYPE) || \
                                    (tod.iSubstFace) )

#define ERROR_PER_GLYPH_POS     3
#define ERROR_PER_ENUMERATION   15
#define EROOR_PER_GLYPHRECT     5  // For Adjusting height of the glyph rect.


/*  NOTE:  this must be the same as the winddi.h ENUMRECT */
typedef  struct
{
   ULONG    c;                  /* Number of rectangles returned */
   RECTL    arcl[ RECT_LIMIT ]; /* Rectangles supplied */
} MY_ENUMRECTS;

/*
 *   Local function prototypes.
 */
VOID
SelectTextColor(
    PDEV      *pPDev,
    PVOID     pvColor
    );

VOID
VClipIt(
    BYTE     *pbClipBits,
    TO_DATA  *ptod,
    CLIPOBJ  *pco,
    STROBJ   *pstro,
    int       cGlyphs,
    int       iRot,
    BOOL      bPartialClipOn
    );

BOOL
BPSGlyphOut(
    register  TO_DATA  *pTOD
    );

BOOL
BRealGlyphOut(
    register  TO_DATA  *pTOD
    );

BOOL
BWhiteText(
    TO_DATA  *pTOD
    );

BOOL
BDLGlyphOut(
    TO_DATA   *pTOD
    );

VOID
VCopyAlign(
    BYTE  *pjDest,
    BYTE  *pjSrc,
    int    cx,
    int    cy
    );

INT
ISubstituteFace(
    PDEV    *pPDev,
    FONTOBJ *pfo);

HGLYPH
HWideCharToGlyphHandle(
    PDEV    *pPDev,
    FONTMAP *pFM,
    WCHAR    wchOrg);

PHGLYPH
PhAllCharsPrintable(
    PDEV  *pPDev,
    INT    iSubst,
    ULONG  ulGlyphs,
    PWCHAR pwchUnicode);

BOOL
BGetStartGlyphandCount(
    BYTE  *pbClipBits,
    DWORD dwEndIndex,
    DWORD *pdwStartIndex,
    DWORD *pdwGlyphToPrint);

BOOL
BPrintTextAsGraphics(
    PDEV        *pPDev,
    ULONG       iSolidColor,
    DWORD       dwForeColor,
    DWORD       dwFlags,
    INT         iSubstFace
    );


BOOL
FMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    )
/*++
Routine Description:

    The call to use for output of text.  Our behaviour depends
    upon the type of printer.  Page printers (e.g. LaserJets) do
    whatever is required to send the relevant commands to the printer
    during this call.  Otherwise (typified by dot matrix printers),
    we store the data about the glyph so that we can output the
    characters as we are rendering the bitmap.  This allows the output
    to be printed unidirectionally DOWN the page.

Arguments:

    pso;            Surface to be drawn on
    pstro;          The "string" to be produced
    pfo;            The font to use
    pco;            Clipping region to limit output
    prclExtra;      Underline/strikethrough rectangles
    prclOpaque;     Opaquing rectangle
    pboFore;        Foreground brush object
    pboOpaque;      Opaqueing brush
    pptlBrushOrg;   Brush origin for both above brushes
    mix;            The mix mode


Return Value:

    TRUE for success and FALSE for failure.FALSE logs the error.

Note:

    1/16/1997 -ganeshp-
        Created it.
--*/

{
    PDEV        *pPDev;            // Our main PDEV
    FONTPDEV    *pFontPDev;        // FONTMODULE based PDEV
    FONTMAP     *pfm;              // Font's details
    GLYPHPOS    *pgp, *pgpTmp;     // Value passed from gre
    XFORMOBJ    *pxo;              // The transform of interest
    FLOATOBJ_XFORM xform;
    TO_DATA      tod;              // Our convenience
    RECTL        rclRegion;        // For z-ordering fixes
    HGLYPH      *phSubstGlyphOrg, *phSubstGlyph;
    POINTL       ptlRem;

    BOOL       (*pfnDrawGlyph)( TO_DATA * );  // How to produce the glyph
    PFN_OEMTextOutAsBitmap pfnOEMTextOutAsBitmap = NULL;

    I_UNIFONTOBJ UFObj;

    ULONG      iSolidColor;

    DWORD      dwGlyphToPrint, dwTotalGlyph, dwPGPStartIndex, dwFlags;
    DWORD      dwForeColor;

    INT        iyAdjust;           // Adjust for printing position WRT baseline
    INT        iXInc, iYInc;       // Glyph to glyph movement, if needed
    INT        iRot;               // The rotation factor
    INT        iI, iJ, iStartIndex;

    WCHAR     *pwchUnicode;

    BYTE      *pbClipBits;         // For clip limits
    BYTE       ubMask;

    BOOL       bMore;              // Getting glyphs from engine loop
    BOOL       bRet = FALSE;       // Return Value.

    //
    // First step is to extract the PDEV address from the surface.
    // Then we can get to all the other bits & pieces that we need.
    // We should also initialize the TO_DATA as much as possible.
    //

    pPDev = (PDEV *) pso->dhpdev;
    if( !(VALID_PDEV(pPDev)) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ERR(( "Invalid or NULL PDEV\n" ))

        return  FALSE;
    }

    //
    //  Quick check on abort - should we return failure NOW
    //
    if( pPDev->fMode & PF_ABORTED )
        return  FALSE;

    //
    // Misc initialization
    //

    dwFlags             = 0;
    iRot                = 0;
    pgp                 =
    pgpTmp              = NULL;
    pfm                 = NULL;
    pbClipBits          = NULL;
    phSubstGlyphOrg     = NULL;

    //
    // Initialize TO_DATA
    //
    ZeroMemory(&tod, sizeof(TO_DATA));
    tod.pPDev  = pPDev;
    tod.pfo    = pfo;
    tod.flAccel= pstro->flAccel;

    pFontPDev = pPDev->pFontPDev;           // The important stuff

    //
    // Initialize TT file pointer to NULL to avoid caching. TT File pointer
    // should be initialized per DrvTextOut. Also initialize the TOD pointer.
    // This is needed by download routines, which have access to PDEV only.
    //

    pFontPDev->pTTFile = NULL;
    pFontPDev->pcjTTFile = 0;
    pFontPDev->ptod = &tod;

    pFontPDev->pso = pso;  // SURFOBJ changes every call - so reset
    pFontPDev->pIFI = FONTOBJ_pifi(pfo);

    if( pPDev->dwFreeMem && (pFontPDev->flFlags & FDV_TRACK_FONT_MEM) )
        pFontPDev->dwFontMem = pPDev->dwFreeMem;

    iSolidColor = pboFore->iSolidColor;     // Local Copy.
    dwForeColor = BRUSHOBJ_ulGetBrushColor(pboFore);

    //
    //
    // Flag Initialization
    //
    //
    // Check if the printer can set the foreground color.This is necessary
    // to support grey or dithered device fonts.
    //
    if (pFontPDev->flFlags & FDV_SUPPORTS_FGCOLOR)
        dwFlags |= TXTOUT_FGCOLOR;

    if (DRIVER_DEVICEMANAGED (pPDev))
        dwFlags |= TXTOUT_DMS;

    //
    // Device managed surface has to send White text when it's received.Also
    // we don't need to do any Z-order specific checking.
    //

    if (!(dwFlags & TXTOUT_DMS))
    {
        BOOL bIsRegionW;

        //
        // Get rectangle for background checking - z-ordering fix
        //

        if ( !BIntersectRect(&rclRegion, &(pstro->rclBkGround),&(pco->rclBounds)))
            return TRUE;

        bIsRegionW = bIsRegionWhite(pso, &rclRegion);
        
#ifndef DISABLE_NEWRULES        
        // 
        // if there is an opaque background or the text color is not black, we
        // need to test whether the text overlaps the rules array
        //
        if (bIsRegionW && pPDev->pbRulesArray && pPDev->dwRulesCount > 0)
        {
                PRECTL pTmpR = prclOpaque;
                if (!pTmpR && 
                    ((pso->iBitmapFormat == BMF_24BPP ||
                      iSolidColor != (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) &&
                     (pso->iBitmapFormat != BMF_24BPP ||
                      iSolidColor != 0)))
                {
                    pTmpR = &rclRegion;
                }
                if (pTmpR)
                {
                    DWORD i;
                    for (i = 0;i < pPDev->dwRulesCount;i++)
                    {
                        PRECTL pTmp = &pPDev->pbRulesArray[i];
                        if (pTmp->right > pTmpR->left &&
                            pTmp->left < pTmpR->right &&
                            pTmp->bottom > pTmpR->top &&
                            pTmp->top < pTmpR->bottom)
                        {
                            bIsRegionW = FALSE;
                            break;
                        }
                    }
                }
        }
#endif        
        if (((ULONG)pFontPDev->iWhiteIndex == iSolidColor) && !bIsRegionW)
            dwFlags |= TXTOUT_CACHED;

        //
        // Z-ordering fix, check if we are not printing Text as graphics.
        //

        if (pFontPDev->flFlags & FDV_DLTT || pfo->flFontType & DEVICE_FONTTYPE)
        {
            //
            // If we are banding and this isn't a device font we want to
            // use EngTextOut if the textbox crosses a band boundary. This
            // is because the bIsRegionWhite test can't test the entire
            // region so it is invalid.
            //
            if ((pPDev->bBanding && !(pfo->flFontType & DEVICE_FONTTYPE) &&
                   (rclRegion.left != pstro->rclBkGround.left            ||
                    rclRegion.right != pstro->rclBkGround.right          ||
                    rclRegion.bottom != pstro->rclBkGround.bottom        ||
                    (rclRegion.top != pstro->rclBkGround.top             &&
                     pPDev->rcClipRgn.top != 0)))                        ||
                   !bIsRegionW)
            {
                dwFlags |= TXTOUT_COLORBK;
            }
        }
    }

    //
    // This is necessary because we map low intensity color to black
    // in palette management,
    // However, if we detect text and graphic overlapping, we map
    // low intensity color to white so it's visible over graphics
    //
    if ( pso->iBitmapFormat == BMF_4BPP &&
         dwFlags & TXTOUT_COLORBK)
    {
        if (pboFore->iSolidColor == 8)
        {
            iSolidColor = pFontPDev->iWhiteIndex;
            dwFlags |= TXTOUT_CACHED;
        }
    }

    //
    // Font substitution initialization
    //
    // Get iFace to substitute TrueType font with.
    // Note: pwszOrg is available only when SO_GLYPHINDEX_TEXTOUT is set
    //       in  pstro->flAccel.
    //       SO_DO_NOT_SUBSTITUTE_DEVICE_FONT also has to be checked for BI-DI
    //       fonts.
    //
    //  We should now get the transform.  This is only really needed
    //  for a scalable font OR a printer which can do font rotations
    //  relative to the graphics orientation (i.e. PCL5 printers!).
    //  It is easier just to get the transform all the time.
    //

    pxo = FONTOBJ_pxoGetXform( pfo );
    XFORMOBJ_iGetFloatObjXform(pxo, &xform);
    pFontPDev->pxform = &xform;


    if (NO_ROTATION(xform))
        dwFlags |= TXTOUT_NOTROTATED;

    if (pFontPDev->pIFI->flInfo & FM_INFO_90DEGREE_ROTATIONS)
        dwFlags |= TXTOUT_90_ROTATION;

    tod.iSubstFace = 0;
    tod.phGlyph    = NULL;
    pwchUnicode    = NULL;
    tod.cGlyphsToPrint = pstro->cGlyphs;

    if (!(pstro->flAccel & SO_GLYPHINDEX_TEXTOUT))
    {
        pwchUnicode = pstro->pwszOrg;
    }

    //
    // Conditions to substitute:
    // The Text is not supposed to be printed as graphics and
    // Device can substitute font and
    // Font is True Type   and
    // STROBJ flags have no conflict with substitution.
    //

    if ( (pfo->flFontType & TRUETYPE_FONTTYPE)      &&
         !(pstro->flAccel & ( SO_GLYPHINDEX_TEXTOUT  |
                             SO_DO_NOT_SUBSTITUTE_DEVICE_FONT)) )
    {
        INT iSubstFace;

        if ((iSubstFace = ISubstituteFace(pPDev, pfo)) &&
            (phSubstGlyphOrg = PhAllCharsPrintable(pPDev,
                                                iSubstFace,
                                                pstro->cGlyphs,
                                                pwchUnicode)))
        {
            tod.iSubstFace = iSubstFace;
        }
    }

    //
    // Check if Text should be printed as graphics or not.
    //
    if( BPrintTextAsGraphics(pPDev, iSolidColor, dwForeColor, dwFlags, tod.iSubstFace) )
    {
        dwFlags |= TXTOUT_PRINTASGRX;
        tod.iSubstFace = 0;
    }

    //
    // Initialize for OEM Callback function
    // ulFontID
    // dwFlags
    // pIFIMetrics
    // pfnGetInfo
    // pFontObj
    // pStrObj
    // pFontMap
    // pFontPDev
    // ptGrxRes
    // pGlyph
    //

    if(pPDev->pOemHookInfo || (pPDev->ePersonality == kPCLXL))
    {
        ZeroMemory(&UFObj, sizeof(I_UNIFONTOBJ));
        UFObj.pfnGetInfo  = UNIFONTOBJ_GetInfo;
        UFObj.pPDev       = pPDev;
        UFObj.pFontObj    = pfo;
        UFObj.pStrObj     = pstro;
        UFObj.ptGrxRes    = pPDev->ptGrxRes;
        UFObj.pIFIMetrics = pFontPDev->pIFI;

        if (tod.cGlyphsToPrint)
            UFObj.pGlyph  = MemAlloc(sizeof(DWORD) * tod.cGlyphsToPrint);

        if (pfo &&
            !(pfo->flFontType & DEVICE_FONTTYPE) )
        {
            PFN_OEMTTDownloadMethod pfnOEMTTDownloadMethod;


            if (tod.iSubstFace == 0 && 
                ( (pPDev->pOemHookInfo &&
                   (pfnOEMTTDownloadMethod = (PFN_OEMTTDownloadMethod)pPDev->pOemHookInfo[EP_OEMTTDownloadMethod].pfnHook))
                || (pPDev->ePersonality == kPCLXL))
               )
            {
                DWORD    dwRet = TTDOWNLOAD_DONTCARE;

                HANDLE_VECTORPROCS(pPDev, VMTTDownloadMethod, ((PDEVOBJ)pPDev,
                                                            (PUNIFONTOBJ)&UFObj,
                                                            &dwRet))
                else
                if(pPDev->pOemEntry)
                {
                    FIX_DEVOBJ(pPDev, EP_OEMTTDownloadMethod);

                    if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                    {
                            HRESULT  hr ;
                            hr = HComTTDownloadMethod((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                        &pPDev->devobj, (PUNIFONTOBJ)&UFObj, &dwRet);
                            if(SUCCEEDED(hr))
                                ;  //  cool !
                    }
                    else
                    {
                        dwRet = pfnOEMTTDownloadMethod(&pPDev->devobj,
                                               (PUNIFONTOBJ)&UFObj);
                    }
                }

                switch (dwRet)
                {
                case TTDOWNLOAD_GRAPHICS:
                case TTDOWNLOAD_DONTCARE:
                    dwFlags |= TXTOUT_PRINTASGRX;
                    break;
                    //
                    // A default is to download as bitmap.
                    //
                case TTDOWNLOAD_BITMAP:
                    UFObj.dwFlags |= UFOFLAG_TTDOWNLOAD_BITMAP | UFOFLAG_TTFONT;
                    break;
                case TTDOWNLOAD_TTOUTLINE:
                    UFObj.dwFlags |= UFOFLAG_TTDOWNLOAD_TTOUTLINE | UFOFLAG_TTFONT;
                    break;
                }
            }
        }

        pFontPDev->pUFObj = &UFObj;
    }
    else
    {
        pFontPDev->pUFObj = NULL;
    }

    pPDev->fMode |= PF_DOWNLOADED_TEXT;

    //
    // Get FONTMAP
    //

    //
    // Conditions to download:
    // Text should not be printed as graphics and
    // Font should be TRUETYPE and
    // It is not getting substituted.
    //

    if ( !(dwFlags & TXTOUT_PRINTASGRX)             &&
         (pfo->flFontType & TRUETYPE_FONTTYPE)      &&
         !tod.iSubstFace  )
    {

        //
        // This function sets pfm pointer and iFace in TO_DATA.
        //     tod.iFace
        //     tod.pfm
        //
        if (IDownloadFont(&tod, pstro, &iRot) >= 0)
        {
            pfm = tod.pfm;

            //
            // yAdj has to be added to tod.pgp->ptl.y
            //
            iyAdjust = pfm ? (int)(pfm->syAdj) : 0;
        }
        else
        {
            //
            // If the call fails call engine to draw.
            //

            pfm = NULL;
        }

    }

    if ( DEVICE_FONT(pfo, tod) ) // Device Font
    {
        if( pfo->iFace < 1 || (int)pfo->iFace > pPDev->iFonts )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            ERR(( "Invalid iFace (%ld) in DrvTextOut",pfo->iFace ));
            goto ErrorExit;
        }

        //
        //  Get the stuff we really need for this font
        //

        tod.iFace = pfo->iFace;

        pfm = PfmGetDevicePFM(pPDev, tod.iSubstFace?tod.iSubstFace:tod.iFace);

        if (tod.iSubstFace)
        {
            UFObj.dwFlags |= UFOFLAG_TTSUBSTITUTED;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOAveCharWidth = pFontPDev->pIFI->fwdAveCharWidth;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOMaxCharInc = pFontPDev->pIFI->fwdMaxCharInc;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOUnitsPerEm = pFontPDev->pIFI->fwdUnitsPerEm;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOWinAscender = pFontPDev->pIFI->fwdWinAscender;
        }

        //
        // Deivce font PFM must be returned.
        //
        if (pfm == NULL)
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            ERR(( "Invalid iFace (%ld) in DrvTextOut",pfo->iFace ));
            goto ErrorExit;
        }

	//
	// Set the transform for Device fonts.For downloaded fonts we have already
	// set the transform in download code. Check also for HP Intellifont
	//
	if ( DEVICE_FONT(pfo, tod) )
	{
	    iRot = ISetScale( &pFontPDev->ctl,
			      pxo,
			      (( pfm->flFlags & FM_SCALABLE) &&
				 (((PFONTMAP_DEV)pfm->pSubFM)->wDevFontType ==
				 DF_TYPE_HPINTELLIFONT)),
			      (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

	}
    }

    tod.iRot = iRot;

    UFObj.pFontMap = pfm;
    UFObj.apdlGlyph = tod.apdlGlyph;
    UFObj.dwNumInGlyphTbl = pstro->cGlyphs;

    //
    // TO_DATA initialization
    //
    tod.pfm = pfm;
    if (tod.iSubstFace)
    {
        BOOL bT2Bold, bT2Italic;
        BOOL bDevBold, bDevItalic, bUnderline;

        bT2Bold = (pFontPDev->pIFI->fsSelection & FM_SEL_BOLD) ||
                  (pfo->flFontType & FO_SIM_BOLD);
        bT2Italic = (pFontPDev->pIFI->fsSelection & FM_SEL_ITALIC) ||
                    (pfo->flFontType & FO_SIM_ITALIC);

        bDevBold = (pfm->pIFIMet->fsSelection & FM_SEL_BOLD) ||
                   (pfm->pIFIMet->usWinWeight > FW_NORMAL);
        bDevItalic = (pfm->pIFIMet->fsSelection & FM_SEL_ITALIC) ||
                   (pfm->pIFIMet->lItalicAngle != 0);

        bUnderline = ((pFontPDev->flFlags & FDV_UNDERLINE) && prclExtra)?FONTATTR_UNDERLINE:0;

        tod.dwAttrFlags =
            ((bT2Bold && !bDevBold)?FONTATTR_BOLD:0) |
            ((bT2Italic && !bDevItalic)?FONTATTR_ITALIC:0) |
            (bUnderline?FONTATTR_UNDERLINE:0) |
            FONTATTR_SUBSTFONT;
    }
    else
        tod.dwAttrFlags =
            ( ((pfo->flFontType & FO_SIM_BOLD)?FONTATTR_BOLD:0)|
              ((pfo->flFontType & FO_SIM_ITALIC)?FONTATTR_ITALIC:0)|
              (((pFontPDev->flFlags & FDV_UNDERLINE) && prclExtra)?FONTATTR_UNDERLINE:0)
            );

    //
    // If DEVICE_FONTTYPE not set,  we are dealing with a GDI font.  If
    // the printer can handle it,  we should consider downloading the font
    // to make it a pseudo device font.  If this is a heavily used font,
    // then printing will be MUCH faster.
    //
    // However there are some points to consider.  Firstly, we need to
    // consider the available memory in the printer; little will be gained
    // by downloading a 72 point font,  since there can only be a few
    // glyphs per page.  Also,  if the font is not black (or at least a
    // solid colour), then it cannot be treated as a downloaded font.
    //
    // If the font is TT and we are not doing font substitution,
    // then check for Conditions for not downloading, which are:
    //
    // GDI Font with no cache (DDI spec, iUniq == 0) or
    // Text should be printed as graphics or
    // The Text is white, Assume that there is some merged graphics or
    // iDownLoadFont fails and returns an invalid download index or
    // OEM font download callback doesn't support correct formats.
    //

    if ( !(DEVICE_FONT(pfo, tod))                  &&
         (   (pfo->iUniq == 0)                                          ||
             (dwFlags & TXTOUT_PRINTASGRX)                              ||
             ( pfm == NULL )                                            ||
             ( pPDev->pOemHookInfo &&
               pPDev->pOemHookInfo[EP_OEMTTDownloadMethod].pfnHook &&
               (UFObj.dwFlags & (UFOFLAG_TTDOWNLOAD_BITMAP |
                                 UFOFLAG_TTDOWNLOAD_TTOUTLINE)) == 0)
         )
      )
    {

        /*
         *   GDI font,  and either cannot or do not wish to download.
         *  So,  let the engine handle it!
         */
        PrintAsBitmap:

        if (!(dwFlags & TXTOUT_DMS))   // bitmap surface
        {
        CheckBitmapSurface(pso,&pstro->rclBkGround);
#ifdef WINNT_40 //NT 4.0
        STROBJ_vEnumStart(pstro);
#endif
        bRet = EngTextOut( pso,
                           pstro,
                           pfo,
                           pco,
                           prclExtra,
                           prclOpaque,
                           pboFore,
                           pboOpaque,
                           pptlBrushOrg,
                           mix );

        }
        else
        HANDLE_VECTORPROCS_RET(pPDev, VMTextOutAsBitmap, bRet, (pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlBrushOrg, mix))
        else
        {
            if ( pPDev->pOemHookInfo &&
               (pfnOEMTextOutAsBitmap = (PFN_OEMTextOutAsBitmap)
                pPDev->pOemHookInfo[EP_OEMTextOutAsBitmap].pfnHook))
            {

                bRet = FALSE;
                FIX_DEVOBJ(pPDev, EP_OEMTextOutAsBitmap);

                if(pPDev->pOemEntry)
                {
                    if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                    {
                            HRESULT  hr ;
                            hr = HComTextOutAsBitmap((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                        pso,
                                                         pstro,
                                                         pfo,
                                                         pco,
                                                         prclExtra,
                                                         prclOpaque,
                                                         pboFore,
                                                         pboOpaque,
                                                         pptlBrushOrg,
                                                         mix );
                            if(SUCCEEDED(hr))
                                bRet = TRUE ;  //  cool !
                    }
                    else
                    {
                        bRet = pfnOEMTextOutAsBitmap (pso,
                                                         pstro,
                                                         pfo,
                                                         pco,
                                                         prclExtra,
                                                         prclOpaque,
                                                         pboFore,
                                                         pboOpaque,
                                                         pptlBrushOrg,
                                                         mix );
                    }
                }
            }
            else
                 bRet = FALSE;
        }

        goto ErrorExit;
    }

    //
    // Mark the scanlines to indicate the present of text, z-ordering fix
    //
    // returns BYTE
    //

    if (!(dwFlags & TXTOUT_DMS))   // bitmap surface
    {
        //
        // Mark the scanlines to indicate the present of text, z-ordering fix
        //

        ubMask = BGetMask(pPDev, &rclRegion);
        for (iI = rclRegion.top; iI < rclRegion.bottom ; iI++)
        {
            pPDev->pbScanBuf[iI] |= ubMask;
        }
    }

    /*
     *  Serial printers (those requiring the text be fed out at the same
     *  time as the raster data) are processed by storing all the text
     *  at this time,  then playing it back while rendering the bitamp.
     *  THIS ALSO HAPPENS FOR WHITE TEXT,  on those printers capable
     *  of doing this.  The difference is that the white text is played
     *  back in one hit AFTER RENDERING THE BITMAP.
     */

    //
    // Realize the Color
    //

    if ((!(dwFlags & TXTOUT_DMS)) &&
        !(tod.pvColor = GSRealizeBrush(pPDev, pso, pboFore)) )
    {
        ERR(( "GSRealizeBrush Failed;Can't Realize the Color\n" ));
        goto ErrorExit;
    }

    //
    // Font selection
    //
    // Initialize pfnDrwaGlyph function pointer
    // pfnDrwaGlyph cound be
    //     BPSGlyphOut     -- Dot matrics
    //     BWhiteText      -- White character
    //     BRealGlyphOut   -- Device font output
    //     BDLGlyphOut     -- TrueType download font output
    //

    if( pFontPDev->flFlags & FDV_MD_SERIAL )
    {
        //
        // yAdj has to be added to tod.pgp->ptl.y
        // Device font could be scalable font so that iyAdjust calculation
        // has to be done after BNewFont.
        //
        iyAdjust = (int)pfm->syAdj + (int)((PFONTMAP_DEV)pfm->pSubFM)->sYAdjust;

        //
        //  Dot matrix or white text on an LJ style printer
        //
        pfnDrawGlyph =  BPSGlyphOut;

        //
        //For Serial printer White text is also interlaced.
        //
        dwFlags &= ~(TXTOUT_CACHED|TXTOUT_SETPOS);      /* Assume position is set elsewhere */
    }
    else
    {

        /*
         *     Page printer - e.g. LaserJet.   If this is a font that we
         *  have downloaded,  then there is a specific output routine
         *  to use.  Using a downloaded font is rather tricky, as we need
         *  to translate HGLYPHs to char index, or possibly bitblt the
         *  bitmap to the page bitmap.
         */

        if( DEVICE_FONT(pfo, tod) )
        {
            if (dwFlags & TXTOUT_COLORBK)
            {
                /* Z-ordering fix, delay device font to the end */
                dwFlags |= TXTOUT_CACHED;
            }

            UFObj.ulFontID = ((PFONTMAP_DEV)pfm->pSubFM)->dwResID;

            pfnDrawGlyph = BRealGlyphOut;
            BNewFont(pPDev,
                     tod.iSubstFace?tod.iSubstFace:tod.iFace,
                     pfm,
                     tod.dwAttrFlags);

            //
            // yAdj has to be added to tod.pgp->ptl.y
            // Device font could be scalable font so that iyAdjust calculation
            // has to be done after BNewFont.
            //
            iyAdjust = (int)pfm->syAdj + (int)((PFONTMAP_DEV)pfm->pSubFM)->sYAdjust;

        }
        else
        {
            //
            // GDI font (TrueType), so we will want print it. All the glyphs
            // are already downloaded. The font has already been selected by
            // IDownloadFont
            //
            pfnDrawGlyph = BDLGlyphOut;
            UFObj.ulFontID = pfm->ulDLIndex;
        }

        //
        // For DMS we don't want to not cache the text. So turn off
        // TXTOUT_CACHED flag.
        //
        if (dwFlags & TXTOUT_DMS)
            dwFlags &= ~TXTOUT_CACHED;

        //
        // For cached text always use BWhiteText as we need to send cached text
        // after the graphics.
        //
        if (dwFlags & TXTOUT_CACHED)
        {
            pfnDrawGlyph = BWhiteText;
        }

        dwFlags |= TXTOUT_SETPOS;

    }

    /*
     * Also set the colour - ignored if already set or irrelevant
     * We want to select the color only if we are not caching the text.
     * Cache text when we have white text or it's a serial printer
     */

    if (!((dwFlags & TXTOUT_DMS) || (dwFlags & TXTOUT_CACHED) ||
          (pFontPDev->flFlags & FDV_MD_SERIAL)))
        SelectTextColor( pPDev, tod.pvColor );

    //
    // Initialize iXInc and iYInc for SO_FLAG_DEFAULT_PLACEMENT
    //

    iXInc = iYInc = 0;                  /* We do nothing case */

    if( (pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) && pstro->ulCharInc )
    {
        /*
         *     We need to calculate the positions ourselves, as GDI has
         *  become lazy to gain some speed - I guess.
         */

        if( pstro->flAccel & SO_HORIZONTAL )
            iXInc = pstro->ulCharInc;

        if( pstro->flAccel & SO_VERTICAL )
            iYInc =  pstro->ulCharInc;

        if( pstro->flAccel & SO_REVERSED )
        {
            /*   Going the other way! */
            iXInc = -iXInc;
            iYInc = -iYInc;
        }
    }

    //
    // Allocate GLYPHPOS structure.
    //

    pgp    = MemAlloc(sizeof(GLYPHPOS) * pstro->cGlyphs);

    if (!pgp)
    {
        ERR(("pgp memory allocation failed\r\n"));
        goto ErrorExit;
    }

    //
    //
    // Allocate pbClipBits. size = cMaxGlyphs / BBITS
    //

    if (!(pbClipBits = MemAlloc((pstro->cGlyphs + BBITS - 1)/ BBITS)))
    {
        ERR(("pbClipBits memory allocation failed\r\n"));
        goto ErrorExit;
    }

    //
    // Start Glyph Enumuration
    //
    //
    // Enumuration
    //
    // (a) iStartIndex        - phSubstGlyphOrg
    // (b) dwPGPStartIndex    - pgp, pbClipBits, tod
    //
    //                 (pgp, pbClipBits)
    //                       |
    //                       |   dwPGPStartIndex
    //                       |   |
    //                       |   v   +Current point in the string.
    //                       |       |
    //                       |<----->|
    //                       |       |<----dwGlyphToPrint--->|       |
    //                       v       |                       v       |
    // |-----------------------------+-------------------------------|
    // ^                     |
    // |<-----iStartIndex--->|<------------dwTotalGlyph------------->|
    // |
    // phSubstGlyphOrg
    //

    iStartIndex  = 0;
    tod.dwCurrGlyph = 0;
    tod.flFlags |= TODFL_FIRST_ENUMRATION;

    STROBJ_vEnumStart(pstro);
    do
    {
        #ifndef WINNT_40 //NT 5.0

        bMore = STROBJ_bEnumPositionsOnly( pstro, &dwTotalGlyph, &pgpTmp );

        #else // NT 4.0

        bMore = STROBJ_bEnum( pstro, &dwTotalGlyph, &pgpTmp );

        #endif //!WINNT_40

        CopyMemory(pgp, pgpTmp, sizeof(GLYPHPOS) * dwTotalGlyph);

        //
        // Set the first Glyph position in the TextOut data. This can be used
        // by Glyph Output functions to optimize.
        //
        tod.ptlFirstGlyph = pgp[0].ptl;

        //
        // Evaluate the position of the chars if this is needed.
        // SO_FLAG_DEFAULT_PLACEMENT case
        //

        if( iXInc || iYInc )
        {
            //
            // NT4.0 font support or GDI soft font
            //
            if ( !(pfo->flFontType & DEVICE_FONTTYPE) ||
                 (pfm->flFlags & FM_IFIVER40) )
            {
                for( iI = 1; iI < (int)dwTotalGlyph; ++iI )
                {
                    pgp[ iI ].ptl.x = pgp[ iI - 1 ].ptl.x + iXInc;
                    pgp[ iI ].ptl.y = pgp[ iI - 1 ].ptl.y + iYInc;
                }
            }
            else
            //
            // NT5.0 device font support
            //
            {
                PMAPTABLE pMapTable;
                PTRANSDATA pTrans;

                pMapTable = GET_MAPTABLE(((PFONTMAP_DEV)pfm->pSubFM)->pvNTGlyph);
                pTrans = pMapTable->Trans;

                //
                // iXInc and iYInc are DBCS width when Far East charset.
                //
                for( iI = 1; iI < (int)dwTotalGlyph; ++iI )
                {
                    if (pTrans[pgp[iI].hg - 1].ubType & MTYPE_SINGLE)
                    {
                        pgp[ iI ].ptl.x = pgp[ iI - 1 ].ptl.x + iXInc/2;
                        pgp[ iI ].ptl.y = pgp[ iI - 1 ].ptl.y + iYInc;
                    }
                    else
                    {
                        pgp[ iI ].ptl.x = pgp[ iI - 1 ].ptl.x + iXInc;
                        pgp[ iI ].ptl.y = pgp[ iI - 1 ].ptl.y + iYInc;
                    }
                }
            }
        }


        //
        // Initialize the pgp in TextOut Data for Clipping.
        //
        tod.pgp         = pgp;
        dwPGPStartIndex  = 0;

        //
        // Check to see if there is any character at the boundary of clipping
        // rectangle.
        //
        VClipIt( pbClipBits, &tod, pco, pstro, dwTotalGlyph, iRot, pFontPDev->flFlags & FDV_ENABLE_PARTIALCLIP);

        //
        // If partial clipping has happend for TT font, call EngTextOut.
        //
        if (tod.flFlags & TODFL_TTF_PARTIAL_CLIPPING )
        {
            //
            // We have to use goto, but no other better way.
            //
            goto PrintAsBitmap;
        }

        //
        // Replace pgp's hg with Device font glyph handle
        //
        if (tod.iSubstFace)
        {
            tod.phGlyph     =
            phSubstGlyph    = phSubstGlyphOrg + iStartIndex;

            pgpTmp = pgp;

            for (iJ = 0; iJ < (INT)(int)dwTotalGlyph; iJ++, pgpTmp++)
            {
                pgpTmp->hg = *phSubstGlyph++;
            }
        }

        while ( dwTotalGlyph > dwPGPStartIndex )
        {
            //
            // Got the glyph data, so onto the real work!
            //

            if (BGetStartGlyphandCount(pbClipBits,
                                       dwTotalGlyph,
                                       &dwPGPStartIndex,
                                       &dwGlyphToPrint))
            {
                //VERBOSE(("dwTotalGlyph        = %d\n", dwTotalGlyph));
                //VERBOSE(("dwGlyphToPrint      = %d\n", dwGlyphToPrint));
                //VERBOSE(("dwPGPStartIndex     = %d\n", dwPGPStartIndex));

                ASSERT((dwTotalGlyph > dwPGPStartIndex));

                tod.dwCurrGlyph  = iStartIndex + dwPGPStartIndex;

                //
                // DCR: Add the Glyph position optimization call here.
                // If we are drawing Underline or strike through then disable
                // default placement optimization.
                //
                // if( prclExtra )
                //    tod.flFlags &= ~TODFL_DEFAULT_PLACEMENT;

                if (dwFlags & TXTOUT_SETPOS)
                {

                    //
                    // Set initial position so that LaserJets can
                    // use relative position.   This is deferred until
                    // here because applications (e.g. Excel) start
                    // printing right off the edge of the page, and
                    // our position tracking code then needs to
                    // understand what the printer does about moving
                    // out of the printable area. This is too risky
                    // to be safe,  so we save setting the position
                    // until we are in the printable region. Note
                    // that this assumes that the clipping data we
                    // have is limited to the printable region.
                    // I believe this to be true (16 June 1993).
                    //
                    //
                    // We need to handle the return value. Devices with
                    // resoloutions finer than their movement capability
                    // (like LBP-8 IV) get into a knot here , attempting
                    // to y-move on each glyph. We pretend we got where
                    // we wanted to be.
                    //

                    VSetCursor( pPDev,
                                pgp[dwPGPStartIndex].ptl.x,
                                pgp[dwPGPStartIndex].ptl.y+(iyAdjust?iyAdjust:0),
                                MOVE_ABSOLUTE,
                                &ptlRem);

                    pPDev->ctl.ptCursor.y += ptlRem.y;


                    VSetRotation( pFontPDev, iRot );    /* It's safe now */

                    //
                    // If the default placement is not set then we need to set
                    // the cursor for each enumration. So we clear the SETPOS
                    // flag only for default placement.
                    //

                    if ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT))
                        dwFlags &= ~TXTOUT_SETPOS;

                    //
                    // we set the cursor to forst glyph position. So set
                    // the TODFL_FIRST_GLYPH_POS_SET flag. Output function
                    // don't need to do a explicit move to this position.
                    //
                    tod.flFlags |= TODFL_FIRST_GLYPH_POS_SET;
                }


                tod.pgp              = pgp + dwPGPStartIndex;
                tod.cGlyphsToPrint   = dwGlyphToPrint;

                if ( iyAdjust )
                {
                    for ( iI = 0; iI < (int)dwGlyphToPrint; iI ++)
                        tod.pgp[iI].ptl.y += iyAdjust;
                }

                if( !pfnDrawGlyph( &tod ) )
                {
                    ERR(( "Glyph Drawing Failed;Can't draw the glyph\n" ));
                    goto ErrorExit;
                }
            }
            else // None of the Glyphs are printable.
            {
                //
                // If none of the glyphs are printable that update the counters
                // to point to next run.
                //

                dwGlyphToPrint = dwTotalGlyph;
            }

            dwPGPStartIndex += dwGlyphToPrint;
        }

        iStartIndex += dwTotalGlyph;

        //
        // Clear the first enumartion flag, if more glyphs has to be enumerated.
        //
        if (bMore)
        {
            tod.flFlags &= ~TODFL_FIRST_ENUMRATION;

        }

    } while( bMore );

    //
    // Actual character printing. We may have enumurated once for downloading.
    // So call STROBJ_vEnumStart here.
    //

    //
    //   Restore the normal graphics orientation by setting rotation to 0.
    //

    VSetRotation( pFontPDev, 0 );

    /*
     *   Do the rectangles.  If present,  these are defined by prclExtra.
     *  Typically these are used for strikethrough and underline.
     */

    if( prclExtra )
    {
        if (!DRIVER_DEVICEMANAGED (pPDev) &&   // If not device managed surface
            !(pFontPDev->flFlags & FDV_UNDERLINE))
        {
            /* prclExtra is an array of rectangles;  we loop through them
             * until we find one where all 4 points are 0.engine does not
             * follow the spec - only sets x coords to 0.
             */

            while( prclExtra->left != prclExtra->right &&
                       prclExtra->bottom != prclExtra->top )
            {

                /* Use the engine's Bitblt function to draw the rectangles.
                 * last parameter is 0 for black!!
                 */
                 
                CheckBitmapSurface(pso,prclExtra);
                if( !EngBitBlt( pso, NULL, NULL, pco, NULL, prclExtra, NULL, NULL,
                                        pboFore, pptlBrushOrg, 0 ) )
                {
                    ERR(( "EngBitBlt Failed;Can't draw rectangle simulations\n" ));
                    goto ErrorExit;
                }

                ++prclExtra;
            }
        }
    }

    //
    // Set the dwFreeMem in PDEV
    //
    if( pPDev->dwFreeMem && (pFontPDev->flFlags & FDV_TRACK_FONT_MEM) )
    {
        pPDev->dwFreeMem = pFontPDev->dwFontMem - pFontPDev->dwFontMemUsed;
        pFontPDev->dwFontMemUsed = 0;
    }

    bRet = TRUE;

    //
    // Free pbClipBits
    //
    ErrorExit:

    //
    // In case of white text, BPlayWhite text must free the pgp.
    //

    if (pgp)
        MemFree(pgp);
    if (pbClipBits)
        MemFree(pbClipBits);
    if (phSubstGlyphOrg)
        MemFree(phSubstGlyphOrg);
    MEMFREEANDRESET(tod.apdlGlyph );
    VUFObjFree(pFontPDev);
    pFontPDev->ptod = NULL;
    pFontPDev->pIFI = NULL;
    pFontPDev->pUFObj = NULL;

    return  bRet;
}

BOOL
BPrintTextAsGraphics(
    PDEV        *pPDev,
    ULONG       iSolidColor,
    DWORD       dwForeColor,
    DWORD       dwFlags,
    INT         iSubstFace
    )
/*++
Routine Description:
    This routine checks the textout flag for printing text as graphics.

Arguments:
    pPDev     PDEV struct.
    dwFlags   TextOut Flags

Return Value:
    TRUE if text should be printed as graphics else FALSE

Note:

    10/9/1997 -ganeshp-
        Created it.
--*/

{
    FONTPDEV    *pFontPDev;        // FONTMODULE based PDEV


    //
    // Local initialization.
    //
    pFontPDev = pPDev->pFontPDev;

    //
    // DMS
    //
    if (pPDev->ePersonality == kPCLXL)
    {
        return FALSE;
    }


    //
    // Condition to print as graphics:
    // No substitution and Download option is FALSE in bitmap mode .
    //
    if ( (!iSubstFace && !(pFontPDev->flFlags & FDV_DLTT))              ||
        //
        // Font is rotated.
        //
        !(dwFlags & TXTOUT_NOTROTATED)                                  ||
        //
        // TXTOUT_COLORBK says that there is a color background. Merging with
        // Graphics. For non DMS case.
        //
        (dwFlags &  TXTOUT_COLORBK)                                     ||

        //
        // Color is non Primary color or Model doesn't supports programmable
        // foreground Color
        //
        // Print text as graphics, if device doesn't support programable
        // foreground color and the color of text is dithered and not black.
        //
        (!(dwFlags & TXTOUT_FGCOLOR) &&
         iSolidColor == DITHERED_COLOR &&
         (0x00FFFFFF & dwForeColor) !=  0x00000000)                     ||

        //
        // Disable substitution of device font for TrueType, if device does't
        // support programable foreground color and color is not black.
        //
        (iSubstFace &&
         !(dwFlags & TXTOUT_FGCOLOR) &&
         (0x00FFFFFF & dwForeColor) !=  0x00000000)                     
         )
   {
       return TRUE;

   }
    else
        return FALSE;

}

//
// pfnDrawGlyph functions
//     BDLGlyphOut
//     BWhiteText
//     BRealGlyphOut
//     BDLGGlyphOut
//

BOOL
BDLGlyphOut(
    TO_DATA   *pTOD
    )
/*++
Routine Description:
      Function to process a glyph for a GDI font we have downloaded.  We
      either treat this as a normal character if this glyph has been
      downloaded,  or BitBlt it to the page bitmap if it is one we did
      not download.

Arguments:

    pTOD    Textout Data. Holds all necessary information.

Return Value:

    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{
    BOOL        bRet;
    FONTMAP     *pFM;

    bRet = FALSE;

    if ( pFM = pTOD->pfm)
    {
        //
        // Check if the glyphout fucntions pointer is not null and then call
        // the function. We also have to check the return value. The fmtxtout
        // function assumes that the Glyphout fucntion will print all the
        // glyphs it requested to print i.e pTOD->cGlyphsToPrint should be
        // equal to return value of pFM->pfnGlyphOut.
        //

        if ( pFM->pfnGlyphOut )
        {
            DWORD dwGlyphPrinted;

            dwGlyphPrinted = pFM->pfnGlyphOut(pTOD);

            if (dwGlyphPrinted != pTOD->cGlyphsToPrint)
            {
                ERR(("UniFont!BDLGlyphOut:pfnGlyphOut didn't print all glyphs\n"));
            }
            else
                bRet = TRUE;
        }
        else
        {
            ERR(("UniFont!BDLGlyphOut:pFM->pfnGlyphOut is NULL\n"));
        }
    }
    else
    {
        ERR(("UniFont!BDLGlyphOut:pTOD->pfm is NULL, Can't do glyphout\n"));
    }

    return  bRet;

}


BOOL
BRealGlyphOut(
    register  TO_DATA  *pTOD
    )
/*++
Routine Description:
    Print this glyph on the printer,  at the given position.  Unlike
    bPSGlyphOut,  the data is actually spooled for output now,  since this
    function is used for things like LaserJets, i.e. page printers.

Arguments:
    pTOD    Textout Data. Holds all necessary information.

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{
    //
    //    All we need to do is set the Y position,  then call bOutputGlyph
    //  to do the actual work.
    //

    PDEV      *pPDev;
    PGLYPHPOS  pgp;   // Glyph positioning info
    DWORD      dwGlyph;
    INT        iX,iY; // Calculate real position
    BOOL       bRet;

    ASSERTMSG(pTOD->pfm->pfnGlyphOut, ("NULL GlyphOut Funtion Ptr\n"));

    pPDev   = pTOD->pPDev;
    pgp     = pTOD->pgp;
    dwGlyph = pTOD->cGlyphsToPrint;

    if (pTOD->pfm->pfnGlyphOut)
    {
        pTOD->pfm->pfnGlyphOut( pTOD );
        bRet = TRUE;
    }
    else
    {
        ASSERTMSG(FALSE,("NULL GlyphOut function pointer\n"));
        bRet = FALSE;
    }

    return bRet;
}


BOOL
BWhiteText(
    TO_DATA  *pTOD
    )
/*++
Routine Description:
    Called to store details of the white text.  Basically the data is
    stored away until it is time to send it to the printer.  That time
    is AFTER the graphics data has been sent.

Arguments:
    pTOD    Textout Data. Holds all necessary information.

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{
    WHITETEXT *pWT, *pWTLast;
    FONTCTL    FontCtl;
    FONTPDEV*  pFontPDev;
    DWORD      dwWhiteTextAlign;
    DWORD      dwIFIAlign;
    BOOL       bRet;

    pFontPDev = pTOD->pPDev->pFontPDev;           // The important stuff

    //
    // Note that we allocate a new one of these for each
    // iteration of this loop - that would be slightly wasteful
    // if we ever executed this loop more than once, but that
    // is unlikely.
    //

    pWT = NULL;
    //
    // 64 bit align.
    //
    dwWhiteTextAlign = (sizeof(WHITETEXT) + 7) / 8 * 8;
    dwIFIAlign = (pFontPDev->pIFI->cjThis + 7) / 8 * 8;

    if ( (pWT = (WHITETEXT *)MemAllocZ(dwWhiteTextAlign + dwIFIAlign + 
                                      pTOD->cGlyphsToPrint * sizeof(GLYPHPOS))))
    {
        pWT->next    = NULL;
        pWT->sCount  = (SHORT)pTOD->cGlyphsToPrint;
        pWT->iFontId = pTOD->iSubstFace?pTOD->iSubstFace:pTOD->iFace;
        pWT->pvColor = pTOD->pvColor;
        pWT->dwAttrFlags = pTOD->dwAttrFlags;
        pWT->flAccel    = pTOD->flAccel;
        pWT->rcClipRgn  = pTOD->pPDev->rcClipRgn;
        pWT->iRot    = pTOD->iRot;
        pWT->eXScale = pFontPDev->ctl.eXScale;
        pWT->eYScale = pFontPDev->ctl.eYScale;
        pWT->pIFI = (IFIMETRICS*)((PBYTE)pWT + dwWhiteTextAlign);
        CopyMemory(pWT->pIFI, pFontPDev->pIFI, pFontPDev->pIFI->cjThis);
        pWT->pgp = (GLYPHPOS *)((PBYTE)pWT->pIFI + dwIFIAlign);
        CopyMemory(pWT->pgp, pTOD->pgp, pWT->sCount * sizeof(GLYPHPOS));

        //
        // True Type Font download case
        //
        if ( (pTOD->pfo->flFontType & TRUETYPE_FONTTYPE) &&
            (pTOD->iSubstFace == 0) )
        {
            //
            // We need to copy the download glyph array.Allocate the array
            // for DLGLYPHs.
            //

            if (!(pWT->apdlGlyph = MemAllocZ( pWT->sCount * sizeof(DLGLYPH *))))
            {
                ERR(("UniFont:BWhiteText: MemAlloc for pWT->apdlGlyph failed\n"));
                goto ErrorExit;
            }
            CopyMemory( pWT->apdlGlyph, &(pTOD->apdlGlyph[pTOD->dwCurrGlyph]),
                        pWT->sCount * sizeof(DLGLYPH *) );

        }

        //
        // Put new text at the end of the list
        //
        if (!(pFontPDev->pvWhiteTextFirst))
            pFontPDev->pvWhiteTextFirst = pWT;

        if (pWTLast = (WHITETEXT *)pFontPDev->pvWhiteTextLast)
            pWTLast->next = pWT;

        pFontPDev->pvWhiteTextLast = pWT;

        bRet = TRUE;

    }
    else
    {
        ErrorExit:
        ERR(( "MemAlloc failed for white text.\n" ));
        bRet = FALSE;
    }

    return  bRet;
}


BOOL
BPSGlyphOut(
    register TO_DATA  *pTOD
    )
/*++
Routine Description:
    Places glyphs for dot matrix type printers.  These actually store
    the position and glyph data for later printing.  This is because
    dot matrix printers cannot or should not reverse line feed -
    for positioning accuracy.  Hence, play the data back when the
    bitmap is being rendered to the printer.  Output occurs in the
    following function, bDelayGlyphOut.

Arguments:
    pTOD    Textout Data. Holds all necessary information.

Return Value:
    TRUE/FALSE.  FALSE if the glyph storage fails.
Note:

    1/21/1997 -ganeshp-
        Created it.
--*/
{
    PGLYPHPOS  pgp;        // Glyph positioning info
    PSGLYPH    psg;        // Data to store away
    PFONTPDEV  pFontPDev;

    DWORD      dwGlyph;
    SHORT      sFontIndex;

    INT        iyVal;

    pFontPDev = (PFONTPDEV)pTOD->pPDev->pFontPDev;

    pgp     = pTOD->pgp;
    dwGlyph = pTOD->cGlyphsToPrint;

    /*
     *   About all that is needed is to take the parameters,  store in
     *  a PSGLYPH structure,  and call bAddPS to add this glyph to the list.
     */

    sFontIndex = pTOD->iSubstFace?pTOD->iSubstFace:pTOD->iFace;

    //
    // Scalable font support
    //
    psg.eXScale     = pFontPDev->ctl.eXScale;
    psg.eYScale     = pFontPDev->ctl.eYScale;

    while (dwGlyph--)
    {
        //
        // Transform the input X and Y from band corrdnate to page coordinate.
        //
        if (pTOD->pPDev->bBanding)
        {
            psg.ixVal = pgp->ptl.x + pTOD->pPDev->rcClipRgn.left;
            iyVal = pgp->ptl.y + pTOD->pPDev->rcClipRgn.top;
        }
        else
        {
            psg.ixVal = pgp->ptl.x;
            iyVal = pgp->ptl.y;
        }

        psg.hg          = pgp->hg;
        psg.sFontIndex  = sFontIndex;
        psg.pvColor     = pTOD->pvColor;       // Which colour
        psg.dwAttrFlags = pTOD->dwAttrFlags;
        psg.flAccel     = pTOD->flAccel;

        if ( BAddPS( ((PFONTPDEV)(pTOD->pPDev->pFontPDev))->pPSHeader,
                     &psg,
                     iyVal,
                     ((FONTMAP_DEV *)(pTOD->pfm->pSubFM))->fwdFOWinAscender) )
        {
            pgp ++;

        }
        else // Failure, So fail the call.
        {
            ERR(( "\nUniFont!BPSGlyphOut: BAddPS Failed.\n" ))
            return  FALSE;
        }

    }

    return TRUE;
}

//
// Delay and White test printing entry points
//

BOOL
BPlayWhiteText(
    PDEV  *pPDev
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/
{
    I_UNIFONTOBJ    UFObj;
    FONTPDEV        *pFontPDev;               /* Miscellaneous uses */
    WHITETEXT       *pwt;
    TO_DATA         Tod;
    GLYPHPOS        *pgp;
    RECTL           rcClipRgnOld;
    DWORD           dwGlyphCount;

    BOOL bRet = TRUE;

    //
    // Save the Clip rectangle.
    //
    rcClipRgnOld = pPDev->rcClipRgn;

    /*
     *    Loop through the linked list of these hanging off the PDEV.
     *  Mostly, of course, there will be none.
     */

    pFontPDev = pPDev->pFontPDev;
    pFontPDev->ptod = &Tod;
    ZeroMemory(&Tod, sizeof(TO_DATA));
    ZeroMemory(&UFObj, sizeof(I_UNIFONTOBJ));
    dwGlyphCount = 0;

    pPDev->ctl.dwMode |= MODE_BRUSH_RESET_COLOR;
    GSResetBrush(pPDev);

    for( pwt = pFontPDev->pvWhiteTextFirst; pwt && bRet; pwt = pwt->next )
    {
        int        iI;              /* Loop index */
        int        iRot;            /* Rotation amount */
        FONTMAP   *pfm;

        /*
         *    Not too hard - we know we are dealing with device fonts,
         *  and that this is NOT a serial printer,  although we could
         *  probably handle that too.  Hence,  all we need do is fill in
         *  a TO_DATA structure,  and loop through the glyphs we have.
         */


        if( pwt->sCount < 1 )
            continue;               /* No data, so skip it */

        Tod.pPDev = pPDev;
        Tod.flAccel = pwt->flAccel;
        Tod.dwAttrFlags = pwt->dwAttrFlags;
        pgp = Tod.pgp   = pwt->pgp;
        Tod.cGlyphsToPrint = pwt->sCount;

        if (pwt->dwAttrFlags & FONTATTR_SUBSTFONT)
        {
            Tod.iSubstFace = pwt->iFontId;
            UFObj.dwFlags |= UFOFLAG_TTSUBSTITUTED;
        }
        else
        {
            Tod.iSubstFace = 0;
            UFObj.dwFlags &= ~UFOFLAG_TTSUBSTITUTED;
        }

        Tod.pfm =
        pfm     = PfmGetIt( pPDev, pwt->iFontId );

        if (NULL == pfm)
        {
            //
            // Fatal error, PFM is not available.
            //
            continue;
        }

        //
        // The glyph positions are wrt banding rect, so set the PDEV clip region
        // to the recorded clip region.
        //
        pPDev->rcClipRgn = pwt->rcClipRgn;

        //
        // Set the download glyph array for True type downloaded fonts.
        //
        if (pwt->apdlGlyph)
        {
            Tod.apdlGlyph = pwt->apdlGlyph;
            Tod.dwCurrGlyph = 0;
        }

        /*
         *   Before switching fonts,  and ESPECIALLY before setting the
         *  font rotation,  we should move to the starting position of
         *  the string.  Then we can set the rotation and use relative
         *  moves to position the characters.
         */


        if(pPDev->pOemHookInfo)
        {
            // ulFontID
            // dwFlags
            // pIFIMetrics
            // pfnGetInfo
            // pFontObj X (set to NULL)
            // pStrObj X (set to NULL)
            // pFontPDev
            // pFontMap
            // ptGrxRes
            // pGlyph

            if (pfm->dwFontType == FMTYPE_DEVICE)
            {
                UFObj.ulFontID = ((PFONTMAP_DEV)pfm->pSubFM)->dwResID;
            }
            else
            {
                UFObj.dwFlags = UFOFLAG_TTFONT;
                UFObj.ulFontID = pfm->ulDLIndex;
            }

            if (Tod.cGlyphsToPrint)
            {
                if (UFObj.pGlyph != NULL && dwGlyphCount < Tod.cGlyphsToPrint)
                {
                    MemFree(UFObj.pGlyph);
                    UFObj.pGlyph = NULL;
                    dwGlyphCount = 0;
                }

                if (UFObj.pGlyph == NULL)
                {
                    UFObj.pGlyph  = MemAlloc(sizeof(DWORD) * Tod.cGlyphsToPrint);
                    dwGlyphCount = Tod.cGlyphsToPrint;
                }
            }

            if (pwt->dwAttrFlags & FONTATTR_SUBSTFONT)
            {
                //
                // In the substitution case, UNIDRV needs to pass TrueType font
                // IFIMETRICS to minidriver.
                //
                UFObj.pIFIMetrics = pwt->pIFI;
            }
            else
            {
                UFObj.pIFIMetrics = pfm->pIFIMet;
            }

            UFObj.pfnGetInfo  = UNIFONTOBJ_GetInfo;
            UFObj.pPDev       = pPDev;
            UFObj.pFontMap    = pfm;
            UFObj.ptGrxRes    = pPDev->ptGrxRes;
            if (pwt->apdlGlyph)
            {
                UFObj.apdlGlyph       = Tod.apdlGlyph;
                UFObj.dwNumInGlyphTbl = pwt->sCount;
            }
            else
            {
                UFObj.apdlGlyph       = NULL;
                UFObj.dwNumInGlyphTbl = 0;
            }

            pFontPDev->pUFObj = &UFObj;
        }
        else
            pFontPDev->pUFObj = NULL;

        //
        // If this is a new font, it's time to change it now.
        // BNewFont() checkes to see if a new font is needed.
        //
        pFontPDev->ctl.eXScale = pwt->eXScale;
        pFontPDev->ctl.eYScale = pwt->eYScale;

        BNewFont(pPDev, pwt->iFontId, pfm, pwt->dwAttrFlags);
        VSetRotation( pFontPDev, pwt->iRot );

        /*  Also set the colour - ignored if already set or irrelevant */
        SelectTextColor( pPDev, pwt->pvColor );
        ASSERTMSG(pfm->pfnGlyphOut, ("NULL GlyphOut Funtion Ptr\n"));
        if( !pfm->pfnGlyphOut( &Tod))
        {
            bRet = FALSE;
            break;
        }

        VSetRotation( pFontPDev, 0 );          /* For MoveTo calls */
        //
        // Reset TODFL_FIRST_GLYPH_POS_SET so that the cursor is set next time.
        //
        Tod.flFlags &= ~TODFL_FIRST_GLYPH_POS_SET;
    }

    VSetRotation( pFontPDev, 0 );        /* Back to normal */

    //
    // Cleanup everything.
    //

    {
        WHITETEXT  *pwt0,  *pwt1;

        for( pwt0 = pFontPDev->pvWhiteTextFirst; pwt0; pwt0 = pwt1 )
        {
            pwt1 = pwt0->next;

            //Free the download glyph array.
            if (pwt0->apdlGlyph)
                MemFree( pwt0->apdlGlyph );
            MemFree( pwt0 );
        }

        pFontPDev->pvWhiteTextFirst =
        pFontPDev->pvWhiteTextLast  = NULL;

        VUFObjFree(pFontPDev);
    }

    //
    // Restore the Clip rectangle.
    //
    pPDev->rcClipRgn = rcClipRgnOld;

    return  TRUE;
}

BOOL
BDelayGlyphOut(
    PDEV  *pPDev,
    INT    yPos
    )
/*++
Routine Description:
    Called during output to a dot matrix printer.  We are passed the
    PSGLYPH data stored above,  and go about placing the characters
    on the line.


Arguments:
    pPDev   Pointer to PDEV
    yPos    Y coordinate of interest

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/
{
    BOOL      bRet;             /* Return value */
    PSHEAD   *pPSH;             /* Base data for glyph info */
    PSGLYPH  *ppsg;             /* Details of the GLYPH to print */
    FONTMAP  *pFM;              /* Base address of FONTMAP array */
    FONTPDEV *pFontPDev;          /* FM's PDEV - for our convenience */
    I_UNIFONTOBJ UFObj;
    TO_DATA   Tod;
    GLYPHPOS  gp;

    ASSERT(pPDev);

    /*
     *    Check to see if there are any glyphs for this Y position.  If so,
     *  loop through each glyph,  calling the appropriate output function
     *  as we go.
     */

    pFontPDev = PFDV;               /* UNIDRV data */
    pFontPDev->ptod = &Tod;
    pPSH = pFontPDev->pPSHeader;
    bRet = TRUE;                /* Until proven otherwise */

    /* No Glyph Queue, so return. Check if there are device fonts? */
    if(pPDev->iFonts && !pPSH)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    Tod.pPDev          = pPDev;
    Tod.pgp            = &gp;
    Tod.iSubstFace     = 0;
    Tod.cGlyphsToPrint = 1;

    //
    // Check if a minidriver supports OEM plugin.
    //
    if(pPDev->pOemHookInfo)
    {
        ZeroMemory(&UFObj, sizeof(I_UNIFONTOBJ));
        UFObj.pfnGetInfo  = UNIFONTOBJ_GetInfo;
        UFObj.pPDev       = pPDev;
        UFObj.dwFlags     = 0;
        UFObj.ptGrxRes    = pPDev->ptGrxRes;
        UFObj.pGlyph      = MemAlloc(sizeof(DWORD) * Tod.cGlyphsToPrint);
        UFObj.apdlGlyph   = NULL;
        UFObj.dwNumInGlyphTbl = 0;
        pFontPDev->pUFObj = &UFObj;
    }
    else
        pFontPDev->pUFObj = NULL;


    //
    // Actual print out
    //
    if( pPSH && ISelYValPS( pPSH, yPos ) > 0 )
    {
        /*
         *    Got some,  so first set the Y position,  so that the glyphs
         *  will appear on the correct line!
         */

        gp.ptl.y = yPos - pPDev->rcClipRgn.top;

        //
        // Reset Brush, since Raster Module might send color selection
        // commnd.Set MODE_BRUSH_RESET_COLOR flag so that  the brush
        // color selection command is sent. This will change the current
        // brush color to be default brush color. We need to reset the
        // brush color as on some printers sending a color plane of
        // raster date cahnges the brush color also.
        //
        pPDev->ctl.dwMode |= MODE_BRUSH_RESET_COLOR;
        GSResetBrush(pPDev);

        while( bRet && (ppsg = PSGGetNextPSG( pPSH )) )
        {
            /*
             *   Check for the correct font!  Since the glyphs are now
             *  in an indeterminate order,  we need to check EACH one for
             *  the font,  since each one can be different, as we have
             *  no idea of how the glyphs arrived in this order.
             */

            if (pFM = PfmGetIt( pPDev, ppsg->sFontIndex))
            {
                //
                // Error check.
                // BDelayGlyphOut can only handle printer device fonts.
                //
                if (pFM->dwFontType != FMTYPE_DEVICE)
                {
                    bRet = FALSE;
                    break;
                }

                Tod.flAccel = ppsg->flAccel;
                Tod.dwAttrFlags = ppsg->dwAttrFlags;
                Tod.iFace = ppsg->sFontIndex;

                pFontPDev->ctl.eXScale = ppsg->eXScale;
                pFontPDev->ctl.eYScale = ppsg->eYScale;

                UFObj.pFontMap = Tod.pfm = pFM;
                UFObj.pIFIMetrics = pFM->pIFIMet;

                //
                // Reselect new font
                //
                BNewFont(pPDev, ppsg->sFontIndex, pFM, ppsg->dwAttrFlags);
                SelectTextColor( pPDev, ppsg->pvColor );

                ASSERTMSG(pFM->pfnGlyphOut, ("NULL GlyphOut Funtion Ptr\n"));

                gp.hg    = (HGLYPH)(ppsg->hg);
                gp.ptl.x = ppsg->ixVal - pPDev->rcClipRgn.left;

                //
                // Send character string
                //
                bRet = pFM->pfnGlyphOut(&Tod);
            }
            else
                bRet = FALSE;
        }
    }

    VUFObjFree(pFontPDev);
    return  bRet;
}

//
// Mics. functions
//

VOID
SelectTextColor(
    PDEV      *pPDev,
    PVOID     pvColor
    )
/*++
Routine Description:
    Select a text color.

Arguments:

    pPDev   Pointer to PDEV
    color   Color of the Text.

Return Value:

    Nothing.

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{

    //Select the Brush and then unrealize it.
    if (!GSSelectBrush( pPDev, pvColor))
    {
        ERR(( "GSSelectBrush Failed;Can't Select the Color\n" ));

    }

    return;

}


BCheckForDefaultPlacement(
    GLYPHPOS  *pgp,
    SHORT     sWidth,
    INT       *piTolalError
    )
/*++
Routine Description:

Arguments:
    pgp             Current Glyph
    sWidth          Width of the previous glyph.
    piTolalError    Comulative Error

Return Value:
    TRUE if the current glyph is at default placement else FALSE.

Note:

    11/11/1997 -ganeshp-
        Created it.
--*/
{
    GLYPHPOS    *pgpPrevious;
    INT         iError;

    pgpPrevious = pgp -1;

    iError = (pgpPrevious->ptl.x + sWidth) - pgp->ptl.x;
    *piTolalError += iError;

    //DbgPrint("\nTODEL!BCheckForDefaultPlacement:pgpPrevious->ptl.x = %d, Previous Glyph sWidth = %d,\n\t\tCurrpgp->ptl.x = %d, iError = %d, *piTolalError = %d\n",
    //pgpPrevious->ptl.x, sWidth, pgp->ptl.x, iError, *piTolalError );

    if ( (abs(iError) <= ERROR_PER_GLYPH_POS) /*&& (*piTolalError <= ERROR_PER_ENUMERATION)*/ )
    {
        //DbgPrint("TODEL!BCheckForDefaultPlacement: The Glyph is at Default Placement.\n");
        return TRUE;

    }
    else
    {
        //DbgPrint("TODEL!BCheckForDefaultPlacement: Non Default Placement Glyph Found.\n");
        //DbgPrint("\nTODEL!BCheckForDefaultPlacement:pgpPrevious->ptl.x = %d, Previous Glyph sWidth = %d,\n\t\tCurrpgp->ptl.x = %d, iError = %d, *piTolalError = %d\n",
        //pgpPrevious->ptl.x, sWidth, pgp->ptl.x, iError, *piTolalError );
        return FALSE;
    }

}


VOID
VClipIt(
    BYTE     *pbClipBits,
    TO_DATA  *ptod,
    CLIPOBJ  *pco,
    STROBJ   *pstro,
    int      cGlyphs,
    int      iRot,
    BOOL     bPartialClipOn
    )
/*++
Routine Description:
    Applies clipping to the glyphos array passed in,  and sets bits in
    bClipBits to signify that the corresponding glyph should be printed.
    NOTE:   the clipping algorithm is that the glyph is displayed if
    the top, left corner of the character cell is within the clipping
    region.  This is the formula of Win 3.1, so it is important for
    us to follow it.


Arguments:
    pbClipBits      Output data is placed here
    ptod            Much information
    cGlyphs         Number of glyphs in following array
    iRot            90 degree rotation amount (0-3)

Return Value:
    Nothing

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{


    int       iIndex;             /* Classic loop variable!  */
    ULONG     iClipIndex;         /* For clipping rectangle */
    int       iYTop;              /* Font's ascender, scaled if relevant */
    int       iYBot;              /* Descender, scaled if required */
    BYTE      bVal;               /* Determine how to set the bits */
    FONTMAP  *pFM;                /* Speedier access to data */
    FONTPDEV  *pFontPDev;           /* Ditto */
    GLYPHPOS *pgp;                /* Ditto */
    short    *asWidth;


    /*
     *  Behaviour depends upon the complexity of the clipping region.
     *  If it is non-existent (I doubt that this happens,  but play it safe)
     *  or of complexity DC_TRIVIAL,  then set all the relevant bits and
     *  return.
     *  If DC_RECT is set,  the CLIPOBJ contains the clipping rectangle,
     *  so clip using that information.
     *  Otherwise,  it is DC_COMPLEX,  and so we need to enumerate clipping
     *  rectangles.
     *  If we do not need to do anything,  then set the bits and return.
     *  Otherwise,  we have either of the two cases requiring evaluation.
     *  For those we want to set the bits to 0 and set the 1 bits as needed.
     *
     *  Disable clipping for PCL-XL.
     */

    if( pco &&
        (pco->iDComplexity == DC_RECT || pco->iDComplexity == DC_COMPLEX) &&
        !(ptod->pPDev->ePersonality == kPCLXL))
        bVal = 0;               /*  Requires us to evaluate it */
    else
        bVal = 0xff;            /*  Do it all */

    FillMemory( pbClipBits, (cGlyphs + BBITS - 1) / BBITS, bVal );

    if( bVal == 0xff )
        return;                 /* All done */

    if (!(asWidth = MemAlloc(cGlyphs * sizeof(short))))
    {
        return;
    }

    pFM = ptod->pfm;
    pFontPDev = ptod->pPDev->pFontPDev;

    /*
     *    We now calculate the widths of the glpyhs.  We need these to
     *  correctly clip the data.  However,  calculating widths can be
     *  expensive,  and since we need the data later on,  we save
     *  the values in the width array that ptod points to.  This can
     *  then be used in the bottom level function, rather than calculating
     *  the width again.
     */

    pgp = ptod->pgp;

    //
    // pgp may be NULL causing problems below. So don't clip, just return.
    //

    if (pgp == NULL)
    {
        if (asWidth)
        {
            MemFree(asWidth);
        }
        ASSERTMSG((FALSE),("\nCan't Clip the text.Null pgp in VClipIt. \n"));
        return;
    }

    if (!(ptod->pfo->flFontType & TRUETYPE_FONTTYPE))
    {
        /*   The normal case - a standard device font */

        int   iWide;                     /* Calculate the width */

        for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
        {

            iWide = IGetGlyphWidth( ptod->pPDev, pFM, pgp->hg);

            if( pFM->flFlags & FM_SCALABLE )
            {
                /*   Need to transform the value to current size */
                iWide = LMulFloatLong(&pFontPDev->ctl.eXScale,iWide);
            }

            asWidth[ iIndex ] = iWide - 1;       /* Will be used later */
        }


    }
    else  //GDI Font
    {

        GLYPHDATA *pgd;

        /*
         *    SPECIAL CASE:  DOWNLOADED GDI font.  The width is
         *  obtained by calling back to GDI to get the data on it.
         */

        for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
        {
            pgd = NULL;

            if( !FONTOBJ_cGetGlyphs( ptod->pfo, FO_GLYPHBITS, (ULONG)1,
                                                   &pgp->hg, &pgd ) )
            {
                if (asWidth)
                {
                   MemFree(asWidth);
                }

                ERR(( "FONTOBJ_cGetGlyphs fails\n" ))
                return;
            }

            /*
             *   Note about rotations:  we do NOT download rotated fonts,
             *  so the following piece of code is quite correct.
             */

            if (pgd)
            {
                asWidth[ iIndex ] = (short)(pgd->ptqD.x.HighPart + 15) / 16 - 1;

            }
            else
            {
                ASSERTMSG(FALSE,("UniFont!VClipIt:GLYPHDATA pointer is NULL\n"));
                if (asWidth)
                {
                   MemFree(asWidth);
                }

                return;

            }


        }
    }

    /*
     * We also want the Ascender and Descender fields, as these are
     * used to check the Y component. While calculationg these values we have
     * to do special case for Font substitution. In font substitution case
     * True Type font's IFIMERTICS should be used rather than substituted
     * device font's IFIMETRICS.
     */

    //
    // Initialize itTop and iyBot to fontmap values. Then based on what font we
    // are using these values will change.
    //

    iYTop = (INT)((IFIMETRICS *)(pFM->pIFIMet))->fwdWinAscender;
    iYBot = (INT)((IFIMETRICS *)(pFM->pIFIMet))->fwdWinDescender;

    if (ptod->pfo->flFontType & TRUETYPE_FONTTYPE)
    {
        //
        // True Type Font case. Get the values from FONTOBJ ifimetrics.
        //

        ASSERTMSG((pFontPDev->pIFI),("NULL pFontPDev->pIFI, TT Font IFIMETRICS\n"));

        if (pFontPDev->pIFI)
        {
            iYTop = (INT)((IFIMETRICS *)(pFontPDev->pIFI))->fwdWinAscender;
            iYBot = (INT)((IFIMETRICS *)(pFontPDev->pIFI))->fwdWinDescender;

        }
        //
        // We always need to do the sacling as TT font metrics values
        // are in notional space.
        //
        iYTop = LMulFloatLong(&pFontPDev->ctl.eYScale,iYTop);
        iYBot = LMulFloatLong(&pFontPDev->ctl.eYScale,iYBot);


    }
    else
    {
        //
        // Device Font  case. We just need to scale for scalable fonts.
        //

        if( pFM->flFlags & FM_SCALABLE )
        {
            iYTop = LMulFloatLong(&pFontPDev->ctl.eYScale,iYTop);
            iYBot = LMulFloatLong(&pFontPDev->ctl.eYScale,iYBot);
        }
    }



    /*
     *    Down here means we are serious!  Need to determine which (if any)
     *  glyphs are within the clip region.
     */

    pgp = ptod->pgp;

    if( pco->iDComplexity == DC_RECT )
    {
        /*   The simpler case - one clipping rectangle.  */
        RECTL   rclClip;
        LONG    lFirstGlyphX;

        /* Local access -> speedier access */
        rclClip = pco->rclBounds;
        lFirstGlyphX = 0;

        /*
         *    Nothing especially exciting.  The clipping is checked for
         *  each particular type of rotation,  as this is probably faster
         *  than having the loop go through the switch statement.  The
         *  selection criteria are that all the character must be within
         *  the clip region in the X direction,  while any part of it must
         *  be within the clip region in the Y direction.  Then we print.
         *  Failing either means it is clipped out.
         *
         *    NOTE that we fiddle with the clipping rectangle coordinates
         *  before the loop,  as this saves some computation within the loop.
         */

        switch( iRot )
        {
        case  0:                 /*  Normal direction */
            //
            // Save the x position to restore after clipping calculation.
            //
            lFirstGlyphX = pgp->ptl.x;

            // Check the First Glyph position. If it's just OFF by one or two
            // pixels, print it.
            if ( (pgp->ptl.x != rclClip.left) &&
                (abs(pgp->ptl.x - rclClip.left) <= 2) )
            {
                pgp->ptl.x = rclClip.left;
            }

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
#ifndef OLDWAY
                //
                // We want to draw the character in the first band
                // in which a portion of it appears. This means that
                // if the character starts in the current band we will
                // draw it. We also draw the character if it starts before
                // the first band but some of it exists within the band.
                // The x and y points are relative to the lower left of the
                // character cell so we calculate a upper left value for
                // our testing purposes.
                //
                INT     iyTopLeft;
                INT     iyBottomLeft, ixRight;

                iyTopLeft    = pgp->ptl.y - iYTop;
                iyBottomLeft = pgp->ptl.y + iYBot;
                ixRight      = pgp->ptl.x + asWidth[ iIndex ];


                if ((ptod->pfo->flFontType & TRUETYPE_FONTTYPE) &&
                    (ptod->flFlags & TODFL_FIRST_ENUMRATION)    &&
                    bPartialClipOn)
                {
                    BOOL    bGlyphVisible; // Set if glyph is totally visible.
                    BOOL    bLeftVisible, bRightVisible,
                            bTopVisible, bBottomVisible;
                    INT     iError, iYdpi;

                    //
                    // Fix iyTopLeft to be maximum of STROBJ background rectangle's
                    // top and current calculated value of the top using asender of
                    // the font.This is needed because we want to clip using
                    // smallest bounding rectangle for the glyph. We also need to
                    // fix iyBottomLeft to be smaller of current value and STROBJ
                    // background rectangle's bottom.
                    //

                    iyTopLeft     = max(iyTopLeft, pstro->rclBkGround.top);
                    iyBottomLeft  = min(iyBottomLeft, pstro->rclBkGround.bottom);

                    //
                    // If the glyph rectangle's top or bottom is outside the
                    // clipping rectangle, we may need adjust the glyph
                    // rectangle. This is needed as the glyph rectangle's top and
                    // bottom is calculated using ascender and decender. This
                    // gives us a bigger rectangle height(worst case) than needed.
                    // Adjust the rectangle height by the Error factor. The
                    // error factor value is based upon the graphics dpi. For a
                    // 600 or 300 dpi printer it's set to 5 pixels and will
                    // scale based upon the graphics resolution.This number
                    // makes the glyph bounding rectangle small enough to catch
                    // the normal non partial clipping case and still catches
                    // the partial clipping of the glyphs.This adjustment should
                    // be done only if error factor is smaller than ascender or
                    // decender. Finally we must check if ptl.y is between
                    // topleft and bottomleft.
                    //

                    if ( (iyTopLeft < rclClip.top) ||
                         (iyBottomLeft > rclClip.bottom) )
                    {
                        iYdpi = ptod->pPDev->ptGrxRes.y;
                        if (iYdpi == 300)
                            iYdpi = 600;
                        iError = (EROOR_PER_GLYPHRECT * iYdpi) / 600;

                        if (iYTop > iError)
                            iyTopLeft += iError;

                        if (iYBot > iError)
                            iyBottomLeft  -= iError;

                    }

                    if (iyTopLeft > pgp->ptl.y)
                        iyTopLeft = pgp->ptl.y;

                    if (iyBottomLeft < pgp->ptl.y)
                        iyBottomLeft = pgp->ptl.y;

                    //
                    // Now test for partial clipping. If the charecter is
                    // partially clippeed and the font is truetype, then we need
                    // to call EngTextOut.
                    //
                    // We can only call EngTextOut if we are clipping the first
                    // enumaration of the glyphs. EngTextOut doesn't support
                    // partial glyph printing.
                    //

                    //
                    // Glyph is fully visible if all the four corners of the
                    // glyph rectangle are visible.
                    //


                    bLeftVisible = (pgp->ptl.x >= rclClip.left);
                    bRightVisible = (ixRight <= rclClip.right);
                    bTopVisible    = (iyTopLeft >= rclClip.top);
                    bBottomVisible = (iyBottomLeft <= rclClip.bottom);


                    bGlyphVisible = ( bLeftVisible && bRightVisible &&
                                      bTopVisible && bBottomVisible );


                    if (!bGlyphVisible)
                    {

                        ptod->flFlags |= TODFL_TTF_PARTIAL_CLIPPING;

                        //
                        // No need to test rest of the glyphs for clipping.
                        //
                        break;
                    }

                }
                else
                {

                    if ( (iyTopLeft < rclClip.top) ||
                         (iyBottomLeft > rclClip.bottom) )
                    {
                        INT iError;
                        INT iYdpi = ptod->pPDev->ptGrxRes.y;
                        if (iYdpi <= 600)
                            iYdpi = 600;
                        iError = (EROOR_PER_GLYPHRECT * iYdpi) / 600;

                        if (iYTop > iError)
                            iyTopLeft += iError;

                        if (iYBot > iError)
                            iyBottomLeft  -= iError;

                    }
                }

                if( pgp->ptl.x >= rclClip.left &&
                    pgp->ptl.x <= rclClip.right &&
                    iyTopLeft <= rclClip.bottom &&
                    (iyTopLeft >= rclClip.top ||
                     (pgp->ptl.y >= rclClip.top &&
                      ptod->pPDev->rcClipRgn.top == 0)))
#else
                if( pgp->ptl.x >= rclClip.left &&
                    pgp->ptl.x <= rclClip.right &&
                    pgp->ptl.y <= rclClip.bottom &&
                    pgp->ptl.y >= rclClip.top )
#endif
                {


                    /*   Got it!  So set the bit to print it  */

                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);

                }

                //
                // Restore the position of the first glyph. It may have been
                // changed.
                //
                if ( iIndex == 0 )
                    pgp->ptl.x = lFirstGlyphX;
            }

            break;

        case  1:                /* 90 degrees counter clockwise */

            rclClip.left += iYTop;
            rclClip.right -= iYBot;

            /* Check the First Glyph. If it's just OFF by One, print it.*/
            if (abs(pgp->ptl.y - rclClip.bottom) == 1)
                pgp->ptl.y = rclClip.bottom;

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
                if( (pgp->ptl.y <= rclClip.bottom)                    &&
                    ((pgp->ptl.y - asWidth[ iIndex ]) >= rclClip.top) &&
                    (pgp->ptl.x >= rclClip.left)                      &&
                    (pgp->ptl.x <= rclClip.right) )
                {
                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);
                }
            }

            break;

        case  2:                /* 180 degrees, CCW (aka right to left) */

            rclClip.bottom += iYBot;
            rclClip.top -= iYTop;

            /* Check the First Glyph. If it's just OFF by One, print it.*/
            if (abs(pgp->ptl.x - rclClip.right) == 1)
                pgp->ptl.x = rclClip.right;

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
                if( pgp->ptl.x <= rclClip.right &&
                    (pgp->ptl.x - asWidth[ iIndex ]) >= rclClip.left &&
                    pgp->ptl.y <= rclClip.bottom &&
                    pgp->ptl.y >= rclClip.top )
                {
                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);
                }
            }

            break;

        case 3:                 /* 270 degrees CCW */

            rclClip.right += iYBot;
            rclClip.left -= iYTop;

            /* Check the First Glyph. If it's just OFF by One, print it.*/
            if (abs(pgp->ptl.y - rclClip.top) == 1)
                pgp->ptl.y = rclClip.top;

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
                if( pgp->ptl.y >= rclClip.top &&
                    (pgp->ptl.y + asWidth[ iIndex ]) <= rclClip.bottom &&
                    pgp->ptl.x <= rclClip.right &&
                    pgp->ptl.x >= rclClip.left )
                {
                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);
                }
            }

            break;
        }


    }
    else // Complex Clipping.
    {
        //
        // For True type font call engine to draw the text.
        //
        if ( (ptod->pfo->flFontType & TRUETYPE_FONTTYPE) && bPartialClipOn)
        {

            ptod->flFlags |= TODFL_TTF_PARTIAL_CLIPPING;

        }
        else  // Device font case. We have to clip anyway.
        {
            /*  enumerate the rectangles and see  */

            int        cGLeft;
            BOOL       bMore;
            MY_ENUMRECTS  erClip;

            /*
             *    Let the engine know how we want this handled.  All we want
             *  to set is the use of rectangles rather than trapezoids for
             *  the clipping info.  Direction of enumeration is of no great
             *  interest,  and I don't care how many rectangles are involved.
             *  I also see no reason to enumerate the whole region.
             */

            CLIPOBJ_cEnumStart( pco, FALSE, CT_RECTANGLES, CD_ANY, 0 );

            cGLeft = cGlyphs;

            do
            {
                bMore = CLIPOBJ_bEnum( pco, sizeof( erClip ), &erClip.c );

                for( iIndex = 0; iIndex < cGlyphs; ++iIndex )
                {
                    RECTL   rclGlyph;

                    if( pbClipBits[ iIndex >> 3 ] & (1 << (iIndex & 0x7)) )
                        continue;           /*  Already done!  */

                    /*
                     *   Compute the RECTL describing this char, then see
                     *  how this maps to the clipping data.
                     */

                    switch( iRot )
                    {
                    case  0:
                        rclGlyph.left = (pgp + iIndex)->ptl.x;
                        rclGlyph.right = rclGlyph.left + asWidth[ iIndex ];
                        rclGlyph.top = (pgp + iIndex)->ptl.y - iYTop;
                        rclGlyph.bottom = rclGlyph.top + iYTop + iYBot;

                        break;

                    case  1:
                        rclGlyph.left = (pgp + iIndex)->ptl.x - iYTop;
                        rclGlyph.right = rclGlyph.left + iYTop + iYBot;
                        rclGlyph.bottom = (pgp + iIndex)->ptl.y;
                        rclGlyph.top = rclGlyph.bottom - asWidth[ iIndex ];

                        break;

                    case  2:
                        rclGlyph.right = (pgp + iIndex)->ptl.x;
                        rclGlyph.left = rclGlyph.right - asWidth[ iIndex ];
                        rclGlyph.bottom = (pgp + iIndex)->ptl.y + iYTop;
                        rclGlyph.top = rclGlyph.bottom - iYTop - iYBot;

                        break;

                    case  3:
                        rclGlyph.left = (pgp + iIndex)->ptl.x - iYBot;
                        rclGlyph.right = rclGlyph.left + iYTop + iYBot;
                        rclGlyph.top = (pgp + iIndex)->ptl.y;
                        rclGlyph.bottom = rclGlyph.top + asWidth[ iIndex ];

                        break;

                    }


                    /*
                     *    Define the char as being printed if any part of it
                     *  is visible in the Y direction,  and all of it in the X
                     *  direction.  This is not really what we want for
                     *  rotated text,  but it is hard to do it correctly,
                     *  and of dubious benefit.
                     */

                    for( iClipIndex = 0; iClipIndex < erClip.c; ++iClipIndex )
                    {
                        if( rclGlyph.right <= erClip.arcl[ iClipIndex ].right  &&
                            rclGlyph.left >= erClip.arcl[ iClipIndex ].right &&
                            rclGlyph.bottom >= erClip.arcl[ iClipIndex ].top &&
                            rclGlyph.top <= erClip.arcl[ iClipIndex ].bottom )
                        {
                            /*
                             *   Got one,  so set the bit to print,  and also
                             *  decrement the count of those remaining.
                             */

                            pbClipBits[ iIndex >> 3 ] |= (1 << (iIndex & 0x7));
                            --cGLeft;

                            break;
                        }
                    }
                }

            }  while( bMore && cGLeft > 0 );

        }
    }

    if (asWidth)
    {
       MemFree(asWidth);
    }

    return;

}

VOID
VCopyAlign(
    BYTE  *pjDest,
    BYTE  *pjSrc,
    int    cx,
    int    cy
    )
/*++
Routine Description:
   Copy the source area to the destination area,  aligning the scan lines
   as they are processed.

Arguments:
    pjDest      Output area,  DWORD aligned
    pjSrc       Input area,   BYTE aligned
    cx          Number of pixels per scan line
    cy          Number of scan lines

Return Value:
    Nothing.

Note:

    1/22/1997 -ganeshp-
        Created it.
--*/

{
    /*
     *    Basically a trivial function.
     */


    int    iX,  iY;                 /* For looping through the bytes */
    int    cjFill;                  /* Extra bytes per output scan line */
    int    cjWidth;                 /* Number of bytes per input scan line */



    cjWidth = (cx + BBITS - 1) / BBITS;       /* Input scan line bytes */
    cjFill = ((cjWidth + 3) & ~0x3) - cjWidth;


    for( iY = 0; iY < cy; ++iY )
    {
        /*   Copy the scan line bytes, then fill in the trailing bits */
        for( iX = 0; iX < cjWidth; ++iX )
        {
            *pjDest++ = *pjSrc++;
        }

        pjDest += cjFill;             /* Output alignment */
    }

    return;
}


INT
ISubstituteFace(
    PDEV    *pPDev,
    FONTOBJ *pfo)
/*++
Routine Description:

    Return a device font id to substitute TrueType font with.

Arguments:

    pPDev   a pointer to PDEV
    pfo     a pointer to FONTOBJ

Return Value:

    font id

Note:

--*/
{
    PTTFONTSUBTABLE pTTFontSubDefault;
    PIFIMETRICS     pIFITT;
    FONTPDEV       *pFontPDev;
    PFONTMAP        pfm;
    WCHAR           awstrFaceName[256];

    PWSTR pwstrTTFaceName, pwstrTTFaceNameRes, pwstrDevFont, pwstrIFIFace;
    DWORD dwCountOfTTSubTable, dwSize;
    PBYTE pubResourceData;
    BOOL  bFound, bNonsquare;
    INT   iFace, iFaceSim, iI, iCountOfTTSubTable;

    iFace     = 0;
    iFaceSim  = 0;
    pFontPDev = pPDev->pFontPDev;

    //
    // if dwTTOption is DMTT_DOWNLOAD or DMTT_GRAPHICS,
    // UNIDRV doesn't substitute TrueType font.
    //
    if  (pPDev->pdm->dmTTOption != DMTT_SUBDEV)
    {
        //VERBOSE(( "ISubstituteFace: Don't substitute.\n"));
        return 0;
    }

    //
    // If TrueType font is scaled X and Y differently (non-square font),
    // we should not download.
    // Since current UNIDRV can't scale device font x and y independently.
    //

    bNonsquare = NONSQUARE_FONT(pFontPDev->pxform);
    if (bNonsquare && !(pFontPDev->flText & TC_SF_X_YINDEP))
    {
        //VERBOSE(( "ISubstituteFace: Don't substitute non-square TrueType font.\n"));
        return 0;
    }

    //
    // Get TrueType font's facename from IFIMETRICS structure.
    //

    if (!(pIFITT = pFontPDev->pIFI))
    {
        ERR(( "ISubstituteFace: Invalid pFontPDev->pIFI\n"));
        return 0;
    }

    //
    // Get TrueType font face name.
    // In substitution table, there are a list of T2 face name and Device
    // font face name.
    //

    pwstrTTFaceName = (PWSTR)((BYTE *) pIFITT + pIFITT->dpwszFamilyName);

    pTTFontSubDefault = NULL;

    if (!pFontPDev->pTTFontSubReg)
    {
        //
        // Use a default font substitution table, if there no info in registry.
        //

        bFound      = FALSE;

        pubResourceData   = pPDev->pDriverInfo->pubResourceData;
        pTTFontSubDefault  = GETTTFONTSUBTABLE(pPDev->pDriverInfo);
        iCountOfTTSubTable = (INT)pPDev->pDriverInfo->DataType[DT_FONTSUBST].dwCount;

        for (iI = 0; iI < iCountOfTTSubTable; iI++, pTTFontSubDefault++)
        {
            if (!pTTFontSubDefault->arTTFontName.dwCount)
            {
                dwSize = ILoadStringW(&pPDev->WinResData, pTTFontSubDefault->dwRcTTFontNameID, awstrFaceName, 256);
                pwstrTTFaceNameRes = awstrFaceName;
            }
            else
            {
                //
                // dwCount is supposed be the number of characters according to
                // a GPD parser.
                // However, the size is actually the size in byte.
                // We need the number of characters.
                //

                dwSize = pTTFontSubDefault->arTTFontName.dwCount/sizeof(WCHAR);
                pwstrTTFaceNameRes = (PWSTR)(pubResourceData +
                                     pTTFontSubDefault->arTTFontName.loOffset);
            }

            if (dwSize > 0 &&
                dwSize == wcslen(pwstrTTFaceName) &&
                NULL  != pwstrTTFaceNameRes)
            {
                if (!wcsncmp(pwstrTTFaceNameRes, pwstrTTFaceName, dwSize))
                {
                    bFound = TRUE;
                    break;
                }
            }

        }

        if (!bFound)
        {
            return 0;
        }

        if (pTTFontSubDefault->arDevFontName.dwCount)
        {
            pwstrDevFont = (PWSTR)(pubResourceData +
           pTTFontSubDefault->arDevFontName.loOffset);
            dwSize = pTTFontSubDefault->arDevFontName.dwCount;
        }
        else
        {
            dwSize = ILoadStringW(&pPDev->WinResData, pTTFontSubDefault->dwRcDevFontNameID, awstrFaceName, 256);
            pwstrDevFont = awstrFaceName;
        }

    }
    else
    {
        pwstrDevFont = (PWSTR)PtstrSearchTTSubstTable(pFontPDev->pTTFontSubReg,
                                                      pwstrTTFaceName);
    }

    if (!pwstrDevFont)
    {
        return 0;
    }

    //
    // Get iFace of the font name.
    //

    pfm = pFontPDev->pFontMap;

    for (iI = 1;
         iI <= pPDev->iFonts;
         iI ++, (PBYTE)pfm += SIZEOFDEVPFM() )
    {
        if( pfm->pIFIMet == NULL )
        {
            if (!BFillinDeviceFM( pPDev, pfm, iI - 1 ) )
            {
                continue;
            }
        }

        if (pfm->pIFIMet)
        {
            PIFIMETRICS pDevIFI = pfm->pIFIMet;
            BOOL        bT2Bold, bT2Italic;

            bT2Bold = (pIFITT->fsSelection & FM_SEL_BOLD) ||
                      (pfo->flFontType & FO_SIM_BOLD);
            bT2Italic = (pIFITT->fsSelection & FM_SEL_ITALIC) ||
                        (pfo->flFontType & FO_SIM_ITALIC);

            pwstrIFIFace = (WCHAR*)((BYTE *)pDevIFI + pDevIFI->dpwszFamilyName);

            //
            // (1) FaceName match.
            // (2) Character sets match.
            //      -> Set iFaceSim.
            // (3) Bold attributes match.  !(bT2Bold xor bDevBold)
            // (4) Italic attributes match. !(bT2Italic xor bDevItalic)
            //      -> Set iFace.
            //

            #if 0
            VERBOSE(( "bT2Bold=%d, bT2Italic=%d, IFIFace=%ws, DevFace=%ws\n",
                       bT2Bold, bT2Italic, pwstrIFIFace, pwstrDevFont));
            #endif
            if(!wcscmp(pwstrDevFont, pwstrIFIFace) &&
               (pIFITT->jWinCharSet == pDevIFI->jWinCharSet) &&
               ((bNonsquare && (pDevIFI->flInfo & FM_INFO_ANISOTROPIC_SCALING_ONLY)) || !bNonsquare)
              )
            {

                //
                // Substitute TrueType font with simulated device font.
                //
                if( !(((pDevIFI->fsSelection & FM_SEL_BOLD)?TRUE:FALSE) ^ bT2Bold) &&
                    !(((pDevIFI->fsSelection & FM_SEL_ITALIC)?TRUE:FALSE) ^ bT2Italic))
                {
                    //
                    // Attribute match
                    // Substitute with bold or italic face device font.
                    //
                    iFace = iI;
                    break;
                }
                else
                if (pfm->pIFIMet->dpFontSim)
                {
                    //
                    // Attribute doesn't match.
                    // Check if this device font can be simulated as bold
                    // or italic.
                    //
                    FONTSIM *pFontSim = (FONTSIM*)((PBYTE)pfm->pIFIMet +
                                        pfm->pIFIMet->dpFontSim);

                    if (! (pFontPDev->flFlags & FDV_INIT_ATTRIB_CMD))
                    {
                        pFontPDev->pCmdBoldOn = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDON);
                        pFontPDev->pCmdBoldOff = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDOFF);
                        pFontPDev->pCmdItalicOn = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICON);
                        pFontPDev->pCmdItalicOff = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICOFF);
                        pFontPDev->pCmdUnderlineOn = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEON);
                        pFontPDev->pCmdUnderlineOff = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEOFF);
                        pFontPDev->pCmdClearAllFontAttribs = COMMANDPTR(pPDev->pDriverInfo, CMD_CLEARALLFONTATTRIBS);
                        pFontPDev->flFlags |= FDV_INIT_ATTRIB_CMD;
                    }
                    if (bT2Bold && bT2Italic)
                    {
                        if( pFontSim->dpBoldItalic &&
                            pFontPDev->pCmdBoldOn  &&
                            pFontPDev->pCmdItalicOn )
                        {
                            iFaceSim = iI;
                            break;
                        }
                    }
                    else
                    if (bT2Bold)
                    {
                        if( pFontSim->dpBold &&
                            pFontPDev->pCmdBoldOn)
                        {
                            iFaceSim = iI;
                            break;
                        }
                    }
                    else
                    if (bT2Italic)
                    {
                        if (pFontSim->dpItalic &&
                            pFontPDev->pCmdItalicOn)
                        {
                            iFaceSim = iI;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (iFace)
        return iFace;
    else
        return iFaceSim;
}



PHGLYPH
PhAllCharsPrintable(
    PDEV  *pPDev,
    INT    iSubst,
    ULONG  ulGlyphs,
    PWCHAR pwchUnicode)
{
    PHGLYPH  phGlyph;
    PFONTMAP pfm;
    ULONG    ulI;
    BOOL     bRet;

    //
    // Error check
    //
    if (!pwchUnicode)
        return NULL;

    if (!(PVGetUCGlyphSetData( pPDev, iSubst)) ||
        !(pfm = PfmGetIt( pPDev, iSubst)) ||
        !(phGlyph = MemAlloc(sizeof(HGLYPH) * ulGlyphs)))
    {
        return NULL;
    }

    for (ulI = 0; ulI < ulGlyphs; ulI ++)
    {
        if (!(*(phGlyph+ulI) = HWideCharToGlyphHandle(pPDev,
                                                      pfm,
                                                      *(pwchUnicode+ulI))))
        {
            MemFree(phGlyph);
            phGlyph = NULL;
            break;
        }
    }

    return phGlyph;
}

HGLYPH
HWideCharToGlyphHandle(
    PDEV    *pPDev,
    FONTMAP *pFM,
    WCHAR    wchOrg)
/*++
Routine Description:

    Select a text color.

Arguments:

    pPDev   a pointer to PDEV
    ptod    a pointer to TO_DATA
    wchOrg  Unidrv character

Return Value:

    Glyph handle.

Note:

--*/
{
    PFONTMAP_DEV       pFMDev;
    HGLYPH             hRet;
    DWORD              dwI;
    BOOL               bFound;

    if (wchOrg < pFM->wFirstChar || pFM->wLastChar < wchOrg)
    {
        return (HGLYPH)0;
    }

    hRet   = 1;
    pFMDev = pFM->pSubFM;
    bFound = FALSE;

    if (pFM->flFlags & FM_GLYVER40)
    {
        WCRUN *pWCRuns;
        DWORD dwCRuns;

        if (!pFMDev->pUCTree)
            return (HGLYPH)0;

        dwCRuns = ((FD_GLYPHSET*)pFMDev->pUCTree)->cRuns;
        pWCRuns = ((FD_GLYPHSET*)pFMDev->pUCTree)->awcrun;

        for (dwI = 0; dwI < dwCRuns; dwI ++, pWCRuns ++)
        {
            if (pWCRuns->wcLow <= wchOrg                    &&
                wchOrg < pWCRuns->wcLow + pWCRuns->cGlyphs  )
            {
                hRet = *(pWCRuns->phg + (wchOrg - pWCRuns->wcLow));
                bFound = TRUE;
                break;
            }
        }

    }
    else
    {
        PUNI_GLYPHSETDATA  pGlyphSetData;
        PGLYPHRUN          pGlyphRun;

        if (pFMDev && pFMDev->pvNTGlyph)
        {
            pGlyphSetData = (PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph;
            pGlyphRun  = GET_GLYPHRUN(pFMDev->pvNTGlyph);
        }
        else
        {
            return (HGLYPH)0;
        }

        for (dwI = 0; dwI < pGlyphSetData->dwRunCount; dwI ++, pGlyphRun ++)
        {
            if (pGlyphRun->wcLow <= wchOrg                        &&
                wchOrg < pGlyphRun->wcLow + pGlyphRun->wGlyphCount )
            {
                hRet += wchOrg - pGlyphRun->wcLow;
                bFound = TRUE;
                break;
            }

            hRet += pGlyphRun->wGlyphCount;
        }
    }

    if (bFound)
    {
        return hRet;
    }
    else
    {
        return (HGLYPH)0;
    }
}

BOOL
BGetStartGlyphandCount(
    BYTE  *pbClipBits,
    DWORD dwEndIndex,
    DWORD *pdwStartIndex,
    DWORD *pdwGlyphToPrint)
/*++
Routine Description:

    Select a text color.

Arguments:

    pbClipBits  bit flags for character clipping
    dwTotalGlyph a total count of glyph
    pdwStartIndex a pointer to the index of starting glyph
    pdwGlyphtoPrint a pointer to the the number of glyphs to print

Return Value:

    True if there is any character to print. Otherwise False.

Note:

    Caller passes the number of characters to print in pdwGlyphCount.
    And the ID of the first character to print.

--*/
{
    DWORD  dwI;
    BOOL bRet;

    dwI = *pdwStartIndex;

    *pdwStartIndex = *pdwGlyphToPrint = 0;
    bRet = FALSE;

    for (; dwI < dwEndIndex; dwI ++)
    {
        if (pbClipBits[dwI >> 3] & (1 << (dwI & 0x07)))
        {
            if (bRet)
            {
                (*pdwGlyphToPrint)++;
            }
            else
            {
                bRet           = TRUE;
                *pdwStartIndex  = dwI;
                *pdwGlyphToPrint = 1;
            }
        }
        else
        {
            if (bRet)
            {
                break;
            }
        }
    }

    return bRet;

}

//
// If the difference between width and height is not within +-0.5%,
// returns  TRUE.
//

BOOL
NONSQUARE_FONT(
    PXFORML pxform)
{
    BOOL     bRet;
    FLOATOBJ eMa, eMb, eMc;
    FLOATOBJ Round, RoundM;

    //
    // PCL5e printers can not scale with and height of fonts idependently.
    // This function checks if font is squarely scaled.
    // It means width and height is same.
    // Also this function is functional in 0, 90, 180, and 270 degree rotation.
    // PCL5e printer can't not scale arbitrary degree, but only on 0, 90, 180,
    // and 270 degree. So this function works fine.
    //
    if (FLOATOBJ_EqualLong(&pxform->eM11, (LONG)0))
    {
        eMa = eMc = pxform->eM21;
        eMb = pxform->eM12;
    }
    else
    {
        eMa = eMc = pxform->eM11;
        eMb = pxform->eM22;
    }

    //
    // Set 0.005 (0.5%) round values.
    //
#ifndef WINNT_40 //NT 5.0
    FLOATOBJ_SetFloat(&Round, (FLOAT)0.005);
    FLOATOBJ_SetFloat(&RoundM, (FLOAT)-0.005);
#else
    FLOATOBJ_SetFloat(&Round, FLOATL_00_005);
    FLOATOBJ_SetFloat(&RoundM, FLOATL_00_005M);
#endif //!WINNT_40
    //
    // eM11 = (eM11 - eM22) / eM11
    //
    FLOATOBJ_Sub(&eMa, &eMb);
    FLOATOBJ_Div(&eMa, &eMc);

    //
    // (eM11 - eM22) / eM11 < 0.5%
    //
    bRet = FLOATOBJ_LessThan(&(eMa), &(Round)) &&
           FLOATOBJ_GreaterThan(&(eMa), &(RoundM));


    eMa = eMc;
    FLOATOBJ_Add(&eMa, &eMb);
    FLOATOBJ_Div(&eMa, &eMc);
    bRet = bRet
        || (  FLOATOBJ_LessThan(&eMa, &Round)
           && FLOATOBJ_GreaterThan(&(eMa), &(RoundM)));

    return !bRet;
}

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmdebug.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmdebug.h

Abstract:

    Font module Debugging header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _FMDEBUG_H
#define _FMDEBUG_H

#if DBG

#ifdef PUBLIC_GDWDEBUGFONT
    DWORD gdwDebugFont;
#else
    extern DWORD gdwDebugFont;

#endif //PUBLIC_GDWDEBUGFONT

/* Debugging Macroes */
#define IFTRACE(b, xxx)          {if((b)) {VERBOSE((xxx));}}
#define PRINTVAL( Val, format)   {\
            if (gdwDebugFont == DBG_TRACE) \
                DbgPrint("Value of "#Val " is "#format "\n",Val );\
            }

#define TRACE( Val )             {\
            if (gdwDebugFont == DBG_TRACE) \
                DbgPrint(#Val"\n");\
            }

#define DBGP(x)             DbgPrint x

/* Debugging Flags */
#define DBG_FD_GLYPHSET      0x00000001 /* To Dump the FD_GLYPHSET of a font */
#define DBG_UNI_GLYPHSETDATA 0x00000002 /* To Dump the UNI_GLYPHSET of a font */
#define DBG_FONTMAP          0x00000004 /* To Dump the FONTMAP of a font */
#define DBG_TRACE            0x00000008 /* To TRACE */
#define DBG_IFIMETRICS       0x00000010 /* To Dump the IFIMETRICS of a font */
#define DBG_TEXTSTRING       0x00000020 /* To Dump the Input Text string */

/* Debugging Helper Function prototypes. Always use the Macro version of
 * the Call.This will make sure that no extra code is compiled in retail build.
 */

VOID
VDbgDumpUCGlyphData(
    FONTMAP   *pFM
    );

VOID
VDbgDumpGTT(
     PUNI_GLYPHSETDATA pGly);

VOID
VDbgDumpFONTMAP(
    FONTMAP *pFM);

VOID
VDbgDumpIFIMETRICS(
    IFIMETRICS *pFM);

VOID
VPrintString(
    STROBJ     *pstro
    );

/* Function Macroes */
#define VDBGDUMPUCGLYPHDATA(pFM)    VDbgDumpUCGlyphData(pFM)
#define VDBGDUMPGTT(pGly)           VDbgDumpGTT(pGly)
#define VDBGDUMPFONTMAP(pFM)        VDbgDumpFONTMAP(pFM)
#define VDBGDUMPIFIMETRICS(pIFI)    VDbgDumpIFIMETRICS(pIFI)
#define VPRINTSTRING(pstro)         VPrintString(pstro)



#else  //!DBG Retail Build

/* Debugging Macroes */
#define IFTRACE(b, xxx)
#define PRINTVAL( Val, format)
#define TRACE( Val )
#define DBGP(x)            DBGP

/* Function Macroes */
#define VDBGDUMPUCGLYPHDATA(pFM)
#define VDBGDUMPGTT(pGly)
#define VDBGDUMPFONTMAP(pFM)
#define VDBGDUMPIFIMETRICS(pIFI)
#define VPRINTSTRING(pstro)

#endif //DBG

// Macroes for file lavel tracing. Define FILETRACE at the of the file
// before including font.h.

#if DBG

#ifdef FILETRACE

#define FTST( Val, format)  DbgPrint("[UniFont!FTST] Value of "#Val " is "#format "\n",Val );
#define FTRC( Val )         DbgPrint("[UniFont!FTRC] "#Val);\

#else  //FILETRACE

#define FTST( Val, format)
#define FTRC( Val )

#endif //FILETRACE

#else //DBG

#define FTST( Val, format)
#define FTRC( Val )

#endif //DBG

#endif  // !_FMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fmtxtout.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmtxtout.h

Abstract:

    Unidrv Textout related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05-28-97 -eigos-
        Created

    dd-mm-yy -author-
        description

--*/

#ifndef _FMTXTOUT_
#define _FMTXTOUT_

// This is a forward declaration to build.
// Actual definition of FONTMAP is in fontmap.h
// PDLGLYPH is in download.h
//
typedef struct _FONTMAP FONTMAP;
typedef struct _DLGLYPH *PDLGLYPH;

/*
 *   WHITE TEXT:  on LJ III and later printers,  it is possible to
 *  print white text.  Doing this requires sending the white text
 *  after the graphics.  TO do this,  we store the white text details
 *  in the following structures,  then replay them after sending
 *  all the graphics.
 */

/*
 *   First is a structure to determine which glyph and where to put it.
 */

typedef  struct
{
    HGLYPH     hg;               /* The glyph's handle -> the glyph */
    POINTL     ptl;              /* It's position */
} GLYPH;


/*
 *   When some white text appears in DrvTextOut(),  we create one of these
 *  structures,  and add it to the list of such.  At the end of rendering,
 *  these are then processed using the normal sort of code in DrvTextOut().
 *
 *  NOTE that the xfo field is appropriate to scalable fonts or fonts on a
 *  printer that can do font rotations relative to the graphics.
 */

typedef  struct  _WHITETEXT
{
    struct  _WHITETEXT  *next;  // Next in list,  NULL on last
    short     sCount;           // Number of entries
    PVOID     pvColor;          // Color info - For convenience
    int       iFontId;          // Which font
    DWORD     dwAttrFlags;      // Font attribute flags, italic/bold
    FLONG     flAccel;          // STROBJ.flAccel
    GLYPHPOS  *pgp;              // Pointer to a PGLYPHPOS
    PDLGLYPH  *apdlGlyph;     // Download Glyph array. Free in BPlayWhiteText.
    INT       iRot;             // Text Rotation Angle
    FLOATOBJ  eXScale;          // X Scale factor
    FLOATOBJ  eYScale;          // Y Scale factor
    RECTL     rcClipRgn;        // Clipping region of the text(for banding)
    IFIMETRICS *pIFI;
}  WHITETEXT;

//
// Processing textout calls requires access to a considerable number
// of parameters.  To simplify function calls,  this data is accumulated
// in one structure which is then passed around.  Here is that structure.
//
//

typedef  struct _TO_DATA
{
    PDEV        *pPDev;           // The PDEV of interes
    FONTMAP     *pfm;             // Relevant font data
    FONTOBJ     *pfo;             // FONTOBJ
    FLONG       flAccel;          // STROBJ.flAccel
    GLYPHPOS    *pgp;             // Glyph data returned from the engine.
    PDLGLYPH    *apdlGlyph;       // Download Glyph array. Free
                                  // this at the end of Drvtxtout.
    PHGLYPH     phGlyph;          // For font substitution.
    WHITETEXT   *pwt;             // Current WHITETEXT
    PVOID       pvColor;          // Color of the Brush to use

    DWORD       cGlyphsToPrint;   // Number of glyph stored in pgp
    DWORD       dwCurrGlyph;      // Index of the current Glyph to print.
                                  // This is wrt all glyphs in Textout.
    INT         iFace;            // The font index to use
    INT         iSubstFace;       // The font index to substutite.
    INT         iRot;             // 90 deg multiple of font rotation.
    DWORD       dwAttrFlags;      // Font attribute
    DWORD       flFlags;          // Various Flags.
    POINTL      ptlFirstGlyph;    // Position of the first Glyph in pgp.

} TO_DATA;


#define  TODFL_FIRST_GLYPH_POS_SET  0x00000001 // Cursor is set to first glyph
#define  TODFL_DEFAULT_PLACEMENT    0x00000002 // For Default placement
#define  TODFL_TTF_PARTIAL_CLIPPING 0x00000004 // For partial clipping
#define  TODFL_FIRST_ENUMRATION     0x00000008 // For first enum of glyphs


#endif // !_FMTXTOUT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fntmanag.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fntmanag.c

Abstract:

    Routine  to handle EXTENDEDTEXTMETRICS.

Environment:

    Windows NT Unidrv driver.

Revision History:

    12/30/96 -ganeshp-
        Created

--*/

#include "font.h"

ULONG
FMFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    )
/*++

Routine Description:
    This routine is here to provide support for EXTTEXTMETRICS.

Arguments:

   pso      SURFOBJ of interest.
   pfo      FONTOBJ whose EXTTEXTMETRICS is required.
   iMode    Specifies the escape number to be perfomed. This must either
            be equal to QUERYESCSUPPORT, or in the range 0x100 through 0x3FE.

   cjIn     Specifies the size, in bytes, of the buffer pointed to by pvIn.
   pvIn     Points to an input buffer. If the iMode parameter is
            QUERYESCSUPPORT, pvIn points to a ULONG value in the range 0x100
            through 0x3FE.

   cjOut    Specifies the size, in bytes, of the output buffer.
   pvOut    Points to the output data buffer.


Return Value:

    The return value is a value in the range 0x00000001, if the function is
    successful. If the escape is not implemented, the return value is zero.
    If the function fails, the return value is  0xFFFFFFFF.

Note:
    12-30-96: Created it -ganeshp-

--*/
{

    EXTTEXTMETRIC *pETM;

    // unlike the PSCRIPT equivilent this routine only handles GETEXTENDEDTEXTMETRICS


    if( iMode == QUERYESCSUPPORT )
    {
        return ( *((PULONG)pvIn) == GETEXTENDEDTEXTMETRICS ) ? 1 : 0;

    }
    else
    if( iMode == GETEXTENDEDTEXTMETRICS )
    {
        PDEV        *pPDev = ((PDEV  *)pso->dhpdev);
        INT         iFace = pfo->iFace;
        FONTMAP     *pFM;             /* Details of the particular font */

        if( !VALID_PDEV(pPDev) && !VALID_FONTPDEV(PFDV) )
        {
            ERR(( "UniFont!DrvFntManagement: Invalid PDEV\n" ));

            SetLastError( ERROR_INVALID_PARAMETER );
            return  (ULONG)-1;
        }

        if( iFace < 1 || ((int)iFace > pPDev->iFonts) )
        {
            ERR(( "UniFont!DrvFntManagement:  Illegal value for iFace (%ld)", iFace ));

            SetLastError( ERROR_INVALID_PARAMETER );

            return  (ULONG)-1;
        }

        if (NULL == (pFM = PfmGetDevicePFM( pPDev, iFace )))
        {
            ERR(( "UniFont!DrvFntManagement:  PfmGetDevicePFM failed.\n" ));
            return -1;
        }

        //
        // Get pETM pointer.
        // Make sure that pFM is a device font's and pSubFM is valid.
        //
        if (FMTYPE_DEVICE == pFM->dwFontType  &&
            NULL != pFM->pSubFM                )
        {
            pETM = ((PFONTMAP_DEV)pFM->pSubFM)->pETM;
        }
        else
        {
            pETM = NULL;
        }


        if( ( pFM == NULL ) || ( pETM == NULL ) )
        {
            return  0;
        }

        *((EXTTEXTMETRIC *)pvOut) = *pETM;

        return 1;

    }

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fontddi.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontddi.c

Abstract:

    Implementation of the DDI interface functions specific to font module.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/11/96 -ganeshp-
        Created

--*/

#include "font.h"


BOOL
FMResetPDEV(
    PDEV  *pPDevOld,
    PDEV  *pPDevNew
    )
/*++

Routine Description:
    This callback is provided to do cacheing incase of ResetPDev.

Arguments:

    pPDevOld            Pointer to Old PDEV.
    pPDevNew            Pointer to new PDEV.

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    BOOL bRet = FALSE;
    PFONTPDEV   pFontPDevNew = pPDevOld->pFontPDev,
                pFontPDevOld = pPDevOld->pFontPDev;

    /* Check the FontPdev Signature */
    if( (pFontPDevNew->dwSignature != FONTPDEV_ID) ||
        (pFontPDevOld->dwSignature != FONTPDEV_ID) )
    {
        ERR(("\nUniFont!FMResetPDEV; Bad Input PDEV\n"));
        goto ErrorExit;
    }

    bRet = TRUE;
    ErrorExit:
    /* Check for Errors */
    if (!bRet)
    {

    }

    return bRet;


}

VOID
FMDisablePDEV(
    PDEV *pPDev
    )
/*++

Routine Description:
    DrvDisablePDEV entry in Font Module. This routine frees up all the font
    module related memory.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    /* Free the Memory allocated by the font module */
    VFontFreeMem(pPDev);

}


VOID
FMDisableSurface(
    PDEV *pPDev
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{

    /*
     *    If appropriate,  free the position sorting memory. PFMPDV is macro
     *    defined in fmmacro.h. This assumes that 'pPDev' is defined.
     */

    if( PFDV->pPSHeader )
    {

        /*   Memory has been allocated,  so free it now.  */
        VFreePS( pPDev );

        /* Only once, in case */
        PFDV->pPSHeader = 0;
    }

}

BOOL
FMEnableSurface(
    PDEV *pPDev
    )
/*++

Routine Description:
    Font Module DrvEnableSurface entry. We don't do any snything.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    12-18-96: Created it -ganeshp-

--*/
{
    return TRUE;
}


BOOL
FMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )
/*++

Routine Description:
    Font Module DrvStartDoc interface. No need to do any specific job.

Arguments:

    pso              Pointer to SurfOBJ
    pDocName         Document Name
    jobId            Job Id

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-18-96: Created it -ganeshp-

--*/
{
    return TRUE;

}

BOOL
FMStartPage(
    SURFOBJ *pso
    )
/*++

Routine Description:
    DrvStartPage interface. All the font specific data structures needed on
    per page basis will be created.

Arguments:

    pso              Pointer to SurfOBJ

Return Value:

    TRUE for success and FALSE for failure
Note:
    12-18-96: Created it -ganeshp-

--*/
{
    BOOL        bRet = FALSE;
    PDEV        *pPDev;
    FONTPDEV    *pFontPDev;             /* Font pdev */

    pPDev = (PDEV *)pso->dhpdev;

    pFontPDev = (FONTPDEV *)pPDev->pFontPDev;


    /*
     *  If this is NOT a page printer,  we need to initialise the position
     * sorting functions,  so that we print the page unidirectionally.
     */

    if( ((pFontPDev->flFlags & FDV_MD_SERIAL) && pPDev->iFonts) &&
        !BCreatePS( pPDev) )
    {
        ERREXIT(( "Rasdd!DrvStartPage: Cannot create text sorting areas\n" ));

    }

    bRet = TRUE;
    ErrorExit:
    return bRet;

}

BOOL
FMSendPage(
    SURFOBJ *pso
    )
/*++

Routine Description:
    This routine is called on page boundries. we play back the
    white text and free up the memory used by Text Queue.

Arguments:

    pso              Pointer to SurfOBJ

Return Value:

    TRUE for success and FALSE for failure
Note:
    12-18-96: Created it -ganeshp-

--*/
{
    PDEV  *pPDev;                       /* Access to all that is important */
    BOOL   bRet = TRUE;

    pPDev = (PDEV *) pso->dhpdev;

    if( PFDV->pvWhiteTextFirst )
    {
        /*
         *   This page contains white text.  This is stored away in a
         * separate buffer.  Now is the time to play it back.   This is
         * required because the LJ III etc require this data be sent
         * after the graphics.
         */

        bRet = BPlayWhiteText( pPDev );
    }
    if( PFDV->pPSHeader )
        VFreePS( pPDev );               /* Done with this page */

    return bRet;
}

BOOL
FMEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )
/*++

Routine Description:
    Font Module DrvEndDoc interface. We reset font module specif flags.
    Download specific data structure is also freed, so that for new document
    we download again.

Arguments:

    pso              Pointer to SurfOBJ
    flags            DrvEndDoc Flags

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-18-96: Created it -ganeshp-

--*/
{
    PDEV * pPDev = ((PDEV *)(pso->dhpdev));

    //
    // Clear Out the Text Flags based on per document.
    //
    pPDev->fMode  &= ~PF_ENUM_TEXT;
    PFDV->flFlags &= ~FDV_GRX_ON_TXT_BAND;
    PFDV->flFlags &= ~FDV_GRX_UNDER_TEXT;

     /* Free The download specific data */

    VFreeDL( (PDEV *)pso->dhpdev );
    return TRUE;
}

BOOL
FMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
/*++

Routine Description:
    Font Module StartBanding interface.
Arguments:

    pso              Pointer to SurfOBJ
    pptl             Origin of the first Band

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-19-96: Created it -ganeshp-

--*/
{
    PDEV    *pPDev;      /* Access to all that is important */

    pPDev = (PDEV *) pso->dhpdev;

    /* Mark the surface as Graphics */
    pPDev->fMode &= ~PF_ENUM_TEXT;
    pPDev->fMode &= ~PF_REPLAY_BAND;
    pPDev->fMode |= PF_ENUM_GRXTXT;
    PFDV->flFlags &= ~FDV_GRX_ON_TXT_BAND;
    PFDV->flFlags &= ~FDV_GRX_UNDER_TEXT;

    return TRUE;
}

BOOL
FMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )

/*++

Routine Description:
    Font Module StartBanding interface.
Arguments:

    pso              Pointer to SurfOBJ
    pptl             Origin of the Next Band

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-19-96: Created it -ganeshp-

--*/
{
    PDEV    *pPDev;                       /* Access to all that is important */

    pPDev = (PDEV *) pso->dhpdev;


    /* Check if we need separate text band. We need a separate text band if
     * during any TextOut we fond that there is graphics data on the surface
     * under the text clipping rectangle.
     */
    if ( (pPDev->fMode & PF_FORCE_BANDING) &&
         (pPDev->fMode & PF_ENUM_GRXTXT) &&
         (PFDV->flFlags & FDV_GRX_UNDER_TEXT))
    {
        /* Mark the surface as Text */
        pPDev->fMode |= PF_ENUM_TEXT;
        pPDev->fMode |= PF_REPLAY_BAND;
        pPDev->fMode &= ~PF_ENUM_GRXTXT;
    }
    else if (pPDev->fMode & PF_ENUM_TEXT) /* If This is a Text Band */
    {
        /* Mark the surface as Graphics */
        pPDev->fMode &= ~PF_ENUM_TEXT;
        pPDev->fMode &= ~PF_REPLAY_BAND;
        pPDev->fMode |= PF_ENUM_GRXTXT;
        PFDV->flFlags &= ~FDV_GRX_ON_TXT_BAND;
        PFDV->flFlags &= ~FDV_GRX_UNDER_TEXT;
    }

    if( PFDV->pPSHeader )
    {
        if (((PSHEAD*)(PFDV->pPSHeader))->ppPSGSort)
        {
            MemFree(((PSHEAD*)(PFDV->pPSHeader))->ppPSGSort);
            ((PSHEAD*)PFDV->pPSHeader)->ppPSGSort = NULL;
        }
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\font.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    font.h

Abstract:

    Font module main header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

        dd-mm-yy -author-
                description

--*/


#ifndef _FONT_H_
#define _FONT_H_

#include "lib.h"
#include "winnls.h"
#include "unilib.h"

//
// UNIDRV resource ID
//

#include "unirc.h"

//
// Font resource format
//
#include <prntfont.h>
#include "fmoldfm.h"
#include "fmoldrle.h"

//
// GPC and GPD header
//

#include "gpd.h"
#include "uni16res.h"
#include "mini.h"

//
// Internal resource data format
//

#include "fontinst.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "common.h"
#include "fontif.h"
#include "fmcallbk.h"
#include "fmtxtout.h"
#include "fontmap.h"
#include "fontpdev.h"
#include "download.h"
#include "posnsort.h"
#include "sf_pcl.h"
#include "sfinst.h"

#include "fmfnprot.h"
#include "fmdevice.h"
#include "sfttpcl.h"

//
// Misc
//

#include "fmmacro.h"
#include "fmdebug.h"

//
// Vector plugins (HPGL2, PCLXL)
//
#include "vectorif.h"

#endif  // !_FONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fontpdev.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    FontPdev.h

Abstract:

    Unidrv FONTPDEV and related infor header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    11/06/96 -ganeshp-
        Created

        dd-mm-yy -author-
                description

--*/

#ifndef _FONTPDEV_H_
#define _FONTPDEV_H_

//
//  FONTCTL is included in FONTPDEV for controlling the state device.
//

typedef struct _FONTCTL
{
    DWORD       dwAttrFlags;  // Font attribute flags, italic/bold.
    INT         iFont;        // Font index; -ve for downloaded GDI font
    INT         iSoftFont;    // Soft Font index;
    INT         iRotate;      // Font Rotation Angle
    POINTL      ptlScale;     // Printer sizes for scalable fonts
    FLOATOBJ    eXScale;      // Font scaling in baseline direction
    FLOATOBJ    eYScale;      // Font scaling in the ascender direction
    PFONTMAP    pfm;
} FONTCTL;

//
// dwAttrFlags
//

#define FONTATTR_BOLD      0x00000001
#define FONTATTR_ITALIC    0x00000002
#define FONTATTR_UNDERLINE 0x00000004
#define FONTATTR_STRIKEOUT 0x00000008
#define FONTATTR_SUBSTFONT 0x10000000

#define INVALID_FONT       0x7FFFFFFF  // for iFont.

//
// Font Cartridges definitions.
//

#define MAXCARTNAMELEN          64

//
// Font cart mapping table. This table is a list of names and correponding
// FONTCAT structure which is filled by the parser. The actual font list
// is in the FONTCART structure.
//

typedef struct _FONTCARTMAP
{
    PFONTCART   pFontCart;         //Pointer to fontcart in GPD.
    WCHAR       awchFontCartName[MAXCARTNAMELEN]; /* Name of the Font Cart*/
    BOOL        bInstalled;         //This Font Cartridges is installed or not
} FONTCARTMAP, *PFONTCARTMAP;

//
// This structure is stored in the FontPDEV and has all the information about
// Font cartridges.
//

typedef struct _FONTCARTINFO
{
    PFONTCARTMAP    pFontCartMap;       // Font Cartridge Mapping Table.
    INT             iNumAllFontCarts;   // Number of all supported font carts.
    INT             iNumInstalledCarts;  // Number of installed cartridges.
    DWORD           dwFontCartSlots;    // Number of Font Cartridge Slots.
}FONTCARTINFO, *PFONTCARTINFO;


//
// This structe stores the Font resource ids of all the preinstalled fonts.
// This include Resident fonts plus installed Cartridge specific fonts.
//

typedef  struct  _FONTLIST_
{
    PDWORD    pdwList;               // An array of device font resource Ids.
    INT       iEntriesCt;            // Number of valid entries.
    INT       iMaxEntriesCt;         // Max number of Entries in this list
}  FONTLIST, *PFONTLIST;

//
// FONTPDEV structure
//

typedef struct _FONTPDEV {

    DWORD       dwSignature;       // FONTPDEV Signature
    DWORD       dwSize;            // FONTPDEV Size.

    PDEV        *pPDev;            // Pointer to PDEV.
    DWORD       flFlags;           // General Flags.
    DWORD       flText;            // Text Capabilities.

    DWORD       dwFontMem;         // Bytes of allocated printer memory
                                   // for font download
    DWORD       dwFontMemUsed;     // Bytes of printer memory used for
                                   // downloaded fonts
    DWORD       dwSelBits;         // Font selection bits
    POINT       ptTextScale;       // relationship between master units
                                   // and text units.
    INT         iUsedSoftFonts;    // Number of soft fonts used
    INT         iNextSFIndex;      // Index ID to use for next softfont
    INT         iFirstSFIndex;     // Value used to reset the above
    INT         iLastSFIndex;      // Largest value available
    INT         iMaxSoftFonts;     // Maximum number of Soft font per page

    INT         iDevResFontsCt;    // Num of device resident fonts.
                                   // No cartridge fonts: No soft fonts.
    INT         iDevFontsCt;       // Num of device fonts including cartridge
                                   // fonts: no soft fonts.'cBIFonts' in Rasdd
    INT         iSoftFontsCt;      // Number of SoftFonts installed.
    INT         iCurXFont;         // Index of currently selected softfont
    INT         iWhiteIndex;       // White index of the device palette
    INT         iBlackIndex;       // Black index of the device palette
    DWORD       dwDefaultFont;     // Default font
    SHORT       sDefCTT;           // Default translation table
    WORD        wReserved;         // Padding
    DWORD       dwTTYCodePage;     // Default codepage for TTY
    SURFOBJ     *pso;              // SurfObj access
    PVOID       pPSHeader;         // Position sorting header (posnsort.[hc])
    PVOID       pvWhiteTextFirst;  // Pointer to first in the White text list, if needed
    PVOID       pvWhiteTextLast;   // Pointer to the last in the White text list
    PVOID       pTTFile;           // True Type File pointer
    ULONG       pcjTTFile;         // size of True Type File
    PVOID       ptod;              // For access to TextOut Data.

    FONTMAP     *pFontMap;         // Array of FONTMAPS describing fonts.
    FONTMAP     *pFMDefault;       // Default font FONTMAP,  if != 0

    PVOID       pvDLMap;           // Mapping of GDI to downloaded info

    FONTLIST    FontList;          // This is array of font resource ids of
                                   // Device and precompiled Cartridges fonts.
    FONTCARTINFO FontCartInfo;     // This is array of font Cartridges.

    FONTCTL      ctl;              // Font state of the printer.

    IFIMETRICS  *pIFI;             // Current font IFIMETRICS cache.
    PFLOATOBJ_XFORM pxform;        // Current font XFORM

    HANDLE       hUFFFile;

    //
    // Font attribute command cache

    PCOMMAND pCmdBoldOn;
    PCOMMAND pCmdBoldOff;
    PCOMMAND pCmdItalicOn;
    PCOMMAND pCmdItalicOff;
    PCOMMAND pCmdUnderlineOn;
    PCOMMAND pCmdUnderlineOff;
    PCOMMAND pCmdClearAllFontAttribs;

    //
    // Font substitution table in registry.
    //
    TTSUBST_TABLE pTTFontSubReg;   // Font substitution table.

    //
    // Font module callback interface object
    //
    PI_UNIFONTOBJ pUFObj;

} FONTPDEV, *PFONTPDEV;

//
//General MACROes
//
#define     FONTPDEV_ID     'VDPF'      //"FPDV" in ASCII.
#define     FONTMAP_ID      'PAMF'      //"FMAP" in ASCII.
#define     MAXDEVFONT      255         // Maximum number of font entris in a
                                        // List. There may be more than one
                                        // LIST to repesent all the fonts.
//
// FONTPDEV.flflags Values
//

#define  FDV_ROTATE_FONT_ABLE       0x00000001 // Font can be rotated
#define  FDV_ALIGN_BASELINE         0x00000002 // Text is Base Line aligned
#define  FDV_TT_FS_ENABLED          0x00000004 // Text is Base Line aligned
#define  FDV_DL_INCREMENTAL         0x00000008 // always TRUE
#define  FDV_TRACK_FONT_MEM         0x00000010 // Track Memory for font DL
#define  FDV_WHITE_TEXT             0x00000020 // Can print white text
#define  FDV_DLTT                   0x00000040 // Download True Type
#define  FDV_DLTT_ASTT_PREF         0x00000080 // True Type as outline
#define  FDV_DLTT_BITM_PREF         0x00000100 // True Type as Bitmap
#define  FDV_DLTT_OEMCALLBACK       0x00000200 // True Type as Bitmap
#define  FDV_MD_SERIAL              0x00000400 // Printer is a serial printer
#define  FDV_GRX_ON_TXT_BAND        0x00000800 // Grx is drawn on Text Band
#define  FDV_GRX_UNDER_TEXT         0x00001000 // Grx is drawn under Text
#define  FDV_BKSP_OK                0x00002000 // use BkSpace to overstrike
#define  FDV_90DEG_ROTATION         0x00004000 // Supports 90 Deg Rot.
#define  FDV_ANYDEG_ROTATION        0x00008000 // Supports Any Deg Rot.
#define  FDV_SUPPORTS_FGCOLOR       0x00010000 // Supports Foreground color.
#define  FDV_SUBSTITUTE_TT          0x00020000 // Substitute TT font.
#define  FDV_SET_FONTID             0x00040000 // Soft font ID command is sent
#define  FDV_UNDERLINE              0x00080000 // Device can simlulate underline
#define  FDV_INIT_ATTRIB_CMD        0x00100000 // Initalized font attribute cmd
#define  FDV_SINGLE_BYTE            0x00200000  // ESC/P Single/Double byte mode flag
#define  FDV_DOUBLE_BYTE            0x00400000  // ESC/P Single/Double byte mode flag
#define  FDV_DISABLE_POS_OPTIMIZE   0x00800000  // Disable X position optimization
#define  FDV_ENABLE_PARTIALCLIP     0x01000000  // Enable partial clipping

//
// Misc macros
//   A macro to swap bytes in words.  Needed as PCL structures are in
// 68k big endian format.
//

#define SWAB( x )   ((WORD)(x) = (WORD)((((x) >> 8) & 0xff) | (((x) << 8) & 0xff00)))

#endif  // !_FONTPDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fontmap.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontmap.h

Abstract:

    Unidrv FONTMAP and related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05-19-97 -eigos-
        Created

    dd-mm-yy -author-
        description

--*/

#ifndef  _FONTMAP_
#define _FONMTAP_

//
//  CD - Command Descriptor is used in many of the following structures to
//  reference a particular set of printer command/escape codes
//  used to select paper sizes, graphics resolutions, character attributes,
//  etc. If CD.wType = CMD_FTYPE_EXTENDED, the CD is followed by CD.sCount
//  EXTCD structures.
//

#define NOOCD                     -1    // command does not exist

typedef struct _CD
{
    BYTE    fType;          // type of command
    BYTE    bCmdCbId;       // command callback ID, as in 95
    short   sCount;
    WORD    wLength;        // length of the command
    char    rgchCmd[2];     // Actual Command String, variable length
} CD, *PCD;

//
// FINVOCATION data structure is in printoem.h at public\oak\inc
//

//
// FONTMAP structure for NT 5.0
//

typedef struct _FONTMAP *PFONTMAP;

//
//           _________________
//          |                 |
//          |   Font Main     |
//          |     module      |
//           -----------------
//           |       |        |
//       ____|__  ___|___   __|_____
//      |Device ||TT     | |TT      |
//      | font  || Bitmap| | Outline|
//      | sub   || sub   | | sub    |
//      | module|| Module| | Module |
//       -------  --------  --------
//
//
//

//
// Glyph output function
//
// TO_DATA structure is in fmtxtout.h
//
typedef DWORD (*PFNGLYPHOUT)  (TO_DATA *pTod);

//
// Font selection/deselection function
// UNIDRV
//

typedef BOOL  (*PFNSELFONT)   (PDEV *pdev, PFONTMAP pFM, POINTL* pptl);
typedef BOOL  (*PFNDESELFONT) (PDEV *pdev, PFONTMAP pFM);
typedef BOOL  (*PFNFREEPFM)   (PFONTMAP pFM);

//
// font download functions
//
// Header download function
// This function returns the memory used to download this font.
// If this function fails, this function has to return 0,
//
typedef DWORD (*PFNDLHEADER)  (PDEV *pdev, PFONTMAP pFM);

//
// Character glyph download function
// This function returns the memory used to download this character.
// If this function fails, this function has to return 0. The optional
// parameter is width. This function should fill in the width of the
// Glyph downloaded. This value is save in DLGLYPH.wWidth field.
//
typedef DWORD (*PFNDLGLYPH)   ( PDEV *pdev, PFONTMAP pFM,
                                HGLYPH hGlyph, WORD wDLGlyphId, WORD *pwWidth);
//
// Before downnloading this font a font main calls this function
// to determine if this font can be downloaded with this font and the current
// condition.
// Sub module checks if this font is appropriate to download with  FONTMAP.
// And checks if the remaining memory is enough to download this font.
//
typedef BOOL (*PFNCHECKCOND) (  PDEV *pdev, FONTOBJ *pfo,
                                STROBJ *pstro, IFIMETRICS  *pifi);

typedef struct _FONTMAP
{
    DWORD  dwSignature;         // FONTMAP Signature
    DWORD  dwSize;              // FONTMAP Size.
    DWORD  dwFontType;          // Device/TTBitmap//TTOutline/..
    LONG   flFlags;             // Flags listed below
    IFIMETRICS   *pIFIMet;      // The IFIMETRICS for this font

    WCHAR  wFirstChar;          // First char available
    WCHAR  wLastChar;           // Last one available - inclusive
    ULONG  ulDLIndex;           // Currently selected DL index.

    WORD        wXRes;          // X Res used for font metrics numbers
    WORD        wYRes;          // Ditto for the y coordinates
    SHORT       syAdj;          // Y position adjustment during printing

    //
    // Font specific data structure
    //
    PVOID pSubFM;               // Pointer to the font specific data structure
                                // dwFontType represents this FONTMAP font type.
                                // FMTYPE_DEVICE
                                // FMTYPE_TTBITMAP
                                // FMTYPE_TTOUTLINE
                                // FMTYPE_TTOEM

    //
    // Font specific drawing functions' pointers
    // These pointers varies according to the dwFontType.
    //
    PFNGLYPHOUT  pfnGlyphOut;           // Glyph drawing function
    PFNSELFONT   pfnSelectFont;         // Font selection function
    PFNDESELFONT pfnDeSelectFont;       // Font deselection function
    PFNDLHEADER  pfnDownloadFontHeader; // Download font header
    PFNDLGLYPH   pfnDownloadGlyph;      // Download glyph
    PFNCHECKCOND pfnCheckCondition;     // Condition check function
    PFNFREEPFM   pfnFreePFM;            // To Free the pfm
} FONTMAP, *PFONTMAP;

//
// Values for dwFontType
//
#define FMTYPE_DEVICE       1    // Set for Device font.
#define FMTYPE_TTBITMAP     2    // Set for True Type Bitmap font.
#define FMTYPE_TTOUTLINE    3    // Set for True Type Outline font.
#define FMTYPE_TTOEM        4    // Set for True Type download OEM callback.

//
// FONTMAP_DEV
// Device font sub part of FONTMAP
//

typedef BOOL  (*PFNDEVSELFONT) (PDEV *pdev, BYTE *pbCmd, INT iCmdLength, POINTL *pptl);

typedef struct _FONTMAP_DEV
{
    WORD        wDevFontType;        // Type of Device font
    SHORT       sCTTid;              // It's value as ID in resource data
                                     // Assume that RLE/GTT must be in the same
         // DLL as IFI/UFM is in.
    SHORT       fCaps;               // Capabilities flags
    SHORT       sYAdjust;            // Position adjustment amount before print
    SHORT       sYMoved;             // Position adjustment amount after print
    SHORT       sPadding;            // For Padding
    union
    {
        DWORD      dwResID;          // Resource ID for this font
        QUALNAMEEX QualName;         // Fully qualified resource ID.
    };

    EXTTEXTMETRIC *pETM;             // Pointer to ETM for this font
    FWORD       fwdFOAveCharWidth;   // TrueType IFI Average char width
    FWORD       fwdFOMaxCharInc  ;   // TrueType IFI Max char width.
    FWORD       fwdFOUnitsPerEm;     // TrueType IFI units per em
    FWORD       fwdFOWinAscender;    // TrueType IFI Win Ascender

    ULONG       ulCodepage;          // default codepage
    ULONG       ulCodepageID;        // current codepage

    VOID        *pUCTree;            // UNICODE glyph handle tree
    VOID        *pUCKernTree;        // UNICODE Kernpair table
    VOID        *pvMapTable;         // Allocated MAPTABLE. This is a merged
                                     // MAPTABLE from predefined and mini def.
    PUFF_FONTDIRECTORY pFontDir;    // UFF font directory of this font.
    //
    // Font selection function pointer
    //
    PFNDEVSELFONT pfnDevSelFont;     // Device font selection command

    //
    // File resource pointer
    //
    VOID        *pvNTGlyph;          // The GLYPH TRANS data for this font
    VOID        *pvFontRes;          // Font Matrics(IFI) Resource Pointer
    VOID        *pvPredefGTT;        // This is used for lPredefinedID

    union
    {
        SHORT       *psWidth;        // Width vector (proportional font) else 0
        PWIDTHTABLE pWidthTable;     // pointer to WIDTHTABLE
    } W;

    //
    // Font command
    // If FM_IFIVER40 is set, pCDSelect and pCDDeselect are set.
    // Otherwise, FInvSelect/FinvDeselect are set.
    //
    union
    {
        CD          *pCD;      // How to select/deselect this font
        FINVOCATION  FInv;
    }cmdFontSel;
    union
    {
        CD          *pCD;
        FINVOCATION  FInv;
    }cmdFontDesel;

} FONTMAP_DEV, *PFONTMAP_DEV;

//
//   Values for device font flFlags
//
#define FM_SCALABLE     0x00000001  // Scalable font
#define FM_DEFAULT      0x00000002  // Set for the device's default font
#define FM_EXTCART      0x00000004  // Cartridge, in external font file
#define FM_FREE_GLYDATA 0x00000008  // we need to free GTT or CTT data
#define FM_FONTCMD      0x00000010  // Font select/deselect command in resource
#define FM_WIDTHRES     0x00000020  // Width tables are in a resource
#define FM_IFIRES       0x00000040  // IFIMETRICS are in a resource
#define FM_KERNRES      0x00000080  // FD_KERNINGPAIR is in a resource
#define FM_IFIVER40     0x00000100  // Old IFIMETRICS(NT 4.0) resource
#define FM_GLYVER40     0x00000200  // Old RLE(NT 4.0) resource
#define FM_FINVOC       0x00000400  // FINVOCATION is filled out
#define FM_SOFTFONT     0x00000800  // Soft font, downloaded or installed
#define FM_GEN_SFONT    0x00001000  // Internally generated soft font
#define FM_SENT         0x00002000  // Set if downloaded font downloaded
#define FM_TT_BOUND     0x00004000  // Bound TrueType font
#define FM_TO_PROP      0x00008000  // PROPORTIONAL font
#define FM_EXTERNAL     0x00010000  // External font

//
// FONTMAP_TTB
// TrueType as Bitmap font sub part of FONTMAP
//
typedef struct _FONTMAP_TTB
{
    DWORD dwDLSize;

    union
    {
        VOID  *pvDLData;        // Pointer to DL_MAP
        ULONG  ulOffset;
    } u;
} FONTMAP_TTB, *PFONTMAP_TTB;

//
// FONTMAP_TTO
// TrueType as TrueType Outline font sub part of FONTMAP
//
typedef struct _FONTMAP_TTO
{
    VOID  *pvDLData;        // Pointer to DL_MAP
    LONG   lCurrentPointSize;
    DWORD  dwCurrentTextParseMode;
    //VOID  *pTTFile;
    ULONG  ulGlyphTable;
    ULONG  ulGlyphTabLength;
    USHORT usNumGlyphs;
    SHORT  sIndexToLoc;      // head.indexToLocFormat
    ULONG  ulLocaTable;
    PVOID  pvGlyphData;
    //GLYPH_DATA GlyphData;      // TT GlyphData
    FLONG  flFontType;         // Font Type (bold/italic)
} FONTMAP_TTO, *PFONTMAP_TTO;

typedef struct _FONTMAP_TTOEM
{
    DWORD dwDLSize;
    DWORD dwFlags;
    FLONG flFontType;

    union
    {
        VOID  *pvDLData;        // Pointer to DL_MAP
        ULONG  ulOffset;
    } u;
} FONTMAP_TTOEM, *PFONTMAP_TTOEM;
#endif  // !_FONTMAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fontread.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontread.c

Abstract:

    Functions to assist processing of the data in a common font
    installer file format.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

--*/



#include        "font.h"


int
IFIOpenRead(
    FI_MEM  *pFIMem,                /* Output goes here */
    PWSTR    pwstrName,             /* Name of printer data file */
    PDEV    *pPDev                 /* pointer to PDEV */
    )
/*++

Routine Description:

    Makes the font installer file accessible & memory mapped.  Called
    by a driver to gain access to the fonts in the font installer's
    output file.


Arguments:


    FI_MEM : Font Installer Header
    PWSTR  : Font file.
    PDEV   :    Pointer to PDEV

    Return Value:

    Number of records in the file;  0 for an empty/non-existant file.

Note:
    12-02-96: Created it -ganeshp-
--*/

{

    DWORD   dwSize;             /* Size of buffer needed for file name */
    PWSTR   pwstrLocal;



    pFIMem->hFont = INVALID_HANDLE_VALUE;      /* No data until we have it */
    pFIMem->pbBase = NULL;

    /*
     *   First map the file to memory.  However,  we do need firstly to
     * generate the file name of interest.  This is based on the data
     * file name for this type of printer.
     *   Allocate more storage than is indicated:  we MAY want to add
     * a prefix to the file name rather than replace the existing one.
     */


    dwSize = sizeof( WCHAR ) * (wcslen( pwstrName ) + 1 + 4);


    if( pwstrLocal = (PWSTR)MemAllocZ( dwSize ) )
    {
        /*  Got the memory,  so fiddle the file name to our standard */

        int    iPtOff;             /* Location of '.' */


        FF_HEADER  ffh;          /* Read in to determine memory size needed */



        wcscpy( pwstrLocal, pwstrName );

        /*
         *   Go looking for a '.' - if not found,  append to string.
         */

        iPtOff = wcslen( pwstrLocal );

        while( --iPtOff > 0 )
        {
            if( *(pwstrLocal + iPtOff) == (WCHAR)'.' )
                break;
        }

        if( iPtOff <= 0 )
        {
            iPtOff = wcslen( pwstrLocal );              /* Presume none! */
            *(pwstrLocal + iPtOff) = L'.';
        }
        ++iPtOff;               /* Skip the period */



        /*  Generate the name and map the file */
        wcscpy( pwstrLocal + iPtOff, FILE_FONTS );

        pFIMem->hFont = DrvOpenFile ( pwstrLocal, pPDev );


        MEMFREEANDRESET( pwstrLocal );        /* No longer needed */

        /*
         *   Now for the fun part.   The file header contains the size
         *  of the fixed part of the file.  This is the part containing
         *  the IFIMETRICS etc.  This is the part of the file that causes
         *  great distress to GDI if the network fails when we are mapping
         *  to a remote system.  SO,  we allocate storage for this data
         *  now,  and read the data in.  Then it is safe for ever after.
         */

        if( pFIMem->hFont == INVALID_HANDLE_VALUE )
            return  0;           /*  Probably no file there at all */

        if( !DrvReadFile( pFIMem->hFont, &ffh, sizeof( ffh ), &dwSize,pPDev ) ||
            dwSize != sizeof( ffh ) )
        {
            /*
             *   Bad news on the read,  so fail the call now.
             */

            DrvCloseFile( pFIMem->hFont,pPDev );
            pFIMem->hFont = INVALID_HANDLE_VALUE;

            return  0;
        }

        dwSize = ffh.ulFixSize + sizeof( ffh );

        pFIMem->pbBase = (BYTE *)MemAllocZ( dwSize );


        if( pFIMem->pbBase == NULL )
        {
            /*  Could not get the memory,  so give up now */
            DrvCloseFile( pFIMem->hFont,pPDev );
            pFIMem->hFont = INVALID_HANDLE_VALUE;

            return  0;
        }

        /*
         *   We want to read the file header again,  so rewind the file.
         */

        DrvSetFilePointer( pFIMem->hFont,  0,  DRV_FILE_BEGIN, pPDev );

        if( !DrvReadFile( pFIMem->hFont, pFIMem->pbBase, dwSize, &dwSize, pPDev ) ||
            dwSize != dwSize )
        {

            /*   Not good either - cannot read the file again.  */

            MEMFREEANDRESET( pFIMem->pbBase );

            DrvCloseFile( pFIMem->hFont,pPDev );
            pFIMem->hFont = INVALID_HANDLE_VALUE;

            return  0;
        }


        return  IFIRewind( pFIMem );
    }
    else
        return  0;              /* Too bad: oh well, no extra fonts */

}


BOOL
BFINextRead(
    FI_MEM   *pFIMem
    )
/*++

Routine Description:

    Updates pFIMem to the next entry in the font installer file.
    Returns TRUE if OK, and updates the pointers in pFIMem.

Arguments:

    FI_MEM : Font Installer Header

    Return Value:

    TRUE/FALSE.   FALSE for EOF,  otherwise pFIMem updated.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    FF_HEADER      *pFFH;               /* Overall file header */
    FF_REC_HEADER  *pFFRH;              /* Per record header */

    /*
     *  Validate that we have valid data.
     */


    if( pFIMem == 0 || pFIMem->hFont == INVALID_HANDLE_VALUE )
        return  FALSE;                          /* Empty file */


    pFFH = (FF_HEADER *)pFIMem->pbBase;

    if( pFFH->ulID != FF_ID )
    {
#if DBG
        DbgPrint( "Print!bFINextRead: FF_HEADER has invalid ID\n" );
#endif

        return  FALSE;
    }

    /*
     *   If pFIMem->pvFix == 0, we should return the data from the
     * first record.  Otherwise,  return the next record in the chain.
     * This is done to avoid the need to have a ReadFirst()/ReadNext()
     * pair of functions.
     */

    if( pFIMem->pvFix )
    {
        /*
         *   The header is located immediately before the data we last
         * returned for the fixed portion of the record.  SO,  we back
         * over it to get the header which then gives us the address
         * of the next header.
         */

        pFFRH = (FF_REC_HEADER *)((BYTE *)pFIMem->pvFix -
                                                 sizeof( FF_REC_HEADER ));

        if( pFFRH->ulRID != FR_ID )
        {
#if DBG
            DbgPrint( "Print!bFINextRead: Invalid FF_REC_HEADER ID\n" );
#endif

            return  FALSE;
        }

        /*
         *   We could check here for EOF on the existing structure, but this
         * is not required BECAUSE THE ulNextOff field will be 0, so when
         * it is added to our current address,  we don't move.  Hence, the
         * check for the NEW address is OK to detect EOF.
         */

        (BYTE *)pFFRH += pFFRH->ulNextOff;              /* Next entry */

    }
    else
    {
        /*   Point to the first record.  */
        pFFRH = (FF_REC_HEADER *)(pFIMem->pbBase + pFFH->ulFixData);
    }

    if( pFFRH->ulNextOff == 0 )
        return  FALSE;

    pFIMem->pvFix = (BYTE *)pFFRH + sizeof( FF_REC_HEADER );
    pFIMem->ulFixSize = pFFRH->ulSize;

    if( pFIMem->ulVarSize = pFFRH->ulVarSize )
        pFIMem->ulVarOff = pFFRH->ulVarOff + pFFH->ulVarData;
    else
        pFIMem->ulVarOff = 0;              /* None here */


    return  TRUE;

}


int
IFIRewind(
    FI_MEM   *pFIMem               /* File of importance */
    )
/*++

Routine Description:

    Reset pFIMem to the first font in the file.

Arguments:

    FI_MEM : Font Installer Header

    Return Value:

    Number of entries in the file.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    /*
     *  Not hard!  The pFIMem contains the base address of the file, so we
     * use this to find the address of the first record,  and any variable
     * data that corresponds with it.
     */

    FF_HEADER      *pFFH;
    FF_REC_HEADER  *pFFRH;

    if( pFIMem == 0 || pFIMem->hFont == INVALID_HANDLE_VALUE )
        return  0;                              /* None! */


    /*
     *   The location of the first record is specified in the header.
     */

    pFFH = (FF_HEADER *)pFIMem->pbBase;
    if( pFFH->ulID != FF_ID )
    {
#if DBG
        DbgPrint( "Print!iFIRewind: FF_HEADER has invalid ID\n" );
#endif

        return  0;
    }

    pFFRH = (FF_REC_HEADER *)(pFIMem->pbBase + pFFH->ulFixData);

    if( pFFRH->ulRID != FR_ID )
    {
#if DBG
        DbgPrint( "Print!iFIRewind: Invalid FF_REC_HEADER ID\n" );
#endif

        return  0;
    }

    /*
     *   Set the pvFix field in the header to 0.  This is used in bFINextRead
     * to mean that the data for the first record should be supplied.
     */
    pFIMem->pvFix = 0;          /* MEANS USE FIRST NEXT READ */
    pFIMem->ulFixSize = 0;
    pFIMem->ulVarOff = 0;       /* None here */

    return  pFFH->ulRecCount;

}


/******************************* Function Header ***************************
 * BFICloseRead
 *      Called when finished with this font file.
 *
 * RETURNS:
 *      Nothing
 *
 * HISTORY:
 *  15:07 on Sat 12 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *      Can no longer use MapFile,  so free memory and close handles as needed.
 *
 *  13:56 on Thu 27 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Time t = 0
 *
 ***************************************************************************/

BOOL
BFICloseRead(
    FI_MEM  *pFIMem,                /* File/memory we are finished with */
    PDEV    *pPDev                  /* pointer to PDEV */
    )
/*++

Routine Description:

    Called when finished with this font file.

Arguments:

    FI_MEM : Font Installer Header
    PDEV:    Pointer to PDEV

    Return Value:

    TRUE for success and FALSE for failure.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    /*
     *   Easy!  All we need do is unmap the file.  We have the address too!
     */

    BOOL   bRet;                /* Return code */


    if( pFIMem == 0 || pFIMem->hFont == INVALID_HANDLE_VALUE )
        return  TRUE;                   /* Nothing there! */


    bRet =  DrvCloseFile( pFIMem->hFont,pPDev );


    /*   Also free our chunk of memory  */

    if( pFIMem->pbBase )
    {
        /*   Address is valid,  so free it now  */

        MEMFREEANDRESET( pFIMem->pbBase );
    }


    if( bRet )
        pFIMem->hFont = INVALID_HANDLE_VALUE; /* Stops freeing more than once */


    return  bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fontfree.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontfree.c

Abstract:

Frees any font memory,  no matter where allocated.  This should be
called from DrvDisableSurface to free any memory allocated for
holding font information.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/03/97 -ganeshp-
        Created

--*/

#include "font.h"



VOID
VFontFreeMem(
    PDEV   *pPDev
    )
/*++

Routine Description:

    Called to free all memory allocated for font information.
    Basically we track through all the font data contained in
    FONTPDEV,  freeing as we come across it.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value: None.


Note:
    01-03-97: Created it -ganeshp-
--*/
{

    /*
     *   The PDEV contains only one thing of interest to us - a pointer
     * to the FONTPDEV,  which contains all the font memory.
     */

    register  FONTMAP   *pFM;           /* Working through per font data */
    int                 iIndex;
    FONTPDEV            *pFontPDev;
    FONTMAP_DEV         *pFMDev;


    pFontPDev = pPDev->pFontPDev;

    if (pFontPDev)
        pFM = pFontPDev->pFontMap;    /* The per font type data */
    else
    {
        WARNING(("\nUnifont!VFontFreeMem: NULL pFontPDev\n"));
        return;
    }

    /*
     *   If there is font stuff,  free it up now.
     */

    if( pFM )
    {
        /*   Loop through per font */
        for( iIndex = 0;
             iIndex < pPDev->iFonts;
             ++iIndex, (PBYTE)pFM += SIZEOFDEVPFM() )
        {
            pFMDev = pFM->pSubFM;

            if (pFM->dwSignature != FONTMAP_ID)
                continue;

            /*   The UNICODE tree data */
            if( pFMDev->pUCTree )
                MEMFREEANDRESET(pFMDev->pUCTree );

            /*   May also need to free the translation table */
            if( pFM->flFlags & FM_FREE_GLYDATA && pFMDev->pvNTGlyph)
            {
                pFM->flFlags &= ~FM_FREE_GLYDATA;
                MEMFREEANDRESET(pFMDev->pvNTGlyph );

            }


            /*   The IFIMETRICS data */
            if( pFM->pIFIMet )
            {
                if (pFM->flFlags & FM_IFIRES)
                {
                    /*  Data is a resource,  so No need to free. */
                }
                else
                {
                    MEMFREEANDRESET(pFM->pIFIMet);
                }
            }

            if( !(pFM->flFlags & FM_FONTCMD) )
            {
                /*   The font select/deselect commands - if present */
                if( pFMDev->cmdFontSel.pCD)
                    MEMFREEANDRESET(pFMDev->cmdFontSel.pCD);

                if( pFMDev->cmdFontDesel.pCD)
                    MEMFREEANDRESET(pFMDev->cmdFontDesel.pCD);
            }

            /*   Free the width table,  if one is allocated */
            if( pFMDev->W.psWidth )
            {
                if( !(pFM->flFlags & FM_WIDTHRES) )
                    MEMFREEANDRESET(pFMDev->W.psWidth );
            }
        }

        /*   Finally - free the FONTMAP array!  */
        MEMFREEANDRESET(pFontPDev->pFontMap );
    }

    pPDev->iFonts = 0;


    /*
     *   There may also be font installer information to free up.
     */


    /*
     *   Free the downloaded font information.  This MUST be done whenever
     *  the printer is reset (and thus looses fonts), which typically
     *  is an event that happens during DrvRestartPDEV.
     */

    VFreeDL( pPDev );

    /* Free the Text sorting array, if allocated */
    if (pFontPDev->pPSHeader)
    {

        VFreePS( pPDev );
    }

    if (pFontPDev)
    {
        /* Free different structuress */
        if (pFontPDev->FontList.pdwList)
            MEMFREEANDRESET(pFontPDev->FontList.pdwList);

        if (pFontPDev->FontCartInfo.pFontCartMap)
            MEMFREEANDRESET(pFontPDev->FontCartInfo.pFontCartMap);

        if (pFontPDev->pTTFontSubReg)
            MEMFREEANDRESET(pFontPDev->pTTFontSubReg);

        if (pFontPDev->hUFFFile)
            FICloseFontFile(pFontPDev->hUFFFile);

        MEMFREEANDRESET(pFontPDev);
        pPDev->pFontPDev = NULL;

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\fonts.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Functions associated with fonts - switching between, downloading etc.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/19/96 -ganeshp-
        Created

--*/

#include "font.h"
#include "math.h"

//
// Local Function Prototypes.
//

BOOL
BDeselectFont(
    PDEV        *pPDev,
    FONTMAP     *pfm,
    INT         iFont
    );





VOID
VResetFont(
    PDEV   *pPDev
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    8/7/1997 -ganeshp-
        Created it.
--*/
{
    FONTPDEV  *pFontPDev;            /* UNIDRVs PDEV */

    //
    // All we have to do is to set the iFont to INVALID_FONT.
    //
    pFontPDev = PFDV;
    pFontPDev->ctl.iFont = INVALID_FONT;
    FTRC(\nUniFont!VResetFont:Reselecting Current Font\n);
    return;
}


BOOL
BNewFont(
    PDEV    *pPDev,
    int      iNewFont,
    PFONTMAP pfm,
    DWORD    dwFontAttrib)
/*++

Routine Description:
    Switch to a new font.   This involves optionally deselecting
    the old font,  selecting the new font,  then recording the new
    font as active AND setting the font's attributes.

Arguments:

    pPDev           Pointer to PDEV
    iNewFont        The font we want, 1 BASED!!!!!
    pfm             Pointer to FONTMAP
    dwFontAttr      Font attribute

Return Value:

     TRUE/FALSE - TRUE if font changed,  else FALSE.

Note:
    12-19-96: Created it -ganeshp-

--*/
{
    FONTPDEV    *pFontPDev;
    POINTL    ptl;  // For size comparisons in scalable fonts
    FWORD     fwdUnitsPerEm, fwdAveCharWidth, fwdMaxCharInc, fwdWinAscender;
    BOOL      bRet; // What we return

    bRet = TRUE;
    pFontPDev = PFDV;
    fwdAveCharWidth = 0;
    fwdUnitsPerEm   = 0;
    fwdWinAscender  = 0;

    //
    // First check to see if a new font is needed.   Compare the
    // font index first,  then check if it is a scalable font, and
    // if so,  whether the transform has changed.
    //

    if ( !pfm && !(pfm = PfmGetIt( pPDev, iNewFont )) )
    {
        ASSERTMSG(FALSE,("\nUniFont!BNewFont:Null pfm passed in and PfmGetIt failed\n"));
        return FALSE;
    }

    if( pfm->flFlags & FM_SCALABLE )
    {
        // Device Scalable or TrueType outline download
        //
        // Calculate the new height/width.  If we have the same font AND
        // and the same point size,  we return as all is now done.
        // Otherwise, go through the works.
        //

        if (dwFontAttrib & FONTATTR_SUBSTFONT)
        {
            fwdAveCharWidth = ((FONTMAP_DEV*)(pfm->pSubFM))->fwdFOAveCharWidth;
            fwdUnitsPerEm   = ((FONTMAP_DEV*)(pfm->pSubFM))->fwdFOUnitsPerEm;
            fwdWinAscender  = ((FONTMAP_DEV*)(pfm->pSubFM))->fwdFOWinAscender;
        }
        else // Device font or TT Outline download case
        {
            fwdAveCharWidth = ((IFIMETRICS*)(pfm->pIFIMet))->fwdAveCharWidth;
            fwdUnitsPerEm   = ((IFIMETRICS*)(pfm->pIFIMet))->fwdUnitsPerEm;
            fwdWinAscender  = ((IFIMETRICS*)(pfm->pIFIMet))->fwdWinAscender;
        }

        bRet = BGetPSize( pFontPDev, &ptl, fwdUnitsPerEm, fwdAveCharWidth);

        if( !bRet ||
            pFontPDev->ctl.iFont == iNewFont &&
            pFontPDev->ctl.iSoftFont == (INT)pfm->ulDLIndex &&
            pFontPDev->ctl.ptlScale.x == ptl.x &&
            pFontPDev->ctl.ptlScale.y == ptl.y  )
        {
            bRet = FALSE;
        }
    }
    else
    {
        //
        // Bitmap font. only check indices
        //

        if( (iNewFont == pFontPDev->ctl.iFont) &&
            (pFontPDev->ctl.iSoftFont == (INT)pfm->ulDLIndex  ||
            (INT)pfm->ulDLIndex == -1))
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    //
    // Need to change a font.
    //
    {
#if 0
        VERBOSE(("\n---------Previous font\n"));
        VERBOSE(("iFont        =%d\n", pFontPDev->ctl.iFont));
        VERBOSE(("ulDLIndex    =%d\n", pFontPDev->ctl.iSoftFont));
        VERBOSE(("ptlScale.x   =%d\n", pFontPDev->ctl.ptlScale.x));
        VERBOSE(("ptlScale.y   =%d\n", pFontPDev->ctl.ptlScale.y));

        VERBOSE(("\n         New font\n"));
        if (pfm->flFlags & FM_SCALABLE)
        {
            VERBOSE((" Scalable font\n"));
        }
        else
        {
            VERBOSE((" NonScalable font\n"));
        }
        VERBOSE(("iFont        =%d\n", iNewFont));
        VERBOSE(("ulDLIndex    =%d\n", pfm->ulDLIndex));
        VERBOSE(("ptlScale.x   =%d\n", ptl.x));
        VERBOSE(("ptlScale.y   =%d\n\n", ptl.y));
#endif

        if (BDeselectFont( pPDev, pFontPDev->ctl.pfm, pFontPDev->ctl.iFont) &&
            BUpdateStandardVar(pPDev, pfm, 0, dwFontAttrib, STD_FH|
                                                            STD_FW|
                                                            STD_FB|
                                                            STD_FI|
                                                            STD_FU|
                                                            STD_FS) &&
            pfm->pfnSelectFont( pPDev, pfm, &ptl)      )
        {
            //
            // New font available - so update the red tape
            //

            pFontPDev->ctl.iFont     = (short)iNewFont;
            pFontPDev->ctl.iSoftFont = (INT)pfm->ulDLIndex;
            pFontPDev->ctl.ptlScale  = ptl;
            pFontPDev->ctl.pfm       = pfm;

            //
            // Need to scale syAdj for UPPERLEFT character position fonts.
            //

            if( pfm->flFlags & FM_SCALABLE)
            {
                if ( (pfm->dwFontType == FMTYPE_DEVICE) &&
                     !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
                    {
                        FLOATOBJ fo;
                        int   iTmp;           /* Temporary holding variable */

                        fo = pFontPDev->ctl.eYScale;
                        FLOATOBJ_MulLong(&fo,
                                fwdWinAscender);
                        pfm->syAdj = -(SHORT)FLOATOBJ_GetLong(&fo);
                    }
             }


            //
            //  Set the desired mode info into the FONTPDEV
            //

            if( pfm->dwFontType == FMTYPE_DEVICE &&
                 ((FONTMAP_DEV*)pfm->pSubFM)->fCaps & DF_BKSP_OK )
                pFontPDev->flFlags |= FDV_BKSP_OK;
            else
                pFontPDev->flFlags &= ~FDV_BKSP_OK;

            bRet = BSetFontAttrib( pPDev, 0, dwFontAttrib, TRUE);
        }
        else
            bRet = FALSE;
    }
    else
    //
    // Just change the font attribute
    //
    {
        if (pFontPDev->ctl.dwAttrFlags != dwFontAttrib)
        {
            BUpdateStandardVar(pPDev, pfm, 0, dwFontAttrib, STD_FH|
                                                            STD_FW|
                                                            STD_FB|
                                                            STD_FI|
                                                            STD_FU|
                                                            STD_FS);
            if (!(pfm->dwFontType == FMTYPE_TTOUTLINE) &&
                !(pfm->dwFontType == FMTYPE_TTOEM)      )
            {
                bRet = BSetFontAttrib( pPDev,
                                       pFontPDev->ctl.dwAttrFlags,
                                       dwFontAttrib, FALSE);
            }
        }
    }

    return  bRet;

}


BOOL
BDeselectFont(
    PDEV        *pPDev,
    FONTMAP     *pfm,
    INT         iFont
    )
/*++

Routine Description:
    Issues a deselect command for the given font.

Arguments:

    pPDev           Pointer to PDEV.
    iFont           Font index to be unselected,  1 based

Return Value:

     TRUE/FALSE - FALSE if the command write fails.

Note:
    12-23-96: Created it -ganeshp-

--*/
{
    //
    // iFont < 1: TrueType font case
    // iFont == 0: This is a first call of SelectFont
    //
    // In these cases, just return TRUE;
    //
    if( iFont == INVALID_FONT)
            return  TRUE;

    if( !pfm )
    {
        ASSERTMSG((FALSE),("\nUniFont!BDeselectFont: NULL pfm\n"));
        return   FALSE;
    }

    return  pfm->pfnDeSelectFont(pPDev, pfm);
}


FONTMAP *
PfmGetIt(
    PDEV *pPDev,
    INT   iIndex)
{
    FONTMAP *pfm;

    //
    // Font indexes Less than equal to 0 are for downloaded fonts and greater
    // than 0 ( from 1 ) are for device fonts.
    //

    if (iIndex <= 0)
    {
        DL_MAP  *pdm;

        //
        // Assume +ve from here on.
        //
        iIndex = -iIndex;

        if (NULL != (pdm = PGetDLMapFromIdx ((PFONTPDEV)(pPDev->pFontPDev),iIndex)))
        {
            pfm = pdm->pfm;
        }
        else
        {
            ERR(("PfmGetIf failed\n"));
            pfm = NULL;
        }
    }
    else
    {
        pfm = PfmGetDevicePFM(pPDev, iIndex);
    }

    return pfm;
}

FONTMAP *
PfmGetDevicePFM(
    PDEV   *pPDev,
    INT     iIndex
    )
/*++

Routine Description:
    Returns the address of the FONTMAP structure corresponding to the
    iDLIndex entry of the downloaded GDI fonts.

Arguments:

    pPDev           Pointer to PDEV.
    iFont           Font index to be unselected,  1 based

Return Value:

     The address of the FONTMAP structure; 0 on error.

Note:
    12-23-96: Created it -ganeshp-

--*/
{
    FONTPDEV   *pFontPDev;       /* FM PDEV */
    FONTMAP   *pfm;           /* What we return */
    DL_MAP_LIST  *pdml;       /* The linked list of chunks */


    pFontPDev = pPDev->pFontPDev;
    pfm = NULL;               /* Serious error return value */

    if( iIndex > 0 )
    {
        /*
         *   With lazy fonts,  first check that the font count has
         *  been initialised.  This means that the font infrastructure
         *  has been created,  and so we can then go on to the more
         *  detailed data.
         */

        if( iIndex >= 1 && iIndex <= pPDev->iFonts )
        {
            pfm = (PFONTMAP)((PBYTE)pFontPDev->pFontMap
                     + (SIZEOFDEVPFM() * (iIndex - 1)) );

            if( pfm->pIFIMet == NULL )
            {
                /*  Initialise this particular font  */
                if( !BFillinDeviceFM( pPDev, pfm, iIndex - 1) )
                {
                    pfm = NULL;             /* Bad news */
                }
            }
        }
    }

    return pfm;
}


BOOL
BGetPSize(
    FONTPDEV    *pFontPDev,
    POINTL      *pptl,
    FWORD        fwdUnitsPerEm,
    FWORD        fwdAveCharWidth
    )
/*++

Routine Description:
    Apply the font transform to obtain the point size for this font.

Arguments:

     pFontPDev      Access to font stuff
     pptl               Where to place the results
     pfm                Gross font details

Return Value:

    TRUE/FALSE,   TRUE for success.

Note:
    12-26-96: Created it -ganeshp-

--*/
{


    int   iTmp;           /* Temporary holding variable */
    FLOATOBJ fo;
    PIFIMETRICS   pIFI;   /* Ifimetrics of interest */

    /*
     *   The XFORM gives us the scaling factor from notional
     * to device space.  Notional is based on the fwdEmHeight
     * field in the IFIMETRICS,  so we use that to convert this
     * font height to scan lines.  Then divide by device
     * font resolution gives us the height in inches, which
     * then needs to be converted to point size (multiplication
     * by 72 gives us that).   We actually calculate to
     * hundredths of points, as PCL has this resolution. We
     * also need to round to the nearest quarter point.
     *
     *   Also adjust the scale factors to reflect the rounding of the
     * point size which is applied.
     */

#ifdef   USEFLOATS

    /*   Typically only the height is important: width for fixed pitch */
    iTmp = (int)(0.5 + pFontPDev->ctl.eYScale * fwdUnitsPerEm * 7200) /
                                                pFontPDev->pPDev->ptGrxRes.y;

    /* if the tranform is very small (Less than a quarter of point size)
    * then make it atleast a quarter point. This was causing AV in certain
    * cases.
    */
    if (iTmp < 25)
    {
        WARNING((UniFont!BGetPSize: Too Small Font Size));
        iTmp = 25;
    }

    pptl->y = ((iTmp + 12) / 25) * 25;

    pFontPDev->ctl.eYScale = (pFontPDev->ctl.eYScale * pptl->y) /iTmp;
    pFontPDev->ctl.eXScale = (pFontPDev->ctl.eXScale * pptl->y) /iTmp;

    iTmp = (int)(pFontPDev->ctl.eXScale * fwdAveCharWidth)

   /* if the tranform is very small, so that the width is Less than a 1 pixel,
    * then make it atleast a 1 pixel point. This was causing AV in certain
    * cases.
    */

    if (iTmp < 1)
    {
        iTmp = 1;
    }

    /*   Width factor chars per inch:  fixed pitch fonts only */
    iTmp = (100 *  pFontPDev->pPDev->ptGrxRes.x) / iTmp;

    pptl->x = ((iTmp + 12) / 25) * 25;
#else

    /*   Typically only the height is important: width for fixed pitch */

    fo = pFontPDev->ctl.eYScale;
    FLOATOBJ_MulLong(&fo,fwdUnitsPerEm);
    FLOATOBJ_MulLong(&fo,7200);
    #ifndef WINNT_40 //NT 5.0

    FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

    #else // NT 4.0


    FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

    #endif //!WINNT_40

    iTmp = FLOATOBJ_GetLong(&fo);
    iTmp /= pFontPDev->pPDev->ptGrxRes.y;
    /* if the tranform is very small (Less than a quarter of point size)
     * then make it atleast a quarter point. This was causing AV in certain
     * cases.
     */
    if (iTmp < 25)
    {
        WARNING(("UniFont!BGetPSize: Too Small Font Height, iTmp = %d\n",iTmp));
        iTmp = 25;

    }

    pptl->y = ((iTmp + 12) / 25) * 25;

    
    //
    // If there is any arounding error, disable x position optimization.
    // The optimization code introduces positioning problem on TrueType font.
    //
    if (iTmp != pptl->y)
    {
        pFontPDev->flFlags |= FDV_DISABLE_POS_OPTIMIZE;
    }
    else
    {
        pFontPDev->flFlags &= ~FDV_DISABLE_POS_OPTIMIZE;
    }

    FLOATOBJ_MulLong(&pFontPDev->ctl.eYScale,pptl->y);
    FLOATOBJ_DivLong(&pFontPDev->ctl.eYScale,iTmp);

    FLOATOBJ_MulLong(&pFontPDev->ctl.eXScale,pptl->y);
    FLOATOBJ_DivLong(&pFontPDev->ctl.eXScale,iTmp);

    /*   Width factor:  fixed pitch fonts only */
    fo = pFontPDev->ctl.eXScale;
    FLOATOBJ_MulLong(&fo,fwdAveCharWidth);

    iTmp = FLOATOBJ_GetLong(&fo);

   /* if the tranform is very small, so that the width is Less than a 1 pixel,
    * then make it atleast a 1 pixel point. This was causing AV in certain
    * cases.
    */

    if (iTmp < 1)
    {
        iTmp = 1;

    }

    /*   Width factor chars per inch in 100s:  fixed pitch fonts only */
    iTmp = (100 * pFontPDev->pPDev->ptGrxRes.x) / iTmp;

    pptl->x = ((iTmp + 12) / 25) * 25;      /* To nearest quarter point */

#endif

    return  TRUE;

}




INT
ISetScale(
    FONTCTL    *pctl,
    XFORMOBJ   *pxo,
    BOOL       bIntellifont,
    BOOL       bAnyRotation
)
/*++

Routine Description:
    Looks at the XFORM to determine the nearest right angle direction.
    This function is useful for scalable fonts on LaserJet printers,
    where the device can rotate fonts in multiples of 90 degrees only.
    We select the nearest 90 degree multiple.

Arguments:

    pctl            Where the output is placed.
    pxo             The transform of interest
    bIntellifont    TRUE for Intellifont width adjustment

Return Value:

    Printer is able rotate any rotation (bAnyRotation is TRUE)
        Degress (0 - 359)

    Printer is not able rotate any rotation (bAnyRotation is FALSE)
        Multiple of 90 degress,  i.e.  0 - 3, 3 being 270 degrees.

Note:
    12-26-96: Created it -ganeshp-

--*/
{

    /*
     *    The technique is quite simple.  Take a vector and apply the
     *  transform.  Look at the output and compare the (x, y) components.
     *  The vector to transform is (100 000,  0), so any rotations, shears
     *  etc are very obvious.
     */

    int      iRet;                /* Value to return */

#ifdef USEFLOATS

    XFORM xform;         /* Obtain the full XFORM then select */

    XFORMOBJ_iGetXform( pxo, &xform );


    /*
     *     This logic is based on the following data:-
     *
     *   Angle    eM11     eM12     eM21      eM22
     *      0       S        0        0         S
     *     90       0       -S        S         0
     *    180      -S        0        0        -S
     *    270       0        S       -S         0
     *
     *  The value S is some non-zero value,  being the scaling
     *  factor from notional to device.
     */



    /*
     *   Further notes on the eXScale and eYScale values.  The eXScale field
     *  is hereby defined as being the value by which x values in font metrics
     *  are scaled to produce the desired value.  IF the font is rotated
     *  by either 90 or 270 degrees,  then this x value ultimately ends up
     *  in the y direction,  but this is not important.
     */

    if( xform.eM11 )
    {
        /*   Either 0 or 180 rotation  */

        if( xform.eM11 > 0 )
        {
            /*   Normal case,  0 degree rotation */
            iRet = 0;
            pctl->eXScale = xform.eM11;
            pctl->eYScale = xform.eM22;
        }
        else
        {
            /*   Reverse case,  180 degree rotation */
            iRet = 2;
            pctl->eXScale = -xform.eM11;
            pctl->eYScale = -xform.eM22;
        }
    }
    else
    {
        /*  Must be 90 or 270 degree rotation */

        if( xform.eM12 < 0 )
        {
            /*   The 90 degree case  */
            iRet = 1;
            pctl->eXScale = xform.eM21;
            pctl->eYScale = -xform.eM12;
        }
        else
        {
            /*   The 270 degree case  */
            iRet = 3;
            pctl->eXScale = -xform.eM21;
            pctl->eYScale = xform.eM12;
        }
    }

    /*
     *    Width tables are based on Intellifont's 72.31 points to the inch.
     */

    if( bIntellifont )
        pctl->eXScale = pctl->eXScale * (FLOAT)72.0 / (FLOAT)72.31;

    return  iRet;

#else

    FLOATOBJ_XFORM xform;         /* Obtain the full XFORM then select */

    XFORMOBJ_iGetFloatObjXform( pxo, &xform );


    /*
     *     This logic is based on the following data:-
     *
     *   Angle    eM11     eM12     eM21      eM22
     *      0       S        0        0         S
     *     90       0       -S        S         0
     *    180      -S        0        0        -S
     *    270       0        S       -S         0
     *
     *  The value S is some non-zero value,  being the scaling
     *  factor from notional to device.
     */



    /*
     *   Further notes on the eXScale and eYScale values.  The eXScale field
     *  is hereby defined as being the value by which x values in font metrics
     *  are scaled to produce the desired value.  IF the font is rotated
     *  by either 90 or 270 degrees,  then this x value ultimately ends up
     *  in the y direction,  but this is not important.
     */

    if(!FLOATOBJ_EqualLong(&xform.eM11,0) )
    {
        double rotate;

        //
        // R != 90 & R != 270
        // 

        if( FLOATOBJ_GreaterThanLong(&xform.eM11,0) )
        {
            //
            // 0 <= R  < 90 or 270 < R <= 360
            //
            if (FLOATOBJ_EqualLong(&xform.eM21, 0))
            {
                //
                // R = 0
                //
                iRet = 0;
            }
            else
            if (FLOATOBJ_GreaterThanLong(&xform.eM21, 0))
            {
                //
                // 0 < R < 90
                //
                    iRet = 0;
            }
            else
            {
                //
                // 270 < R < 360
                //
                if (bAnyRotation)
                    iRet = 270;
                else
                    iRet = 3;
            }

#ifndef WINNT_40 // NT 5.0
            if (bAnyRotation)
            {
#pragma warning( disable: 4244)
                        rotate = atan2(xform.eM21, xform.eM11);
                        rotate *= 180;
                        rotate /= FLOATL_PI;
                        if (rotate < 0)
                            rotate += 360;
                        iRet = rotate;
#pragma warning( default: 4244)
            }
#endif

        }
        else
        {
            //
            // 90 < R < 270
            //

            if ( FLOATOBJ_EqualLong(&xform.eM21, 0))
            {
                //
                // R = 180
                //
                if (bAnyRotation)
                    iRet = 180;
                else
                    iRet = 2;
            }
            else
            if ( FLOATOBJ_GreaterThanLong(&xform.eM21, 0))
            {
                //
                // 90 < R < 180
                // 
                if (bAnyRotation)
                    iRet = 90;
                else
                    iRet = 1;
            }
            else
            {
                //
                // 180 < R < 270
                //
                if (bAnyRotation)
                    iRet = 180;
                else
                    iRet = 2;
            }

#ifndef WINNT_40 // NT 5.0
            if (bAnyRotation)
            {
#pragma warning( disable: 4244)
                        rotate = atan2(xform.eM21, xform.eM11);
                        rotate *= 180;
                        rotate /= FLOATL_PI;
                        if (rotate < 0)
                            rotate += 360;
                        iRet = rotate;
#pragma warning( default: 4244)
            }
#endif

            FLOATOBJ_Neg(&xform.eM11);
            FLOATOBJ_Neg(&xform.eM22);

        }

#ifndef WINNT_40 // NT 5.0
        if (bAnyRotation)
        {
#pragma warning( disable: 4244)
            pctl->eXScale = sqrt(xform.eM11 * xform.eM11 + xform.eM12 * xform.eM12);
            pctl->eYScale = sqrt(xform.eM22 * xform.eM22 + xform.eM21 * xform.eM21);
#pragma warning( default: 4244)
        }
        else
#endif
        {
            pctl->eXScale = xform.eM11;
            pctl->eYScale = xform.eM22;
        }
    }
    else
    {
        //
        // 90 or 270
        //

        if( FLOATOBJ_GreaterThanLong(&xform.eM21,0) )
        {
            //
            // 90
            //
            if (bAnyRotation)
                iRet = 90;
            else
                iRet = 1;

            FLOATOBJ_Neg(&xform.eM12);
        }
        else
        {
            //
            // 270
            //
            if (bAnyRotation)
                iRet = 270;
            else
                iRet = 3;

            FLOATOBJ_Neg(&xform.eM21);
        }

        pctl->eXScale = xform.eM12;
        pctl->eYScale = xform.eM21;
    }

    /*
     *    Width tables are based on Intellifont's 72.31 points to the inch.
     */

    if( bIntellifont )
    {
        FLOATOBJ_MulLong(&pctl->eXScale,72);

        #ifndef WINNT_40 //NT 5.0

        FLOATOBJ_DivFloat(&pctl->eXScale,(FLOATL)FLOATL_72_31);

        #else // NT 4.0

        FLOATOBJ_DivFloat(&pctl->eXScale,(FLOAT)72.31);

        #endif //!WINNT_40

    }

    return  iRet;

#endif //USEFLOATS
}


VOID
VSetRotation(
    FONTPDEV *pFontPDev,
    int       iRot
    )
/*++

Routine Description:
    Function to set the angular rotation for PCL 5 printers.  These allow
    fonts to be rotated in multiples of 90 degrees relative to graphics.

Arguments:

    pFontPDev       Pointer to FONTPDEV.
    iRot            Rotation amount, range 0 to 3.

Return Value:

    TRUE/FALSE,   TRUE being that the data was queued to be sent OK.

Note:
    12-26-96: Created it -ganeshp-

--*/
{
    PDEV   *pPDev = pFontPDev->pPDev;

    if( iRot != pFontPDev->ctl.iRotate )
    {
        /*  Rotation angle is different,  so change it now */
        COMMAND *pCmd = NULL;

        if (pFontPDev->flFlags & FDV_90DEG_ROTATION)
        {
            pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION);
        }
        else if ((pFontPDev->flFlags & FDV_ANYDEG_ROTATION))
        {
            pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION);
        }


        if (pCmd)
        {
            pFontPDev->ctl.iRotate = iRot;
            BUpdateStandardVar(pPDev, NULL, 0, 0, STD_PRND);
            WriteChannel(pPDev, pCmd);
        }
    }
}

BOOL
BSetFontAttrib(
    PDEV  *pPDev,
    DWORD  dwPrevAttrib,
    DWORD  dwAttrib,
    BOOL   bReset)
{
    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    PCOMMAND pBoldCmd      = NULL,
             pItalicCmd    = NULL,
             pUnderlineCmd = NULL;

    if (! (pFontPDev->flFlags & FDV_INIT_ATTRIB_CMD))
    {
        pFontPDev->pCmdBoldOn = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDON);
        pFontPDev->pCmdBoldOff = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDOFF);
        pFontPDev->pCmdItalicOn = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICON);
        pFontPDev->pCmdItalicOff = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICOFF);
        pFontPDev->pCmdUnderlineOn = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEON);
        pFontPDev->pCmdUnderlineOff = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEOFF);
        pFontPDev->pCmdClearAllFontAttribs = COMMANDPTR(pPDev->pDriverInfo, CMD_CLEARALLFONTATTRIBS);
        pFontPDev->flFlags |= FDV_INIT_ATTRIB_CMD;
    }

    //
    // pCmdBoldOn,Off, pCmdItalicOn,Off, pCmdUnderlineOn,Off
    // and pCmdClearAllFont Attribs are initialized in PDEV initialization.
    //
    if (!pFontPDev->pCmdBoldOn &&
        !pFontPDev->pCmdItalicOn &&
        !pFontPDev->pCmdUnderlineOn)
    {
        //
        // This printer doesn't support font attributes.
        //
        return TRUE;
    }

    if (bReset || (dwAttrib & FONTATTR_BOLD) != (dwPrevAttrib & FONTATTR_BOLD))
    {
        if(dwAttrib & FONTATTR_BOLD)
            pBoldCmd = pFontPDev->pCmdBoldOn;
        else
            pBoldCmd = pFontPDev->pCmdBoldOff;
    }

    if (bReset || (dwAttrib & FONTATTR_ITALIC) != (dwPrevAttrib & FONTATTR_ITALIC))
    {
        if(dwAttrib & FONTATTR_ITALIC)
            pItalicCmd = pFontPDev->pCmdItalicOn;
        else
            pItalicCmd = pFontPDev->pCmdItalicOff;
    }

    if (bReset || (dwAttrib & FONTATTR_UNDERLINE) != (dwPrevAttrib & FONTATTR_UNDERLINE))
    {
        if (dwAttrib & FONTATTR_UNDERLINE)
            pUnderlineCmd = pFontPDev->pCmdUnderlineOn;
        else
            pUnderlineCmd = pFontPDev->pCmdUnderlineOff;
    }

    if (
        pFontPDev->pCmdClearAllFontAttribs
            &&
        (bReset ||
         (pFontPDev->pCmdBoldOn && !pFontPDev->pCmdBoldOff)           ||
         (pFontPDev->pCmdItalicOn && !pFontPDev->pCmdItalicOff)       ||
         (pFontPDev->pCmdUnderlineOn && !pFontPDev->pCmdUnderlineOff)
        )
       )
    {
        WriteChannel(pPDev, pFontPDev->pCmdClearAllFontAttribs);
        //
        // Reset all font attributes
        //
        if (dwAttrib & FONTATTR_BOLD)
            pBoldCmd = pFontPDev->pCmdBoldOn;
        if (dwAttrib & FONTATTR_ITALIC)
            pItalicCmd = pFontPDev->pCmdItalicOn;
        if (dwAttrib & FONTATTR_UNDERLINE)
            pBoldCmd = pFontPDev->pCmdUnderlineOn;
    }

    if (pBoldCmd)
        WriteChannel(pPDev, pBoldCmd);
    if (pItalicCmd)
        WriteChannel(pPDev, pItalicCmd);
    if (pUnderlineCmd)
        WriteChannel(pPDev, pUnderlineCmd);

    ((FONTPDEV*)pPDev->pFontPDev)->ctl.dwAttrFlags = dwAttrib;

    return TRUE;
}

INT
IGetGlyphWidth(
    PDEV    *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    )
/*++

Routine Description:
    Function to get the width of a given Glyph.

    Arguments:
    pFM,              Font data .
    hg                Handle to glyph.

Return Value:

    Scaled width wrt the current graphics resolution of a glyph.
    This width is in notional space and must be transformed to
    device space.

Note:
    12-26-96: Created it -ganeshp-

--*/
{
    if( pFM->flFlags & FM_GLYVER40 )
    {
        //
        // Old Format
        // This function return scaled width for fixed-pitch and proportioanl
        // pitch font.
        //

        return IGetIFIGlyphWidth(pPDev, pFM, hg);

    }
    else
    {
        //
        // New Format
        // This function return scaled width for fixed-pitch and proportioanl
        // pitch font.
        //

        return IGetUFMGlyphWidth(pPDev, pFM, hg);

    }

}

LONG LMulFloatLong(
    PFLOATOBJ pfo,
    LONG l)
/*++

Routine Description:
    Helper Function to multiply a Float with a long.

    Arguments:
    pfo,              Float data .
    l                 Long data.

Return Value:

    Returns a long data.

Note:
    12-29-96: Created it -ganeshp-

--*/
{
    FLOATOBJ fo;
    fo = *pfo;
    FLOATOBJ_MulLong(&fo,l);

    #ifndef WINNT_40 //NT 5.0

    FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

    #else // NT 4.0

    FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

    #endif //!WINNT_40

    return(FLOATOBJ_GetLong(&fo));
}


BOOL
BUpdateStandardVar(
    PDEV       *pPDev,
    PFONTMAP    pfm,
    INT         iGlyphIndex,
    DWORD       dwFontAtt,
    DWORD       dwFlags)
/*++

Routine Description:

    Updates GPD standard variable according to the pFontMap passed.

Arguments:
    pPDev       - a pointer to the physical device
    pfm         - a pointer to the FONTMAP data structure
    iGlyphIndex - an index of glyph
    dwFontAtt   - a font attribute
    dwFlags     - a type of standard variable

Return Value:
    TRUE if suceeded. Otheriwse FALSE;

--*/

{
    FONTPDEV *pFontPDev;
    IFIMETRICS *pIFIMet;
    FLOATOBJ  fo;

    //VERBOSE(("BUpdateStandardVar dwFlags=%x\n",dwFlags));

    pFontPDev = pPDev->pFontPDev;

    //
    // Update standard variables
    //
    // Font related variables
    // ---------------------------------------------------
    // NextGlyph         TT Download        STD_GL
    // FontHeight        TT/Device font     STD_FH
    // FontWidth         TT/Device font     STD_FW
    // FontBold          TT/Device font     STD_FB
    // FontItalic        TT/Device font     STD_FI
    // FontUnderline     TT/Device font     STD_FU
    // FontStrikeThru    TT/Device font     STD_FS
    // NextFontID        TT Download        STD_NFID
    // CurrentFontID     TT Download        STD_CFID
    // PrintDirection    TT/Device font     STD_PRND
    //
    // STD_STD = STD_GL| STD_FH| STD_FW| STD_FB| STD_FI| STD_FU| STD_FS
    // STD_TT  = STD_NFID| STD_CFID| STD_PRND
    //

    if (pfm)
    {
        pIFIMet = (IFIMETRICS *) pfm->pIFIMet;

        //
        // TT Outline has to be scaled as well as device font.
        //if (pfm->dwFontType == FMTYPE_TTBITMAP)
        //
        if (pIFIMet->flInfo & FM_INFO_TECH_TRUETYPE)
        {
            //
            // FontHeight
            //
            if (dwFlags & STD_FH)
            {
                pPDev->dwFontHeight = (WORD)( max(pIFIMet->rclFontBox.top,
                    pIFIMet->fwdWinAscender) -
                    min(-pIFIMet->fwdWinDescender,
                    pIFIMet->rclFontBox.bottom ) +
                    1);
                pPDev->dwFontHeight *= pPDev->ptGrxScale.y;
            }

            //
            // FontWidth
            //
            if (dwFlags & STD_FW)
            {
                //
                // FontMaxWidth update
                //
                pPDev->dwFontMaxWidth = pIFIMet->fwdMaxCharInc;
                pPDev->dwFontMaxWidth *= pPDev->ptGrxScale.x;

                //
                // FontWidth update
                //
                pPDev->dwFontWidth = max(pIFIMet->rclFontBox.right -
                  pIFIMet->rclFontBox.left + 1,
                  pIFIMet->fwdAveCharWidth );
                pPDev->dwFontWidth *= pPDev->ptGrxScale.x;
            }
        }
        else
        {
            //
            // FontHeight
            //
            if (dwFlags & STD_FH)
            {
                fo = pFontPDev->ctl.eYScale;
                if (dwFontAtt & FONTATTR_SUBSTFONT)
                {
                    FLOATOBJ_MulLong(&fo, ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOUnitsPerEm);
                }
                else
                    FLOATOBJ_MulLong(&fo, pIFIMet->fwdUnitsPerEm);

                FLOATOBJ_MulLong(&fo, pPDev->ptGrxScale.y);
                pPDev->dwFontHeight = FLOATOBJ_GetLong(&fo);
            }

            //
            // FontWidth
            //
            if (dwFlags & STD_FW)
            {
                //
                // FontWidth update
                //
                fo = pFontPDev->ctl.eXScale;
                if (dwFontAtt & FONTATTR_SUBSTFONT)
                {
                    FLOATOBJ_MulLong(&fo,((FONTMAP_DEV*)pfm->pSubFM)->fwdFOAveCharWidth);
                }
                else
                    FLOATOBJ_MulLong(&fo, pIFIMet->fwdAveCharWidth);
                FLOATOBJ_MulLong(&fo, pPDev->ptGrxScale.x);
                pPDev->dwFontWidth  = FLOATOBJ_GetLong(&fo);

                //
                // FontMaxWidth update
                //
                fo = pFontPDev->ctl.eXScale;
                if (dwFontAtt & FONTATTR_SUBSTFONT)
                {
                    FLOATOBJ_MulLong(&fo,((FONTMAP_DEV*)pfm->pSubFM)->fwdFOMaxCharInc);
                }
                else
                    FLOATOBJ_MulLong(&fo, pIFIMet->fwdMaxCharInc);
                FLOATOBJ_MulLong(&fo, pPDev->ptGrxScale.x);
                pPDev->dwFontMaxWidth  = FLOATOBJ_GetLong(&fo);
            }
        }
    }
    //
    //
    // Font attributes, dwFontBold
    //                  dwFontItalic
    //
    if (dwFlags & STD_FB)
        pPDev->dwFontBold       = dwFontAtt & FONTATTR_BOLD;

    if (dwFlags & STD_FI)
        pPDev->dwFontItalic     = dwFontAtt & FONTATTR_ITALIC;

    //
    // TrueType font font ID/glyph ID
    //
    if (dwFlags & STD_NFID && NULL != pfm)
        pPDev->dwNextFontID = pfm->ulDLIndex;
    else
        pPDev->dwNextFontID = 0;

    //
    // Glyph ID
    //
    if (dwFlags & STD_GL)
        pPDev->dwNextGlyph = iGlyphIndex;

    //
    // String rotation
    //
    if (dwFlags & STD_PRND)
    {
        if (!(pFontPDev->flText & TC_CR_ANY))
            pPDev->dwPrintDirection = pFontPDev->ctl.iRotate * 90;
        else
            pPDev->dwPrintDirection = pFontPDev->ctl.iRotate;
    }

    //
    // Font ID
    //
    if (dwFlags & STD_CFID)
        pPDev->dwCurrentFontID = pfm->ulDLIndex;

    return TRUE;
}

INT
IFont100toStr(
    BYTE   *pjOut,
    int     iVal
    )
/*++

Routine Description:
     Convert a font size parameter to ASCII.  Note that the value is
     100 times its actual value,  and we need to include the decimal
     point and trailing zeroes should these be significant.

Arguments:

    BYTE    pjOut     Output area
    int     iVal      Value to convert

Return Value:

     Number of bytes added to output buffer.

Note:
    12-26-96: Created it -ganeshp-

--*/
{

    int    iSize;          /* Count bytes placed in output area */
    int    cDigits;        /* Count number of digits processed */
    BYTE  *pjConv;         /* For stepping through local array */
    BYTE   ajConv[ 16 ];   /* Local conversion buffer */

    /*
     *   Convert the value into ASCII,  remembering that there are
     *  two digits following the decimal point; these need not be
     *  sent if they are zero.
     */

    pjConv = ajConv;
    cDigits = 0;

    while( iVal > 0 || cDigits < 3 )
    {
        *pjConv++ = (iVal % 10) + '0';
        iVal /= 10;
        ++cDigits;

    }

    iSize = 0;
    while( cDigits > 2 )
    {
        pjOut[ iSize++ ] = *--pjConv; /* Backwards from MSD */
        --cDigits;
    }

    /*   Test for digits following the decimal point */
    if( ajConv[ 1 ] != '0' || ajConv[ 0 ] != '0' )
    {
        pjOut[ iSize++ ] = '.';
        pjOut[ iSize++ ] = ajConv[ 1 ];

        /*  Test for the least significant digit */
        if( ajConv[ 0 ] != '0' )
            pjOut[ iSize++ ] = ajConv[ 0 ];

    }

    return    iSize;
}

VOID
VSetCursor(
    IN  PDEV   *pPDev,
    IN  INT     iX,
    IN  INT     iY,
    IN  WORD    wMoveType,
    OUT POINTL *pptlRem
    )
/*++
Routine Description:
    This routine set the absolute cursor position.
Arguments:
    pPDev       Pointer to PDEV
    iX, iY      Input cursor position to move
    wMoveType   Type of the input Value, MOVE_RELATIVE, MOVE_ABSOLUTE or
                MOVE_UPDATE
    pptlRem     Remainder part which couldn't be moved. Return values from XMoveTo
                and YMoveTo.

Return Value:
    None
Note:

    8/12/1997 -ganeshp-
        Created it.
--*/
{
    FONTPDEV *pFontPDev;
    TO_DATA  *pTod;
#if defined(_M_IA64) // NTBUG #206444 (203236)
    volatile
#endif
    WORD      wUpdate = 0;

    pFontPDev = pPDev->pFontPDev;
    pTod = pFontPDev->ptod;

    if (wMoveType & MOVE_UPDATE)
    {
        wUpdate = MV_UPDATE;
    }


    if (wMoveType & MOVE_ABSOLUTE)
    {
        //
        //Transform the input X and Y from band coordinates to page coordinates.
        //
        iX += pPDev->rcClipRgn.left;
        iY += pPDev->rcClipRgn.top;


        pptlRem->y = YMoveTo( pPDev, iY, MV_GRAPHICS | wUpdate );

        if (pPDev->fMode & PF_ROTATE)
            pptlRem->x = XMoveTo( pPDev, iX, MV_GRAPHICS | wUpdate);
        else
            pptlRem->x = XMoveTo( pPDev, iX, MV_GRAPHICS | MV_FINE | wUpdate);

    }
    else if (wMoveType & MOVE_RELATIVE)
    {

        //
        // if we are moving relative then no need to do the transform. Just
        // call XMoveTo and YMoveTo
        //

        pptlRem->x = XMoveTo( pPDev, iX, MV_GRAPHICS | MV_RELATIVE | wUpdate);
        pptlRem->y = YMoveTo( pPDev, iY, MV_GRAPHICS | MV_RELATIVE | wUpdate);

    }

    //
    // If PF_RESELECTFONT_AFTER_XMOVE is set, UNIDRV has to reset font after
    // XMoveTo command.
    //
    if (pFontPDev->ctl.iFont == INVALID_FONT)
    {
        BNewFont(pPDev,
                 (pTod->iSubstFace?pTod->iSubstFace:pTod->iFace),
                 pTod->pfm,
                 pTod->dwAttrFlags);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\oldfonts.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    oldfont.c

Abstract:

    Implementation of the functions to use NT4.0 font format.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/02/97 -eigos-
        Created

--*/

#include "font.h"

//
// Macro
//

#define ADDR_CONV(x)    ((BYTE *)pFDH + pFDH->x)

ULONG UlCharsetToCodepage(
        BYTE ubCharSet)
{
    CHARSETINFO CharsetInfo;
    
    //
    // Initialize CharsetInfo
    // 
    CharsetInfo.ciCharset = 0;
    CharsetInfo.ciACP = 1252;
    CharsetInfo.fs.fsUsb[0] = 0x01;
    CharsetInfo.fs.fsUsb[1] = CharsetInfo.fs.fsUsb[2] = CharsetInfo.fs.fsUsb[3] = 0;
    CharsetInfo.fs.fsCsb[0] = 0x01;
    CharsetInfo.fs.fsCsb[1] = CharsetInfo.fs.fsCsb[2] = CharsetInfo.fs.fsCsb[3] =  0;

    PrdTranslateCharsetInfo((UINT)ubCharSet, &CharsetInfo, TCI_SRCCHARSET);
    return CharsetInfo.ciACP;
}

BOOL
BGetOldFontInfo(
    FONTMAP   *pfm,
    BYTE      *pRes
    )
/*++

Routine Description:

    Fill in the FONTMAP data using the NT format data passed to us.
    There is not too much for us to do,  since the NT data is
    all in the desired format.  However,  we do have to update some
    addresses.

Arguments:

    pfm - Pointer to FONTMAP.

    pRes - Pointer to Font Resource.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-05-96: Created it -ganeshp-
--*/
{

    FI_DATA_HEADER  *pFDH;
    FONTMAP_DEV     *pfmdev;

    ASSERT(pfm != NULL &&
           pRes != NULL &&
           pfm->dwFontType == FMTYPE_DEVICE &&
           pfm->flFlags & FM_IFIVER40);

    pfmdev = pfm->pSubFM;

    pfmdev->pvFontRes = pRes;

    //
    // Old Format Data
    //
    pFDH = (FI_DATA_HEADER *)pRes;

    //
    //   Verify that there is some semblance of correctness
    //
    if( pFDH->cjThis != sizeof( FI_DATA_HEADER ) )
    {
        ERR(( "BGetOldFontInfo: invalid FI_DATA_HEADER\n" ));
        return  FALSE;
    }

    //
    //  Mark this data as being in a resource
    //
    pfm->flFlags |= (FM_IFIRES | FM_FONTCMD);


    pfm->pIFIMet = (IFIMETRICS *)ADDR_CONV( dwIFIMet );

    if (!(pfm->flFlags & FM_SOFTFONT))
    {
        if( pFDH->dwCDSelect )
        {
            pfmdev->cmdFontSel.pCD = (CD *)ADDR_CONV( dwCDSelect );
            ASSERT(pfmdev->cmdFontSel.pCD);
        }

        if( pFDH->dwCDDeselect )
        {
            pfmdev->cmdFontDesel.pCD = (CD *)ADDR_CONV( dwCDDeselect );
            ASSERT(pfmdev->cmdFontDesel.pCD);
        }

    }

    if( pFDH->dwETM )
    {
        pfmdev->pETM = (EXTTEXTMETRIC *)ADDR_CONV( dwETM );
    }

    if( pFDH->dwWidthTab )
    {
        pfmdev->W.psWidth = (short *)ADDR_CONV( dwWidthTab );
        pfm->flFlags |= FM_WIDTHRES;             /* Width vector too! */
    }

    /*
     *    Miscellaneous odds & ends.
     */

    pfmdev->ulCodepage = UlCharsetToCodepage(pfm->pIFIMet->jWinCharSet);

    pfmdev->sCTTid    = pFDH->u.sCTTid;
    pfmdev->fCaps     = pFDH->fCaps;
    pfmdev->wDevFontType = pFDH->wFontType;
    pfm->wXRes        = pFDH->wXRes;
    pfm->wYRes        = pFDH->wYRes;
    pfmdev->sYAdjust  = pFDH->sYAdjust;
    pfmdev->sYMoved   = pFDH->sYMoved;

    return  TRUE;
}


BOOL
BRLEOutputGlyph(
    TO_DATA *pTod
    )
/*++

Routine Description:
    Send printer commands to print the glyph passed in.  Basically
    we do the translation from ANSI to the printer's representation,

Arguments:
    hg      HGLYPH of interest

Return Value:
    TRUE for success and FALSE for failure.FALSE being a failure of Spool

Note:

    1/22/1997 -ganeshp-
        Created it.
--*/

{
    PDEV        *pPDev;         // UNIDRV PDEV
    FONTPDEV    *pFontPDev;     // Font PDEV
    FONTMAP_DEV *pFMDev;        // Device font PDEV
    FONTMAP     *pFM;           // Fontmap data structure
    NT_RLE      *pntrle;        // Access to data to send to printer
    COMMAND     *pCmd;          // Command Pointer
    PGLYPHPOS    pgp;
    POINTL       ptlRem;

    HGLYPH       hg;
    UHG          uhg;           // Various flavours of HGLYPH contents
    INT          iLen;          // Length of string
    INT          iIndex;        // Index from glyph to width table
    INT          cGlyphs;
    INT          iX, iY, iXInc, iYInc;
    BYTE        *pb;            // Determining length for above
    BOOL         bRet;          // Returned to caller
    BOOL         bSetCursorForEachGlyph;

    ASSERT(pTod);

    pPDev     = pTod->pPDev;
    pFontPDev = pPDev->pFontPDev;
    pFM       = pTod->pfm;
    pFMDev    = pFM->pSubFM;
    pntrle    = pFMDev->pvNTGlyph;
    cGlyphs   = pTod->cGlyphsToPrint;
    pgp       = pTod->pgp;

    ASSERT(pPDev && pFontPDev && pFM && pFMDev && pntrle && pgp);

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    if (!bSetCursorForEachGlyph)
        VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

    pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;

    bRet = FALSE;               /* Default case */
    iX = iY = 0;

    while (cGlyphs --)
    {
        hg = uhg.hg = pgp->hg;     /* Lets us look at it however we want */
        iX = pgp->ptl.x;
        iY = pgp->ptl.y;

        //
        // Move to the next character's position
        //
        if (bSetCursorForEachGlyph)
            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

        if( pntrle )
        {
            /*   The normal case - a standard device font */

            switch( pntrle->wType )
            {
            case RLE_DIRECT:            /*  Up to 2 bytes of data */
                iLen = uhg.rd.b1 ? 2 : 1;
                iIndex = uhg.rd.wIndex;

                bRet = WriteSpoolBuf( pPDev, &uhg.rd.b0, iLen ) == iLen;

                break;

            case  RLE_PAIRED:           /* Two glyphs (1 byte), overstruck */
                /*
                 *   First, try to use cursor push/pop escapes to
                 * overlay the 2 characters. If they are not
                 * available, try the backspace. If it doesn't exist
                 * either, ignore the second character.
                 */

                pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_PUSHCURSOR);

                if ( uhg.rd.b1 && (pCmd != NULL) )
                {
                    /* Pushed the position; output ch1, pop position, ch2 */
                    bRet = WriteSpoolBuf( pPDev, &uhg.rd.b0, 1 ) == 1;
                    WriteChannel( pPDev, pCmd );
                    bRet = WriteSpoolBuf( pPDev, &uhg.rd.b1, 1 ) == 1;
                }
                else
                {
                    pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_BACKSPACE);

                    bRet = WriteSpoolBuf( pPDev, &uhg.rd.b0, 1 ) == 1;
                    if( uhg.rd.b1 && (pFontPDev->flFlags & FDV_BKSP_OK) )
                    {
                        WriteChannel( pPDev, pCmd );
                        bRet = WriteSpoolBuf( pPDev, &uhg.rd.b1, 1 ) == 1;
                    }
                }
                iIndex = uhg.rd.wIndex;

                break;

            case  RLE_LI_OFFSET:               /* Compact format of offset mode */
                if( uhg.rli.bLength <= 2 )
                {
                    /*   Compact format:  the data is in the offset field */
                    pb = &uhg.rlic.b0;
                }
                else
                {
                    /*  Standard format:  the offset points to the data */
                    pb = (BYTE *)pntrle + uhg.rli.wOffset;
                }
                iLen = uhg.rli.bLength;
                iIndex = uhg.rli.bIndex;

                bRet = WriteSpoolBuf(pPDev, pb, iLen ) == iLen;
                break;


            case  RLE_L_OFFSET:                /* Arbitrary length strings */
                /*
                 *    The HGLYPH contains a 3 byte offset from the beginning of
                 *  the memory area,  and a 1 byte length field.
                 */
                pb = (BYTE *)pntrle + (hg & 0xffffff);
                iLen = (hg >> 24) & 0xff;

                iIndex = *((WORD *)pb);
                pb += sizeof( WORD );

                bRet = WriteSpoolBuf(pPDev, pb, iLen ) == iLen;

                break;

            default:
                ERR(( "Rasdd!bOutputGlyph: Unknown HGLYPH format %d\n",
                                                                  pntrle->wType ));
                SetLastError( ERROR_INVALID_DATA );
                break;
            }
        }

        //
        // After drawing the character, in the printer, the cursor position
        // moves. Update the UNIDRV internal value to reduce the amount of
        // command to send.
        //
        if (bSetCursorForEachGlyph)
        {
            if( pFMDev->W.psWidth)
            {
                iXInc = pFMDev->W.psWidth[iIndex];
                iXInc = iXInc * pPDev->ptGrxRes.x / pFM->wXRes;
            }
            else
                iXInc = ((IFIMETRICS *)(pFM->pIFIMet))->fwdMaxCharInc;

            if( pFM->flFlags & FM_SCALABLE )
            {
                iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
            }

            if (pTod->flAccel & SO_VERTICAL)
            {
                iYInc = iXInc;
                iXInc = 0;
            }
            else
            {
                iYInc = 0;
            }

            VSetCursor( pPDev,
                        iXInc,
                        iYInc,
                        MOVE_RELATIVE|MOVE_UPDATE,
                        &ptlRem);
        }

        pgp ++;
    }

    /*
     *    If the output succeeded,  update our view of the printer's
     *  cursor position.  Typically,  this will be to move along the
     *  width of the glyph just printed.
     */

    if( bRet && pFM)
    {
        //
        // Output may have succeeded,  so update the position for default
        // placement.
        //

        if( !bSetCursorForEachGlyph)
        {
            if( pFMDev->W.psWidth )
            {
                /*
                 *    Proportional font - so use the width table.  Note that
                 *  it will also need scaling,  since the fontwidths are stored
                 *  in the text resolution units.
                 */
                /*  This also scales correctly for downloaded fonts */

                iXInc =  pFMDev->W.psWidth[iIndex];
                iXInc = iXInc * pPDev->ptGrxRes.x / pFM->wXRes;
            }
            else
            {
                /*
                 *   Fixed pitch font - metrics contains the information. NOTE
                 * that scaling is NOT required here,  since the metrics data
                 * has already been scaled.
                 */
                iXInc = ((IFIMETRICS *)(pFM->pIFIMet))->fwdMaxCharInc;
            }

            if( pFM->flFlags & FM_SCALABLE )
            {
                iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
            }

            if (pTod->flAccel & SO_VERTICAL)
            {
                iYInc = iXInc;
                iXInc = 0;
            }
            else
            {
                iYInc = 0;
            }

            VSetCursor( pPDev,
                        (iX + iXInc) - pTod->pgp->ptl.x,
                        (iY + iYInc) - pTod->pgp->ptl.y,
                        MOVE_RELATIVE | MOVE_UPDATE,
                        &ptlRem);
        }
    }
    else
        bRet = FALSE;

    return   bRet;
}

BOOL
BRLESelectFont(
    PDEV     *pPDev,
    PFONTMAP  pFM,
    POINTL   *pptl)
{
    FONTMAP_DEV *pfmdev = pFM->pSubFM;
    CD          *pCD;

    ASSERT(pPDev && pfmdev);

    if (!(pCD = pfmdev->cmdFontSel.pCD))
        return FALSE;

    pfmdev->pfnDevSelFont(pPDev,
                          pCD->rgchCmd,
                          pCD->wLength,
                          pptl);

    return TRUE;
}

BOOL
BSelectNonScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    if( iCmdLength > 0 && pbCmd &&
        WriteSpoolBuf( pPDev, pbCmd, iCmdLength ) != iCmdLength)
    {
        return  FALSE;
    }

    return TRUE;
}

BOOL
BSelectPCLScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    INT  iIn, iConv, iOut;
    BYTE aubLocal[80];

    ASSERT(pPDev && pbCmd && pptl);

    iOut = 0;

    for( iIn = 0; iIn < iCmdLength; iIn++ )
    {
        if( pbCmd[ iIn ] == '#')
        {
            //
            // The next byte tells us what information is required.
            //

            switch ( pbCmd[ iIn + 1 ] )
            {
                case  'v':
                case  'V':       /*   Want the font's height */
                    iConv = pptl->y;
                    break;

                case  'h':
                case  'H':       /* Want the pitch */
                    iConv = pptl->x;
                    break;

                default:        /* This should not happen! */
                    ERR(( "UniFont!BSelScalableFont(): Invalid command format\n"));
                    return  FALSE;           /* Bad news */
            }

            iOut += IFont100toStr( &aubLocal[ iOut ], iConv );

        }
        else
            aubLocal[iOut++] = pbCmd[iIn];
    }

    WriteSpoolBuf( pPDev, aubLocal, iOut);

    return TRUE;
}

BOOL
BSelectCapslScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    INT  iIn, iConv, iOut;
    BYTE aubLocal[80];

    ASSERT(pPDev && pbCmd && pptl);

    iOut = 0;

    for( iIn = 0; iIn < iCmdLength; iIn++ )
    {
        if( pbCmd[ iIn ] == '#')
        {
            //
            // The next byte tells us what information is required.
            //

            switch ( pbCmd[ iIn + 1 ] )
            {
                case  'v':
                case  'V':
                    iConv = pptl->y * 300 / 72;
                    break;

                case  'h':
                case  'H':
                    iConv = pptl->x;
                    break;

                default:
                    ERR(( "Invalid command format\n"));
                    return  FALSE;
            }
            iIn ++;
            iOut += iDrvPrintfA(&aubLocal[iOut], "%d", (iConv + 50)/100);
        }
        else
            aubLocal[iOut++] = pbCmd[iIn];
    }

    WriteSpoolBuf( pPDev, aubLocal, iOut);

    return TRUE;
}

BOOL
BSelectPPDSScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    INT  iIn, iOut, iConv;
    BYTE aubLocal[80];

    ASSERT(pPDev && pbCmd && pptl);

    iOut = 0;

    for( iIn = 0; iIn < iCmdLength; iIn++ )
    {
        if (pbCmd[ iIn ] == '\x0B' && pbCmd[ iIn + 1] == '#')
        //
        // Height param for PPDS
        //
        {

            aubLocal[ iOut++ ] = '\x0B';
            aubLocal[ iOut++ ] = '\x06';
            iConv = pptl->y;

            //
            //  Due to restriction of PPDS cmds, param must be sent in
            //  xxx.xx format !
            //

            if ( ( iDrvPrintfA(&aubLocal[ iOut ], "%05d",iConv ) ) != 5 )
                    return FALSE;   /* Bad news */

            //
            // insert the decimal point
            //
            aubLocal[ iOut+5 ] = aubLocal[ iOut+4 ];
            aubLocal[ iOut+4 ] = aubLocal[ iOut+3 ];
            aubLocal[ iOut+3 ] = '.';

            iOut += 6; // xxx.xx  ( ie 6 incl decimal pt
            iIn++;
        }
        else if (pbCmd[ iIn ] == '\x0E' && pbCmd[ iIn + 1] == '#')
        //
        // Pitch param  for GPC_TECH_PPDS
        //
        {
            aubLocal[ iOut++ ] = '\x0E';
            aubLocal[ iOut++ ] = '\x07';
            aubLocal[ iOut++ ] = '\x30';  // special byte required
            iConv = pptl->x;

            if ( ( iDrvPrintfA(&aubLocal[ iOut ], "%05d",iConv ) ) != 5 )
                return FALSE;

            //
            // insert the decimal point
            //

            aubLocal[ iOut+5 ] = aubLocal[ iOut+4 ];
            aubLocal[ iOut+4 ] = aubLocal[ iOut+3 ];
            aubLocal[ iOut+3 ] = '.';

            iOut += 6; // xxx.xx  ( ie 6 incl decimal pt
            iIn++;
        }
        else
            //
            // No translation necessary
            //
            aubLocal[ iOut++ ] = pbCmd[ iIn ];

    }

    WriteSpoolBuf( pPDev, aubLocal, iOut );

    return TRUE;

}

BOOL
BRLEDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM)
{
    PFONTMAP_DEV  pfmdev;
    CD           *pCD;
    BOOL          bRet = TRUE;

    ASSERT(pPDev && pFM);

    pfmdev = pFM->pSubFM;
    pCD    = pfmdev->cmdFontDesel.pCD;

    if (pCD &&
        pCD->wLength != 0 &&
        pCD->rgchCmd &&
        pCD->wLength != WriteSpoolBuf(pPDev, pCD->rgchCmd, pCD->wLength))
            bRet = FALSE;

    return bRet;
}


INT
IGetIFIGlyphWidth(
    PDEV    *pPDev,
    FONTMAP *pFM,
    HGLYPH   hg)
{
    FONTMAP_DEV *pfmdev;
    NT_RLE      *pntrle;           // The RLE stuff - may be needed
    UHG          uhg;              // Defined access to HGLYPH contents
    INT          iWide = 0;

    ASSERT(pPDev && pFM);

    pfmdev = pFM->pSubFM;
    pntrle = pfmdev->pvNTGlyph;

    ASSERT(pfmdev && pntrle);

    if( pfmdev->W.psWidth )
    {
        /*   Proportional font - width varies per glyph */

        uhg.hg = (HGLYPH)hg;

        /*
         *    We need the index value from the HGLYPH.  The
         *  index is the offset in the width table.  For all
         *  but the >= 24 bit offset types,  the index is
         *  included in the HGLYPH.  For the 24 bit offset,
         *  the first WORD of the destination is the index,
         *  while for the 32 bit offset, it is the second WORD
         *  at the offset.
         */

        switch( pntrle->wType )
        {
        case  RLE_DIRECT:
        case  RLE_PAIRED:
            iWide = uhg.rd.wIndex;
            break;

        case  RLE_LI_OFFSET:
            iWide = uhg.rli.bIndex;
            break;

        case  RLE_L_OFFSET:
            iWide = (DWORD)uhg.hg & 0x00ffffff;
            iWide = *((WORD *)((BYTE *)pntrle + iWide));
            break;

        case  RLE_OFFSET:
            iWide = (DWORD)uhg.hg + sizeof( WORD );
            iWide = *((WORD *)((BYTE *)pntrle + iWide));
            break;
        }

        iWide = pfmdev->W.psWidth[iWide];

        //
        // If this is a proportionally spaced font,
        // we need to adjust the width table entries
        // to the current resolution.  The width tables are NOT
        // converted for lower resolutions,  so we add the factor in now.
        // Fixed pitch fonts must not be adjusted, since the width is converted
        // in the font metrics.
        //

        iWide = iWide * pPDev->ptGrxRes.x / pFM->wXRes;
    }
    else
    {
        //
        //  Fixed pitch fonts come from IFIMETRICS
        //

        iWide = ((IFIMETRICS  *)(pFM->pIFIMet))->fwdMaxCharInc;

    }

    return iWide;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\posnsort.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    posnsort.h

Abstract:

    The details required for posnsort.c - code used to sort the output
    glyphs by position on the page.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/02/97 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _POSNSORT_H

/*
 *   The structure used to store glyph data.  These are allocated from
 *  chunks of memory,  as required.  Entries are stored as an array,
 *  but are part of a linked list;  there is one list for every y
 *  value.  The order in the linked list is that in which the glyphs
 *  are received by the driver,  which may or may not be the order
 *  in which they will be printed.
 */
typedef  struct PSGlyph
{
    struct  PSGlyph  *pPSGNext;         /* Next in list,  0 for last */
    INT     ixVal;                      /* The X coordinate */
    HGLYPH  hg;                         /* The HGLYPH to print */
    SHORT   sFontIndex;                 /* The font to use */
    PVOID   pvColor;                    /* Colour for this glyph */
    DWORD   dwAttrFlags;                /* Font attribute flags, italic/bold */
    FLONG   flAccel;
    FLOATOBJ  eXScale;          // X Scale factor
    FLOATOBJ  eYScale;          // Y Scale factor
} PSGLYPH;

/*
 *    Structure used to manage the chunks of memory allocated for the
 *  PSGLYPH structures.  Basically it remembers the necessary details
 *  for freeing the block(s),  and also how much free space is available.
 */

#define PSG_CHUNK       1024            /* Glyph details per chunk */

typedef  struct  PSChunk
{
    struct  PSChunk  *pPSCNext;         /* Next in chain,  0 for last */
    int     cUsed;                      /* Entries in use */
    PSGLYPH aPSGData[ PSG_CHUNK ];      /* Actual glyph data */
} PSCHUNK;

/*
 *    The linked lists of PSGLYPH are based in a linked list of the
 * following structures.  These are linked in order of Y coordinate,
 * with an indexing table to speed scanning the list to find the
 * current Y coordinate.  Some caching also takes place.
 */

typedef  struct  YList
{
    struct  YList  *pYLNext;            /* Next in chain */
    int       iyVal;                    /* The Y coordinate */
    int       iyMax;                    /* Greatest height font this line */
    int       cGlyphs;                  /* The number of glyphs in this list */
    PSGLYPH  *pPSGHead;                 /* The start of the list of glyphs */
    PSGLYPH  *pPSGTail;                 /* The end of the list of glyphs */
} YLIST;

/*
 *    Structure used to manage the chunks of memory allocated for the
 *  PSGLYPH structures.  Basically it remembers the necessary details
 *  for freeing the block(s),  and also how much free space is available.
 */

#define YL_CHUNK        128             /* Glyph details per chunk */

typedef  struct  YLChunk
{
    struct  YLChunk  *pYLCNext;         /* Next in chain,  0 for last */
    int     cUsed;                      /* Entries in use */
    YLIST   aYLData[ YL_CHUNK ];        /* Actual YLIST data */
} YLCHUNK;


/*
 *   Finally,  the overall header block:  used to head the chain(s) of
 * data,  and to hold the cache and speedup data.
 */

#define NUM_INDICES     32              /* Indices into Y linked list */

typedef  struct  PSHead
{
    PSCHUNK  *pPSCHead;         /* Head of X linked data chunks */
    YLCHUNK  *pYLCHead;         /* Head of Y list chunks */
    int       cGlyphs;          /* Glyph count in longest list */
    int       iyDiv;            /* y div iyDiv -> index to following */
    YLIST    *pYLIndex[ NUM_INDICES ];  /* Speed up index into linked list */
    YLIST    *pYLLast;          /* Last Y element used.  This is a sort of
                                 * cache,  on the presumption that the last
                                 * used value is the one most likely to be
                                 * used next, AT LEAST for horizontal text.
                                 */
    PSGLYPH **ppPSGSort;        /* Memory used to sort the glyph lists */
    int       cGSIndex;         /* Index of next returned value in above */
} PSHEAD;


#define _POSNSORT_H
#endif  // !_POSNSORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\posnsort.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    posnsort.c

Abstract:

    Functions used to store/sort/retrieve output glyphs based on their
    position on the page.  This is required to be able to print
    the page in one direction,  as vertical repositioning may not
    be available,  and is generally not accurate enough. Not required
    for page printers.

Environment:

    Windows NT Unidrv driver

Revision History:

    01//97 -ganeshp-
        Created

--*/

#include "font.h"

/*
 *   Private function prototypes.
 */

static  PSGLYPH *
GetPSG(
    PSHEAD  *pPSH
    );

static  YLIST *
GetYL(
    PSHEAD  *pPSH
    );

static INT __cdecl
iPSGCmp(                  /*   The qsort() compare function */
    const void   *ppPSG0,
    const void   *ppPSG1
    );


#if     PRINT_INFO
int     __LH_QS_CMP;            /* Count number of qsort() comparisons */
#endif


BOOL
BCreatePS(
    PDEV  *pPDev
    )
/*++

Routine Description:
    Set up the data for the position sorting functions.  Allocate
    the header and the first of the data chunks,  and set up the
    necessary pointers etc.  IT IS ASSUMED THAT THE CALLER HAS
    DETERMINED THE NEED TO CALL THIS FUNCTION; otherwise,  some
    memory will be allocated,  but not used.


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    01/02/97 -ganeshp-
        Created it.

--*/
{
    /*
     *    Initialise the position sorting tables.
     */

    PSCHUNK     *pPSC;
    YLCHUNK     *pYLC;
    PSHEAD      *pPSHead;
    FONTPDEV    *pFontPDev = PFDV;

    if( !(pPSHead = (PSHEAD *)MemAllocZ(sizeof( PSHEAD))) )
    {
        ERR(("UniFont!BCreatePS:Can't allocate PSHEAD\n"));
        return  FALSE;
    }


    pFontPDev->pPSHeader = pPSHead;         /* Connect to other structures */

    /*
     *   Get a chunk of memory for the first PSCHUNK data block.  The
     * address is recorded in the PSHeader allocated above.
     */

    if( !(pPSC = (PSCHUNK *)MemAllocZ( sizeof( PSCHUNK ) )) )
    {
        ERR(("UniFont!BCreatePS:Can't allocate PSCHUNK\n"));
        VFreePS( pPDev );

        return  FALSE;
    }
    pPSC->pPSCNext = 0;                 /* This is the only chunk */
    pPSC->cUsed = 0;                    /* AND none of it is in use */

    pPSHead->pPSCHead = pPSC;

    /*
     *   Get a chunk of memory for the first YLCHUNK data block.  The
     * address is recorded in the PSHeader allocated above.
     */

    if( !(pYLC = (YLCHUNK *)MemAllocZ( sizeof( YLCHUNK ) )) )
    {
        ERR(("UniFont!BCreatePS:Can't allocate YLCHUNK\n"));
        VFreePS( pPDev );

        return  FALSE;
    }
    pYLC->pYLCNext = 0;                 /* This is the only chunk */
    pYLC->cUsed = 0;                    /* AND none of it is in use */
    pPSHead->pYLCHead = pYLC;

    //
    // To text units
    //
    pPSHead->iyDiv = (pPDev->sf.szImageAreaG.cy * pPDev->ptGrxScale.y) / pFontPDev->ptTextScale.y;

    //
    // Round up one to avoid DIVIDED-BY-ZERO.
    //
    pPSHead->iyDiv = (pPSHead->iyDiv + NUM_INDICES) / NUM_INDICES;



#if     PRINT_INFO
    __LH_QS_CMP = 0;            /* Count number of qsort() comparisons */
#endif
    return  TRUE;
}



VOID
VFreePS(
    PDEV  *pPDev
    )
/*++

Routine Description:
     Free all memory allocated for the posnsort operations.  Start with
     the header to find the chains of data chunks we have,  freeing
     each as it is found.


Arguments:

    pPDev           Pointer to PDEV

Return Value:
    None.

Note:
    01/02/97 -ganeshp-

--*/
{

    PSCHUNK   *pPSC;
    PSCHUNK   *pPSCNext;                /* For working through the list */
    YLCHUNK   *pYLC;
    YLCHUNK   *pYLCNext;                /* Ditto */
    PSHEAD    *pPSH;
    FONTPDEV    *pFontPDev = PFDV;

#if     PRINT_INFO
    DbgPrint( "vFreePS: %ld qsort() comparisons\n", __LH_QS_CMP );
#endif

    if( !(pPSH = pFontPDev->pPSHeader) )
        return;                         /* Nothing to free! */


    for( pPSC = pPSH->pPSCHead; pPSC; pPSC = pPSCNext )
    {
        pPSCNext = pPSC->pPSCNext;      /* Next one, if any */
        MemFree( (LPSTR)pPSC );
    }

    /*   Repeat for the YLCHUNK segments */
    for( pYLC = pPSH->pYLCHead; pYLC; pYLC = pYLCNext )
    {
        pYLCNext = pYLC->pYLCNext;      /* Next one, if any */
        MemFree( (LPSTR)pYLC );
    }

    /*  Array storage for sorting - free it too!  */
    if( pPSH->ppPSGSort )
        MemFree( (LPSTR)pPSH->ppPSGSort );

    /*   Finally,  the hook in the PDEV.  */
    MemFree( (LPSTR)pPSH );

    pFontPDev->pPSHeader = NULL;

    return;
}


BOOL
BAddPS(
    PSHEAD  *pPSH,
    PSGLYPH *pPSGIn,
    INT      iyVal,
    INT      iyMax
    )
/*++

Routine Description:
    Add an entry to the position sorting data.

Arguments:
    pPSH    All the pointer data needed.
    pPSGIn  Glyph, font, X coordinate info.
    iyVal   The y coordinate.
    iyMax   fwdWinAscender for this font.



Return Value:
    TRUE/FALSE,  for success or failure.  Failure comes from a lack
    of memory to store more data.

Note:
    01/02/97 -ganeshp-

--*/
{

    PSCHUNK  *pPSC;     /* Local for faster access */
    PSGLYPH  *pPSG;     /* Summary of data passed to us,  and stored away */
    YLIST    *pYL;      /* Finding the correct list */

    //VERBOSE(("BAddPS:iyVal = %d\n", iyVal));

    //
    // Validate the Y position. It shouldn't be -ve. For negative y position
    // return true without adding the text in in the list.
    //
    if (iyVal < 0 || pPSH->ppPSGSort)
    {
#if DBG
        if (pPSH->ppPSGSort)
            WARNING(("BAddPS: Additional glyph after ppPSGSort was allocated.\n"));
#endif
        return TRUE;
    }

    pPSC = pPSH->pPSCHead;

    /*
     *   Step 1:  Store the data in the next PSGLYPH.
     */

    if( !(pPSG = GetPSG( pPSH )) )
        return  FALSE;

    *pPSG = *pPSGIn;            /* Major data */
    pPSG->pPSGNext = 0;         /* No next value! */

    /*
     *    Step 2 is to see if this is the same Y location as last time.
     *  If so,  our job is easy,  since all we need do is tack onto the
     *  end of the list we have at hand.
     */

    pYL = pPSH->pYLLast;
    if( pYL == 0 || pYL->iyVal != iyVal )
    {
        /*  Out of luck,  so go pounding through the lists  */
        YLIST   *pYLTemp;
        int      iIndex;

        iIndex = iyVal / pPSH->iyDiv;
        if( iIndex >= NUM_INDICES )
            iIndex = NUM_INDICES - 1;   /* Value is out of range */

        pYLTemp = pPSH->pYLIndex[ iIndex ];

        if( pYLTemp == 0 )
        {
            /*  An empty slot,  so now we must fill it  */
            if( !(pYL = GetYL( pPSH )) )
            {
                /*  Failed,  so we cannot do anything  */

                return  FALSE;
            }
            pYL->iyVal = iyVal;
            pPSH->pYLIndex[ iIndex ] = pYL;
        }
        else
        {
            /*  We have a list,  start scanning for this value,  or higher */
            YLIST  *pYLLast;

            pYLLast = 0;                /* Means looking at first */
            while( pYLTemp && pYLTemp->iyVal < iyVal )
            {
                pYLLast = pYLTemp;
                pYLTemp = pYLTemp->pYLNext;
            }
            if( pYLTemp == 0 || pYLTemp->iyVal != iyVal )
            {
                /*  Not available,  so get a new one and add it in  */
                if( !(pYL = GetYL( pPSH )) )
                    return  FALSE;

                pYL->iyVal = iyVal;

                if( pYLLast == 0 )
                {
                    /*  Needs to be first on the list */
                    pYL->pYLNext = pPSH->pYLIndex[ iIndex ];
                    pPSH->pYLIndex[ iIndex ] = pYL;
                }
                else
                {
                    /*  Need to insert it */
                    pYL->pYLNext = pYLTemp;     /* Next in chain */
                    pYLLast->pYLNext = pYL;     /* Link us in */
                }
            }
            else
                pYL = pYLTemp;          /* That's the one!  */
        }
    }
    /*
     *   pYL is now pointing at the Y chain for this glyph.  Add the new
     *  entry to the end of the chain.  This means that we will mostly
     *  end up with presorted text,  for apps that draw L->R with a
     *  font that is oriented that way.
     */

    if( pYL->pPSGHead )
    {
        /*   An existing chain - add to the end of it */
        pYL->pPSGTail->pPSGNext = pPSG;
        pYL->pPSGTail = pPSG;
        if( iyMax > pYL->iyMax )
            pYL->iyMax = iyMax;        /* New max height */
    }
    else
    {
        /*   A new YLIST structure,  so fill in the details  */
        pYL->pPSGHead = pYL->pPSGTail = pPSG;
        pYL->iyVal = iyVal;
        pYL->iyMax = iyMax;
    }
    pYL->cGlyphs++;                     /* Another in the list */
    if( pYL->cGlyphs > pPSH->cGlyphs )
        pPSH->cGlyphs = pYL->cGlyphs;

    pPSH->pYLLast = pYL;


    return  TRUE;
}


static  PSGLYPH  *
GetPSG(
    PSHEAD  *pPSH
    )
/*++

Routine Description:
    Returns the address of the next available PSGLYPH structure.  This
    may require allocating additional memory.

Arguments:
    pPSH    All the pointer data needed.

Return Value:
    The address of the structure, or zero on error.

Note:
    01/02/97 -ganeshp-

--*/
{

    PSCHUNK   *pPSC;
    PSGLYPH   *pPSG;

    pPSC = pPSH->pPSCHead;              /* Current chunk */

    if( pPSC->cUsed >= PSG_CHUNK )
    {
        /*   Out of room,  so add another chunk,  IFF we get the memory */
        PSCHUNK  *pPSCt;

        if( !(pPSCt = (PSCHUNK *)MemAllocZ(sizeof(PSCHUNK))) )
        {
            ERR(("UniFont!GetPSG: Unable to Allocate PSCHUNK\n"));
            return  FALSE;
        }


        /*  Initialise the new chunk,  add it to list of chunks */
        pPSCt->cUsed = 0;
        pPSCt->pPSCNext = pPSC;
        pPSH->pPSCHead = pPSC = pPSCt;

    }

    pPSG = &pPSC->aPSGData[ pPSC->cUsed ];

    ++(pPSC->cUsed);

    return  pPSG;
}



static  YLIST  *
GetYL(
    PSHEAD  *pPSH
    )
/*++

Routine Description:
    Allocates another YLIST structure,  allocating any storage that
    may be required,  and then initialises some of the fields.

Arguments:
    pPSH    All the pointer data needed.

Return Value:
     Address of new YLIST structure,  or zero for error.

Note:
    01/02/97 -ganeshp-

--*/
{

    YLCHUNK   *pYLC;
    YLIST     *pYL;


    pYLC = pPSH->pYLCHead;              /* Chain of these things */

    if( pYLC->cUsed >= YL_CHUNK )
    {
        /*  These have all gone,  we need another chunk  */
        YLCHUNK  *pYLCt;


        if( !(pYLCt = (YLCHUNK *)MemAllocZ( sizeof(YLCHUNK) )) )
        {
            ERR(("UniFont!GetPSG: Unable to Allocate YLCHUNK\n"));
            return  0;
        }


        pYLCt->pYLCNext = pYLC;
        pYLCt->cUsed = 0;
        pYLC = pYLCt;

        pPSH->pYLCHead = pYLC;
    }

    pYL = &pYLC->aYLData[ pYLC->cUsed ];
    ++(pYLC->cUsed);                      /* Count this one off */

    pYL->pYLNext = 0;
    pYL->pPSGHead = pYL->pPSGTail = 0;
    pYL->cGlyphs = 0;                   /* None in this list (yet) */

    return  pYL;
}


INT
ILookAheadMax(
    PDEV    *pPDev,
    INT     iyVal,
    INT     iLookAhead
    )
/*++

Routine Description:
    Scan down the next n scanlines,  looking for the largest device
    font in this area.   This value is returned,  and becomes the
    "text output box", as defined in the HP DeskJet manual.  In
    essence,  we print any font in this area.

Arguments:
    pPDev       Base of our operations.
    iyVal       The current scan line
    iLookAhead  Size of lookahead region, in scan lines

Return Value:
     The number of scan lines to look ahead,  0 is legitimate.

Note:
    01/02/97 -ganeshp-

--*/
{

    INT     iyMax = 0;     /* Returned value */
    INT     iIndex;        /* For churning through the red tape */
    YLIST   *pYL;           /* For looking down the scan lines */
    PSHEAD  *pPSH = PFDV->pPSHeader;

    /*
     *  Scan from iyVal to iyVal + iLookAhead,  and return the largest
     *  font encountered.  We have remembered the largest font on each
     *  line,  so there is no difficulty finding this information.This
     *  has to be done only if the device has fonts.
     */


    if (pPDev->iFonts)
    {
        ASSERT(pPSH);

        for( iyMax = 0; --iLookAhead > 0; ++iyVal )
        {
            /*
             *    Look for the YLIST for this particular scan line.  There
             *  may not be one - this will be the most common case.
             */

            iIndex = iyVal / pPSH->iyDiv;
            if( iIndex >= NUM_INDICES )
                iIndex = NUM_INDICES;

            if( (pYL = pPSH->pYLIndex[ iIndex ]) == 0 )
                continue;                   /* Nothing on this scan line */

            /*
             *   Have a list,  so scan the list to see if we have this value.
             */

            while( pYL && pYL->iyVal < iyVal )
                pYL = pYL->pYLNext;

            if( pYL && pYL->iyVal == iyVal )
                iyMax = max( iyMax, pYL->iyMax );
        }

    }

    return  iyMax;
}



INT
ISelYValPS(
    PSHEAD  *pPSH,
    int     iyVal
    )
/*++

Routine Description:
    Set the desired Y value for glyph retrieval.  Returns the number
    of glyphs to be used in this row.

Arguments:
    pPSH        Base of our operations.
    iyVal       The current scan line

Return Value:
     Number of glyphs in this Y row.  -1 indicates an error.

Note:
    01/02/97 -ganeshp-

--*/
{
    /*
     *    All that is needed is to scan the relevant Y list.  Stop when
     *  either we have gone past the iyVal (and return 0), OR when we
     *  find iyVal,  and then sort the data on X order.
     */

    int     iIndex;

    YLIST     *pYL;
    PSGLYPH  **ppPSG;
    PSGLYPH   *pPSG;

    //VERBOSE(("ISelYValPS:iyVal = %d\n", iyVal));

    iIndex = iyVal / pPSH->iyDiv;
    if( iIndex >= NUM_INDICES )
        iIndex = NUM_INDICES;

    if( (pYL = pPSH->pYLIndex[ iIndex ]) == 0 )
        return  0;                      /* Nothing there */

    /*
     *   Have a list,  so scan the list to see if we have this value.
     */

    while( pYL && pYL->iyVal < iyVal )
        pYL = pYL->pYLNext;

    if( pYL == 0 || pYL->iyVal != iyVal )
        return  0;                      /* Nothing on this row  */

    /*
     *   There are glyphs on this row,  so sort them.  This requires an
     *  array to use as pointers into the linked list elements.  The
     *  array is allocated for the largest size linked list (we have
     *  kept records on this!),  so the allocation is only done once.
     */

    if( pPSH->ppPSGSort == 0 )
    {
        /*  No,  so allocate it now  */
        if( !(pPSH->ppPSGSort = (PSGLYPH **)MemAllocZ(pPSH->cGlyphs * sizeof(PSGLYPH *))) )
        {
            ERR(("UniFont!ISelYValPS: Unable to Alloc Sorting Array of PSGLYPH\n"));
            return  -1;
        }
    }

    /*
     *    Scan down the list,  recording the addresses as we go.
     */

    ppPSG = pPSH->ppPSGSort;
    pPSG = pYL->pPSGHead;

    while( pPSG )
    {
        *ppPSG++ = pPSG;
        pPSG = pPSG->pPSGNext;
    }

    /*   Sorting is EASY!  */
    qsort( pPSH->ppPSGSort, pYL->cGlyphs, sizeof( PSGLYPH * ), iPSGCmp );

    pPSH->cGSIndex = 0;
    pPSH->pYLLast = pYL;        /* Speedier access in psgGetNextPSG() */

    return  pYL->cGlyphs;
}


static INT __cdecl
iPSGCmp(
    const void   *ppPSG0,
    const void   *ppPSG1
    )
/*++

Routine Description:
    Compare function for qsort() X position ordering.  Look at the
    qsort() documentation for further details.

Arguments:
    ppPSG0        Value 1.
    ppPSG1        Value 2.

Return Value:
    < 0 if arg0 < arg1
      0 if arg0 == arg1
    > 0 if arg0 > arg1


Note:
    01/02/97 -ganeshp-

--*/
{

#if     PRINT_INFO
    __LH_QS_CMP++;              /* Count number of qsort() comparisons */
#endif

    return  (*((PSGLYPH **)ppPSG0))->ixVal - (*((PSGLYPH **)ppPSG1))->ixVal;

}

/************************ Function Header *********************************
 * psgGetNextPSG
 *
 * RETURNS:
 *
 *
 * HISTORY:
 *  14:44 on Wed 12 Dec 1990    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 ***************************************************************************/

PSGLYPH  *
PSGGetNextPSG(
    PSHEAD  *pPSH
    )
/*++

Routine Description:
    Return the address of the next PSGLYPH structure from the current
    sorted list.  Returns 0 when the end has been reached.

Arguments:
    pPSH        Base of our operations.

Return Value:
     The address of the PSGLYPH to use,  or 0 for no more.

Note:
    01/02/97 -ganeshp-

--*/
{

    if( pPSH->cGSIndex >= pPSH->pYLLast->cGlyphs )
        return  0;                      /* We have none left */

    return  pPSH->ppPSGSort[ pPSH->cGSIndex++ ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\qadvwdth.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qadvwdth.c

Abstract:

    Implements the DrvQueryAdvanceWidths function - returns information
    about glyph widths.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/02/97 -ganeshp-
        Created

--*/

#include "font.h"


BOOL
FMQueryAdvanceWidths(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH *phg,
    PVOID  *pvWidths,
    ULONG   cGlyphs
    )
/*++

Routine Description:
    Return Width information about glyphs in the font.

Arguments:

    pPDev           Pointer to PDEV
    pfo             The font of interest
    iMode           Glyphdata or kerning information
    phg             handle to glyph
    pvWidths        Output area
    cGlyphs         The number of them

Return Value:

    TRUE for success and FALSE if widths of all the glyphs cannot be computed.
    It returns DD_ERROR if the function fails.
Note:
    01/02/97 -ganeshp-

--*/
{
    /*
     *   First version is for fixed pitch fonts,  which are easy to do:
     *  the data is in the font's metrics!
     */



    FONTPDEV    *pFontPDev;
    int         iRot;             /* Rotation multiple of 90 degrees */
    BOOL        bRet;             /* Value returned */
    FONTMAP     *pFM;              /* Font data */
    IFIMETRICS  *pIFI;
    XFORMOBJ    *pxo;
    FONTCTL     ctl;              /* Scaling information */
    USHORT      *pusWidths;
    FLOATOBJ    fo;

    pFontPDev = pPDev->pFontPDev;
    bRet      = DDI_ERROR;
    pusWidths = (USHORT *) pvWidths;


    if( pfo->iFace < 1 || (int)pfo->iFace > pPDev->iFonts )
    {
        ERR(("UniFont!FMQueryAdvanceWidths: Bad FONTOBJ, iFace is %d",pfo->iFace));
        SetLastError( ERROR_INVALID_PARAMETER );
        return  bRet;
    }

    pFM = PfmGetDevicePFM( pPDev, pfo->iFace );

    if( pFM == NULL )
        return   FALSE;


    pIFI = pFM->pIFIMet;                /* IFIMETRICS - useful to have */


    if( !(pxo = FONTOBJ_pxoGetXform( pfo )) )
    {
        ERR(( "UniFont!FMQueryAdvanceWidths: FONTOBJ_pxoGetXform fails\n" ));
        return  bRet;
    }

    /*
     *   ALWAYS call the iSetScale function,  because some printers can
     *  rotate bitmap fonts.
     */

    //Added Check for HP Intellifont
    iRot = ISetScale( &ctl, pxo, ((pFM->flFlags & FM_SCALABLE) &&
                          (((PFONTMAP_DEV)pFM->pSubFM)->wDevFontType ==
                                            DF_TYPE_HPINTELLIFONT)),
                          (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

    if( pFM->flFlags & FM_SCALABLE )
    {

        int         iPtSize, iAdjustedPtSize;       /* For scale factor adjustment */

    #ifdef USEFLOATS

        /*  The limited font size resolution */
        iPtSize = (int)(0.5 + ctl.eYScale * pIFI->fwdUnitsPerEm * 7200) / pPDev->ptGrxRes.y;

        /* if the tranform is very small (Less than a quarter of point size)
         * then make it atleast a quarter point. This was causing AV in certain
         * cases.
         */

        if (iPtSize < 25)
        {
            iPtSize = 25;

        }
        iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

        //Adjust the Scale Factor for quarter point adjustment.
        ctl.eXScale = (ctl.eXScale * iAdjustedPtSize) / iPtSize;
        ctl.eYScale = (ctl.eYScale * iAdjustedPtSize) / iPtSize;

    #else

        fo = ctl.eYScale;
        FLOATOBJ_MulLong(&fo,pIFI->fwdUnitsPerEm);
        FLOATOBJ_MulLong(&fo,7200);

        #ifndef WINNT_40 //NT 5.0

        FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

        #else // NT 4.0

        FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

        #endif //!WINNT_40

        iPtSize = FLOATOBJ_GetLong(&fo);
        iPtSize /= pPDev->ptGrxRes.y;

        /* if the trannform is very small (Less than a quarter of point size)
         * then make it atleast a quarter point. This was causing AV in certain
         * cases.
         */

        if (iPtSize < 25)
        {
            iPtSize = 25;

        }

        iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

        //Adjust the Scale Factor for quarter point adjustment.
        FLOATOBJ_MulLong(&ctl.eXScale,iAdjustedPtSize);
        FLOATOBJ_DivLong(&ctl.eXScale,iPtSize);

        FLOATOBJ_MulLong(&ctl.eYScale,iAdjustedPtSize);
        FLOATOBJ_DivLong(&ctl.eYScale,iPtSize);
    #endif
    }


    /* We need to adjust the width table entries to the current resolution.IGetGlyphWidth
     * returns the scaled width for current resolution.
     */

    switch( iMode )
    {
    case  QAW_GETWIDTHS:            /* Glyph width etc data */
    case  QAW_GETEASYWIDTHS:

        while( cGlyphs-- > 0 )
        {

            int   iWide;            /* Glyph's width */


            iWide = IGetGlyphWidth( pPDev, pFM, (HGLYPH)*phg++);

            iWide = LMulFloatLong(&ctl.eXScale,iWide);

            *pusWidths++ = LTOFX( iWide );
        }
        bRet = TRUE;

        break;

    default:
        ERR(( "UniFont!FMQueryAdvanceWidths:  illegal iMode value" ));
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    return  bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\qeryfont.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qeryfont.c

Abstract:

    Implementation of Functions to answer font queries from the engine.
Environment:

    Windows NT Unidrv driver

Revision History:

    12/19/96 -ganeshp-
        Created

--*/

#include "font.h"



PIFIMETRICS
FMQueryFont(
    PDEV    *pPDev,
    ULONG_PTR iFile,
    ULONG   iFace,
    ULONG_PTR *pid
    )
/*++

Routine Description:
    Returns the IFIMETRICS of the nominated font.

Arguments:

    pPDev           Pointer to PDEV
    iFile           This is the identifier of the driver font file.
    iFace           Font index of interest,  first is # 1
    pid             Can be used by driver to id or flag the return data

Return Value:

    Pointer to the IFIMETRICS of the requested font.  NULL on error.
Note:
    11-18-96: Created it -ganeshp-

--*/

{

    //
    //    This is not too hard - verify that iFace is within range,  then
    //  use it as an index into the array of FONTMAP structures hanging
    //  off the PDEV!  The FONTMAP array contains the address of the
    //  IFIMETRICS structure!
    //

    FONTPDEV *pFontPDev;
    FONTMAP  *pfm;

    pFontPDev = PFDV;

    //
    // This can be used by the driver to flag or id the data returned.
    // May be useful for deletion of the data later by DrvFree().
    //

    *pid = 0;        // dont really need to do anything with it

    if( iFace == 0 && iFile == 0 )
    {
        return (IFIMETRICS *)IntToPtr(pPDev->iFonts);
    }

    if( iFace < 1 || (int)iFace > pPDev->iFonts )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ERR(( "iFace = %ld WHICH IS INVALID\n", iFace ));
        return  NULL;
    }

    pfm = PfmGetDevicePFM( pPDev, iFace );

    return   pfm ? pfm->pIFIMet : NULL;

}

ULONG
FMGetGlyphMode(
    PDEV    *pPDev,
    FONTOBJ *pfo
    )
/*++

Routine Description:
    Tells engine how we want to handle various aspects of glyph
    information.
Arguments:

    pPDev           Pointer to PDEV.
    pfo             The font in question?.

Return Value:

    Information about glyph handling.
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    return  FO_GLYPHBITS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\newfonts.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    newfont.c

Abstract:

    Implementation of the functions to use new font format.

Environment:

    Windows NT Unidrv driver

Revision History:

    02/21/97 -eigos-
        Support Double byte font

    01/24/97 -eigos-
        Filled in functionality

    01/14/97 -ganeshp-
        Created

--*/

#include "font.h"

//
//
//

const BYTE aubAnsi[256] =
{
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

//
// Macro definition
//

#define DW_MASK    (DWBITS - 1)


//
// Internal function prototype
//

BOOL
BExtractGTT(
    PUNI_GLYPHSETDATA  pGTT,
    WCHAR              wchFirst,
    WCHAR              wchLast,
    FD_GLYPHSET       *pFD_GLYPHSET,
    PDWORD             pdwFD_GLYPHSETSize);

BOOL
BExtractGTTwithPredefGTT(
    IN  PUNI_GLYPHSETDATA pPreDefGTT,
    IN  PUNI_GLYPHSETDATA pMiniDefGTT,
    IN  WCHAR             wchFirst,
    IN  WCHAR             wchLast,
    OUT FD_GLYPHSET     **ppFD_GLYPHSET,
    OUT PMAPTABLE        *pMapTable,
    IN  PDWORD            pdwFD_GLYPHSETSize);

SHORT
SGetWidth(
    PWIDTHTABLE pWidthTable,
    HGLYPH      hg);


BYTE ubGetAnsi(
    WCHAR,
    INT,
    PWCHAR,
    PBYTE);

DWORD
DwCheckTrans(
    PGLYPHRUN pMiniGlyphRun,
    PMAPTABLE pMiniMapTable,
    DWORD     dwMiniGlyphRunCount,
    WORD      wUnicode);

WCHAR
WchGetNextUnicode(
    PWCHAR pwchUnicode,
    PDWORD pdwUnicodeBits,
    INT    iNumOfHandle);

int __cdecl Comp(const void *elem1, const void *elem2);

//
//
// Functions
//
//

VOID*
PVGetUCFD_GLYPHSET(
    PDEV    *pPDev,
    FONTMAP *pFM
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    PFONTMAP_DEV pFMDev;
    PVOID        pvFD_GLYPHSET = NULL;
    DWORD        dwFD_GLYPHSETSize;

    //
    // Paremeter validation
    //

    ASSERT(pFM != NULL);

    pFMDev = pFM->pSubFM;
    pvFD_GLYPHSET = NULL;

    if (pFMDev->pvNTGlyph)
    {

#if ENABLE_GTT_COMBINE
    RES_ELEM     ResElem;

        if (((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph)->lPredefinedID !=
            CC_NOPRECNV)
        {
            if (BGetWinRes( &(pPDev->WinResData),
                            ((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph)->lPredefinedID,
                            RC_GTT,
                            &ResElem))
            {
                pFMDev->pvPredefGTT = ResElem.pvResData;

        BExtractGTTwithPredefGTT(pFMDev->pvPredefGTT,
                     pFMDev->pvNTGlyph,
                     pFM->wFirstChar,
                     pFM->wLastChar,
                     pvFD_GLYPHSET,
                     (PMAPTABLE*)&pFMDev->pvMapTable,
                     &dwFD_GLYPHSETSize);

            }
            else
            {
                pFMDev->pvPredefGTT = NULL;
                ERR(("UniFont!PVGetUCFD_GLYPHSET: pvNTGTT is no loaded.\n"));
            }


        }
#endif

        //
        // First, try to get Far East Stock FD_GLYPHSET.
        //

#if ENABLE_STOCKGLYPHSET
        if (!BGetStockGlyphset( pPDev, &pvFD_GLYPHSET, (SHORT)pFMDev->sCTTid))
        {
            if (!BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                             pFM->wFirstChar,
                             pFM->wLastChar,
                             (FD_GLYPHSET*)NULL,
                             (PDWORD)&dwFD_GLYPHSETSize) ||

                !(pvFD_GLYPHSET = MemAlloc(dwFD_GLYPHSETSize)) ||

                !BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                             pFM->wFirstChar,
                             pFM->wLastChar,
                             (FD_GLYPHSET*)pvFD_GLYPHSET,
                             (PDWORD)&dwFD_GLYPHSETSize))
            {
                if (pvFD_GLYPHSET)
                {
                    MemFree(pvFD_GLYPHSET);
                    pvFD_GLYPHSET = NULL;
                    ERR(("UniFont!PVGetUCFD_GLYPHSET failed\n"));
                }
            }
        }
#else

        if (!BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                         pFM->wFirstChar,
                         pFM->wLastChar,
                         (FD_GLYPHSET*)NULL,
                         (PDWORD)&dwFD_GLYPHSETSize) ||

            !(pvFD_GLYPHSET = MemAlloc(dwFD_GLYPHSETSize)) ||

            !BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                         pFM->wFirstChar,
                         pFM->wLastChar,
                         (FD_GLYPHSET*)pvFD_GLYPHSET,
                         (PDWORD)&dwFD_GLYPHSETSize))
        {
            if (pvFD_GLYPHSET)
            {
                MemFree(pvFD_GLYPHSET);
                pvFD_GLYPHSET = NULL;
                ERR(("UniFont!PVGetUCFD_GLYPHSET failed\n"));
            }
        }
#endif
    }
    else
    {
        ERR(("UniFont!PVGetUCFD_GLYPHSET: pvNTGTT is no loaded.\n"));
    }

    pFMDev->pUCTree = pvFD_GLYPHSET;

    return pvFD_GLYPHSET;

}

VOID  *
PVUCKernPair(
    PDEV   *pPDev,
    FONTMAP   *pFM
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    PFONTMAP_DEV pFMDev;
    PKERNDATA    pKerningData;
    PUNIFM_HDR   pUFM;
    PVOID        pvKernPair = NULL;

    //
    // Paremeter validation
    //

    ASSERT(pFM != NULL);

    pFMDev = pFM->pSubFM;
    pUFM = pFMDev->pvFontRes;

    if (pFM->flFlags & FM_KERNRES)
    {
        pvKernPair = pFMDev->pUCKernTree;
    }
    else
    if (pUFM && pUFM->loKernPair)
    {
        pKerningData     = GET_KERNDATA(pUFM);
        pFMDev->pUCKernTree = pKerningData->KernPair;
        pFM->flFlags    |= FM_KERNRES;
    }

    return pvKernPair;

}

BOOL
BGetNewFontInfo(
    FONTMAP   *pFM,
    BYTE      *pRes)
/*++

Routine Description:


Arguments:

    pfm           Pointer to FONTMAP
    pRes          Pointer to UFM resource

Return Value:

    TRUE for success and FALSE for failure
Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    PUNIFM_HDR      pUFM;
    PUNIDRVINFO     pUnidrvInfo;
    PIFIMETRICS     pIFI;
    PKERNDATA       pKerningData;
    PFONTMAP_DEV    pFMDev;

    //
    // Paremeter validation
    //

    ASSERT(pFM != NULL || pRes != NULL);

    //
    // Get UFM data
    //

    pFMDev = pFM->pSubFM;
    pFMDev->pvFontRes = pRes;
    pUFM           = (PUNIFM_HDR)pRes;


    if (pUFM == NULL ||
        pUFM->loIFIMetrics == 0)
    {
        ERR(("UniFont!BGetNewFontInfo failed: Invalid FONTMAP.pUFMFontRes\n"));
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Get data pointer of UFM
    //

    pUnidrvInfo = GET_UNIDRVINFO(pUFM);

    //
    // Fill out FONTMAP members
    //
    if (0 != pUFM->loIFIMetrics % sizeof(PVOID))
    {
        DWORD dwSize;
        CopyMemory(&dwSize, (PBYTE)pUFM + pUFM->loIFIMetrics, sizeof(dwSize));

        if (pFM->pIFIMet = MemAlloc(dwSize))
        {
            pIFI = GET_IFIMETRICS(pUFM);
            CopyMemory(pFM->pIFIMet, pIFI, dwSize);
            pIFI = pFM->pIFIMet;
            pFM->flFlags &= ~FM_IFIRES;
        }
        else
            return FALSE;
    }
    else
    {
        pIFI         = GET_IFIMETRICS(pUFM);
        pFM->pIFIMet = pIFI;
        pFM->flFlags = FM_IFIRES;
    }


    if (pUnidrvInfo->SelectFont.dwCount && pUnidrvInfo->SelectFont.loOffset)
    {
        pFMDev->cmdFontSel.FInv.dwCount =
                pUnidrvInfo->SelectFont.dwCount;

        pFMDev->cmdFontSel.FInv.pubCommand =
                GET_SELECT_CMD(pUnidrvInfo);

        pFM->flFlags    |= FM_FINVOC | FM_FONTCMD;
    }

    if (pUnidrvInfo->UnSelectFont.dwCount && pUnidrvInfo->UnSelectFont.loOffset)
    {
        pFMDev->cmdFontDesel.FInv.dwCount =
                pUnidrvInfo->UnSelectFont.dwCount;

        pFMDev->cmdFontDesel.FInv.pubCommand =
                GET_UNSELECT_CMD(pUnidrvInfo);

        pFM->flFlags    |= FM_FINVOC | FM_FONTCMD;
    }

    if (pUFM->loExtTextMetric)
    {
        pFMDev->pETM = GET_EXTTEXTMETRIC(pUFM);
    }

    if (pUFM->loWidthTable)
    {
        pFMDev->W.pWidthTable = GET_WIDTHTABLE(pUFM);

        if (pUFM->loWidthTable % sizeof(PVOID))
        {
            DWORD dwSize;
            PVOID pWidthTmp;

            CopyMemory(&dwSize, pFMDev->W.pWidthTable, sizeof(DWORD));

            if (pWidthTmp = MemAlloc(dwSize))
            {
                CopyMemory(pWidthTmp, pFMDev->W.pWidthTable, dwSize);
                pFMDev->W.pWidthTable = pWidthTmp;
            }
            else
            {
                if( pFM->pIFIMet && !(pFM->flFlags & FM_IFIRES))
                {
                    MEMFREEANDRESET(pFM->pIFIMet);
                }
                return FALSE;
            }
        }
        else
        {
            pFM->flFlags |= FM_WIDTHRES;
        }
    }

    if (pUFM->loKernPair)
    {
        pKerningData     = GET_KERNDATA(pUFM);
        pFMDev->pUCKernTree = pKerningData->KernPair;
        pFM->flFlags    |= FM_KERNRES;
    }

    pFMDev->wDevFontType = pUnidrvInfo->wType;
    pFMDev->ulCodepage   = pUFM->ulDefaultCodepage;
    pFM->wFirstChar      = pIFI->wcFirstChar;
    pFM->wLastChar       = pIFI->wcLastChar;
    pFM->wXRes           = pUnidrvInfo->wXRes;
    pFM->wYRes           = pUnidrvInfo->wYRes;
    pFMDev->sYAdjust     = pUnidrvInfo->sYAdjust;
    pFMDev->sYMoved      = pUnidrvInfo->sYMoved;
    pFMDev->sCTTid       = (SHORT)pUFM->lGlyphSetDataRCID;
    pFMDev->fCaps        = pUnidrvInfo->fCaps;

    return TRUE;

}


INT
IGetUFMGlyphWidth(
    PDEV     *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    )
/*++

Routine Description:


Arguments:

    pFM           Pointer to FONTMAP

Return Value:

    Width

Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{

    return IGetUFMGlyphWidthJr(&(pPDev->ptGrxRes), pFM, hg);
}


INT
IGetUFMGlyphWidthJr(
    POINT    *pptGrxRes,
    FONTMAP  *pFM,
    HGLYPH     hg
    )
/*++

Routine Description:


Arguments:

    pFM           Pointer to FONTMAP

Return Value:

    Width

Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    TRANSDATA      *pTrans;
    MAPTABLE       *pMapTable;
    FONTMAP_DEV    *pFMDev;
    INT             iGlyphWidth;

    //
    // UNIDRV returns 1 for the first glyph handle in FD_GLYPHSET.
    // However, GDI could pass zero in hg.
    // We need to handle this GDI error properly.
    // 
    if (NULL == pFM || NULL == pptGrxRes || 0 == hg)
    {
        return  0;
    }

    pFMDev    = pFM->pSubFM;

    if ((pFM->flFlags & FM_WIDTHRES) &&
        (iGlyphWidth = SGetWidth(pFMDev->W.pWidthTable, hg)))
    {
        iGlyphWidth = iGlyphWidth * pptGrxRes->x / pFM->wXRes;
    }
    else
    {
        pMapTable = GET_MAPTABLE(pFMDev->pvNTGlyph);
        pTrans = pMapTable->Trans;
        if (IS_DBCSCHARSET(((IFIMETRICS*)pFM->pIFIMet)->jWinCharSet))
        {
            if (pTrans[hg - 1].ubType & MTYPE_DOUBLE)
            {
                iGlyphWidth = (INT)((PIFIMETRICS)pFM->pIFIMet)->fwdMaxCharInc;
                //VERBOSE(("(2)MTYPE_DOUBLE:Char=0x%x%x, ",
                //                 pTrans[hg-1].uCode.ubPairs[0],
                //                 pTrans[hg-1].uCode.ubPairs[1]));
            }
            else
            {
                iGlyphWidth = (INT)((PIFIMETRICS)pFM->pIFIMet)->fwdAveCharWidth;
                //VERBOSE(("(2)MTYPE_SINGLE:Char=%d, ",
                //                   pTrans[hg-1].uCode.ubCode));
            }
        }
        else
        {
            iGlyphWidth = (INT)((PIFIMETRICS)pFM->pIFIMet)->fwdMaxCharInc;
        }
    }

    //VERBOSE(("Width=%d\n",iGlyphWidth));
    return iGlyphWidth;
}

BOOL
BGTTOutputGlyph(
    TO_DATA *pTod)

/*++

Routine Description:
    Same as BRLEOutputGlyph in textout.c. Should use GTT data instead of
    RLE.

Arguments:

    pTod - a pointer to TEXTOUT DATA (TO_DATA) structure

Return Value:

    TRUE for success and FALSE for failure
Note:

    02/14/97 -eigos-
        Created it.
--*/
{
    FONTPDEV          *pFontPDev;
    IFIMETRICS        *pIFIMetrics;
    PUNI_GLYPHSETDATA  pGlyphSetData;
    PUNI_CODEPAGEINFO  pCodePageInfo;
    PMAPTABLE          pMapTable;
    COMMAND           *pCmd;
    PTRANSDATA         pTrans;
    PFONTMAP_DEV       pFMDev;
    PDEV              *pPDev;
    HGLYPH             hg;
    FONTMAP           *pFM;
    PGLYPHPOS          pgp;
    POINTL             ptlRem;


    PBYTE              pString;
    DWORD              dwSize, cGlyphs;
    INT                iX, iY, iXInc, iYInc;
    BOOL               bRet;
    BOOL               bSetCursorForEachGlyph;

    pPDev         = pTod->pPDev;
    pFontPDev     = pPDev->pFontPDev;
    pFM           = pTod->pfm;
    pIFIMetrics   = (IFIMETRICS*)pFM->pIFIMet;
    pFMDev        = pFM->pSubFM;
    pGlyphSetData = (PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph;
    cGlyphs       = pTod->cGlyphsToPrint;
    pgp           = pTod->pgp;

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    if (!bSetCursorForEachGlyph ||
        pFontPDev->flFlags & FDV_DISABLE_POS_OPTIMIZE)
    {
	//
        // If bSetCursorForEachGlyph is not set, send the first character's
        // position.
        //
        // FDV_DISABLE_POS_OPTIMIZE
	// If there is rounding error, when scaling width,
	// disable x position optimization
	//

        VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);
    }

    pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;

    //
    // Set the cursor to the desired X position for this glyph.  NOTE
    // that we should only use RELATIVE move commands in here,  since
    // the LaserJet family rotates the COORDINATE AXES when text is
    // being rotated by multiples of 90 degrees.  Using relative moves
    // means we can avoid trying to figure out where the printer thinks
    // the print positiion is located.  It's almost guaranteed to be
    // different to what we think it is!
    //
    // DCR - should reorganise the move command code to do a better
    // job here.  Problem is that if we are rotating the bitmap, then MV_FINE
    // is NOT a good idea,  since it almost undoubtedly move the cursor in
    // the WRONG dimension!   When we are rotating the bitmap,  it is most
    // probable that the MV_FINE will move in the Y direction!!!
    //

    bRet = TRUE;
    iX = iY = 0;

    if (pGlyphSetData != NULL)
    {
        while (cGlyphs --)
        {
            //
            // Do nothing. GDI could pass ZERO HGLYPH.
            // GTT glyph handle starts from 1. GDI is not supposed to pass 0 in
            // HGLYPH.
            //
            if (0 == pgp->hg)
                continue;

            hg = pgp->hg;
            iX = pgp->ptl.x;
            iY = pgp->ptl.y;

            //
            // Move to the next character's position
            //
            if (bSetCursorForEachGlyph)
                VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

            //
            // Minidriver defined glyph conversion
            //

            pMapTable     = GET_MAPTABLE((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph);
            pTrans        = pMapTable->Trans;

            //
            // Send symbol set selection command
            //

            if ( pFMDev->ulCodepageID != pTrans[hg - 1].ubCodePageID )
            {
                if (pFMDev->ulCodepageID != -1)
                {
                    pCodePageInfo = GET_CODEPAGEINFO((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph);
                    pCodePageInfo += pFMDev->ulCodepageID;
                    pString = (PBYTE)pCodePageInfo +
                              pCodePageInfo->UnSelectSymbolSet.loOffset;
                    dwSize = pCodePageInfo->UnSelectSymbolSet.dwCount;

                    if (dwSize)
                    {
                        WriteSpoolBuf(pPDev, pString, dwSize);
                    }
                }

                pFMDev->ulCodepageID = pTrans[hg - 1].ubCodePageID;
                pCodePageInfo = GET_CODEPAGEINFO((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph);
                pCodePageInfo += pFMDev->ulCodepageID;
                pString = (PBYTE)pCodePageInfo +
                          pCodePageInfo->SelectSymbolSet.loOffset;
                dwSize = pCodePageInfo->SelectSymbolSet.dwCount;

                if (dwSize)
                {
                    WriteSpoolBuf(pPDev, pString, dwSize);
                }
            }

            //
            // Single/Double byte mode switch
            //

            if ((pTrans[hg - 1].ubType & MTYPE_SINGLE) &&
                !(pFontPDev->flFlags & FDV_SINGLE_BYTE)  )
            {
                if(pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTSINGLEBYTEMODE))
                {
                    pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
                    WriteChannel( pPDev, pCmd );
                }
                else
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
            }
            else
            if ((pTrans[hg - 1].ubType & MTYPE_DOUBLE)   &&
                !(pFontPDev->flFlags & FDV_DOUBLE_BYTE) )
            {
                if (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTDOUBLEBYTEMODE))
                {
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_SINGLE_BYTE;
                    WriteChannel( pPDev, pCmd );
                }
                else
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;

            }

            //
            // Send string
            //

            switch(MTYPE_FORMAT_MASK & pTrans[hg - 1].ubType)
            {
            case MTYPE_DIRECT:
                bRet = WriteSpoolBuf(pPDev, &(pTrans[hg - 1].uCode.ubCode), 1) == 1;
                break;

            case MTYPE_PAIRED:
                //
                //   First, try to use cursor push/pop escapes to
                // overlay the 2 characters. If they are not
                // available, try the backspace. If it doesn't exist
                // either, ignore the second character.
                //

                pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_PUSHCURSOR);

                pString = pTrans[hg - 1].uCode.ubPairs;

                if (pTrans[hg - 1].ubType & (MTYPE_SINGLE|MTYPE_DOUBLE))
                {
                    bRet = WriteSpoolBuf( pPDev, pString, 2 ) == 2;
                }
                else
                {
                    if ( *(pString + 1) && (pCmd != NULL) )
                    {
                        //
                        // Pushed the position; output ch1, pop position, ch2
                        //

                        bRet = WriteSpoolBuf( pPDev, pString, 1 ) == 1;
                        WriteChannel( pPDev, pCmd );
                        bRet = WriteSpoolBuf( pPDev, pString + 1, 1 ) == 1;
                    }
                    else
                    {
                        pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_BACKSPACE);

                        bRet = WriteSpoolBuf( pPDev, pString, 1 ) == 1;
                        if( (*(pString + 1)) && (pFontPDev->flFlags & FDV_BKSP_OK) )
                        {
                            WriteChannel( pPDev, pCmd );
                            bRet = WriteSpoolBuf( pPDev, pString + 1, 1 ) == 1;
                        }
                    }
                }
                break;

            case MTYPE_COMPOSE:
                pString = (PBYTE)pMapTable + pTrans[hg - 1].uCode.sCode;
                bRet = (WriteSpoolBuf(pPDev, pString + 2, *(PWORD)pString) ==
                        *(PWORD)pString);

                break;

            }

            pgp++;


            //
            // After drawing the character, in the printer, the cursor position
            // moves. Update the UNIDRV internal value to reduce the amount of
            // command to send.
            //
            if (bSetCursorForEachGlyph)
            {
                if( pFM->flFlags & FM_WIDTHRES)
                {
                    if ((iXInc = SGetWidth(pFMDev->W.pWidthTable, hg)))
                        iXInc = iXInc * pPDev->ptGrxRes.x / pFM->wXRes;
                    else
                        iXInc = pIFIMetrics->fwdAveCharWidth;
                }
                else
                {
                    if (pTrans[hg - 1].ubType & MTYPE_DOUBLE)
                        iXInc = pIFIMetrics->fwdMaxCharInc;
                    else
                        iXInc = pIFIMetrics->fwdAveCharWidth;
                }

                if (pFM->flFlags & FM_SCALABLE)
                {
                    iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
                }

                if (pTod->flAccel & SO_VERTICAL)
                {
                    iYInc = iXInc;
                    iXInc = 0;
                }
                else
                {
                    iYInc = 0;
                }

                VSetCursor( pPDev,
                            iXInc,
                            iYInc,
                            MOVE_RELATIVE|MOVE_UPDATE,
                            &ptlRem);
            }
        }
    }
    else
    {
        bRet = FALSE;
    }

    if (bRet && pFM)
    {
        if (!bSetCursorForEachGlyph)
        {
            //
            // Output may have successed, so update the position.
            //

            if (pFM->flFlags & FM_WIDTHRES)
            {
                if (!(iXInc = SGetWidth(pFMDev->W.pWidthTable, hg)))
                    iXInc = pIFIMetrics->fwdAveCharWidth;
            }
            else
            {
                if (pTrans[hg - 1].ubType & MTYPE_DOUBLE)
                {
                    iXInc = pIFIMetrics->fwdMaxCharInc;
                }
                else
                {
                    iXInc = pIFIMetrics->fwdAveCharWidth;
                }
            }

            if (pFM->flFlags & FM_SCALABLE)
            {
                //
                // Need to transform the value to current size
                //
                iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
            }

            if (pTod->flAccel & SO_VERTICAL)
            {
                iYInc = iXInc;
                iXInc = 0;
            }
            else
            {
                iYInc = 0;
            }
            VSetCursor( pPDev,
                        (iX + iXInc) - pTod->pgp->ptl.x,
                        (iY + iYInc) - pTod->pgp->ptl.y,
                        MOVE_RELATIVE | MOVE_UPDATE,
                        &ptlRem);
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL
BGTTSelectFont(
    PDEV     *pPDev,
    PFONTMAP pFM,
    POINTL  *pptl)
{
    PFONTMAP_DEV pfmdev;
    INT          iCmdLength;
    PBYTE        pbCmd;

    pfmdev = pFM->pSubFM;

    if ((iCmdLength = (INT)pfmdev->cmdFontSel.FInv.dwCount) &&
        (pbCmd = pfmdev->cmdFontSel.FInv.pubCommand))
    {
        pfmdev->pfnDevSelFont( pPDev, pbCmd, iCmdLength, pptl);
    }

    //
    // Reset uLCodepageID to send codepage selection command.
    //
    pfmdev->ulCodepageID = (ULONG)-1;
    ((PFONTPDEV)pPDev->pFontPDev)->flFlags &= ~FDV_DOUBLE_BYTE | FDV_SINGLE_BYTE;

    return TRUE;
}


BOOL
BGTTDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM)
{
    PFONTMAP_DEV pfmdev;
    INT          iCmdLength;
    PBYTE        pbCmd;

    pfmdev = pFM->pSubFM;

    if ((iCmdLength = (INT)pfmdev->cmdFontDesel.FInv.dwCount) &&
        (pbCmd = pfmdev->cmdFontDesel.FInv.pubCommand)        &&
        iCmdLength != WriteSpoolBuf( pPDev, pbCmd, iCmdLength)     )
    {
        return FALSE;
    }

    return TRUE;
}

//
//
// Internal functions
//
//

BOOL
BExtractGTT(
    PUNI_GLYPHSETDATA  pGTT,
    WCHAR              wchFirst,
    WCHAR              wchLast,
    FD_GLYPHSET       *pFD_GLYPHSET,
    PDWORD             pdwFD_GLYPHSETSize)
/*++

Routine Description:

    Create FD_GLYPHSET from GLYPHRUN in GTT.

Arguments:

    pGTT - GTT file resource
    pFD_GLYPHSET - a buffer to be filled out
    pdwFD_GLYPHSETSize - a pointer to the size of FD_GLYPHSET

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/
{
    PGLYPHRUN pGlyphRun;
    HGLYPH    GlyphHandle, *pGlyphHandle;
    DWORD     dwI, dwGlyphNum;
    WORD      wJ;

    //
    // parameter validation
    //

    ASSERT(pGTT != NULL);

    if (pFD_GLYPHSET == NULL)
    {
        //
        // pFD_GLYPHSET == NULL case
        // return the necessary amount of memory
        //

        pGlyphRun  = GET_GLYPHRUN(pGTT);
        dwGlyphNum = 0;

        for (dwI = 0; dwI < pGTT->dwRunCount; dwI ++, pGlyphRun ++)
        {
            dwGlyphNum += pGlyphRun->wGlyphCount;
        }

        *pdwFD_GLYPHSETSize = sizeof(FD_GLYPHSET) +
                              (pGTT->dwRunCount - 1) * sizeof(WCRUN) +
                              dwGlyphNum * sizeof(HGLYPH);
    }
    else
    {
        //
        // pFD_GLYPHSET != NULL case
        // Fill out pFD_GLYPHSET
        //

        pFD_GLYPHSET->cjThis           = *pdwFD_GLYPHSETSize;
        pFD_GLYPHSET->flAccel          = 0;
        pFD_GLYPHSET->cGlyphsSupported = 0;
        pFD_GLYPHSET->cRuns            = pGTT->dwRunCount;

        pGlyphHandle                   = (HGLYPH*)( (PBYTE)pFD_GLYPHSET +
                                         sizeof(FD_GLYPHSET) +
                                         sizeof(WCRUN) * (pGTT->dwRunCount-1) );

        pGlyphRun                      = GET_GLYPHRUN(pGTT);
        dwGlyphNum                     = 0;

        //
        // IMPORTANT!!!: Glyph handle in FD_GLYPHSET starts from 1 for GTT.
        //
        GlyphHandle                    = 1;

        for (dwI = 0; dwI < pGTT->dwRunCount; dwI ++, pGlyphRun ++)
        {
            dwGlyphNum += pGlyphRun->wGlyphCount;

            pFD_GLYPHSET->awcrun[dwI].cGlyphs = pGlyphRun->wGlyphCount;
            pFD_GLYPHSET->awcrun[dwI].wcLow = pGlyphRun->wcLow;
            pFD_GLYPHSET->awcrun[dwI].phg = pGlyphHandle;

            for (wJ = 0; wJ < pGlyphRun->wGlyphCount; wJ ++,
                                                      pGlyphHandle ++,
                                                      GlyphHandle ++)
            {
                *pGlyphHandle = GlyphHandle;
            }
        }

        pFD_GLYPHSET->cGlyphsSupported = dwGlyphNum;
    }

    return TRUE;

}


SHORT
SGetWidth(
    PWIDTHTABLE pWidthTable,
    HGLYPH      hg)
{
    PWIDTHRUN pWidthRun = pWidthTable->WidthRun;
    PSHORT    psWidth;
    DWORD     dwRunCount = 0;

    while ( (hg < (ULONG)pWidthRun->wStartGlyph                          ||
            (ULONG)pWidthRun->wStartGlyph + pWidthRun->wGlyphCount <= hg  ) &&
            dwRunCount < pWidthTable->dwRunNum                               )
    {
        pWidthRun ++;
        dwRunCount ++;
    }

    if (dwRunCount == pWidthTable->dwRunNum)
    {
        return 0;
    }
    else
    {
        psWidth = (PSHORT)( (PBYTE)pWidthTable + pWidthRun->loCharWidthOffset );

        return psWidth[hg - pWidthRun->wStartGlyph];
    }
}

PUNI_GLYPHSETDATA
PNTGTT1To1(
    IN  DWORD dwCodePage,
    IN  BOOL  bSymbolCharSet,
    IN  INT   iFirstChar,
    IN  INT   iLastChar)
/*++

Routine Description:

    Generates a simple mapping format for the GTT stuff.  This is
    typically used for a printer with a 1:1 mapping to the Windows
    character set.

Arguments:

    iFirst:     The lowest glyph in the range.
    iLast:      The last glyph in the range (inclusive)


    Return Value:

    Address of GTT structure allocated from heap;  NULL on failure.


Note:
    11-27-96: Created it -ganeshp-
--*/
{

    PUNI_CODEPAGEINFO  pCodePageInfo;
    PGLYPHRUN         pGlyphRun, pGlyphRunOrg;

    TRANSDATA        *pTrans;
    PMAPTABLE         pMapTable;

    USHORT usAnsiCodePage, usOEMCodePage;

    INT  iNumOfHandle, iNumOfRuns, iTotalGlyphSetDataSize, iNumOfUnsupportChar;
    INT  iI, iJ, iK, iIndex;

    WCHAR awchUnicode[256];
    struct {
        WORD  wID;
        WCHAR Unicode;
    } UnicodeDst[256];
    WCHAR wchChar, wchCurrent, wchTemp;
    PBYTE pbBase;

    ASSERT(iFirstChar == 0x20 && iLastChar == 0xFF);

    iNumOfUnsupportChar = 0;
    iNumOfHandle =  iLastChar - iFirstChar + 1;

    if (iNumOfHandle > 256)
    {
        ERR(("UniFont!NTGTT1To1 failed:iNumOfHandle > 256.\n"));
        return NULL;
    }

    if (dwCodePage == 0)
    {
        dwCodePage = 1252;
    }

#ifndef WINNT_40 // NT 5.0
    if( -1 == (iNumOfHandle = EngMultiByteToWideChar(dwCodePage,
                                         awchUnicode,
                                         (INT)(iNumOfHandle * sizeof(WCHAR)),
                                         (PCH)aubAnsi+iFirstChar,
                                         (INT)iNumOfHandle)))
    {
        ERR(("UniFont!NTGTT1To1:EngMultiByteToWideChar failed\n"));
        return NULL;
    }
#else
    EngMultiByteToUnicodeN(awchUnicode, iNumOfHandle * sizeof(WCHAR), NULL, (PBYTE)aubAnsi+iFirstChar, iNumOfHandle);

    //
    // Disable new symbol set character range on NT4 (F020 to F0FF)
    //
    bSymbolCharSet = FALSE;
#endif // WINNT_40

    wchCurrent = 0;
    iNumOfRuns = 0;

    for (iI = 0; iI < iNumOfHandle; iI ++)
    {
        UnicodeDst[iI].wID = iI+iFirstChar;
        UnicodeDst[iI].Unicode = awchUnicode[iI];
    }

    qsort(UnicodeDst, iNumOfHandle, sizeof(WCHAR)+sizeof(WORD), Comp);

    for( iI = 0; iI < iNumOfHandle; iI ++ )
    {
        wchTemp = UnicodeDst[iI].Unicode;

        if (wchTemp == EURO_CUR_SYMBOL || wchTemp == 0xFFFF)
        {
            iNumOfUnsupportChar ++;
            UnicodeDst[iI].Unicode = 0;
            continue;
        }
        else
        if (wchTemp == wchCurrent + 1)
        {
            wchCurrent ++;
            continue;
        }

        wchCurrent = wchTemp;
        iNumOfRuns ++;
    }

    //
    // Create GLYPHRUN
    //

    if (bSymbolCharSet)
    {
        iNumOfRuns ++;
    }

    if( !(pGlyphRunOrg = pGlyphRun =
         (PGLYPHRUN)MemAlloc( iNumOfRuns * sizeof(GLYPHRUN) )) )
    {
        ERR(("UniFont!NTGTT1To1:MemAlloc failed\n"));
        return  NULL;
    }

    wchCurrent = 0;

    for (iI = 0; iI < iNumOfHandle; iI ++)
    {
        wchTemp = UnicodeDst[iI].Unicode;

        if (wchTemp == 0)
        {
            continue;
        }
        else
        if (wchTemp == wchCurrent + 1)
        {
            pGlyphRun->wGlyphCount++;
            wchCurrent ++;
        }
        else
        {
            if (wchCurrent != 0)
                pGlyphRun ++;

            wchCurrent             =
            pGlyphRun->wcLow       = wchTemp;
            pGlyphRun->wGlyphCount = 1;
        }
    }

    if (bSymbolCharSet)
    {
        pGlyphRun++;
        pGlyphRun->wcLow       = SYMBOL_START;
        pGlyphRun->wGlyphCount = NUM_OF_SYMBOL;
    }

    //
    // Calculate total size of this file.
    //

    iNumOfHandle -= iNumOfUnsupportChar;
    iTotalGlyphSetDataSize = sizeof(UNI_GLYPHSETDATA) +
                             sizeof(UNI_CODEPAGEINFO) +
                             iNumOfRuns * sizeof( GLYPHRUN ) +
                             sizeof(MAPTABLE) +
                             (iNumOfHandle - 1) * sizeof(TRANSDATA);
    if (bSymbolCharSet)
    {
        iTotalGlyphSetDataSize += sizeof(TRANSDATA) * NUM_OF_SYMBOL;
    }

    //
    // Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO
    //

    if( !(pbBase = MemAlloc( iTotalGlyphSetDataSize )) )
    {
        MemFree(pGlyphRunOrg);
        return  NULL;
    }

    ((PUNI_GLYPHSETDATA)pbBase)->dwVersion       = UNI_GLYPHSETDATA_VERSION_1_0;
    ((PUNI_GLYPHSETDATA)pbBase)->dwFlags         = 0;
    ((PUNI_GLYPHSETDATA)pbBase)->lPredefinedID   = CC_NOPRECNV;
    ((PUNI_GLYPHSETDATA)pbBase)->dwGlyphCount    = 0;
    ((PUNI_GLYPHSETDATA)pbBase)->dwCodePageCount = 1;
    ((PUNI_GLYPHSETDATA)pbBase)->dwRunCount      = iNumOfRuns;
    ((PUNI_GLYPHSETDATA)pbBase)->dwSize          = iTotalGlyphSetDataSize;
    ((PUNI_GLYPHSETDATA)pbBase)->loRunOffset     = sizeof(UNI_GLYPHSETDATA);
    ((PUNI_GLYPHSETDATA)pbBase)->loCodePageOffset =
                                    sizeof(UNI_GLYPHSETDATA) +
                                    sizeof(GLYPHRUN) * iNumOfRuns;
    ((PUNI_GLYPHSETDATA)pbBase)->loMapTableOffset =
                                    sizeof(UNI_GLYPHSETDATA) +
                                    sizeof(GLYPHRUN) * iNumOfRuns +
                                    sizeof(UNI_CODEPAGEINFO);

    CopyMemory(pbBase + sizeof(UNI_GLYPHSETDATA),
               pGlyphRunOrg,
               sizeof(GLYPHRUN) * iNumOfRuns);

    //
    // CodePageInfo
    //

    pCodePageInfo = (PUNI_CODEPAGEINFO)(pbBase + ((PUNI_GLYPHSETDATA)pbBase)->loCodePageOffset);

    pCodePageInfo->dwCodePage                 = dwCodePage;
    pCodePageInfo->SelectSymbolSet.dwCount    = 0;
    pCodePageInfo->UnSelectSymbolSet.dwCount  = 0;
    pCodePageInfo->SelectSymbolSet.loOffset   = 0;
    pCodePageInfo->UnSelectSymbolSet.loOffset = 0;

    //
    // MapTable
    //

    pMapTable = (PMAPTABLE)(pbBase +
                            ((PUNI_GLYPHSETDATA)pbBase)->loMapTableOffset);

    pMapTable->dwSize = sizeof(MAPTABLE) +
                        (iNumOfHandle - 1) * sizeof(TRANSDATA);

    pMapTable->dwGlyphNum =  iNumOfHandle;

    pTrans = pMapTable->Trans;

    iIndex = 0;
    iK = 0;

    pGlyphRun = pGlyphRunOrg;

    if (bSymbolCharSet)
    {
        for( iI = 0;  iI < iNumOfRuns; iI ++, pGlyphRun ++)
        {
            if (pGlyphRun->wcLow == SYMBOL_START)
            {
                for (iJ = SYMBOL_START; iJ <= SYMBOL_END; iJ ++)
                {
                    pTrans[iIndex].ubCodePageID = 0;
                    pTrans[iIndex].ubType       = MTYPE_DIRECT;
                    pTrans[iIndex].uCode.ubCode = (BYTE)iJ;

                    iIndex++;
                }
            }
            else
            {
                for( iJ = 0;  iJ < pGlyphRun->wGlyphCount; iJ ++)
                {
                    while (iK < 256 && UnicodeDst[iK].Unicode == 0)
                    {
                        iK++;
                    }

                    if (iK < 256)
                    {
                        pTrans[iIndex].ubCodePageID = 0;
                        pTrans[iIndex].ubType       = MTYPE_DIRECT;
                        pTrans[iIndex].uCode.ubCode = (BYTE)UnicodeDst[iK++].wID;
                        iIndex++;
                    }
                }
            }
        }
    }
    else
    {
        for( iI = 0;  iI < iNumOfHandle; iI ++)
        {
            while (iK < 256 && UnicodeDst[iK].Unicode == 0)
            {
                iK++;
            }

            if (iK < 256)
            {
                pTrans[iIndex].ubCodePageID = 0;
                pTrans[iIndex].ubType       = MTYPE_DIRECT;
                pTrans[iIndex].uCode.ubCode = (BYTE)UnicodeDst[iK++].wID;
                iIndex++;
            }
        }
    }

    MemFree(pGlyphRunOrg);

    VDBGDUMPGTT((PUNI_GLYPHSETDATA)pbBase);

    return (PUNI_GLYPHSETDATA)pbBase;
}

BOOL
BExtractGTTwithPredefGTT(
    IN PUNI_GLYPHSETDATA pPreDefGTT,
    IN PUNI_GLYPHSETDATA pMiniDefGTT,
    IN WCHAR             wchFirst,
    IN WCHAR             wchLast,
    OUT FD_GLYPHSET     **ppFD_GLYPHSET,
    OUT MAPTABLE        **ppMapTable,
    IN PDWORD            pdwFD_GLYPHSETSize)
{
    PGLYPHRUN  pPreDefGlyphRun, pMiniDefGlyphRun;
    PMAPTABLE  pMiniMapTable;
    PTRANSDATA pMiniDefTrans, pPreDefTrans;
    PTRANSDATA pSrcTrans, pDstTrans, pNewTrans, pTrans;
    WCRUN*     pWCRun;
    HGLYPH     *pHGlyph;

    DWORD      dwGlyphNum, dwMapTableSize, dwRunCount, dwIndex, dwI;
    DWORD      dwAddGlyphNum, dwSubGlyphNum, dwType;
    WORD       wJ;
    WCHAR      wcLow, wcHigh;
    BOOL       bInRun;

    //
    // FD_GLYPHSET creation.
    //
    // Additonal case:
    //     case 1: the begining of predef run
    //             Change wcLow and add cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 2: the end of predef run
    //             Change add cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 3: not in the predef run
    //             Add new WCRUN
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //
    // Disable case:
    //     case 1: the begining of predef run
    //             Change wcLow and cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 2: in the middle of predef run
    //             Divide this run into two different run.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 3: the end of predef run
    //             Change cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //
    // Replace case:
    //     Do nothing.
    //

    ASSERT(pPreDefGTT != NULL && pMiniDefGTT);

    //
    // Count glyph number in predefined GTT.
    //

    dwGlyphNum = 0;
    pPreDefGlyphRun = GET_GLYPHRUN(pPreDefGTT);

    for (dwI = 0; dwI < pPreDefGTT->dwRunCount; dwI ++, pPreDefGlyphRun ++)
    {
        dwGlyphNum += pPreDefGlyphRun->wGlyphCount;
    }

    pPreDefGlyphRun  = GET_GLYPHRUN(pPreDefGTT);
    pMiniDefGlyphRun = GET_GLYPHRUN(pMiniDefGTT);
    pMiniMapTable    = GET_MAPTABLE(pMiniDefGTT);

    dwIndex = 0;

    dwAddGlyphNum = 0;
    dwSubGlyphNum = 0;

    //
    // Count a total glyph number and glyph run number.
    //

    for (dwI = 0; dwI < pMiniDefGTT->dwRunCount; dwI ++, pMiniDefGlyphRun ++)
    {
        wcHigh = pMiniDefGlyphRun->wcLow + pMiniDefGlyphRun->wGlyphCount;

        for (wJ = pMiniDefGlyphRun->wcLow; wJ < wcHigh; wJ ++, dwIndex ++)
        {
            switch (pMiniMapTable->Trans[dwIndex].ubType & MTYPE_PREDEFIN_MASK)
            {
            case MTYPE_ADD:
                dwAddGlyphNum ++;
                break;

            case MTYPE_DISABLE:
                dwSubGlyphNum ++;
                break;

            case MTYPE_REPLACE:
            default:
                break;
            }
        }
    }

    dwGlyphNum += dwAddGlyphNum - dwSubGlyphNum;

    //
    // Create MAPTABLE
    //
    // Memory allocation
    // Creation
    //
    // ----------------
    //  Predefined MAPPTABLE (1 -> n glyph handle)
    //  Minidriver's MTYPE_DISABLE is already removed.
    // ----------------
    //  Minidriver additional MAPTABLE
    //  (n + 1  -> n + m) glyph handle
    //  Even if some glyphs could be merged into Predefined MAPTABLE, we
    //  separate them with minidriver's additional glyphs for a convenience.
    // ----------------
    //

    dwMapTableSize = sizeof(MAPTABLE) + sizeof(TRANSDATA) * (dwGlyphNum - 1);

    if((*ppMapTable = MemAlloc(dwMapTableSize)) == NULL)
    {
        return FALSE;
    }

    //
    // Fill in MAPTABLE
    //

    (*ppMapTable)->dwSize     = dwMapTableSize;
    (*ppMapTable)->dwGlyphNum = dwGlyphNum;

    pPreDefGlyphRun  = GET_GLYPHRUN(pPreDefGTT);
    pMiniDefGlyphRun = GET_GLYPHRUN(pMiniDefGTT);
    pMiniMapTable    = GET_MAPTABLE(pMiniDefGTT);
    pPreDefTrans     = (GET_MAPTABLE(pPreDefGTT))->Trans;
    pMiniDefTrans    = pMiniMapTable->Trans;
    pTrans           = (*ppMapTable)->Trans;
    pNewTrans        = (*ppMapTable)->Trans + dwGlyphNum - dwAddGlyphNum;

    dwIndex      = 0;
    dwRunCount   = 0;

    for (dwI = 0; dwI < pPreDefGlyphRun->wGlyphCount; dwI ++)
    {
        wcHigh = pPreDefGlyphRun->wcLow + pPreDefGlyphRun->wGlyphCount;
        bInRun = FALSE;

        for (wJ = pPreDefGlyphRun->wcLow; wJ < wcHigh; wJ ++)
        {
            dwType = DwCheckTrans(pMiniDefGlyphRun,
                                  pMiniMapTable,
                                  pMiniDefGTT->dwRunCount,
                                  wJ);

            if ( (dwType == 0) || (dwType == MTYPE_REPLACE) )
            {
                if (!bInRun)
                {
                    dwRunCount ++;
                    bInRun = TRUE;
                }

                if (!dwType )
                {
                    pSrcTrans = pPreDefTrans;
                    pDstTrans = pTrans;
                }
                else
                if (dwType == MTYPE_REPLACE)
                {
                    pSrcTrans = pMiniDefTrans;
                    pDstTrans = pTrans;
                }

                pDstTrans->ubCodePageID = pSrcTrans->ubCodePageID;
                pDstTrans->ubType       = pSrcTrans->ubType;

                switch(pSrcTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_COMPOSE:
                    pDstTrans->uCode.ubCode = pSrcTrans->uCode.ubCode;
                    break;

                case MTYPE_DIRECT:
                    pDstTrans->uCode.ubPairs[0] = pSrcTrans->uCode.ubPairs[0];
                    pDstTrans->uCode.ubPairs[1] = pSrcTrans->uCode.ubPairs[1];
                    break;

                case MTYPE_PAIRED:
                    pDstTrans->uCode.sCode = pSrcTrans->uCode.sCode;
                    break;
                }

                pSrcTrans ++;
                pDstTrans ++;
            }
            else
            if (dwType == MTYPE_DISABLE)
            {
                pPreDefTrans ++;

                if (bInRun && wJ != wcHigh - 1)
                {
                    dwRunCount ++;
                    bInRun = FALSE;
                }
            }
        }
    }


    for (dwI = 0; dwI < pMiniDefGlyphRun->wGlyphCount; dwI ++)
    {
        wcHigh = pMiniDefGlyphRun->wcLow + pMiniDefGlyphRun->wGlyphCount;
        bInRun = FALSE;

        for (wJ = pMiniDefGlyphRun->wcLow; wJ < wcHigh; wJ ++, pMiniDefTrans ++)
        {
            if (pMiniDefTrans->ubType & MTYPE_ADD)
            {
                pNewTrans->ubCodePageID = pMiniDefTrans->ubCodePageID;
                pNewTrans->ubType       = pMiniDefTrans->ubType;

                switch (pNewTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_COMPOSE:
                    pNewTrans->uCode.ubCode = pMiniDefTrans->uCode.ubCode;
                    break;

                case MTYPE_DIRECT:
                    pNewTrans->uCode.ubPairs[0] = pMiniDefTrans->uCode.ubPairs[0];
                    pNewTrans->uCode.ubPairs[1] = pMiniDefTrans->uCode.ubPairs[1];
                    break;

                case MTYPE_PAIRED:
                    pNewTrans->uCode.sCode = pMiniDefTrans->uCode.sCode;
                    break;
                }

                pNewTrans ++;

                if (!bInRun)
                {
                    dwRunCount ++;
                    bInRun = TRUE;
                }
            }
            else
            {
                if (bInRun)
                {
                    bInRun = FALSE;
                }
            }
        }
    }

    //
    // Crate FD_GLYPHSET
    //
    // Memory allocation with dwGlyphNum and dwRunCount.
    //
    // -----------------
    // Predefined FD_GLYPHSET
    // -----------------
    // Minidriver additional glyph run
    // ----------------
    //

    //
    // Now we know the number of run. Allocate memory for FD_GLYPHSET.
    //

    *pdwFD_GLYPHSETSize = sizeof(FD_GLYPHSET) +
                          sizeof(WCRUN) * dwRunCount +
                          sizeof(HGLYPH) * dwGlyphNum;

    if((*ppFD_GLYPHSET = (FD_GLYPHSET*)MemAlloc(*pdwFD_GLYPHSETSize)) == NULL)
    {
        MemFree(*ppMapTable);
        return FALSE;
    }

    (*ppFD_GLYPHSET)->cjThis           = *pdwFD_GLYPHSETSize;
    (*ppFD_GLYPHSET)->cGlyphsSupported = *pdwFD_GLYPHSETSize;
    (*ppFD_GLYPHSET)->cRuns            = dwRunCount;

    pWCRun           = (*ppFD_GLYPHSET)->awcrun;
    pHGlyph          = (HGLYPH*)((PBYTE)*ppFD_GLYPHSET +
                                  sizeof(FD_GLYPHSET) +
                                  sizeof(WCRUN) * dwRunCount);

    pPreDefGlyphRun  = GET_GLYPHRUN(pPreDefGTT);
    pMiniDefGlyphRun = GET_GLYPHRUN(pMiniDefGTT);
    pMiniDefTrans    = pMiniMapTable->Trans;

    for (dwI = 1; dwI <= dwGlyphNum; dwI ++, *pHGlyph)
    {
        *pHGlyph = dwI;
    }

    pHGlyph = (HGLYPH*)((PBYTE)*ppFD_GLYPHSET +
                        sizeof(FD_GLYPHSET) +
                        sizeof(WCRUN) * dwRunCount);

    for (dwI = 0; dwI < pPreDefGlyphRun->wGlyphCount; dwI ++)
    {
        pWCRun->wcLow = wcLow
                      = pPreDefGlyphRun->wcLow;
        wcHigh        = wcLow + pPreDefGlyphRun->wGlyphCount;
        bInRun        = FALSE;

        for (wJ = pPreDefGlyphRun->wcLow; wJ < wcHigh; wJ ++)
        {
            if (MTYPE_DISABLE == DwCheckTrans(pMiniDefGlyphRun,
                                              pMiniMapTable,
                                              pMiniDefGTT->dwRunCount,
                                              wJ))
            {
                if (bInRun)
                {
                    pWCRun->cGlyphs = wJ - wcLow + 1;
                    pWCRun->phg     = pHGlyph;
                    pHGlyph        += pWCRun->cGlyphs;

                    pWCRun ++;
                    bInRun = FALSE;
                }
            }
            else
            {
                if (!bInRun)
                {
                    pWCRun->wcLow = wcLow
                                  = wJ;
                    wcHigh        = wcLow + pPreDefGlyphRun->wGlyphCount;
                    bInRun        = TRUE;
                }
            }
        }
        pWCRun->cGlyphs = wcHigh - wcLow;
        pWCRun->phg = pHGlyph;

        pWCRun ++;
    }

    bInRun = FALSE;

    for (dwI = 0; dwI < pMiniDefGlyphRun->wGlyphCount; dwI ++)
    {
        for (wJ = pMiniDefGlyphRun->wcLow; wJ < wcHigh; wJ ++, pMiniDefTrans ++)
        {
            if (pMiniDefTrans->ubType & MTYPE_ADD)
            {
                if (!bInRun)
                {
                    pWCRun->wcLow  = wcLow = wJ;
                    bInRun         = TRUE;
                }
            }
            else
            {
                if (bInRun)
                {
                    pWCRun->cGlyphs = wJ - wcLow + 1;
                    pWCRun->phg     = pHGlyph;
                    pHGlyph        += pWCRun->cGlyphs;

                    bInRun          = FALSE;
                }
            }
        }
    }

    return TRUE;
}

DWORD
DwCheckTrans(
    PGLYPHRUN pMiniGlyphRun,
    PMAPTABLE pMiniMapTable,
    DWORD     dwMiniGlyphRunCount,
    WORD      wUnicode)
{
    DWORD dwI;
    WORD  wIndex;

    for (dwI = 0; dwI < dwMiniGlyphRunCount; dwI ++, pMiniGlyphRun ++)
    {
        if (wUnicode < pMiniGlyphRun->wcLow)
        {
            continue;
        }

        if (wUnicode < pMiniGlyphRun->wcLow + pMiniGlyphRun->wGlyphCount)
        {
            wIndex = wUnicode - pMiniGlyphRun->wcLow;

            return pMiniMapTable->Trans[wIndex].ubType & MTYPE_PREDEFIN_MASK;
        }
        else
        {
            return 0;
        }
    }

    return 0;
}

int __cdecl Comp(const void *elem1, const void *elem2)
{
    //struct {
    //    WORD  wID;
    //    WCHAR Unicode;
    //} UnicodeDst[256];
    //
    // Compare Unicode in this data structure
    //
    return *((PWORD)elem1+1) - *((PWORD)elem2+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\intrface.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Implementation of the interface between Control module and Font module

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    11/18/96 -ganeshp-
        FMInit implementation.
--*/

#include "font.h"

static FMPROCS UniFMFuncs =
{
    FMStartDoc,
    FMStartPage,
    FMSendPage,
    FMEndDoc,
    FMNextBand,
    FMStartBanding,
    FMResetPDEV,
    FMEnableSurface,
    FMDisableSurface,
    FMDisablePDEV,
    FMTextOut,
    FMQueryFont,
    FMQueryFontTree,
    FMQueryFontData,
    FMFontManagement,
    FMQueryAdvanceWidths,
    FMGetGlyphMode
};

//
// Local functions Prototype
//

BOOL
BFMInitDevInfo(
    DEVINFO *pDevInfo,
    PDEV    *pPDev
    );

BOOL
BInitStandardVariable(
    PDEV *pPDev);

BOOL
BCheckFontMemUsage(
    PDEV    *pPDev);

INT
iMaxFontID(
    IN INT      iMax,
    OUT DWORD   *pFontIndex);

VOID
VGetFromBuffer(
    IN PWSTR pwstrDest,
    IN OUT PWSTR *ppwstrSrc,
    IN OUT PINT  piRemBuffSize);

VOID
VSetReselectFontFlags(
    PDEV    *pPDev
    );

LRESULT
PartialClipOn(
    PDEV *pPDev);

//
//
// Main initialization function
//
//

BOOL
FMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO  *pGDIInfo
    )
/*++

Routine Description:

    This function is called to initialize font related information in
    pPDev, pDevInfo pGDIInfo and FontPDEV. This module will initialize
    various dat structures needed for other modules. For example all
    all the font specific resources will be loaded.

    The following fields of PDev are intialized:

    iFonts :    Number of Device Fonts including Cartridge and SoftFonts.
    ptDefaultFont: Default Font Width and Height in Device Units.
    pFontPDEV:  Font Module PDevice.
    pFontProcs: Font Module specific DDI callback functions pointers.
                Control Module uses this table to call different DDI
                entry points specific to Font Module.
    fHooks:     Set to  HOOK_TEXTOUT if the printer has device fonts.
    Also standard variables specific to font module will be initialized.

    The following fields of pDevInfo are intialized.

    lfDefaultFont : Default logical Device Font.
    lfAnsiVarFont: Default Logical Variable pitch Device font.
    lfAnsiFixFont: Default Logical Fixed pitch Device font.
    cFonts: Number of Device Fonts.

    The following fields of pGDIInfo will be initialized:

    flTextCaps : Text Capability Flags.

Arguments:

    pPDev           Pointer to PDEV
    pDevInfo        Pointer to DEVINFO
    pGDIInfo        Pointer to GDIINFO

Return Value:

    TRUE for success and FALSE for failure
Note:

--*/
{
    PFONTPDEV   pFontPDev;
    //
    // Validate Input Parameters and ASSERT.
    //

    ASSERT(pPDev);
    ASSERT(pDevInfo);
    ASSERT(pGDIInfo);

    //
    // Allocate and initialize FONTPDEV.
    //
    // Initialize FONTPDEV
    //
    // Build the Device Module specific data structures. This involves going
    // through Device and cartrige font list building the FONTMAP structure for
    // each of them. We also go through the soft font list and add them to the
    // list.
    //
    // Initialize FONTMAP
    //
    // Build the font map table.The font cartridges are stored as DT_FONTSCART.
    // The installed cartrides are stored in Registry. So we need a mapping
    // table of font cartridges names to translate the registry information
    // into a list of fonts. After buildind the font mapping table we read the
    // registry and mark the corresponding Font Cartridges as installed.
    //
    // Initialize Device font list from GPD.
    // Read the GPD data about Device Fonts. The font information is in PDEV.
    // The Device fonts are stored as LIST of resource IDs.
    //
    // Initialize DEVINFO specific fields.
    //
    // Initialize the GDIINFO specific fileds.
    //
    // This include text capability flag and other font specific information.
    //

    if ( !(pFontPDev = MemAllocZ(sizeof(FONTPDEV))) )
    {
        ERR(("UniFont!FMInit:Can't Allocate FONTPDEV"));
        return FALSE;

    }

    pPDev->pFontPDev = pFontPDev;

    //
    //Initialize various fields.
    //

    pFontPDev->dwSignature = FONTPDEV_ID;
    pFontPDev->dwSize = sizeof(FONTPDEV);
    pFontPDev->pPDev = pPDev;

    if (!BBuildFontCartTable(pPDev)     ||
        !BRegReadFontCarts(pPDev)       ||
        !BInitFontPDev(pPDev)           ||
        !BInitDeviceFontsFromGPD(pPDev) ||
        !BBuildFontMapTable(pPDev)      ||
        !BFMInitDevInfo(pDevInfo,pPDev) ||
        !BInitGDIInfo(pGDIInfo,pPDev)   ||
        !BInitStandardVariable(pPDev)    )
    {
        VFontFreeMem(pPDev);
        ERR(("Can't Initialize the Font specific data in PDEV"));
        return FALSE;
    }

    //
    // Initialze PDEV specific fields.
    //

    pPDev->pFontProcs = &UniFMFuncs;

    #if DO_LATER

    //
    // if the printer is not a serial printer.
    //

    if (pPDev->pGlobals->printertype != PT_SERIAL)
    {
        pPDev->fMode |= PF_FORCE_BANDING;
    }
    else
    {
        pPDev->fMode &= ~PF_FORCE_BANDING;
    }

    #endif //DO_LATER

    return TRUE;

}

//
//
// Initialization sub functions
//
// BInitFontPDev
// BBuildFontCartTable
// BRegReadFontCarts
// BInitDeviceFontsFromGPD
// BBuildFontMapTable
// BFMInitDevInfo
// BInitGDIInfo
// BInitStandardVariable
//


BOOL
BInitFontPDev(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine allocates the FONTPDEV and initializes various fileds.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    11-18-96: Created it -ganeshp-
--*/

{
    PFONTPDEV   pFontPDev  = PFDV;
    GLOBALS     *pGlobals = pPDev->pGlobals;
    DWORD       dwSize;
    INT         iMaxDeviceFonts;
    SHORT       sOrient;
    BOOL        bRet = FALSE;

    iMaxDeviceFonts   = IGetMaxFonts(pPDev);

    //
    // Allocate the font list buffer.
    //

    if ( iMaxDeviceFonts  &&
         !(pFontPDev->FontList.pdwList =
                        MemAllocZ(iMaxDeviceFonts * sizeof(DWORD))) )
    {
        ERREXIT("UniFont!BInitFontPDev:Can't Allocate Device Font List");
    }

    //
    // Set the number of entries
    //

    pFontPDev->FontList.iEntriesCt = 0;
    pFontPDev->FontList.iMaxEntriesCt = iMaxDeviceFonts;

    //
    // Set differnt General Flags
    //

    if ( pGlobals->bRotateFont)
        pFontPDev->flFlags |= FDV_ROTATE_FONT_ABLE;

    if ( pGlobals->charpos == CP_BASELINE)
        pFontPDev->flFlags |= FDV_ALIGN_BASELINE;

    if ( pGlobals->bTTFSEnabled)
        pFontPDev->flFlags |= FDV_TT_FS_ENABLED;

    //
    // Check if Memory should be tracked for font downloading
    //
    if ( BCheckFontMemUsage(pPDev) )
        pFontPDev->flFlags |= FDV_TRACK_FONT_MEM;

    //
    // Set the Reselect font Flags.
    //
    VSetReselectFontFlags(pPDev);


    if ( pGlobals->printertype == PT_SERIAL ||
         pGlobals->printertype == PT_TTY  )
        pFontPDev->flFlags |= FDV_MD_SERIAL;

    //
    // The code assumes that COMMANDPTR macro returns NULL if the
    // command doesn't exist.
    //

    if ( COMMANDPTR(pPDev->pDriverInfo, CMD_WHITETEXTON))
        pFontPDev->flFlags |= FDV_WHITE_TEXT;

    if ( COMMANDPTR(pPDev->pDriverInfo,CMD_SETSIMPLEROTATION ))
        pFontPDev->flFlags |= FDV_90DEG_ROTATION;

    if ( COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION))
        pFontPDev->flFlags |= FDV_ANYDEG_ROTATION;

    if (pPDev->fMode & PF_ANYCOLOR_BRUSH)
        pFontPDev->flFlags |= FDV_SUPPORTS_FGCOLOR;
    else // Monochrome case
    {
        //
        // PF_ANYCOLOR_BRUSH is set only for color printers with explicit
        // colormode. But Monochrome printers can also support dither color
        // using downloadable pattern brush. This is a good optimization because
        // we will do substitution or download instead of sending the text as
        // graphics. For enabling this mode the printer must support
        // CmdSelectBlackBrush so that Resetbrush  can rest the color to black
        // befroe sending raster. So for a monochrome printer if
        // CmdSelectBlackBrush, CmdDownloadPattern and CmdSelectPattern
        // are supported then we will set FDV_SUPPORTS_FGCOLOR.
        //
        if ( (pPDev->arCmdTable[CMD_DOWNLOAD_PATTERN] ) &&
             (pPDev->arCmdTable[CMD_SELECT_PATTERN])    &&
             (pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH])
           )
            pFontPDev->flFlags |= FDV_SUPPORTS_FGCOLOR;
    }

    if ( COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEON))
        pFontPDev->flFlags |= FDV_UNDERLINE;

    //
    // Set dwSelection bits
    //

    sOrient = (pPDev->pdm->dmFields & DM_ORIENTATION) ?
              pPDev->pdm->dmOrientation : (SHORT)DMORIENT_PORTRAIT;

    if ( sOrient == DMORIENT_LANDSCAPE )
        pFontPDev->dwSelBits |= FDH_LANDSCAPE;
    else
        pFontPDev->dwSelBits |= FDH_PORTRAIT;

    //
    //  If the printer can rotate fonts, then we don't care about
    //  the orientation of fonts.  Hence,  set both selection bits.
    //

    if( pFontPDev->flFlags & FDV_ROTATE_FONT_ABLE )
        pFontPDev->dwSelBits |= FDH_PORTRAIT | FDH_LANDSCAPE;

    //
    // Presume we can always print bitmap fonts,  so now add that
    // capability.
    //

    pFontPDev->dwSelBits |= FDH_BITMAP;

    //
    // Set the Text Scale Fasctor.
    //

    pFontPDev->ptTextScale.x = pGlobals->ptMasterUnits.x / pPDev->ptTextRes.x;
    pFontPDev->ptTextScale.y = pGlobals->ptMasterUnits.y / pPDev->ptTextRes.y;

    if ( pGlobals->dwLookaheadRegion  )
    {
        // !!!TODO pFontPDev->flFlags |=  FDV_FONT_PERMUTE;
        pPDev->dwLookAhead =  pGlobals->dwLookaheadRegion /
                              pFontPDev->ptTextScale.y;
    }

    //
    // Initialize the Text Flag.
    //

    if (!BInitTextFlags(pPDev) )
    {
        ERREXIT(("UniFont!BInitFontPDev:Can't initialize Text Flags\n"));

    }

    //
    // Initalize memory to be used by Font Module. If no memory tracking
    // has to be done the set the dwFontMem to a big value.

    if( (pFontPDev->flFlags & FDV_TRACK_FONT_MEM) )
       pFontPDev->dwFontMem = pPDev->dwFreeMem;

    //
    // If it is set to zero initialize this item to a big value. */
    //

    if (pFontPDev->dwFontMem == 0)
        pFontPDev->dwFontMem = MAXLONG;

    //
    // No DL font memory used */
    //

    pFontPDev->dwFontMemUsed = 0;

    //
    // Set Download specific information, if printer supports it */
    //

    if (pGlobals->fontformat != UNUSED_ITEM)
    {
        BOOL bValidFontIDRange;
        BOOL bValidGlyphIDRange;

        /* Start index */
        pFontPDev->iFirstSFIndex = pFontPDev->iNextSFIndex
                                 = pGlobals->dwMinFontID;

        pFontPDev->iLastSFIndex  = pGlobals->dwMaxFontID;

        /*
         *  There may also be a limit on the number of softfonts that the
         *  printer can support.  If not,  the limit is < 0, so when
         *  we see this,  set the value to a large number.
         */

        if ((pFontPDev->iMaxSoftFonts = (INT)pGlobals->dwMaxFontUsePerPage) < 0)
            pFontPDev->iMaxSoftFonts = pFontPDev->iLastSFIndex + 100;

        pFontPDev->flFlags       |= FDV_DL_INCREMENTAL;   //Always incremental.

        /*
         * Now varify that the font ID range is less that MAXWORD. This is
         * necessary, otherwise trunction will happen. We don't download
         * if the values are more than MAXWORD.
         */

        bValidFontIDRange = ((pFontPDev->iFirstSFIndex <= MAXWORD) &&
                             (pFontPDev->iLastSFIndex <= MAXWORD));

        //
        // If the downloaded font in not bound to a symbols set(i.e. dlsymbolset
        // is not defined), We don't want to download, if there are less than
        // 64 glyphs per downloaded font.
        //

        bValidGlyphIDRange = (pPDev->pGlobals->dlsymbolset != UNUSED_ITEM) ||
                             ( (pPDev->pGlobals->dlsymbolset == UNUSED_ITEM) &&
                               ( pPDev->pGlobals->dwMaxGlyphID -
                                 pPDev->pGlobals->dwMinGlyphID) >=
                                                   MIN_GLYPHS_PER_SOFTFONT );

        /*
         *   Consider enabling downloading of TT fonts. This is done only
         * if text and graphics resolutions are the same - otherwise
         * the TT fonts will come out smaller than expected, since they
         * will be generated for the lower graphics resolution yet
         * printed at the higher text resolution!  LaserJet 4 printers
         * can also download fonts digitised at 300dpi when operating
         * at 600 dpi,  so we also accept that as a valid mode.
         *
         *   Also check if the user wants this: if the no cache flag
         * is set in the driver extra part of the DEVMODE structure,
         * then we also do not set this flag.
         */

        VERBOSE(("pPDev->pdm->dmTTOption is %d\n",pPDev->pdm->dmTTOption));

        if( ( POINTEQUAL(pPDev->ptGrxRes,pPDev->ptTextRes) ||
              (pPDev->ptGrxRes.x >= 300 && pPDev->ptGrxRes.y >= 300))
            && (bValidFontIDRange)
            && (bValidGlyphIDRange)
            && (!(pPDev->fMode2 & PF2_MIRRORING_ENABLED))
            && (!(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS )) 
          )
        {
            //
            // Conditions have been met,  so set the flag
            // Check the application preference.
            //

            if( (pPDev->pdm->dmFields & DM_TTOPTION) &&
                (pPDev->pdm->dmTTOption != DMTT_BITMAP)
              )
            {
                pFontPDev->flFlags |= FDV_DLTT;

                //
                // Find Out if Download TT as TT is available or not. We only
                // want to do this if text and graphics resolutions are same.
                //

                if ( POINTEQUAL(pPDev->ptGrxRes,pPDev->ptTextRes) )
                {
                    if (pPDev->ePersonality == kPCLXL)
                        pFontPDev->flFlags |= FDV_DLTT_OEMCALLBACK;
                    else
                    if ( (pGlobals->fontformat ==  FF_HPPCL_OUTLINE) )
                        /*!!!TODO Enable after parser add this command &&
                         (COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTHEIGHT))*/
                    {
                        //
                        // We assume that if the printer support TT as outline,
                        // then TT as Bitmap format is also supported. We only
                        // support TrueType outline if font height selection
                        // command is present, else we assume download as
                        // bitmap.
                        //

                        pFontPDev->flFlags |= FDV_DLTT_ASTT_PREF;
                    }
                    else if ( pGlobals->fontformat == FF_OEM_CALLBACK)
                        pFontPDev->flFlags |= FDV_DLTT_OEMCALLBACK;
                    else //OEM CallBack
                        pFontPDev->flFlags |= FDV_DLTT_BITM_PREF;

                    //
                    // We also need to check the memory. For printers with
                    // less than 2MB of free memory, download as TT outline
                    // will be disabled.
                    //
                    if (pFontPDev->flFlags & FDV_DLTT_ASTT_PREF)
                    {
                        if (pPDev->dwFreeMem < (2L * ONE_MBYTE))
                        {
                            pFontPDev->flFlags &= ~FDV_DLTT_ASTT_PREF;
                            pFontPDev->flFlags |= FDV_DLTT_BITM_PREF;
                        }
                    }
                }
            }
        }
    }

    //
    // Initialize the Font state control structure */
    //

    pFontPDev->ctl.iSoftFont = -1;
    pFontPDev->ctl.iFont = INVALID_FONT;
    pFontPDev->ctl.dwAttrFlags = 0;
    pFontPDev->ctl.iRotate = 0;
    pFontPDev->ctl.pfm = NULL;

    //
    // Set the White and Black Ref Color
    //

    pFontPDev->iWhiteIndex = ((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;
    pFontPDev->iBlackIndex = ((PAL_DATA*)(pPDev->pPalData))->iBlackIndex;

    //
    // Initialize font substitution table from a registry.
    //
    pFontPDev->pTTFontSubReg = PGetTTSubstTable(pPDev->devobj.hPrinter, &dwSize);

    if (pPDev->pGlobals->bTTFSEnabled &&

            ( (pFontPDev->pTTFontSubReg &&
               *((PDWORD)pFontPDev->pTTFontSubReg) != 0) ||

              (!pFontPDev->pTTFontSubReg &&
               (INT)pPDev->pDriverInfo->DataType[DT_FONTSUBST].dwCount )
            )
       )
    //
    // Check if GPD supports "*TTFSEnableD?: TRUE"
    //       if there is a substitution table in registry
    //       if there is a default substitution table in GPD.
    //
    {
        pFontPDev->flFlags |= FDV_SUBSTITUTE_TT;
    }
    else
    {
        pFontPDev->flFlags &= ~FDV_SUBSTITUTE_TT;
    }

    //
    // Enable/Disable partial clipping
    //
    if (S_FALSE != PartialClipOn(pPDev))
        pFontPDev->flFlags |= FDV_ENABLE_PARTIALCLIP;
    else
        pFontPDev->flFlags &= ~FDV_ENABLE_PARTIALCLIP;

    //
    // store some members of pGlobals to save the memory allocation
    //

    pFontPDev->sDefCTT = (SHORT)pPDev->pGlobals->dwDefaultCTT;
    pFontPDev->dwDefaultFont = pPDev->pGlobals->dwDefaultFont;

    //
    // For TTY driver ask the minidriver for user selection of code page.
    //
    if ( pPDev->bTTY )
    {
        BOOL  bOEMinfo;
        INT   iTTYCodePageInfo;
        DWORD cbcNeeded;
        PFN_OEMTTYGetInfo   pfnOemTTYGetInfo;

        iTTYCodePageInfo = 0;
        bOEMinfo = FALSE ;

        FIX_DEVOBJ(pPDev, EP_OEMTTYGetInfo);

        if(pPDev->pOemEntry)
        {
            if(  ((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                            (PDEVOBJ)pPDev, OEMTTY_INFO_CODEPAGE, &iTTYCodePageInfo, sizeof(INT), &cbcNeeded);
                if( SUCCEEDED(hr))
                    bOEMinfo = TRUE ;
            }
            else  if((pfnOemTTYGetInfo = (PFN_OEMTTYGetInfo)pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pfnHook) &&
                 (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_CODEPAGE, &iTTYCodePageInfo, sizeof(INT), &cbcNeeded)))
                        bOEMinfo = TRUE ;
        }


        if(bOEMinfo)
        {
            //
            // predefined GTT ID case
            //
            if (iTTYCodePageInfo < 0)
            {
                pFontPDev->sDefCTT = (SHORT)iTTYCodePageInfo;
                switch (iTTYCodePageInfo)
                {
                    case CC_CP437:
                        pFontPDev->dwTTYCodePage = 437;
                        break;

                    case CC_CP850:
                        pFontPDev->dwTTYCodePage = 850;
                        break;

                    case CC_CP863:
                        pFontPDev->dwTTYCodePage = 863;
                        break;
                }
            }
            else
            {
                pFontPDev->dwTTYCodePage = iTTYCodePageInfo;
                switch (iTTYCodePageInfo)
                {
                case 936:
                    pFontPDev->sDefCTT = CC_GB2312;
                    break;

                case 950:
                    pFontPDev->sDefCTT = CC_BIG5;
                    break;

                case 949:
                    pFontPDev->sDefCTT = CC_WANSUNG;
                    break;

                case 932:
                    pFontPDev->sDefCTT = CC_SJIS;
                    break;

                default:
                    pFontPDev->sDefCTT = 0;
                    break;
                }
            }
        }

    }
    //
    // All Success
    //

    bRet = TRUE;

    ErrorExit:

    return bRet;

}

BOOL
BBuildFontCartTable(
    PDEV    *pPDev
    )

/*++

Routine Description:

    Builds the Fontcart Table. It reads the minidriver and get the
    FontCart string and the corresponding indexes and put them in the
    FontCart Table.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    11-18-96: Created it -ganeshp-
--*/

{


    PFONTPDEV       pFontPDev           = pPDev->pFontPDev;
    INT             iNumAllCartridges;
    INT             iIndex;
    PFONTCARTMAP    *ppFontCartMap      = &(pFontPDev->FontCartInfo.pFontCartMap);
    WINRESDATA      *pWinResData        = &(pPDev->WinResData);
    GPDDRIVERINFO   *pDriverInfo       = pPDev->pDriverInfo; // GPDDRVINFO
    FONTCART        *pFontCart ;

    /* Read the total number of Font Cartridges supported */
    iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts
                      = (INT)(pDriverInfo->DataType[DT_FONTSCART].dwCount);

    pFontPDev->FontCartInfo.dwFontCartSlots = pPDev->pGlobals->dwFontCartSlots;

    /* FONTCARTS are stored as arrayref and are contiguous. Get to the start
     * start of the array.
     */
    pFontCart = GETFONTCARTARRAY(pDriverInfo);


    if (iNumAllCartridges)
        *ppFontCartMap = MemAllocZ(iNumAllCartridges * sizeof(FONTCARTMAP) );
    else
        *ppFontCartMap = NULL;

    if(*ppFontCartMap)
    {
        PFONTCARTMAP pTmpFontCartMap = *ppFontCartMap; /* Temp Pointer */

        for( iIndex = 0; iIndex < iNumAllCartridges ;
                                    pTmpFontCartMap++, pFontCart++, iIndex++ )
        {
            if ( !ARF_IS_NULLSTRING(pFontCart->strCartName) )
            {
                wcsncpy( (PWSTR)(&(pTmpFontCartMap->awchFontCartName)),
                        GETSTRING(pDriverInfo, (pFontCart->strCartName)),
                        MAXCARTNAMELEN - 1);
            }
            else if ((ILoadStringW( pWinResData, pFontCart->dwRCCartNameID,
                        (PWSTR)(&(pTmpFontCartMap->awchFontCartName)),
                        (MAXCARTNAMELEN )))  == 0)
            {

                ERR(("\n UniFont!bBuildFontCartTable:FontCart Name not found\n") );
                continue;
            }

            pTmpFontCartMap->pFontCart = pFontCart;

            VERBOSE(("\n UniFont!bBuildFontCartTable:(pTmpFontCartMap->awchFontCartName)= %ws\n", (pTmpFontCartMap->awchFontCartName)));
            VERBOSE(("UniFont!bBuildFontCartTable:pTmpFontCartMap->pFontCart= %p\n", (pTmpFontCartMap->pFontCart)));

        }
    }
    else if (iNumAllCartridges)
    {
        ERR(("UniFont!bBuildFontCartTable:HeapAlloc for FONTCARTMAP table failed!!\n") );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE ;
    }

    return TRUE ;
}



BOOL
BInitDeviceFontsFromGPD(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine builds the device font list. The list include device resident
    fonts and the fonts specific to installed cartridges.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    11-18-96: Created it -ganeshp-
--*/

{
    BOOL        bRet = FALSE;
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    PDWORD      pdwList = pFontPDev->FontList.pdwList;
    PLISTNODE   pListNode;
    PINT        piFontCt = &(pFontPDev->FontList.iEntriesCt);

    //
    // The List of Fonts is stored in PDEV. GLOBALS.dwDeviceFontList is
    // Offset to the ListNode. Macro LISTNODEPTR will return a pointer
    // to the ListNode. Then we have to traverse the list and build the
    // font list. Font module stores the font list as an array of WORDS.
    // Each of these is a resource Id of the font. The array is NULL
    // terminated.
    //

    if (pPDev->bTTY)
    {
        PFN_OEMTTYGetInfo   pfnOemTTYGetInfo;
        DWORD               cbcNeeded, dwNumOfFonts;

        //
        // TTY driver case
        // TTY driver supports 3 fonts. According to the current selected
        // codepage, TTY driver returns appropriate font resource IDs.
        // UNIDRV stores these IDs in pdwList.
        //

        if (pPDev->pOemEntry)
        {
            ASSERT(pdwList);

            if (((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem)
            {
                HRESULT hr;

                hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                    (PDEVOBJ)pPDev,
                                    OEMTTY_INFO_NUM_UFMS,
                                    &dwNumOfFonts,
                                    sizeof(DWORD),
                                    &cbcNeeded);

                if( SUCCEEDED(hr) && dwNumOfFonts <= MAXDEVFONT)
                {
                     hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                          (PDEVOBJ)pPDev,
                                          OEMTTY_INFO_UFM_IDS,
                                          pdwList,
                                          sizeof(DWORD) * dwNumOfFonts,
                                          &cbcNeeded);

                    if( SUCCEEDED(hr))
                    {
                        *piFontCt += dwNumOfFonts;
                        pFontPDev->dwDefaultFont = *pdwList;
                    }
                }
            }
            else
            {
                if((pfnOemTTYGetInfo = (PFN_OEMTTYGetInfo)pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pfnHook) &&
                   (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_NUM_UFMS, &dwNumOfFonts, sizeof(DWORD), &cbcNeeded)) &&
                   (dwNumOfFonts <= MAXDEVFONT) &&
                   (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_UFM_IDS, pdwList, sizeof(DWORD) * dwNumOfFonts, &cbcNeeded)))
                {
                    *piFontCt += dwNumOfFonts;
                    pFontPDev->dwDefaultFont = *pdwList;
                }
            }
        }
    }
    else
    {
        if (pListNode = LISTNODEPTR(pPDev->pDriverInfo , pPDev->pGlobals->liDeviceFontList ) )
        {
            ASSERT(pdwList);

            while (pListNode)
            {
                //
                // Check the Font Resource ID. It shouldn't be NULL.
                //

                if (!pListNode->dwData)
                {
                    ERREXIT("Bad Font Resource Id");
                }

                //
                // Store the Font Resource ID in the List Array.
                //

                *pdwList++ = pListNode->dwData;

                (*piFontCt)++;

                pListNode = LISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
            }

        }
    }

    pFontPDev->iDevResFontsCt  = *piFontCt;

    //
    // Add Cartridge Fonts. By this time we have scanned the regitry and know
    //
    // which fontcartridges has been installed. All we have have to do is
    // go through each font cartriges font list and add them to our list.
    //

    if (pFontPDev->FontCartInfo.iNumInstalledCarts)
    {
        INT         iNumAllCartridges, iI;
        FONTCARTMAP *pFontCartMap;  /* FontCart Map Pointer */
        SHORT       sOrient;

        pFontCartMap = (pFontPDev->FontCartInfo.pFontCartMap);
        iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts;
        sOrient = (pPDev->pdm->dmFields & DM_ORIENTATION) ?
                  pPDev->pdm->dmOrientation : (SHORT)DMORIENT_PORTRAIT;

        //
        // The logic is very simple. Installed font Cartridges are marked in
        // the Font Cartridge mapping table. We go through the mapping table
        // and for each installed cartridges we get the font list and add them
        // to our list.
        //

        for( iI = 0; iI < iNumAllCartridges ; iI++,pFontCartMap++ )
        {
            if (pFontCartMap->bInstalled == TRUE )
            {
                //
                // Check for Orientation, as there can be different font list
                // for different orientation.
                //

                if ( sOrient == DMORIENT_LANDSCAPE )
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwLandFontLst );

                }
                else
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwPortFontLst );
                }

                while (pListNode)
                {
                    //
                    // Check the Font Resource ID. It shouldn't be NULL.
                    //

                    if (!pListNode->dwData)
                    {
                        ERREXIT("Bad Font Resource Id");
                    }

                    //
                    //Store the Font Resource ID in the List Array.
                    //

                    *pdwList++ = pListNode->dwData;
                    (*piFontCt)++;
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                pListNode->dwNextItem);
                }

            }

        }
    }

    //
    // Update the count of all device fonts
    //

    pFontPDev->iDevFontsCt += *piFontCt;

    //
    // All Success
    //
    if (pFontPDev->FontCartInfo.pFontCartMap)
        MEMFREEANDRESET(pFontPDev->FontCartInfo.pFontCartMap);
    bRet = TRUE;

    ErrorExit:

    return bRet;

}


BOOL
BBuildFontMapTable(
    PDEV     *pPDev
    )
/*++

Routine Description:

   Build a table of fonts available on this model.
   Each entry in this table is an atom for the facename followed
   by TEXTMETRIC structure.  This table will accelerate font
   enumeration and font realization.  This routine is responsible
   for allocating the global memory needed to store the table.
   It also has 2 OCD's to select/unselect each font

Arguments:

    pPDev - Pointer to PDEV.

    Return Value: None

Note:
    11-18-96: Created it -ganeshp-
--*/
{
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    PDWORD      pdwFontList = pFontPDev->FontList.pdwList;

    //
    // Basic idea here is to generate a bit array indicating which of
    // the minidriver fonts are available for this printer in it's
    // current mode.  This is saved in the UD_PDEV,  and will be filled in
    // as required later,  during DrvQueryFont,  if this is required.
    //

    //
    // If no hardware font is available,  give up now!
    //

    if( !(pFontPDev->flText & ~TC_RA_ABLE) )
        return TRUE;

    // At this point we check for reasons why not to use device fonts.
    // We disable device fonts for n-up printing on serial devices because they
    // typically can't scale their fonts
    //
    if( ( !pPDev->bTTY ) &&
        ( (pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS ) ||
#ifndef WINNT_40
          (pPDev->pdmPrivate->iLayout != ONE_UP && 
           pPDev->pGlobals->printertype == PT_SERIAL &&
           pPDev->pGlobals->bRotateRasterData == FALSE) ||
#endif
          (pPDev->fMode2 & PF2_MIRRORING_ENABLED) ||
          ((pPDev->pdm->dmFields & DM_TTOPTION) &&
          (pPDev->pdm->dmTTOption == DMTT_BITMAP)) ) )
    {
        return TRUE;
    }


    /*
     *    That's all we need do during DrvEnablePDEV time.  We now know
     *  which fonts are available, and there was little effort involved.
     *  This data is now saved away,  and will be acted upon as and when
     *  GDI comes and asks us about fonts.
     */

    pPDev->iFonts = (UINT)(-1);          /* Tells GDI about lazy evaluation */

    IInitDeviceFonts( pPDev );

    //
    // Initialize font substitution flag.
    // Check if this printer supports any device font.
    //

    if (pPDev->iFonts <= 0 &&
        pFontPDev->flFlags & FDV_SUBSTITUTE_TT)
    {
        pFontPDev->flFlags &= ~FDV_SUBSTITUTE_TT;
    }

    return TRUE;
}


BOOL
BFMInitDevInfo(
    DEVINFO *pDevInfo,
    PDEV    *pPDev
    )
/*++

Routine Description:

    This routine intializes the font specific fileds of DevInfo.

Arguments:
    pDevInfo - Pointer to DEVINFO to be initialized.
    pPDev - Pointer to PDEV.

    Return Value:
    TRUE  - for success
    FALSE - for failure

Note:
    12-11-96: Created it -ganeshp-
--*/
{
    CHARSETINFO ci;
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    FONTMAP    *pFMDefault;
    BOOL        bSetTrueType;

    bSetTrueType = TRUE;
    pFMDefault = pFontPDev->pFMDefault;
    pDevInfo->flGraphicsCaps |= GCAPS_SCREENPRECISION | GCAPS_FONT_RASTERIZER;

    if (!PrdTranslateCharsetInfo(PrdGetACP(), &ci, TCI_SRCCODEPAGE))
        ci.ciCharset = ANSI_CHARSET;

    if( pDevInfo->cFonts = pPDev->iFonts )
    {
        //
        // Device fonts are available,  so set the default font data
        //

        if( pFMDefault &&
            ((IFIMETRICS*)pFMDefault->pIFIMet)->jWinCharSet == ci.ciCharset)
        {
            VLogFont(&pPDev->ptTextRes, &(pDevInfo->lfDefaultFont), pFontPDev->pFMDefault );
            bSetTrueType = FALSE;
        }

        //
        //Initialize the Hooks flag.
        //

        pPDev->fHooks |= HOOK_TEXTOUT;
    }

    //
    // Always switch off TC_RA_ABLE flag
    //
    pFontPDev->flText &= ~TC_RA_ABLE;


    if (bSetTrueType)
    {
        pDevInfo->lfDefaultFont.lfCharSet = (BYTE)ci.ciCharset;
        ZeroMemory( pDevInfo->lfDefaultFont.lfFaceName,
                    sizeof ( pDevInfo->lfDefaultFont.lfFaceName ));
    }

    ZeroMemory( &pDevInfo->lfAnsiVarFont, sizeof( LOGFONT ) );
    ZeroMemory( &pDevInfo->lfAnsiFixFont, sizeof( LOGFONT ) );

    return TRUE ;
}

BOOL
BInitGDIInfo(
    GDIINFO  *pGDIInfo,
    PDEV     *pPDev
    )
/*++

Routine Description:

    This routine intializes the font specific fileds of GdiInfo.

Arguments:
    pGDIInfo - Pointer to GDIINFO to be initialized.
    pPDev    - Pointer to PDEV.

    Return Value:
    TRUE  - for success
    FALSE - for failure

Note:
    12-11-96: Created it -ganeshp-
--*/
{
    pGDIInfo->flTextCaps = PFDV->flText;
    return TRUE;
}


BOOL
BInitStandardVariable(
    PDEV *pPDev)
{

    //
    // Initialize the Standard Variable, Just for sanity
    //
    pPDev->dwPrintDirection   =
    pPDev->dwNextFontID       =
    pPDev->dwNextGlyph        =
    pPDev->dwFontHeight       =
    pPDev->dwFontWidth        =
    pPDev->dwFontBold         =
    pPDev->dwFontItalic       =
    pPDev->dwFontUnderline    =
    pPDev->dwFontStrikeThru   =
    pPDev->dwCurrentFontID    = 0;

    return TRUE;
}

//
//
// Misc functions
//
//

VOID
VLogFont(
    POINT    *pptTextRes,
    LOGFONT  *pLF,
    FONTMAP  *pFM
)
/*++

Routine Description:

    Turn an IFIMETRICS structure into a LOGFONT structure,  for whatever
    reason this is needed.

Arguments:

    pLF - Output is a LOGFONT.
    pFM - Input is a FONTMAP.

    Return Value: None

Note:
    12-11-96: Created it -ganeshp-
--*/
{
    /*
     *    Convert from IFIMETRICS to LOGFONT type structure.
     */

    int           iLen;            /* Loop variable */

    IFIMETRICS   *pIFI;
    WCHAR        *pwch;            /* Address of face name */



    pIFI = pFM->pIFIMet;                /* The BIG metrics */

    pLF->lfHeight = pIFI->fwdWinAscender + pIFI->fwdWinDescender;
    pLF->lfWidth  = pIFI->fwdAveCharWidth;

    /*
     *   Note that this may be a scalable font, in which case we pick a
     *  reasonable number!
     */
    if( pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
    {
        /*
         *    Invent an arbitrary size.  We choose an approximately 10 point
         *  font.  The height is achieved easily, as we simply set the
         *  height based on the device resolution!  For the width, adjust
         *  it using the same factor as we used on the height.  This
         *  assumes that the resolution is the same in both directions,
         *  but this is reasonable given laser printers are the most
         *  common with scalable fonts.
         */


        //
        // Needs to reflect a current resolution.
        //

        pLF->lfHeight = pptTextRes->x / 7; /* This is about 10 points */
        pLF->lfWidth = (2 * pLF->lfHeight * pptTextRes->y) /
                       (3 * pptTextRes->y);

    }

    pLF->lfEscapement  = 0;
    pLF->lfOrientation = 0;

    pLF->lfWeight = pIFI->usWinWeight;

    pLF->lfItalic    = (BYTE)((pIFI->fsSelection & FM_SEL_ITALIC) ? 1 : 0);
    pLF->lfUnderline = (BYTE)((pIFI->fsSelection & FM_SEL_UNDERSCORE) ? 1 : 0);
    pLF->lfStrikeOut = (BYTE)((pIFI->fsSelection & FM_SEL_STRIKEOUT) ? 1 : 0);

    pLF->lfCharSet = pIFI->jWinCharSet;

    pLF->lfOutPrecision = OUT_DEFAULT_PRECIS;
    pLF->lfClipPrecision = CLIP_DEFAULT_PRECIS;
    pLF->lfQuality = DEFAULT_QUALITY;

    pLF->lfPitchAndFamily = pIFI->jWinPitchAndFamily;

    /*
     *    Copy the face name,  after figuring out it's address!
     */

    pwch = (WCHAR *)((BYTE *)pIFI + pIFI->dpwszFaceName);
    iLen = min( wcslen( pwch ), LF_FACESIZE - 1 );

    wcsncpy( pLF->lfFaceName, pwch, iLen );

    pLF->lfFaceName[ iLen ] = (WCHAR)0;


    return;
}

BOOL
BInitTextFlags(
    PDEV    *pPDev
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    BOOL        bRet = FALSE;
    PLISTNODE   pListNode;
    DWORD       flText = 0;

    TRACE(UniFont!BInitTextFlags:START);

    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liTextCaps ) )
    {
        while (pListNode)
        {
            // Check the Text Flag. It shouldn't be < 0 or greater than 32.
            if ( ((INT)pListNode->dwData < 0) ||
                 (pListNode->dwData > DWBITS) )
                ERREXIT("UniFont!BInitTextFlags:Bad FText Flag Value\n");

            //Set the corresponding bit in fText
            flText |= 1 << pListNode->dwData;

            pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
        }
    }

    PRINTVAL(flText,0x%x);

    // If there is a TextCAP List, Modify the text flags as needed.
    if (flText)
    {
        /* Switch off TC_RA_ABLE if text resolution is different than graphics
         * resolution. Rasdd code does this.
         */

        if (!POINTEQUAL(pPDev->ptGrxRes,pPDev->ptTextRes))
            flText &= ~TC_RA_ABLE;


        /*   NOTE:  IF WE DO NOT HAVE RELATIVE MOVE COMMANDS,  TURN OF THE
         *  TC_CR_90 BIT IN fTextCaps.  THE ROTATED TEXT CODE ASSUMES THIS
         *  FUNCTIONALITY IS AVAILABLE,  SO DISABLE IT IF NOT THERE.  This does
         *  not usually happen,  as the only printers with the TC_CR_90
         *  bit set are LJ III and 4 models,  which have the relative move
         *  commands available.
         */
        if ( (COMMANDPTR(pPDev->pDriverInfo, CMD_XMOVERELLEFT) == NULL)  ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_XMOVERELRIGHT) == NULL) ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_YMOVERELUP) == NULL)    ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_YMOVERELDOWN) == NULL)  ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION) == NULL)  )
        {
            flText &= ~TC_CR_90;
            flText &= ~TC_CR_ANY;

        }
        else if ((COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION) == NULL))
        {
            flText &= ~TC_CR_ANY;

        }

        //
        // Text rotation hack
        // Disable text rotation except PCL XL driver
        //
        if (pPDev->ePersonality != kPCLXL)
        {
            flText &= ~(TC_CR_ANY|TC_CR_90);
        }
    }

    PFDV->flText = flText;

    bRet = TRUE;

    ErrorExit:

    TRACE(UniFont!BInitTextFlags:END);
    return bRet;

}


BOOL
BRegReadFontCarts(
    PDEV        *pPDev                  /* PDEV to fill in */
    )
/*++

Routine Description:

    Read FontCart data form registry and Update the
    it in the in incoming devmode,
Arguments:

    pPDev - Pointer to PDEV.

    Return Value:
    TRUE  - for success
    FALSE - for failure

Note:
    11-25-96: Created it -ganeshp-
--*/
{

    FONTCARTMAP *pFontCartMap, *pTmpFontCartMap;          /* FontCart Map Pointer */
    PFONTPDEV   pFontPDev;              /* FONTPDEV access */
    int         iNumAllCartridges;      /* Total Number of Font Carts */
    HANDLE      hPrinter;               /* Printer Handle */

    int         iI;                     /* Loop index */
    DWORD       dwType;                 /* Registry access information */
    DWORD       cbNeeded;               /* Extra parameter to GetPrinterData */
    DWORD       dwErrCode = 0;          /* Error Code from GetPrinterData */
    int         iRemBuffSize = 0 ;      /* Used size of the Buffer */
    WCHAR       *pwchBuffPtr = NULL;    /* buffer Pointer */
    WCHAR       *pwchCurrBuffPtr = NULL;/* Current position buffer Pointer */


    //Initialize the variables.
    hPrinter    = pPDev->devobj.hPrinter;
    pFontPDev   = pPDev->pFontPDev;
    pFontCartMap = (pFontPDev->FontCartInfo.pFontCartMap);
    iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts;
    pFontPDev->FontCartInfo.iNumInstalledCarts = 0;

    /* If No FontCartriges are supported return TRUE */
    if (!iNumAllCartridges)
    {
        //
        // This is a valid case. Only external cartridges may be supported.
        //
        return(TRUE);
    }

    dwType = REG_MULTI_SZ;

    if( ( dwErrCode = EngGetPrinterData( hPrinter, REGVAL_FONTCART, &dwType,
                                     NULL, 0, &cbNeeded ) ) != ERROR_SUCCESS )
    {

       if( (dwErrCode != ERROR_INSUFFICIENT_BUFFER) &&
           (dwErrCode != ERROR_MORE_DATA) )
       {

          //
          // Check for the ERROR_FILE_NOT_FOUND. It's OK not to have the key.
          //
          if (dwErrCode != ERROR_FILE_NOT_FOUND)
          {
               WARNING(( "UniFont!bRegReadFontCarts:GetPrinterData(FontCart First Call) fails: Errcode = %ld\n",dwErrCode) );

               EngSetLastError(dwErrCode);
          }
          return(TRUE);
       }
       else
       {
           if( !cbNeeded     ||
               !(pwchCurrBuffPtr = pwchBuffPtr =(WCHAR *)MemAllocZ(cbNeeded)) )
           {

               ERR(( "UniFont!MemAllocZ(FontCart) failed, cbNeeded = %d:\n", cbNeeded));
               return(FALSE);
           }
       }

       VERBOSE(("\n UniFont!bRegReadFontCarts:Size of buffer needed (1) = %d\n",cbNeeded));

       if( ( dwErrCode = EngGetPrinterData( hPrinter, REGVAL_FONTCART, &dwType,
                                      (BYTE *)pwchBuffPtr, cbNeeded,
                                       &cbNeeded) ) != ERROR_SUCCESS )
       {


           ERR(( "UniFont!bRegReadFontCarts:GetPrinterData(FontCart Second Call) fails: errcode = %ld\n",dwErrCode) );
           ERR(( "                         :Size of buffer needed (2) = %d\n",cbNeeded));

           /* Free the Heap */
           if( pwchBuffPtr )
               MEMFREEANDRESET( pwchBuffPtr );

           EngSetLastError(dwErrCode);
           return(FALSE);
       }

    }
    else
    {
        //
        // We could not get the FONTCART path.
        //
        return FALSE;
    }

    VERBOSE(("UniFont!bRegReadFontCarts:Size of buffer read = %d\n",cbNeeded));

    /* iRemBuffSize is number of WCHAR */
    iRemBuffSize = cbNeeded / sizeof(WCHAR);

    /* Buffer ends with two consequtive Nulls */

    while( ( pwchCurrBuffPtr[ 0 ] != UNICODE_NULL )  )
    {
       WCHAR   achFontCartName[ MAXCARTNAMELEN ];  /* Font Cart Name */

       ZeroMemory(achFontCartName,sizeof(achFontCartName) );

       if( iRemBuffSize)
       {

          VERBOSE(("\nRasdd!bRegReadFontCarts:FontCartName in buffer = %ws\n",pwchCurrBuffPtr));
          VERBOSE(("UniFont!bRegReadFontCarts:iRemBuffSize of buffer (before) = %d\n",iRemBuffSize));

          VGetFromBuffer(achFontCartName,&pwchCurrBuffPtr,&iRemBuffSize);

          VERBOSE(("UniFont!bRegReadFontCarts:Retrieved FontCartName = %ws\n",achFontCartName));
          VERBOSE(("UniFont!bRegReadFontCarts:iRemBuffSize of buffer (after) = %d\n",iRemBuffSize));
       }
       else
       {
           ERR(("UniFont!bRegReadTrayFormTable: Unexpected End of FontCartTable\n"));

          /* Free the Heap */
          if( pwchBuffPtr )
              MEMFREEANDRESET( pwchBuffPtr );

           return(FALSE);
       }

       pTmpFontCartMap = pFontCartMap;

       for( iI = 0; iI < iNumAllCartridges ; iI++,pTmpFontCartMap++ )
       {

           if (pTmpFontCartMap != NULL)
           {
               if ((wcscmp((PCWSTR)(&(pTmpFontCartMap->awchFontCartName)), (PCWSTR)achFontCartName ) == 0))
               {
                  pTmpFontCartMap->bInstalled = TRUE;
                  pFontPDev->FontCartInfo.iNumInstalledCarts++;
                  break;
               }
           }
       }
    }


    /* Free the Heap */
    if( pwchBuffPtr )
        MEMFREEANDRESET( pwchBuffPtr );

    return(TRUE);
}

#ifdef DELETE

VOID
VSetFontID(
    DWORD   *pdwOut,           /* The output area */
    PFONTLIST pFontList
    )
/*++

Routine Description:

    Set the bits in the available fonts bit array.  We use the 1 based
    values stored in various minidriver structures.

Arguments:

    pdwOut - Pointer to output Bit Array.
    pFontList - Pointer to FONTLIST structure.

    Return Value: None

Note:
    11-27-96: Created it -ganeshp-
--*/
{
    int     iStart;             /* Current value, or start of range */
    int     iI;                 /* Index variable */
    DWORD   *pdwList;           /* Address  font list */

    pdwList = pFontList->pdwList;

    /*
     *    The values are all singles.
     */

    for ( iI = 0; iI < pFontList->iEntriesCt; iI++ )
    {
        iStart = *pdwList++;
        pdwOut[ iStart / DWBITS ] |= 1 << (iStart  & (DWBITS - 1));

        //VERBOSE(("UniFont!VSetFontID:Setting single font indexes,index is %d\n",iStart));
        //VERBOSE(("UniFont!VSetFontID:Setting Bit number %d in Word num %d\n",\
        //(iStart  & (DWBITS - 1)),(iStart / DWBITS)) );
     }

    return;
}
#endif //DELETE


BOOL
BCheckFontMemUsage(
    PDEV    *pPDev
    )
/*++

Routine Description:
    This routine goes through the list of MemoryUsage and returns true if
    MEMORY_FONT is found.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    01-16-97: Created it -ganeshp-

--*/
{
    BOOL        bRet = FALSE;
    PLISTNODE   pListNode;


    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liMemoryUsage ) )
    {
        while (pListNode)
        {
            // Check the MEMORY_FONT value;
            if ( pListNode->dwData == MEMORY_FONT )
            {
                bRet = TRUE;
                break;
            }
            pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
        }
    }

    return bRet;

}

VOID
VSetReselectFontFlags(
    PDEV    *pPDev
    )
/*++

Routine Description:
    This routine goes through the list of Reselect Font flags and sets
    corresponding PDEV PF_ flags.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    None
Note:
    08-07-97: Created it -ganeshp-

--*/
{
    PLISTNODE   pListNode;


    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liReselectFont ) )
    {
        while (pListNode)
        {
            //
            // Check the ReselectFont value;
            //
            FTRC(\nUniFont!VSetReselectFontFlags:ReselectFont Flags Found\n);

            if ( pListNode->dwData == RESELECTFONT_AFTER_GRXDATA )
            {
                pPDev->fMode |= PF_RESELECTFONT_AFTER_GRXDATA;
                FTRC(UniFont!VSetReselectFontFlags:Setting PF_RESELECTFONT_AFTER_GRXDATA\n);
            }
            else if ( pListNode->dwData == RESELECTFONT_AFTER_XMOVE )
            {
                pPDev->fMode |= PF_RESELECTFONT_AFTER_XMOVE;
                FTRC(UniFont!VSetReselectFontFlags:Setting RESELECTFONT_AFTER_XMOVE\n);
            }
            else if ( pListNode->dwData == RESELECTFONT_AFTER_FF )
            {
                pPDev->fMode |= PF_RESELECTFONT_AFTER_FF;
                FTRC(UniFont!VSetReselectFontFlags:Setting RESELECTFONT_AFTER_FF\n);
            }

            pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
        }
    }
    else
    {
        FTRC(\nUniFont!VSetReselectFontFlags:ReselectFont Flags Not Found\n);
    }


    return;

}

INT
IGetMaxFonts(
    PDEV    *pPDev
    )

/*++

Routine Description:
    This routine returns Maximum number of fonts supported. Assumes each
    Font Cartridges and device has not more than MAXDEVFONTS.
Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    Maximum number of device fonts  - for success
    Zero  - for failure or Device fonts.

Note:
    11-18-96: Created it -ganeshp-
--*/

{
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    PLISTNODE   pListNode;
    INT         iFontCt = 0;

    //
    // Count Device resident fonts.
    //
    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo , pPDev->pGlobals->liDeviceFontList ) )
    {
        while (pListNode)
        {
            iFontCt++;

            pListNode = LISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
        }

    }


    //
    // Add Cartridge Fonts. By this time we have scanned the regitry and know
    // which fontcartridges has been installed. All we have have to do is
    // go through each font cartriges font list and add them to our list.
    //

    if (pFontPDev->FontCartInfo.iNumInstalledCarts)
    {
        INT         iNumAllCartridges, iI;
        FONTCARTMAP *pFontCartMap;  /* FontCart Map Pointer */
        SHORT       sOrient;

        pFontCartMap = (pFontPDev->FontCartInfo.pFontCartMap);
        iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts;
        sOrient = (pPDev->pdm->dmFields & DM_ORIENTATION) ?
                  pPDev->pdm->dmOrientation : (SHORT)DMORIENT_PORTRAIT;

        //
        // The logic is very simple. Installed font Cartridges are marked in
        // the Font Cartridge mapping table. We go through the mapping table
        // and for each installed cartridges we get the font list and add them
        // to our list.
        //

        for( iI = 0; iI < iNumAllCartridges ; iI++,pFontCartMap++ )
        {
            if (pFontCartMap->bInstalled == TRUE )
            {
                //
                // Check for Orientation, as there can be different font list
                // for different orientation.
                //

                if ( sOrient == DMORIENT_LANDSCAPE )
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwLandFontLst );

                }
                else
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwPortFontLst );
                }

                while (pListNode)
                {
                    iFontCt++;
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                pListNode->dwNextItem);
                }

            }

        }
    }

    return max(MAXDEVFONT,iFontCt);
    //
    // return iFontCt;
    //
}


#define MAXBUFFLEN (MAXCARTNAMELEN - 1)

VOID
VGetFromBuffer(
    IN PWSTR pwstrDest,             /* Destination */
    IN OUT PWSTR *ppwstrSrc,        /* Source */
    IN OUT PINT  piRemBuffSize      /*Remaining Buffer size in WCHAR */
    )
/*++

Routine Description:

Reads a string from Multi string buffer.
Arguments:

    pwstrDest    - Pointer to Destination Buffer.
    ppwstrSrc    - Pointer Sourc Buffer, Updated by the function.
    piRemBuffSize - Pointer to remaining buffer size. Also updated.

    Return Value:
    None

Note:
    11-25-96: Created it -ganeshp-
--*/
{
    if ( wcslen(*ppwstrSrc) > MAXBUFFLEN )
    {

        ERR(("Rasddlib!vGetFromBuffer:Bad Value read from registry !!\n") );
        ERR(("String Length = %d is too Big, String is %ws !!\n",wcslen(*ppwstrSrc), *ppwstrSrc) );

        *piRemBuffSize = 0;
        *ppwstrSrc[ 0 ] = UNICODE_NULL;
    }

    if ( *piRemBuffSize )
    {
        INT iIncr;

        /* The return Count Doesn't include '/0'.It is number of chars copied */
        iIncr = ( wcslen( wcscpy((LPWSTR)pwstrDest,*ppwstrSrc) ) + 1 ) ;

        *ppwstrSrc   += iIncr;
        *piRemBuffSize -= iIncr;

    }

}

LRESULT
PartialClipOn(
    PDEV *pPDev)
{
    DWORD dwData, dwType, dwSize;
    PVOID pvData;
    LRESULT Ret;

    Ret = E_NOTIMPL;
    pvData = &dwData;
    dwSize = sizeof(dwData);

    //
    // If there is not registry value set, returns E_NOTIMPL.
    // If there is and it is TRUE,, return S_OK
    // If there is and it is FALSE,  return S_FALSE;
    //
    if ((GetPrinterData(pPDev->devobj.hPrinter, REGVAL_PARTIALCLIP, &dwType, pvData, dwSize, &dwSize) == ERROR_SUCCESS))
    {
        if (dwData)
            Ret = S_OK;
        else
            Ret = S_FALSE;
    }

    return Ret;
}

#ifdef DELETE
INT
iMaxFontID(
    IN INT      iMax,                   /* Highest found so far */
    OUT DWORD   *pFontIndex             /* Address of start of list */
    )


/*++

Routine Description:

    Returns the index number (1 based) of the highest numbered font
    in the list supplied.

Arguments:

    iMax - Highest Font resource id foundso far.
    pFontMax - Start of the font list.

    Return Value:

    Highest font index encountered, or passed in.

Note:
    11-26-96: Created it -ganeshp-
--*/
{

    /*
     *    All we need do is scan along,  remembering the largest we find.
     */


    while( *pFontIndex )
    {
        if( (INT)*pFontIndex > iMax )
            iMax = (INT)*pFontIndex;

        ++pFontIndex;

    }


    return  iMax;
}
#endif //DELETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\qfontdat.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qfontdat.c

Abstract:

    Implements the DrvQueryFontData function - returns information
    about glyphs (size, position wrt box) or kerning information.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/19/96 -ganeshp-
        Created

--*/
#include "font.h"


/*
 *    The values for pteBase, pteSide in FD_DEVICEMETRICS,  allowing
 *  for rotation by 90 degree multiples.
 */

#if defined(USEFLOATS) || defined(WINNT_40)

static  const  POINTE  pteRotBase[] =
{
    { (FLOAT) 1.0, (FLOAT) 0.0 },
    { (FLOAT) 0.0, (FLOAT)-1.0 },
    { (FLOAT)-1.0, (FLOAT) 0.0 },
    { (FLOAT) 0.0, (FLOAT) 1.0 }
};

static  const  POINTE  pteRotSide[] =
{
    { (FLOAT) 0.0, (FLOAT)-1.0 },
    { (FLOAT)-1.0, (FLOAT) 0.0 },
    { (FLOAT) 0.0, (FLOAT) 1.0 },
    { (FLOAT) 1.0, (FLOAT) 0.0 }
};

#else

static  const  POINTE  pteRotBase[] =
{
    { (FLOATL) FLOATL_1_0, (FLOATL) FLOATL_0_0 },
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0M },
    { (FLOATL) FLOATL_1_0M,(FLOATL) FLOATL_0_0 },
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0 }
};

static  const  POINTE  pteRotSide[] =
{
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0M },
    { (FLOATL) FLOATL_1_0M,(FLOATL) FLOATL_0_0 },
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0 },
    { (FLOATL) FLOATL_1_0, (FLOATL) FLOATL_0_0 }
};
#endif //defined(USEFLOATS) || defined(WINNT_40)


/*  The X dimension rotation cases */

static  const  POINTL   ptlXRot[] =
{
    {  1,  0 },
    {  0, -1 },
    { -1,  0 },
    {  0,  1 },
};


/*  The Y dimension rotation cases */

static  const  POINTL   ptlYRot[] =
{
    {  0,  1 },
    {  1,  0 },
    {  0, -1 },
    { -1,  0 },
};


LONG
FMQueryFontData(
    PDEV       *pPDev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
/*++

Routine Description:
    Return information about glyphs in the font,  OR kerning data.

    Arguments:
    pPDev   Really  a pPDev
    pfo     The font of interest
    iMode   Glyphdata or kerning information
    hg      Handle to glyph
    pgd     Place to put metrics
    pv      Output area
    cjSize  Size of output area



Return Value:

    Number of bytes needed or written,  0xffffffff for error.

Note:
    12-29-96: Created it -ganeshp-

--*/
{


    FONTPDEV    *pFontPDev;
    int         iRot;             /* Rotation multiple of 90 degrees */
    LONG        lRet;             /* Value returned */
    FONTMAP     *pFM;             /* Font data */
    FONTMAP_DEV *pFMDev;          /* Font data */
    FONTCTL     ctl;              /* Font scale/rotation adjustments */
    IFIMETRICS  *pIFI;
    XFORMOBJ    *pxo;
    LONG        lAscender;
    LONG        lDescender;
    FLOATOBJ    fo;

    pFontPDev =  pPDev->pFontPDev;
    lRet = FD_ERROR;

    if( pfo->iFace < 1 || (int)pfo->iFace > pPDev->iFonts )
    {
        ERR(("Bad FONTOBJ, iFace is %d",pfo->iFace));
        SetLastError( ERROR_INVALID_PARAMETER );
        return  lRet;
    }

    pFM = PfmGetDevicePFM( pPDev, pfo->iFace );
    if( pFM == NULL )
        return  lRet;

    VDBGDUMPFONTMAP(pFM);

    pFMDev = pFM->pSubFM;
    pIFI = pFM->pIFIMet;                /* IFIMETRICS - useful to have */

    if( pgd || pv )
    {
        /*
         *    Need to obtain a transform to adjust these numbers as to
         *  how the engine wants them.
         */


        if( !(pxo = FONTOBJ_pxoGetXform( pfo )) )
        {
            ERR(( "UniFont!FMQueryFontData: FONTOBJ_pxoGetXform fails\n" ));
            return  lRet;
        }

        /*  Can now obtain the transform!  */

        //Added Check for HP Intellifont
        iRot = ISetScale( &ctl, pxo, ((pFM->flFlags & FM_SCALABLE) &&
                                      (pFMDev->wDevFontType ==
                                                DF_TYPE_HPINTELLIFONT)),
                                     (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

        if (pFontPDev->flText & TC_CR_ANY)
            iRot = (iRot + 45) / 90;


        /*
         *    There are some adjustments to make to the scale factors.  One
         *  is to compensate for resolutions (these are coarse, integral
         *  adjustments),  the others are to to do with Intellifont.  First
         *  is the Intellifont point is 1/72.31 inches (!), and secondly
         *  the LaserJet only adjusts font size to the nearest 0.25 point,
         *  and hence when we round to that multiple, we need to adjust
         *  the width accordingly.
         */

        if( pFM->flFlags & FM_SCALABLE )
        {

            int         iPtSize, iAdjustedPtSize;       /* For scale factor adjustment */

        #ifdef USEFLOATS

            /*  The limited font size resolution */
            iPtSize = (int)(0.5 + ctl.eYScale * pIFI->fwdUnitsPerEm * 7200) / pPDev->ptGrxRes.y;

            /* if the tranform is very small (Less than a quarter of point size)
             * then make it atleast a quarter point. This was causing AV in certain
             * cases.
             */

            if (iPtSize < 25)
            {
                iPtSize = 25;

            }
            iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

            //Adjust the Scale Factor for quarter point adjustment.
            ctl.eXScale = (ctl.eXScale * iAdjustedPtSize) / iPtSize;
            ctl.eYScale = (ctl.eYScale * iAdjustedPtSize) / iPtSize;

        #else

            fo = ctl.eYScale;
            FLOATOBJ_MulLong(&fo,pIFI->fwdUnitsPerEm);
            FLOATOBJ_MulLong(&fo,7200);

            #ifndef WINNT_40 //NT 5.0

            FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

            #else // NT 4.0

            FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

            #endif //!WINNT_40

            iPtSize = FLOATOBJ_GetLong(&fo);
            iPtSize /= pPDev->ptGrxRes.y;

            /* if the trannform is very small (Less than a quarter of point size)
             * then make it atleast a quarter point. This was causing AV in certain
             * cases.
             */

            if (iPtSize < 25)
            {
                iPtSize = 25;

            }

            iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

            //Adjust the Scale Factor for quarter point adjustment.
            FLOATOBJ_MulLong(&ctl.eXScale,iAdjustedPtSize);
            FLOATOBJ_DivLong(&ctl.eXScale,iPtSize);

            FLOATOBJ_MulLong(&ctl.eYScale,iAdjustedPtSize);
            FLOATOBJ_DivLong(&ctl.eYScale,iPtSize);
        #endif
        }
    }

    /*
     * precompute the lDescender and lAscender
     */

    lDescender = LMulFloatLong(&ctl.eYScale,pIFI->fwdWinDescender);
    lAscender  = LMulFloatLong(&ctl.eYScale,pIFI->fwdWinAscender);

    switch( iMode )
    {
    case  QFD_GLYPHANDBITMAP:            /* Glyph width etc data */
        // size is now just the size of the bitmap, which in this
        // case doesn't exist.
        lRet = 0;

        if( pgd )
        {

            int   iWide;            /* Glyph's width */

            /*
             *    First get the width of this glyph,  as this is needed
             *  in several places.The width returned by IGetGlyphWidth
             *  is not scaled in device units. To convert in device units
             *  multily with the scale factor calculated earlier.
             */

            iWide = IGetGlyphWidth( pPDev, pFM, hg);

            iWide = LMulFloatLong(&ctl.eXScale,iWide);

            switch( iRot )
            {
            case 0:
                pgd->rclInk.left   = 0;
                pgd->rclInk.top    = lDescender;
                pgd->rclInk.right  = iWide;
                pgd->rclInk.bottom = -lAscender;
                break;

            case 1:
                pgd->rclInk.left   = lDescender;
                pgd->rclInk.top    = iWide;
                pgd->rclInk.right  = -lAscender;
                pgd->rclInk.bottom = 0;
                break;

            case 2:
                pgd->rclInk.left   = -iWide;
                pgd->rclInk.top    = -lAscender;
                pgd->rclInk.right  = 0;
                pgd->rclInk.bottom = lDescender;
                break;

            case 3:
                pgd->rclInk.left   = lAscender;
                pgd->rclInk.top    = 0;
                pgd->rclInk.right  = -lDescender;
                pgd->rclInk.bottom = -iWide;
                break;
            }

            pgd->fxD = LTOFX( iWide );
            pgd->ptqD.x.HighPart = pgd->fxD * ptlXRot[ iRot ].x;
            pgd->ptqD.x.LowPart = 0;
            pgd->ptqD.y.HighPart =  pgd->fxD * ptlXRot[ iRot ].y;
            pgd->ptqD.y.LowPart = 0;

            pgd->fxA = 0;
            pgd->fxAB = pgd->fxD;

            pgd->fxInkTop = (FIX)LTOFX( lAscender );
            pgd->fxInkBottom = -(FIX)LTOFX( lDescender );

            pgd->hg = hg;
            pgd->gdf.pgb = NULL;

        }
        break;

    case  QFD_MAXEXTENTS:         /* Alternative form of the above */

        lRet = sizeof( FD_DEVICEMETRICS );

        if( pv )
        {
            LONG   lTmp;            /* Rotated case */
            FD_DEVICEMETRICS *pdm =  ((FD_DEVICEMETRICS *)pv);

            /*
             *   Check that the size is reasonable!
             */

            if( cjSize < sizeof( FD_DEVICEMETRICS ) )
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                ERR(( "rasdd!DrvQueryFontData: cjSize (%ld) too small\n", cjSize ));
                return  -1;
            }

            /*
             *   These are accelerator flags - it is not obvious to me
             *  that any of them are relevant to printer driver fonts.
             */
            pdm->flRealizedType = 0;

            /*
             *   Following fields set this as a normal type of font.
             */

            pdm->pteBase = pteRotBase[ iRot ];
            pdm->pteSide = pteRotSide[ iRot ];

            pdm->cxMax = LMulFloatLong(&ctl.eXScale,pIFI->fwdMaxCharInc);

            //
            // DBCS fonts are not monospaced, have halfwidth glyphs and
            // fullwidth glyphs.
            //

            if ( pFMDev->W.psWidth ||
                IS_DBCSCHARSET(((IFIMETRICS*)pFM->pIFIMet)->jWinCharSet))
            {
                pdm->lD = 0;      /* Proportionally spaced font */
            }
            else
            {
                pdm->lD = pdm->cxMax;
            }

            pdm->fxMaxAscender = (FIX)LTOFX( lAscender );
            pdm->fxMaxDescender = (FIX)LTOFX( lDescender );

            lTmp = -LMulFloatLong(&ctl.eYScale,pIFI->fwdUnderscorePosition);
            pdm->ptlUnderline1.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlUnderline1.y = lTmp * ptlYRot[ iRot ].y;

            lTmp = -LMulFloatLong(&ctl.eYScale,pIFI->fwdStrikeoutPosition);
            pdm->ptlStrikeOut.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlStrikeOut.y = lTmp * ptlYRot[ iRot ].y;

            lTmp = LMulFloatLong(&ctl.eYScale,pIFI->fwdUnderscoreSize);
            pdm->ptlULThickness.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlULThickness.y = lTmp * ptlYRot[ iRot ].y;

            lTmp = LMulFloatLong(&ctl.eYScale,pIFI->fwdStrikeoutSize);
            pdm->ptlSOThickness.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlSOThickness.y = lTmp * ptlYRot[ iRot ].y;
        }
        break;

    default:
        ERR(( "Rasdd!DrvQueryFontData:  unprocessed iMode value - %ld",iMode ));
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    return  lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\sfttpcl.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    sfttpcl.h

Abstract:

    TT outline download header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/03/97 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _SFTTPCL_H

#define _SFTTPCL_H

/*
 * True Type data structures
 */
typedef  signed  char  SBYTE;
/*
 * Table Directory for True Type Font files
 */
#define TABLE_DIR_ENTRY_SIZE    (16/sizeof(int))
#define TABLE_DIR_ENTRY         4 * TABLE_DIR_ENTRY_SIZE
#define SIZEOF_TABLEDIR         8 * TABLE_DIR_ENTRY
typedef ULONG     TT_TAG;
#define TRUE_TYPE_HEADER        12
#define NUM_DIR_ENTRIES         8

typedef unsigned short int  uFWord;
typedef short int           FWord;
/* Some True Type Font default values   */
#define TT_QUALITY_LETTER     2
#define DEF_WIDTHTYPE         0
#define DEF_SERIFSTYLE        0
#define DEF_FONTNUMBER        0
#define DEF_STYLE             0x03e0
#define DEF_TYPEFACE          254
#define DEF_STROKEWEIGHT      0
#define DEF_XHEIGHT           0
#define DEF_CAPHEIGHT         0
#define DEF_SYMBOLSET         0x7502
#define MAX_SEGMENTS          0x200
#define MAX_CHAR              0x100
#define x_UNICODE             0x78
#define H_UNICODE             0x48
#define INVALID_GLYPH         0xffff
#define MAX_FONTS             8
#define MORE_COMPONENTS       0x20

#define FIXED_SPACING         0
#define PROPORTIONAL_SPACING  1
#define LEN_FONTNAME          16
#define LEN_PANOSE            10
#define LEN_COMPLEMENTNUM     8
#define UB_SYMBOLSET          56
#define RESERVED_CHARID       0xffff
#define PCL_MAXHEADER_SIZE   32767


#define PANOSE_TAG            0x4150          // "PA" swapped
#define CE_TAG                'EC'
#define CC_TAG                'CC'
#define GC_TAG                'CG'
#define SEG_TAG               0x5447          // already swapped
#define Null_TAG              0xffff
#define CHAR_COMP_TAG         0x4343

#define PLATFORM_MS           3
#define SYMBOL_FONT           0
#define UNICODE_FONT          1
#define TT_BOUND_FONT         2
#define TT_2BYTE_FONT         3
#define TT_UNBOUND_FONT       11
#define FAMILY_NAME           4

// For Parsing Method 21 we need to start at 0x2100
#define FIRST_TT_2B_CHAR_CODE 0x2100

#define SHORT_OFFSET          0
#define LONG_OFFSET           1

/*
 * Constants used for compound glyphs
 */
#define     ARG_1_AND_2_ARE_WORDS       0x01
#define     WE_HAVE_A_SCALE             0x08
#define     MORE_COMPONENTS             0x20
#define     WE_HAVE_AN_X_AND_Y_SCALE    0x40
#define     WE_HAVE_A_TWO_BY_TWO        0x80


/* TT Table directory header. This is the first str */
typedef struct
{
    FIXED      version;
    USHORT     numTables;
    USHORT     searchRange;
    USHORT     entrySelector;
    USHORT     rangeShift;
} TRUETYPEHEADER;

/* TT Table directory structure. */
typedef struct
{
    ULONG      uTag;
    ULONG      uCheckSum;
    ULONG      uOffset;
    ULONG      uLength;
} TABLEDIR;

typedef TABLEDIR ATABLEDIR[NUM_DIR_ENTRIES];
typedef TABLEDIR *PTABLEDIR;

/* List of tables needed for PCL TT download. They are listed in order. */

#define   TABLEOS2     "OS/2" /* Not sent to PCL header */
#define   TABLEPCLT    "PCLT" /* Not sent to PCL header */
#define   TABLECMAP    "cmap" /* Not sent to PCL header */

#define   TABLECVT     "cvt "
#define   TABLEFPGM    "fpgm"
#define   TABLEGDIR    "gdir" /* This is PCL specific table. Not a TT table */
#define   TABLEGLYF    "glyf" /* This table is not sent in PCL font header */
#define   TABLEHEAD    "head"
#define   TABLEHHEA    "hhea"
#define   TABLEHMTX    "hmtx"
#define   TABLELOCA    "loca" /* Not sent to PCL header */
#define   TABLEMAXP    "maxp"
#define   TABLENAME    "name" /* Not sent to PCL header */
#define   TABLEPOST    "post" /* Not sent to PCL header */
#define   TABLEPREP    "prep"



typedef struct
{
    ULONG u1;
    ULONG u2;
} DATETIME;

typedef struct
{
    FIXED   version;
    FIXED   fontRevision;
    ULONG   checkSumAdjustment;
    ULONG   magicNumber;
    USHORT  flags;
    USHORT  unitsPerEm;
    DATETIME    dateCreated;
    DATETIME    dateModified;
    SHORT   xMin;
    SHORT   yMin;
    SHORT   xMax;
    SHORT   yMax;
    USHORT  macStyle;
    USHORT  lowestRecPPEM;
    SHORT   fontDirectionHint;
    SHORT   indexToLocFormat;
} HEAD_TABLE;

typedef struct
{
    BYTE stuff[34];
    USHORT numberOfHMetrics;
} HHEA_TABLE;

typedef struct {
    uFWord      advanceWidth;
    FWord       leftSideBearing;
} HORIZONTALMETRICS;

typedef struct {
    HORIZONTALMETRICS   longHorMetric[1];
} HMTXTABLE;

typedef struct
{
    uFWord   advanceWidth;
} HMTX_INFO;

typedef struct
{
    FIXED   version;
    USHORT  numGlyphs;
} MAXP_TABLE;

typedef struct
{
    USHORT      version;
    SHORT       xAvgCharWidth;
    USHORT      usWeightClass;
    USHORT      usWidthClass;
    SHORT       fsType;
    SHORT       ySubscriptXSize;
    SHORT       ySubscriptYSize;
    SHORT       ySubscriptXOffset;
    SHORT       ySubscriptYOffset;
    SHORT       ySuperscriptXSize;
    SHORT       ySuperscriptYSize;
    SHORT       ySuperscriptXOffset;
    SHORT       ySuperscriptYOffset;
    SHORT       yStrikeoutSize;
    SHORT       yStrikeoutPosition;
    SHORT       sFamilyClass;
    PANOSE      Panose;
    SHORT       ss1;
    SHORT       ss2;
    SHORT       ss3;
    ULONG       ulCharRange[3];
    SHORT       ss4;
    USHORT      fsSelection;
    USHORT      usFirstCharIndex;
    USHORT      usLastCharIndex;
    USHORT      sTypoAscender;
    USHORT      sTypoDescender;
    USHORT      sTypoLineGap;
    USHORT      usWinAscent;
    USHORT      usWinDescent;
} OS2_TABLE;

typedef struct
{
    FIXED   FormatType;
    FIXED   italicAngle;
    SHORT   underlinePosition;
    SHORT   underlineThickness;
    ULONG   isFixedPitch;              /* set to 0 if proportional, else !0  */
} POST_TABLE;

typedef struct
{
    ULONG   Version;
    ULONG   FontNumber;
    USHORT  Pitch;
    USHORT  xHeight;
    USHORT  Style;
    USHORT  TypeFamily;
    USHORT  CapHeight;
    USHORT  SymbolSet;
    char    Typeface[LEN_FONTNAME];
    char    CharacterComplement[8];
    char    FileName[6];
    char    StrokeWeight;
    char    WidthType;
    BYTE    SerifStyle;
} PCLT_TABLE;

typedef struct
{
    USHORT  PlatformID;
    USHORT  EncodingID;
    ULONG   offset;
} ENCODING_TABLE;

typedef struct
{
    USHORT  Version;
    USHORT  nTables;
    ENCODING_TABLE  encodingTable[3];
} CMAP_TABLE;

typedef struct
{
    USHORT   format;
    USHORT   length;
    USHORT   Version;
    USHORT   SegCountx2;
    USHORT   SearchRange;
    USHORT   EntrySelector;
    USHORT   RangeShift;
} GLYPH_MAP_TABLE;

typedef struct
{
    SHORT numberOfContours;
    FWord xMin;
    FWord yMin;
    FWord xMax;
    FWORD yMax;
//    SHORT GlyphDesc[1];
} GLYPH_DATA_HEADER;

typedef struct
{
    CMAP_TABLE cmapTable;
    ULONG      offset;
} GLYPH_DATA;

typedef struct
{
    USHORT   PlatformID;
    USHORT   EncodingID;
    USHORT   LanguageID;
    USHORT   NameID;
    USHORT   StringLen;
    USHORT   StringOffset;
} NAME_RECORD;

typedef struct
{
    USHORT      FormatSelector;
    USHORT      NumOfNameRecords;
    USHORT      Offset;
    NAME_RECORD *pNameRecord;
} NAME_TABLE;

typedef struct
{
    ULONG ulOffset;
    ULONG ulLength;
} FONT_DATA;

/* Segment data */
#define CE_SEG_SIGNATURE 'EC'
typedef struct
{
    WORD  wSig;
    WORD  wSize;
    WORD  wSizeAlign;
    WORD  wStyle; // 1 = italics, 0,2,3=reserved.
    WORD  wStyleAlign; // 1 = italics, 0,2,3=reserved.
    WORD  wStrokeWeight;
    WORD  wSizing;
} CE_SEGMENT;

//
// From PCL TechRef.pdf
//
// Character Complement Numbers
//
// The "Intellifont Unbound Scalable Font Header" (header) includes a
// 64 bit field (bytes 78-85) which contains the Character Complement
// number. For TrueType fonts, in the "15 Font Header for
// Scalable Fonts" (unbound), the Character Complement number is
// included in the accompanying "Font Data" section of the
// header.
// The Character Complement number identifies the symbol collections
// in the font. Each bit in this field corresponds to a symbol collection
// (not all bits are currently defined; refer to Appendix D in the PCL 5
// Comparison Guide).
//
// This 8-byte field works in conjunction with the Character Complement
// field in the header of a type 10 or 11 (unbound) font to determine the
// compatibility of a symbol set with an unbound font. These two fields
// identify the unbound fonts in the printer which contain the symbol
// collections required to build a symbol set. Refer to "Scalable
// Fonts" in Chapter 9, for a description of symbol collections and
// unbound fonts.
// Each bit in the field represents a specific collection. Setting a bit to 1
// indicates that collection is required; setting the bit to 0 indicates that
// collection is not required. (Bit 63 refers to the most significant bit of
// the first byte, and bit 0 refers to the least significant bit of the eight
// byte field.) The bit representations for the collections are shown
// below.
//
// MSL Symbol index
//
// Bit   Field Designated Use
// 58-63 Reserved for Latin fonts.
// 55-57 Reserved for Cyrillic fonts.
// 52-54 Reserved for Arabic fonts.
// 50-51 Reserved for Greek fonts.
// 48-49 Reserved for Hebrew fonts.
// 3-47  Miscellaneous uses (South Asian, Armenian, 
//       other alphabets, bar codes, OCR, Math, PC Semi-graphics, etc.).
// 0-2   Symbol Index field. 111 - MSL Symbol Index
//
// Unicode Symbol Index
//
// Bit   Field Designated Use
// 32-63 Miscellaneous uses (South Asian, Armenian, other
//       alphabets, bar codes, OCR, Math, etc.).
// 28-31 Reserved for Latin fonts.
// 22-27 Reserved for platform/application variant fonts.
// 3-21  Reserved for Cyrillic, Arabic, Greek and Hebrew fonts.
// 0-2   Symbol Index field. 110 - Unicode Symbol Index
//
// MSL Symbol Index Character Complement Bits
// Bit Value
// 63  0 if font is compatible with standard Latin character
//       sets (e.g., Roman-8, ISO 8859-1 Latin 1);
//     1 otherwise.
// 62  0 if font is compatible with East European Latin
//       character sets (e.g., ISO 8859-2 Latin 2); 1 otherwise.
// 61  0 if font contains Turkish character sets
//       (e.g., ISO 8859/9 Latin 5); 1 otherwise.
// 34  0 if font has access to the math characters of the
//       Math-8, PS Math and Ventura Math character sets;
//     1 otherwise.
// 33  0 if font has access to the semi-graphic characters of
//       the PC-8, PC-850, etc. character sets; 1 otherwise.
// 32  0 if font is compatible with ITC Zapf Dingbats series
//       100, 200, etc.;
//     1 otherwise.
// 2, 1, 0 
//     111 if font is arranged in MSL Symbol Index order.
//
// Unicode Symbol Index Character Complement Bits
// Bit Value
// 31  0 if font is compatible with 7-bit ASCII;
//     1 otherwise.
// 30  0 if font is compatible with ISO 8859/1 Latin 1 (West
//       Europe) character sets;
//     1 otherwise.
// 29  0 if font is compatible with ISO 8859/2 Latin 2 (East
//       Europe) character sets;
//     1 otherwise.
// 28  0 if font is compatible with Latin 5 (Turkish) character
//       sets (e.g., ISO 8859/9 Latin 5, PC-Turkish);
//     1 otherwise.
// 27  0 if font is compatible with Desktop Publishing
//       character sets (e.g., Windows 3.1 Latin 1, DeskTop, MC Text);
//     1 otherwise.
// 26  0 if font is compatible with character sets requiring a
//       wider selection of accents (e.g., MC Text, ISO 8859/1 Latin 1);
//     1 otherwise.
// 25  0 if font is compatible with traditional PCL character
//       sets (e.g., Roman-8, Legal, ISO 4 United Kingdom);
//     1 otherwise.
// 24  0 if font is compatible with the Macintosh character set (MC Text);
//     1 otherwise.
// 23  0 if font is compatible with PostScript Standard Encoding (PS Text);
//     1 otherwise.
// 22  0 if font is compatible with Code Pages
//       (e.g., PC-8, PC 850, PC-Turk, etc.);
//     1 otherwise.
// 2,1,0
//     110 if font is arranged in Unicode Symbol Index order.
//
#define CC_SEG_SIGNATURE 'CC'
typedef struct
{
    WORD  wSig;
    WORD  wSize;
    WORD  wSizeAlign;
    //
    // 64 bit field
    //
    WORD  wCCNumber1;
    WORD  wCCNumber2;
    WORD  wCCNumber3;
    WORD  wCCNumber4;
} CC_SEGMENT;

#define GC_SEG_SIGNATURE 'CG'
typedef struct
{
    WORD  wSig;
    WORD  wSize;
    WORD  wSizeAlign;
    WORD  wFormat; // = 0
    WORD  wDefaultGalleyChar; //FFFF
    WORD  wNumberOfRegions;   // 1 (Hebrew)
    struct {
        WORD wRegionUpperLeft; // 0
        WORD wRegionLowerRight; // FFFE
        WORD wRegional;         // FFFE
    } RegionChar[1];
} GC_SEGMENT;

/* True Type character descriptor */
typedef struct
{
    BYTE    bFormat;
    BYTE    bContinuation;
    BYTE    bDescSize;
    BYTE    bClass;
    WORD    wCharDataSize;
    WORD    wGlyphID;
} TTCH_HEADER;

/* Unbound True Type Font Descriptor */
typedef struct
{
    USHORT  usSize;
    BYTE    bFormat;
    BYTE    bFontType;
    BYTE    bStyleMSB;
    BYTE    bReserve1;
    USHORT  usBaselinePosition;
    USHORT  usCellWidth;
    USHORT  usCellHeight;
    BYTE    bOrientation;
    BYTE    bSpacing;
    USHORT  usSymbolSet;
    USHORT  usPitch;
    USHORT  usHeight;
    USHORT  usXHeight;
    SBYTE   sbWidthType;
    BYTE    bStyleLSB;
    SBYTE   sbStrokeWeight;
    BYTE    bTypefaceLSB;
    BYTE    bTypefaceMSB;
    BYTE    bSerifStyle;
    BYTE    bQuality;
    SBYTE   sbPlacement;
    SBYTE   sbUnderlinePos;
    SBYTE   sbUnderlineThickness;
    USHORT  Reserve2;
    USHORT  Reserve3;
    USHORT  Reserve4;
    USHORT  usNumberContours;
    BYTE    bPitchExtended;
    BYTE    bHeightExtended;
    WORD    wCapHeight;
    ULONG   ulFontNum;
    char    FontName[LEN_FONTNAME];
    WORD    wScaleFactor;
    SHORT   sMasterUnderlinePosition;
    USHORT  usMasterUnderlineHeight;
    BYTE    bFontScaling;
    BYTE    bVariety;
} UB_TT_HEADER;

/* Bounded True Type Font Descriptor */
typedef struct
{
    USHORT  usSize;                    /* Number of bytes in here     */
    BYTE    bFormat;                  /* Descriptor Format  TT is 15 */
    BYTE    bFontType;                /* 7, 8, or PC-8 style font    */
    BYTE    bStyleMSB;
    BYTE    wReserve1;                /* Reserved                    */
    WORD    wBaselinePosition;        /* TT = 0                      */
    USHORT    wCellWide;                /* head.xMax - xMin            */
    USHORT    wCellHeight;              /* head.yMax - yMin            */
    BYTE    bOrientation;             /* TT = 0                      */
    BYTE    bSpacing;                 /* post.isFixedPitch           */
    WORD    wSymSet;                  /* PCLT.symbolSet              */
    WORD    wPitch;                   /* hmtx.advanceWidth           */
    WORD    wHeight;                  /* TT = 0                      */
    WORD    wXHeight;                 /* PCLT.xHeight                */
    SBYTE   sbWidthType;              /* PCLT.widthType              */
    BYTE    bStyleLSB;
    SBYTE   sbStrokeWeight;           /* OS2.usWeightClass          */
    BYTE    bTypefaceLSB;             /*                            */
    BYTE    bTypefaceMSB;             /*                            */
    BYTE    bSerifStyle;              /* PCLT.serifStyle            */
    BYTE    bQuality;
    SBYTE   sbPlacement;              /* TT = 0                     */
    SBYTE   sbUnderlinePos;           /* TT = 0                     */
    SBYTE   sbUnderlineThickness;     /* TT = 0                     */
    USHORT  usTextHeight;             /* Reserved                    */
    USHORT  usTextWidth;              /* Reserved                    */
    WORD    wFirstCode;               /* OS2.usFirstCharIndex       */
    WORD    wLastCode;                /* OS2.usLastCharIndex        */
    BYTE    bPitchExtended;           /* TT = 0                    */
    BYTE    bHeightExtended;          /* TT = 0                    */
    USHORT  usCapHeight;              /* PCLT.capHeight             */
    ULONG   ulFontNum;                /* PCLT.FontNumber            */
    char    FontName[LEN_FONTNAME];   /* name.FontFamilyName        */
    WORD    wScaleFactor;             /* head.unitsPerEm            */
    SHORT   sMasterUnderlinePosition; /* post.underlinePosition     */
    USHORT  usMasterUnderlineHeight;   /* post.underlineThickness    */
    BYTE    bFontScaling;             /* TT = 1                     */
    BYTE    bVariety;                 /* TT = 0                     */
} TT_HEADER;

#endif  // !_SFTTPCL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\sfinst.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    sfinst.h

Abstract:

    Data structures  used for reading the common font installer file format.
    Typically used by drivers during font counting and enumeration at
    EnabldPDEV() time - at the time of writing!  Subject to change as the
    DDI/GDI change.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/

/*
 *   The following structure is returned from the FIOpenRead() function,
 * and contains the basic information needed to access the data in the
 * file once it is memory mapped.
 */

typedef  struct
{
    HANDLE hFont;               /* Font installer file, for downloaded part */
    BYTE  *pbBase;              /* Base address of data as mapped */
    void  *pvFix;               /* Fixed part at start of file */
    ULONG  ulFixSize;           /* Bytes in fixed data record */
    ULONG  ulVarOff;            /* File offset of data, relative file start */
    ULONG  ulVarSize;           /* Bytes in variable part */
}  FI_MEM;


/*
 *      Definitions used in the font file.  This is the file which holds
 *      information about cartridge and download fonts.  The file format
 *      is quite basic:  a header for verification; then an array of
 *      records,  each with a header.  These records contain FONTMAP
 *      information.  Cartridges have an array of these, one for each
 *      font.  Finally,  the tail of the file contains extra data, as
 *      required.  For download fonts,  this would be the download data.
 *
 */


/*
 *   The file header.   One of these is located at the beginning of the file.
 *  The ulVarData field is relative to the beginning of the file.  This
 *  makes it easier to regenerate the file when fonts are deleted.
 */

typedef  struct
{
    ULONG   ulID;               /* ID info - see value below */
    ULONG   ulVersion;          /* Version information - see below */
    ULONG   ulFixData;          /* Start of FF_REC_HEADER array */
    ULONG   ulFixSize;          /* Number of bytes in fixed section */
    ULONG   ulRecCount;         /* Number of records in fixed part */
    ULONG   ulVarData;          /* Start of variable data, rel to 0 */
    ULONG   ulVarSize;          /* Numbier of bytes in variable portion */
}  FF_HEADER;

/*
 *   Values for the ID and Version fields.
 */

#define FF_ID           0x6c666e66              /* "fnfl" - fOnTfIlE */
#define FF_VERSION      1                       /* Start at the bottom */

/*
 *   Each entry in the file starts with the following header.  Typically
 * there will be one of these for a softfont, and one per cartridge.
 * In the case of a cartridge,  there will be an array of these, within
 * the master entry.  Each sub-entry will be for one specific font.
 *
 *   Note that there is a dummy entry at the end.  This contains a 0
 * in the ulSize field - it is to mark the last one,  and makes it
 * easier to manipulate the file.
 */

typedef  struct
{
    ULONG   ulRID;              /* Record ID */
    ULONG   ulNextOff;          /* Offset from here to next record: 0 == end */
    ULONG   ulSize;             /* Bytes in this record */
    ULONG   ulVarOff;           /* Offset from start of variable data */
    ULONG   ulVarSize;          /* Number of bytes in variable part */
}  FF_REC_HEADER;

#define FR_ID           0x63657266              /* "frec" - fONT recORD */

/*
 *   Define the file extensions used.  The first is the name of the
 * font installer file;  the others are temporaries used during update
 * of the (possibly) existing file.
 */


#define  FILE_FONTS     L"fi_"           /* "Existing" single file */
#define  TFILE_FIX      L"fiX"           /* Fixed part of file */
#define  TFILE_VAR      L"fiV"           /* Variable (optional) portion */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\xtrafont.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

     xtrafont.c

Abstract:

    Additional font information code.  Basically this involves handling
    softfonts or font cartridges not included with the minidriver.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/05/96 -ganeshp-
        Created

--*/

#include "font.h"




/*
 *   A macro to decide font compatability with this printer.  The fnt
 *  parameter should be the dwSelBits of the FI_DATA structure for
 *  the font of interest,  while the prt field is the dwSelBits for
 *  this particular printer.
 */

#define FONT_USABLE( fnt, prt ) (((fnt) & (prt)) == (fnt))



int
IXtraFonts(
PDEV    *pPDev         /* All that there is to know */
    )

/*++

Routine Description:
        Function to determine the number of extra fonts available for this
        particular printer variety (mini driver based).  Open the font
        installer generated file, if it exists, and examine it to determine
        how many of these fonts are available to us.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    Number of fonts available; 0 is legitimate; -1 on error.
Note:
    12-05-96: Created it -ganeshp-


--*/
{

    int      iNum;              /* Number of fonts */
    int      iRet;              /* Number of usable fonts */
    int      iI;                /* Loop parameter */

    DWORD    dwSelBits;         /* Selection mask for this printer */

    FI_MEM   FIMem;             /* For accessing installed fonts */

    PFONTPDEV pFontPDev = pPDev->pFontPDev;


    iNum = IFIOpenRead( &FIMem, pPDev->WinResData.pwstrDataFile, pPDev );

    VERBOSE(( "UniFont!iXtraFonts: ++++ Got %ld EXTRA FONTS", iNum ));

    dwSelBits = pFontPDev->dwSelBits;

    for( iRet = 0, iI = 0; iI < iNum; ++iI )
    {
        if( BFINextRead( &FIMem ) )
        {
            if( FONT_USABLE( ((FI_DATA_HEADER *)FIMem.pvFix)->dwSelBits,
                                                                 dwSelBits ) )
                ++iRet;
        }
        else
            break;              /* Should not happen */
    }

    VERBOSE(( " - %ld are usable\n", iRet ));

    if( iRet > 0 )
    {
        /*  Have fonts,  so remember all this stuff for later */

        VXFRewind( pPDev );            /* Back to the start */

        if( pFontPDev->pvFIMem = MemAllocZ(sizeof( FI_MEM)) )
        {
            /*  Got the storage,  so fill it up for later */
            *((FI_MEM *)(pFontPDev->pvFIMem)) = FIMem;

            return  iRet;               /* The number of fonts */
        }
    }

    /*
     *  Here means that there are no fonts OR that the HeapAlloc()
     * failed.  In either case,  return no fonts.
     */

    if( !BFICloseRead( &FIMem, pPDev )  )      /* Drop any connections */
    {
        ERR(( "UniFont!iXtraFonts: bFICloseRead() fails\n" ));
    }


    pFontPDev->pvFIMem = 0;               /* Nothing available */

    return  0;
}


BOOL
BGetXFont(
    PDEV  *pPDev,           /* All that's worth knowing */
    int    iIndex           /* Which one of the suitable fonts */
    )
/*++

Routine Description:
        Returns the next record (in the font file) which is suitable for
        the current printer and mode of printing.



Arguments:

    pPDev           Pointer to PDEV
    iIndex          Which one of the suitable fonts.


Return Value:
    TRUE/FALSE,  FALSE being EOF.  Updates the FI_MEM structure in the UDPDEV.

Note:
    12-05-96: Created it -ganeshp-


--*/
{
    /*
     *    Not hard:  loop reading the next entry in the file,  until
     *  we find one that matches the capabilities of this printer.
     */


    FI_MEM  *pFIMem;
    PFONTPDEV pFontPDev = pPDev->pFontPDev;


    /*
     *    Perform some safety checks and a little optimisation.  The
     *  safety check is for reference to index 0.  In this case, do
     *  the safe operation of a rewind, which sets us into a known
     *  state.  It also will force us to read the very first record,
     *  which we might not otherwise do.
     *    The optimisation checks to see if this request is for the
     *  same record as last time.  This is an unlikely happening, but
     *  if we do not detect it,  we will rewind before coming
     *  back to where we are!
     */

    if( iIndex == 0 || iIndex < pFontPDev->iCurXFont )
        VXFRewind( pPDev );               /* Back to the beginning */
    else
    {
        if( iIndex == (pFontPDev->iCurXFont - 1) )
            return  TRUE;                 /* It's our current one! */
    }


    pFIMem = pFontPDev->pvFIMem;


    while( BFINextRead( pFIMem ) )
    {
        if( FONT_USABLE( ((FI_DATA_HEADER *)pFIMem->pvFix)->dwSelBits,
                                                        pFontPDev->dwSelBits ) )
        {
            /*
             *   Is this the font we want?  Check on the index.
             *  NOTE that we need to increment the record number, as the
             *  bFINextRead() function does so.
             */

            if( iIndex == pFontPDev->iCurXFont++ )
                return  TRUE;               /* AOK for us */
        }
    }

    return  FALSE;
}




void
VXFRewind(
    PDEV   *pPDev
    )
/*++

Routine Description:
        Rewind the font installer database file, and update our red tape.

Arguments:

    pPDev           Pointer to PDEV


Return Value:
    Nothing

Note:
    12-05-96: Created it -ganeshp-


--*/
{

    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    /*
     *    Not much to do,  but having this function ensures we always do it.
     */

    IFIRewind( pFontPDev->pvFIMem );

    pFontPDev->iCurXFont = 0;                  /* Back at the start */


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\truetype.c ===
/*++

  Copyright (c) 1996 - 1999  Microsoft Corporation,
                     Hewlett-Packard

  Module Name:

    TrueType.c

  Abstract:

    This module implements the TrueType-as-Outline support.

  Author:

    Sandra Matts. v-sandma@microsoft.com
    Jim Fordemwalt: v-jford@microsoft.com

  Notes:

    When time permits a flags field should be added to the privateFM including
    a flag for fixed-pitch/variable-pitch.

    When time permits code should be added to retrieve a list of exempted fonts
    from the registry.  Look at raster.c and enable.c for calls to
    EngGetPrinterData and use a string like L"ExemptedFonts" of type multi-sz.

  Revision History:

    10/95   Sandra Matts
        First version

--*/

//Comment out this line to disable FTRC and FTST macroes.
//#define FILETRACE

//
// This KLUDGE flag signifies that I am running a kludgey version
// of this file.  As I am cleaning up I will need to remove this and
// deal with the issues in the code.  However, this allows me to compile,
// run and test without being complete.
//
// #define KLUDGE 1

//
// The TT_ECHO_ON flag indicates that I want to see TT messages for each
// font and glyph that is sent to the printer.  It should be used with care
// because even a modest page can contain several thousand glyph-outs.  It
// will cause printing to occur very slowly!
//
// #define TT_ECHO_ON 1

#include    "font.h"

///////////////////////////////////////////////////////////////////////////////
// Local function prototypes


USHORT
usParseTTFile(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT PTABLEDIR pPCLTableDir,
    OUT PTABLEDIR pTableDir,
    OUT BOOL *pbExistPCLTTable
);

PTABLEDIR
pFindTag(
    IN PTABLEDIR pTableDir,
    IN USHORT usMaxDirEntries,
    IN char *pTag
);

BOOL
bCopyDirEntry(
    OUT PTABLEDIR pDst,
    IN PTABLEDIR pSrc
);

BOOL
bTagCompare(
    IN ULONG uTag,
    IN char *pTag
);

DWORD
dwDLTTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN TT_HEADER ttheader,
    IN USHORT usNumTags,
    IN PTABLEDIR pPCLTableDir,
    IN BYTE *PanoseNumber,
    IN BOOL bExistPCLTTable
);

BOOL
bOutputSegment(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN BYTE *pbData,
    IN LONG ulSegSize,
    IN OUT USHORT *pusCheckSum
);

BOOL
bOutputSegHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN ULONG ulSegSize,
    IN OUT USHORT *pusCheckSum
);

BOOL
bOutputSegData(
    IN PDEV *pPDev,
    IN BYTE *pbData,
    IN LONG ulDataSize,
    IN OUT USHORT *pusCheckSum
);

BOOL
bSendFontData(
    IN PDEV *pPDev,
    IN FONT_DATA *aFontData,
    IN USHORT usNumTags,
    IN BYTE *abNumPadBytes,
    IN OUT USHORT *pusCheckSum
);

DWORD
dwTTOutputGlyphData(
    IN PDEV *pPDev,
    IN HGLYPH hGlyph
);

PBYTE pbGetGlyphInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    OUT USHORT *pusGlyphLen
);

BOOL
bReadInTable(
    IN PVOID pTTFile,
    IN PVOID pvTableDir,
    IN char *tag,
    OUT PVOID pvTable,
    IN LONG lSize
);

BOOL
bCopyGlyphData(
    IN OUT PDEV *pPDev,
    IN PFONTMAP pFM,
    IN CMAP_TABLE cmapTable,
    IN PTABLEDIR pTableDir
);

ULONG
ulCalcTableCheckSum(
    IN ULONG *pulTable,
    IN ULONG ulLength
);

USHORT
usCalcCheckSum(
    IN BYTE *pbData,
    IN ULONG ulLength
);

void
vBuildTrueTypeHeader(
    IN PVOID pTTFile,
    OUT TRUETYPEHEADER *trueTypeHeader,
    IN USHORT usNumTags,
    IN BOOL bExistPCLTTable
);

void
vGetFontName(
    IN PDEV *pPDev,
    IFIMETRICS  *pIFI,
    OUT char *szFontName
);

USHORT
usGetCharCode(
    IN HGLYPH hglyph,
    IN PDEV *pPDev
);

BYTE *
pbGetTableMem(
    IN char *tag,
    IN PTABLEDIR pTableDir,
    IN PVOID pTTFile
);

void
vGetHmtxInfo(
    OUT BYTE *hmtxTable,
    IN USHORT glyphId,
    IN USHORT numberOfHMetrics,
    IN HMTX_INFO *hmtxInfo
);

USHORT
usGetDefStyle(
    IN USHORT WidthClass,
    IN USHORT macStyle,
    IN USHORT flSelFlags
);

SBYTE
sbGetDefStrokeWeight(
    IN USHORT WeightClass,
    IN USHORT macStyle
);

USHORT
usGetDefPitch(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
);

void
vGetPCLTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT TT_HEADER *ttheader,
    IN PCLT_TABLE pcltTable,
    IN BOOL bExistPCLTTable,
    IN OS2_TABLE OS2Table,
    IN HEAD_TABLE headTable,
    IN POST_TABLE postTable,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
);

void
vSetFontFlags(
    IN OUT PFONTMAP pFM,
    IN IFIMETRICS *pIFI
);

LRESULT
IsFont2Byte(
    IN PFONTMAP pFM
);

DWORD
dwSendCompoundCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph
);

DWORD
dwSendCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    IN USHORT usCharCode
);

HGLYPH
hFindGlyphId(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usCharCode
);

BOOL
bInitTrueTypeFontMap(
    PFONTMAP pFontMap,
    FONTOBJ *pFontObj
);

BOOL
bSetParseMode(
    IN PDEV *pPDev,
    IN OUT PFONTMAP pFM,
    IN DWORD dwNewTextParseMode
);

USHORT
usGetCapHeight(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bIsTrueTypeFileTTC(
    IN PVOID pTTFile
);

USHORT
usGetNumTableDirEntries(
    IN PVOID pTTFile
);

PTABLEDIR
pGetTableDirStart(
    IN PVOID pTTFile
);

BOOL
bPCL_SetFontID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bPCL_SendFontDCPT(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN DWORD dwDefinitionSize
);

BOOL
bPCL_SelectFontByID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bPCL_SelectPointSize(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN POINTL *pptl
);

BOOL
bPCL_DeselectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bPCL_SetParseMode(
    PDEV *pPDev,
    PFONTMAP pFM
);

BOOL
bPCL_SetCharCode(
    PDEV *pPDev,
    PFONTMAP pFM,
    USHORT usCharCode
);

BOOL
bPCL_SendCharDCPT(
    PDEV *pPDev,
    PFONTMAP pFM,
    DWORD dwSend
);

PVOID
pvGetTrueTypeFontFile(
    IN  PDEV *pPDev,
    OUT ULONG *pulSize
);

BOOL BIsExemptedFont(
    PDEV        *pPDev,
    IFIMETRICS  *pIFI
);

BOOL BIsPDFType1Font(
    IFIMETRICS  *pIFI
);

///////////////////////////////////////////////////////////////////////////////
// Local Macros

/*++

  Macro Description:

    The PCLSTRING is used to send specific (short) PCL command strings
    to the printer.

--*/
#define PCLSTRLEN 30
typedef char PCLSTRING[PCLSTRLEN];

/*++

  Macro Description:

    The INTSTRING is used to store integer values when converted to string.

--*/
#define INTSTRLEN 15
typedef char INTSTRING[INTSTRLEN];

#define MAX_PAD_BYTES 4

// [ISSUE] Where is a better place to define this?
#ifndef MAX_USHORT
#define MAX_USHORT 0xFFFF
#endif

/*++

  Macro Description:

    Text parsing mode controls PCL treatment of text data.
    We will use parsing mode 21 with format 16 because most printers
    don't support parsing mode 2.

--*/
#define PARSE_MODE_0   0
#define PARSE_MODE_21 21

/*++

  Macro Description:

    GetPrivateFM: isolates the private truetype fontmap field

  Arguments:

    pFontMap - The fontmap which contains the truetype private section

  Return Value:

    The private fontmap field.

--*/
#define GETPRIVATEFM(pFontMap) ((pFontMap) ? ((FONTMAP_TTO*)pFontMap->pSubFM) : NULL)


/*++

  Macro Description:

    GetFontPDev: isolates the font FontPDev buried in the PDEV structure.

  Arguments:

    pPDev - The PDEV for the current process

  Return Value:

    The FontPDev field.

--*/
#define GETFONTPDEV(pPDev)  ((pPDev) ? ((PFONTPDEV)pPDev->pFontPDev) : NULL)


/*++

  Macro Description:

    Swaps bytes: b1 b2 b3 b4 becomes b4 b3 b2 b1

  Arguments:

    x - ULONG to be swapped

  Return Value:

    None.

--*/
#define SWAL( x )  ((ULONG)(x) = (ULONG) ((((((x) >> 24) & 0x000000ff) | \
                                         (((((x) >> 8) & 0x0000ff00)   | \
                                         ((((x) << 8) & 0x00ff0000)    | \
                                         (((x) << 24) & 0xff000000))))))))

/*++

  Macro Description:

    Returns whether the given FONTMAP_TTO is in a valid state.
    Note that we don't check the pvDLData.

  Arguments:

    pPrivateFM - TrueType fontmap structure.

  Return Value:

    TRUE if FONTMAP_TTO is valid, else FALSE

--*/
#define VALID_FONTMAP_TTO(pPrivateFM)                                       \
    ((pPrivateFM) &&                                                        \
     /*(pPrivateFM)->pTTFile && */                                          \
     (pPrivateFM)->pvGlyphData &&                                           \
     /* (pPrivateFM)->pvDLData */ TRUE )


/*++

  Macro Description:

    Returns whether the given FONTMAP is in a valid state.

  Arguments:

    pFM - fontmap structure.

  Return Value:

    TRUE if FONTMAP is valid, else FALSE

--*/
#define VALID_FONTMAP(pFM)  ((pFM) && VALID_FONTMAP_TTO(GETPRIVATEFM(pFM)))


/*++

  Macro Description:

    Asserts if the given FONTMAP is not in a valid state.

  Arguments:

    pFM - fontmap structure.

  Return Value:

    None.

--*/
#define ASSERT_VALID_FONTMAP(pFM)                                           \
{                                                                           \
    ASSERTMSG(VALID_FONTMAP(pFM), ("Invalid FONTMAP\n"));                   \
}


/*++

  Macro Description:

    Asserts if the given FONTPDEV is not in a valid state.

  Arguments:

    pFontPDev - TrueType fontmap structure.

  Return Value:

    None.

--*/
#define ASSERT_VALID_FONTPDEV(pFontPDev)                                    \
{                                                                           \
    ASSERTMSG(VALID_FONTPDEV(pFontPDev), ("Invalid FONTPDEV\n"));           \
    /* ASSERTMSG(pFontPDev, ("FONTPDEV: NULL\n")); */                       \
}


/*++

  Macro Description:

    Asserts if the given TO_DATA is not in a valid state.

  Arguments:

    pTod - TO_DATA structure.

  Return Value:

    None.

--*/
#define ASSERT_VALID_TO_DATA(pTod)                                          \
{                                                                           \
    ASSERTMSG(pTod, ("TO_DATA: NULL\n"));                                   \
    ASSERT_VALID_PDEV(pTod->pPDev);                                         \
    ASSERT_VALID_FONTMAP(pTod->pfm);                                        \
    ASSERTMSG(pTod->pgp, ("TO_DATA: pgp NULL\n"));                          \
}

/*++

  Macro Description:

    Determines if the file is a converted Type 1 font.

  Arguments:

    pIFI - IFI metrics structure

  Return Value:

    TRUE if Type 1, else FALSE

--*/
#define IS_TYPE1(pIFI) ((pIFI) && ((pIFI)->flInfo & FM_INFO_TECH_TYPE1))

/*++

  Macro Description:

    Determines if the file is a natural TrueType file (TTF)

  Arguments:

    pIFI - IFI metrics structure

  Return Value:

    TRUE if TrueType, else FALSE

--*/
#define IS_TRUETYPE(pIFI) ((pIFI) && ((pIFI)->flInfo & FM_INFO_TECH_TRUETYPE))

#define IS_BIDICHARSET(j) \
    (((j) == HEBREW_CHARSET)      || \
     ((j) == ARABIC_CHARSET)      || \
     ((j) == EASTEUROPE_CHARSET))

/*++

  Constant Description:

    Certain fonts do not print well (or at all) when downloaded as truetype
    outline.  Aside from modifying each and every gpd file this simple list
    will allow the driver to punt (to bitmap--probably) the downloading of
    fonts we don't handle.

    aszExemptedFonts - A lower case list of fonts we don't want to download.
                       The name of the fonts should be in lower case.
    nExemptedFonts - The number of items in the aszExemptedFonts list

--*/
const char * aszExemptedFonts[] = {
    "courier new",
    /* "wingdings", */
#ifdef WINNT_40
    "wingdings",
#endif
    "wide latin" };

const int nExemptedFonts = sizeof(aszExemptedFonts) /
                                sizeof(aszExemptedFonts[0]);

#define BWriteToSpoolBuf(pdev, data, size)                                  \
    (TTWriteSpoolBuf((pdev), (data), (size)) == (size))
//#define BWriteToSpoolBuf(pdev, data, size)                                  \
    //(WriteSpoolBuf((pdev), (data), (size)) == (size))

BOOL BWriteStrToSpoolBuf(IN PDEV *pdev, char *szStr);

/*++

  Macro Description:

    Shorter, simpler way to call WriteSpoolBuf.

  Arguments:

    pdev - Pointer to PDEV
    data - data to write
    size - bytes of data

  Return Value:

    TRUE if successful, else FALSE

--*/
INT TTWriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    );

/*++

  Macro Description:

    Mock-exception handling macros.  These macros perform a simplified
    exception handline using goto and function only within a given routine.

  Arguments:

    label - Goto label.  Multiple labels are supported for a single TRY.

  Return Value:

    None.

--*/
#define TRY             { BOOL __bError = FALSE; BOOL __bHandled = FALSE;
#define TOSS(label)     { __bError = TRUE; WARNING(("Tossing " #label "\n")); goto label; }
#define CATCH(label)    label: if (__bError && !__bHandled) WARNING(("Catching " #label "\n")); \
                               if (__bError && !__bHandled && (__bHandled = TRUE))
#define OTHERWISE       if (!__bError && !__bHandled && (__bHandled = TRUE))
#define ENDTRY          }

/*++

  Macro Description:

    This macro returns TRUE if the pPtr is between pStart and (pStart + ulSize).
    In other words it verifies that pPtr is a valid pointer into the data
    pointed to by pStart of size ulSize.  The macro will evaluate to false if
    the pointer falls before or after the desired range.

  Arguments:

    pStart - The start of data
    ulSize - The number of bytes pointed to by pStart
    pPtr   - A pointer into the data of pStart

  Return Value:

    TRUE if pPtr is in range, else FALSE.

--*/
#define PTR_IN_RANGE(pStart, ulSize, pPtr) \
    (((PBYTE)(pPtr) >= (PBYTE)(pStart)) && \
    ((PBYTE)(pPtr) < ((PBYTE)(pStart) + (ulSize))))

/*++

  Macro Description:

    Converts a FIXED number to a long, with the 'value' field in the
    upper 16 bits and the 'fract' value in the lower 16 bits.
    Note: I'm not using this right now, but let's not delete it just yet.

  Arguments:

    fixed - the FIXED value to convert.

  Return Value:

    The LONG number which is 15-value-8.7-fract-0

#define FIXEDTOLONG(fixed) (((fixed).value << 16) | ((fixed).fract))
--*/

/*++

  Macro Description:

    Evaluates to TRUE if the font is BOLD.

  Arguments:

    pfm - the FONTMAP for thie font.

  Return Value:

    TRUE if the font is BOLD, FALSE otherwise

--*/
#define FONTISBOLD(pfm) ((pfm)->pIFIMet->fsSelection & FM_SEL_BOLD)

/*++

  Macro Description:

    Evaluates to TRUE if the font is ITALIC.

  Arguments:

    pfm - the FONTMAP for thie font.

  Return Value:

    TRUE if the font is ITALIC, FALSE otherwise

--*/
#define FONTISITALIC(pfm) ((pfm)->pIFIMet->fsSelection & FM_SEL_ITALIC)

/*++

  Macro Description:

    Returns TRUE if the font is being simulated (i.e. there is not actual
    ttf file for this specific font).
    Note that there are several different times we will check for simulated
    fonts.  This one handles the initialization of the FONTMAP.

  Arguments:

    flFontType - The FONTOBJ.flFontType for thie font.

  Return Value:

    TRUE if the font is being simulated, FALSE otherwise

--*/

#define FONTISSIMULATED(flFontType) \
    ((flFontType & FO_SIM_BOLD) || (flFontType & FO_SIM_ITALIC))

#define DLMAP_FONTIS2BYTE(pdlm) ((pdlm)->wLastDLGId > 0x00FF)

#ifdef KLUDGE
void mymemcpy(const char *szFileName, int nLineNo,
              void *dst, const void *src, size_t size)
{
    DbgPrint("%s (%d): memcpy(%x,%x,%d)\n",
        szFileName, nLineNo, dst, src, size);
    memcpy(dst, src, size);
}

void mymemset(const char *szFileName, int nLineNo,
              void *dst, int byte, size_t size)
{
    DbgPrint("%s (%d): memset(%x,%d,%d)\n",
        szFileName, nLineNo, dst, byte, size);
    memset(dst, byte, size);
}

#define memcpy(dst, src, size) mymemcpy(StripDirPrefixA(__FILE__), __LINE__, (dst), (src), (size))

#define strcpy(dst, src) mymemcpy(StripDirPrefixA(__FILE__), __LINE__, (dst), (src), strlen(src)+1)

#undef ZeroMemory
#define ZeroMemory(ptr, size) mymemset(StripDirPrefixA(__FILE__), __LINE__, (ptr), 0, (size))

#endif


#define VERIFY_VALID_FONTFILE(pPDev) { }

///////////////////////////////////////////////////////////////////////////////
// Implementation

FONTMAP *
InitPFMTTOutline(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    )
/*++

  Routine Description:

    Initializes a FONTMAP structure for a truetype font.  Memory is allocated
    for the FONTMAP and private FONTMAP areas.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFontObj - Font object--used to get truetype file.

  Return Value:

    A FONTMAP for a truetype font with initialized fields.

--*/
{
    PFONTMAP pFontMap;
    DWORD    dwSize;


    FTRC(Entering InitPFMTTOutline...);

    ASSERT(VALID_PDEV(pPDev));

    // I want TERSE messages to print.
#ifdef TT_ECHO_ON
    giDebugLevel = DBG_TERSE;
#endif

    //
    // This is an example of Device font sub module.
    //
    dwSize = sizeof(FONTMAP) + sizeof(FONTMAP_TTO);
    TRY
    {
        if (!VALID_PDEV(pPDev) || !pFontObj)
            TOSS(ParameterError);

        if (FONTISSIMULATED(pFontObj->flFontType))
            TOSS(SimulatedFont);

        pFontMap = MemAlloc(dwSize);
        if (pFontMap == NULL)
            TOSS(MemoryAllocationFailure);

        ZeroMemory(pFontMap, dwSize);

        pFontMap->dwSignature = FONTMAP_ID;
        pFontMap->dwSize      = sizeof(FONTMAP);
        pFontMap->dwFontType  = FMTYPE_TTOUTLINE;
        pFontMap->pSubFM      = (PVOID)(pFontMap+1);
        pFontMap->flFlags    |= FM_SCALABLE;

        //
        // This function initializes pFontMap->pfnXXXX function pointer, pSubFM data structure.
        //
        if (!bInitTrueTypeFontMap(pFontMap, pFontObj))
        {
            MemFree(pFontMap);
            pFontMap = NULL;
        }
        TERSE(("Preparing to print a TrueType font.\n"));

    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        pFontMap = NULL;
    }
    CATCH(SimulatedFont)
    {
        TERSE(("Font is simulated bold or italic. Punting.\n"));
        pFontMap = NULL;
    }
    CATCH(MemoryAllocationFailure)
    {
        pFontMap = NULL;
    }
    ENDTRY;

    FTRC(Leaving InitPFMTTOutline...);

    return pFontMap;
}


BOOL
bInitTrueTypeFontMap(
    IN OUT PFONTMAP pFontMap,
    IN FONTOBJ *pFontObj
    )
/*++

  Routine Description:

    Initializes the truetype specific part of the fontmap structure, including
    the truetype file pointer itself.  The truetype file is loaded and memory-
    mapped as a result of this funciton.

  Arguments:

    pFontMap - Newly created fontmap structure to be initialized
    pFontObj - Font object--used to get truetype file.

  Return Value:

    TRUE if successful
    FALSE if failure

--*/
{
    FONTMAP_TTO *pPrivateFM;
    ULONG ulFile;
    BOOL bRet;

    FTRC(Entering bInitTrueTypeFontMap...);

    pFontMap->ulDLIndex             = (ULONG)-1;
    pFontMap->pfnSelectFont         = bTTSelectFont;
    pFontMap->pfnDeSelectFont       = bTTDeSelectFont;
    pFontMap->pfnDownloadFontHeader = dwTTDownloadFontHeader;
    pFontMap->pfnDownloadGlyph      = dwTTDownloadGlyph;
    pFontMap->pfnGlyphOut           = dwTTGlyphOut;
    pFontMap->pfnCheckCondition     = bTTCheckCondition;
    pFontMap->pfnFreePFM            = bTTFreeMem;

    // set other TT-specific fields here
    pPrivateFM = GETPRIVATEFM(pFontMap);

    // pPrivateFM->pTTFile = FONTOBJ_pvTrueTypeFontFile(pFontObj, &ulFile);

    // Set to default parsing mode
    pPrivateFM->dwCurrentTextParseMode = PARSE_MODE_0;

    // Grab a copy of the font type
    pPrivateFM->flFontType = pFontObj->flFontType;

    // Grab some memory for the GlyphData
    TRY
    {
        pPrivateFM->pvGlyphData = MemAlloc(sizeof(GLYPH_DATA));
        if (pPrivateFM->pvGlyphData == NULL)
            TOSS(MemoryAllocationFailure);

        ZeroMemory(pPrivateFM->pvGlyphData, sizeof(GLYPH_DATA));
    }
    CATCH(MemoryAllocationFailure)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bInitTrueTypeFontMap...);

    return bRet;
}


BOOL
bTTSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN POINTL *pptl
    )
/*++

  Routine Description:

    Selects the given font on the device.

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to select

  Return Value:

    TRUE if successful
    FALSE if failure

--*/
{
    DWORD dwParseMode; // Current PCL text parsing mode
    FONTMAP_TTO *pPrivateFM = GETPRIVATEFM(pFM);
    BOOL bRet;

    FTRC(Entering bTTSelectFont...);

    if (!VALID_PDEV(pPDev) || NULL == pFM)
    {
            return FALSE;
    }
    VERIFY_VALID_FONTFILE(pPDev);

    TERSE(("Selecting font ID 0x%x.\n", pFM->ulDLIndex));

    // IMPORTANT: Please note that the order of the point size command
    // and the font id command are very important.  If you send the
    // point size command *after* the font ID command you may not
    // get the font you wanted! JFF

    //
    // send Point Size Command if needed
    // Let's set it every time just to be sure! JFF
    // Note that this is now even more interesting because some fonts
    // are fixed space and the lCurrentPointSize doesn't apply.
    //
    // if (pptl->y != pPrivateFM->lCurrentPointSize)
    bRet = bPCL_SelectPointSize(pPDev, pFM, pptl);
    pPrivateFM->lCurrentPointSize = pptl->y;

    //
    // Select font pFM->ulDLIndex
    //
    bRet = bRet & bPCL_SelectFontByID(pPDev, pFM);

    //
    // Text Parsing Command
    //
    if (bRet & (S_OK == IsFont2Byte(pFM)))
    {
        bRet = bSetParseMode(pPDev, pFM, PARSE_MODE_21);
    }

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving bTTSelectFont...);

    return bRet;
}


BOOL
bSetParseMode(
    IN PDEV *pPDev,
    IN OUT PFONTMAP pFM,
    IN DWORD dwNewTextParseMode
    )
/*++

  Routine Description:

    Sets the parsing mode for this font.  Use parse mode 21 for two bype
    fonts and parse mode 0 for single byte fonts.  If the parsing mode
    already matches the given parsing mode nothing is done.

  Arguments:

    pFM - Font map
    dwNewTextParseMode - desired text parsing mode

  Return Value:

    Success.

--*/
{
    BOOL bRet;
    FONTMAP_TTO *pPrivateFM = GETPRIVATEFM(pFM);


    FTRC(Entering bSetParseMode...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    bRet = FALSE;

    if (pPrivateFM)
    {
        if (pPrivateFM->dwCurrentTextParseMode != dwNewTextParseMode)
        {
            pPrivateFM->dwCurrentTextParseMode = dwNewTextParseMode;
            if (bPCL_SetParseMode(pPDev, pFM))
                bRet = TRUE;
        }
        else
            bRet = TRUE;
    }

    FTRC(Leaving bSetParseMode...);

    return bRet;
}


BOOL
bTTDeSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    DeSelects the given font on the device.

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to deselect

  Return Value:

    TRUE if successful
    FALSE if failure

--*/
{
    BOOL bRet;
    FTRC(Entering bTTDeSelectFont...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    TERSE(("Deselecting font ID 0x%x.\n", pFM->ulDLIndex));

    // send Text Parsing Command - set to 0 (default)
    bRet = bSetParseMode(pPDev, pFM, PARSE_MODE_0) &&

    // send Font DeSelection Command
           bPCL_DeselectFont(pPDev, pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving bTTDeSelectFont...);

    return bRet;
}


DWORD
dwTTDownloadGlyph(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    WORD wDLGlyphId,
    WORD *pwWidth
    )
/*++

  Routine Description:

    Download the glyph table for the glyph passed to us.

    Two basic steps: first is to generate the header structure and send that
    off,  then send the actual glyph table.  The only complication happens if
    the download data exceeds 32,767 bytes of glyph image.  This is unlikely
    to happen, but we should be prepared for it.

    Note: If this routine fails do we download as bitmap, or is there another
    routine that we call, or does the caller handle this?

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to download
    hGlyph - specifies glyph to download

  Return Value:

    Bytes of memory used to download glyph.  On failure returns 0.

--*/
{
    USHORT   usGlyphLen;        // number of bytes in glyph
    BYTE    *pbGlyphMem;        // location of glyph in tt file
    DWORD    dwBytesSent;       // Amount of glyph data sent to device
    GLYPH_DATA_HEADER glyphData;
    PFONTPDEV pFontPDev;


    FTRC(Entering dwTTDownloadGlyph...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pwWidth, ("dwTTDownloadGlyph!pwWidth NULL\n"));

    VERIFY_VALID_FONTFILE(pPDev);

    TRY
    {
        dwBytesSent = 0;

        TERSE(("Downloading glyph ID 0x%x.\n", wDLGlyphId));

        if (NULL == (pFontPDev = GETFONTPDEV(pPDev)))
        {
            TOSS(DataError);
        }

        //
        // The font id is no longer set at the beginning of the download sequence.
        // However, the FDV_SET_FONTID flag will tell me when I need to send it.
        //
        if (!(pFontPDev->flFlags & FDV_SET_FONTID))
        {
            PFONTMAP_TTO pPrivateFM;
            DL_MAP *pDLMap;

            if (NULL == (pPrivateFM = GETPRIVATEFM(pFM)))
            {
                TOSS(DataError);
            }
            pDLMap = (DL_MAP*)pPrivateFM->pvDLData;

            TERSE(("Setting Font ID 0x%x.\n", pDLMap->wCurrFontId));
            pFM->ulDLIndex = pDLMap->wCurrFontId;
            bPCL_SetFontID(pPDev, pFM);
            pFontPDev->flFlags  |= FDV_SET_FONTID;
        }

        pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        if (pbGlyphMem == NULL)
            TOSS(DataError);

        memcpy(&glyphData, pbGlyphMem, sizeof(glyphData));


        #if PRINT_INFO
        if (glyphData.numberOfContours < 0)
            ERR(( "dwTTDownloadGlyph!Complex Glyph\n" ));
        #endif

        dwBytesSent = dwSendCharacter(pPDev, pFM, hGlyph, wDLGlyphId);

        //
        // If the glyph is a composite character, need to send the remaining glyph
        // data with a special glyph id of 0xffff
        //
        if (glyphData.numberOfContours < 0)
            dwBytesSent += dwSendCompoundCharacter(pPDev, pFM, hGlyph);
    }
    CATCH(DataError)
    {
        dwBytesSent = 0;
    }
    ENDTRY;

    if (dwBytesSent == 0)
        ERR(("dwTTDownloadGlyph!No bytes sent to printer.\n"));

    VERIFY_VALID_FONTFILE(pPDev);

    //
    // When downloading as TT outline there is no way to calculate the width.
    // So use the width returned by GDI. Do to this just return zero.
    //

    *pwWidth = 0;

    FTRC(Leaving dwTTDownloadGlyph...);

    return  dwBytesSent;
}


DWORD
dwTTGlyphOut(
    IN TO_DATA *pTod
    )
/*++

  Routine Description:

    Invokes a set of glyphs on the device.

    We are given two arrays in the TOD: a glyphpos array and a dlglyph
    array.  The first specifies the position of the glyphs on the page,
    and the second specifies the download ids of the glyphs.  The
    cGlyphsToPrint member specifies how many glyphs to send in this call.

  Arguments:

    pTod - The Text Out data--specifies glyph and everything
    pTod->cGlyphsToPrint - Number of glyphs to send
    pTod->pgp - Glyph positions array
    pTod->apdlGlyph - Glyph download ids array
    pTod->dwCurrGlyph - index into pdlGlyph of where to begin

  Return Value:

    The number of glyphs printed.


--*/
{
    // DWORD dwBytesSent;
    DWORD dwGlyphsSent;
    PDEV *pPDev;
    PFONTPDEV pFontPDev;
    GLYPHPOS *pgp;
    GLYPHPOS *pgpPrev;
    DWORD i;
    BOOL bDefaultPlacement;
    BOOL bHorizontalMovement;
    POINTL ptlFirst, rtlRem;
    BOOL bFirstLoop;
    DWORD dwGlyphs;
    PDLGLYPH pDLG ;
    INT iRelX = 0;
    INT iRelY = 0;
    LONG lWidth = 0;


    FTRC(Entering dwTTGlyphOut...);

    ASSERT_VALID_TO_DATA(pTod);

    pPDev = pTod->pPDev;
    i = pTod->dwCurrGlyph;
    pgp = pTod->pgp;
    pgpPrev = NULL;
    // dwBytesSent = 0;
    dwGlyphsSent = 0;
    bDefaultPlacement = !(SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel));
    ptlFirst = pgp->ptl;
    bFirstLoop = TRUE;
    dwGlyphs = pTod->cGlyphsToPrint;

    VERIFY_VALID_FONTFILE(pPDev);

    //
    // Set the cursor to first glyph if not already set.
    //
    // If there is rounding error, when scaling width,
    // disable x position optimization
    //
    //
    if ( !(pTod->flFlags & TODFL_FIRST_GLYPH_POS_SET) ||
         (pFontPDev = GETFONTPDEV(pPDev)) &&
	 pFontPDev->flFlags & FDV_DISABLE_POS_OPTIMIZE )
    {

        VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &rtlRem);

        //
        // We need to handle the return value. Devices with resoloutions finer
        // than their movement capability (like LBP-8 IV) get into a knot here,
        // attempting to y-move on each glyph. We pretend we got where we
        // wanted to be.
        //

        pPDev->ctl.ptCursor.x += rtlRem.x;
        pPDev->ctl.ptCursor.y += rtlRem.y ;

        //
        // Now set the flag.
        //
        pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;
    }

    while (dwGlyphs--)
    {
        // Locate the download glyph info (pgp is already set)
        pDLG = pTod->apdlGlyph[i++];

        // Skip this the first time through.
        if (bFirstLoop)
        {
            ASSERT(pgpPrev == NULL);
            bFirstLoop = FALSE;
        }
        else
        {
            ASSERT(pgp && pgpPrev);

            //
            // If default placement is off then the character spacing is
            // defined by the pgp->ptl.  Otherwise, the printer's CAP movement
            // will suffice.
            //
            if (!bDefaultPlacement)
            {

                VSetCursor(pPDev, pgp->ptl.x, pgp->ptl.y,
                           MOVE_ABSOLUTE, &rtlRem);
            }
        }

        // Send the glyph to the printer
        TERSE(("Outputting glyph ID 0x%x.\n", (UINT)pDLG->wDLGlyphID));

        if (BPrintADLGlyph(pPDev, pTod, pDLG))
            dwGlyphsSent++;


        //
        // Update the cusor position. This is done only for non default
        // placement case.
        //
        if (!bDefaultPlacement)
        {
            iRelX = 0;
            iRelY = 0;

            lWidth = pDLG->wWidth;

            if (pTod->flAccel & SO_VERTICAL)
                iRelY =  lWidth;
            else
                iRelX = lWidth;

            VSetCursor( pPDev, iRelX, iRelY,
                        MOVE_RELATIVE | MOVE_UPDATE, &rtlRem);
        }

        // Keep track of pos for next loop.
        pgpPrev = pgp;

        // Go to the next glyph in the list
        pgp++;
    }

    // If default placement is on, then we've been ignoring position info.  Time to
    // reconcile with the printer's CAP.  The trick is getting the width of the last
    // char.  The last char is pointed to by pgpPrev and the width is in the bitmap bits.
    if (!bFirstLoop)
    {
        LONG lDelta;
        iRelX = 0;
        iRelY = 0;

        ASSERT(pgpPrev);

        lWidth = pDLG->wWidth;

        if (pTod->flAccel & SO_HORIZONTAL)
        {
            iRelX = pgpPrev->ptl.x - ptlFirst.x + lWidth;
        }
        else if (pTod->flAccel & SO_VERTICAL)
        {
            iRelY = pgpPrev->ptl.y - ptlFirst.y + lWidth;
        }
        else
        {
            iRelX = pgpPrev->ptl.x - ptlFirst.x + lWidth;
            iRelY = pgpPrev->ptl.y - ptlFirst.y;
        }
        VSetCursor(pPDev, iRelX, iRelY, MOVE_RELATIVE | MOVE_UPDATE, &rtlRem);
    }
    // Note: pFM->ctl.iRotate also indicates print direction (?).
    // Represented as 90 degrees * pFM->ctl.iRotate.

    FTRC(Leaving dwTTGlyphOut...);

    VERIFY_VALID_FONTFILE(pPDev);

    return dwGlyphsSent;
}


BOOL IsAnyCharsetDbcs(PBYTE aCharSets)
{
    BOOL bRet = FALSE;

    if (NULL != aCharSets)
    {
        for ( ;*aCharSets != DEFAULT_CHARSET; aCharSets++)
        {
            if (IS_DBCSCHARSET(*aCharSets))
	    {
	        bRet = TRUE;
	        break;
	    }
        }
    }
    return bRet;
}

BOOL IsAnyCharsetBidi(PBYTE aCharSets)
{
    BOOL bRet = FALSE;

    if (NULL != aCharSets)
    {
        for ( ;*aCharSets != DEFAULT_CHARSET; aCharSets++)
        {
            if (IS_BIDICHARSET(*aCharSets))
            {
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

#ifdef WINNT_40
BOOL BIsFontPFB(
        IFIMETRICS* pifi)
{
    BOOL  bRet;
    PTSTR pTmp;

    if (pTmp = wcsrchr((WCHAR*)((PBYTE)pifi+pifi->dpwszFaceName), L'.'))
    {
        bRet = (0 == _wcsicmp(pTmp, L".tmp"));
    }
    else
        bRet = FALSE;


    return bRet;
}
#endif

// Note these are guesses! There should be a better way! JFF
#define AVG_BYTES_PER_HEADER 4096
#define AVG_BYTES_PER_GLYPH   275

BOOL
bTTCheckCondition(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pstro,
    IFIMETRICS  *pifi
    )
/*++

  Routine Description:

    Verifies that the current operation can be carried out by this module.

  Arguments:

    pPDev - Pointer to PDEV
    pGlyphPos - A glyph to be printed
    pFI - font info

  Return Value:

    TRUE if the operation can be carried.
    FALSE otherwise.

--*/
{
    BOOL         bEnoughMem = FALSE;
    DL_MAP      *pDLMap;
    PFONTPDEV    pFontPDev;
    ULONG        ulTTFileLen;

    FTRC(Entering bTTCheckCondition...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(pfo, ("bTTCheckCondition!pfo NULL.\n"));
    ASSERTMSG(pstro, ("bTTCheckCondition!pstro NULL.\n"));

    //
    // Make sure that all parameters ara valid.
    //
    if (NULL == pPDev ||
        NULL == (pFontPDev = GETFONTPDEV(pPDev)) ||
        NULL == pfo   ||
        NULL == pstro ||
        NULL == pifi   )
    {
        return FALSE;
    }

    VERIFY_VALID_FONTFILE(pPDev);

    pDLMap = PGetDLMapFromIdx(pFontPDev, PtrToLong(pfo->pvConsumer) - 1);

    TRY
    {
        WORD wTotalGlyphs;
        DWORD cjMemReq;

        //
        // Make sure that the technology of the font matches the capabilities
        // of the driver.  For example we don't like converted Type 1 fonts.
        //
        if (!IS_TRUETYPE(pifi) && IS_TYPE1(pifi))
            TOSS(UnhandledFont);

#ifdef WINNT_40
        if (BIsFontPFB(pifi))
            TOSS(UnhandledFont);
#endif

        //
        // Fonts we don't want to handle are in the UnhandledFonts list
        //
        if (BIsExemptedFont(pPDev, pifi))
            TOSS(UnhandledFont);

        //
        // Is PDF Type1 font?
        //
        if (BIsPDFType1Font(pifi))
        {
            TOSS(UnhandledFont);
        }

        //
        //
        // TrueType outline downloaded font can't be scaled by non-square
        // (X and Y independendly).
        //
        if(NONSQUARE_FONT(pFontPDev->pxform))
            TOSS(UnhandledFont);

        // Trunction may have happened.We won't download if the number glyphs
        // or Glyph max size are == MAXWORD.  (Note to self: what is "Trunction"?)
        //
        if ( (pDLMap->cTotalGlyphs  == MAXWORD) ||
             (pDLMap->wMaxGlyphSize == MAXWORD) ||
             (pDLMap->wFirstDLGId   == MAXWORD) ||
             (pDLMap->wLastDLGId    == MAXWORD) )
             TOSS(InsufficientFontMem);

        wTotalGlyphs = min( (pDLMap->wLastDLGId - pDLMap->wFirstDLGId),
                           pDLMap->cTotalGlyphs );

        //
        // Calculate the predicted memory requirements for this font.
        //
        cjMemReq = AVG_BYTES_PER_HEADER;
        cjMemReq += wTotalGlyphs * AVG_BYTES_PER_GLYPH;

        //
        // This one's easy.  Don't use all the font memory!
        //
        if ((pFontPDev->dwFontMemUsed + cjMemReq) > pFontPDev->dwFontMem)
            TOSS(InsufficientFontMem);

        //
        // Another check: don't use more than 1/4 of the font memory on any
        // single font!
        //
        if ((cjMemReq * 4) > pFontPDev->dwFontMem)
            TOSS(InsufficientFontMem);

        //
        // Check: don't download wide truetype font. Check the character set
        // of font and if it's one of CJK, return FALSE.
        //

        if (pifi && (IS_DBCSCHARSET(pifi->jWinCharSet) || (pifi->dpCharSets && IsAnyCharsetDbcs((PBYTE)pifi + pifi->dpCharSets))))
            TOSS(CharSetMismatch);

        //
        // Check: If the font is a TTC, but the mode is single-byte then we
        // will probably run out of glyph ids.  Better punt.
        //
        if (bIsTrueTypeFileTTC(pvGetTrueTypeFontFile(pPDev, &ulTTFileLen)) &&
                !DLMAP_FONTIS2BYTE(pDLMap))
            TOSS(CharSetMismatch);
    }
    CATCH(InsufficientFontMem)
    {
        WARNING(("UniFont!bTTCheckCondition:"
                 "Not Downloading the font:TOO BIG for download\n"));
        bEnoughMem = FALSE;
    }
    CATCH(CharSetMismatch)
    {
        //
        // The character set is unacceptable to the truetype download code.
        //
        WARNING(("UniFont!bTTCheckCondition:"
                 "Not Downloading the font:Character set mismatch.\n"));
        bEnoughMem = FALSE;
    }
    CATCH(UnhandledFont)
    {
        //
        // Although there may be enough memory to handle this font we will
        // return false to indicate that this font should be handled some
        // other way--such as bitmap.
        //
        bEnoughMem = FALSE;
    }
    OTHERWISE
    {
        bEnoughMem = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bTTCheckCondition...);

    VERIFY_VALID_FONTFILE(pPDev);

    return bEnoughMem;
}


BOOL
bTTFreeMem(
    IN OUT PFONTMAP pFM
    )
/*++

  Routine Description:

    Free's any memory used by the fontmap structure, including the fontmap
    itself.  Now is a good time to do any cleanup necessary.
    This funciton must reflect the memory allocated in the Init function.

  Arguments:

    pFM - FontMap to be free'd.

  Return Value:

    None.

--*/
{
    BOOL bRet = FALSE;


    FTRC(Entering bTTFreeMem...);

    ASSERT_VALID_FONTMAP(pFM);

    TERSE(("Preparing to release a TrueType font.\n"));

    TRY
    {
        FONTMAP_TTO *pPrivateFM;

        if (!pFM || (pFM->dwFontType != FMTYPE_TTOUTLINE))
            TOSS(ParameterError);

        pPrivateFM = GETPRIVATEFM(pFM);

        // Return the GlyphData memory too.
        if (pPrivateFM->pvGlyphData)
            MemFree(pPrivateFM->pvGlyphData);

        // Return the entire fontmap structure.
        MemFree(pFM);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;


    FTRC(Leaving bTTFreeMem...);

    return bRet;
}


DWORD
dwTTDownloadFontHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Sends a font header to the device for the given font.

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to download

  Return Value:

    Memory used to download header.  On failure returns 0.

--*/
{
    FONTMAP_TTO *pPrivateFM;
    DL_MAP      *pDLMap;

    PVOID       pTTFile;
    ULONG       ulTTFileLen;

    TT_HEADER   ttheader;
    USHORT      usNumTags;
    BOOL        bStatus;
    BOOL        bExistPCLTTable = FALSE;  // TRUE if the optional PCLT Table is in TT file
    DWORD       dwBytesSent;

    HEAD_TABLE  headTable;
    POST_TABLE  postTable;
    MAXP_TABLE  maxpTable;
    PCLT_TABLE  pcltTable;
    CMAP_TABLE  cmapTable;
    NAME_TABLE  nameTable;
    OS2_TABLE   OS2Table;
    HHEA_TABLE  hheaTable;
    BYTE        PanoseNumber[LEN_PANOSE];
    BOOL        bUse2Byte;

    ATABLEDIR PCLTableDir; // Tables needed for PCL download
    ATABLEDIR TableDir;    // Other tables needed for info but not sent to printer


    FTRC(Entering dwTTDownloadFontHeader...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    if (!(pPrivateFM = GETPRIVATEFM(pFM)))
    {
        ERR(("dwTTDownloadFontHeader!pPrivateFM NULL\n"));
        return 0;
    }

    pDLMap = (DL_MAP*)pPrivateFM->pvDLData;
    pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

    //
    // UNIDRV failed to get a memory mapped TT file image.
    //
    if (!pTTFile)
    {
        ERR(("dwTTDownloadFontHeader!pTTFile NULL\n"));
        return 0;
    }

    bUse2Byte = (S_OK == IsFont2Byte(pFM));

    if (pDLMap == 0)
    {
        ERR(("dwTTDownloadFontHeader!pDLMap NULL\n"));
        return 0;
    }

    VERIFY_VALID_FONTFILE(pPDev);

    ZeroMemory(&ttheader, sizeof(ttheader));        // Safe default values
    ZeroMemory(&PCLTableDir, sizeof (PCLTableDir));

    //
    // First fill in the stuff that is easy to find
    //

    //
    // Note that the TT_HEADER and UB_TT_HEADER structures are identical.
    // Therefore, many fields will be treated the same from format 15 to
    // format 16.  Differences start to show up in the segmented font data.
    //
    ttheader.usSize = sizeof(TT_HEADER); // = sizeof(UB_TT_HEADER); too
    SWAB(ttheader.usSize);

    if (bUse2Byte)
    {
        ttheader.bFormat = PCL_FM_2B_TT;
        ttheader.bFontType = TT_2BYTE_FONT; // not TT_UNBOUND_FONT;
    }
    else
    {
        ttheader.bFormat = PCL_FM_TT;
        ttheader.bFontType = TT_BOUND_FONT;
    }

    //
    // Now fill in the entries from the True Type File
    // pPCLTableDir is the table directory that is downloaded
    // to the printer.
    // pvTableDir is the table directory containing info that
    // is needed for the font but it is not downloaded to
    // the printer. Keep the two tables separate so it's easier
    // to dump to the printer later - simply dump the pPCLTableDir
    // and free the pvTableDir memory.
    //

    usNumTags = usParseTTFile (pPDev, pFM, PCLTableDir, TableDir, &bExistPCLTTable);

    //
    // Get the various tables so we can parse the font information
    //
    bReadInTable (pTTFile, PCLTableDir, TABLEHEAD, &headTable, sizeof ( headTable ));
    pPrivateFM->sIndexToLoc = headTable.indexToLocFormat;

    bReadInTable (pTTFile, PCLTableDir, TABLEMAXP, &maxpTable, sizeof ( maxpTable ));
    pPrivateFM->usNumGlyphs = maxpTable.numGlyphs;

    bReadInTable (pTTFile, TableDir,   TABLEPOST, &postTable, sizeof ( postTable ));
    bReadInTable (pTTFile, TableDir,   TABLECMAP, &cmapTable, sizeof ( cmapTable ));
    bReadInTable (pTTFile, TableDir,   TABLENAME, &nameTable, sizeof ( nameTable ));
    bReadInTable (pTTFile, PCLTableDir, TABLEHHEA, &hheaTable, sizeof ( hheaTable ));

    bReadInTable (pTTFile, TableDir,  TABLEOS2,  &OS2Table, sizeof (OS2Table));

    if (bExistPCLTTable)
        bReadInTable (pTTFile, TableDir,  TABLEPCLT, &pcltTable, sizeof ( pcltTable ));

    //
    // Fill in the True Type header with the info from the True
    // Type file.
    //
    SWAB (headTable.xMax);
    SWAB (headTable.xMin);
    SWAB (headTable.yMax);
    SWAB (headTable.yMin);
    ttheader.wCellWide = (headTable.xMax - headTable.xMin);
    SWAB (ttheader.wCellWide);
    ttheader.wCellHeight = (headTable.yMax - headTable.yMin);
    SWAB (ttheader.wCellHeight);

    ttheader.bSpacing = postTable.isFixedPitch ? FIXED_SPACING : 1; // 1=PROPORTIONAL
    // pUDPDev->pFM->bSpacing = postTable.isFixedPitch ? FIXED_SPACING : 1; // 1=PROPORTIONAL

#ifdef DBG
    // I'm going to use jWinPitchAndFamily later.  Make sure that
    // it agrees with postTable.isFixedPitch. JFF
    {
        BYTE fontPitch = (pFM->pIFIMet->jWinPitchAndFamily & 0x03);
        if ((postTable.isFixedPitch && (fontPitch != FIXED_PITCH)) ||
            (!postTable.isFixedPitch && (fontPitch != VARIABLE_PITCH)))
        {
            ERR(("dwTTDownloadFontHeader!postTable.isFixedPitch different from "
             "pIFI->jWinPitchAndFamily"));
        }
    }
#endif
    //
    // Build the Glyph linked list. Each node contains a character
    // code and its corresponding Glyph ID from the True Type file.
    //
    bCopyGlyphData (pPDev, pFM, cmapTable, TableDir);

    // Get the PCL table. If it's not present generate defaults.
    vGetPCLTInfo (pPDev, pFM, &ttheader, pcltTable, bExistPCLTTable, OS2Table, headTable, postTable, hheaTable, PCLTableDir);

    ttheader.bQuality = TT_QUALITY_LETTER;

    //
    // Set the first/last ids.  When using 2-byte downloading I override the
    // DL_MAP values with the parse-mode 21 char codes.
    //
    if (bUse2Byte)
    {
        //
        // [ISSUE] The number of chars, 0x0800, is just a guess for now.  We need a sensible
        // algorithm for determining this number so that it's large enough to be useful
        // but doesn't blow the memory on the printer.
        //
        ttheader.wFirstCode = pDLMap->wFirstDLGId = FIRST_TT_2B_CHAR_CODE;
        ttheader.wLastCode  = pDLMap->wLastDLGId  = FIRST_TT_2B_CHAR_CODE + 0x0800;
        SWAB(ttheader.wFirstCode);
        SWAB(ttheader.wLastCode);

        // Because I changed the range I need to change this too.
        pDLMap->wNextDLGId = pDLMap->wFirstDLGId;
    }
    else
    {
        // ttheader.wFirstCode = OS2Table.usFirstCharIndex;
        // ttheader.wLastCode = OS2Table.usLastCharIndex;
        // ttheader.wLastCode = 0xff00;
        ttheader.wFirstCode = pDLMap->wFirstDLGId;
        ttheader.wLastCode  = pDLMap->wLastDLGId;
        SWAB(ttheader.wFirstCode);
        SWAB(ttheader.wLastCode);
    }

    //
    // Get the font name from the True Type Font file and put
    // it into the ttheader
    //
    vGetFontName (pPDev, pFM->pIFIMet, ttheader.FontName);

    ttheader.wScaleFactor = headTable.unitsPerEm;
    SWAB (headTable.unitsPerEm);

    ttheader.sMasterUnderlinePosition = postTable.underlinePosition;
    ttheader.sMasterUnderlinePosition = -(SHORT) (headTable.unitsPerEm/5);
    SWAB (ttheader.sMasterUnderlinePosition);

    ttheader.usMasterUnderlineHeight = postTable.underlineThickness;
    ttheader.usMasterUnderlineHeight = (USHORT) (headTable.unitsPerEm/20);
    SWAB (ttheader.usMasterUnderlineHeight);

    ttheader.usTextHeight = SWAB(OS2Table.sTypoLineGap) +
                            headTable.unitsPerEm;
    SWAB (ttheader.usTextHeight);

    ttheader.usTextWidth = OS2Table.xAvgCharWidth;

    ttheader.bFontScaling = 1;

#ifdef COMMENTEDOUT
    if (ttheader.wSymSet == 0)
        ttheader.wSymSet = DEF_SYMBOLSET;
#endif
    //
    // The symbol set is conflicting with device font symbol sets.  This is most evident
    // when printing the Euro character.  The downloaded TNR TT font causes future uses of the
    // TNR device font to be ignored.  Characters are interpreted as glyph ids and nothing
    // useful is printed.  The solution is to use a custom character set (in this case 0Q)
    // for all TT downloaded fonts.
    //
    ttheader.wSymSet = 17; // Symbol set 0Q
    SWAB(ttheader.wSymSet);



    memcpy (&PanoseNumber, &OS2Table.Panose, LEN_PANOSE);

    //
    // Send the font info from the True Type file to the printer
    //
    dwBytesSent = dwDLTTInfo (pPDev, pFM, ttheader, usNumTags, PCLTableDir, PanoseNumber, bExistPCLTTable);

    //
    // rem return maxpTable.numGlyphs;
    // return mem used.  This may be the size of the font header.
    //
    FTRC(Leaving dwTTDownloadFontHeader...);

    VERIFY_VALID_FONTFILE(pPDev);

    return dwBytesSent;
}


USHORT
usParseTTFile(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT PTABLEDIR pPCLTableDir,
    OUT PTABLEDIR pTableDir,
    OUT BOOL *pbExistPCLTTable
    )
/*++

  Routine Description:

    Function to  retrieve True Type font information from the True Type file
    and store into the ttheader font structure.  Modifies pbExistPCLTTable: True
    if PCLT table is in the True Type file otherwise pbExistPCLTTable becomes
    FALSE.

    Need to parse through and pick up the tables needed for the PCL spec. There
    are 8 tables of which 5 are required and three are optional. Tables are
    sorted in alphabetical order.   The PCL tables needed are:
        cvt -  optional
        fpgm - optional
        gdir - required
        head - required
        hhea - required
        hmtx - required
        maxp - required
        prep - optional
    The optional tables are used in hinted fonts.

    usNumTags is incremented only for PCL tables.

  Arguments:

    pPDev - Unidriver-specific PDev structure
    pPCLTableDir - Pointer to PCL Tables Total 8, They are sent to printer
    pvTableDir - Pointer to General Tables Total 3, used for other info.
    pbExistPCLTTable - Set to TRUE if PCLT table is in True Type file

  Return Value:

    The number of tags in the True Type file.

--*/
{
#define REQUIRED_TABLE(pTable, TableName) { if ((pTable) == NULL) { \
    ERR(("usParseTTFile!Missing required table " #TableName "\n")); return 0; } }

    FONTMAP_TTO *pPrivateFM;
    PVOID        pTTFile;
    ULONG        ulTTFileLen;

    USHORT usNumTags; // Num elements in PCL Table Dir
    USHORT usMaxTags; // Num elements in TrueType file
    PTABLEDIR pDirectory; // Pointer to TrueType file's table dir
    PTABLEDIR pDirEntry; // Pointer to desired entry


    FTRC(Entering usParseTTFile...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    //
    // Use byte-pointers to move through the table arrays.  A counter
    // will track the number of elements in the PCLTableDir.
    //
    pPrivateFM = GETPRIVATEFM(pFM);
    pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

    if (!pTTFile)
    {
        ERR(("usParseTTFile!pTTFile NULL\n"));
        return 0;
    }

    usNumTags = 0;
    usMaxTags = usGetNumTableDirEntries(pTTFile);
    pDirectory = pGetTableDirStart(pTTFile);
    pDirEntry = NULL;

    //
    // Much of this code works from this basic assumption
    //
    if ((sizeof(TABLEDIR) != TABLE_DIR_ENTRY) ||
        (sizeof(TABLEDIR) != 4 * sizeof(ULONG)))
    {
        ERR(("usParseTTFile!Fundamental assumption invalid: sizeof(TABLEDIR)\n"));
        return 0;
    }

    if (NULL == pTableDir)
    {
        ERR(("usParseTTFile!Fundamental assumption invalid: NULL pTableDir\n"));
        return 0;
    }

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEOS2))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLEOS2);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEPCLT))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
        *pbExistPCLTTable = TRUE;
    }
    else
    {
        *pbExistPCLTTable = FALSE;
    }

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLECMAP))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLECMAP);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLECVT))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEFPGM))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }

    // add gdir table here
    memcpy (pPCLTableDir, TABLEGDIR, 4);
    pPCLTableDir++;
    usNumTags += 1;

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEGLYF))
    {
        pPrivateFM->ulGlyphTable = pDirEntry->uOffset;
        pPrivateFM->ulGlyphTabLength = pDirEntry->uLength;

        SWAL (pPrivateFM->ulGlyphTable);
        SWAL (pPrivateFM->ulGlyphTabLength);
    }
    REQUIRED_TABLE(pDirEntry, TABLEGLYF);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEHEAD))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEHEAD);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEHHEA))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEHHEA);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEHMTX))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEHMTX);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLELOCA))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pPrivateFM->ulLocaTable = pTableDir->uOffset;
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLELOCA);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEMAXP))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEMAXP);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLENAME))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLENAME);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEPOST))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLEPOST);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEPREP))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }

    FTRC(Leaving usParseTTFile...);

    return usNumTags;

#undef REQUIRED_TABLE
}


PTABLEDIR
pFindTag(
    IN PTABLEDIR pTableDir,
    IN USHORT usMaxDirEntries,
    IN char *pTag
    )
/*++

  Routine Description:

    Locates the given tag in the true-type header and returns a pointer
    to the desired entry, or NULL if it was not found.

    Note that this routine leaves room for improvement.  Since the fields
    are defined to be in alpha order you should be able to stop after
    passing the desired location (but before reaching the end).

  Arguments:

    pTableDir - pointer to directory entries
    usMaxDirEntries - number of fields in pTableDir
    pTag - pointer to tag we want to find

  Return Value:

    A pointer to the desired entry or NULL if failure.

--*/
{
    USHORT us;
    PTABLEDIR pEntry;


    FTRC(Entering pFindTag...);

    ASSERTMSG(pTableDir, ("pFindTag!pTableDir NULL.\n"));
    ASSERTMSG(pTag, ("pFindTag!pTag NULL.\n"));

    pEntry = NULL;

    //
    // Search the array.  Return the matching item if found.
    //
    for (us = 0; (us < usMaxDirEntries) && pTableDir; us++)
    {
        if (bTagCompare(pTableDir->uTag, pTag))
        {
            pEntry = pTableDir;
            break;
        }

        pTableDir++;
    }

    //
    // Return the item if it was found, else NULL
    //
    FTRC(Leaving pFindTag...);

    return pEntry;
}


BOOL
bCopyDirEntry(
    OUT PTABLEDIR pDst,
    IN PTABLEDIR pSrc
    )
/*++

  Routine Description:

    Copies a table directory entry out of the true type file (i.e. from
    the given location) into the given destination.  The offset field
    byte order is fixed-up.

    Note that this uses the same parameter order as strcpy: (Dest, Src)

  Arguments:

    pbDst - Pointer to destination
    pbSrc - Pointer to source

  Return Value:

    TRUE if the entry could be copied. FALSE otherwise.

--*/
{
    BOOL bRet = FALSE;

    FTRC(Entering bCopyDirEntry...);

    ASSERTMSG(pSrc, ("bCopyDirEntry!pSrc NULL.\n"));
    ASSERTMSG(pDst, ("bCopyDirEntry!pDst NULL.\n"));

    if ((pSrc != NULL) && (pDst != NULL))
    {
        // Get the table directory entry
        memcpy(pDst, pSrc, TABLE_DIR_ENTRY);

        // now fix the byte-order of the offset field
        SWAL(pDst->uOffset);
        SWAL(pDst->uLength);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

        FTRC(Leaving bCopyDirEntry...);

    return bRet;
}


BOOL
bTagCompare(
    IN ULONG uTag,
    IN char *pTag
    )
/*++

  Routine Description:

    Compares the memory and tag to see if they are equal.

    Note this only works when the size of the tag does not exceed
    4 bytes AND any three-letter tags have the following space, e.g.
    "cvt"  <-- WRONG
    "cvt " <-- RIGHT

    Since this routine works by casting the 4 character string to a DWORD it
    is constrained by the fact that sizeof(DWORD) == (4 * sizeof(char)).

  Arguments:

    uTag - Hardcoded tag value
    pTag - Pointer to tag

  Return Value:

    TRUE if the tag at the current location in the TT file matches the
    given tag.  Otherwise FALSE.

--*/
{
    BOOL   bMatch;


    //FTRC(Entering bTagCompare...);

    ASSERTMSG(pTag, ("bTagCompare!pTag NULL.\n"));

    // If this fails change the include file (see above)
    ASSERTMSG(strcmp("cvt ", TABLECVT) == 0, ("bTagCompare!'cvt ' string incorrect.\n"));

    if (pTag != NULL)
    {
        DWORD *pdwTag = (DWORD *)pTag;
        bMatch = (uTag == *pdwTag);
    }
    else
        bMatch = FALSE;

        //FTRC(Leaving bTagCompare...);

    return bMatch;
}


BOOL
bIsTrueTypeFileTTC(
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Returns whether the truetype file is in the TTC file format or not
    (your other choice is TTF).

  Arguments:

    pTTFile - Pointer to memory mapped TrueType file

  Return Value:

    TRUE if the file is TTC, or FALSE if the file is TTF.

--*/
{
    BOOL bRet;
    const ULONG *pulFile = (const ULONG*)pTTFile;

    FTRC(Entering bIsTrueTypeFileTTC...);

    if (pTTFile)
        bRet = bTagCompare(*(pulFile), "ttcf");
    else
        bRet = FALSE;

    FTRC(Leaving bIsTrueTypeFileTTC...);

    return bRet;
}


USHORT
usGetNumTableDirEntries(
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Returns the number of TABLEDIR entries in the TrueType file.

  Arguments:

    pTTFile - Pointer to memory mapped TrueType file

  Return Value:

    Number of TABLEDIR entries.

--*/
{
    USHORT usNumTags;
    USHORT *pusFile;


    FTRC(Entering usGetNumTableDirEntries...);

    ASSERTMSG(pTTFile, ("usGetNumTableDirEntries!pTTFile NULL.\n"));

    pusFile = (USHORT*)pTTFile;
    if (bIsTrueTypeFileTTC(pTTFile))
    {
        usNumTags = *(pusFile + 12); // byte 24 in file
    }
    else
    {
        usNumTags = *(pusFile + 2); // Just after version (Fixed)
    }
    SWAB(usNumTags);

    FTRC(Leaving usGetNumTableDirEntries...);

    return usNumTags;
}


PTABLEDIR
pGetTableDirStart(
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Returns a pointer to the start of the TABLEDIR entries in the truetype file.

  Arguments:

    pTTFile - Pointer to memory mapped TrueType file

  Return Value:

    Pointer to TABLEDIR entries.

--*/
{
    BYTE *pStart;


    FTRC(Entering pGetTableDirStart...);

    ASSERTMSG(pTTFile, ("pGetTableDirStart!pTTFile NULL.\n"));

    if (bIsTrueTypeFileTTC(pTTFile))
    {
        pStart = (PBYTE)pTTFile + 32; // How should I calculate this?
    }
    else
    {
        pStart = (PBYTE)pTTFile + TRUE_TYPE_HEADER;
    }

    FTRC(Leaving pGetTableDirStart...);

    return (PTABLEDIR) pStart;
}


DWORD
dwDLTTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN TT_HEADER ttheader,
    IN USHORT usNumTags,
    IN PTABLEDIR pPCLTableDir,
    IN BYTE *PanoseNumber,
    IN BOOL bExistPCLTTable
    )
/*++

  Routine Description:

    Function to  retrieve build a new True Type header structure relative to
    the PCL file that is sent to the printer and also send the font data from
    the True Type file.

  Arguments:

    pPDev - Pointer to current PDev
    ttheader - TrueType header structure
    usNumTags - Number of tags found in TrueType file
    pPCLTableDir - Tags from TrueType file
    PanoseNumber - Panose number for this font
    bExistPCLTTable - True if PCLT table was present in TrueType file

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PVOID   pTTFile;
    BYTE   *pbTTFile;
    ULONG   ulTTFileLen;
    ULONG   ulOffset;
    ULONG  *pulOffset;
    ULONG  *pulLength;
    USHORT  us;
    DWORD   dwBytes;
    DWORD   dwTotalBytes;
    ULONG   ulTableLen = 0;
    USHORT  usCheckSum = 0;    //font header checkSum

    BOOL      bUse2Byte;       // True for format 16, false for format 15

    ATABLEDIR PCLtableDir; // Table directory sent to printer,PCL takes   8 table dirs
    ATABLEDIR TTtableDir;  // Temporary Buffer for PCL tables. Needed for
                                 // Calculating new field valued
    TRUETYPEHEADER trueTypeHeader;

    USHORT  usSegHeaderSize;   // Segment header size. Depends on format 15/16

    FONT_DATA  fontData[NUM_DIR_ENTRIES];    // There are eight PCL tables
    BYTE       abNumPadBytes[NUM_DIR_ENTRIES];         // Padding array, Contains num of bytes to be
                                  // padded for each table

    ULONG     ulGTSegSize;
    PTABLEDIR pEntry; // Pointer to dir entry, used for walking tables.


    FTRC(Entering dwDLTTInfo...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pPCLTableDir, ("dwDLTTInfo!pPCLTableDir NULL.\n"));
    ASSERTMSG(PanoseNumber, ("dwDLTTInfo!PanoseNumber NULL.\n"));

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM) ||
            !pPCLTableDir || !PanoseNumber)
            TOSS(ParameterError);

        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);
        if (!pTTFile)
            TOSS(DataError);

        bUse2Byte = (S_OK == IsFont2Byte(pFM));
        usSegHeaderSize = (bUse2Byte ? (sizeof(USHORT) + sizeof(ULONG)) :    // format 16
                                      (sizeof(USHORT) + sizeof(USHORT)));   // format 15
            // (bUse2Byte ? sizeof(UB_SEG_HEADER) : sizeof(SEG_HEADER));

        TERSE(("Downloading TrueType ID 0x%x, as %s.\n", pFM->ulDLIndex,
               (bUse2Byte ? "double-byte" : "single-byte")));

        ZeroMemory(&PCLtableDir, sizeof(PCLtableDir));
        ZeroMemory(&abNumPadBytes, sizeof(abNumPadBytes));

        //
        // Recalculate offsets starting after the end of the tabledir
        //
        ulOffset = TRUE_TYPE_HEADER + SIZEOF_TABLEDIR;

        memcpy (&TTtableDir, (BYTE *)pPCLTableDir, sizeof (TTtableDir));

        //
        // Build the True Type Header with information from the
        // True Type file.
        //
        vBuildTrueTypeHeader (pTTFile, &trueTypeHeader, usNumTags, bExistPCLTTable);

        //
        // Fill in the New Table Dir - which is sent to printer -
        // with the recalculated offsets.
        //
        for (pEntry = pPCLTableDir, us = 0; us < usNumTags; us++, pEntry++)
        {
            PCLtableDir[us].uTag = pEntry->uTag;

            //
            // GDIR is a contrived segment.  It needs to have len = ofs = 0.
            //
            if (!bTagCompare (PCLtableDir[us].uTag, TABLEGDIR))
            {
                PCLtableDir[us].uOffset = ulOffset;
            }

            if (pEntry->uLength % (sizeof (DWORD)) != 0)
            {
                pEntry->uLength += sizeof(DWORD) - (pEntry->uLength % (sizeof (DWORD)));
            }
            PCLtableDir[us].uLength = pEntry->uLength;

            ulOffset += pEntry->uLength;
            ulTableLen += pEntry->uLength;
        }

        //
        // Now send the actual font data from the True Type file.
        // Read in the offsets from the original table directory
        // and fetch the data at the offset in the True Type file.
        // Then dump it to the spooler file.
        //
        for (pEntry = pPCLTableDir, us = 0; us < usNumTags; us++, pEntry++)
        {
            pbTTFile = (BYTE *)pTTFile + pEntry->uOffset;

            fontData[us].ulOffset = TTtableDir[us].uOffset;

            fontData[us].ulLength = TTtableDir[us].uLength;

            //
            // Since the tables have  to be DWORD aligned, we make
            // the adjustments here. Pad to the next word with zeros.
            //
            if (TTtableDir[us].uLength != PCLtableDir[us].uLength)
            {
                abNumPadBytes[us] = (BYTE)(PCLtableDir[us].uLength - TTtableDir[us].uLength);
                PCLtableDir[us].uLength = TTtableDir[us].uLength;
            }


            PCLtableDir[us].uCheckSum = ulCalcTableCheckSum ((ULONG *)pbTTFile,
                                            pEntry->uLength);
            SWAL (PCLtableDir[us].uCheckSum);
            SWAL (PCLtableDir[us].uOffset);
            SWAL (PCLtableDir[us].uLength);
        }

        //
        // Calculate the total number of bytes being sent
        // and send it all to the printer.
        //
        dwBytes = dwTotalBytes = sizeof (TT_HEADER);
        dwTotalBytes += (DWORD) ulOffset;
        dwTotalBytes += (DWORD) LEN_PANOSE;
        dwTotalBytes += (DWORD) usSegHeaderSize; // sizeof (PanoseID);
        dwTotalBytes += (DWORD) usSegHeaderSize; // sizeof (SegHead);
        dwTotalBytes += (DWORD) usSegHeaderSize; // sizeof (NullSegment);
        if (bUse2Byte)
        {
            dwTotalBytes += (DWORD) sizeof(CC_SEGMENT); // sizeof (CCSegment);
            //dwTotalBytes += (DWORD) sizeof(CE_SEGMENT); // sizeof (CESegment);
            //dwTotalBytes += (DWORD) sizeof(GC_SEGMENT); // sizeof (GCSegment);
        }
        dwTotalBytes += sizeof(usCheckSum);      // ending checksum

        // make sure the font header is not too large for PCL5
        // JFF: Need to break up these segments if they are too large.
        if (dwTotalBytes > PCL_MAXHEADER_SIZE)
        {
            ERR(("dwDLTTInfo!PCL Header too large to download.\n"));
            TOSS(ParameterError);
        }

        //
        // This command is sent by the caller: {download.c,BDownLoadAsTT}
        //
        // bPCL_SetFontID(pPDev, pFM);

        bPCL_SendFontDCPT(pPDev, pFM, dwTotalBytes);

        if(!BWriteToSpoolBuf( pPDev, (BYTE *)&ttheader, (LONG)dwBytes ))
            TOSS(WriteError);

        usCheckSum = usCalcCheckSum ((BYTE*)&ttheader.wScaleFactor,
                                  sizeof (ttheader.wScaleFactor));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.sMasterUnderlinePosition,
                                   sizeof (ttheader.sMasterUnderlinePosition));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.usMasterUnderlineHeight,
                                   sizeof (ttheader.usMasterUnderlineHeight));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.bFontScaling,
                                   sizeof (ttheader.bFontScaling));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.bVariety,
                                   sizeof (ttheader.bVariety));

        if (bUse2Byte)
        {
            CC_SEGMENT CCSeg;
            CE_SEGMENT CESeg;
            GC_SEGMENT GCSeg;
            
#if 0
            //
            // Send the Chracter Enhancement Segment (Format 16 only)
            //
            CESeg.wSig = CE_SEG_SIGNATURE;
            CESeg.wSize = 0;
            CESeg.wSizeAlign = SWAPW(sizeof(CE_SEGMENT) - offsetof(CE_SEGMENT, wStyle));
            if (pFM->pIFIMet->fsSelection & FM_SEL_ITALIC)
            {
                CESeg.wStyle = 0x0;
                CESeg.wStyleAlign |= SWAPW(0x2); // Pseudo-italics
            }
            else
            {
                CESeg.wStyle = 0x0;
                CESeg.wStyleAlign = 0x0;
            }
            CESeg.wStrokeWeight = 0XFFFF; // ??? HP monolich does this.
            CESeg.wSizing = 0x0;
            if (!bOutputSegData(pPDev, (PBYTE)&CESeg, sizeof(CESeg), &usCheckSum))
                TOSS(WriteError);
#endif
            //
            // Send the Character Complement (Array of UBYTE)
            // Please see the detain about CC in sfttpcl.h.
            //
            CCSeg.wSig = CC_SEG_SIGNATURE;
            CCSeg.wSize = 0;
            CCSeg.wSizeAlign = SWAPW(sizeof(CCSeg) - offsetof(CC_SEGMENT, wCCNumber1));
            CCSeg.wCCNumber1 = 0;
            CCSeg.wCCNumber2 = SWAPW(0xFFFE);
            CCSeg.wCCNumber3 = 0;
            CCSeg.wCCNumber4 = SWAPW(0xFFFE);
            if (!bOutputSegData(pPDev, (PBYTE)&CCSeg, sizeof(CCSeg), &usCheckSum))
                TOSS(WriteError);

#if 0
            //
            // Galley Character Segment (Format 16 only)
            //
            GCSeg.wSig = GC_SEG_SIGNATURE;
            GCSeg.wSize = 0;
            GCSeg.wSizeAlign = SWAPW(sizeof(GCSeg) - offsetof(GC_SEGMENT, wFormat));
            GCSeg.wFormat = 0;
            GCSeg.wDefaultGalleyChar = 0xFFFF;
            GCSeg.wNumberOfRegions = SWAPW(1);
            GCSeg.RegionChar[0].wRegionUpperLeft = 0;
            GCSeg.RegionChar[0].wRegionLowerRight = 0xFFFE;
            GCSeg.RegionChar[0].wRegional = 0xFFFE;
            if (!bOutputSegData(pPDev, (PBYTE)&GCSeg, sizeof(GCSeg), &usCheckSum))
                TOSS(WriteError);
#endif
        }

        //
        // Send the Panose structure. This include a 2 bytes tag "PA",
        // the size of the Panose Number, and the Panose number.
        //
        if (!bOutputSegment(pPDev, pFM, PANOSE_TAG, PanoseNumber, LEN_PANOSE, &usCheckSum))
            TOSS(WriteError);

        //
        // Send GlobalTrueType data "GT"
        //

        // First calculate the segment size--this is independent of format 15/16
        //ul = sizeof (TRUETYPEHEADER) + ((usNumTags ) * sizeof (TABLEDIR));
        //
        // usNumTags can be 7 or 8, but we always write out 8 entries even when the
        // last one is all zeroes. Therefore usNumTags should *not* be taken into
        // account in this computation. JFF
        //
        ulGTSegSize = sizeof (TRUETYPEHEADER) + (SIZEOF_TABLEDIR);
        ulGTSegSize += ulTableLen;

        if (!bOutputSegHeader(pPDev, pFM, SEG_TAG, ulGTSegSize, &usCheckSum))
            TOSS(WriteError);

        //
        // Send the True Type Header
        //
        if (!bOutputSegData(pPDev, (BYTE*)&trueTypeHeader, TRUE_TYPE_HEADER, &usCheckSum))
            TOSS(WriteError);

        //
        // Send the True Type table directory and the font data.
        //
        if (!bOutputSegData(pPDev, (BYTE*)PCLtableDir, SIZEOF_TABLEDIR, &usCheckSum))
            TOSS(WriteError);

        if (!bSendFontData(pPDev, fontData, usNumTags, abNumPadBytes, &usCheckSum))
            TOSS(WriteError);

        //
        // Send the null segment to indicate the end of segment data
        //
        if (!bOutputSegHeader(pPDev, pFM, Null_TAG, 0, &usCheckSum))
            TOSS(WriteError);

        usCheckSum = 256 - (usCheckSum % 256);
        SWAB (usCheckSum);

        // Don't bother with checksum calculations since we're *sending* it.
        if (!bOutputSegData(pPDev, (BYTE *)&usCheckSum, sizeof (usCheckSum), NULL))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        // Return 0 to show that the header wasn't correctly downloaded.
        dwTotalBytes = 0;
    }
    CATCH(WriteError)
    {
        // Return 0 to show that the header wasn't correctly downloaded.
        dwTotalBytes = 0;
    }
    CATCH(DataError)
    {
        // Return 0 to show that the header wasn't correctly downloaded.
        dwTotalBytes = 0;
    }
    ENDTRY;

    if (dwTotalBytes == 0)
        ERR(("dwDLTTInfo!Font header not downloaded.\n"));
    FTRC(Leaving dwDLTTInfo...);

    return dwTotalBytes;
}

BOOL
bOutputSegment(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN BYTE *pbData,
    IN LONG ulSegSize,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Sends a segment header and data to the printer using bOutputSegHeader
    and bOutputSegData.  This is a handy shortcut for simple segments.

  Arguments:

    pPDev - Pointer to PDEV
    usSegId - Segment ID
    pbData - Segment Data
    ulSegSize - Amount of data (number of bytes pointed to by pbData)
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    BOOL bRet = FALSE;


    FTRC(Entering bOutputSegment...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pbData, ("bOutputSegment!pbData NULL.\n"));

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM) || !pbData)
            TOSS(ParameterError);

        if (!bOutputSegHeader(pPDev, pFM, usSegId, ulSegSize, pusCheckSum))
            TOSS(WriteError);

        if (!bOutputSegData(pPDev, pbData, ulSegSize, pusCheckSum))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bOutputSegment...);

    return bRet;
}


BOOL
bOutputSegHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN ULONG ulSegSize,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Sends a segment header to the printer given the segment's id
    and size.  Handles format 15 or format 16.  Also continues to
    caclulate the checksum for data sent.

  Arguments:

    pPDev - Pointer to PDEV
    usSegId - Segment ID
    ulSegSize - Amount of data
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, FALSE if an error occurred.

--*/
{
    BOOL bUse2Byte = (S_OK == IsFont2Byte(pFM));
    BOOL bRet = TRUE;


    FTRC(Entering bOutputSegHeader...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        if (bUse2Byte)
        {
            // Segment id is already swapped. just swap the size
            SWAL(ulSegSize);

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&usSegId, sizeof(USHORT) ))
                TOSS(WriteError);

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&ulSegSize, sizeof(ULONG) ))
                TOSS(WriteError);

            if (pusCheckSum)
            {
                *pusCheckSum += usCalcCheckSum ((BYTE*)&usSegId, sizeof(USHORT));
                *pusCheckSum += usCalcCheckSum ((BYTE*)&ulSegSize, sizeof(ULONG));
            }
        }
        else
        {
            USHORT usSegSize = (USHORT) ulSegSize;
            SWAB(usSegSize);
            if (ulSegSize > MAX_USHORT)
                ERR(("bOutputSegHeader!Segment size too large.\n"));

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&usSegId, sizeof(USHORT) ))
                TOSS(WriteError);

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&usSegSize, sizeof(USHORT) ))
                TOSS(WriteError);

            if (pusCheckSum)
            {
                *pusCheckSum += usCalcCheckSum ((BYTE*)&usSegId, sizeof(USHORT));
                *pusCheckSum += usCalcCheckSum ((BYTE*)&usSegSize, sizeof(USHORT));
            }
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bOutputSegHeader...);

    return bRet;
}


BOOL
bOutputSegData(
    IN PDEV *pPDev,
    IN BYTE *pbData,
    IN LONG ulDataSize,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Sends segment data to the printer. Should be called after calling
    bOutputSegHeader.

  Arguments:

    pPDev - Pointer to PDEV
    usSegId - Segment ID
    ulSegSize - Amount of data
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, FALSE if an error occurred.

--*/
{
    BOOL bRet = FALSE;


    FTRC(Entering bOutputSegData...);

    ASSERT(VALID_PDEV(pPDev));

    TRY
    {
        TERSE(("Sending %d bytes of segment data.\n", ulDataSize));

        if (!VALID_PDEV(pPDev))
            TOSS(ParameterError);

        if(!BWriteToSpoolBuf( pPDev, pbData, ulDataSize ))
            TOSS(WriteError);

        if (pusCheckSum)
        {
            *pusCheckSum += usCalcCheckSum (pbData, ulDataSize);
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bOutputSegData...);

    return bRet;
}


BOOL
bSendFontData(
    IN PDEV *pPDev,
    IN FONT_DATA *aFontData,
    IN USHORT usNumTags,
    IN BYTE *abNumPadBytes,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Function to retrieve the actual font information from the true type file
    and then send the data to the printer.

  Arguments:

    pPDev - Pointer to PDEV
    aFontData - Array specifing locations of font data to be sent
    usNumTags - Number of tables to be sent
    abNumPadBytes - Number of bytes to pad for each table
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PVOID   pTTFile;
    BYTE   *pbTTFile;
    ULONG   ulTTFileLen;
    BYTE    abZeroArray[MAX_PAD_BYTES];
    USHORT  usZeroArraySize;
    USHORT  us;
    BOOL    bRet = FALSE;


    FTRC(Entering bSendFontData...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(aFontData, ("bSendFontData!aFontData NULL.\n"));
    ASSERTMSG(abNumPadBytes, ("bSendFontData!abNumPadBytes NULL.\n"));
    ASSERTMSG(pusCheckSum, ("bSendFontData!pusCheckSum NULL.\n"));

    // Initialize 4 bytes of padding. The abNumPadBytes[] array describes how many to
    // use for each table
    usZeroArraySize = MAX_PAD_BYTES / sizeof(BYTE);
    ZeroMemory(abZeroArray, usZeroArraySize);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !aFontData ||
            !abNumPadBytes || !pusCheckSum)
            TOSS(ParameterError);

        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

        if (!pTTFile)
            TOSS(DataError);

        // Output each of the tables from the truetype file
        for (us = 0; us < usNumTags; us++)
        {
            pbTTFile = (BYTE *)pTTFile + aFontData[us].ulOffset;

            if (!bOutputSegData(pPDev, pbTTFile, aFontData[us].ulLength, pusCheckSum))
                TOSS(WriteError);

            // If necessary write out zeroes from the zero array to pad to the next boundary.
            if (abNumPadBytes[us] != 0)
            {
                ASSERT(abNumPadBytes[us] <= MAX_PAD_BYTES);

                if (!bOutputSegData(pPDev, abZeroArray, abNumPadBytes[us], pusCheckSum))
                    TOSS(WriteError);
            }
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    CATCH(DataError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bSendFontData...);

    return bRet;
}


DWORD
dwSendCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    IN USHORT usCharCode
    )
/*++

  Routine Description:

    Creates a character header for the true type glyph and sends
    it to the printer

  Arguments:

    pPDev - Pointer to PDEV
    hGlyph - Glyph handle
    usCharCode - Character code associated with glyph

  Return Value:

    Amount of memory used by the glyph.

--*/
{
    TTCH_HEADER  ttCharH;                // true type character header
    USHORT       usCheckSum = 0;
    USHORT       usGlyphLen;            // number of bytes in glyph
    BYTE        *pbGlyphMem;            // location of glyph in tt file
    DWORD        dwTotal;               // Total number of bytes to send
    DWORD        dwSend;                // If size > 32767; send in chunks
    DWORD        dwBytesSent;           // Number of bytes actually sent


    FTRC(Entering dwSendCharacter...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        if (pbGlyphMem == NULL)
            TOSS(DataError);

        ttCharH.bFormat = PCL_FM_TT;
        ttCharH.bContinuation = 0;
        ttCharH.bDescSize = 2;
        ttCharH.bClass = PCL_FM_TT;
        ttCharH.wCharDataSize = usGlyphLen + 2 * sizeof (USHORT);
        ttCharH.wGlyphID = (WORD)hGlyph;

        SWAB (ttCharH.wGlyphID);
        SWAB (ttCharH.wCharDataSize);

        dwTotal = sizeof (ttCharH) + usGlyphLen + sizeof (usCheckSum);

        //
        // Presume that data is less than the maximum, and so can be
        // sent in one hit.  Then loop on any remaining data.
        //

        dwSend = min( dwTotal, 32767 );

        //
        // send the character header and glyph data to the printer
        //
        bPCL_SetCharCode(pPDev, pFM, usCharCode);

        bPCL_SendCharDCPT(pPDev, pFM, dwSend);

        if(!BWriteToSpoolBuf( pPDev, (BYTE *)&ttCharH, sizeof( ttCharH )))
            TOSS(WriteError);

        // Send the actual TT Glyph data
        if(!BWriteToSpoolBuf( pPDev, pbGlyphMem, usGlyphLen ))
            TOSS(WriteError);

        usCheckSum = usCalcCheckSum ((BYTE *)&ttCharH.wCharDataSize,
                                     sizeof (ttCharH.wCharDataSize));

        usCheckSum += usCalcCheckSum ((BYTE *)&ttCharH.wGlyphID,
                                      sizeof (ttCharH.wGlyphID));

        usCheckSum += usCalcCheckSum (pbGlyphMem, usGlyphLen);

        usCheckSum = (~usCheckSum + 1) & 0x00ff;
        SWAB (usCheckSum);

        if(!BWriteToSpoolBuf( pPDev, (BYTE *)&usCheckSum, sizeof (usCheckSum)))
            TOSS(WriteError);

        dwBytesSent = dwSend;

        //   Sent some,  so reduce byte count to compensate
        dwSend -= sizeof( ttCharH );
        dwTotal -= sizeof( ttCharH );

        dwTotal -= dwSend;                   // Adjust for about to send data

        if( dwTotal > 0 )
        {
            ERR(("dwSendCharacter!Glyph data too large; need loop.\n"));
            TOSS(WriteError);
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        // Set to zero to indicate that glyph wasn't sent.
        dwBytesSent = 0;
    }
    CATCH(WriteError)
    {
        // Set to zero to indicate that glyph wasn't sent.
        ERR(("dwSendCharacter!Write error. Glyph not downloaded.\n"));
        dwBytesSent = 0;
    }
    CATCH(DataError)
    {
        dwBytesSent = 0;
    }
    ENDTRY;

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving dwSendCharacter...);

    return dwBytesSent;
}


DWORD
dwSendCompoundCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph
    )
/*++

  Routine Description:

    Finds the additional glyph information for a complex glyph
    and ends the gylph data to the printer using the character
    select code of -1.

  Arguments:

    pPDEV - Pointer to PDEV
    hGlyph - Glyph handle

  Return Value:

    Number of bytes sent to the device

--*/
{
    USHORT   usGlyphLen;        // number of bytes in glyph
    BYTE    *pbGlyphMem;           // location of glyph in tt file
    USHORT   usFlag;
    SHORT   *psGlyphDescMem;
    USHORT  *pusGlyphId;
    GLYPH_DATA_HEADER  glyphData;
    DWORD    dwBytesSent;


    FTRC(Entering dwSendCompoundCharacter...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    TRY
    {
        pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        if (pbGlyphMem == NULL)
            TOSS(DataError);

        memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));
        psGlyphDescMem = (SHORT*)(pbGlyphMem + sizeof (glyphData));
        dwBytesSent = 0;

        do {
            //
            // Get the glyph flag
            //
            usFlag = *((USHORT*)psGlyphDescMem);
            SWAB (usFlag);
            psGlyphDescMem++;

            //
            // Get the glyph id
            //
            pusGlyphId = (USHORT*)psGlyphDescMem;
            psGlyphDescMem++;

            //
            // Skip over args
            //
            if (usFlag & ARG_1_AND_2_ARE_WORDS)
            {
                psGlyphDescMem += 2;
            }
            else
            {
                psGlyphDescMem++;
            }

            //
            // Skip over scale
            //
            if (usFlag & WE_HAVE_A_TWO_BY_TWO)
            {
                psGlyphDescMem += 4;
            }
            else if (usFlag & WE_HAVE_AN_X_AND_Y_SCALE)
            {
                psGlyphDescMem += 2;
            }
            else if (usFlag & WE_HAVE_A_SCALE)
            {
                psGlyphDescMem++;
            }

            //
            // Now send the glyph
            //
            hGlyph = *pusGlyphId;
            SWAB (hGlyph);
            dwBytesSent += dwSendCharacter(pPDev, pFM, hGlyph, 0xffff);
        } while (usFlag & MORE_COMPONENTS);
    }
    CATCH(DataError)
    {
        //
        // Flag the error by returning zero.
        //
        dwBytesSent = 0;
    }
    ENDTRY;

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving dwSendCompoundCharacter...);

    return dwBytesSent;
}


PBYTE
pbGetGlyphInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    OUT USHORT *pusGlyphLen
    )
/*++

  Routine Description:

    Function to get the glyph data for a particular glyph.
    The glyph id is passed in as a parameter and the
    glyph data is kept in the loca table in the True Type file.

  Arguments:

    hGlyph - Glyph handle
    pPDev - Pointer to PDEV
    ppbGlyphMem - Pointer to a pointer which will be directed to the glyph data

  Return Value:

    The number of bytes in the Glyph data table.

--*/
{
    ULONG  ulGlyphTable;
    ULONG  ulLength;
    ULONG  ulLocaTable;
    PVOID  pTTFile;
    PBYTE  pbTTFile;
    PBYTE  pbGlyphMem;
    ULONG  ulTTFileLen;

    ULONG  ul;
    FONTMAP_TTO *pPrivateFM;
    PFONTPDEV pFontPDev = pPDev->pFontPDev;


    FTRC(Entering pbGetGlyphInfo...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pusGlyphLen, ("pbGetGlyphInfo!pusGlyphLen NULL.\n"));

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        pPrivateFM = GETPRIVATEFM(pFM);
        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

        if ((!pTTFile) || (ulTTFileLen == 0))
            TOSS(DataError);

        // JFF: What is the best thing to do here?
        if (hGlyph == INVALID_GLYPH)
            TOSS(InvalidGlyph);

        ulGlyphTable = pPrivateFM->ulGlyphTable;
        ulLength = pPrivateFM->ulGlyphTabLength;
        pbTTFile = (BYTE *)pTTFile;
        ulLocaTable = pPrivateFM->ulLocaTable;

        pbTTFile += ulLocaTable;

        //
        // Before accessing pbTTFile, make sure that the pointer is valid.
        //
        if (pbTTFile > ((BYTE *)pTTFile + ulTTFileLen))
            TOSS(DataError);

        if (pPrivateFM->sIndexToLoc == SHORT_OFFSET)
        {
            USHORT  *pusOffset;
            USHORT   ui;
            USHORT   uj;

            pusOffset = (USHORT *) pbTTFile + hGlyph;

            ui = pusOffset[0];
            SWAB (ui);
            uj = pusOffset[1];

            *pusGlyphLen = (SWAB (uj) - ui) << 1;
            ul = ui;
            pbGlyphMem = (BYTE *)((BYTE *)pTTFile + ulGlyphTable) + (ul << 1);

            if (!PTR_IN_RANGE(pTTFile, ulTTFileLen, pbGlyphMem + *pusGlyphLen - 1))
                TOSS(DataError);

        }
        else     // LONG_OFFSET
        {
            ULONG   *pulOffset,
                     uj;

            pulOffset = (ULONG *) pbTTFile + hGlyph;

            ul = pulOffset[0];
            SWAL (ul);
            uj = pulOffset[1];
            *pusGlyphLen = (USHORT)(SWAL (uj) - ul);
            pbGlyphMem = (BYTE *)((BYTE *)pTTFile + ulGlyphTable) + ul;

            if (!PTR_IN_RANGE(pTTFile, ulTTFileLen, pbGlyphMem + *pusGlyphLen - 1))
                TOSS(DataError);

        }
        //
        // add check here to make sure pbGlyphMem <= pTTFile + size of file
        //
        if (pbGlyphMem > ((BYTE *)pTTFile + ulTTFileLen))
            TOSS(DataError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        *pusGlyphLen = 0;
        pbGlyphMem = NULL;
    }
    CATCH(DataError)
    {
        *pusGlyphLen = 0;
        pbGlyphMem = NULL;
    }
    CATCH(InvalidGlyph)
    {
        ERR(("pbGetGlyphInfo!Invalid glyph handle given.\n"));
        *pusGlyphLen = 0;
        pbGlyphMem = NULL;
    }
    ENDTRY;

    FTRC(Leaving pbGetGlyphInfo...);

    return pbGlyphMem;
}


BOOL
bReadInTable(
    IN PVOID pTTFile,
    IN PTABLEDIR pTableDir,
    IN char *szTag,
    OUT PVOID pvTable,
    IN LONG lSize
    )
/*++

  Routine Description:

    Finds the table in the truetype file that matches the given tag and copies
    the data into the given pointer.

  Arguments:

    pTTFile - Memory mapped truetype file
    pvTableDir - Index of table locations and sizes
    tag - Tag of desired table
    pvTable - buffer to place table data in
    lSize - size of pvTable structure

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PTABLEDIR pEntry;
    BYTE     *pbSrcTable;
    BOOL      bRet = FALSE;


    FTRC(Entering bReadInTable...);

    ASSERTMSG(pTTFile, ("bReadInTable!pTTFile NULL.\n"));
    ASSERTMSG(pTableDir, ("bReadInTable!pTableDir NULL.\n"));
    ASSERTMSG(szTag, ("bReadInTable!szTag NULL.\n"));
    ASSERTMSG(pvTable, ("bReadInTable!pvTable NULL.\n"));
    //
    // Locate the desired table in the truetype file.
    // If it is found copy the table bits to the desired
    // location.
    //
    pbSrcTable = pbGetTableMem(szTag, pTableDir, pTTFile);

    if (pbSrcTable)
    {
        memcpy((BYTE*)pvTable, pbSrcTable, lSize);
        bRet = TRUE;
    }
    else
    {
        ERR(("bReadInTable!Unable to locate tag: '%s'.\n", szTag));
        bRet = FALSE;
    }

    FTRC(Leaving bReadInTable...);

        return bRet;
}


ULONG
ulCalcTableCheckSum(
    IN ULONG *pulTable,
    IN ULONG ulLength
    )
/*++

  Routine Description:

    Calculates checksum for the given table.

  Arguments:

    pulTable - pointer to table data
    ulLength - number of bytes in table

  Return Value:

    Checksum value.

--*/
{
    ULONG  ulSum = 0L;
    ULONG  ulNumFields = (ULONG)(((ulLength + 3) & ~3) / sizeof(ULONG));
    ULONG  ul;


    FTRC(Entering ulCalcTableCheckSum...);

    ASSERTMSG(pulTable, ("ulCalcTableCheckSum!pulTable NULL.\n"));

    for(ul = 0; ul < ulNumFields; ul++)
    {
        ULONG ulTemp = *pulTable;
        SWAL(ulTemp);
        ulSum += ulTemp;
        pulTable++;
    }

    FTRC(Leaving ulCalcTableCheckSum...);

    return (ulSum);
}


void
vBuildTrueTypeHeader(
    IN PVOID pTTFile,
    OUT TRUETYPEHEADER *trueTypeHeader,
    IN USHORT usNumTags,
    IN BOOL bExistPCLTTable
    )
/*++

  Routine Description:

    Fills truetype header structure with the correct information.

  Arguments:

    pTTFile - memory mapped truetype file
    pTrueTypeHeader - header structure to be filled
    usNumTags - number of tables found in TT file
    bExistPCLTTable - whether PCLT table was present

  Return Value:

    None.

--*/
{
    int num;
    int i;


    FTRC(Entering vBuildTrueTypeHeader...);

    ASSERTMSG(pTTFile, ("vBuildTrueTypeHeader!pTTFile NULL.\n"));
    ASSERTMSG(trueTypeHeader, ("vBuildTrueTypeHeader!trueTypeHeader NULL.\n"));

    memcpy (&trueTypeHeader->version, pTTFile, sizeof (trueTypeHeader->version));
    if (!bExistPCLTTable)
        usNumTags = 8;

    trueTypeHeader->numTables = usNumTags;
    num = usNumTags << 4;
    i = 15;
    while ( (i > 0) && (! (num & 0x8000)) )
    {
        num = num << 1;
        i--;
    }
    num = 1 << i;
    trueTypeHeader->searchRange = (USHORT)num;

    num =  usNumTags;
    i = 15;
    while ( (i > 0) && (! (num & 0x8000)) )
    {
        num = num << 1;
        i--;
    }
    trueTypeHeader->entrySelector = (USHORT)i;

    num = (usNumTags << 4) - trueTypeHeader->searchRange;
    trueTypeHeader->rangeShift = (USHORT)num;

    SWAB (trueTypeHeader->searchRange);
    SWAB (trueTypeHeader->numTables);
    SWAB (trueTypeHeader->entrySelector);
    SWAB (trueTypeHeader->rangeShift);

    FTRC(Leaving vBuildTrueTypeHeader...);
}


USHORT
usCalcCheckSum(
    IN BYTE *pbData,
    IN ULONG ulLength
    )
/*++

  Routine Description:

    Calculates the checksum for a buffer

  Arguments:

    pbData - data
    ulLength - amount of data

  Return Value:

    Checksum

--*/
{
    ULONG  ul;
    USHORT usSum = 0;


    FTRC(Entering usCalcCheckSum...);

    ASSERTMSG(pbData, ("usCalcCheckSum!pbData NULL.\n"));

    for (ul = 0; ul < ulLength; ul++)
    {
        usSum += (USHORT)*pbData;
        pbData++;
    }

    FTRC(Leaving usCalcCheckSum...);

    return (usSum);
}


void
vGetFontName(
    IN PDEV *pPDev,
    IN IFIMETRICS *pIFI,
    OUT char *szFontName
    )
/*++

  Routine Description:

    Retrieves the fontname from the name table.

  Arguments:

    pPDev - pointer to PDEV
    PCLFontName - name of font
    pUnicodeFontName - The name as stored in the TT file
    StringLen - length of font name

  Return Value:

    None.

--*/
{
    PWSTR wszUniFaceName;
    ULONG ulUniFaceNameLen;

    char abMultiByteStr[(LEN_FONTNAME + 1) * 2];
    ULONG ulMultiByteStrLen;
    ULONG ulBytesUsed;


    FTRC(Entering vGetFontName...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(szFontName, ("vGetFontName!szFontName NULL.\n"));

    // Retrieve the name from the IFI metrics
    wszUniFaceName = (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName);
    ulUniFaceNameLen = min(wcslen(wszUniFaceName), LEN_FONTNAME) * 2;

    // Copy and convert unicode to a (multibyte?) string.
    EngUnicodeToMultiByteN(abMultiByteStr, ulUniFaceNameLen, &ulBytesUsed,
                           wszUniFaceName, ulUniFaceNameLen);
    ulBytesUsed = min(ulBytesUsed, LEN_FONTNAME-1);
    abMultiByteStr[ulBytesUsed] = '\0';

    // Transfer at most LEN_FONTNAME chars to the destination.
    strcpy (szFontName, abMultiByteStr);

    FTRC(Leaving vGetFontName...);
}


USHORT
usGetDefStyle(
    IN USHORT usWidthClass,
    IN USHORT usMacStyle,
    IN USHORT flSelFlags
    )
/*++

  Routine Description:

    Fills in style.

  Arguments:

    usWidthClass -
    usMacStyle -

  Return Value:

    Default style bits

--*/
{
    USHORT usStyle;
    USHORT usModifier;
    const USHORT usStyleTable[] = { 0, 4, 2, 1, 1, 0, 6, 6, 7, 7 };
    const USHORT usStyleTableLen = sizeof(usStyleTable) /
                                   sizeof(usStyleTable[0]);

        FTRC(Entering usGetDefStyle...);

    usStyle = DEF_STYLE;
    SWAB (usWidthClass);

    // Default value
    //
    usModifier = 0;

    // If possible translate width class to style information using table
    //
    if ((usWidthClass >= 0) && (usWidthClass < usStyleTableLen))
    {
        usModifier = usStyleTable[usWidthClass];
    }

    // Adjust the style with the modifier we just looked up
    //
    usModifier = usModifier << 2;
    usStyle |= usModifier;

    // Apply the mac style too
    usModifier = (usMacStyle >> 1) & 0x0001;
    usStyle |= usModifier;

    // Set the posture bits: 0: Upright, 1: Italic,
    //                       2: Alternate Italic, 3: Reserved
    // Note: I'm selecting 2 for Bold/Italic.
    if (flSelFlags & FM_SEL_ITALIC)
    {
        usModifier = ((flSelFlags & FM_SEL_BOLD) ? 0x0002 : 0x0001);
        usStyle |= usModifier;
    }

    FTRC(Leaving usGetDefStyle...);

    return usStyle;
}


SBYTE
sbGetDefStrokeWeight(
    IN USHORT WeightClass,
    IN USHORT macStyle
    )
/*++

  Routine Description:

    Calculates the stroke weight of the font.

  Arguments:

    WeightClass -
    macStyle -

  Return Value:

    The stroke weight of the font

--*/
{
    SBYTE sbStrokeWeight;
    SBYTE sbModifier;


        FTRC(Entering sbGetDefStrokeWeight...);

    sbStrokeWeight = DEF_STROKEWEIGHT;
    sbModifier = WeightClass / 100;
    if (WeightClass >= 400)
        sbStrokeWeight = sbModifier - 4;
    else
        sbStrokeWeight = sbModifier - 6;

    FTRC(Leaving sbGetDefStrokeWeight...);

    return sbStrokeWeight;
}


void
vGetHmtxInfo(
    OUT BYTE *hmtxTable,
    IN USHORT glyphId,
    IN USHORT numberOfHMetrics,
    IN HMTX_INFO *hmtxInfo
    )
/*++

  Routine Description:

    Fills in hmtxInfo.

  Arguments:

    hmtxTable -
    glyphId -
    numberOfHMetrics -
    hmtxInfo -

  Return Value:

    None.

--*/
{
    HORIZONTALMETRICS   *longHorMetric;
    uFWord               advanceWidth;


    FTRC(Entering vGetHmtxInfo...);

    ASSERTMSG(hmtxTable, ("vGetHmtxInfo!hmtxTable NULL.\n"));
    ASSERTMSG(hmtxInfo, ("vGetHmtxInfo!hmtxInfo NULL.\n"));

    if (hmtxInfo == NULL)
    {
        //
        // Error exit
        //
        return;
    }

    longHorMetric = ((HMTXTABLE *)hmtxTable)->longHorMetric;

    if (longHorMetric == NULL)
    {
        //
        // Error exit
        //
        hmtxInfo->advanceWidth = 0;
    }
    else
    {
        if (glyphId < numberOfHMetrics)
        {
            advanceWidth = longHorMetric[glyphId].advanceWidth;
            hmtxInfo->advanceWidth = SWAB(advanceWidth);
        }
        else
        {
            advanceWidth = longHorMetric[numberOfHMetrics-1].advanceWidth;
            hmtxInfo->advanceWidth = SWAB(advanceWidth);
        }
    }

    FTRC(Leaving vGetHmtxInfo...);
}


BYTE *
pbGetTableMem(
    IN char *szTag,
    IN PTABLEDIR pTableDir,
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Function to find the location of a specific table in the true type file.

  Arguments:

    tag -
    tableDir -
    pTTFile -

  Return Value:

    A Pointer to the beginning of the table in the true type file.

--*/
{
    PTABLEDIR pEntry;
    BYTE     *pRet = NULL;


    FTRC(Entering pbGetTableMem...);

    ASSERTMSG(szTag, ("pbGetTableMem!szTag NULL.\n"));
    ASSERTMSG(pTableDir, ("pbGetTableMem!pTableDir NULL.\n"));
    ASSERTMSG(pTTFile, ("pbGetTableMem!pTTFile NULL.\n"));
    //
    // Locate the tag in the directory entry array.  Return FALSE
    // if the entry cannot be located.
    //
    pEntry = pFindTag(pTableDir, NUM_DIR_ENTRIES, szTag);

    if (pEntry)
    {
        pRet = ((BYTE *)pTTFile + pEntry->uOffset);
    }
    else
    {
        ERR(("pbGetTableMem!Unable to find entry '%s'.\n", szTag));
        pRet = NULL;
    }

    //
    // Found the directory for the table. Now need to
    // read the actual bits at the offset specified in
    // the table directory.
    //
    FTRC(Leaving pbGetTableMem...);

    return pRet;
}


USHORT
usGetXHeight(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Calculates the XHeight for the font. This is only called for
    fonts that do not have a PCLT table.

  Arguments:

    pPDev -

  Return Value:

    The XHeight.

--*/
{
    HGLYPH hGlyph;
    USHORT usHeight;


    FTRC(Entering usGetXHeight...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

#ifdef COMMENTEDOUT
    hGlyph = hFindGlyphId (pPDev, pFM, x_UNICODE);
    if (hGlyph != INVALID_GLYPH)
    {
        USHORT            usGlyphLen;    // number of bytes in glyph
        BYTE             *pbGlyphMem;    // location of glyph in tt file
        GLYPH_DATA_HEADER glyphData;

        phGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));

        usHeight = glyphData.yMax;
    }
    else
    {
        usHeight = DEF_XHEIGHT;
    }
#else
    usHeight = DEF_XHEIGHT;
#endif

    FTRC(Leaving usGetXHeight...);

    return usHeight;
}


USHORT
usGetCapHeight(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Calculates the CapHeight for the font.  This is only called when the
    font does not have a PCLT table.

    This function has two versions.  The newer version--which is commented out--
    and the older version below it.  This is because the newer version is not
    'tried and true' and we want less turmoil at this time.

  Arguments:

    pPDev -

  Return Value:

    The cap hight.

--*/
#ifdef COMMENTEDOUT
{
    //
    // Nominally we would get the height for glyph #43.  After all, that's what
    // the 95 driver does, so it must be right.  However, in some cases the
    // entire glyph set is not present (such as embedded TTF in PDF files) and
    // we will punt.  The first punt, in my opinion, is to try other glyphs which
    // are probably capital letters.  Let's suppose that 43 is supposed to be 'M'.
    // Then the next 12 glyphs should be capitals too.  If that fails
    //
    const HGLYPH kEmGlyph = 43;
    const HGLYPH kStartGlyph = (kEmGlyph - 12);
    const HGLYPH kEndGlyph = (kStartGlyph + 25);

    typedef struct tagGLYPH_RANGE
    {
        HGLYPH start;
        HGLYPH end;
    } GLYPH_RANGE;

    const GLYPH_RANGE aGlyphRange[] = {
        { kEmGlyph, kEndGlyph },
        { kStartGlyph, kEmGlyph - 1 }
    };
    const int kNumGlyphRanges = sizeof aGlyphRange / sizeof aGlyphRange[0];

    USHORT      usGlyphLen;         // number of bytes in glyph
    BYTE       *pbGlyphMem;         // location of glyph in tt file
    HGLYPH      hGlyph;
    GLYPH_DATA_HEADER  glyphData;
    int         i;


    FTRC(Entering usGetCapHeight...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    for (i = 0; i < kNumGlyphRanges; i++)
    {
        for (hGlyph = aGlyphRange[i].start; hGlyph <= aGlyphRange[i].end; hGlyph++)
        {
            pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
            if (pbGlyphMem != NULL)
            {
                memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));
                FTRC(Leaving usGetCapHeight...);
                return glyphData.yMax;
            }
        }
    }

    FTRC(Leaving usGetCapHeight...);

    return DEF_CAPHEIGHT;
}
#else
{
    USHORT            usGlyphLen;         // number of bytes in glyph
    BYTE             *pbGlyphMem;         // location of glyph in tt file
    HGLYPH            hGlyph;             // Glyph handle
    GLYPH_DATA_HEADER glyphData;          // Glyph data structure
    USHORT            usCapHeight;        // The glyph cap height


    FTRC(Entering usGetCapHeight...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // Windows 95 driver uses 43 so we will too.  Probably 'M'.
    hGlyph = 43;

    pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
    if (pbGlyphMem != NULL)
    {
        memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));
        usCapHeight = glyphData.yMax;
    }
    else
    {
        usCapHeight = DEF_CAPHEIGHT;
    }

    FTRC(Leaving usGetCapHeight...);

    return usCapHeight;
}
#endif

USHORT
usGetDefPitch(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
    )
/*++

  Routine Description:

    Calculates the pitch for the font.  Uses the htmx table to get the
    inormation.  This is only called for fonts that have no PCLT table.

  Arguments:

    pPDev -
    pFM -
    hheaTable -
    pTableDir -

  Return Value:

    Pitch or zero if failure.

--*/
{
    HMTX_INFO    HmtxInfo;
    USHORT       glyphId;
    BYTE        *hmtxTable;
    PVOID        pTTFile;
    FONTMAP_TTO *pPrivateFM;
    USHORT       usPitch;


    FTRC(Entering usGetDefPitch...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pTableDir, ("usGetDefPitch!pTableDir NULL.\n"));

    pPrivateFM = GETPRIVATEFM(pFM);
    pTTFile = pvGetTrueTypeFontFile(pPDev, 0);

    if (!pTTFile)
        return 0;

    if (NULL == (hmtxTable = pbGetTableMem (TABLEHMTX, pTableDir, pTTFile)))
    {
        return 0;
    }

    // pick a typical glyph to use - Windows 95 driver uses 3
    glyphId = 3;
    vGetHmtxInfo (hmtxTable, glyphId, hheaTable.numberOfHMetrics,
                 &HmtxInfo);

    usPitch = HmtxInfo.advanceWidth;
    SWAB(usPitch);

    FTRC(Leaving usGetDefPitch...);

    return usPitch;
}


void
vGetPCLTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT TT_HEADER *ttheader,
    IN PCLT_TABLE pcltTable,
    IN BOOL bExistPCLTTable,
    IN OS2_TABLE OS2Table,
    IN HEAD_TABLE headTable,
    IN POST_TABLE postTable,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
    )
/*++

  Routine Description:

    Fills in the TrueType header with information from the PCLT table in the
    TrueType file.  If the PCLT table dos not exist (it's optional), then a good
    set of defaults are used.  The defaults come from the Windows 95 driver.

    ISSUE: These structures are being passed on the stack!

  Arguments:

    pPDev -
    ttheader -
    pcltTable -
    bExistPCLTTable -
    OS2Table -
    headTable -
    postTable -
    hheaTable -
    pTableDir -

  Return Value:

    None.

--*/
{
    FTRC(Entering vGetPCLTInfo...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(ttheader, ("vGetPCLTInfo!ttheader NULL.\n"));
    ASSERTMSG(pTableDir, ("vGetPCLTInfo!pTableDir NULL.\n"));

    SWAL (pcltTable.Version);

    //
    // If there is a PCLT table and it's version is
    // later than 1.0, we can use it.
    //
    if (bExistPCLTTable && (pcltTable.Version >= 0x10000L))
    {
        SWAB (pcltTable.Style);
        ttheader->bStyleMSB = (BYTE)(pcltTable.Style >> 8);
        ttheader->wSymSet = pcltTable.SymbolSet;

        ttheader->wPitch = pcltTable.Pitch;
        ttheader->wXHeight = pcltTable.xHeight;

        ttheader->sbWidthType = pcltTable.WidthType;
        ttheader->bStyleLSB = (BYTE)pcltTable.Style & 0x0ff;

        ttheader->sbStrokeWeight = pcltTable.StrokeWeight;

        ttheader->usCapHeight = pcltTable.CapHeight;
        ttheader->ulFontNum = pcltTable.FontNumber;

        ttheader->bTypefaceLSB = (BYTE) ((pcltTable.TypeFamily & 0xff00) >> 8);
        ttheader->bTypefaceMSB = (BYTE) pcltTable.TypeFamily & 0x00ff;

        ttheader->bSerifStyle =  pcltTable.SerifStyle;
    }
    else
    {
        USHORT usStyle;
        USHORT TypeFamily;
        BOOL   bRet;

        usStyle = usGetDefStyle (OS2Table.usWidthClass, headTable.macStyle,
                                 pFM->pIFIMet->fsSelection);

        ttheader->bStyleMSB = (BYTE)(usStyle >> 8);
        ttheader->bStyleLSB = (BYTE)(usStyle & 0x0ff);

        ttheader->ulFontNum = DEF_FONTNUMBER;
        ttheader->sbWidthType = DEF_WIDTHTYPE;
        ttheader->bSerifStyle =  DEF_SERIFSTYLE;
        TypeFamily = DEF_TYPEFACE;

        ttheader->bTypefaceLSB = (BYTE) (TypeFamily & 0x0ff);
        ttheader->bTypefaceMSB = (BYTE) (TypeFamily >> 8);

        ttheader->wSymSet = 0;

        ttheader->wPitch = usGetDefPitch(pPDev, pFM, hheaTable, pTableDir);

        ttheader->wXHeight = usGetXHeight (pPDev, pFM);

        ttheader->sbStrokeWeight = sbGetDefStrokeWeight (
                                        SWAB (OS2Table.usWeightClass),
                                        SWAB (headTable.macStyle) );

        ttheader->usCapHeight =  usGetCapHeight(pPDev, pFM);
    }

    FTRC(Leaving vGetPCLTInfo...);
}


BOOL
bCopyGlyphData(
    IN OUT PDEV *pPDev,
    IN PFONTMAP pFM,
    IN CMAP_TABLE cmapTable,
    IN PTABLEDIR pTableDir
    )
/*++

  Routine Description:

    Pull out information about the location of the cmap table in the TrueType
    file and store it into the FONTMAP structure.  We need this information in
    case we have to reconstruct the glyph list.

  Arguments:

    pPDev -
    cmapTable -
    pvTableDir -

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    FONTMAP_TTO *pPrivateFM;
    PTABLEDIR    pEntry;
    GLYPH_DATA  *pGlyphData;
    BOOL         bRet = FALSE;


    FTRC(Entering bCopyGlyphData...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pTableDir, ("bCopyGlyphData!pTableDir NULL.\n"));

    if (NULL == (pPrivateFM = GETPRIVATEFM(pFM)))
    {
        return FALSE;
    }
    
    pGlyphData = (GLYPH_DATA*)pPrivateFM->pvGlyphData;

    //
    // Locate CMAP table in the tabledir
    //
    pEntry = pFindTag(pTableDir, NUM_DIR_ENTRIES, TABLECMAP);

    //
    // Copy the glyph information from the CMAP table
    //
    if (pEntry)
    {
        pGlyphData->offset = pEntry->uOffset;
        pGlyphData->cmapTable.Version = cmapTable.Version;
        pGlyphData->cmapTable.nTables = cmapTable.nTables;
        memcpy(pGlyphData->cmapTable.encodingTable,
               cmapTable.encodingTable,
               sizeof(cmapTable.encodingTable));
        bRet = TRUE;
    }
    else
    {
        ERR(("bCopyGlyphData!Unable to find table '%s'.\n", TABLECMAP));
        bRet = FALSE;
    }

    FTRC(Leaving bCopyGlyphData...);

    return bRet;
}


HGLYPH
hFindGlyphId(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usCharCode
    )
/*++

  Routine Description:

    Retrieves the glyph id from the cmap table given the character code for a
    glyph.

    Normally the TOSS/CATCH is for error handling.  However, in this routine
    some of the CATCH labels are for normal processing and have OK appended to
    them to demonstrate that it is not necessarily an error with they occur.

  Arguments:

    usCharCode -
    pPDev -

  Return Value:

    Glyph id if successful, else INVALID_GLYPH.

--*/
{
    int     iI;
    ULONG   ulOffset;
    BYTE   *pbTmp;
    USHORT  segCount;            // Number of segments in table
    USHORT  TTFileSegments;      // Number of segments actually parsed -
                                 // in case segCount is really large
    GLYPH_MAP_TABLE  mapTable;
    CMAP_TABLE       cmapTable;
    PIFIMETRICS      pIFIMet;
    PVOID            pTTFile;
    ULONG            ulTTFileLen;

    USHORT        *pGlyphIdArray;
    USHORT        *pRangeOffset;
    USHORT        startCode[MAX_SEGMENTS];
    USHORT        endCode[MAX_SEGMENTS];
    SHORT         idDelta[MAX_SEGMENTS];
    USHORT        idRangeOffset[MAX_SEGMENTS];
    USHORT        GlyphId;

    ULONG        ulTmp;
    int          iJ, iIndex = 0;
    USHORT       usMaxChar;
    BOOL         bFound = FALSE;
    FONTMAP_TTO *pPrivateFM;
    GLYPH_DATA  *pGlyphData;
    HGLYPH       hGlyph = INVALID_GLYPH;


    FTRC(Entering hFindGlyphId...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        pPrivateFM = GETPRIVATEFM(pFM);
        pGlyphData = (GLYPH_DATA*)pPrivateFM->pvGlyphData;
        ZeroMemory(&endCode, sizeof(endCode));

        pIFIMet = pFM->pIFIMet;
        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

        if (!pTTFile)
            TOSS(DataError);

        usMaxChar = 0xffff;

        //
        // The cmap table contains the Character to Glyph Index mapping table.
        //
        ulOffset = pGlyphData->offset;
        pbTmp = pTTFile;

        //
        // Get the encoding format based on the format id
        // Windows uses Platform ID 3
        // Encoding ID = 1 means format 4
        //
        cmapTable = pGlyphData->cmapTable;
        SWAB (cmapTable.nTables);
        for (iI = 0; iI < cmapTable.nTables; iI++)
        {
            SWAB (cmapTable.encodingTable[iI].PlatformID);
            SWAB (cmapTable.encodingTable[iI].EncodingID);
            if (cmapTable.encodingTable[iI].PlatformID == PLATFORM_MS)
            {
                switch ( cmapTable.encodingTable[iI].EncodingID)
                {
                    case SYMBOL_FONT:    // Symbol font
                        SWAL (cmapTable.encodingTable[iI].offset);
                        ulOffset += cmapTable.encodingTable[iI].offset;
                        bFound = TRUE;
                        break;
                    case UNICODE_FONT:    // Unicode font
                        SWAL (cmapTable.encodingTable[iI].offset);
                        ulOffset += cmapTable.encodingTable[iI].offset;
                        bFound = TRUE;
                        break;
                    default:   // error - can't handle
                        TOSS(GlyphNotFound);
                }
            }

        }
        if (!bFound)
            TOSS(GlyphNotFound);

        pbTmp += ulOffset;
        if (!PTR_IN_RANGE(pTTFile, ulTTFileLen, pbTmp))
            TOSS(DataError);

        memcpy (&ulTmp, pbTmp, sizeof (ULONG));
        ulTmp = (0x0000ff00 & ulTmp) >> 8;

        switch (ulTmp)
        {
            case 4:
                memcpy (&mapTable, pbTmp, sizeof (mapTable));
                SWAB (mapTable.SegCountx2 );
                segCount = mapTable.SegCountx2 / 2;
                TTFileSegments = segCount;

                if (segCount > MAX_SEGMENTS)
                    segCount = MAX_SEGMENTS;

                pbTmp += 7 * sizeof (USHORT);
                memcpy (&endCode, pbTmp, segCount*sizeof(USHORT));

                pbTmp += ((TTFileSegments +1) * sizeof (USHORT));
                memcpy (&startCode, pbTmp, segCount*sizeof(USHORT));

                pbTmp += (TTFileSegments * sizeof (USHORT));
                memcpy (&idDelta, pbTmp, segCount*sizeof(USHORT));

                pbTmp += (TTFileSegments * sizeof (USHORT));
                memcpy (&idRangeOffset, pbTmp, segCount*sizeof(USHORT));
                pRangeOffset = (USHORT*)pbTmp;

                pbTmp += (TTFileSegments * sizeof (USHORT));

                pGlyphIdArray = (USHORT*)pbTmp;

                for (iI = 0; iI < segCount-1; iI++)
                {
                    SWAB (startCode[iI]);
                    SWAB (endCode[iI]);
                }

                for (iI = 0; iI < segCount-1; iI++)
                {
                    SWAB (idDelta[iI]);
                    SWAB (idRangeOffset[iI]);
                    for (iJ = startCode[iI]; iJ <= endCode[iI]; iJ++)
                    {
                        if (iIndex < usMaxChar)
                        {
                            if (usCharCode == iJ)
                            {
                                if (idRangeOffset[iI] == 0)
                                {
                                    //if ((HGLYPH)(idDelta[iI] + iJ) == hglyph)
                                    hGlyph = (HGLYPH)(idDelta[iI] + iJ);
                                    TOSS(GlyphFoundOk);
                                }
                                else
                                {
                                    GlyphId =  *(pGlyphIdArray + (iJ - startCode[iI]) );
                                    SWAB (GlyphId);
                                    GlyphId += idDelta[iI];
                                    //if (GlyphId == hglyph)
                                    hGlyph = (HGLYPH)GlyphId;
                                    TOSS(GlyphFoundOk);
                                }
                            }
                            iIndex++;
                        }
                    }

                }

                break;
            default:
                TOSS(GlyphFoundOk);
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        hGlyph = INVALID_GLYPH;
    }
    CATCH(GlyphNotFound)
    {
        // Not found.  Return invalid glyph handle.
        hGlyph = INVALID_GLYPH;
    }
    CATCH(DataError)
    {
        // Not found.  Return invalid glyph handle.
        hGlyph = INVALID_GLYPH;
    }
    CATCH(GlyphFoundOk)
    {
        // Just a placeholder.  The glyph id is in hGlyph--to be returned.
    }
    ENDTRY;

    FTRC(Leaving hFindGlyphId...);

    return hGlyph;
}


LRESULT
IsFont2Byte(
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Returns whether or not this font should be output as a format 16 font.
    Put this logic here in case we decide to change it!

  Arguments:

    pPDev -

  Return Value:

    S_OK for format 16,
    S_FALSE for format 15.
    Otherwise E_UNEXPECTED.

--*/
{
    FONTMAP_TTO *pPrivateFM;
    DL_MAP *pDLMap;

    FTRC(Entering IsFont2Byte...);

    ASSERT_VALID_FONTMAP(pFM);

    if (NULL == (pPrivateFM = GETPRIVATEFM(pFM)))
    {
        return E_UNEXPECTED;
    }

    pDLMap = (DL_MAP*)pPrivateFM->pvDLData;
    ASSERTMSG(pDLMap, ("IsFont2Byte!pDLMap NULL\n"));

    if (NULL == pDLMap)
    {
        return E_UNEXPECTED;
    }

    FTRC(Leaving IsFont2Byte...);

#ifdef FORCE_TT_2_BYTE
    return S_OK;
#else
    if (NULL != pFM->pIFIMet && 
            ((IS_BIDICHARSET(pFM->pIFIMet->jWinCharSet)) ||
             (IS_DBCSCHARSET(pFM->pIFIMet->jWinCharSet))))
        return S_OK;
    else
    return DLMAP_FONTIS2BYTE(pDLMap)?S_OK:S_FALSE;
    // return (pDLMap->wLastDLGId > 0x00FF);
    // return (pDLMap->wFlags & DLM_UNBOUNDED) != 0;
#endif
    // return (pPDev->pUDPDev->fMode & PF_DLTT_ASTT_2BYTE) != 0;
}


BOOL
bPCL_SetFontID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Sends the PCL string to select the font specified by pFM
    The history of this process has been left for your amusement.

    The GPD contains a line something like this.
    *Command: CmdSetFontID { *Cmd : "<1B>*c" %d{NextFontID}"D" }

  Arguments:

    pPDev -
    pFM -

  Return Value:

    TRUE if successful else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;


    FTRC(Entering bPCL_SetFontID...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // 1: The good-old-fashoned way.
    //iCmdLen = iDrvPrintfA(szCmdStr, "\033*c%dD", pFM->ulDLIndex);
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_SetFontID!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return 0;

    // 2: The old-fashoned way.
    //WriteChannel(pPDev, CMD_SET_FONT_ID, pFM->ulDLIndex);

    // 3: The new way.
    BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));

    FTRC(Leaving bPCL_SetFontID...);

    return TRUE;
}


BOOL
bPCL_SendFontDCPT(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN DWORD dwDefinitionSize
    )
/*++

  Routine Description:

    Outputs PCL string that begins a font definition download.  This should follow
    a call to bPCL_SetFontID and be followed by the truetype header info etc.

    [ISSUE] Is there a GPD string for this command?

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    dwDefinitionSize - Num bytes in the font data to be sent.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;
    BOOL bRet = FALSE;

    FTRC(Entering bPCL_SendFontDCPT...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // 1: The old way
    // Send the font definition command
    //WriteChannel( pPDev, CMD_SEND_FONT_DCPT, dwTotalBytes );

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        iCmdLen = iDrvPrintfA(szCmdStr, "\033)s%dW", dwDefinitionSize);
        if (iCmdLen >= PCLSTRLEN)
            TOSS(InsufficientBuffer);

        if (!BWriteToSpoolBuf(pPDev, szCmdStr, iCmdLen))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(InsufficientBuffer)
    {
        ERR(("bPCL_SendFontDCPT!Insufficient buffer size.\n"));
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        ERR(("bPCL_SendFontDCPT!Write Error.\n"));
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

        FTRC(Leaving bPCL_SendFontDCPT...);

    return bRet;
}


BOOL
bPCL_SelectFontByID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Outputs PCL string that selects a font by font-id.  The font-id is passed in as
    pFM->ulDLIndex.

    The GPD contains a line like this:
    *Command: CmdSelectFontID { *Cmd : "<1B>(" %d{CurrentFontID}"X" }

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    pFM->ulDLIndex - id of font to select.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;


    FTRC(Entering bPCL_SelectFontByID...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    //iCmdLen = iDrvPrintfA(szCmdStr, "\033(%dX", pFM->ulDLIndex);
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_SelectFontByID!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return FALSE;

    BUpdateStandardVar(pPDev, pFM, 0, 0, STD_CFID);
    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTID));

        FTRC(Leaving bPCL_SelectFontByID...);

    return TRUE;
}


BOOL
bPCL_SelectPointSize(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN POINTL *pptl
    )
/*++

  Routine Description:

    This routine downloads the height or width of the font depending
    on whether it is a fixed-pitch or variable-pitch font.

    Variable Pitch: send down the font height command, "Esc(s#V", using
      pptl->y as POINT_SIZE * 100.

    Fixed Pitch: the font height command, "Esc(s#V", is ignored for
      fixed-pitch fonts (PCL Implementor's Guide, p9-19).  Send down
      the Font Pitch command, "Esc(s#H", instead.  Use the pptl->x as
      CPI * 100.

    [ISSUE] Although there are GPD commands, CmdSelectFontHeight and
    CmdSelectFontWidth, and the standard variables, STD_FW and STD_FH,
    there are two problems with the GPD solution.
    1) BUpdateStandardVariable doesn't use any parameters when calculating
       the PDEV::dwFontWidth or PDEV::dwFontHeight values.  That isn't what
       I want.  I want to pass in pptl->x / 100 or pptl->y / 100.
    2) The GPD commands CMD_SELECTFONTHEIGHT/WIDTH, which evaluate to
       CmdSelectFontHeight/Width in the GPD file, are evaluating to NULL in
       the CMDPOINTER() macro even though I've added the entries to my GPD
       file.
    I have use the COMMENTEDOUT macro to omit the non-working code for now.

  Arguments:

    pPDev - pointer to PDEV
    pptl->x - Width of glyph expressed as CPI * 100
    pptl->y - Heigt of glyph expressed in points * 100
    pfm - Current font

  Return Value:

    TRUE/FALSE,   TRUE for success.

--*/
{
// #define USE_GPD_HEIGHTWIDTH 1

#ifndef USE_GPD_HEIGHTWIDTH
    PCLSTRING szCmd;
    INTSTRING szValue;
    int iLen;
#endif
    BOOL bRet = FALSE;


    FTRC(Entering bPCL_SelectPointSize...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(pptl, ("bPCL_SelectPointSize!pptl NULL.\n"));

    TRY
    {
        BYTE fontPitch = (pFM->pIFIMet->jWinPitchAndFamily & 0x03);

        if (!VALID_PDEV(pPDev) || !pptl)
            TOSS(ParameterError);

        if (fontPitch == FIXED_PITCH)
        {
#ifdef USE_GPD_HEIGHTWIDTH
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_FW);
            if (WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTWIDTH)) == NOOCD)
                TOSS(WriteError);
#else
            iLen = IFont100toStr (szValue, pptl->x);
            if (iLen <= 0 || iLen >= INTSTRLEN)
                TOSS(DataError);

            // IFont100toStr does not NULL terminate.
            szValue[iLen] = '\0';

            // Note: can't call sprintf and iDrvPrintfA doesn't support %s.
            // Intention: sprintf(szCmd, "\033(s%sH", szValue);
            szCmd[0] = '\0';
            strcat(szCmd, "\033(s");
            strcat(szCmd, szValue);
            strcat(szCmd, "H");

            if (!BWriteStrToSpoolBuf(pPDev, szCmd))
                TOSS(WriteError);
#endif
        }
        else if (fontPitch == VARIABLE_PITCH)
        {
#ifdef USE_GPD_HEIGHTWIDTH
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_FH);
            if (WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTHEIGHT)) == NOOCD)
                TOSS(WriteError);
#else
            iLen = IFont100toStr (szValue, pptl->y);
            if (iLen <= 0 || iLen >= INTSTRLEN)
                TOSS(DataError);

            // IFont100toStr does not NULL terminate.
            szValue[iLen] = '\0';

            // Note: can't call sprintf and iDrvPrintfA doesn't support %s.
            // Intention: sprintf(szCmd, "\033(s%sV", szValue);
            szCmd[0] = '\0';
            strcat(szCmd, "\033(s");
            strcat(szCmd, szValue);
            strcat(szCmd, "V");

            if (!BWriteStrToSpoolBuf(pPDev, szCmd))
                TOSS(WriteError);
#endif
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
#ifndef USE_GPD_HEIGHTWIDTH
    CATCH(DataError)
    {
        bRet = FALSE;
    }
#endif
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bPCL_SelectPointSize...);

    return bRet;
}

BOOL
bPCL_DeselectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Outputs PCL string that deselects a font.  This routine really doesn't do
    much since PCL doesn't have the notion of deselecting fonts.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;


    FTRC(Entering bPCL_DeselectFont...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // I don't think PCL has the notion of "deselection"
    //iCmdLen = iDrvPrintfA(szCmdStr, "");
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_DeselectFont!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return FALSE;

    //BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
    //WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTID));

        FTRC(Leaving bPCL_DeselectFont...);

    return TRUE;
}


BOOL
bPCL_SetParseMode(
    PDEV *pPDev,
    PFONTMAP pFM
    )
/*++

  Routine Description:

    Outputs PCL string to set the PCL parsing mode.  The logical choices
    for this are mode 0 (default) and 21 (two-byte with 0x2100 offset).  The desired
    mode is passed in with pFM.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    pFM->dwCurrentTextParseMode - desired parsing mode

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;
    FONTMAP_TTO *pPrivateFM;
    BOOL bRet = FALSE;


    FTRC(Entering bPCL_SetParseMode...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    pPrivateFM = GETPRIVATEFM(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM) || (pPrivateFM == NULL))
            TOSS(ParameterError);

        iCmdLen = iDrvPrintfA(szCmdStr, "\033&t%dP", pPrivateFM->dwCurrentTextParseMode);
        if (iCmdLen >= PCLSTRLEN)
            TOSS(InsufficientBuffer);

        if (!BWriteToSpoolBuf(pPDev, szCmdStr, iCmdLen))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(InsufficientBuffer)
    {
        ERR(("bPCL_SetParseMode!Insufficient buffer size.\n"));
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

        FTRC(Leaving bPCL_SetParseMode...);

    return bRet;
}


BOOL
bPCL_SetCharCode(
    PDEV *pPDev,
    PFONTMAP pFM,
    USHORT usCharCode
    )
/*++

  Routine Description:

    Outputs PCL string to specify the character code for the next downloaded
    character.  This should be followed by the characters glyph definition.

    The GPD will contain something like this:
    *Command: CmdSetCharCode { *Cmd : "<1B>*c" %d{NextGlyph}"E" }

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    usCharCode - Designated download-id for the character.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;

        FTRC(Entering bPCL_SetCharCode...);

    // WriteChannel( pPDev, CMD_SET_CHAR_CODE, usCharCode );

    // CMD_SET_CHAR_CODE, usCharCode
    //iCmdLen = iDrvPrintfA(szCmdStr, "\033*c%dE", usCharCode);
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_SetCharCode!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return FALSE;

    BUpdateStandardVar(pPDev, pFM, usCharCode, 0, STD_GL);
    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETCHARCODE));

        FTRC(Leaving bPCL_SetCharCode...);

    return TRUE;
}


BOOL
bPCL_SendCharDCPT(
    PDEV *pPDev,
    PFONTMAP pFM,
    DWORD dwSend
    )
/*++

  Routine Description:

    Outputs PCL string to begin the downloading of a character's glyph info.
    This should be followed immediately by the glyph data.

    Want: WriteChannel( pPDev, CMD_SEND_CHAR_DCPT, dwSend );

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    dwSend - the number of bytes in the glyph data to follow.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;
    BOOL bRet = FALSE;


        FTRC(Entering bPCL_SendCharDCPT...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        iCmdLen = iDrvPrintfA(szCmdStr, "\033(s%dW", dwSend);
        if (iCmdLen >= PCLSTRLEN)
            TOSS(InsufficientBuffer);

        if (!BWriteToSpoolBuf(pPDev, szCmdStr, iCmdLen))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(InsufficientBuffer)
    {
        ERR(("bPCL_SendCharDCPT!Insufficient buffer size.\n"));
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

        FTRC(Leaving bPCL_SendCharDCPT...);

    return bRet;
}

PVOID
pvGetTrueTypeFontFile(
    PDEV *pPDev,
    ULONG *pulSize
    )
/*++

  Routine Description:

    Retrieves the pointer to the truetype file.  The pointer may be cached
    in the pFontPDev, or returned from FONTOBJ_pvTrueTypeFontFile.

    Should I/Can I use VirtualProtect?
    VirtualProtect(pFontPDev->pTTFile, ulFile, PAGE_READONLY, &oldProtect);

  Arguments:

    pPDev - Pointer to PDEV structure.
    pulSize - Pointer to size variable, if NULL this is ignored

  Return Value:

    Pointer to the truetype file.

--*/
{
    PFONTPDEV pFontPDev;
    PVOID     pTTFile;

    ASSERT(VALID_PDEV(pPDev));

    pFontPDev = GETFONTPDEV(pPDev);
    if (pFontPDev)
    {
        if ( pFontPDev->pTTFile == NULL)
        {
            //
            // Get the pointer to memory mapped TrueType font from GDI.
            //
            TO_DATA *pTod;
            ULONG ulFile;
            DWORD oldProtect;
            pTod = (TO_DATA *)pFontPDev->ptod;
            ASSERTMSG(pTod, ("Null TO_DATA.\n"));

            pTTFile = pFontPDev->pTTFile
                    = FONTOBJ_pvTrueTypeFontFile(pTod->pfo, &ulFile);
            pFontPDev->pcjTTFile = ulFile;
        }
        else
        {
            //
            // Get the pointer from font pdev.
            //
            pTTFile = pFontPDev->pTTFile;
        }

        if (pulSize)
            *pulSize = pFontPDev->pcjTTFile;
    }
    else
    {
        pTTFile = NULL;
        if (NULL != pulSize)
        {
            *pulSize = 0;
        }
    }

    return pTTFile;
}

//
// DCR: This function is a workaround for WritePrinter Failure, which happens
// because  of a bug in spooler which treates TT memory mapped file pointers to
// be user mode memory. Onece this is fix in spooler, we will disable this code.
//
#define MAX_SPOOL_BYTES 2048
INT TTWriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    )
{
    INT iTotalBytesWritten = 0;

    while (iCount)
    {
        INT iBytesToWrite = min(iCount, MAX_SPOOL_BYTES);
        INT iBytesWritten = WriteSpoolBuf(pPDev, pbBuf, iBytesToWrite);
        if (iBytesToWrite != iBytesWritten)
            break;

        iTotalBytesWritten += iBytesWritten;
        pbBuf += iBytesWritten;
        iCount -= iBytesWritten;
    }
    return iTotalBytesWritten;
}

BOOL BIsExemptedFont(
    PDEV       *pPDev,
    IFIMETRICS *pIFI
)
/*++

  Routine Description:

    Determines whether the given font is one of the unhandled fonts.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pIFI - Pointer to ifimetrics structure

  Return Value:

    TRUE if the font is an unhandled font else FALSE.

--*/
{
    int i;
    char szFontName[LEN_FONTNAME+1];
    BOOL bRet = FALSE;

    ASSERT(VALID_PDEV(pPDev));

    vGetFontName(pPDev, pIFI, szFontName);

    TRY
    {
        char *pszRegExemptedFont;

        if (strlen(szFontName) == 0)
            TOSS(BlankFontName);
        //
        // Make it lower case.
        //
        _strlwr(szFontName);

        for (i = 0; i < nExemptedFonts; i++)
        {
            //
            // Search the exemptedfont name in current font. we search for
            // subtring only. So if "courier new" is exempted then we don't
            // download any font that contains "courier new" string. This will
            // cause "Courier New Bold" to be not downloaded as TT outline.
            //
            if (strstr(szFontName, aszExemptedFonts[i]))
            {
                bRet = TRUE;
                break;
            }
        }

#ifdef COMMENTEDOUT
        //
        // When the registry entry is passed in then
        // pszRegExemptedFont should be set to that value instead
        // of the test value.Note For registry we test exact match
        // of font name.
        //
        for (pszRegExemptedFont = "One\0Two\0Three\0";
             *pszRegExemptedFont;
             pszRegExemptedFont += (strlen(pszRegExemptedFont) + 1))
        {
            if (strcmp(szFontName, pszRegExemptedFont) == 0)
            {
                bRet = TRUE;
                break;
            }
        }
#endif
    }
    CATCH(BlankFontName)
    {
        //
        // The name was blank so it can't match one of the exempted fonts,
        // but I'm not happy about that.
        //
        bRet = FALSE;
    }
    ENDTRY;

    return bRet;
}

BOOL BIsPDFType1Font(
    IFIMETRICS  *pIFI)
/*++

  Routine Description:

    Helper function to determine if the font is TrueType font converted from
    Type1 font by PDF writer.

  Arguments:

    pIFI - a pointer to IFIMETRICS.

  Return Value:

    TRUE if the font of the IFIMETRICS is a TrueType font converted from Type1.

--*/
{
    const WCHAR szPDFType1[] = L".tmp";
    WCHAR *szFontName;

    if (NULL == pIFI)
    {
        //
        // Error return. Disable TrueType font downloading.
        //
        TRUE;
    }
    szFontName = (WCHAR*)((PBYTE)pIFI+pIFI->dpwszFamilyName);

    if (wcsstr(szFontName, szPDFType1))
        return TRUE;
    else
        return FALSE;
}

BOOL BWriteStrToSpoolBuf(
    IN PDEV *pPDev,
    IN char *szStr
)
/*++

  Routine Description:

    Helper function to write null-terminated strings to the printer.

  Arguments:

    pPDev - Pointer to PDEV structure.
    szStr - Pointer to null-terminated string

  Return Value:

    TRUE if the string was successfully written, else FALSE

--*/
{
    LONG iLen = 0;

    if (!pPDev || !szStr)
        return FALSE;

    iLen = strlen(szStr);
    return BWriteToSpoolBuf(pPDev, szStr, iLen);
}

#ifdef COMMENTEDOUT
int TTstricmp(const char *str1, const char *str2)
{
    int diff = 0;
    while (*str1 && *str2)
    {
        diff += toupper(*str1) - toupper(*str2);
        if (*str1) str1++;
        if (*str2) str2++;
    }
    return diff;
}
#endif

#ifdef KLUDGE
#undef ZeroMemory
#define ZeroMemory(pb, cb) memset((pb),0,(cb))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\common.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

    This file contain information and function prototypes for helper
    library functions provided by the Control module

Environment:

        Windows NT Unidrv driver

Revision History:

    10/12/96 -amandan-
        Created

    dd-mm-yy -author-
         description

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#ifdef __cplusplus
extern "C" {
#endif


#include "ddint5.h"

INT
WriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    );


VOID  WriteAbortBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount,
    DWORD       dwWait
    );


BOOL
FlushSpoolBuf(
    PDEV    *pPDev
    );

INT
WriteChannel(
    PDEV    *pPDev,
    COMMAND *pCmd
    );

INT
WriteChannelEx(
    PDEV    *pPDev,
    COMMAND *pCmd,
    INT     iRequestedValue,
    INT     iDeviceScaleFac
    );


VOID
SetRop3(
    PDEV    *pPDev,
    DWORD   dwRop3
    );


INT
XMoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlags
    );

INT
YMoveTo(
    PDEV    *pPDev,
    INT     iYIn,
    INT     fFlags
    );

BOOL
BIntersectRect(
    OUT PRECTL   prcDest,
    IN  PRECTL   prcRect1,
    IN  PRECTL   prcRect2
    );

BOOL
bIsRegionWhite (
        SURFOBJ *,
        RECTL *
        );

VOID
CheckBitmapSurface(
        SURFOBJ *,
        RECTL *
        );

ULONG
DrawPatternRect(
        PDEV *,
        PDRAWPATRECT
        );
/*
 *   Flags to use when calling the [XY]Moveto functions.
 *
 *  MV_UPDATE  is used when it is desired to change our record of where
 *      the cursor is now located.  Typically this will happen after some
 *      operation such as printing a glyph, or sending graphics.
 *
 *  MV_RELATIVE  means add the value passed to the current position.  This
 *      would be used after printing a glyph,  and passing in the glyph
 *      width as parameter,  rather than calculating the new position.
 *
 *  MV_GRAPHICS  indicates that the value is in GRAPHICS RESOLUTION units.
 *      Otherwise MASTER UNITS are assumed.  If set,  the value will be
 *      converted to master units before processing.  Typically used to
 *      pass information when sending scan lines of graphics data.
 *
 *  MV_PHYSICAL  is used to indicate that the value passed in is relative
 *      to the printers print origin,  and not the printable area,  which
 *      is the case otherwise.  Typically this flag would be used to
 *      allow setting the position to the printer's X = 0 position after
 *      sending a <CR>.
 *
 *  MV_FINE  requests sending graphics data (nulls) to position the cursor
 *      to finer position than can otherwise be achieved.  Typically
 *      only available in the direction of movement of the head on a
 *      dot matrix printer.  This command may be ignored.  It must not
 *      be issued for a LaserJet,  since it will cause all sorts of other
 *      problems.
 */

//
// 4/7/97 Zhanw
// the first 4 constants are defined in "printoem.h" since we now export
// XMoveTo and YMoveTo to OEM DLL's
//

//#define MV_UPDATE       0x0001
//#define MV_RELATIVE     0x0002
//#define MV_GRAPHICS     0x0004
//#define MV_PHYSICAL     0x0008

//
// Internal use only!!! update warning in oak\inc\printoem.h
// whenever new flags are added.
//
#define MV_FORCE_CR         0x4000
#define MV_FINE             0x8000

BOOL
BSelectProgrammableBrushColor(
    PDEV   *pPDev,
    ULONG   Color
    );

VOID
VResetProgrammableBrushColor(
    PDEV   *pPDev
    );

DWORD
BestMatchDeviceColor(
    PDEV    *pPDev,
    DWORD   Color
    );

BYTE
BGetMask(
    PDEV *  pPDev,
    RECTL * pRect
    );
BOOL
BGetStandardVariable(
    PDEV    *pPDev,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );
DWORD
ConvertRGBToGrey(
    DWORD   Color
    );

BOOL
BGetGPDData(
    PDEV    *pPDev,
    DWORD       dwType,     // Type of the data
    PVOID         pInputData,   // reserved. Should be set to 0
    PVOID          pBuffer,     // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    ) ;


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\fd_glyph.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fd_glyhph.h

Abstract:

    Stock FD_GLYPHSET data definitions.

Environment:

    Windows NT printer drivers

Revision History:

    01/21/96 -eigos-
        Created it.

--*/

#ifndef _FD_GLYPH_H_
#define _FD_GLYPH_H_


//
// Stock FD_GLYPHSET id
//

#define STOCK_GLYPHSET_932       0  // Japan
#define STOCK_GLYPHSET_936       1  // Chinese (PRC, Singapore)
#define STOCK_GLYPHSET_949       2  // Korean
#define STOCK_GLYPHSET_950       3  // Chinese (Taiwan, Hong Kong)

#define MAX_STOCK_GLYPHSET       4

//
// Codepage macros
//

#define CP_SHIFTJIS_932        932
#define CP_GB2312_936          936
#define CP_WANSUNG_949         949
#define CP_CHINESEBIG5_950     950

//
// Predefined GTT Resource ID
//

#define GTT_CC_CP437              1
#define GTT_CC_CP850              2
#define GTT_CC_CP863              3
#define GTT_CC_CBIG5              10
#define GTT_CC_ISC                11
#define GTT_CC_JIS                12
#define GTT_CC_JIS_ANK            13
#define GTT_CC_NS86               14
#define GTT_CC_TCA                15
#define GTT_CC_GB2312             16
#define GTT_CC_WANSUNG            17

#endif // _FD_GLYPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\font\qfontree.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qfontree.c

Abstract:

    Routines Generates the trees required by the engine.  There are three
    tree types defined,  UNICODE (handle <-> glyph), ligatures and kerning
    pairs.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

--*/

#include "font.h"


//
//
// Functions
//
//

PVOID
FMQueryFontTree(
    PDEV    *pPDev,
    ULONG_PTR iFile,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    )
/*++

Routine Description:
    Returns tree structured data describing the mapping between UNICODE
    and printer glyphs,  or ligature information or kerning pair data.


Arguments:

    pPDev           Pointer to PDEV
    iFile           Not Used.
    iFace           Font about which information is desired
    iMode           Type of information requested
    pid             Our field: fill as needed for recognition

Return Value:

    A pointer to the relevant structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{

    /*
     *  Processing differs dramatically,  depending upon iMode.  We will
     *  always handle the QFT_GLYPHSET case,  the others we may not have
     *  any information about.
     */


    void   *pvRet;                      /* Return value */


    UNREFERENCED_PARAMETER(iFile);

    if( PFDV->dwSignature != FONTPDEV_ID )
    {
        ERR(( "UniFont!FMQueryFontTree: Invalid FONTPDEV\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );

        return  NULL;
    }

    if( iFace < 1 || (int)iFace >  pPDev->iFonts )
    {
        ERR(( "UniFont!FMQueryFontTree:  Illegal value for iFace (%ld)", iFace ));

        SetLastError( ERROR_INVALID_PARAMETER );

        return  NULL;
    }

    pvRet = NULL;                       /* Default return value: error */

    /*
     *   The pid field is one which allows us to put identification data in
     *  the font information, and which we can use later in DrvFree().
     */

    *pid = 0;


    switch( iMode )
    {

    case QFT_GLYPHSET:          /* RLE style UNICODE -> glyph handle mapping */
        pvRet = PVGetUCGlyphSetData( pPDev, iFace );
        break;


    case  QFT_LIGATURES:        /* Ligature variant information */
        SetLastError( ERROR_NO_DATA );
        break;

    case  QFT_KERNPAIRS:        /* Kerning information */
        pvRet = PVGetUCKernPairData( pPDev, iFace );
        break;

    default:
        ERR(( "Rasdd!DrvQueryFontTree: iMode = %ld - illegal value\n", iMode ));
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    return  pvRet;

}



VOID  *
PVGetUCGlyphSetData(
    PDEV   *pPDev,
    UINT    iFace
    )
/*++

Routine Description:
    Generates the array of WCRUN data used as a mapping between UNICODE and
    our internal representation.

Arguments:

    pPDev           Pointer to PDEV
    iFace           Font about which information is desired

Return Value:

    A pointer to the array of WCRUN structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{
    FONTMAP     *pFM;             /* Details of the particular font */
    FONTMAP_DEV *pFMDev;
    VOID        *pvData = NULL;

    if (pFM = PfmGetDevicePFM( pPDev, iFace ) )
    {
        pFMDev = pFM->pSubFM;

        if (!pFMDev->pUCTree)  //No FD_GLYPHSET data for this font.
        {
            if( pFM->flFlags & FM_GLYVER40 )    //NT 4.0 RLE
                pvData = PVGetUCRLE(pPDev, pFM);
            else                                // New stuff
                pvData = PVGetUCFD_GLYPHSET(pPDev, pFM);

        }
        else
            pvData = pFMDev->pUCTree;
    }

    // VDBGDUMPUCGLYPHDATA(pFM);

    return pvData;
}

VOID  *
PVGetUCKernPairData(
    PDEV   *pPDev,
    UINT    iFace
    )
/*++

Routine Description:
    Generates the array of FD_KERNPAIR data for the given font.

Arguments:

    pPDev           Pointer to PDEV
    iFace           Font about which information is desired

Return Value:

    A pointer to the array of WCRUN structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{
    FONTMAP     *pFM;             /* Details of the particular font */
    FONTMAP_DEV *pFMDev;
    VOID        *pvData = NULL;

    if (pFM = PfmGetDevicePFM( pPDev, iFace ) )
    {
        pFMDev = pFM->pSubFM;

        if (!pFMDev->pUCKernTree)  //No FD_GLYPHSET data for this font.
        {
            /* pvUCKernPair should allocate the appropriate buffer, if
             * necessary and store the value in FONTMAP, pFM->pUCKernTree.
             */

            if( pFM->flFlags & FM_GLYVER40 )    //NT 4.0 RLE
            {
                SetLastError( ERROR_NO_DATA );
            }
            else
                pvData = PVUCKernPair(pPDev, pFM);

        }
        else
            pvData = pFMDev->pUCKernTree;
    }

    return pvData;

}

VOID  *
PVGetUCRLE(
    PDEV      *pPDev,
    FONTMAP   *pFM
    )
/*++

Routine Description:
    Generates the array of WCRUN data used as a mapping between
    UNICODE and our internal representation.  The format of this
    data is explained in the DDI,  but basically for each group of
    glyphs we support,  we provide starting glyph and count info.
    There is an overall structure to define the number and location
    of each of the run data.

Arguments:

    pPDev           Pointer to PDEV.
    pFM             FONTMAP struct of the Font about for which information is
                    desired.

Return Value:

    A pointer to the array of WCRUN structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{
    /*
     *    Basically all we need do is allocate storage for the FD_GLYPHSET
     *  structure we will return.  Then the WCRUN entries in this need
     *  to have the offsets (contained in the resource format data) changed
     *  to addresses,  and we are done.  One minor point is to amend the
     *  WCRUN data to only point to glyphs actually available with this
     *  font.  This means limiting the lower and upper bounds as
     *  determined by the IFIMETRICS.
     */


    INT         cbReq;           /* Bytes to allocate for tables */
    INT         cRuns;           /* Number of runs we discover */
    INT         iI;              /* Loop index */
    INT         iStart, iStop;   /* First and last WCRUNs to use */
    INT         iDiff;           /* For range limiting operations */
    FD_GLYPHSET *pGLSet;       /* Base of returned data */
    IFIMETRICS  *pIFI;          /* For convenience */
    NT_RLE      *pntrle;        /* RLE style data already available */
    WCRUN       *pwcr;
    FONTMAP_DEV *pFMDev;

    #if DBG
    PWSTR pwszFaceName;
    #endif

    pIFI   = pFM->pIFIMet;
    pFMDev = pFM->pSubFM;

    #if DBG
    pwszFaceName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName  );
    #endif

    TRACE(\nUniFont!PVGetUCRLE:START);
    PRINTVAL(pwszFaceName, %ws);
    PRINTVAL((pFM->flFlags & FM_GLYVER40), 0X%x);

    /*
     *    Start working on memory requirements.  First generate the bit
     *  array of available glyphs.  In the process,  count the number
     *  of glyphs too!  This tells us how much storage will be needed
     *  just for the glyph handles.
     */

    cRuns = 0;                  /* Count number of runs */

    pntrle = pFMDev->pvNTGlyph;         /* Translation table */

    if( !pntrle )
    {
        ERR(( "!!!UniFont!PVGetUCRLE:( NULL Glyph Translation Data, pwszFaceName = %s )\n",pwszFaceName ));
        TRACE(UniFont!PVGetUCRLE:END\n);
        return   NULL;          /* Should not happen */
    }

    /*
     *    The hard part is deciding whether to trim the number of glyph
     *  handles returned due to limitiations of the font metrics.
     */

    cRuns = pntrle->fdg.cRuns;        /* Max number of runs */
    iStart = 0;
    iStop = cRuns;

    /*
     *   Look to see if the first glyph in the font is higher than the lowest
     *  in the RLE data.  If so, we need to amend the lower limit.
     */


    if( pFM->wFirstChar > pntrle->wchFirst )
    {
        /*  Need to amend the lower end  */

        pwcr = &pntrle->fdg.awcrun[ iStart ];

        for( ; iStart < iStop; ++iStart, ++pwcr )
        {
            if( pFM->wFirstChar < (pwcr->wcLow + pwcr->cGlyphs) )
                break;

        }
    }


    if( pFM->wLastChar < pntrle->wchLast )
    {
        /*  The top end goes too far!  */

        pwcr = &pntrle->fdg.awcrun[ iStop - 1 ];

        for( ; iStop > iStart; --iStop, --pwcr )
        {
            if( pFM->wLastChar >= pwcr->wcLow )
                break;

        }
    }

    /*   Now have a new count of runs (sometimes, anyway)  */
    cRuns = iStop - iStart;


    if( cRuns == 0 )
    {
        /*  SHOULD NEVER HAPPEN! */
        cRuns = 1;
        ERR(( "UniFont!DrvQueryFontTree: cRuns == 0, pwszFaceName = %s\n", pwszFaceName ));
    }


    /*
     *   Allocate the storage required for the header.  Note that the
     *  FD_GLYPHSET structure contains 1 WCRUN,  so we reduce the number
     *  required by one.
     */

    cbReq = sizeof( FD_GLYPHSET ) + (cRuns - 1) * sizeof( WCRUN );

    pFMDev->pUCTree = (void *)MemAllocZ(cbReq );

    if( pFMDev->pUCTree == NULL )
    {
        /*  Tough - give up now */
        ERR(( "!!!UniFont!PVGetUCRLE:( MemAlloc Failed for pUCTree \n"));
        TRACE(UniFont!PVGetUCRLE:END\n);

        return  NULL;
    }
    pGLSet = pFMDev->pUCTree;
    CopyMemory( pGLSet, &pntrle->fdg, sizeof( FD_GLYPHSET ) );

    /*
     *     Copy the WCRUN data as appropriate.  Some of those in the
     *  resource may be dropped at this time,  depending upon the range
     *  of glyphs in the font.  It is also time to convert the offsets
     *  stored in the phg field to an address.
     */

    pwcr = &pntrle->fdg.awcrun[ iStart ];
    pGLSet->cGlyphsSupported = 0;             /* Add them up as we go! */
    pGLSet->cRuns = cRuns;

    for( iI = 0; iI < cRuns; ++iI, ++pwcr )
    {
        pGLSet->awcrun[ iI ].wcLow = pwcr->wcLow;
        pGLSet->awcrun[ iI ].cGlyphs = pwcr->cGlyphs;
        pGLSet->cGlyphsSupported += pwcr->cGlyphs;
        pGLSet->awcrun[ iI ].phg = (HGLYPH *)((BYTE *)pntrle + (ULONG_PTR)pwcr->phg);
    }

    /*  Do the first and last entries need modifying??  */
    if( (iDiff = (UINT)pGLSet->awcrun[0].wcLow - (UINT)pFM->wFirstChar) > 0 )
    {
        /*   The first is not the first,  so adjust values  */


        pGLSet->awcrun[ 0 ].wcLow += (WORD)iDiff;
        pGLSet->awcrun[ 0 ].cGlyphs -= (WORD)iDiff;
        pGLSet->awcrun[ 0 ].phg += (ULONG_PTR)iDiff;

        pGLSet->cGlyphsSupported -= iDiff;
    }


    if( (iDiff = (UINT)pGLSet->awcrun[ cRuns - 1 ].wcLow +
                 (UINT)pGLSet->awcrun[ cRuns - 1 ].cGlyphs - 1 -
                 (UINT)pFM->wLastChar) > 0 )
    {
         /*  Need to limit the top one too!  */


         pGLSet->awcrun[ cRuns - 1 ].cGlyphs -= (WORD)iDiff;

         pGLSet->cGlyphsSupported -= (ULONG)iDiff;

    }

    TRACE(UniFont!PVGetUCRLE:END\n);
    return   pFMDev->pUCTree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\fmnewfm.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmnewfm.h

Abstract:

    Universal printer driver specific font metrics resource header

Environment:

    Windows NT printer drivers

Revision History:

    10/30/96 -eigos-
        Created it.

--*/

#ifndef _FMNEWFM_H_
#define _FMNEWFM_H_

//
// NOTE: To include this header file, it is necessary to include
//       parser.h which has a definition of INVOCATION structure,
//       winddi.h which has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData;
    short   sShift;
    INVOCATION SelectFont;
    INVOCATION UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font.
// All the measurements are given in the specified units,
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table.
// This width table is a continuous GLYPHHANDLE base,
// not Unicode nor codepage/character code base.
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width
// for a single glyph. The first width corresponds to glyph index wStartGlyph
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;

#endif //_FMNEWFM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\fmoldrle.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmoldrle.h

Abstract:

    NT4.0 RASDD RLE resource header

Environment:

    Windows NT printer drivers

Revision History:

    11/08/96 -eigos-
        Created it.

--*/

#ifndef _FMOLDRLE_H_
#define _FMOLDRLE_H_

//
//   The following structure represents the layout of this data in the
//  resource.  References to addresses are actually stored as offsets.
//  Basically this is a small amount of header data coupled with the
//  standard GDI  FD_GLYPHSET structures.   These latter require a little
//  manipulation before being returned to GDISRV.
//
//  POINTS OF INTEREST:
//    The first 4 bytes of this structure match the Win 3.1 CTT layout.
//  The reason for this is to allow us to verify that we have an NT
//  format structure, rather than a Win 3.1 layout.  This is also helped
//  by using a different range for the wType field.  As well,  the
//  CTT chFirstChar and chLastChar fields are set to have chLastChar <
//  chFirstChar,  which must not happen with Win 3.1.
//
//  The FD_GLYPHSET structure contains POINTERS.  These are stored in
//  the resource as offsets to the beginning of the resource,  and will
//  need to be translated at run time.  When this resource is passed
//  to GDISRV,  the FD_GLYPHSET information will be allocated from the
//  heap,  and all pointers will have the offsets converted to real
//  addresses.  That way we manage to keep the resource data as a resource,
//  but we pass addresses to GDISRV.
//

#define RLE_MAGIC0    0xfe
#define RLE_MAGIC1    0x78

typedef  struct
{
    WORD   wType;             /* Format of data */
    BYTE   bMagic0;           /* chFirstChar in CTT data */
    BYTE   bMagic1;           /* chLastChar in CTT data */
    DWORD  cjThis;            /* Number of bytes in this resource */
    WORD   wchFirst;          /* First glyph index */
    WORD   wchLast;           /* Last glyph index */
    FD_GLYPHSET  fdg;         /* The actual GDI desired information  */
}  NT_RLE;

//
//
//
typedef struct
{
    WCHAR   wcLow;
    USHORT  cGlyphs;
    DWORD   dwOffset_phg;
} WCRUN_res;

typedef struct
{
    WORD  wType;
    BYTE  bMagic0;
    BYTE  bMagic1;
    DWORD cjThis;

    WORD  wchFirst;
    WORD  wchLast;

    //
    // FD_GLYPHSET
    //
    ULONG fdg_cjThis;

    FLONG fdg_flAccel;

    ULONG fdg_cGlyphSupported;
    ULONG fdg_cRuns;
    WCRUN_res fdg_wcrun_awcrun[1];
} NT_RLE_res;

//
//    Values for the wType field above.  These control the interpretation
//  of the contents of the HGLYPH fields in the FD_GLYPHSET structure.
//
//  This is a data how many RLE file has each type of CTT.
//  Type          Number
//  RLE_DIRECT    67
//  RLE_PAIRED    40
//  RLE_L_OFFSET  0
//  RLE_LI_OFFSET 73
//  RLE_OFFSET    0
//


#define RLE_DIRECT    10     /*  Index + 1 or 2 data bytes */
#define RLE_PAIRED    11     /*  Index plus 2 bytes,  overstruck */
#define RLE_L_OFFSET  12     /*  Length + 3 byte offset to data */
#define RLE_LI_OFFSET 13     /*  Length + Index + 2 byte Offset */
#define RLE_OFFSET    14     /*  Offset to (length; data) */

//
//   Note that for RLE_DIRECT and RLE_PAIRED,  each HGLYPH consists of
//  2 WORDS:  the low WORD is the byte/bytes to send to the printer, the
//  high WORD is the linear index of this glyph.  Linear index starts at
//  0 for the first, and increments by one for every glyph in the font.
//  It is used to access width tables.
//
//    For RLE_L_OFFSET,  the high byte is the length of data to send to
//  the printer,  the low 24 bits are the offset (relative to start of
//  resource data) to the data,  which is WORD aligned,  and contains
//  a WORD with the index followed by the data.  The length byte does NOT
//  include the index WORD.
//
//     For RLE_LI_OFFSET,  the high byte contains a length, the next
//  lower byte contains a length,  and the bottom WORD contains the
//  offset to the actual data in the file.
//

typedef  struct
{
    BYTE   b0;         /* First (only) data byte to send to printer */
    BYTE   b1;         /* Second byte: may be null,  may be overstruck */
    WORD   wIndex;     /* Index to width tables */
} RD;                  /* Layout for RLE_DIRECT,  RLE_PAIRED */


typedef  struct
{
    WORD    wOffset;   /* Offset to (length, data) in resource */
    BYTE    bIndex;    /* Index to width tables */
    BYTE    bLength;   /* Length of data item */
} RLI;                  /* Layout for RLE_LI_OFFSET  */


typedef  struct
{
    BYTE   b0;      /* First (only) data byte */
    BYTE   b1;      /* Optional second byte */
    BYTE   bIndex;  /* Index to width tables */
    BYTE   bLength; /* Length byte */
} RLIC;                 /* Compact format for RLI - no offset */


typedef  union
{
    RD      rd;     /* Direct/overprint format */
    RLI     rli;    /* Short offset format: 3 byte offset + 1 byte length */
    RLIC    rlic;   /* The data format for 1 or 2 byte entries */
    HGLYPH  hg;     /* Data as an HGLYPH */
}  UHG;

#endif // _FMOLDRLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\fontif.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fontif.h

Abstract:

    Interface between Control module and Font module

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _FONTIF_H_
#define _FONTIF_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
FMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO *pGDIInfo
    );

typedef struct _FMPROCS {

    BOOL
    (*FMStartDoc) (
        SURFOBJ *pso,
        PWSTR   pDocName,
        DWORD   jobId
        );

    BOOL
    (*FMStartPage) (
        SURFOBJ *pso
        );

    BOOL
    (*FMSendPage)(
        SURFOBJ *pso
        );

    BOOL
    (*FMEndDoc)(
        SURFOBJ *pso,
        FLONG   flags
        );

    BOOL
    (*FMNextBand)(
        SURFOBJ *pso,
        POINTL *pptl
        );

    BOOL
    (*FMStartBanding)(
        SURFOBJ *pso,
        POINTL *pptl
        );

    BOOL
    (*FMResetPDEV)(
        PDEV  *pPDevOld,
        PDEV  *pPDevNew
        );

    BOOL
    (*FMEnableSurface)(
        PDEV *pPDev
        );

    VOID
    (*FMDisableSurface)(
        PDEV *pPDev
        );

    VOID
    (*FMDisablePDEV)(
        PDEV *pPDev
        );


    BOOL
    (*FMTextOut)(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix
        );


    PIFIMETRICS
    (*FMQueryFont)(
        PDEV    *pPDev,
        ULONG_PTR   iFile,
        ULONG   iFace,
        ULONG_PTR *pid
        );

    PVOID
    (*FMQueryFontTree)(
        PDEV    *pPDev,
        ULONG_PTR   iFile,
        ULONG   iFace,
        ULONG   iMode,
        ULONG_PTR *pid
        );

    LONG
    (*FMQueryFontData)(
        PDEV       *pPDev,
        FONTOBJ    *pfo,
        ULONG       iMode,
        HGLYPH      hg,
        GLYPHDATA  *pgd,
        PVOID       pv,
        ULONG       cjSize
        );

    ULONG
    (*FMFontManagement)(
        SURFOBJ *pso,
        FONTOBJ *pfo,
        ULONG   iMode,
        ULONG   cjIn,
        PVOID   pvIn,
        ULONG   cjOut,
        PVOID   pvOut
        );

    BOOL
    (*FMQueryAdvanceWidths)(
        PDEV    *pPDev,
        FONTOBJ *pfo,
        ULONG   iMode,
        HGLYPH *phg,
        PVOID  *pvWidths,
        ULONG   cGlyphs
        );

    ULONG
    (*FMGetGlyphMode)(
        PDEV    *pPDev,
        FONTOBJ *pfo
        );


}FMPROCS, * PFMPROCS;

/* Font Interface functions for Raster Module */

INT
ILookAheadMax(
    PDEV    *pPDev,
    INT     iyVal,
    INT     iLookAhead
    );

BOOL
BDelayGlyphOut(
    PDEV  *pPDev,
    INT    yPos
    );

VOID
VResetFont(
    PDEV   *pPDev
    );

/* Font Interface functions for OEM Module */

BOOL
FMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

#ifdef __cplusplus
}
#endif

#endif  // !_FONTIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\mini.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    mini.h

Abstract:

    Minidrv related header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _MINI_H_
#define _MINI_H_

typedef struct _MINIPAPERFORMAT {

    //
    // All paper units are in Master units
    //

    SIZEL       szPaper;                        // Physical size of paper selected, in text resolution
    SIZEL       szImageArea;                    // Imageable area of paper
    POINT       ptImgOrigin;                    // X, Y origin of where image area starts
    POINT       ptPrinterOffset;                // X, Y offset to printer cursor position

} MINIPAPERFORMAT, *PMINIPAPERFORMAT;


typedef struct {
    DWORD       fGeneral;           /* Misc. flags for RASDD use*/
    DWORD       fMGeneral;          /* Misc. flags for minidriver use*/
    short       iOrient;            /* DMORIENT_LANDSCAPE else portrait */
    WORD        fColorFormat;       /* color flags DEVCOLOR: */
    short       sDevPlanes;         /* # of planes in the device color model, */
    short       sBitsPixel;         /* Bits per pixel  - if Pixel model */
    int         iLookAhead;         /* Look ahead region: DeskJet type */
    int         iyPrtLine;          /* Current Y printer cursor position */
    MINIPAPERFORMAT minipf;         /* paper format structure */
    SIZEL       szlPage;            /* Whole page, in graphics units */
    SIZEL       szlBand;            /* Size of banding region, if banding */
    BYTE        *pMemBuf;            /* Pointer to buffer for minidriver use (rasdd frees) */
    int         iMemReq;            /* Minidriver needs some memory */
    int         ixgRes;             /* Resolution, x graphics */
    int         iygRes;             /* Ditto, y */
    int         iModel;             /* index into the MODELDATA array. */
    int         iCompMode;          /* Which compression mode in use */
    short       sImageControl;       /* Index of Image Control in Use */
    short       sTextQuality;        /* Index of Text Quality in Use */
    short       sPaperQuality;       /* Index of Paper Quality in Use */
    short       sPrintDensity;       /* Index of Print Density in Use */
    short       sColor;              /* Index of DevColor Struct in Use */
    WORD        wReserved;           /* Alignment of struct */
    DWORD       dwMReserved[16];     /* Reserved for minidriver use */
    DWORD       dwReserved[16];      /* Reserved for future RASDD use */
} MDEV;

typedef MDEV *PMDEV;


typedef struct{
            MDEV *pMDev;
}
M_UD_PDEV;

#endif  // !_MINI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\fmnewgly.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmnewgly.h

Abstract:

    Universal printer driver specific font metrics resource header

Environment:

    Windows NT printer drivers

Revision History:

    10/30/96 -eigos-
        Created it.

--*/

#ifndef _FMNEWGLY_H_
#define _FMNEWGLY_H_

//
// NOTE: To include this header file, it is necessary to include
//       winddi.h which has a definition of FD_GLYPHSET
//       parser.h which has a definition of INVOCATION
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information
// of printer device font.
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD      dwCodePage;
    INVOCATION SelectSymbolSet;
    INVOCATION UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//

#define CC_DEFAULT  0 // Default Character Conversion
#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.

#endif // _FMNEWGLY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\fmlib.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmlib.h

Abstract:

    Include file to provide prototypes and data types for the rasdd
    private library.

Environment:

    Windows NT printer drivers

Revision History:

    11/11/96 -eigos-
        From NT4.0.

Note:

    uni16gpc.h has to be included before including this header file.
    Definition CD is defined in uni16gpc.h

--*/

#ifndef _FMLIB_H_
#define _FMLIB_H_


//
//   A convenient grouping for passing around information about the
// Win 3.1 font information.
//

typedef  struct
{
    BYTE           *pBase;      // The base address of data area
    DWORD           dwFlags;    // Misc. flags.
    DRIVERINFO      DI;         // DRIVERINFO for this font
    PFMHEADER       PFMH;       // Properly aligned, not resource format
    PFMEXTENSION    PFMExt;     // Extended PFM data,  properly aligned!
    EXTTEXTMETRIC  *pETM;        // Extended text metric
    CD             *pCDSelectFont;
    CD             *pCDUnSelectFont;
    DWORD           dwKernPairSize;
    w3KERNPAIR     *pKernPair;
    DWORD           dwWidthTableSize;
    PSHORT          psWidthTable;
    DWORD           dwCodePageOfFacenameConv;
} FONTIN, *PFONTIN;

#define FLAG_FONTSIM        0x01

typedef struct
{
    DWORD dwSize;
    PBYTE pCmdString;
} CMDSTRING, *PCMDSTRING;

typedef struct
{
    UNIFM_HDR   UniHdr;
    UNIDRVINFO  UnidrvInfo;
    CMDSTRING   SelectFont;
    CMDSTRING   UnSelectFont;
    CMDSTRING   IDString;
    DWORD       dwIFISize;
    PIFIMETRICS pIFI;
    EXTTEXTMETRIC  *pETM;        // Extended text metric
    DWORD       dwKernDataSize;
    PKERNDATA   pKernData;
    DWORD       dwWidthTableSize;
    PWIDTHTABLE pWidthTable;
} FONTOUT, *PFONTOUT;

typedef struct
{
    PWSTR pwstrUniqName;
} FONTMISC, *PFONTMISC;

//
//   Function prototypes for functions that convert Win 3.1 PFM style
//  font info to the IFIMETRICS etc required by NT.
//

//
// Convert PFM style metrics to IFIMETRICS
//

BOOL BFontInfoToIFIMetric(
    IN     HANDLE,
    IN     FONTIN*,
    IN     PWSTR,
    IN     DWORD,
    IN OUT PIFIMETRICS*,
    IN OUT PDWORD,
    IN DWORD);

//
// Align PFM data
//

BOOL
BAlignPFM(
    FONTIN   *pFInData);

//
// Extract the Command Descriptors for (de)selecting a font
//

BOOL BGetFontSelFromPFM(
    IN     HANDLE,
    IN     FONTIN*,
    IN     BOOL,
    IN OUT CMDSTRING*);

//
//   Obtain a width vector - proportionally spaced fonts only
//

BOOL BGetWidthVectorFromPFM(
    IN     HANDLE,
    IN     FONTIN*,
    IN OUT PSHORT*,
    IN OUT PDWORD);

//
// Obtain a kerning pair
//

BOOL
BGetKerningPairFromPFM(
    IN  HANDLE,
    IN  FONTIN*,
    OUT w3KERNPAIR **);

//
// Function to convert PFM to UFM
//

BOOL
BConvertPFM2UFM(
    IN     HANDLE,
    IN     PBYTE,
    IN     PUNI_GLYPHSETDATA,
    IN     DWORD,
    IN     PFONTMISC,
    IN     PFONTIN,
    IN     int,
    IN OUT PFONTOUT,
    IN     DWORD);

//
// Function to convert CTT to GTT
//

BOOL
BConvertCTT2GTT(
    IN     HANDLE,
    IN     PTRANSTAB,
    IN     DWORD,
    IN     WCHAR,
    IN     WCHAR,
    IN     PBYTE,
    IN     PBYTE,
    IN OUT PUNI_GLYPHSETDATA*,
    IN     DWORD);

#endif // _FMLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\oemkm.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    oemkm.h

Abstract:

    Header file to support kernel mode OEM plugins

Environment:

        Windows NT Universal Printer driver (UNIDRV)

Revision History:

        03/28/97 -zhanw-
                Adapted from Pscript driver.

--*/


#ifndef _OEMKM_H_
#define _OEMKM_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <printoem.h>
#include "oemutil.h"


//
// Information about OEM hooks
//

typedef struct _OEM_HOOK_INFO
{
    OEMPROC             pfnHook;        // function address of the hook
    POEM_PLUGIN_ENTRY   pOemEntry;      // which OEM plugin hooked it
} OEM_HOOK_INFO, *POEM_HOOK_INFO;

//
// This macro should be placed near the beginning of every
// DDI entrypoint which can be hooked by OEM plugin
//

#define HANDLE_OEMHOOKS(pdev, ep, pfnType, resultType, args) \
        if ((pdev)->pOemHookInfo != NULL && \
            (pdev)->pOemHookInfo[ep].pfnHook != NULL && \
            (pdev)->dwCallingFuncID != ep) \
        { \
            resultType result; \
            DWORD      dwCallerFuncID;\
            dwCallerFuncID = (pdev)->dwCallingFuncID;\
            (pdev)->dwCallingFuncID = ep; \
            (pdev)->devobj.hOEM = ((pdev)->pOemHookInfo[ep].pOemEntry)->hInstance; \
            (pdev)->devobj.pdevOEM = ((pdev)->pOemHookInfo[ep].pOemEntry)->pParam; \
            (pdev)->devobj.pOEMDM = ((pdev)->pOemHookInfo[ep].pOemEntry)->pOEMDM; \
            result = ((pfnType) (pdev)->pOemHookInfo[ep].pfnHook) args; \
            (pdev)->dwCallingFuncID = dwCallerFuncID; \
            return result; \
        }

//
// Macros used to call an entrypoint for all OEM plugins
//

#define START_OEMENTRYPOINT_LOOP(pdev) \
        { \
            DWORD _oemCount = (pdev)->pOemPlugins->dwCount; \
            POEM_PLUGIN_ENTRY pOemEntry = (pdev)->pOemPlugins->aPlugins; \
            for ( ; _oemCount--; pOemEntry++) \
            { \
                if (pOemEntry->hInstance == NULL) continue; \
                (pdev)->devobj.hOEM    = pOemEntry->hInstance; \
                (pdev)->devobj.pdevOEM = pOemEntry->pParam; \
                (pdev)->devobj.pOEMDM = pOemEntry->pOEMDM;

#define END_OEMENTRYPOINT_LOOP \
            } \
        }

//
// Get information about OEM plugins associated with the current device
// Load them into memory and call OEMEnableDriver for each of them
//

typedef struct _PDEV PDEV;

#ifdef WINNT_40

PVOID
DrvMemAllocZ(
    ULONG   ulSize
    );

VOID
DrvMemFree(
    PVOID   pMem
    );


LONG
DrvInterlockedIncrement(
    PLONG pRef
    );

LONG
DrvInterlockedDecrement(
    PLONG  pRef
    );

#endif //WINNT_40


BOOL
BLoadAndInitOemPlugins(
    PDEV    *pPDev
    );

// Constant flag bits for OEM_PLUGIN_ENTRY.dwFlags field

#define OEMENABLEDRIVER_CALLED  0x0001
#define OEMENABLEPDEV_CALLED    0x0002

//
// Unload OEM plugins and free all relevant resources
//

VOID
VUnloadOemPlugins(
    PDEV    *pPDev
    );

#define FIX_DEVOBJ(pPDev, ep) \
    { \
        (pPDev)->devobj.pdevOEM = (pPDev)->pOemHookInfo[ep].pOemEntry->pParam; \
        (pPDev)->devobj.pOEMDM = (pPDev)->pOemHookInfo[ep].pOemEntry->pOEMDM; \
        (pPDev)->pOemEntry = (PVOID)((pPDev)->pOemHookInfo[ep].pOemEntry); \
    } \


//
// Provide OEM plugins access to driver private settings
//

BOOL
BGetDriverSettingForOEM(
    PDEV    *pPDev,
    PCSTR   pFeatureKeyword,
    PVOID   pOutput,
    DWORD   cbSize,
    PDWORD  pcbNeeded,
    PDWORD  pdwOptionsReturned
    );

BOOL
BSetDriverSettingForOEM(
    PDEVMODE    pdm,
    PTSTR       pPrinterName,
    PCSTR       pFeatureKeyword,
    PCSTR       pOptionKeyword
    );




//
// Unidrv specific COM wrappers
//

//
// Method for getting the implemented method.
// Returns S_OK if the given method is implemneted.
// Returns S_FALSE if the given method is notimplemneted.
//

HRESULT HComGetImplementedMethod(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PSTR  pMethodName
    );


//
// OEMDriverDMS - UNIDRV only,
//

HRESULT HComDriverDMS(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PVOID                 pDevObj,
    PVOID                 pBuffer,
    WORD                  cbSize,
    PDWORD                pcbNeeded
    );

//
// OEMCommandCallback - UNIDRV only,
//

HRESULT HComCommandCallback(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    DWORD                 dwCallbackID,
    DWORD                 dwCount,
    PDWORD                pdwParams,
    OUT INT               *piResult
    ) ;


//
// OEMImageProcessing - UNIDRV only,
//

HRESULT HComImageProcessing(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pSrcBitmap,
    PBITMAPINFOHEADER       pBitmapInfoHeader,
    PBYTE                   pColorTable,
    DWORD                   dwCallbackID,
    PIPPARAMS               pIPParams,
    OUT PBYTE               *ppbResult
    );

//
// OEMFilterGraphics - UNIDRV only,
//

HRESULT HComFilterGraphics(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pBuf,
    DWORD                   dwLen
    );

//
// OEMCompression - UNIDRV only,
//

HRESULT HComCompression(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pInBuf,
    PBYTE                   pOutBuf,
    DWORD                   dwInLen,
    DWORD                   dwOutLen,
    OUT INT                 *piResult
    );

//
// OEMHalftone - UNIDRV only
//

HRESULT HComHalftonePattern(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pHTPattern,
    DWORD                   dwHTPatternX,
    DWORD                   dwHTPatternY,
    DWORD                   dwHTNumPatterns,
    DWORD                   dwCallbackID,
    PBYTE                   pResource,
    DWORD                   dwResourceSize
    ) ;

//
// OEMMemoryUsage - UNIDRV only,
//

HRESULT HComMemoryUsage(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    POEMMEMORYUSAGE         pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//

HRESULT HComTTYGetInfo(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    DWORD                   dwInfoIndex,
    PVOID                   pOutputBuf,
    DWORD                   dwSize,
    DWORD                   *pcbcNeeded
    );
//
// OEMDownloadFontheader - UNIDRV only
//

HRESULT HComDownloadFontHeader(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

HRESULT HComDownloadCharGlyph(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    HGLYPH                  hGlyph,
    PDWORD                  pdwWidth,
    OUT DWORD               *pdwResult
    );


//
// OEMTTDownloadMethod - UNIDRV only
//

HRESULT HComTTDownloadMethod(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    );

//
// OEMOutputCharStr - UNIDRV only
//

HRESULT HComOutputCharStr(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    DWORD                   dwType,
    DWORD                   dwCount,
    PVOID                   pGlyph
    );

//
// OEMSendFontCmd - UNIDRV only
//


HRESULT HComSendFontCmd(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    PFINVOCATION            pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//

HRESULT HComTextOutAsBitmap(
    POEM_PLUGIN_ENTRY       pOemEntry,
    SURFOBJ                 *pso,
    STROBJ                  *pstro,
    FONTOBJ                 *pfo,
    CLIPOBJ                 *pco,
    RECTL                   *prclExtra,
    RECTL                   *prclOpaque,
    BRUSHOBJ                *pboFore,
    BRUSHOBJ                *pboOpaque,
    POINTL                  *pptlOrg,
    MIX                     mix
    );

//
// OEMWritePrinter - UNIDRV only (Interface 2 only)
//

HRESULT HComWritePrinter(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    LPVOID                  pBuf,
    DWORD                   cbBuf,
    LPDWORD                 pcbWritten
    );

#ifdef __cplusplus
}
#endif

#endif  // !_OEMKM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\palette.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

        pdev.h

Abstract:

        Unidrv PDEV and related infor header file.

Environment:

        Windows NT Unidrv driver

Revision History:

        dd-mm-yy -author-
                description

--*/

#ifndef _PALETTE_H_
#define _PALETTE_H_


#define PALETTE_MAX 256

typedef  struct _PAL_DATA {

    INT         iWhiteIndex;             // Index for white entry (background)
    INT         iBlackIndex;             // Index for black entry (background)
    WORD        wPalGdi;                 // Number of colors in GDI palette
    WORD        wPalDev;                 // Number of colors in printer palette
    WORD        fFlags;                  // Various Bit Flags.
    WORD        wIndexToUse;             // Progammable index
    ULONG       *pulDevPalCol;           // Device Palette entry, only in planer mode.
    HPALETTE    hPalette;                // Palette Handle
    ULONG       ulPalCol[ PALETTE_MAX ]; // GDI Palette enties
} PAL_DATA;

//
// Macro Definitions
//

#define     PALETTE_SIZE_DEFAULT        2
#define     PALETTE_SIZE_8BIT           256
#define     PALETTE_SIZE_24BIT          8
#define     PALETTE_SIZE_4BIT           16
#define     PALETTE_SIZE_3BIT           8
#define     PALETTE_SIZE_1BIT           2
#define     RGB_BLACK_COLOR             0x00000000
#define     RGB_WHITE_COLOR             0x00FFFFFF
#define     INVALID_COLOR               0xFFFFFFFF
#define     INVALID_INDEX               0xFFFF

//fMode Flags
#define     PDF_DOWNLOAD_GDI_PALETTE        0x0001
#define     PDF_PALETTE_FOR_24BPP           0x0002
#define     PDF_PALETTE_FOR_8BPP            0x0004
#define     PDF_PALETTE_FOR_4BPP            0x0008
#define     PDF_PALETTE_FOR_1BPP            0x0010
#define     PDF_USE_WHITE_ENTRY             0x0020
#define     PDF_DL_PAL_EACH_PAGE            0x0040
#define     PDF_DL_PAL_EACH_DOC             0x0080
#define     PDF_PALETTE_FOR_8BPP_MONO       0x0100
#define     PDF_PALETTE_FOR_OEM_24BPP       0x0200

/* defines for color manipulation    */
#define RED_VALUE(c)   ((BYTE) c & 0xff)
#define GREEN_VALUE(c) ((BYTE) (c >> 8) & 0xff)
#define BLUE_VALUE(c)  ((BYTE) (c >> 16) & 0xff)


#endif // !_PALETTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\render.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    pdev.h

Abstract:

    Unidrv PDEV and related infor header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    dd-mm-yy -author-
        description

--*/

#ifndef _RENDER_H_
#define _RENDER_H_


#define PALETTE_MAX 256

typedef  struct _PAL_DATA {

    INT     iPalGdi;                    // Number of colors in GDI palette
    INT     iPalDev;                    // Number of colors in printer palette
    INT     iWhiteIndex;                // Index for white entry (background)
    INT     iBlackIndex;                // Index for black entry (background)
    ULONG   ulPalCol[ PALETTE_MAX ];    // Palette enties!
} PAL_DATA;


#endif // !_RENDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\unidebug.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    Unidebug.h

Abstract:

    Unidrv specific Debugging header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/

// Macroes for file lavel tracing. Define FILETRACE at the of the file
// before including font.h.

#if DBG

#ifdef FILETRACE

#define FVALUE( Val, format)  DbgPrint("[UniDrv!FVALUE] Value of "#Val " is "#format "\n",Val );
#define FTRACE( Val )         DbgPrint("[UniDrv!FTRACE] "#Val"\n");\

#else  //FILETRACE

#define FVALUE( Val, format)
#define FTRACE( Val )

#endif //FILETRACE

#else //DBG

#define FVALUE( Val, format)
#define FTRACE( Val )

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\state.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    state.h

Abstract:

    Graphic state tracking header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05/14/96 -amandan-
        Created

--*/

#ifndef _STATE_H_
#define _STATE_H_

typedef struct _DEVBRUSH{

    DWORD       dwBrushType;            // One of BRUSH_XXX types listed above
    INT         iColor;                 // Color of the brush, depending on the type
                                        // it could be one of the following:
                                        // 2. RGB Color
                                        // 3. User define pattern ID
                                        // 4. Shading percentage
    PVOID       pNext;                  // Pointed to next brush in list

}DEVBRUSH, *PDEVBRUSH;

typedef struct _GSTATE {

    //
    // Current Brush Information
    //

    DEVBRUSH    CurrentBrush;
    PDEVBRUSH   pRealizedBrush;
    PWORD       pCachedPatterns;


} GSTATE, * PGSTATE;

PDEVBRUSH
GSRealizeBrush(
    IN OUT  PDEV        *pPDev,
    IN      SURFOBJ     *pso,
    IN      BRUSHOBJ    *pbo
    );

BOOL
GSSelectBrush(
    IN      PDEV        *pPDev,
    IN      PDEVBRUSH   pDevBrush
    );

VOID
GSResetBrush(
    IN OUT  PDEV        *pPDev
    );

VOID
GSUnRealizeBrush(
    IN      PDEV    *pPDev
    );


#endif // _STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\uni16res.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    uni16res.h

Abstract:

    Universal printer driver specific resource header
    Windows 16 UNIDRV Font data structure

Environment:

    Windows NT printer drivers

Revision History:

    10/16/96 -eigos-
        Created it.

--*/

#ifndef _UNI16RES_H_
#define _UNI16RES_H_

//
// NOTE: It is necessary to include "uni16res.h" header before including this
//       file.
//

#ifndef _OCD_
#define _OCD_

//
// OCD are offsets into the heap to obtain a CD structure
//

typedef WORD       OCD;
typedef DWORD      LOCD;            /* double word offset to a CD  */
typedef WORD       OOCD;            /* offset to table of OCD's.  */

#endif //_OCD_

//
// Old version of the structure
//

#define DRIVERINFO_VERSION      0x0200


//
// DRIVERINFO contains extra font information needed by genlib to output text
//

#pragma pack (2)
typedef struct _DRIVERINFO
{
    short   sSize;          /* size of this structure */
    short   sVersion;       /* version number */
    WORD    fCaps;          /* Capabilties Flags */
    short   sFontID;        /* unique font id defined by the driver */
    short   sYAdjust;       /* adjust y position before output character */
                            /* used by double height characters */
    short   sYMoved;        /* cursor has moved after printing this font */
    short   sTransTab;      /* ID value for CTT */
    short   sUnderLinePos;
    short   sDoubleUnderlinePos;
    short   sStrikeThruPos;
    LOCD    locdSelect;     /* long offset to command descriptor */
    LOCD    locdUnSelect;   /* long offset to command descriptor to unselect */
                            /* NOOCD is none */

    WORD    wPrivateData;   /* Used in DeskJet driver for font enumerations */
    short   sShift;         /* # of pixels shifted from the center of the
                             * char center-line. Used for Z1 cartidge.
                             * Use a negative value representing left shift.
                             */
    WORD    wFontType;   /* Type of font */
}  DRIVERINFO;
#pragma pack ()

//
// flags defined for DRIVERINFO.fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline
                                        // via FONTSIMULATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec.


//
// Types for DRIVERINFO.wFontType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2


//
//  The following structure has awful alignment characteristics.  So,
//  all the non-aligned entries have been turned into BYTE arrays.  This
//  ensures that the structure has the correct size,  since we MUST
//  use the data in the minidrivers,  which have this format.
//

//
// res_PFMHEADER
//

typedef struct _res_PFMHEADER
{
    short dfType;
    short dfPoints;
    short dfVertRes;
    short dfHorizRes;
    short dfAscent;
    short dfInternalLeading;
    short dfExternalLeading;
    BYTE  dfItalic;
    BYTE  dfUnderline;
    BYTE  dfStrikeOut;
    BYTE  b_dfWeight[ 2 ];        // short  dfWeight;
    BYTE  dfCharSet;
    short dfPixWidth;
    short dfPixHeight;
    BYTE  dfPitchAndFamily;
    BYTE  b_dfAvgWidth[ 2 ];      // short  dfAvgWidth;
    BYTE  b_dfMaxWidth[ 2 ];      // short  dfMaxWidth;
    BYTE  dfFirstChar;
    BYTE  dfLastChar;
    BYTE  dfDefaultChar;
    BYTE  dfBreakChar;
    BYTE  b_dfWidthBytes[ 2 ];    // short  dfWidthBytes;
    BYTE  b_dfDevice[ 4 ];        // DWORD  dfDevice;
    BYTE  b_dfFace[ 4 ];          // DWORD  dfFace;
    BYTE  b_dfBitsPointer[ 4 ];   // DWORD  dfBitsPointer;
    BYTE  b_dfBitsOffset[ 4 ];    // DWORD  dfBitsOffset;
    BYTE  dfReservedByte;
} res_PFMHEADER;

//
// PFMHEADER
//
// Following are the correctly byte aligned versions of the above
// structures with a name beginning res_
//

typedef struct _PFMHEADER
{
    DWORD       dfDevice;
    DWORD       dfFace;
    DWORD       dfBitsPointer;
    DWORD       dfBitsOffset;
    short       dfType;
    short       dfPoints;
    short       dfVertRes;
    short       dfHorizRes;
    short       dfAscent;
    short       dfInternalLeading;
    short       dfExternalLeading;
    short       dfWeight;
    short       dfPixWidth;
    short       dfPixHeight;
    short       dfAvgWidth;
    short       dfMaxWidth;
    short       dfWidthBytes;
    BYTE        dfItalic;
    BYTE        dfUnderline;
    BYTE        dfStrikeOut;
    BYTE        dfCharSet;
    BYTE        dfFirstChar;
    BYTE        dfLastChar;
    BYTE        dfDefaultChar;
    BYTE        dfBreakChar;
    BYTE        dfPitchAndFamily;
    BYTE        dfReservedByte;
} PFMHEADER;

//
// res_PFMEXTENSION
//

typedef struct _res_PFMEXTENSION
{
    WORD    dfSizeFields;
    BYTE    b_dfExtMetricsOffset[ 4 ];
    BYTE    b_dfExtentTable[ 4 ];
    BYTE    b_dfOriginTable[ 4 ];
    BYTE    b_dfPairKernTable[ 4 ];
    BYTE    b_dfTrackKernTable[ 4 ];
    BYTE    b_dfDriverInfo[ 4 ];
    BYTE    b_dfReserved[ 4 ];
} res_PFMEXTENSION;

//
// PFMEXTENSION
//
//  The aligned version of the above - for civilised users
//

typedef struct _PFMEXTENSION
{
    DWORD   dfSizeFields;               /* DWORD for alignment */
    DWORD   dfExtMetricsOffset;
    DWORD   dfExtentTable;
    DWORD   dfOriginTable;
    DWORD   dfPairKernTable;
    DWORD   dfTrackKernTable;
    DWORD   dfDriverInfo;
    DWORD   dfReserved;
} PFMEXTENSION;

//
// PFM structure used by all hardware fonts
//

typedef struct _PFM
{
    res_PFMHEADER    pfm;
    res_PFMEXTENSION pfme;
} PFM;

//
// BMFEXTENSION
//
// bitmap font extension
//

typedef struct _BMFEXTENSION
{
    DWORD   flags;              // Bit Blags
    WORD    Aspace;             // Global A space, if any
    WORD    Bspace;             // Global B space, if any
    WORD    Cspace;             // Global C space, if any
    DWORD   oColor;             // offset to color table, if any
    DWORD   reserve;
    DWORD   reserve1;
    WORD    reserve2;
    WORD    dfCharOffset[1];    // Area for storing the character offsets
} BMFEXTENSION;

//
// BMF
// bitmap font structure used by 3.0 bitmap fonts
//

typedef struct _BMF
{
    PFMHEADER       pfm;
    BMFEXTENSION    bmfe;
} BMF;

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

//
// EXTTEXTMETRIC
//

typedef struct _EXTTEXTMETRIC
{
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC;

#endif //_EXTTEXTMETRIC_

//
// w3KERNPAIR
//

typedef struct _w3KERNPAIR
{
    union
    {
        BYTE each[2];
        WORD both;
    } kpPair;
    short kpKernAmount;
} w3KERNPAIR;

//
// w3KERNTRACK
//

typedef struct _w3KERNTRACK
{
    short ktDegree;
    short ktMinSize;
    short ktMinAmount;
    short ktMaxSize;
    short ktMaxAmount;
} w3KERNTRACK;


//
// TRANSTAB is used to do ANSI to OEM code pages.
//

typedef struct _TRANSTAB
{
    WORD    wType;       // tells what type of translation table
    BYTE    chFirstChar;
    BYTE    chLastChar;
    union
    {
        short   psCode[1];
        BYTE    bCode[1];
        BYTE    bPairs[1][2];
    } uCode;
} TRANSTAB, *PTRANSTAB;

//
// Defined indices for wType
//

#define CTT_WTYPE_COMPOSE   0
                //
                // uCode is an array of 16-bit offsets from the
                // beginning of the file pointing to the strings to
                // use for translation.  The length of the translated
                // string is the difference between the next offset
                // and the current offset.
                //

#define CTT_WTYPE_DIRECT    1
                //
                // uCode is a byte array of one-to-one translation
                // table from bFirstChar to bLastChar
                //

#define CTT_WTYPE_PAIRED    2
                //
                // uCode contains an array of paired unsigned
                // bytes.  If only one character is needed to do
                // the translation then the second byte is zero,
                // otherewise the second byte is struct over the
                // first byte.
                //

//
// Predefined CTT in Win95
//

#define CTT_CP437     -1    // MS-DOS United States
#define CTT_CP850     -2    // MS-DOS Multilingual (Latin I)
#define CTT_CP863     -3    // MS-DOS Canadian-French
#define CTT_BIG5      -261  // Chinese (PRC, Singapore)
#define CTT_ISC       -258  // Korean
#define CTT_JIS78     -256  // Japan
#define CTT_JIS83     -259  // Japan
#define CTT_JIS78_ANK -262  // Japan
#define CTT_JIS83_ANK -263  // Japan
#define CTT_NS86      -257  // Chinese (PRC, Singapore)
#define CTT_TCA       -260  // Chinese (PRC, Singapore)

//
// PFMDATA
//

typedef struct _PFMDATA
{
    PFMHEADER        *pPfmHeader;
    short            *pCharWidths;
    PFMEXTENSION     *pPfmExtension;
    EXTTEXTMETRIC    *pExtTextMetrics;
    short            *pExtentTable;
    DRIVERINFO       *pDriverInfo;
    w3KERNPAIR       *pKernPair;
    w3KERNTRACK      *pKernTrack;
} PFMDATA;

//
// PCMHEADER is taken from HP/PCL font installer's "pfm.h".
//

typedef struct _PCMHEADER
{
    WORD pcmMagic;
    WORD pcmVersion;
    DWORD pcmSize;
    DWORD pcmTitle;
    DWORD pcmPFMList;
} PCMHEADER;

#define PCM_MAGIC       0xCAC
#define PCM_VERSION 0x310

#endif // _UNI16RES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\rasterif.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

        rasterif.h

Abstract:

        Interface between Control module and Render module

Environment:

        Windows NT Unidrv driver

Revision History:

        10/14/96 -amandan-
                Created

        01-17-97 -alvins-
                Added definition for bIsRegionWhite

        mm-dd-yy -author-
                description

--*/


#ifndef _RASTERIF_H_
#define _RASTERIF_H_


BOOL
RMInit (
        PDEV    *pPDev,
        DEVINFO *pDevInfo,
        GDIINFO *pGDIInfo
        );

typedef struct _RMPROCS {

        BOOL
        (*RMStartDoc) (
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL
        (*RMStartPage) (
                SURFOBJ *pso
                );

        BOOL
        (*RMSendPage)(
                SURFOBJ *pso
                );

        BOOL
        (*RMEndDoc)(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL
        (*RMNextBand)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*RMStartBanding)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*RMResetPDEV)(
                PDEV  *pPDevOld,
                PDEV  *pPDevNew
                );

        BOOL
        (*RMEnableSurface)(
                PDEV *pPDev
                );

        VOID
        (*RMDisableSurface)(
                PDEV *pPDev
                );

        VOID
        (*RMDisablePDEV)(
                PDEV *pPDev
                );

        BOOL
        (*RMCopyBits)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        BOOL
        (*RMBitBlt)(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL
        (*RMStretchBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

        ULONG
        (*RMDitherColor)(
                PDEV    *pPDev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL
        (*RMStretchBltROP)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );
        BOOL
        (*RMPaint)(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL
        (*RMPlgBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                POINTFIX   *pptfx,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

}RMPROCS, * PRMPROCS;

BOOL
RMInitDevicePal(
    PDEV *pPDev,
    PAL_DATA *pPal
    );

#endif  // !_RASTERIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\pdev.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    pdev.h

Abstract:

    Unidrv PDEV and related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "oemkm.h"
#include "state.h"

#ifndef _PDEV_H_
#define _PDEV_H_

#define CCHNAME         32                  // length of port names.
#define CCHMAXBUF       128                 // size of local buffer
#define CCHSPOOL        4096                // Size of spool buffer
#define PDEV_ID         0x72706476          // "rpdv" in ASCII

#define BBITS           8                   // Bits per BYTE
#define WBITS           (sizeof( WORD ) * BBITS)
#define WBYTES          (sizeof( WORD ))
#define DWBITS          (sizeof( DWORD ) * BBITS)
#define DWBYTES         (sizeof( DWORD ))

#define NOOCD           -1                  // Command does not exist

#define MIN(x, y)   ((x) < (y) ? (x) : (y))
#define MAX(x, y)   ((x) < (y) ? (y) : (x))

//
// Possible personality types
//
typedef enum _EPERSONALITY {
    kNoPersonality,
    kPCLXL,
    kHPGL2,
    kPCLXL_RASTER,
} EPERSONALITY;

//
// SHRINK_FACTOR is used to reduce the number of scan lines in the
// drawing surface bitmap when we cannot create a full sized version.
// Each iteration of the "try this size" loop  will reduce the number
// of scan lines by this factor.
//

#define SHRINK_FACTOR     2                 // Bitmap reduction size
#define ONE_MBYTE         (1024L * 1024L)
#define MAX_SIZE_OF_BITMAP (6L * ONE_MBYTE)
#define MIN_SIZE_OF_BITMAP (ONE_MBYTE / 2L)
#define MAX_COLUMM        8
#define LINESPERBLOCK     32                // scans per bitmap block for erasing surface
#define MAX_NUM_RULES     256
//
//  OUTPUTCTL is included in PDEVICE for controlling the state of the output
//  device during banding
//

typedef struct _OUTPUTCTL {

    POINT           ptCursor;        // current cursor position (printer's CAP)
                                     // (in master units), use this for
                                     // absolute x,y move cmds
    POINT           ptRelativePos;   // The desired relative cursor position,
                                     // relative to current
                                     // cursor position
    POINT           ptAbsolutePos;   // The absolute cursor postion
    DWORD           dwMode;          // flags for controling printer state.
    LONG            lLineSpacing;    // last line spacing chosen
    ULONG           ulBrushColor;    // Current Brush Color.

    //
    // The following fields are initialized and update by
    // the Raster module
    //

    SHORT           sColor;                     // Last color chosen
    SHORT           sBytesPerPinPass;           // number of bytes per row of printhead.
    SHORT           sPad;                       // Padding for alignment

} OUTPUTCTL;

//
// flags for OUTPUTCTL.dwCursorMode
//

#define MODE_CURSOR_X_UNINITIALIZED  0x00000001
#define MODE_CURSOR_Y_UNINITIALIZED  0x00000002
#define MODE_CURSOR_UNINITIALIZED    0x00000003    // both X and Y
#define MODE_BRUSH_RESET_COLOR       0x00000004    // Reset the brush color by
                                                   // by sending the command.

typedef struct _PAPERFORMAT {
    //
    // All paper units are in Master units. All fields are in Portrait orientation.
    //

    SIZEL       szPhysSizeM;        // Physical size, in Portrait
    SIZEL       szImageAreaM;       // Imageable area of paper, in Portrait
    POINT       ptImageOriginM;     // X, Y origin of imageable area, in Portrait

} PAPERFORMAT, *PPAPERFORMAT;

typedef struct _SURFACEFORMAT {
    //
    // all fields in this structure are in the current orientation.
    // Fields end with 'M' are in master units; and those end with 'G' are in graphics
    // device units.

    POINT   ptPrintOffsetM;     // X, Y offset of image origin relative to cursor origin
    SIZEL   szPhysPaperG;
    SIZEL   szImageAreaG;
    POINT   ptImageOriginG;

} SURFACEFORMAT, * PSURFACEFORMAT;
//
// PDEVICE structure for Unidrv
//

typedef struct _PDEV {
    //
    // the first field must be DEVOBJ, defined in <printoem.h>.
    //
    DEVOBJ       devobj;        // the first field of DEVOBJ is the pointer
                                // to PDEV itself.
    //
    // General information
    //

    PVOID       pvStartSig;                     // Signature at the start
    ULONG       ulID;                           // For PDEV verification
    HANDLE      hUniResDLL;                     // Handle to resource DLL
    HBITMAP     hbm;                            // The bitmap handle from EngCreateBitmap
    HSURF       hSurface;                       // The surface handle from EngCreateDeviceSurface
    SURFOBJ     *pso;                           // Pointer to driver managed surface
    DWORD       fMode;                          // Device context flags
    DWORD       fMode2;				// Device context flags
    DWORD       fHooks;                         // Hook flag for EngAssociateSurface
    WINRESDATA  WinResData;                     // Struct for resource data loading
    //  WINRESDATA  localWinResData;                     //  references  unires.dll
    BOOL        bTTY;                           // Set if the printer is TTY
    PDRIVER_INFO_3  pDriverInfo3;               // pointer to DRIVER_INFO_3 structure
    DWORD       dwDelta;                        // Size of each columm for z-ordering fix
    PBYTE       pbScanBuf;                      // Array representing # of scan lines on the band
    PBYTE       pbRasterScanBuf;                // Array representing # of scan lines block on the band
#ifndef DISABLE_NEWRULES
    PRECTL      pbRulesArray;			// Array containing pseudo vector rectangles
    DWORD       dwRulesCount;			// Number of pseudo vector rectangles
#endif
    DWORD	dwHTPatSize;			// Size of halftone pattern
    PFORM_INFO_1    pSplForms;     //   Array of forms registered in forms database.
    DWORD       dwSplForms ;       //   Number of forms in the array.

    //
    // OEM info
    //
    POEM_PLUGINS    pOemPlugins;
    POEM_PLUGINS    pOemEntry;  //  the Plugin that supports the selected OEM entry point
    POEM_HOOK_INFO  pOemHookInfo;
    DWORD           dwCallingFuncID;
    PFN_OEMCommandCallback  pfnOemCmdCallback;  // cache the function ptr, if any

    //
    // Graphic State Info
    //

    GSTATE      GState;

    //
    // Personality
    //
    EPERSONALITY ePersonality;

    //
    // Memory related information
    //

    DWORD       dwFreeMem;                      // Memory available on printer

    //
    // Banding related information
    //

    BOOL        bBanding;                       // Flag to indicate banding
    INT         iBandDirection;                 // Banding direction
    SIZEL       szBand;                         // Dimensions of the band in Graphic units
    RECTL       rcClipRgn;                      // Clipping region
    //
    // Binary data related information
    //

    GPDDRIVERINFO *pDriverInfo;                 // Pointer to GPDDRVINFO
    RAWBINARYDATA *pRawData;                    // Pointer to RAWBINARYDATA
    INFOHEADER *pInfoHeader;                    // Pointer to INFOHEADER
    UIINFO      *pUIInfo;                       // Pointer to UIINFO
    PRINTERDATA PrinterData;                    // PRINTERDATA struct
    POPTSELECT  pOptionsArray;                  // Pointer to combined option array
    SHORT       sBitsPixel;                     // Bits per pixel selected, from COLORMODEEX

    PDWORD      arStdPtrs[SV_MAX];              // Array of PDWORD , where the
                                                // pointers points to the standard variables
    GLOBALS     * pGlobals;                     // Pointer to GLOBALS struct

    PCOMMAND    arCmdTable[CMD_MAX];            // Table containing pointers
                                                // to each predefined command index as
                                                // enumerated in gpd.h, CMDINDEX

    //
    // The following fields are use by the standard variable table.
    //

    //
    // Control module items
    //

    SHORT       sCopies;                        // SV_COPIES
                                                // SV_DESTX, SV_DESTY,
                                                // SV_DESTXREL, SV_DESTYREL,
                                                // SV_LINEFEED
                                                // are in OUTPUTCTL

                                                // SV_PHYSPAPERLENGTH, SV_PHYSPAPERWIDTH,
                                                // are in PAPERFORMAT

    DWORD       dwRop3;                         // SV_ROP3

                                                // SV_TEXTXRES , SV_TEXTYRES are
                                                // in ptTextRes

    DWORD  dwPageNumber ;  //  SV_PAGENUMBER   of a document - may not be accurate
						//  if multiple copies is simulated.
    //
    // Brush specific standard variables
    //

    DWORD       dwPatternBrushType;                // SV_PATTERNBRUSH_TYPE
    DWORD       dwPatternBrushID;                  // SV_PATTERNBRUSH_ID
    DWORD       dwPatternBrushSize;                // SV_PATTERNBRUSH_SIZE

    //
    // Palette specific standard variables.
    //

    DWORD       dwRedValue;                     // SV_REDVALUE
    DWORD       dwGreenValue;                   // SV_GREENVALUE
    DWORD       dwBlueValue ;                   // SV_BLUEVALUE
    DWORD       dwPaletteIndexToProgram;        // SV_PALETTEINDEXTOPROGRAM
    DWORD       dwCurrentPaletteIndex ;         // SV_CURRENTPALETTEINDEX



    //
    // Raster module items
    //

    DWORD       dwNumOfDataBytes;               // SV_NUMDATABYTES
    DWORD       dwWidthInBytes;                 // SV_WIDTHINBYTES
    DWORD       dwHeightInPixels;               // SV_HEIGHTINPIXELS
    DWORD       dwRectXSize;                    // SV_RECTXSIZE
    DWORD       dwRectYSize;                    // SV_RECTYSIZE
    DWORD       dwGrayPercentage;               // SV_GRAYPERCENT

    //
    // Font module items
    //

    DWORD       dwPrintDirection;               // SV_PRINTDIR
    DWORD       dwNextFontID;                   // SV_NEXTFONTID
    DWORD       dwNextGlyph;                    // SV_NEXTGLYPH
    DWORD       dwFontHeight;                   // SV_FONTHEIGHT
    DWORD       dwFontWidth;                    // SV_FONTWIDTH
    DWORD       dwFontMaxWidth;                    // SV_FONTMAXWIDTH
    DWORD       dwFontBold;                     // SV_FONTBOLD
    DWORD       dwFontItalic;                   // SV_FONTITALIC
    DWORD       dwFontUnderline;                // SV_FONTUNDERLINE
    DWORD       dwFontStrikeThru;               // SV_FONTSTRIKETHU
    DWORD       dwCurrentFontID;                // SV_CURRENTFONTID

    //
    // The following are the pointers to the options selected
    // as indicated in the pOptionsArray
    //

    PORIENTATION pOrientation;              // Pointer to ORIENTATION option
    PRESOLUTION pResolution;                // Pointer to RESOLUTION option
    PRESOLUTIONEX pResolutionEx;            // Pointer to RESOLUTIONEX option
    PCOLORMODE    pColorMode;               // Pointer to COLORMODE option
    PCOLORMODEEX  pColorModeEx;             // Pointer to COLORMODEEX option
    PDUPLEX     pDuplex;                    // Pointer to DUPLEX option
    PPAGESIZE   pPageSize;                  // Pointer to PAGESIZE option
    PPAGESIZEEX pPageSizeEx;                // Pointer to PAGESIZEEX option
    PINPUTSLOT  pInputSlot;                 // Pointer to INPUTSLOT option
    PMEMOPTION  pMemOption;                 // Pointer to MEMOPTION option
    PHALFTONING pHalftone;                  // Pointer to HALFTONING option
    PPAGEPROTECT  pPageProtect;             // Pointer to PAGEPROTECT option

//    PMEDIATYPE  pMediaType;               // Pointer to MEDIATYPE option
//    POPTION     pOutputBin;               // Pointer to OUTPUTBIN option
//    POPTION     pCollate;                 // Pointer to COLLATE option


    //
    // Text and Graphics Resolution
    //

    POINT       ptGrxRes;                       // Graphics resolution selected
    POINT       ptTextRes;                      // Text resolution selected
    POINT       ptGrxScale;                     // Scale between Master and Graphics Units
    POINT       ptDeviceFac;                    // Factor to convert from Device to Master Units

    //
    // UNIDRV devmode
    //

    PDEVMODE        pdm;                        // current devmode
    PUNIDRVEXTRA    pdmPrivate;                 // pointer to driver private portion

    //
    // Output Control Information, Paper Format and Palette
    //

    OUTPUTCTL       ctl;                        // State of the printer
    PAPERFORMAT     pf;                         // PAPERFORMAT struct
    SURFACEFORMAT   sf;                         // SURFACEFORMAT struct
    DWORD       fYMove;                         // Fields saved from looking
                                                // ast YMoveAttributes keyword
    PVOID       pPalData;                       // Pointer to PAL_DATA structure
    //
    // Spool buffer
    //

    INT        iSpool;                          // offset into the spool buffer
    PBYTE      pbOBuf;                          // Output buffer base address

    //
    // Text Specific Information
    //
    INT       iFonts;                          // Number of Device Fonts
    DWORD     dwLookAhead;                     // Look ahead region:DskJet type
    POINT     ptDefaultFont;                   // Default font width & height.
    PVOID     pFontPDev;                       // Font Module PDEV
    PVOID     pFontProcs;                      // Table of font functions
    PVOID     pFileList;                       // Pointer to Font File List

    //
    // Raster Specific Information
    //

    PVOID    pRasterPDEV;                      // Raster Module PDEV
    PVOID    pRasterProcs;                     // Table of raster functions

    //
    // Vector Specific Information
    //

    PVOID   pVectorPDEV;                       // Vector Module PDEV
    PVOID   pVectorProcs;                      // Table of vector functions
    DWORD   dwVMCallingFuncID;                 // ID of vector function.

    //
    // Temporary copies due to the fact that we unload
    // the binary data at DrvEnablePDEV and reloads it at
    // DrvEnableSurface
    //

    DWORD   dwMaxCopies;
    DWORD   dwMaxGrayFill;
    DWORD   dwMinGrayFill;
    CURSORXAFTERRECTFILL    cxafterfill;    // *CursorXAfterRectFill
    CURSORYAFTERRECTFILL    cyafterfill;    // *CursorYAfterRectFill

    //
    // DMS
    //
    DWORD dwDMSInfo;

    PVOID   pvEndSig;                       // Signature at the end

} PDEV, *PPDEV;

#define SW_DOWN     0
#define SW_LTOR     1
#define SW_RTOL     2
#define SW_UP     4    //  enum bottom band first and work towards top

//
// Flags for fMode
//

#define  PF_ABORTED             0x00000001 // Output aborted
#define  PF_DOCSTARTED          0x00000002 // Document Started
#define  PF_DOC_SENT            0x00000004 // Indicates start doc cmds sent,
                                           // this flag is  propagated during a resetPDEV.
#define  PF_PAGEPROTECT         0x00000008 // PageProtection

// Set in DrvResetPDEV for not sending  cmds  that cause page eject.
#define  PF_SEND_ONLY_NOEJECT_CMDS     0x00000010
#define  PF_NOEMFSPOOL          0x00000020 // No EMF Spooling
#define  PF_CCW_ROTATE90        0x00000040 // Rotation is 90 degress ccw
#define  PF_ROTATE              0x00000080 // We are doing L->P rotation ourselves since device cannot rotate grx data
#define  PF_NO_RELX_MOVE        0x00000100 // No relative X move cmd
#define  PF_NO_RELY_MOVE        0x00000200 // No relative Y move cmd
#define  PF_NO_XMOVE_CMD        0x00000400 // No X move cmd
#define  PF_NO_YMOVE_CMD        0x00000800 // No Y move cmd
#define  PF_FORCE_BANDING       0x00001000 // Force banding
#define  PF_ENUM_TEXT           0x00002000 // This is a delayed Text Band
#define  PF_REPLAY_BAND         0x00004000 // Enumerate the same band again
#define  PF_ENUM_GRXTXT         0x00008000 // This is a Graphics/Text Band.
#define  PF_RECT_FILL           0x00010000 // device support rect area fill
#define  PF_RESTORE_WHITE_ENTRY 0x00020000 // Restore palette Last entry to original color.
#define  PF_ANYCOLOR_BRUSH      0x00040000 // Device supports programmable color brush.
#define  PF_DOWNLOADED_TEXT     0x00080000 // To indicate we have seen downloaded or device font for the page
#define  PF_WHITEBLACK_BRUSH    0x00100000 // To indicate white/black brush selection cmds
#define  PF_DOWNLOAD_PATTERN    0x00200000 // To indicate support user defined download patter
#define  PF_SHADING_PATTERN     0x00400000 // To indicate support pattern shading
#define  PF_SURFACE_USED        0x00800000 // Indicates the bitmap surface has been used
#define  PF_RECTWHITE_FILL      0x01000000
#define  PF_SURFACE_ERASED      0x02000000 // Indicates entire surface has been cleared

#define  PF_RESELECTFONT_AFTER_GRXDATA  0x04000000 // Reset font after Graphics
#define  PF_RESELECTFONT_AFTER_XMOVE    0x08000000 // Reset Font after XMOVE
#define  PF_RESELECTFONT_AFTER_FF       0x10000000 // Reset Font after FF
#define  PF_DEVICE_MANAGED              0x20000000 // Indicates a device surface driver

#define  PF_JOB_SENT     0x40000000 // Indicates job cmds sent, this flag is
                                    // propagated during a resetPDEV.
#define  PF_SINGLEDOT_FILTER    0x80000000 // Enables filter to expand single pixels

//
// Flags for fMode2
//

#define  PF2_MIRRORING_ENABLED         0x00000001 // Indicates to mirror output raster
#define  PF2_WRITE_PRINTER_HOOKED      0x00000002 // One of plug-ins hooks WritePrinter
#define  PF2_CALLING_OEM_WRITE_PRINTER 0x00000004 // a call to an OEM WRitePrinter is in process
#define  PF2_PASSTHROUGH_CALLED_FOR_TTY 0x00000008// DrvEscape with passthrough
                                                  // is called for TTY drv.
                                                  // TTY driver.
#define  PF2_DRVTEXTOUT_CALLED_FOR_TTY 0x00000010 // DrvText is called for TTY.
#define  PF2_INVERTED_ROP_MODE         0x00000020 // Indicates ROPs should be inverted for CMY vs RGB
#define  PF2_WHITEN_SURFACE            0x00000040 // If you want psoDst to be Whitened when 
                                                  // psoSrc=STYPE_DEVICE, psoDst=STYPE_BITMAP 
                                                  // in DrvCopyBits
#define  PF2_SURFACE_WHITENED          0x00000080 // Just tells that surface has been whitened 
                                                  
                                                  
//
// Flags for fYMove
//

#define FYMOVE_FAVOR_LINEFEEDSPACING    0x00000001
#define FYMOVE_SEND_CR_FIRST            0x00000002

//
// MACROS
//

#define VALID_PDEV(pdev) \
        ((pdev) && ((pdev) == (pdev)->pvStartSig) && \
        ((pdev) == (pdev)->pvEndSig) && \
        ((pdev)->ulID == PDEV_ID))

#if DBG

#define ASSERT_VALID_PDEV(pdev) ASSERT(VALID_PDEV(pdev))

#else   // ! DBG

#define ASSERT_VALID_PDEV(pdev) \
    if (!(VALID_PDEV(pdev)))  \
    {   \
        SetLastError(ERROR_INVALID_PARAMETER); \
        return 0;   \
    }

#endif  // end !DBG

//
// checks for device managed surface
//
#define DRIVER_DEVICEMANAGED(pPDev) ((pPDev->fMode) & PF_DEVICE_MANAGED)


#ifndef USERMODE_DRIVER

extern HSEMAPHORE ghUniSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghUniSemaphore
#define INIT_CRITICAL_SECTION()     ghUniSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghUniSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghUniSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghUniSemaphore)
#define IS_VALID_DRIVER_SEMAPHORE() (ghUniSemaphore ? TRUE : FALSE)

#else // USERMODE_DRIVER

extern CRITICAL_SECTION gUniCritSection;

#define DECLARE_CRITICAL_SECTION    CRITICAL_SECTION gUniCritSection
#define INIT_CRITICAL_SECTION()     InitializeCriticalSection(&gUniCritSection)
#define ENTER_CRITICAL_SECTION()    EnterCriticalSection(&gUniCritSection)
#define LEAVE_CRITICAL_SECTION()    LeaveCriticalSection(&gUniCritSection)
#define DELETE_CRITICAL_SECTION()   DeleteCriticalSection(&gUniCritSection)

#endif // USERMODE_DRIVER


#endif  // !_PDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUD.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\uni16gpc.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    uni16gpc.h

Abstract:

    Universal printer driver specific resource header
    This file contains definitions for tables contained in the resource file
    of the Mini Drivers. It should be shared by both gentool and the
    generic library.

Environment:

    Windows NT printer drivers

Revision History:

    10/30/96 -eigos-
        Created it.

--*/

#ifndef _UNI16GPC_H_
#define _UNI16GPC_H_

//
//  The following definitions are  the resource IDs for the minidrivers.
//  These values are public,  since anyone producing minidrivers needs
//  them.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// DATAHDR is at the beginning of each Mini Driver, describes where the rest
// of the strcutures are, their size, count, etc.
//

typedef struct
{
    short   sOffset;     /* offset from the beginning of this resource  */
                         /* to obtain a table entry  */
    short   sLength;     /* length of each element in the table  */
    short   sCount;      /* number of elements in the table.  */
} HEADERENTRY;

//
// Index into array of header entry in DATAHDR
//

#define HE_MODELDATA       0
#define HE_RESOLUTION      1
#define HE_PAPERSIZE       2
#define HE_PAPERQUALITY    3
#define HE_PAPERSOURCE     4
#define HE_PAPERDEST       5
#define HE_TEXTQUAL        6
#define HE_COMPRESSION     7
#define HE_FONTCART        8
#define HE_PAGECONTROL     9
#define HE_CURSORMOVE      10
#define HE_FONTSIM         11
#define HE_COLOR           12
#define HE_RECTFILL        13
#define HE_DOWNLOADINFO    14

//
//normanh following need to be defined for GPC3
//

#define HE_RESERVED1       15
#define HE_RESERVED2       16
#define HE_RESERVED3       17
#define HE_RESERVED4       18
#define HE_RESERVED5       19
#define HE_RESERVED6       20
#define HE_RESERVED7       21
#define HE_RESERVED8       22

//
// derryd added for WDL release June 1995
//

#define HE_IMAGECONTROL    23
#define HE_PRINTDENSITY    24
#define HE_COLORTRC        25
#define HE_RESERVED12      26
#define HE_RESERVED13      27
#define HE_RESERVED14      28
#define HE_RESERVED15      29
#define MAXHE              30

#define MAXHE_GPC2         15 //for GPC2 compatibility

typedef struct
{
    short        sMagic;          /* Must be 0x7F00 */
    WORD         wVersion;        /* GPC file version # */
    POINTw       ptMaster;        /* Horizontal & Vertical Master Units  */
    DWORD        loHeap;          /* Offset from  DATAHDR to HEAP section */
    DWORD        dwFileSize;      /* Size of file in bytes */
    WORD         fTechnology;     /* Flags for special technologies */
    WORD         fGeneral;        /* Misc flags */
    char         rgchRes[10];     /* 10 bytes reserved */
    short        sMaxHE;          /* Header entry count (15 here) */
    HEADERENTRY  rghe[MAXHE];
} DATAHDR, *PDH;

#define LPDH    PDH               /* UNIDRV compatability */

//
//   The version field consists of two bytes.  The high byte is the major
//  number,  the low byte the minor number.  Version number checking
//  should take place against the high byte,  since this changes when
//  there is a significant structural change.  The minor number will
//  change with updated data only.
//

#define GPC_VERSION3          0x0300    // GPC file version 3
#define GPC_VERSION           0x0300    // current GPC file version #

#define VERSION_CHECK(x)     (((x) & 0xff00) <= GPC_VERSION)


//
// fTechnology--used as an ID, not a bitfield
//

#define GPC_TECH_DEFAULT       0   // Default technology
#define GPC_TECH_PCL4          1   // Uses PCL level 4 or above
#define GPC_TECH_CAPSL         2   // Uses CaPSL level 3 or above
#define GPC_TECH_PPDS          3   // Uses PPDS
#define GPC_TECH_TTY           4   // TTY printer--user configurable
#define GPC_TECH_DBCS          5   // Uses DBCS PDL printer

//
// fGeneral
//

#define GPC_GEN_PRIVATE_HELP    0x0001  // this driver has a private help
#define GPC_GEN_DRAFT_SINGLE    0x0002    // Only 1 font in draft mode


#ifndef _OCD_
#define _OCD_

//
// OCD are offsets into the heap to obtain a CD structure
//

typedef WORD       OCD;
typedef DWORD      LOCD;            /* double word offset to a CD  */
typedef WORD       OOCD;            /* offset to table of OCD's.  */
typedef OCD *      POCD;

#endif //_OCD_

//*****************************************************************************
//
// MODELDATA contains information describing the attributes and capabilities
// of a single printer model.
//
//*****************************************************************************

//
// MODELDATA.rgoi[] index values
//

#define MD_OI_FIRST           MD_OI_PORT_FONTS
#define MD_OI_PORT_FONTS      0
#define MD_OI_LAND_FONTS      1
#define MD_OI_RESOLUTION      2
#define MD_OI_PAPERSIZE       3
#define MD_OI_PAPERQUALITY    4
#define MD_OI_PAPERSOURCE     5
#define MD_OI_PAPERDEST       6
#define MD_OI_TEXTQUAL        7
#define MD_OI_COMPRESSION     8
#define MD_OI_FONTCART        9
#define MD_OI_COLOR          10
#define MD_OI_MEMCONFIG      11
#define MD_OI_MAX            12

//
// MODELDATA.rgoi2[] index values
//

#define MD_OI2_PENINFO      0
#define MD_OI2_IMAGECONTROL 1
#define MD_OI2_PRINTDENSITY 2
#define MD_OI2_COLORTRC     3
#define MD_OI2_RESERVED1    4
#define MD_OI2_MAX          5

//
//   MODELDATA.rgi[] index values
//

#define MD_I_PAGECONTROL      0
#define MD_I_CURSORMOVE       1
#define MD_I_FONTSIM          2
#define MD_I_RECTFILL         3
#define MD_I_DOWNLOADINFO     4
#define MD_I_VECTPAGE         5
#define MD_I_CAROUSEL         6
#define MD_I_LINEINFO         7
#define MD_I_BRUSHINFO        8
#define MD_I_VECTOUTPUT       9
#define MD_I_POLYVECTOUTPUT  10
#define MD_I_VECTSUPPORT     11
#define MD_I_RESERVED1       12
#define MD_I_RESERVED2       13
#define MD_I_RESERVED3       14
#define MD_I_RESERVED4       15
#define MD_I_MAX             16

//
// define some constants help uniform access of rgoi and rgoi2 arrays.
// When more indices are used in rgoi2 array, make sure to add new define's.
//

#define  MD_OI_OI2                 (MD_OI_MAX + MD_I_MAX)
#define  MD_OI_PENINFO             (MD_OI_OI2 + MD_OI2_PENINFO)
#define  MD_OI_IMAGECONTROL        (MD_OI_OI2 + MD_OI2_IMAGECONTROL)
#define  MD_OI_PRINTDENSITY        (MD_OI_OI2 + MD_OI2_PRINTDENSITY)
#define  MD_OI_COLORTRC            (MD_OI_OI2 + MD_OI2_COLORTRC)
#define  MD_OI_RESERVED            (MD_OI_OI2 + MD_OI2_RESERVED)
#define  MD_OI_TOTALMAX            (MD_OI_OI2 + MD_OI2_MAX)

typedef struct
{
    short   cbSize;          // size of MODELDATA, 150 bytes
    short   sIDS;           // stringtable ID for model name
    WORD    fGeneral;       // General printer capabilities
    WORD    fCurves;        // Curve Capabilities
    WORD    fLines;         // Line Capabilities
    WORD    fPolygonals;    // Polygonal Capabilities
    WORD    fText;          // Text Capabilities
    WORD    fClip;          // Clipping Capabilities
    WORD    fRaster;        // Raster Capabilities
    WORD    fLText;         // Text Capabilities in landscape mode
    short   sLeftMargin;    // Unprintable minimum left margin.
    short   sMaxPhysWidth;  // Maximum physical page width
    POINTw  ptMax;          // Maximum X & Y printable dimensions in master units
    POINTw  ptMin;          // Minimum X & Y page dimensions in master units
    short   sDefaultFontID; // Default font resource ID
    short   sLookAhead;     // Size of Lookahead region
    short   sMaxFontsPage;  // Max number of fonts printer can place on single
                            // page -1 if no limit
    short   sCartSlots;     // Number of cartridge slots on printer
    short   sDefaultCTT;
    WORD    rgoi[MD_OI_MAX];// list of offsets to index lists
    short   rgi[MD_I_MAX];  // list of indices.

    //
    // The following fields are added in GPC 3.0
    //

    WORD  rgoi2[MD_OI2_MAX];// Orphans from rgoi (here due to compatibility)
    WORD  orgoiDefaults;    // Offset to list of defaults for RGOI & RGOI2
    WORD  wReserved;        // Needed for alignment
    DWORD dwICMManufacturer;// id to match ICC profiles against
    DWORD dwICMModel;       // id to match ICC profiles against
    DWORD rgdwReserved[8];  // 32 bytes reserved for future use
} MODELDATA, *PMODELDATA;

//
//   MODELDATA.fGeneral flag values
//

#define MD_SERIAL             0x0001 // must output text serially such
                                     // as dotmatrix printers
#define MD_PARAMETERIZE       0x0002 // supports parameterized escape codes
#define MD_ROTATE_FONT_ABLE   0x0004 // can rotate hardware fonts
#define MD_COPIES             0x0008 // supports multiple copies
#define MD_DUPLEX             0x0010 // supports duplexing
#define MD_NO_ADJACENT        0x0020 // old model, cannot print adjacent pins
#define MD_LANDSCAPE_GRX_ABLE 0x0040 // can rotate raster graphics
#define MD_ALIGN_BASELINE     0x0080 // text output are algned on the
                                     // baseline, not top of char
#define MD_FONT_MEMCFG        0x0100 // Mem ref'd @ rgoi[MD_OI_MEMCONFIG]
                                     // used for download fonts only.
#define MD_LANDSCAPE_RT90     0x0200 // landscape is portrait rotated
        // 90 degress counter-clockwise, i.e. the end of a page is printed
        // first. The default is 270 degrees, i.e. the beginning of a
        // page is printed first. !!!For printers which do not have the
        // set-orientation command (i.e. only have portrait mode), this
        // bit should NOT be set. UNIDRV will rotate the graphics and
        // the beginning of a page will come out first.

#define MD_USE_CURSOR_ORIG    0x0400 // use cursor origins in
        // PAPERSIZE to calculate the print origin. The default
        // cursor origin is the upper left corner of the printable area.

#define MD_WHITE_TEXT         0x0800 // can print white text on black
                                     // bkgrd. Cmds from DEVCOLOR struct.
#define MD_PCL_PAGEPROTECT    0x1000 // provide PCL5-style page protection
#define MD_MARGINS            0x2000 // allow the user to set paper
                // unprintable area. On some printers (such
                // as Epson, the user could manipulate the
                // printer to have different margins than
                // the default. Add this bit for Win3.0
                // driver compatibility.
#define MD_CMD_CALLBACK       0x4000 // Model requires fnOEMGetCmd callback
#define MD_MEMRES             0x8000 // User may reserve printer memory

//*****************************************************************************
//
// RESOLUTION contains information needed to compose bitmap images on the printer.
// There is one RESOLUTION structure defined for each supported printer resolution.
// RESOLUTION array should be arranged from the highest resolution to the lowest
// resolution. It is also the order that will be displayed in the dialog box.
// This strucuture becomes part of the physical device block.
//
//*****************************************************************************

//
//   RESOLUTION.rgocd[] index values
//

#define RES_OCD_SELECTRES              0
#define RES_OCD_BEGINGRAPHICS          1
#define RES_OCD_ENDGRAPHICS            2
#define RES_OCD_SENDBLOCK              3
#define RES_OCD_ENDBLOCK               4
#define RES_OCD_MAX                    5

//
//  Note: RESOLUTION data structure is defined in parser.h for GPD.
//        GPC RESOLUTION data strucutre is changed as GPCRESOLUTION
//

typedef struct                  // size is 40 bytes
{
    short   cbSize;              // size of RESOLUTION, 40 bytes
    short   sIDS;               // String ID for displaying resolution
    WORD    fDump;              // Dump method flags.
    WORD    fBlockOut;          // Block out method flags.
    WORD    fCursor;            // Cursor position flags.
    short   iDitherBrush;       // selected brush for dithering
    POINTw  ptTextScale;        // relationship between master units and text units.
    POINTw  ptScaleFac;         // relationship between graphics and text
                // scale factors. expressed in powers of 2.
    short   sNPins;             // Minimum height of the image to be rendered
                // together.
    short   sPinsPerPass;       // Physical number of pins fired in one pass.
    short   sTextYOffset;       // offset from top of graphics output that of text
                // output
    short   sMinBlankSkip;      // Min. # of bytes of null data that must occur before
                // compression (strip null data only) will occur
    short   sSpotDiameter;      // size of dot at this resolution
    OCD     rgocd[RES_OCD_MAX];
} GPCRESOLUTION, *PGPCRESOLUTION;

//
//   RESOLUTION.fDump values
//

#define RES_DM_GDI              0x0040 // GDI bitmap format
#define RES_DM_LEFT_BOUND       0x0080 // Optimize by bounding rect
#define RES_DM_COLOR            0x0100 // Color support is available
#define RES_DM_DOWNLOAD_OUTLINE 0x0200 // this res supports outline font download
#define RES_DM_CALLBACK         0x8000 // Color support is available
                                       // for this resolution
//
//   RESOLUTION.fBlockOut values
//

#define RES_BO_LEADING_BLNKS  0x0001 // Strip leading blanks if sMinBlankSkip
                                     // or more bytes of null data occur
#define RES_BO_TRAILING_BLNKS 0x0002 // Strip trailing blanks if sMinBlankSkip
                                     // or more bytes of null data occur
#define RES_BO_ENCLOSED_BLNKS 0x0004 // Strip enclosed blanks if sMinBlankSkip
                                     // or more bytes of null data occur
#define RES_BO_RESET_FONT     0x0008 // Must reselect font after
                                     // blockout command
#define RES_BO_3BYTESIN4      0x0010 // each pixel is expressed in 4 bytes
#define RES_BO_UNIDIR         0x0020 // send unidir
#define RES_BO_NO_ADJACENT    0x0040 // no adjacent pins can be fired
                                     // block out command
//
// !!!LindsayH additions - for Seiko Color Point */
//

#define RES_BO_ALL_GRAPHICS   0x0100 // Send ALL graphics - no cursor

#define RES_BO_OEMGRXFILTER   0x4000 // use oem supplied graphics filter

//
// Removed ..normanh 20/11/93 minidriv.c does not have this.
// rasdd deson't use it. unidrv GPC3 needs this bit.
// #define RES_BO_CALLBACK         0x8000       // Color support is available
//

#define RES_BO_MULTIPLE_ROWS  0x8000 // Multiple lines of data can be sent
                                     // with the RES_OCD_SENDBLOCK command.


//
//   RESOLUTION.fCursor values
//

#define RES_CUR_X_POS_ORG  0x0001  // X Position is at X start point
                                   // of graphic data after rendering data
#define RES_CUR_X_POS_AT_0 0x0002  // X position at leftmost place
                                   // on page after rendering data
#define RES_CUR_Y_POS_AUTO 0x0004  // Y position automatically moves
                                   // to next Y row
#define RES_CUR_CR_GRX_ORG 0x0008  // CR moves X pos to X start point of
                                   // of graphic data

//
//   RESOLUTION.fDitherBrush flag values
//

#define RES_DB_NONE             0
#define RES_DB_COARSE           1
#define RES_DB_FINE             2
#define RES_DB_LINEART          3
#define RES_DB_ERRORDIFFUSION   4
#define RES_DB_MAX       RES_DB_ERRORDIFFUSION   // last defined ditherbrush

//*****************************************************************************
//
// PAPERSIZE contains physical paper sizes and unprintable margins
//
//*****************************************************************************

//
// PAPERSIZE.rgocd[] index values
//

#define PSZ_OCD_SELECTPORTRAIT      0
#define PSZ_OCD_SELECTLANDSCAPE     1
#define PSZ_OCD_PAGEPROTECT_ON      2
#define PSZ_OCD_PAGEPROTECT_OFF     3
#define PSZ_OCD_RESERVED1           4
#define PSZ_OCD_RESERVED2           5
#define PSZ_OCD_MAX                 6

typedef struct
{
  short cbSize;         // size of PAPERSIZE, 60 bytes.
  short sPaperSizeID;   // If sPaperSizeID is < 256 then it's predefined.
                        // If it's = 256, allow user defined sizes.
                        // If it's >= 257, it's driver-defined & is the
                        // string ID to name this driver-defined PAPERSIZE
  WORD   fGeneral;      // General flag to describe info about this size
  WORD   fPaperType;    // Bit field to describe this size, used by PAPERSRC
  POINTw ptSize;        // X & Y paper size dimension in master units.
  RECTw  rcMargins;     // Specifies the unprintable margins in master units.
                        // (Portrait mode in new spec)
  POINTw ptCursorOrig;  // Cursor origin relative to physical page origin.
  POINTw ptLCursorOrig; // Cursor origin relative to physical page origin
                        // in landscape.
  OCD    rgocd[PSZ_OCD_MAX]; // Command Descriptors
  RECTw  rcLMargins;    // Specifies the unprintable margins in master units
                        // when printing in landscape mode.
  POINTw ptVectOffset;  // Offset (in master units) from vector 0,0 to
                        // UL corner of page in portrait mode
  POINTw ptLVectOffset; // Offset (in master units) from vector 0,0 to
                        // UL corner of page in landscape mode
  WORD  wYSizeUnit;     // Base unit for custom paper size dimensions
  WORD  wPageProtMem;   // Amount of mem (in KBs) PAGEPROTECT_ON uses
} PAPERSIZE, * PPAPERSIZE;

//
//   PAPERSIZE.fGeneral flag values
//

#define PS_CENTER           0x0001 // center the printable area along the paper path
#define PS_ROTATE           0x0002 // rotate X & Y dimensions
#define PS_SUGGEST_LNDSCP   0x0004 // suggest landscape mode
#define PS_EJECTFF          0x0008 // eject page via CURSORMOVE.rgocd[CM_OCD_FF]

//
//   PAPERSIZE.fPaperType flag values
//

#define PS_T_STD            0x0001
#define PS_T_LARGE          0x0002
#define PS_T_ENV            0x0004
#define PS_T_LRGENV         0x0008
#define PS_T_ROLL           0x0010
#define PS_T_OEM1           0x0400
#define PS_T_OEM2           0x0800
#define PS_T_OEM3           0x1000
#define PS_T_OEM4           0x2000
#define PS_T_OEM5           0x4000
#define PS_T_OEM6           0x8000

//*****************************************************************************
//
// PAPERQUALITY contains an ID & OCD
//
//*****************************************************************************

//
// ganeshp!Change the order of wReserved and dwReserved to make dwReserved DWORD
// aligned, as NT compiler adds a word after wReserved to make dwReserved
// DWORD aligned. Because of this ocdSelect gets bad value from the GPC data.
//

typedef struct
{
    short   cbSize;         // size of PAPERQUALITY, 12 bytes.
    short   sPaperQualID;   //
    DWORD   dwReserved;     // "                      "
    WORD    wReserved;      // resevered for future use
    OCD     ocdSelect;      // Command Descriptor to select this Paper Quality.
} PAPERQUALITY, *PPAPERQUALITY;

//*****************************************************************************
//
// PAPERSOURCE contains information needed to select a feed methods and
// the margin that might be introduced by the feed method.
//
//*****************************************************************************

typedef struct
{
    short   cbSize;        // size of PAPERSOURCE, 16 bytes
    short   sPaperSourceID;// If sPaperSourceID <= 256 then it's predefined
                           // by genlib, otherwise, it is the string ID.
    WORD    fGeneral;
    WORD    fPaperType;    // Bit field to describe this size, used by PAPERSRC
    short   sTopMargin;    // Top margin introduced by the feed method.
    short   sBottomMargin; // Bottom margin introduced by the feed method.
    short   sBinAdjust;    // Describes adjustments supported by bin
    OCD     ocdSelect;     // Command Descriptor to select this Paper source.
} PAPERSOURCE, * PPAPERSOURCE;

//
//   PAPERSOURCE.fGeneral flag values
//

#define PSRC_EJECTFF        0x0001
#define PSRC_MAN_PROMPT     0x0002

//*****************************************************************************
//
// PAPERDEST contains information needed to select a paper out bin/tray
//
//*****************************************************************************

typedef struct
{
    short   cbSize;        // size of PAPERDEST, 8 bytes
    short   sID;           // If sID <= 256 then it's predefined
                           // otherwise, it is the stringtable ID.
    short   fGeneral;      // General purpose Bit field
    OCD     ocdSelect;     // Command Descriptor to select this attribute.
} PAPERDEST, * PPAPERDEST;


//
// PAPERDEST.fGeneral flag values
//

#define PDST_JOBSEPARATION  0x0001

//*****************************************************************************
//
// TEXTQUALITY contains information needed to select a text quality attribute
//
//*****************************************************************************

typedef struct
{
    short   cbSize;         // size of TEXTQUALITY, 8 bytes
    short   sID;            // If sID <= 256 then it's predefined
                            // otherwise, it is the string ID.
    short   fGeneral;       // General purpose Bit field
    OCD     ocdSelect;      // Command Descriptor to select this text quality.
} TEXTQUALITY, * PTEXTQUALITY;

//*****************************************************************************
//
//  COMPRESSMODE
//
//*****************************************************************************

//
//    COMPRESSMODE.rgocd[] index values
//
#define CMP_OCD_BEGIN  0
#define CMP_OCD_END    1
#define CMP_OCD_MAX    2

typedef struct
{
    short   cbSize;              // size of COMPRESSMODE, 8 bytes
    WORD    iMode;               // ID for type of commpression mode
    OCD     rgocd[CMP_OCD_MAX];  // Actual Command String, variable length
} COMPRESSMODE, *PCOMPRESSMODE;

//
//    COMPRESSMODE.wModeID flags
//

#define CMP_ID_FIRST                           CMP_ID_RLE
#define CMP_ID_RLE                             1
#define CMP_ID_TIFF40                          2
#define CMP_ID_DELTAROW                        3
#define CMP_ID_BITREPEAT                       4
#define CMP_ID_FE_RLE                          5
#define CMP_ID_LAST                            CMP_ID_FE_RLE

//*****************************************************************************
//
//  GPCFONTCART
//
//*****************************************************************************

#define FC_ORGW_PORT                     0
#define FC_ORGW_LAND                     1
#define FC_ORGW_MAX                      2

typedef struct
{
    short   cbSize;               // size of FONTCART, 12 bytes
    WORD    sCartNameID;          // stringtable ID for cartridge name
    WORD    orgwPFM[FC_ORGW_MAX]; // array of offsets to array of indices
                                  // of PFM resources
    WORD    fGeneral;             // General bit flags
    short   sShiftVal;            // amt to shift each font in this cart by
} GPCFONTCART, *PGPCFONTCART;

//#define FC_GEN_RESIDENT 0x0001  // resident font cart

//*****************************************************************************
//
//  PAGECONTROL
//
//*****************************************************************************

//
//    PAGECONTROL.rgocd[] index values
//

#define PC_OCD_BEGIN_DOC      0
#define PC_OCD_BEGIN_PAGE     1
#define PC_OCD_DUPLEX_ON      2
#define PC_OCD_ENDDOC         3
#define PC_OCD_ENDPAGE        4
#define PC_OCD_DUPLEX_OFF     5
#define PC_OCD_ABORT          6
#define PC_OCD_PORTRAIT       7
#define PC_OCD_LANDSCAPE      8
#define PC_OCD_MULT_COPIES    9
#define PC_OCD_DUPLEX_VERT    10
#define PC_OCD_DUPLEX_HORZ    11
#define PC_OCD_PRN_DIRECTION  12
#define PC_OCD_JOB_SEPARATION 13
#define PC_OCD_MAX            14

typedef struct
{
    short   cbSize;             // size of PAGECONTROL, 36 bytes
    short   sMaxCopyCount;     // max # of copies w/ PC_OCD_MULT_COPIES
    WORD    fGeneral;          // General bit flags
    WORD    orgwOrder;
    OCD     rgocd[PC_OCD_MAX];
} PAGECONTROL, * PPAGECONTROL;

//
//    PAGECONTROL.owOrder index values
//

#define PC_ORD_BEGINDOC        1
#define PC_ORD_ORIENTATION     2
#define PC_ORD_MULT_COPIES     3
#define PC_ORD_DUPLEX          4
#define PC_ORD_DUPLEX_TYPE     5
#define PC_ORD_TEXTQUALITY     6
#define PC_ORD_PAPER_SOURCE    7
#define PC_ORD_PAPER_SIZE      8
#define PC_ORD_PAPER_DEST      9
#define PC_ORD_RESOLUTION      10
#define PC_ORD_BEGINPAGE       11
#define PC_ORD_SETCOLORMODE    12
#define PC_ORD_PAPER_QUALITY   13
#define PC_ORD_PAGEPROTECT     14
#define PC_ORD_IMAGECONTROL    15
#define PC_ORD_PRINTDENSITY    16
#define PC_ORD_MAX             PC_ORD_PRINTDENSITY
#define PC_ORD_LAST            PC_ORD_PRINTDENSITY

//*****************************************************************************
//
//  CURSORMOVE
//
//*****************************************************************************

//
//    CURSORMOVE.rgocd[] index values
//

#define CM_OCD_XM_ABS          0
#define CM_OCD_XM_REL          1
#define CM_OCD_XM_RELLEFT      2
#define CM_OCD_YM_ABS          3
#define CM_OCD_YM_REL          4
#define CM_OCD_YM_RELUP        5
#define CM_OCD_YM_LINESPACING  6
#define CM_OCD_XY_REL          7
#define CM_OCD_XY_ABS          8
#define CM_OCD_CR              9
#define CM_OCD_LF              10
#define CM_OCD_FF              11
#define CM_OCD_BS              12
#define CM_OCD_UNI_DIR         13
#define CM_OCD_UNI_DIR_OFF     14
#define CM_OCD_PUSH_POS        15
#define CM_OCD_POP_POS         16
#define CM_OCD_MAX             17

typedef struct
{
    short   cbSize;             // size of CURSORMOVE, 44 bytes
    short   sReserved;
    WORD    fGeneral;
    WORD    fXMove;
    WORD    fYMove;
    OCD     rgocd[CM_OCD_MAX];  // Actual Command String, variable length
} CURSORMOVE, *PCURSORMOVE;

//
// CURSORMOVE.fGeneral flags
//

#define CM_GEN_FAV_XY   0x0002  // from Win95 GPC

//
//    CURSORMOVE.fXmove flag values
//

#define CM_XM_NO_POR_GRX    0x0004  // no x movemnt while in graphics mode, portrait
#define CM_XM_NO_LAN_GRX    0x0008  // no x movemnt while in graphics mode, landscape
#define CM_XM_RESET_FONT    0x0010  // Font is reset after x movement command
#define CM_XM_FAVOR_ABS     0x0080  // favor absolute x command
#define CM_XM_REL_LEFT      0x0200  // has relative x to the left
#define CM_XM_ABS_NO_LEFT   0x0400  // No left X movement command
#define CM_XM_RES_DEPENDENT 0x0800  // X movement in resolution unit, not mu


//
//    CURSORMOVE.fYmove flag values
//

#define CM_YM_FAV_ABS       0x0001
#define CM_YM_REL_UP        0x0002
#define CM_YM_NO_POR_GRX    0x0004  // no y movemnt while in graphics mode, portrait
#define CM_YM_NO_LAN_GRX    0x0008  // no y movemnt while in graphics mode, landscape
#define CM_YM_CR            0x0040
#define CM_YM_LINESPACING   0x0080
#define CM_YM_TRUNCATE      0x0100  // don't compensate for ymovement error
#define CM_YM_RES_DEPENDENT 0x0200  // X movement in resolution unit, not mu

//*****************************************************************************
//
// FONTSIMULATION describes various printer commands to enable and disable
// various character attributes such as bold, italic, etc.
//
//*****************************************************************************

//
//   FONTSIMULATION.rgocStd[] index values
//

#define FS_OCD_BOLD_ON                   0
#define FS_OCD_BOLD_OFF                  1
#define FS_OCD_ITALIC_ON                 2
#define FS_OCD_ITALIC_OFF                3
#define FS_OCD_UNDERLINE_ON              4
#define FS_OCD_UNDERLINE_OFF             5
#define FS_OCD_DOUBLEUNDERLINE_ON        6
#define FS_OCD_DOUBLEUNDERLINE_OFF       7
#define FS_OCD_STRIKETHRU_ON             8
#define FS_OCD_STRIKETHRU_OFF            9
#define FS_OCD_WHITE_TEXT_ON             10
#define FS_OCD_WHITE_TEXT_OFF            11
#define FS_OCD_SINGLE_BYTE               12
#define FS_OCD_DOUBLE_BYTE               13
#define FS_OCD_VERT_ON                   14
#define FS_OCD_VERT_OFF                  15
#define FS_OCD_MAX                       16

typedef struct
{
    short   cbSize;            // size of FONTSIMULATION, 44 bytes
    short   sReserved;         // so DW aligned
    WORD    fGeneral;
    short   sBoldExtra;
    short   sItalicExtra;
    short   sBoldItalicExtra;
    OCD     rgocd[FS_OCD_MAX];
} FONTSIMULATION, * PFONTSIMULATION;

//*****************************************************************************
//
// DEVCOLOR is the physical color info which describes the device color
// capabilities and how to compose colors based on available device colors.
//
//*****************************************************************************

//
//   DEVCOLOR.fGeneral bit flags:
//

#define DC_PRIMARY_RGB      0x0001   // use RGB as 3 primary colors.
                                     // Default: use CMY instead.
#define DC_EXTRACT_BLK      0x0002   // Separate black ink/ribbon is available.
                                     // Default: compose black using CMY.
                                     // It is ignored if DC_PRIMARY_RGB is set
#define DC_CF_SEND_CR       0x0004   // send CR before selecting graphics
                                     // color. Due to limited printer buffer
#define DC_SEND_ALL_PLANES  0x0008   // All color plane data must be sent
#define DC_SEND_PAGE_PLANE  0x0010   // Color separation required
#define DC_EXPLICIT_COLOR   0x0020   // Color must be set before sending
                                     // the RES_OCD_SENDBLOCK command.
#define DC_SEND_PALETTE     0x0040   // Color palette must be downloaded

//
// sandram
// add field to send dithered text for Color LaserJet - set foreground color.
//

#define DC_FG_TEXT_COLOR    0x0080  // Send command to select text foreground color
#define DC_ZERO_FILL        0x0100  // This model fills raster to the end of the page with zeros

//
// One and only one of DEVCOLOR.sPlanes or DEVCOLOR.sBitsPixel must be 1.
//
// Example:
//
// DEVCOLOR.sPlanes:
//      Valid values are:
//          1:         use the pixel color model.
//          n (n > 1): use the plane color model.
//                     Ex. for Brother M-1924, n = 4; for PaintJet, n = 3.
//
// DEVCOLOR.sBitsPixel:
//      Valid values are:
//          1:      use the plane color model.
//          4 & 8:  use the pixel color model.
//                  The color bits (4 or 8) are directly from DIB driver. They
//                  should be used as index into the printer's color palette.
//                  The mini driver write should make sure that the printer's
//                  color palette is configured in the same way as DIB's
//                  color palette in respective cases.
//

//
// DEVCOLOR.rgocd array values
//

#define DC_OCD_TC_BLACK        0
#define DC_OCD_TC_RED          1
#define DC_OCD_TC_GREEN        2
#define DC_OCD_TC_YELLOW       3
#define DC_OCD_TC_BLUE         4
#define DC_OCD_TC_MAGENTA      5
#define DC_OCD_TC_CYAN         6
#define DC_OCD_TC_WHITE        7
#define DC_OCD_SETCOLORMODE    8
#define DC_OCD_PC_START        9
#define DC_OCD_PC_ENTRY       10
#define DC_OCD_PC_END         11
#define DC_OCD_PC_SELECTINDEX 12
#define DC_OCD_SETMONOMODE    13
#define DC_OCD_MAX            14

//
// DEVCOLOR.rgbOrder array values
//

#define DC_PLANE_NONE    0
#define DC_PLANE_RED     1
#define DC_PLANE_GREEN   2
#define DC_PLANE_BLUE    3
#define DC_PLANE_CYAN    4
#define DC_PLANE_MAGENTA 5
#define DC_PLANE_YELLOW  6
#define DC_PLANE_BLACK   7

#define DC_MAX_PLANES    4

typedef struct
{
  short cbSize;               // size of DEVCOLOR, 44 bytes
  WORD  fGeneral;             // general flag bit field
  short sPlanes;              // # of color planes required
  short sBitsPixel;           // # of bits per pixel (per plane). At least
                              // one of 'sPlanes' and 'sBitsPixel' is 1.
  WORD  orgocdPlanes;         // offset to a list of OCD's for sending data
                              // planes. The # of OCD's is equal to 'sPlanes'.
                              // This field is not used in case of pixel
                              // color models. The first command will be
                              // used to send data of the first plane,
                              // and so on.
  OCD   rgocd[DC_OCD_MAX];    // array of Offsets to commands.
  BYTE  rgbOrder[DC_MAX_PLANES]; // order in which color planes are sent
  WORD  wReserved;            // For alignment
} DEVCOLOR, * PDEVCOLOR, FAR * LPDEVCOLOR;

//*****************************************************************************
//
//  RECTFILL
//
//*****************************************************************************

//
//    RECTFILL.rgocd[] index values
//

#define RF_OCD_X_SIZE                   0
#define RF_OCD_Y_SIZE                   1
#define RF_OCD_GRAY_FILL                2
#define RF_OCD_WHITE_FILL               3
#define RF_OCD_HATCH_FILL               4
#define RF_OCD_MAX                      5

typedef struct
{
    short   cbSize;             // size of RECTFILL, 20 bytes
    WORD    fGeneral;
    WORD    wMinGray;
    WORD    wMaxGray;
    OCD     rgocd[RF_OCD_MAX];   // Actual Command String, variable length
    WORD    wReserved;
} RECTFILL, *PRECTFILL;

//
//    RECTFILL.fGenral flag values
//

#define RF_WHITE_ABLE     0x0001        // White rule exists
#define RF_MIN_IS_WHITE   0x0002        // min. graylevel = white rule

#define RF_CUR_X_END      0x0100        // X Position is at X end point
                                        // of fill area after rendering
#define RF_CUR_Y_END      0x0200        // Y position is at Y end point
                                        // of fill area after rendering
                                        // default is no chg of position

//*****************************************************************************
//
// DOWNLOADINFO describes that way in which genlib should instruct the font
// installer to handle downloading soft fonts.  It contains OCDs for all
// appropriate codes.
//
//*****************************************************************************

//
//   DOWNLOADINFO.rgocd[] index values
//

#define DLI_OCD_RESERVED                 0
#define DLI_OCD_BEGIN_DL_JOB             1
#define DLI_OCD_BEGIN_FONT_DL            2
#define DLI_OCD_SET_FONT_ID              3
#define DLI_OCD_SEND_FONT_DESCRIPTOR     4
#define DLI_OCD_SELECT_FONT_ID           5
#define DLI_OCD_SET_CHAR_CODE            6
#define DLI_OCD_SEND_CHAR_DESCRIPTOR     7
#define DLI_OCD_END_FONT_DL              8
#define DLI_OCD_MAKE_PERM                9
#define DLI_OCD_MAKE_TEMP                10
#define DLI_OCD_END_DL_JOB               11
#define DLI_OCD_DEL_FONT                 12
#define DLI_OCD_DEL_ALL_FONTS            13
#define DLI_OCD_SET_SECOND_FONT_ID       14
#define DLI_OCD_SELECT_SECOND_FONT_ID    15
#define DLI_OCD_MAX                      16

typedef struct
{
    short   cbSize;            // size of DOWNLOADINFO, 52 bytes
    WORD    wReserved;         // for DWORD alignment
    WORD    fGeneral;          // general bit flags
    WORD    fFormat;           // describes download font format
    WORD    wIDMin;
    WORD    wIDMax;
    short   cbBitmapFontDescriptor;
    short   cbScaleFontDescriptor;
    short   cbCharDescriptor;
    WORD    wMaxCharHeight;
    short   sMaxFontCount;
    WORD    orgwCmdOrder;
    OCD     rgocd[DLI_OCD_MAX];
} DOWNLOADINFO, * PDOWNLOADINFO;

//
//   DOWNLOADINFO.fGeneral flag values
//

#define DLI_GEN_CNT             0x0001  // printer limits # DL fonts by fixed #
#define DLI_GEN_MEMORY          0x0002  // printer limits # DL fonts by memory
#define DLI_GEN_DLJOB           0x0004  // printer can only DL fonts on per
                                        // job basis
#define DLI_GEN_DLPAGE          0x0008  // printer can DL fonts on per page
                                        // basis
//
// NOTE: if neither of the above 2 flags
// are ste, assume DL can happen any time
//

#define DLI_GEN_PT_IDS          0x0010  // use OCD_SET_FONT_ID for specifiy
                                        // perm/temp

#define DLI_GEN_FNTDEL          0x0020  // del single font supported
#define DLI_GEN_ALLFNTDEL       0x0040  // del all fonts supported
#define DLI_GEN_FNTDEL_ANYWHERE 0x0080  // if set, fonts can be deleted at
                                        // any point. Default is at page
                                        // boundary only
#define DLI_GEN_7BIT_CHARSET    0x0100  // printer supports only 7-bit charset

//
//   DOWNLOADINFO.fFormat flag values
//

#define DLI_FMT_PCL           0x0001 // PCL printer
#define DLI_FMT_INCREMENT     0x0002 // incremental download recommended
#define DLI_FMT_RES_SPECIFIED 0x0004 // allow resolution specified bitmap
                                     // font download. The X & Y resolutions
                                     // are attached to the end of the
                                     // regular bitmap font descriptor.
#define DLI_FMT_OUTLINE       0x0008 // from WIN95 GPC
#define DLI_FMT_PCLETTO       0x0008 // alias for outline downloading (remove later)
#define DLI_FMT_CAPSL         0x0010 // Use CaPSL download header
#define DLI_FMT_PPDS          0x0020 // Use PPDS download header
#define DLI_FMT_CALLBACK      0x0040 // minidriver provide callbacks for
                                     // for downloading bitmap fonts.
//*****************************************************************************
//
//  VECTPAGE describes information about the vector page and miscellaneous
//  vector capabilities and commands
//
//*****************************************************************************

//
// VECTPAGE.rgocd[] index values
//

#define VP_OCD_INIT_VECT       0
#define VP_OCD_ENTER_VECT      1
#define VP_OCD_EXIT_VECT       2
#define VP_OCD_TRANSPARENT     3
#define VP_OCD_OPAQUE          4
#define VP_OCD_ANCHOR          5
#define VP_OCD_SET_CLIPRECT    6
#define VP_OCD_CLEAR_CLIPRECT  7
#define VP_OCD_ENDCAP_FLAT     8
#define VP_OCD_ENDCAP_ROUND    9
#define VP_OCD_ENDCAP_SQUARE  10
#define VP_OCD_JOIN_BEVEL     11
#define VP_OCD_JOIN_MITER     12
#define VP_OCD_JOIN_ROUND     13
#define VP_OCD_RESERVED1      14
#define VP_OCD_RESERVED2      15
#define VP_OCD_RESERVED3      16
#define VP_OCD_RESERVED4      17
#define VP_OCD_MAX            18

typedef struct
{
  WORD  cbSize;            // Size of VECTPAGE, 44 bytes
  WORD  fGeneral;          // General use bitfield
  POINT ptVectDPI;         // Vector units per inch
  OCD   rgocd[VP_OCD_MAX]; // Offsets to commands
} VECTPAGE, *PVECTPAGE, FAR *LPVECTPAGE;

//
// VECTPAGE.fGeneral flags
//

#define VP_GEN_X_AXIS_LEFT 0x0001 // Set if plotter's X axis (horizontal)
                                  // extends left. Default is to the right
#define VP_GEN_Y_AXIS_UP   0x0002 // Sef if plotter's Y axis (vertical)

//******************************************************************************//
//  CAROUSEL describes carousel characteristics. If the pens are fixed,
//  this also specifies the colors of each pen.
//
//******************************************************************************

//
// CAROUSEL.rgocd[] index values
//

#define CAR_OCD_SELECT_PEN_COLOR   0
#define CAR_OCD_SET_PEN_WIDTH      1
#define CAR_OCD_RETURN_PEN         2
#define CAR_OCD_RESERVED           3
#define CAR_OCD_MAX                4

typedef struct
{
    WORD  cbSize;               // Size of CAROUSEL, 16 bytes
    WORD  fGeneral;             // General purpose bitfield
    WORD  wNumPens;             // # of pens in carousel
    short oiRGBColors;          // colors of pens in carousel
    OCD   rgocd[CAR_OCD_MAX];   // commands associated with carousel
} CAROUSEL, *PCAROUSEL, FAR *LPCAROUSEL;

//
// CAROUSEL.fGeneral flags
//

#define CAR_GEN_CAROUSEL_LEFT      0x0001 // Set if pen moves to the left of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_RIGHT     0x0002 // Set if pen moves to the right of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_TOP       0x0004 // Set if pen moves to the top of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_BOTTOM    0x0008 // Set if pen moves to the bottom of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_FIXED     0x0010 // Carousel has fixed set of pens
#define CAR_GEN_RETURN_PEN         0x0020 // Pen must be explicitly returned
                                          // to the carousel before selecting
                                          // a new pen.
#define CAR_GEN_VARIABLE_PEN_WIDTH 0x0040 // Set if SET_PEN_WIDTH changes
                                          // the width of the (logical) pen
                                          // as opposed to informing the
                                          // plotter of the physical width.

//******************************************************************************//
//  PENINFO describes the characteristics of an available pen
//
//******************************************************************************

//
// PENINFO.rgocd[] index values
//

typedef struct
{
    WORD  cbSize;              // Size of PENINFO, 16 bytes
    WORD  fGeneral;            // General purpose bitfield
    DWORD fType;               // Surfaces on which pen can draw
    DWORD dwColor;             // RGB color of the pen
    WORD  fThick;              // Thickness in which pen is available
    WORD  wIDS;                // Stringtable resource for this color's name
} PENINFO, *PPENINFO, FAR *LPPENINFO;

//
// PENINFO.fThick values
//

#define PI_FTHICK_18     0x0001   // Pen comes in 0.18mm
#define PI_FTHICK_25     0x0002   // Pen comes in 0.25mm
#define PI_FTHICK_30     0x0004   // Pen comes in 0.30mm
#define PI_FTHICK_35     0x0008   // Pen comes in 0.35mm
#define PI_FTHICK_50     0x0010   // Pen comes in 0.50mm
#define PI_FTHICK_70     0x0020   // Pen comes in 0.70mm
#define PI_FTHICK_100    0x0040   // Pen comes in 1.00mm

//
// PENINFO.fType values depend on the defined paper sources, but reserve
// the high bit to indicate that any paper source is valid.
//

#define PI_FTYPE_ANY     0x80000000

//******************************************************************************//
//  LINEINFO describes the line style creation and selection commands
//
//******************************************************************************

//
// LINEINFO.rgocd[] index values
//

#define LI_OCD_DELETE_LINESTYLE    0
#define LI_OCD_SELECT_NULL         1
#define LI_OCD_SELECT_SOLID        2
#define LI_OCD_CREATE_DASH         3
#define LI_OCD_SELECT_DASH         4
#define LI_OCD_CREATE_DOT          5
#define LI_OCD_SELECT_DOT          6
#define LI_OCD_CREATE_DASHDOT      7
#define LI_OCD_SELECT_DASHDOT      8
#define LI_OCD_CREATE_DASHDOTDOT   9
#define LI_OCD_SELECT_DASHDOTDOT  10
#define LI_OCD_RESERVED1          11
#define LI_OCD_RESERVED2          12
#define LI_OCD_RESERVED3          13
#define LI_OCD_RESERVED4          14
#define LI_OCD_RESERVED5          15
#define LI_OCD_MAX                16

typedef struct
{
    WORD  cbSize;           // Size of LINEINFO, 40 bytes
    WORD  fGeneral;         // General purpose bitfield
    short sMaxUserDefined;  // Max # of line styles that can be defined at once
    WORD  wReserved;        // Maintain DWORD alignment
    OCD   rgocd[LI_OCD_MAX];// Offsets to commands
} LINEINFO, *PLINEINFO, FAR *LPLINEINFO;

//******************************************************************************//
//  BRUSHINFO describes the brush style creation and selection commands
//
//******************************************************************************

//
// BRUSHINFO.rgocd[] index values
//

#define BI_OCD_SELECT_NULL             0
#define BI_OCD_SELECT_SOLID            1
#define BI_OCD_SELECT_HS_HORIZONTAL    2
#define BI_OCD_SELECT_HS_VERTICAL      3
#define BI_OCD_SELECT_HS_FDIAGONAL     4
#define BI_OCD_SELECT_HS_BDIAGONAL     5
#define BI_OCD_SELECT_HS_CROSS         6
#define BI_OCD_SELECT_HS_DIAGCROSS     7
#define BI_OCD_CREATE_BRUSHSTYLE_1     8
#define BI_OCD_CREATE_BIT_1            9
#define BI_OCD_CREATE_SEPARATOR_1     10
#define BI_OCD_CREATE_BRUSHSTYLE_2    11
#define BI_OCD_CREATE_BYTE_2          12
#define BI_OCD_SELECT_BRUSHSTYLE      13
#define BI_OCD_DELETE_BRUSHSTYLE      14
#define BI_OCD_CREATE_END_1           15
#define BI_OCD_RESERVED2              16
#define BI_OCD_RESERVED3              17
#define BI_OCD_MAX                    18

typedef struct
{
    WORD  cbSize;             // Size of BRUSHINFO, 40 bytes
    WORD  fGeneral;           // General purpose bitfield
    short sMaxUserDefined;    // Max # of user-defined brushes allowed at once
    WORD  wReserved;          // Maintain DWORD alignment
    OCD   rgocd[BI_OCD_MAX];  // Offsets to commands
} BRUSHINFO, *PBRUSHINFO, FAR *LPBRUSHINFO;

//
// BRUSHINFO.fGeneral flags
//

#define BI_GEN_BRUSHSTYLE1     0x0001  // BRUSHSTYLE1 supported
#define BI_GEN_BRUSHSTYLE2     0x0002  // BRUSHSTYLE2 supported
#define BI_GEN_BRUSH32x32      0x0004  // Brush size of 32x32 pixels ONLY

//******************************************************************************//
//  VECTOUTPUT describes the graphic output drawing commands & ordering
//
//******************************************************************************

//
// VECTOUTPUT.rgocd[] index values
//

#define VO_OCD_RECTANGLE         0
#define VO_OCD_CIRCLE            1
#define VO_OCD_ELLIPSE           2
#define VO_OCD_C_PIE             3
#define VO_OCD_E_PIE             4
#define VO_OCD_C_ARC             5
#define VO_OCD_E_ARC             6
#define VO_OCD_C_CHORD           7
#define VO_OCD_E_CHORD           8
#define VO_OCD_RESERVED1         9
#define VO_OCD_RESERVED2        10
#define VO_OCD_RESERVED3        11
#define VO_OCD_RESERVED4        12
#define VO_OCD_RESERVED5        13
#define VO_OCD_RESERVED6        14
#define VO_OCD_RESERVED7        15
#define VO_OCD_MAX              16
#define VO_OCD_NUM               9  // # non-reserved VOs

typedef struct
{
    WORD  cbSize;             // Size of VECTOUTPUT, 40 bytes
    WORD  fGeneral;           // General purpose bitfield
    WORD  wReserved;          // Maintain DWORD alignment
    short rgoi[VO_OCD_MAX];   // Offsets to arrays of VECTSUPPORT
    OCD   rgocd[VO_OCD_MAX];  // Offsets to commands
} VECTOUTPUT, *PVECTOUTPUT, FAR *LPVECTOUTPUT;

//******************************************************************************//
//  POLYVECTOUTPUT describes the polygon/polyline drawing commands & ordering
//
//******************************************************************************

//
// POLYVECTOUTPUT.rgocd[] index values
//

#define PVO_OCD_POLYLINE       0
#define PVO_OCD_ALTPOLYGON     1
#define PVO_OCD_WINDPOLYGON    2
#define PVO_OCD_POLYBEZIER     3
#define PVO_OCD_RESERVED1      4
#define PVO_OCD_RESERVED2      5
#define PVO_OCD_RESERVED3      6
#define PVO_OCD_RESERVED4      7
#define PVO_OCD_MAX            8
#define PVO_OCD_NUM            4    // # non-reserved PVOs

//
// Indices into 2-dimensional array rgocd
//

#define OCD_BEGIN              0
#define OCD_CONTINUE           1
#define OCD_SEPARATOR          2
#define OCD_END                3
#define OCD_MAX                4

typedef struct
{
    WORD   cbSize;                    // sizeof POLYVECTOUTPUT, 88 bytes
    WORD   fGeneral;                  // General purpose bitfield
    WORD   wPointLimit;               // Polygon Point Number Limit
    WORD   wReserved;                 // Reserved for future use
    short  rgoi[PVO_OCD_MAX];         // Describes which VECTSUPPORTs are used
    OCD    rgocd[PVO_OCD_MAX][OCD_MAX]; // offsets to commands
} POLYVECTOUTPUT, *PPOLYVECTOUTPUT, FAR *LPPOLYVECTOUTPUT;

//******************************************************************************//
//  VECTSUPPORT describes methods used by VECTOUTPUT and POLYVECTOUTPUT
//
//******************************************************************************

//
// VECTSUPPORT.rgocd[] index values
//

#define VS_OCD_BEGIN_POLYDEF    0
#define VS_OCD_END_POLYDEF      1
#define VS_OCD_WIND_FILL        2
#define VS_OCD_ALT_FILL         3
#define VS_OCD_STROKE           4
#define VS_OCD_PEN_UP           5
#define VS_OCD_PEN_DOWN         6
#define VS_OCD_RESERVED1        7
#define VS_OCD_RESERVED2        8
#define VS_OCD_RESERVED3        9
#define VS_OCD_MAX             10

//
// These are used by VECTOUTPUT and POLYVECTOUTPUT to represent their ordering
// of pen and brush selection, as well as their OCD or Begin OCD, Continue
// OCD, and End OCD combination
//

#define VS_SELECT_PEN    -1
#define VS_SELECT_BRUSH  -2
#define VS_OCD           -3
#define VS_OCD_BEGIN     -4
#define VS_OCD_CONTINUE  -5
#define VS_OCD_END       -6

typedef struct
{
    WORD  cbSize;               // Size of VECTSUPPORT, 24 bytes
    WORD  fGeneral;             // General purpose bitfield
    short rgocd[VS_OCD_MAX];    // Offsets to commands
} VECTSUPPORT, *PVECTSUPPORT, FAR *LPVECTSUPPORT;

//*****************************************************************************
//
// IMAGECONTROL contains information needed to select an image control
//
//*****************************************************************************

typedef struct
{
    short cbSize;         // size of IMAGECONTROL, 8 bytes
    short sID;            // If sID <= 256 then it's predefined
                          // otherwise, it is the stringtable ID.
    short fGeneral;       // General purpose Bit field
    OCD   ocdSelect;      // Command Descriptor to select this attribute.
} IMAGECONTROL, * PIMAGECONTROL, FAR * LPIMAGECONTROL;

//
// IMAGECONTROL.fGeneral flag values
//
// None defined

//*****************************************************************************
//
// PRINTDENSITY contains information needed to select an image control
//
//*****************************************************************************

typedef struct
{
    short cbSize;         // size of PRINTDENSITY, 8 bytes
    short sID;            // If sID <= 256 then it's predefined
                          // otherwise, it is the stringtable ID.
    OCD   ocdSelect;      // Command Descriptor to select this attribute.
    WORD  wReserved;      // make the structure DWORD aligned.
} PRINTDENSITY, * PPRINTDENSITY, FAR * LPPRINTDENSITY;

//*****************************************************************************
//
// COLORTRC contains rgb transfer curves on PAPERQUALITY and RESOLUTION basis
//
//*****************************************************************************

typedef struct tagColorTRC
{
    short cbSize;                   // size of COLORTRC, 116 bytes
    WORD  wReserved;                // keep everything DWORD aligned
    WORD  fGeneral;
    WORD  wIndexPaperQuality;
    WORD  wIndexResolution;
    WORD  wDitherType;              // reserved for dither, set to zero
    WORD  wReserved1;               // always a good idea
    WORD  wReserved2;
    BYTE  RGBOrdinates[3][17];
    BYTE  padding0;                 // keep everything DWORD aligned
    BYTE  DarkRGBOrdinates[3][17];
    BYTE  padding1;                 // keep everything DWORD aligned
} COLORTRC, * PCOLORTRC, FAR * LPCOLORTRC;

//
// flags for COLORTRC
//

#define  CTRC_NO_CHECKER_BOARD    0x0001
#define  CTRC_NO_BLACK_PEN        0x0002

//
// Offsets into arrays of ORDINATELIST
//

#define TRC_RED         0
#define TRC_GREEN       1
#define TRC_BLUE        2

//*****************************************************************************
//
//  CD - Command Descriptor is used in many of the following structures to
//  reference a particular set of printer command/escape codes
//  used to select paper sizes, graphics resolutions, character attributes,
//  etc. If CD.wType = CMD_FTYPE_EXTENDED, the CD is followed by CD.sCount
//  EXTCD structures.
//
//*****************************************************************************

typedef struct
{
    BYTE    fGeneral;       // general purpose bit fields
    BYTE    bCmdCbId;       // command callback id. 0 iff no callback
    WORD    wCount;
    WORD    wLength;        // length of the command
} CD, *PCD;

#define LPCD    PCD     /* For UNIDRV code */

//
// for cd.fGeneral field
//

#define CMD_GEN_MAY_REPEAT 0x0001 // Command may be sent multiple times if
                                  // the parameter exceeds sMax


#define CMD_MARKER          '%'

//
//  EXTCD - Extended portion of the  Command Descriptor.  This structure
//  follows rgchCmd[] if cd.wType is 1.
//

typedef struct
{
    WORD    fGeneral;   // Modes, special command formats.
    short   sUnitDiv;   // Units relative to master units (divide by)
    short   sUnitMult;  // Units to multiply master units by, 1 usually
    short   sUnitAdd;   // Units to add to parameter value, usually 0
    short   sPreAdd;    // Units to add to master units prior to multiplication
    short   sMax;       // Maximum parameter allowed in command units.
    short   sMin;       // Minimum parameter allowed in command units.
                        // normanh following added for GPC3 .
    WORD    wParam;     // Parameter ordinal for multiple parameters
} EXTCD;
typedef EXTCD UNALIGNED *PEXTCD ;

#define LPEXTCD  PEXTCD         /* For UNIDRV code */

#define XCD_GEN_RESERVED   0x0001   // Previously defined, now unused
#define XCD_GEN_NO_MAX     0x0002   // Set if there is no max (sMax ignored)
#define XCD_GEN_NO_MIN     0x0004   // Set if there is no min (sMin ignored)
#define XCD_GEN_MODULO     0x0008   // Set if divide should be modulo

#define CMD_FMODE_SETMODE  0x0001

//
//   pre-defined text qualities
//

#define DMTEXT_FIRST        DMTEXT_LQ
#define DMTEXT_LQ           1
#define DMTEXT_NLQ          2
#define DMTEXT_MEMO         3
#define DMTEXT_DRAFT        4
#define DMTEXT_TEXT         5
#define DMTEXT_LAST         DMTEXT_TEXT

#define DMTEXT_USER         256 // lower bound for user-defined text quality id

//
//   pre-defined paper qualities
//

#define DMPAPQUAL_FIRST     DMPAPQUAL_NORMAL
#define DMPAPQUAL_NORMAL            1
#define DMPAPQUAL_TRANSPARENT       2
#define DMPAPQUAL_LAST      DMPAPQUAL_TRANSPARENT

//
//   misc
//

#define NOT_USED                  -1        // the value should not be used.
#define NOOCD                     0xFFFF           // command does not exist

// added by Derry Durand [derryd], June  95 for WDL release


#endif // _UNI16GPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\uni16cid.h ===
//--------------------------------------------------------------------------//
//  Copyright (c) 1996  - 1999  Microsoft Corporation
// Filename: cmdid.h
//
// This file contains constants defined for indicies of PDEVICE.rgocd[].
// It is used as the second parameter of WriteChannel(). If a mini driver
// wants to call-back WriteChannel(), it must include this file.
//
// Created: 10/11/90    zhanw
//
// 10/25/96 -zhanw-
//  copied from \\trango\slmro tree. Remove vector commands.
//--------------------------------------------------------------------------//

// keep parentheses around constants to avoid potential errors in expansions.

//****************
// basic commands:
//****************
// --- from RESOLUTION:
#define CMD_RES_FIRST       0                                       // 0
#define CMD_RES_SELECTRES           (CMD_RES_FIRST + RES_OCD_SELECTRES)     // 0
#define CMD_RES_BEGINGRAPHICS       (CMD_RES_FIRST + RES_OCD_BEGINGRAPHICS) // 1
#define CMD_RES_ENDGRAPHICS         (CMD_RES_FIRST + RES_OCD_ENDGRAPHICS)   // 2
#define CMD_RES_SENDBLOCK           (CMD_RES_FIRST + RES_OCD_SENDBLOCK)     // 3
#define CMD_RES_ENDBLOCK            (CMD_RES_FIRST + RES_OCD_ENDBLOCK)      // 4
#define CMD_RES_LAST        (CMD_RES_FIRST + RES_OCD_MAX - 1)       // 4

// --- from COMPRESSMODE
#define CMD_CMP_FIRST       (CMD_RES_LAST + 1)                      // 5
#define CMD_CMP_NONE                (CMD_CMP_FIRST + 0)     // 5
#define CMD_CMP_RLE                 (CMD_CMP_FIRST + 1)     // 6
#define CMD_CMP_TIFF                (CMD_CMP_FIRST + 2)     // 7
#define CMD_CMP_DELTAROW            (CMD_CMP_FIRST + 3)     // 8
#define CMD_CMP_BITREPEAT           (CMD_CMP_FIRST + 4)     // 9
#define CMD_CMP_FE_RLE              (CMD_CMP_FIRST + 5)     // 10
#define CMD_CMP_LAST        (CMD_CMP_FE_RLE)                        // 10

// --- from PAGECONTROL structure
#define CMD_PC_FIRST        (CMD_CMP_LAST + 1)                      // 11
#define CMD_PC_BEGIN_DOC            (CMD_PC_FIRST + PC_OCD_BEGIN_DOC)   // 11
#define CMD_PC_BEGIN_PAGE           (CMD_PC_FIRST + PC_OCD_BEGIN_PAGE)  // 12
#define CMD_PC_DUPLEX_ON            (CMD_PC_FIRST + PC_OCD_DUPLEX_ON)   // 13
#define CMD_PC_ENDDOC               (CMD_PC_FIRST + PC_OCD_ENDDOC)      // 14
#define CMD_PC_ENDPAGE              (CMD_PC_FIRST + PC_OCD_ENDPAGE)     // 15
#define CMD_PC_DUPLEX_OFF           (CMD_PC_FIRST + PC_OCD_DUPLEX_OFF)  // 16
#define CMD_PC_ABORT                (CMD_PC_FIRST + PC_OCD_ABORT)       // 17
#define CMD_PC_PORTRAIT             (CMD_PC_FIRST + PC_OCD_PORTRAIT)    // 18
#define CMD_PC_ORIENTATION          (CMD_PC_PORTRAIT)                   // 18
#define CMD_PC_LANDSCAPE            (CMD_PC_FIRST + PC_OCD_LANDSCAPE)   // 19
#define CMD_PC_MULT_COPIES          (CMD_PC_FIRST + PC_OCD_MULT_COPIES) // 20
#define CMD_PC_DUPLEX_VERT          (CMD_PC_FIRST + PC_OCD_DUPLEX_VERT) // 21
#define CMD_PC_DUPLEX_HORZ          (CMD_PC_FIRST + PC_OCD_DUPLEX_HORZ) // 22
#define CMD_PC_PRINT_DIR            (CMD_PC_FIRST + PC_OCD_PRN_DIRECTION) // 23
#define CMD_PC_JOB_SEPARATION       (CMD_PC_FIRST + PC_OCD_JOB_SEPARATION) // 24
#define CMD_PC_LAST         (CMD_PC_FIRST + PC_OCD_MAX - 1)         // 24


// --- from CURSORMOVE
#define CMD_CM_FIRST        (CMD_PC_LAST + 1)                       // 25
#define CMD_CM_XM_ABS               (CMD_CM_FIRST + CM_OCD_XM_ABS)
#define CMD_CM_XM_REL               (CMD_CM_FIRST + CM_OCD_XM_REL)
#define CMD_CM_XM_RELLEFT           (CMD_CM_FIRST + CM_OCD_XM_RELLEFT)
#define CMD_CM_YM_ABS               (CMD_CM_FIRST + CM_OCD_YM_ABS)
#define CMD_CM_YM_REL               (CMD_CM_FIRST + CM_OCD_YM_REL)
#define CMD_CM_YM_RELUP             (CMD_CM_FIRST + CM_OCD_YM_RELUP)
#define CMD_CM_YM_LINESPACING       (CMD_CM_FIRST + CM_OCD_YM_LINESPACING)
#define CMD_CM_XY_REL               (CMD_CM_FIRST + CM_OCD_XY_REL)
#define CMD_CM_XY_ABS               (CMD_CM_FIRST + CM_OCD_XY_ABS)
#define CMD_CM_CR                   (CMD_CM_FIRST + CM_OCD_CR)
#define CMD_CM_LF                   (CMD_CM_FIRST + CM_OCD_LF)
#define CMD_CM_FF                   (CMD_CM_FIRST + CM_OCD_FF)
#define CMD_CM_BS                   (CMD_CM_FIRST + CM_OCD_BS)
#define CMD_CM_UNI_DIR              (CMD_CM_FIRST + CM_OCD_UNI_DIR)
#define CMD_CM_UNI_DIR_OFF          (CMD_CM_FIRST + CM_OCD_UNI_DIR_OFF)
#define CMD_CM_PUSH_POS             (CMD_CM_FIRST + CM_OCD_PUSH_POS)
#define CMD_CM_POP_POS              (CMD_CM_FIRST + CM_OCD_POP_POS)
#define CMD_CM_LAST         (CMD_CM_FIRST + CM_OCD_MAX - 1)         // 41

// --- from FONTSIMULATION
#define CMD_FS_FIRST        (CMD_CM_LAST + 1)                       // 42
#define CMD_FS_BOLD_ON              (CMD_FS_FIRST + FS_OCD_BOLD_ON)
#define CMD_FS_BOLD_OFF             (CMD_FS_FIRST + FS_OCD_BOLD_OFF)
#define CMD_FS_ITALIC_ON            (CMD_FS_FIRST + FS_OCD_ITALIC_ON)
#define CMD_FS_ITALIC_OFF           (CMD_FS_FIRST + FS_OCD_ITALIC_OFF)
#define CMD_FS_UNDERLINE_ON         (CMD_FS_FIRST + FS_OCD_UNDERLINE_ON)
#define CMD_FS_UNDERLINE_OFF        (CMD_FS_FIRST + FS_OCD_UNDERLINE_OFF)
#define CMD_FS_DOUBLEUNDERLINE_ON   (CMD_FS_FIRST + FS_OCD_DOUBLEUNDERLINE_ON)
#define CMD_FS_DOUBLEUNDERLINE_OFF  (CMD_FS_FIRST + FS_OCD_DOUBLEUNDERLINE_OFF)
#define CMD_FS_STRIKETHRU_ON        (CMD_FS_FIRST + FS_OCD_STRIKETHRU_ON)
#define CMD_FS_STRIKETHRU_OFF       (CMD_FS_FIRST + FS_OCD_STRIKETHRU_OFF)
#define CMD_FS_WHITE_TEXT_ON        (CMD_FS_FIRST + FS_OCD_WHITE_TEXT_ON)
#define CMD_FS_WHITE_TEXT_OFF       (CMD_FS_FIRST + FS_OCD_WHITE_TEXT_OFF)
#define CMD_FS_SINGLE_BYTE          (CMD_FS_FIRST + FS_OCD_SINGLE_BYTE)
#define CMD_FS_DOUBLE_BYTE          (CMD_FS_FIRST + FS_OCD_DOUBLE_BYTE)
#define CMD_FS_VERT_ON              (CMD_FS_FIRST + FS_OCD_VERT_ON)
#define CMD_FS_VERT_OFF             (CMD_FS_FIRST + FS_OCD_VERT_OFF)
#define CMD_FS_LAST         (CMD_FS_VERT_OFF)                       // 57

// from DEVCOLOR
#define CMD_DC_FIRST        (CMD_FS_LAST + 1)                       // 58
#define CMD_DC_TC_FIRST             (CMD_DC_FIRST)
#define CMD_DC_TC_BLACK             (CMD_DC_TC_FIRST + DC_OCD_TC_BLACK)
#define CMD_DC_TC_RED               (CMD_DC_TC_FIRST + DC_OCD_TC_RED)
#define CMD_DC_TC_GREEN             (CMD_DC_TC_FIRST + DC_OCD_TC_GREEN)
#define CMD_DC_TC_YELLOW            (CMD_DC_TC_FIRST + DC_OCD_TC_YELLOW)
#define CMD_DC_TC_BLUE              (CMD_DC_TC_FIRST + DC_OCD_TC_BLUE)
#define CMD_DC_TC_MAGENTA           (CMD_DC_TC_FIRST + DC_OCD_TC_MAGENTA)
#define CMD_DC_TC_CYAN              (CMD_DC_TC_FIRST + DC_OCD_TC_CYAN)
#define CMD_DC_TC_WHITE             (CMD_DC_TC_FIRST + DC_OCD_TC_WHITE)
#define CMD_DC_SETCOLORMODE         (CMD_DC_TC_FIRST + DC_OCD_SETCOLORMODE) //66
#define CMD_DC_PC_START             (CMD_DC_TC_FIRST + DC_OCD_PC_START)
#define CMD_DC_PC_ENTRY             (CMD_DC_TC_FIRST + DC_OCD_PC_ENTRY)
#define CMD_DC_PC_END               (CMD_DC_TC_FIRST + DC_OCD_PC_END)
#define CMD_DC_PC_SELECTINDEX       (CMD_DC_TC_FIRST + DC_OCD_PC_SELECTINDEX)
#define CMD_DC_SETMONOMODE          (CMD_DC_TC_FIRST + DC_OCD_SETMONOMODE)  // 71

#define DC_NUM_OCDS_USED            (DC_OCD_SETMONOMODE + 1)

// these are from DEVCOLOR.orgocdPlanes:
#define CMD_DC_GC_FIRST             (CMD_DC_SETMONOMODE + 1)
#define CMD_DC_GC_PLANE1            (CMD_DC_GC_FIRST + 0)       // 72
#define CMD_DC_GC_PLANE2            (CMD_DC_GC_FIRST + 1)       // 73
#define CMD_DC_GC_PLANE3            (CMD_DC_GC_FIRST + 2)       // 74
#define CMD_DC_GC_PLANE4            (CMD_DC_GC_FIRST + 3)       // 75
#define CMD_DC_LAST         (CMD_DC_GC_PLANE4)                      // 75


// --- from RECTFILL
#define CMD_RF_FIRST        (CMD_DC_LAST + 1)                       // 76
#define CMD_RF_X_SIZE               (CMD_RF_FIRST + RF_OCD_X_SIZE)
#define CMD_RF_Y_SIZE               (CMD_RF_FIRST + RF_OCD_Y_SIZE)
#define CMD_RF_GRAY_FILL            (CMD_RF_FIRST + RF_OCD_GRAY_FILL)
#define CMD_RF_WHITE_FILL           (CMD_RF_FIRST + RF_OCD_WHITE_FILL)
#define CMD_RF_LAST         (CMD_RF_WHITE_FILL)                     // 79

// --- from DOWNLOADINFO
#define CMD_DLI_FIRST       (CMD_RF_LAST + 1)   // 80
#define CMD_BEGIN_DL_JOB        (CMD_DLI_FIRST + DLI_OCD_BEGIN_DL_JOB) //81
#define CMD_BEGIN_FONT_DL       (CMD_DLI_FIRST + DLI_OCD_BEGIN_FONT_DL)
#define CMD_SET_FONT_ID         (CMD_DLI_FIRST + DLI_OCD_SET_FONT_ID)
#define CMD_SEND_FONT_DCPT      (CMD_DLI_FIRST + DLI_OCD_SEND_FONT_DESCRIPTOR)
#define CMD_SELECT_FONT_ID      (CMD_DLI_FIRST + DLI_OCD_SELECT_FONT_ID)
#define CMD_SET_CHAR_CODE       (CMD_DLI_FIRST + DLI_OCD_SET_CHAR_CODE)
#define CMD_SEND_CHAR_DCPT      (CMD_DLI_FIRST + DLI_OCD_SEND_CHAR_DESCRIPTOR)
#define CMD_END_FONT_DL         (CMD_DLI_FIRST + DLI_OCD_END_FONT_DL)
#define CMD_MAKE_PERM           (CMD_DLI_FIRST + DLI_OCD_MAKE_PERM)
#define CMD_MAKE_TEMP           (CMD_DLI_FIRST + DLI_OCD_MAKE_TEMP)
#define CMD_END_DL_JOB          (CMD_DLI_FIRST + DLI_OCD_END_DL_JOB)
#define CMD_DEL_FONT            (CMD_DLI_FIRST + DLI_OCD_DEL_FONT)
#define CMD_DEL_ALL_FONTS       (CMD_DLI_FIRST + DLI_OCD_DEL_ALL_FONTS)
#define CMD_SET_SECOND_FONT_ID  (CMD_DLI_FIRST + DLI_OCD_SET_SECOND_FONT_ID)
#define CMD_SELECT_SECOND_FONT_ID (CMD_DLI_FIRST + DLI_OCD_SELECT_SECOND_FONT_ID)
#define CMD_DLI_LAST        (CMD_DLI_FIRST + DLI_OCD_MAX - 1)   // 95

#define MAXCMD              (CMD_DLI_LAST + 1)      // 96

//*******************
// extended commands:
//*******************
#define CMD_TEXTQUALITY     (MAXCMD + 0) // command to select text quality
#define CMD_PAPERSOURCE     (MAXCMD + 1) // command to select paper source
#define CMD_PAPERQUALITY    (MAXCMD + 2) // command to select paper quality
#define CMD_PAPERDEST       (MAXCMD + 3) // selects paper destination
#define CMD_PAPERSIZE       (MAXCMD + 4) // selects paper size (Portrait or all)
#define CMD_PAPERSIZE_LAND  (MAXCMD + 5) // select landscape paper size
#define CMD_PAGEPROTECT_ON  (MAXCMD + 6) // selects page protection On
#define CMD_PAGEPROTECT_OFF (MAXCMD + 7) // selects page protection Off
#define CMD_IMAGECONTROL    (MAXCMD + 8) // selects image control option
#define CMD_PRINTDENSITY    (MAXCMD + 9) // selects image control option

#define MAXECMD             10  // total number of extended commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\xlraster.h ===
/*++

 Copyright (c) 1996  - 1999  Microsoft Corporation

 Module Name:

    common.h

Abstract:

    This file contain XL raster mode prorotypes.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/25/00 -eigos-
        Created

    dd-mm-yy -author-
         description

--*/

#ifndef _XLRASTER_H_

#ifndef _PCLXLE_H_
typedef enum
{
    eDirectPixel = 0,
    eIndexedPixel = 1
} ColorMapping;

typedef enum
{
    eNoCompression = 0,
    eRLECompression = 1,
    eJPEGCompression = 2
} CompressMode;
#endif

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
PCLXLSendBitmap(
    PDEVOBJ pdevobj,
    ULONG   ulInputBPP,
    LONG    lHeight,
    LONG    lScanlineWidth,
    INT     iLeft,
    INT     iRight,
    PBYTE   pbData,
    PDWORD  pdwcbOut);

HRESULT
PCLXLReadImage(
    PDEVOBJ pdevobj,
    DWORD  dwBlockHeight,
    CompressMode CMode);

HRESULT
PCLXLSetCursor(
    PDEVOBJ pdevobj,
    ULONG   ulX,
    ULONG   ulY);

HRESULT
PCLXLFreeRaster(
    PDEVOBJ pdevobj);

HRESULT
PCLXLResetPalette(
    PDEVOBJ pdevobj);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H


#include <lib.h>

#include <PRINTOEM.H>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\inc\vectorif.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

        vectorif.h

Abstract:

        Interface between Control module and Vector module

Environment:

        Windows NT Unidrv driver

Revision History:

        02/29/00 -hsingh-
                Created

        mm-dd-yy -author-
                description

--*/


#ifndef _VECTORIF_H_
#define _VECTORIF_H_

#define HANDLE_VECTORHOOKS(pdev, ep, pfn, resultType, args) \
        if ((pdev)->pVectorProcs != NULL && \
            ((PVMPROCS)(pdev)->pVectorProcs)->pfn != NULL && \
            (pdev)->dwVMCallingFuncID != ep) \
        { \
            resultType result; \
            DWORD      dwCallerFuncID;\
            dwCallerFuncID = (pdev)->dwVMCallingFuncID;\
            (pdev)->dwVMCallingFuncID = ep; \
            (pdev)->devobj.pdevOEM = (pdev)->pVectorPDEV; \
            result = (((PVMPROCS)(pdev)->pVectorProcs)->pfn) args; \
            (pdev)->dwVMCallingFuncID = dwCallerFuncID; \
            return result; \
        }

#define HANDLE_VECTORPROCS_RET(pdev, pfn, retval, args) \
    if ((pdev)->pVectorProcs != NULL && \
        ((PVMPROCS)(pdev)->pVectorProcs)->pfn != NULL ) \
    { \
        (pdev)->devobj.pdevOEM = (pdev)->pVectorPDEV; \
        retval = (((PVMPROCS)(pdev)->pVectorProcs)->pfn) args;\
    }

#define HANDLE_VECTORPROCS(pdev, pfn, args) \
    if ((pdev)->pVectorProcs != NULL && \
        ((PVMPROCS)(pdev)->pVectorProcs)->pfn != NULL ) \
    { \
        (pdev)->devobj.pdevOEM = (pdev)->pVectorPDEV; \
        (((PVMPROCS)(pdev)->pVectorProcs)->pfn) args;\
    }

BOOL
VMInit (
        PDEV    *pPDev,
        DEVINFO *pDevInfo,
        GDIINFO *pGDIInfo
        );

//
// This structure provides a table of pointers to each function exported 
// by the plugin.
// The first part consists of functions defined in oemkm.h. 
// under the heading . "Unidrv specific COM wrappers"
// The second part consists of DDI's
//
//
// The order of functions listed is same as the order in 
// static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
//
typedef struct _VMPROCS {

    //
    // Part. 1
    // Functions listed in oemkm.h
    //
        BOOL
        (*VMDriverDMS)(
                PVOID   pdevobj,
                PVOID   pvBuffer,
                DWORD   cbSize,
                PDWORD  pcbNeeded
                );

        INT
        (*VMCommandCallback)(
                PDEVOBJ pdevobj,
                DWORD   dwCmdCbID,
                DWORD   dwCount,
                PDWORD  pdwParams
                );

        LONG
        (*VMImageProcessing)(
                PDEVOBJ             pdevobj,
                PBYTE               pSrcBitmap,
                PBITMAPINFOHEADER   pBitmapInfoHeader,
                PBYTE               pColorTable,
                DWORD               dwCallbackID,
                PIPPARAMS           pIPParams,
                OUT PBYTE           *ppbResult
                );

        LONG
        (*VMFilterGraphics)(
                PDEVOBJ     pdevobj,
                PBYTE       pBuf,
                DWORD       dwLen
                );

        
        LONG
        (*VMCompression)(
                PDEVOBJ     pdevobj,
                PBYTE       pInBuf,
                PBYTE       pOutBuf,
                DWORD       dwInLen,
                DWORD       dwOutLen,
                INT     *piResult
                );

        LONG
        (*VMHalftonePattern)(
                PDEVOBJ     pdevobj,
                PBYTE       pHTPattern,
                DWORD       dwHTPatternX,
                DWORD       dwHTPatternY,
                DWORD       dwHTNumPatterns,
                DWORD       dwCallbackID,
                PBYTE       pResource,
                DWORD       dwResourceSize
                );


        LONG
        (*VMMemoryUsage)(
                PDEVOBJ         pdevobj,
                POEMMEMORYUSAGE pMemoryUsage
                );

        LONG
        (*VMTTYGetInfo)(
                PDEVOBJ     pdevobj,
                DWORD       dwInfoIndex,
                PVOID       pOutputBuf,
                DWORD       dwSize,
                DWORD       *pcbcNeeded
                );

        LONG
        (*VMDownloadFontHeader)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG
        (*VMDownloadCharGlyph)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                HGLYPH      hGlyph,
                PDWORD      pdwWidth,
                OUT DWORD   *pdwResult
                );

        LONG
        (*VMTTDownloadMethod)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG
        (*VMOutputCharStr)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                DWORD       dwType,
                DWORD       dwCount,
                PVOID       pGlyph
                );

        
        LONG
        (*VMSendFontCmd)(
                PDEVOBJ      pdevobj,
                PUNIFONTOBJ  pUFObj,
                PFINVOCATION pFInv
                );

        BOOL
        (*VMTextOutAsBitmap)(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

    //
    // Part 2.
    // Functions listed in enable.c
    // The order of functions listed is same as the order in 
    // static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
    //
        PDEVOEM
        (*VMEnablePDEV)(
                PDEVOBJ   pdevobj,
                PWSTR     pPrinterName,
                ULONG     cPatterns,
                HSURF    *phsurfPatterns,
                ULONG     cjGdiInfo,
                GDIINFO  *pGdiInfo,
                ULONG     cjDevInfo,
                DEVINFO  *pDevInfo,
                DRVENABLEDATA  *pded        // Unidrv's hook table
                );

        BOOL
        (*VMResetPDEV)(
                PDEVOBJ  pPDevOld,
                PDEVOBJ  pPDevNew
                );

        VOID
        (*VMCompletePDEV)(
                DHPDEV  dhpdev,
                HDEV    hdev
                );

        VOID
        (*VMDisablePDEV)(
                PDEVOBJ pPDev
                );

        BOOL
        (*VMEnableSurface)(
                PDEVOBJ pPDev
                );

        VOID
        (*VMDisableSurface)(
                PDEVOBJ pPDev
                );

        VOID
        (*VMDisableDriver)(
                VOID
                );

        BOOL
        (*VMStartDoc)(
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL
        (*VMStartPage) (
                SURFOBJ *pso
                );

        BOOL
        (*VMSendPage)(
                SURFOBJ *pso
                );

        BOOL
        (*VMEndDoc)(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL
        (*VMStartBanding)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*VMNextBand)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*VMPaint)(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL
        (*VMBitBlt)(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL
        (*VMStretchBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

#ifndef WINNT_40
        BOOL
        (*VMStretchBltROP)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );

        BOOL
        (*VMPlgBlt)(
                SURFOBJ         *psoDst,
                SURFOBJ         *psoSrc,
                SURFOBJ         *psoMask,
                CLIPOBJ         *pco,
                XLATEOBJ        *pxlo,
                COLORADJUSTMENT *pca,
                POINTL          *pptlBrushOrg,
                POINTFIX        *pptfixDest,
                RECTL           *prclSrc,
                POINTL          *pptlMask,
                ULONG           iMode
                );
#endif  //ifndef WINNT_40

        BOOL
        (*VMCopyBits)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        ULONG
        (*VMDitherColor)(
                DHPDEV  dhpdev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL
        (*VMRealizeBrush)(
                BRUSHOBJ   *pbo,
                SURFOBJ    *psoTarget,
                SURFOBJ    *psoPattern,
                SURFOBJ    *psoMask,
                XLATEOBJ   *pxlo,
                ULONG       iHatch
                );

        BOOL 
        (*VMLineTo)(
                SURFOBJ    *pso,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL      *prclBounds,
                MIX         mix
                );
        
        BOOL
        (*VMStrokePath)(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                LINEATTRS  *plineattrs,
                MIX         mix
                );
        
        BOOL
        (*VMFillPath)(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                MIX         mix,
                FLONG       flOptions 
                );
        
        BOOL
        (*VMStrokeAndFillPath)(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pboStroke,
                LINEATTRS  *plineattrs,
                BRUSHOBJ   *pboFill,
                POINTL     *pptlBrushOrg,
                MIX         mixFill,
                FLONG       flOptions
                );
        
#ifndef WINNT_40
        BOOL
        (*VMGradientFill)(
                SURFOBJ    *psoDest,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                TRIVERTEX  *pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL      *prclExtents,
                POINTL     *pptlDitherOrg,
                ULONG       ulMode
                );

        BOOL
        (*VMAlphaBlend)(
                SURFOBJ    *psoDest,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDest,
                RECTL      *prclSrc,
                BLENDOBJ   *pBlendObj
                );

        BOOL
        (*VMTransparentBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                ULONG      iTransColor,
                ULONG      ulReserved
                );
#endif // ifndef WINNT_40

        BOOL
        (*VMTextOut)(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

        ULONG
        (*VMEscape)(
                SURFOBJ    *pso,
                ULONG       iEsc,
                ULONG       cjIn,
                PVOID       pvIn,
                ULONG       cjOut,
                PVOID       pvOut
                );

        PIFIMETRICS
        (*VMQueryFont)(
                DHPDEV      dhpdev,
                ULONG_PTR   iFile,
                ULONG       iFace,
                ULONG_PTR  *pid
                );

        PVOID
        (*VMQueryFontTree)(
                DHPDEV      dhpdev,
                ULONG_PTR   iFile,
                ULONG       iFace,
                ULONG       iMode,
                ULONG_PTR  *pid 
                );

        LONG
        (*VMQueryFontData)(
                DHPDEV      dhpdev,
                FONTOBJ    *pfo,
                ULONG       iMode,
                HGLYPH      hg,
                GLYPHDATA  *pgd,
                PVOID       pv,
                ULONG       cjSize
                );

        ULONG
        (*VMGetGlyphMode)(
                DHPDEV  dhpdev,
                FONTOBJ *pfo
                );

        ULONG
        (*VMFontManagement)(
                SURFOBJ *pso,
                FONTOBJ *pfo,
                ULONG   iMode,
                ULONG   cjIn,
                PVOID   pvIn,
                ULONG   cjOut,
                PVOID   pvOut
                );

        BOOL
        (*VMQueryAdvanceWidths)(
                DHPDEV  dhpdev,
                FONTOBJ *pfo,
                ULONG   iMode,
                HGLYPH *phg,
                PVOID  *pvWidths,
                ULONG   cGlyphs
                );

}VMPROCS, * PVMPROCS;

#endif  // !_VECTORIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}


//
// Functions for outputting debug messages
//

VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\ddicmdcb\ddihooks.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    ddihooks.c

Abstract:

    Implementation of OEM DDI hooks (all drawing DDI hooks)

    This test DLL hooks out every DDI call. In reality, an OEM DLL does
    not need to hook out every DDI unless there is a reason to. The only two
    required functions are OEMEnablePDEV and OEMDisablePDEV, which must be
    exported.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMBitBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTrg->dhpdev;
    ASSERT_VALID_PDEVOBJ(pdevobj);

    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    ASSERT(poempdev);

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));

}

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStretchBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStretchBltROP() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4));


}

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMCopyBits() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            pptlSrc));

}

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMPlgBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMAlphaBlend() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            prclSrc,
            pBlendObj));

}

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMGradientFill() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));

}

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));

}

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStokePath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));

}

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));

}

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));

}

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
}

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));

}

#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMEndPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));

}

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));

}

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));

}

////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));

}

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));

}

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));

}

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));

}

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMFontManagement() entry.\r\n"));

    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));

}

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMNextBand() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));

}

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMStartBanding() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));


}

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMDitherColor() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));

}

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMPaint() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));

}

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMLineTo() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));

}

BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    DbgPrint(DLLTEXT("OEMTransparentBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\ddicmdcb\cmdcb.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// command callback ID's for "test.gpd"
//
#define CMDCB_SELECTPORTRAIT    1
#define CMDCB_SELECTLANDSCAPE   2
#define CMDCB_SENDBLOCKDATA     3


static  int
iDwtoA( LPSTR buf, DWORD n )
{
    int     i, j;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    DbgPrint(DLLTEXT("OEMCommandCallback() entry.\r\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    switch (dwCmdCbID)
    {
    case CMDCB_SELECTPORTRAIT:
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, "\x1B&l0O", 5);
        break;

    case CMDCB_SELECTLANDSCAPE:
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, "\x1B&l1O", 5);
        break;

    case CMDCB_SENDBLOCKDATA:
    {
        //
        // this command requires one parameter. Compose the string first.
        //
        BYTE    abSBDCmd[16];
        INT     i = 0;

        if (dwCount < 1 || !pdwParams)
            return 0;       // cannot do anything

        abSBDCmd[i++] = '\x1B';
        abSBDCmd[i++] = '*';
        abSBDCmd[i++] = 'b';
        i += iDwtoA(&abSBDCmd[i], *pdwParams);
        abSBDCmd[i++] = 'W';

        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, abSBDCmd, i);

        break;
    }
    }
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\ddicmdcb\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}


//
// Functions for outputting debug messages
//

VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\rastercb\ht24to4.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ht24to4.c

Abstract:

    Implementation of the test file to convert 24 bit data to
    4 bit data for OEMImageProcessing callback.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/11/97 -alvins-
        Created

--*/
#include "pdev.h"

//
// pattern must have a multiple of 2 width
//
#define PATWIDTH 8
#define PATHEIGHT 8

BYTE  gFine8x8[PATWIDTH*PATHEIGHT] =
{
    0*4+64, 0*4+128, 8*4+64, 8*4+128, 2*4+64, 2*4+128, 10*4+64, 10*4+128,
    0*4+192, 0*4+1, 8*4+192, 8*4, 2*4+192, 2*4, 10*4+192, 10*4,
    12*4+64, 12*4+128, 4*4+64, 4*4+128, 14*4+64, 14*4+128, 6*4+64, 6*4+128,
    12*4+192, 12*4, 4*4+192, 4*4, 14*4+192, 14*4, 6*4+192, 6*4,
    3*4+64, 3*4+128, 11*4+64, 11*4+128, 1*4+64, 1*4+128, 9*4+64, 9*4+128,
    3*4+192, 3*4, 11*4+192, 11*4, 1*4+192, 1*4, 9*4+192, 9*4,
    15*4+64, 15*4+128, 7*4+64, 7*4+128, 13*4+64, 13*4+128, 5*4+64, 5*4+128,
    15*4+192, 15*4, 7*4+192, 7*4, 13*4+192, 13*4, 5*4+192, 5*4
};


VOID Dither24to4(
    BYTE *pOrgIn,
    BYTE *pOrgOut,
    int  x,
    int  y,
    DWORD dwCallbackID
)
{
    int i,j;
    int iInScanBytes;
    int iOutScanBytes;
    BYTE *pIn,*pOut,*pPat,*pPatEnd;
    BYTE arBlackGen[256];

    //
    // generate NULL lookup table for three color
    //
    if (dwCallbackID == 3)
    {
        for (i = 0;i < 256;i++)
            arBlackGen[i] = i;
    }
    //
    // generate look up table to create black plane
    //
    else
    {
        for (i = 0;i < 256;i++)
        {
            BYTE bOut = i;
            if ((bOut & 0x07) == 0x07)
                bOut = (bOut & ~0x07) | 0x08;
            if ((bOut & 0x70) == 0x70)
                bOut = (bOut & ~0x70) | 0x80;
            arBlackGen[i] = bOut;
        }
    }
    //
    // calculate 24 bit input scan line size to nearest dword
    //
    iInScanBytes = ((x * 3) + 3) & ~3; 
    //
    // calculate 4 bit output scan line size to nearest dword
    //
    iOutScanBytes = (((x * 4) + 31) & ~31) / 8;
    
    //
    // loop once per scan line
    //
    for (i = 0;i < y;i++)
    {    
        pIn = pOrgIn;
        pOut = pOrgOut;
        pOrgIn += iInScanBytes;
        pOrgOut += iOutScanBytes;
        pPat = &gFine8x8[(i % PATHEIGHT) * PATWIDTH];
        pPatEnd = pPat + PATWIDTH;

        j = x >> 1;
        while (j--)
        {
            BYTE bOut = 0;
            if (pIn[0] < pPat[0])
                bOut |= 0x10;
            if (pIn[1] < pPat[0])
                bOut |= 0x20;
            if (pIn[2] < pPat[0])
                bOut |= 0x40;
            
            if (pIn[3] < pPat[1])
                bOut |= 0x01;
            if (pIn[4] < pPat[1])
                bOut |= 0x02;
            if (pIn[5] < pPat[1])
                bOut |= 0x04;

            *pOut++ = arBlackGen[bOut];
            pIn += 6;
            if ((pPat += 2) >= pPatEnd)
                pPat -= PATWIDTH;
        }
        // halftone last pixel if odd count
        //
        if (x & 1)
        {
            BYTE bOut = 0;
            if (pIn[0] < pPat[0])
                bOut |= 0x10;
            if (pIn[1] < pPat[0])
                bOut |= 0x20;
            if (pIn[2] < pPat[0])
                bOut |= 0x40;
            *pOut++ = arBlackGen[bOut];
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\fontcb\enable.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of OEM DDI exports.
        OEMEnablePDEV (required)
        OEMDisablePDEV (required)
        OEMResetPDEV (optional)

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    DbgPrint(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    //
    // Fill in OEMDEV as you need
    //

    poempdev->dwReserved[0] = 0xFFFFFFFF;


    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    DbgPrint(DLLTEXT("OEMDisablePDEV() entry.\r\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM);

    //
    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    MemFree(pdevobj->pdevOEM);

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    DbgPrint(DLLTEXT("OEMResetPDEV() entry.\r\n"));

    ASSERT(VALID_PDEVOBJ(pdevobjOld) && pdevobjOld->pdevOEM);
    ASSERT(VALID_PDEVOBJ(pdevobjNew) && pdevobjOld->pdevOEM);

    //
    // if you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\ddicmdcb\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H


#include "..\oemud.h"

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CDCB'      // Command Callback & DDI test dll
#define DLLTEXT(s)      __TEXT("DDICMDCB:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

//
// Warning: the following enum order must match the order in OEMHookFuncs[].
//
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};

typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // Unidrv's hook function pointer so it call back.
    //
    PFN     pfnUnidrv[MAX_DDI_HOOKS];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\fontcb\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H


#include "..\oemud.h"

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'FTCB'      // Raster module callback test dll
#define DLLTEXT(s)      __TEXT("FONTCB:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\ddicmdcb\enable.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of OEM DDI exports.
        OEMEnableDriver (optional)
        OEMEnablePDEV (required)
        OEMDisablePDEV (required)
        OEMResetPDEV (optional)
        OEMDisableDriver (optional)

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//
// If an OEM DLL hooks out any drawing DDI, it must export OEMEnableDriver which
// tells UNIDRV which functions it wants to hook. The following table is the
// maximum set of hooks. Note that an OEM DLL should not hook out OEMRealizeBrush
// unless it wants to draw graphics directly to the device surface.
//
static DRVFN OEMHookFuncs[] = {
    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) OEMPaint               },
    { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
    { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        }

};

BOOL APIENTRY OEMEnableDriver(
    DWORD dwOemIntfVersion,
    DWORD dwSize,
    PDRVENABLEDATA pded)
{
    DbgPrint(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOemIntfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        DbgPrint(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\r\n"));

        return FALSE;
    }

    pded->iDriverVersion = PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = OEMHookFuncs;

    //
    // debug initialize
    //
    MemDebugInit();

    return TRUE;
}

VOID
TestGetDriverSetting(
    PDEVOBJ pdevobj,
    BOOL    bDocSticky
    )

{
    DWORD   dwIndex, cbNeeded, cOptions;
    CHAR    buf[64];

    if (bDocSticky)
    {
        for (dwIndex=OEMGDS_UNIDM_GPDVER; dwIndex <= OEMGDS_UNIDM_FLAGS+1; dwIndex++)
        {
            if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    (PCSTR) dwIndex,
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
            {
                VERBOSE(("DrvGetDriverSetting %d: %d, %d\n", dwIndex, cbNeeded, cOptions));
            }
        }

        VERBOSE(("DrvGetDriverSetting OutputBin: "));

        if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    "OutputBin",
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
        {
            VERBOSE(("%s (%d, %d)\n", buf, cbNeeded, cOptions));
        }

    }
    else
    {
        for (dwIndex=OEMGDS_PRINTFLAGS; dwIndex <= OEMGDS_PROTOCOL+1; dwIndex++)
        {
            if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    (PCSTR) dwIndex,
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
            {
                VERBOSE(("DrvGetDriverSetting %d: %d, %d\n", dwIndex, cbNeeded, cOptions));
            }
        }

        VERBOSE(("DrvGetDriverSetting InstalledMemory: "));
        if (pdevobj->pDrvProcs->DrvGetDriverSetting(
                    pdevobj,
                    "InstalledMemory",
                    buf,
                    64,
                    &cbNeeded,
                    &cOptions))
        {
            VERBOSE(("%s (%d, %d)\n", buf, cbNeeded, cOptions));
        }

    }
}


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    DbgPrint(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            ASSERT(i == UD_DrvRealizeBrush);

            poempdev->pfnUnidrv[i] = NULL;
        }

    }

    //TestGetDriverSetting(pdevobj, TRUE);
    //TestGetDriverSetting(pdevobj, FALSE);

    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    DbgPrint(DLLTEXT("OEMDisablePDEV() entry.\r\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM);

    //
    // free memory for OEMPDEV and any memory block it allocates.
    //
    MemFree(pdevobj->pdevOEM);

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    DbgPrint(DLLTEXT("OEMResetPDEV() entry.\r\n"));

    ASSERT(VALID_PDEVOBJ(pdevobjOld) && pdevobjOld->pdevOEM);
    ASSERT(VALID_PDEVOBJ(pdevobjNew) && pdevobjOld->pdevOEM);

    //
    // if you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY OEMDisableDriver()
{
    DbgPrint(DLLTEXT("OEMDisableDriver() entry.\r\n"));

    //
    // debug cleanup
    //
    MemDebugCleanup();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\fontcb\font.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Implementation of font module customization:
        OEMDownloadFontHeader
        OEMDownloadCharGlyph
        OEMTTDownloadMethod
        OEMOutputCharStr
        OEMSendFontCmd

Environment:

    Windows NT Unidrv driver

Revision History:

    04/28/97 -eigos-
        Filled the functionality for PCL printers.

    04/07/97 -zhanw-
        Created the framework. The functions are not yet exported in
        oemud\oemud.def file. So they are not actually used by Unidrv.

--*/

#include "pdev.h"
#include "sf_pcl.h"
#include "fmnewgly.h"
#include "fmnewfm.h"

#define BBITS 8
#define PCL_MAX_CHAR_HEADER_SIZE  32767
#define SWAB(x) ((WORD)(x) = (WORD)((((x) >> 8)& 0xff) | (((x) << 8) &0xff00)))

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr);


DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj)
{
    DWORD       dwFontHdrCmdLen;
    WORD        wSend;
    SF_HEADER20 sfh;
    BYTE        aubPCLFontHdrCmd[20];

    DbgPrint(DLLTEXT("OEMDownloadFontHeader() entry.\r\n"));

    ZeroMemory( &sfh, sizeof(SF_HEADER20));

    //
    // Fill in PCL font header.
    //

    sfh.wSize     = wSend = sizeof( SF_HEADER20 );
    sfh.bFormat   = PCL_FM_RESOLUTION;
    sfh.wXResn    = (WORD)600;
    sfh.wYResn    = (WORD)600;
    sfh.bFontType = PCL_FT_8LIM;
    sfh.wSymSet   = 277;
    sfh.wBaseline = max( pUFObj->pIFIMetrics->rclFontBox.top,
                         pUFObj->pIFIMetrics->fwdWinAscender );
    sfh.wCellWide = max( pUFObj->pIFIMetrics->rclFontBox.right -
                         pUFObj->pIFIMetrics->rclFontBox.left + 1,
                         pUFObj->pIFIMetrics->fwdAveCharWidth );
    sfh.wCellHeight = (WORD)(1 +
                             max(pUFObj->pIFIMetrics->rclFontBox.top,
                                 pUFObj->pIFIMetrics->fwdWinAscender) -
                             min(-pUFObj->pIFIMetrics->fwdWinDescender,
                                 pUFObj->pIFIMetrics->rclFontBox.bottom ));
    sfh.bOrientation = 0;
    sfh.bSpacing    = (pUFObj->pIFIMetrics->flInfo & FM_INFO_CONSTANT_WIDTH) ?
                      0 : 1;
    sfh.wPitch      = 4 * pUFObj->pIFIMetrics->fwdAveCharWidth;
    sfh.wHeight     = 4 * sfh.wCellHeight;
    sfh.wXHeight    = 4 * (pUFObj->pIFIMetrics->fwdWinAscender / 2);
    sfh.sbWidthType = 0;
    sfh.bStyle      = pUFObj->pIFIMetrics->ptlCaret.x ? 0 : 1;
    sfh.sbStrokeW   = 0;
    sfh.bTypeface   = 0;
    sfh.bSerifStyle = 0;
    sfh.sbUDist     = -1;
    sfh.bUHeight    = 3;
    sfh.wTextHeight = 4 * (pUFObj->pIFIMetrics->fwdWinAscender +
                           pUFObj->pIFIMetrics->fwdWinDescender);
    sfh.wTextWidth  = 4 * pUFObj->pIFIMetrics->fwdAveCharWidth;
    sfh.bPitchExt  = 0;
    sfh.bHeightExt = 0;
    sfh.chName[0]  = 'C';
    sfh.chName[1]  = 'a';
    sfh.chName[2]  = 'c';
    sfh.chName[3]  = 'h';
    sfh.chName[4]  = 'e';
    sfh.chName[5]  = ' '; 
    _ltoa(pUFObj->ulFontID, &sfh.chName[6], 10 );

    SWAB( sfh.wSize );
    SWAB( sfh.wBaseline );
    SWAB( sfh.wCellWide );
    SWAB( sfh.wCellHeight );
    SWAB( sfh.wSymSet );
    SWAB( sfh.wPitch );
    SWAB( sfh.wHeight );
    SWAB( sfh.wXHeight );
    SWAB( sfh.wTextHeight );
    SWAB( sfh.wTextWidth );
    SWAB( sfh.wXResn );
    SWAB( sfh.wYResn );

    //
    //"\x1B)s%dW", cbSend
    //

    ZeroMemory( aubPCLFontHdrCmd, sizeof( aubPCLFontHdrCmd ) );

    dwFontHdrCmdLen = 0;
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = 0x1B;
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = ')';
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = 's';
    dwFontHdrCmdLen += strlen(_ltoa(wSend,
                                    &aubPCLFontHdrCmd[dwFontHdrCmdLen],
                                    10));
    aubPCLFontHdrCmd[dwFontHdrCmdLen++] = 'W';

    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                        aubPCLFontHdrCmd,
                                        dwFontHdrCmdLen);
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                        (BYTE *)&sfh,
                                        wSend );

    return 2048;
}


DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth)
{
    PGETINFO_STDVAR     pSV;
    GETINFO_GLYPHBITMAP GBmp;
    CH_HEADER           chh;
    GLYPHBITS          *pgb;

    DWORD dwCharHdrCmdLen, dwGetInfo;
    LONG  cbTotal, cbLines, cbSend;
    BYTE  aubPCLCharHdrCmd[20];

    DbgPrint(DLLTEXT("OEMDownloadCharGlyph() entry.\r\n"));
    DbgPrint(DLLTEXT("ulFontID = %d\n"), pUFObj->ulFontID);
    DbgPrint(DLLTEXT("hGlyph   = %d\n"), hGlyph);

    //
    // Get the character information.
    //

    dwGetInfo       =
    GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph     = hGlyph;
    GBmp.pGlyphData = NULL;

    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_GLYPHBITMAP,
                            (PVOID)&GBmp,
                            dwGetInfo,
                            &dwGetInfo))
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
        return 0;
    }
    pgb = GBmp.pGlyphData->gdf.pgb;

    DbgPrint(DLLTEXT("ptlOrigin.x   = %d\n"),pgb->ptlOrigin.x);
    DbgPrint(DLLTEXT("ptlOrigin.y   = %d\n"),pgb->ptlOrigin.y);
    DbgPrint(DLLTEXT("sizlBitmap.cx = %d\n"),pgb->sizlBitmap.cx);
    DbgPrint(DLLTEXT("sizlBitmap.cy = %d\n"),pgb->sizlBitmap.cy);

    //
    // Fill int character header.
    //

    ZeroMemory( &chh, sizeof( chh ) );           // Safe initial values

    chh.bFormat       = CH_FM_RASTER;
    chh.bContinuation = 0;
    chh.bDescSize     = sizeof( chh ) - sizeof( CH_CONT_HDR );
    chh.bClass        = CH_CL_BITMAP;

    chh.bOrientation = 0;        /* !!!LindsayH: NEED ORIENTATION!!! */

    chh.sLOff     = (short) pgb->ptlOrigin.x;
    chh.sTOff     = (short)-pgb->ptlOrigin.y;
    chh.wChWidth  = (WORD)  pgb->sizlBitmap.cx;
    chh.wChHeight = (WORD)  pgb->sizlBitmap.cy;
    chh.wDeltaX   = (WORD)  ((GBmp.pGlyphData->ptqD.x.HighPart + 3) >> 2);

    cbLines = (chh.wChWidth + BBITS - 1) / BBITS;
    cbSend = sizeof(chh) + cbLines * (WORD) pgb->sizlBitmap.cy;

    SWAB( chh.sLOff );
    SWAB( chh.sTOff );
    SWAB( chh.wChWidth );
    SWAB( chh.wChHeight );
    SWAB( chh.wDeltaX );

    ZeroMemory( aubPCLCharHdrCmd, sizeof( aubPCLCharHdrCmd ) );

    //
    //"\x1B(s%dW", cbSend
    //

    dwCharHdrCmdLen = 0;
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = 0x1B;
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = '(';
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = 's';
    dwCharHdrCmdLen += strlen(_ltoa(cbSend,
                                   &aubPCLCharHdrCmd[dwCharHdrCmdLen],
                                   10));
    aubPCLCharHdrCmd[dwCharHdrCmdLen++] = 'W';

    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                         aubPCLCharHdrCmd,
                                         dwCharHdrCmdLen);
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                         (BYTE *)&chh,
                                         sizeof( chh ));
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                         pgb->aj,
                                         cbSend-sizeof(chh));

    DbgPrint(DLLTEXT("OEMDownloadCharGlyph returns %d\n"),
            cbLines * pgb->sizlBitmap.cy);

    return cbLines * pgb->sizlBitmap.cy;
}


DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj)
{
    GETINFO_MEMORY Memory;
    DWORD          dwGetInfo;

    DbgPrint(DLLTEXT("OEMTTDownloadMethod() entry.\r\n"));

    if (pUFObj->pfnGetInfo(pUFObj,
                           UFO_GETINFO_MEMORY,
                           (PVOID)&Memory,
                           dwGetInfo,
                           &dwGetInfo))
    {
        DbgPrint(DLLTEXT("dwRemainingMemory = %d\n"), Memory.dwRemainingMemory);
    }
    else
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_MEMORY failed.\r\n"));
        return 0;
    }

    return TTDOWNLOAD_BITMAP;
}


VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    GETINFO_GLYPHWIDTH  GWidth;
    BYTE  aubBuff[256];
    PTRANSDATA pTrans;
    PDWORD pdwGlyphID;
    PLONG  plWidth;
    PWORD  pwUnicode;
    DWORD  dwI, dwGetInfo;

    DbgPrint(DLLTEXT("OEMOutputCharStr() entry.\r\n"));

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
        DbgPrint(DLLTEXT("dwType = TYPE_GLYPHHANDLE\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        }

        GStr.dwTypeOut = TYPE_TRANSDATA;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

        pTrans = (PTRANSDATA)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),pTrans->ubCodePageID);
            DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),pTrans->ubType);
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCode:0x%x\n"),pTrans->uCode.ubCode);
                pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                     &pTrans->uCode.ubCode,
                                                     1);
                break;
            case MTYPE_PAIRED: 
                DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubPairs:0x%x\n"),*(PWORD)(pTrans->uCode.ubPairs));
                pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                     pTrans->uCode.ubPairs,
                                                     2);
                break;
            }
        }
        GWidth.dwSize = sizeof(GETINFO_GLYPHSTRING);
        GWidth.dwCount = dwCount;
        GWidth.dwType = TYPE_GLYPHHANDLE;
        GWidth.pGlyph = pGlyph;
        GWidth.plWidth = (PLONG)aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHWIDTH,
                                &GWidth,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHWIDTH failed.\r\n"));
            return;
        }
        plWidth = (PLONG)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Width[%d] = %d\r\n"), dwI, plWidth[dwI]);
        }
        break;

    case TYPE_GLYPHID:
        DbgPrint(DLLTEXT("dwType = TYPE_GLYPHID\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHID;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_GLYPHHANDLE;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pdwGlyphID = (PDWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("GlyphHandle[%d] = %d\r\n"), dwI, pdwGlyphID[dwI]);
        }

        GStr.dwTypeOut = TYPE_UNICODE;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
                                &GStr,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        }

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {
            DbgPrint(DLLTEXT("TYEP_GLYPHID:0x%x\n"), *(PDWORD)pGlyph);
            pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                 (PBYTE)pGlyph,
                                                 1);
        }
        GWidth.dwSize  = sizeof(GETINFO_GLYPHSTRING);
        GWidth.dwCount = dwCount;
        GWidth.dwType  = TYPE_GLYPHID;
        GWidth.pGlyph  = pGlyph;
        GWidth.plWidth = (PLONG)aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHWIDTH,
                                (PVOID)&GWidth,
                                dwGetInfo,
                                &dwGetInfo))
        {
            DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHWIDTH failed.\r\n"));
            return;
        }
        plWidth = (PLONG)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            DbgPrint(DLLTEXT("Width[%d] = %d\r\n"), dwI, plWidth[dwI]);
        }
        break;
    }
}


VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+2*4];
    DWORD dwIn, dwOut, dwGetInfo;
    PBYTE pubCmd;
    BYTE  aubCmd[80];

    GETINFO_FONTOBJ FO;

    DbgPrint(DLLTEXT("OEMSendFontCmd() entry.\r\n"));

    pubCmd = pFInv->pubCommand;

    //
    // Callback function testing
    //

    //
    // GETINFO_FONTOBJ
    //
    FO.dwSize = sizeof(GETINFO_FONTOBJ);
    FO.pFontObj = NULL;

    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_FONTOBJ,
                            (PVOID)&FO,
                            dwGetInfo,
                            &dwGetInfo))
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_FONTOBJ failed.\r\n"));
        return;
    }
    DbgPrint(DLLTEXT("FontObj.iUniq=%d\r\n"), FO.pFontObj->iUniq);
    DbgPrint(DLLTEXT("FontObj.iFace=%d\r\n"), FO.pFontObj->iFace);
    DbgPrint(DLLTEXT("FontObj.cxMax=%d\r\n"), FO.pFontObj->cxMax);
    DbgPrint(DLLTEXT("FontObj.flFontType=%d\r\n"), FO.pFontObj->flFontType);
    DbgPrint(DLLTEXT("FontObj.iTTUniq=%d\r\n"), FO.pFontObj->iTTUniq);
    DbgPrint(DLLTEXT("FontObj.iFile=%d\r\n"), FO.pFontObj->iFile);
    DbgPrint(DLLTEXT("FontObj.sizLogResPpi.cx=%d\r\n"), FO.pFontObj->sizLogResPpi.cx);
    DbgPrint(DLLTEXT("FontObj.sizLogResPpi.cy=%d\r\n"), FO.pFontObj->sizLogResPpi.cy);
    DbgPrint(DLLTEXT("FontObj.pvConsumer=%d\r\n"), FO.pFontObj->pvConsumer);
    DbgPrint(DLLTEXT("FontObj.pvProducer=%d\r\n"), FO.pFontObj->pvProducer);


    //
    // Get standard variables.
    //

    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (5 - 1);
    pSV->dwNumOfVariable = 5;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_STDVARIABLE,
                            (PVOID)pSV,
                            dwGetInfo,
                            &dwGetInfo))
    {
        DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }

    DbgPrint(DLLTEXT("FNT_INFO_FONTHEIGHT:%d\n"),pSV->StdVar[0].lStdVariable);
    DbgPrint(DLLTEXT("FNT_INFO_FONTWIDTH:%d\n"),pSV->StdVar[1].lStdVariable);
    DbgPrint(DLLTEXT("FNT_INFO_FONTTEXTYRES:%d\n"),pSV->StdVar[2].lStdVariable);
    DbgPrint(DLLTEXT("FNT_INFO_FONTTEXTXRES:%d\n"),pSV->StdVar[3].lStdVariable);

    dwOut = 0;

    for( dwIn = 0; dwIn < pFInv->dwCount;)
    {
        if (pubCmd[dwIn] == '#')
        {
            dwIn ++;
            if (pubCmd[dwIn] == 'v' || pubCmd[dwIn] == 'V')
            {
                dwOut += LConvertFontSizeToStr(
                                LGetPointSize100(pSV->StdVar[0].lStdVariable,
                                                 600),
                                (PSTR)&aubCmd[dwOut]);
            }
            else if ((pubCmd[dwIn] == 'h' || pubCmd[dwIn] == 'H')    // pitch
                     && pSV->StdVar[1].lStdVariable > 0)
            {
                dwOut += LConvertFontSizeToStr(
                              (LONG)MulDiv(600, 100,
                                           pSV->StdVar[1].lStdVariable),
                              (PSTR)&aubCmd[dwOut]);
            }
            else
            {
                return;
            }
        }
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }
    pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, aubCmd, dwOut);

}


LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr)
{
    register long count;

    if (size % 100 == 0)
    {
        count = strlen(_ltoa(size / 100, pStr, 10));
    }
    else if (size % 10 == 0)
    {
        count           = strlen(_ltoa(size / 10, pStr, 10));
        pStr[count]     = pStr[count - 1];
        pStr[count - 1] = '.';
        pStr[++count]   = '\0';
    }
    else
    {
        count           = strlen(_ltoa(size, pStr, 10));
        pStr[count]     = pStr[count - 1];
        pStr[count - 1] = pStr[count - 2];
        pStr[count - 2] = '.';
        pStr[++count]   = '\0';
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\rastercb\enable.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of OEM DDI exports.
        OEMEnablePDEV (required)
        OEMDisablePDEV (required)
        OEMResetPDEV (optional)

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;
#ifdef DBG
    DbgPrint(DLLTEXT("OEMEnablePDEV() entry.\r\n"));
#endif
    //
    // Allocate the OEMDev
    //
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    //
    // Fill in OEMDEV as you need
    //

    poempdev->dwReserved[0] = 0xFFFFFFFF;


    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
#ifdef DBG
    DbgPrint(DLLTEXT("OEMDisablePDEV() entry.\r\n"));
#endif
    ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM);

    //
    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    MemFree(pdevobj->pdevOEM);

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
#ifdef DBG
    DbgPrint(DLLTEXT("OEMResetPDEV() entry.\r\n"));
#endif
    ASSERT(VALID_PDEVOBJ(pdevobjOld) && pdevobjOld->pdevOEM);
    ASSERT(VALID_PDEVOBJ(pdevobjNew) && pdevobjOld->pdevOEM);

    //
    // if you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\rastercb\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H


#include "..\oemud.h"

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'RSCB'      // Raster module callback test dll
#define DLLTEXT(s)      __TEXT("RASTERCB:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\oemtest\rastercb\raster.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Implementation of raster module customization:
        OEMImageProcessing
        OEMFilterGraphics

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created the framework. The functions are not yet exported in
        oemud\oemud.def file. So they are not actually used by Unidrv.

--*/

#include "pdev.h"

VOID Dither24to4(PBYTE,PBYTE,int,int,DWORD);

PBYTE APIENTRY OEMImageProcessing(
    PDEVOBJ pdevobj,
    PBYTE pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfo,
    PBYTE pColorTable,
    DWORD dwCallbackID,
    PIPPARAMS pIPParams
    )
{
#ifdef DBG
    DbgPrint(DLLTEXT("OEMImageProcessing() entry.\r\n"));
#endif
    if (pBitmapInfo->biBitCount == 24)
    {
        if (pIPParams->bBlankBand)
        {
            int i = (((pBitmapInfo->biWidth * 4) + 31) / 32) * 4 * pBitmapInfo->biHeight;
            ZeroMemory(pSrcBitmap,i);
        }
        else
            Dither24to4(pSrcBitmap,pSrcBitmap,
                        pBitmapInfo->biWidth,pBitmapInfo->biHeight,dwCallbackID);
        return pSrcBitmap;                        
    }
    return NULL;
}
//
// If you want to enable OEMFilterGraphics it needs to be exported in 
// rastercb.def
//
BOOL APIENTRY OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen
    )
{
#ifdef DBG
    DbgPrint(DLLTEXT("OEMFilterGraphics() entry.\r\n"));
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\raster.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.h

Abstract:

    Raster module main header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    12/10/96 -alvins-
        Added required header info for raster module
    dd-mm-yy -author-
        description

--*/


#ifndef _RASTER_H_
#define _RASTER_H_


#include "lib.h"
#include "unilib.h"
#include "gpd.h"
#include "mini.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "common.h"
#include "rasterif.h"
#include "printoem.h"
#include "oemutil.h"
#include "rastpdev.h"

#endif  // !_RASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\initpal.c ===
/****************** Module Header *********************
*
* Copyright (c) 1996 - 1999  Microsoft Corporation
*
* initpal.c
*
* HISTORY
* 14:21 on Wed 05 July 1995   -by-   Sandra Matts
* initial version
*
*
******************************************************/

#include    "raster.h"

/* defines for color manipulation    */
#define RED_VALUE(c)   ((BYTE) c & 0xff)
#define GREEN_VALUE(c) ((BYTE) (c >> 8) & 0xff)
#define BLUE_VALUE(c)  ((BYTE) (c >> 16) & 0xff)

/************************** Function Header *********************************
 * lSetup8BitPalette
 *      Function to read in the 256 color palette from GDI into the
 *      palette data structure in Dev Info.
 *
 * RETURNS:
 *      The number of colors in the palette. Returns 0 if the call fails.
 *
 * HISTORY:
 *  10:43 on Wed 06 Sep 1995    -by-    Sandra Matts
 *      Created it to support the Color LaserJet
 *
 ****************************************************************************/
long lSetup8BitPalette (pRPDev, pPD, pdevinfo, pGDIInfo)
RASTERPDEV   *pRPDev;
PAL_DATA  *pPD;
DEVINFO   *pdevinfo;             /* Where to put the data */
GDIINFO   *pGDIInfo;
{

    long    lRet;
    int     _iI;

    PALETTEENTRY  pe[ 256 ];      /* 8 bits per pel - all the way */


    FillMemory (pe, sizeof (pe), 0xff);
    lRet = HT_Get8BPPFormatPalette(pe,
                                  (USHORT)pGDIInfo->ciDevice.RedGamma,
                                  (USHORT)pGDIInfo->ciDevice.GreenGamma,
                                  (USHORT)pGDIInfo->ciDevice.BlueGamma );
#if PRINT_INFO

    DbgPrint("RedGamma = %d, GreenGamma = %d, BlueGamma = %d\n",(USHORT)pGDIInfo->ciDevice.RedGamma, (USHORT)pGDIInfo->ciDevice.GreenGamma, (USHORT)pGDIInfo->ciDevice.BlueGamma);

#endif

    if( lRet < 1 )
    {
#if DBG
        DbgPrint( "Rasdd!GetPalette8BPP returns %ld\n", lRet );
#endif

        return(0);
    }
    /*
     *    Convert the HT derived palette to the engine's desired format.
     */

    for( _iI = 0; _iI < lRet; _iI++ )
    {
        pPD->ulPalCol[ _iI ] = RGB( pe[ _iI ].peRed,
                                    pe[ _iI ].peGreen,
                                    pe[ _iI ].peBlue );
    #if  PRINT_INFO
        DbgPrint("Pallette entry %d= (r = %d, g = %d, b = %d)\n",_iI,pe[ _iI ].peRed, pe[ _iI ].peGreen, pe[ _iI ].peBlue);

    #endif

    }

    pPD->iPalGdi               = lRet;
    pdevinfo->iDitherFormat    = BMF_8BPP;
    pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGDIInfo->ulHTOutputFormat = HT_FORMAT_8BPP;


    /*
     * Since the GPC spec does not support this flag yet,
     * we have to manually set it.
     */
    pRPDev->fColorFormat |= DC_ZERO_FILL;
    /*
     * Since the Color laserJet zero fills we are going to
     * put white in palette entry 0 and black in 7
     */
    if (pRPDev->fColorFormat & DC_ZERO_FILL)
    {
        pPD->ulPalCol[ 7 ]       = RGB (0x00, 0x00, 0x00);
        pPD->ulPalCol[ 0 ]       = RGB (0xff, 0xff, 0xff);
        pPD->iWhiteIndex         = 0;
        pPD->iBlackIndex         = 7;
    }


    return lRet;
}


/************************** Function Header *********************************
 * lSetup24BitPalette
 *      Function to read in the 256 color palette from GDI into the
 *      palette data structure in Dev Info.
 *
 * RETURNS:
 *      The number of colors in the palette. Returns 0 if the call fails.
 *
 * HISTORY:
 *  10:43 on Wed 06 Sep 1995    -by-    Sandra Matts
 *      Created it to support the Color LaserJet
 *
 ****************************************************************************/
long lSetup24BitPalette (pPD, pdevinfo, pGDIInfo)
PAL_DATA  *pPD;
DEVINFO   *pdevinfo;             /* Where to put the data */
GDIINFO   *pGDIInfo;
{

    pPD->iPalGdi               = 0;
    pPD->iWhiteIndex           = 0x00ffffff;
    pdevinfo->iDitherFormat    = BMF_24BPP;
    pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGDIInfo->ulHTOutputFormat = HT_FORMAT_24BPP;

    return 1;
}
/****************************** Function Header ****************************
 * v8BPPLoadPal
 *      Download the palette to the HP Color laserJet in 8BPP
 *      mode.  Takes the data we retrieved from the HT code during
 *      DrvEnablePDEV.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  14:46 on Thu 29 June 1995    -by-    Sandra Matts
 *     Initial version
 *
 ****************************************************************************/

void
v8BPPLoadPal( pPDev )
PDEV   *pPDev;
{
    /*
     *   Program the palette according to PCL5 spec.
     *   The syntax is Esc*v#a#b#c#I
     *      #a is the first color component
     *      #b is the second color component
     *      #c is the third color component
     *      #I assigns the color to the specified palette index number
     *   For example, Esc*v0a128b255c5I assigns the 5th index
     *   of the palette to the color 0, 128, 255
     *
     */

    int   iI,
          iIndex;

    PAL_DATA  *pPD;

    pPD = pPDev->pPalData;

    /*TBD: how do we output a palette to the device?
    for( iI = 0; iI < pPD->iPalDev; ++iI )
    {
        WriteChannel (pPDev, CMD_DC_PC_ENTRY, RED_VALUE (pPD->ulPalCol [iI]),
            GREEN_VALUE (pPD->ulPalCol [iI]), BLUE_VALUE (pPD->ulPalCol [iI]),
            (ULONG) iI);
    }
    */
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\rastpdev.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    RastPdev.h

Abstract:

    Unidrv RASTPDEV and related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    12/06/96 -alvins-
        Created

        dd-mm-yy -author-
                description

--*/
#ifndef _RASTPDEV_H_
#define _RASTPDEV_H_

#include        "win30def.h"

/* flags for fRMode */
#define PFR_SENDSRCWIDTH    0x00000001  // send source width
#define PFR_SENDSRCHEIGHT   0x00000002  // send source height
#define PFR_SENDBEGINRASTER 0x00000004  // send begin raster command
#define PFR_RECT_FILL       0x00000008  // enable rules checking
#define PFR_RECT_HORIZFILL  0x00000010  // enable horizontal rules check
#define PFR_BLOCK_IS_BAND   0x00000020  /* Derryd:Full band sent to OemFlGrx */
#define PFR_ENDBLOCK        0x00000100  // need to send end of block command
#define PFR_COMP_TIFF       0x00000200  // enable TIFF compression
#define PFR_COMP_FERLE      0x00000400  // enable FERLE compression
#define PFR_COMP_DISABLED   0x00000800  // enable no compression
#define PFR_COMP_DRC        0x00001000  // enable DRC compression
#define PFR_COMP_OEM        0x00002000  // enable OEM compression
/*
 *   fDump values
 */

#define RES_DM_GDI             0x0040   // GDI bitmap format
#define RES_DM_LEFT_BOUND      0x0080   // Optimize by bounding rect
#define RES_DM_COLOR           0x0100   // Color support is available
/*
 *   fBlockOut values
 */

#define RES_BO_LEADING_BLNKS    0x0001  // Strip leading blanks
#define RES_BO_TRAILING_BLNKS   0x0002  // Strip trailing blanks
#define RES_BO_ENCLOSED_BLNKS   0x0004  // Strip enclosed blanks
#define RES_BO_UNIDIR           0x0008  // send unidir command for raster
#define RES_BO_MIRROR           0x0010  // mirror the data
#define RES_BO_MULTIPLE_ROWS    0x0020  // Multiple lines of data can be sent
#define RES_BO_NO_YMOVE_CMD     0x0040  // No Y movement so can't strip blanks

/*
 *   fCursor values
 */

#define RES_CUR_X_POS_ORG       0x0001       // X Position is at X start point
             // of graphic data after rendering data
#define RES_CUR_X_POS_AT_0      0x0002       // X position at leftmost place
             // on page after rendering data
#define RES_CUR_Y_POS_AUTO      0x0004       // Y position automatically moves
             // to next Y row
//#define RES_CUR_CR_GRX_ORG      0x0008       // CR moves X pos to X start point of
             // of graphic data

//
// RASTERPDEV structure
//
#define DC_MAX_PLANES   4
typedef struct _RASTERPDEV {
    DWORD   fRMode;
    DWORD   *pdwTrans;           /* Transpose table,  if required */
    DWORD   *pdwColrSep;         /* Colour separation data, if required */
    DWORD   *pdwBitMask;         /* Bitmask table,  white skip code */
    VOID    *pHalftonePattern;  /* Custom halftone table */
    BYTE    rgbOrder[DC_MAX_PLANES]; /*Colour plane/palette order*/
    DWORD   rgbCmdOrder[DC_MAX_PLANES];
    PAL_DATA    *pPalData;          /* Palette information */
    DWORD   dwRectFillCommand;  // command to use for rules
    WORD    fColorFormat;       /* color flags DEVCOLOR: */
    WORD    fDump;              // Dump method flags.
    WORD    fBlockOut;          // Block out method flags.
    WORD    fCursor;            // Cursor position flags.
    short   sMinBlankSkip;      // Min. # of bytes of null data that must occur before
    short   sNPins;             // Minimum height of the image to be rendered together.
    short   sPinsPerPass;       // Physical number of pins fired in one pass.
    short   sDevPlanes;         /* # of planes in the device color model, */
    short   sDevBPP;            /* Device Bits per pixel  - if Pixel model */
    short   sDrvBPP;            // Drv Bits per pixel
    BOOL    bTTY;               // Is printer type TTY
    int     iLookAhead;         // look ahead region for deskjet types
    void    *pRuleData;         // pointer to rules structure
    VOID    *pvRenderData;       /* Rendering summary data, PRENDER */
    VOID    *pvRenderDataTmp;    /* Temporary copy for use in banding */
    //
    // callback functions
    //
    PFN_OEMCompression      pfnOEMCompression;
    PFN_OEMHalftonePattern  pfnOEMHalftonePattern;
    PFN_OEMImageProcessing  pfnOEMImageProcessing;
    PFN_OEMFilterGraphics   pfnOEMFilterGraphics;
    DWORD   dwIPCallbackID;      /* OEM Image Processing CallbackID */
#ifdef TIMING
    DWORD   dwTiming;           // used for timing
    DWORD   dwDocTiming;
#endif
} RASTERPDEV, *PRASTERPDEV;

/*
 *   DEVCOLOR.fGeneral bit flags:
 */
#define DC_PRIMARY_RGB      0x0001   // use RGB as 3 primary colors.
                             // Default: use CMY instead.
#define DC_EXTRACT_BLK      0x0002   // Separate black ink/ribbon is available.
                             // Default: compose black using CMY.
                             // It is ignored if DC_PRIMARY_RGB is set
#define DC_CF_SEND_CR       0x0004   // send CR before selecting graphics
                             // color. Due to limited printer buffer
#define DC_SEND_ALL_PLANES  0x0008  /* All planes must be sent, e.g. PaintJet */
#define DC_OEM_BLACK        0x0010  // OEM is responsible for creating black
                                    // and inverting data
#define DC_EXPLICIT_COLOR   0x0020  /* Send command to select colour */
#define DC_SEND_PALETTE     0x0040  /* Device is Palette Managed; Seiko 8BPP */
/* sandram
 * add field to send dithered text for Color LaserJet - set foreground color.
 */
//#define DC_FG_TEXT_COLOR    0x0080  /* Send command to select text foreground color */

#define DC_ZERO_FILL        0x0100  /* This model fills raster to the end of the page with zeros */

//* define color order
#define DC_PLANE_RED    1
#define DC_PLANE_GREEN  2
#define DC_PLANE_BLUE   3
#define DC_PLANE_CYAN   4
#define DC_PLANE_MAGENTA    5
#define DC_PLANE_YELLOW 6
#define DC_PLANE_BLACK  7


//-------------------------------------------
// fTechnology--used as an ID, not a bitfield
//-------------------------------------------
#define GPC_TECH_DEFAULT       0   // Default technology
#define GPC_TECH_PCL4          1   // Uses PCL level 4 or above
#define GPC_TECH_CAPSL         2   // Uses CaPSL level 3 or above
#define GPC_TECH_PPDS          3   // Uses PPDS
#define GPC_TECH_TTY           4   // TTY printer--user configurable

/*
 *    fCompMode
 */
#define CMP_ID_TIFF4        0x0001
#define CMP_ID_FERLE        0x0002
#define CMP_ID_DRC          0x0004
#define CMP_ID_OEM          0x0008


#endif  // !_RASTPDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\compress.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    compress.c

Abstract:

    Implementation of compression formats for sending data to devices.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/

#include        "raster.h"
#include        "compress.h"            /* Function prototypes */

//*************************************************************
int
iCompTIFF(
    BYTE *pbOBuf,
    BYTE *pbIBuf,
    int  iBCnt
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    TIFF v4 compression.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress

Return Value:

    Number of compressed bytes

Note:
    The output buffer is presumed large enough to hold the output.
    In the worst case (NO REPETITIONS IN DATA) there is an extra
    byte added every 128 bytes of input data.  So, you should make
    the output buffer at least 1% larger than the input buffer.

--*/
{
    BYTE   *pbOut;        /* Output byte location */
    BYTE   *pbStart;      /* Start of current input stream */
    BYTE   *pb;           /* Miscellaneous usage */
    BYTE   *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */
    BYTE   bLast;

    int     iSize;        /* Bytes in the current length */
    int     iSend;        /* Number to send in this command */


    pbOut = pbOBuf;
    pbStart = pbIBuf;
    pbEnd = pbIBuf + iBCnt;         /* The last byte */

#if (TIFF_MIN_RUN >= 4)
    // this is a faster algorithm for calculating TIFF compression
    // that assumes a minimum RUN of at least 4 bytes. If the
    // third and fourth byte don't equal then the first/second bytes are
    // irrelevant. This means we can determine non-run data three times
    // as fast since we only check every third byte pair.

   if (iBCnt > TIFF_MIN_RUN)
   {
    // make sure the last two bytes aren't equal so we don't have to check
    // for the buffer end when looking for runs
    bLast = pbEnd[-1];
    pbEnd[-1] = ~pbEnd[-2];
    while( (pbIBuf += 3) < pbEnd )
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // save the run start pointer, pb, and check whether the first
            // bytes are also part of the run
            //
            pb = pbIBuf-1;
            if (*pbIBuf == pbIBuf[-2])
            {
                pb--;
                if (*pbIBuf == pbIBuf[-3])
                    pb--;
            }

            //  Find out how long this run is
            jLast = *pb;
            do {
                pbIBuf++;
            } while (*pbIBuf == jLast);

            // test whether last byte is also part of the run
            //
            if (jLast == bLast && pbIBuf == (pbEnd-1))
                pbIBuf++;

            // Determine if the run is longer that the required
            // minimum run size.
            //
            if ((iSend = (int)(pbIBuf - pb)) >= (TIFF_MIN_RUN))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = (int)(pb - pbStart)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */
                iSize = iSend;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
        }
    }
    pbEnd[-1] = bLast;
   }
#else
    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */
            pb = pbIBuf;
            do {
                pbIBuf++;
            } while (pbIBuf < pbEnd && *pbIBuf == jLast);

            /*
             *  Note that pb points at the SECOND byte of the pattern!
             *  AND also that pbIBuf points at the first byte AFTER the run.
             */

            if ((iSend = pbIBuf - pb) >= (TIFF_MIN_RUN - 1))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = pb - pbStart - 1) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                iSize = iSend + 1;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
            if (pbIBuf == pbEnd)
                break;
        }

        jLast = *pbIBuf++;                   /* Onto the next byte */

    }
#endif

    if ((iSize = (int)(pbEnd - pbStart)) > 0)
    {
        /*  Left some dangling.  This can only be literal data.   */

        while( (iSend = min( iSize, TIFF_MAX_LITERAL )) > 0 )
        {
            *pbOut++ = iSend - 1;
            CopyMemory( pbOut, pbStart, iSend );
            pbOut += iSend;
            pbStart += iSend;
            iSize -= iSend;
        }
    }

    return  (int)(pbOut - pbOBuf);
}
//**********************************************************
int
iCompFERLE(
    BYTE *pbOBuf,
    BYTE *pbIBuf,
    int  iBCnt,
    int  iMaxCnt
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    Far East Run length encoding.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress
    iMaxCnt     Maximum number of bytes to create on output

Return Value:

    Number of compressed bytes or -1 if too large for buffer

--*/
{
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbI;          /* Scanning for runs */
    BYTE   *pbIEnd;      /* First byte past end of input data */
    BYTE   *pbStart;     /* Start of current data stream */
    BYTE   *pbTmp;
    BYTE    jLast;       /* Previous byte */

    int     iSize;       /* Number of bytes in the run */

    if (iBCnt == 0)
        return 0;

    pbO = pbOBuf;                 /* Working copy */
    pbIEnd = pbIBuf + iBCnt;          /* Gone too far if we reach here */

    /*
     * Calculate the maximum amount of data we will generate
     */

    pbStart = pbIBuf;

    while (++pbIBuf < pbIEnd)
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // valid run but we will first output any literal data
            if ((iSize = (int)(pbIBuf - pbStart) - 1) > 0)
            {
                if ((iMaxCnt -= iSize) < 0)  // test for output overflow
                    return -1;
                CopyMemory(pbO,pbStart,iSize);
                pbO += iSize;
            }

            // determine the run length
            jLast = *pbIBuf;
            pbI = pbIBuf;
            pbTmp = pbIBuf + FERLE_MAX_RUN - 1;
            if (pbTmp > pbIEnd)
                pbTmp = pbIEnd;
            do {
                pbIBuf++;
            } while (pbIBuf < pbTmp && *pbIBuf == jLast);

            iSize = (int)(pbIBuf - pbI) + 1; /* Number of times */

            // output the RLE strings
            if ((iMaxCnt -= 3) < 0)       // test for output overflow
                return -1;
            *pbO++ = jLast;             // copy data byte twice
            *pbO++ = jLast;
            *pbO++ = (BYTE)iSize;

            // test if we are done
            if( pbIBuf == pbIEnd )
                return (int)(pbO - pbOBuf);

            // setup for continuation of loop
            pbStart = pbIBuf;
        }
    }

    /*
     *  Since the data did not end in a run we must output the last
     *  literal data if we haven't overflowed the buffer.
     */
    iSize = (int)(pbIBuf - pbStart);

    if (iMaxCnt < iSize)
        return -1;

    CopyMemory(pbO,pbStart,iSize);
    pbO += iSize;
    return (int)(pbO - pbOBuf);
}

//****************************************************
int
iCompDeltaRow(
    BYTE  *pbOBuf,
    BYTE  *pbIBuf,
    BYTE  *pbPBuf,
    int   iBCnt,
    int   iLimit
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    delta row compression.

Arguments:

    pbOBuf      Pointer to output buffer
    pbIBuf      Pointer to data buffer to compress
    pbPBuf      Pointer to previous row data buffer
    iBCnt       Number of bytes in the above
    iLimit      Don't exceed this number of compressed bytes

Return Value:

    Number of compressed bytes or -1 if too large for buffer

Note:
    A return value of 0 is valid since it implies the two lines
    are identical.

--*/

{
#ifdef _X86_
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    BYTE   *pbIEnd;
    BYTE   *pbStart;
    BYTE   *pb;
    int    iDelta;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */

    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */
    pbO = pbOBuf;                 /* Working copy */
    pbOEnd = pbOBuf + iLimit - 2;
    iDelta = pbPBuf - pbIBuf;
    pbIEnd = pbIBuf + iBCnt;
    pbStart = pbIBuf;

    //
    // this is the main loop for compressing the data
    //
    while (pbIBuf < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbIBuf & 3))
        {
            while (pbIBuf <= (pbIEnd-4) && *(DWORD *)pbIBuf == *(DWORD *)&pbIBuf[iDelta])
                pbIBuf += 4;
            if (pbIBuf >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbIBuf != pbIBuf[iDelta])
        {
            // determine the run length
            pb = pbIBuf;
            do {
                pb++;
            } while (pb < pbIEnd && *pb != pb[iDelta]);

            iSize = (int)(pb - pbIBuf);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            if (((iSize * 9 + 7) >> 3) > (pbOEnd - pbO))     // gives tighter code
                return -1;
            iOffset = (int)(pbIBuf - pbStart);
            if (iOffset > 30)
            {
                if (iSize < 8)
                    *pbO++ = ((iSize-1) << 5) + 31;
                else
                    *pbO++ = (7 << 5) + 31;
                iOffset -= 31;
                while (iOffset >= 255)
                {
                    iOffset -= 255;
                    *pbO++ = 255;
                }
                *pbO++ = (BYTE)iOffset;
                if (iSize > 8)
                    goto FastEightByteRun;
            }
            else if (iSize > 8)
            {
                *pbO++ = (7 << 5) + iOffset;
FastEightByteRun:
                while (1)
                {
                    CopyMemory(pbO,pbIBuf,8);
                    pbIBuf += 8;
                    pbO += 8;
                    if ((iSize -= 8) <= 8)
                        break;
                    *pbO++ = (7 << 5);
                }
                *pbO++ = (iSize-1) << 5;
            }
            else
                *pbO++ = ((iSize-1) << 5) + iOffset;

            CopyMemory (pbO,pbIBuf,iSize);
            pbIBuf += iSize;
            pbO += iSize;
            pbStart = pbIBuf;
        }
        pbIBuf++;
    }
    return (int)(pbO - pbOBuf);
#else
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    BYTE   *pbIEnd;
    BYTE   *pbStart;
    BYTE   *pb;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */

    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */
    pbO = pbOBuf;                 /* Working copy */
    pbOEnd = pbOBuf + iLimit - 2;
    pbIEnd = pbIBuf + iBCnt;
    pbStart = pbIBuf;

    //
    // this is the main loop for compressing the data
    //
    while (pbIBuf < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbIBuf & 3))
        {
            while (pbIBuf <= (pbIEnd-4) && *(DWORD *)pbIBuf == *(DWORD *)pbPBuf)
            {
                pbIBuf += 4;
                pbPBuf += 4;
            }
            if (pbIBuf >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbIBuf != *pbPBuf)
        {
            // determine the run length
            pb = pbIBuf;
            do {
                pb++;
                pbPBuf++;
            } while (pb < pbIEnd && *pb != *pbPBuf);

            iSize = (int)(pb - pbIBuf);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            if (((iSize * 9 + 7) >> 3) > (int)(pbOEnd - pbO))
                return -1;

            // special case the initial offset value since it
            // occurs only once and may require extra bytes
            //
            if ((iOffset = (int)(pbIBuf - pbStart)))
            {
                int iSend = min (iSize,8);
                if (iOffset > 30)
                {
                    *pbO++ = ((iSend-1) << 5) + 31;
                    iOffset -= 31;
                    while (iOffset >= 255)
                    {
                        *pbO++ = 255;
                        iOffset -= 255;
                    }
                    *pbO++ = (BYTE)iOffset;
                }
                else
                {
                    *pbO++ = ((iSend-1) << 5) + iOffset;
                }
                // output the initial changed bytes
                CopyMemory(pbO,pbIBuf,iSend);
                pbIBuf += iSend;
                pbO += iSend;
                iSize -= iSend;
            }

            // now output any remaining changed data
            //
            while (iSize)
            {
                if (iSize >= 8)
                {
                    *pbO++ = (8 - 1) << 5;
                    CopyMemory(pbO,pbIBuf,8);
                    pbIBuf += 8;
                    pbO += 8;
                    iSize -= 8;
                }
                else
                {
                    *pbO++ = (iSize-1) << 5;
                    CopyMemory(pbO,pbIBuf,iSize);
                    pbIBuf += iSize;
                    pbO += iSize;
                    break;
                }
            }
            pbStart = pbIBuf;
        }
        pbIBuf++;
        pbPBuf++;
    }
    return (int)(pbO - pbOBuf);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\rastproc.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    rastproc.h

Abstract:

    Interface between Control module and Render module

Environment:

    Windows NT Unidrv driver

Revision History:

    12/05/96 -alvins-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _RASTPROC_H_
#define _RASTPROC_H_

// internal function declarations

BOOL bInitRasterPDev(PDEV *);
long lSetup8BitPalette (PRASTERPDEV, PAL_DATA *, DEVINFO *, GDIINFO *);
long lSetup24BitPalette (PAL_DATA *, DEVINFO *, GDIINFO *);

// extern interface declarations

    BOOL    RMStartDoc (SURFOBJ *,PWSTR,DWORD);

    BOOL    RMStartPage (SURFOBJ *);

    BOOL    RMSendPage (SURFOBJ *);

    BOOL    RMEndDoc (SURFOBJ *,FLONG);

    BOOL    RMNextBand (SURFOBJ *, POINTL *);

    BOOL    RMStartBanding (SURFOBJ *, POINTL *);

    BOOL    RMResetPDEV (PDEV *,PDEV  *);

    BOOL    RMEnableSurface (PDEV *);

    VOID    RMDisableSurface (PDEV *);

    VOID    RMDisablePDEV (PDEV *);

    BOOL    RMCopyBits (
        SURFOBJ *,
        SURFOBJ *,
        CLIPOBJ *,
        XLATEOBJ *,
        RECTL  *,
        POINTL *
        );

    BOOL    RMBitBlt (
        SURFOBJ    *,
        SURFOBJ    *,
        SURFOBJ    *,
        CLIPOBJ    *,
        XLATEOBJ   *,
        RECTL      *,
        POINTL     *,
        POINTL     *,
        BRUSHOBJ   *,
        POINTL     *,
        ROP4
        );

    BOOL    RMStretchBlt (
        SURFOBJ    *,
        SURFOBJ    *,
        SURFOBJ    *,
        CLIPOBJ    *,
        XLATEOBJ   *,
        COLORADJUSTMENT *,
        POINTL     *,
        RECTL      *,
        RECTL      *,
        POINTL     *,
        ULONG
        );
    BOOL    RMStretchBltROP(
        SURFOBJ         *,
        SURFOBJ         *,
        SURFOBJ         *,
        CLIPOBJ         *,
        XLATEOBJ        *,
        COLORADJUSTMENT *,
        POINTL          *,
        RECTL           *,
        RECTL           *,
        POINTL          *,
        ULONG            ,
        BRUSHOBJ        *,
        DWORD
        );

    BOOL    RMPaint(
        SURFOBJ         *,
        CLIPOBJ         *,
        BRUSHOBJ        *,
        POINTL          *,
        MIX
        );

    BOOL    RMPlgBlt (
        SURFOBJ    *,
        SURFOBJ    *,
        SURFOBJ    *,
        CLIPOBJ    *,
        XLATEOBJ   *,
        COLORADJUSTMENT *,
        POINTL     *,
        POINTFIX   *,
        RECTL      *,
        POINTL     *,
        ULONG
        );

    ULONG   RMDitherColor (PDEV *, ULONG, ULONG, ULONG *);


#endif  // !_RASTPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\compress.h ===
/****************************** MODULE HEADER ******************************
 * compress.h
 *        Function prototypes and other curiosities associated with data
 *        compression code.
 *
 *   Copyright (C) 1997 - 1999  Microsoft Corporation.
 *
 ****************************************************************************/


//
// this parameter controls how much better (in bytes) a new compression mode
// must do before it will be used instead of the current output mode
#define COMP_FUDGE_FACTOR 4

/*
 *   TIFF Compression function.
 */
int  iCompTIFF( BYTE *, BYTE *, int );

//
//  Delta Row Compression function
//
int iCompDeltaRow(BYTE *, BYTE *, BYTE *, int, int);


/*
 *   Some constants defining the limits of TIFF encoding.  The first
 * represent the minimum number of repeats for which it is worth using
 * a repeat operation.  The other two represent the maximum length
 * of data that can be encoded in one control byte.
 */

#define TIFF_MIN_RUN       4            /* Minimum repeats before use RLE */
#define TIFF_MAX_RUN     128            /* Maximum repeats */
#define TIFF_MAX_LITERAL 128            /* Maximum consecutive literal data */

/*
 *   RLE (Run Length Encoding) functions.
 */

int  iCompRLE( BYTE *, BYTE *, int );
int  iCompFERLE (BYTE *, BYTE *, int, int );
/*
 *   Some constants relating to RLE operations.  RLE is ony useful in
 *  data containing runs.  In purely random data, the data size will
 *  double.  Consequently,  we allow a certain expansion of the data
 *  size before calling it off.  A small expansion is OK,  since the
 *  there is a cost involved in switching compression on and off.
 */

#define    FERLE_MAX_RUN    255          /* max consecutive byte count */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\raster.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Implementation of the interface between Control module and Raster module

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/

#include "raster.h"
#include "rastproc.h"
#include "rmrender.h"
#include "unirc.h"
#include "xlraster.h"

// internal function declarations
void vSetHTData(PDEV *, GDIINFO *);
BOOL bInitColorOrder(PDEV *);
DWORD PickDefaultHTPatSize(DWORD,DWORD);
VOID  v8BPPLoadPal(PDEV *);
BOOL bEnoughDRCMemory(PDEV *);

#ifdef TIMING
#include <stdio.h>
void  DrvDbgPrint(
    char *,
    ...);
#endif

// parameter definitions
static RMPROCS RasterProcs =
{
    RMStartDoc,
    RMStartPage,
    RMSendPage,
    RMEndDoc,
    RMNextBand,
    RMStartBanding,
    RMResetPDEV,
    RMEnableSurface,
    RMDisableSurface,
    RMDisablePDEV,
    RMCopyBits,
    RMBitBlt,
    RMStretchBlt,
    RMDitherColor,
    RMStretchBltROP,
    RMPaint,
    RMPlgBlt
};

CONST BYTE  cxcyHTPatSize[HT_PATSIZE_MAX_INDEX+1] = {

        2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16
#ifndef WINNT_40
        ,84,91
#endif        
    };


#define VALID_YC            0xFFFE
#define GAMMA_LINEAR        10000
#define GAMMA_DEVICE_HT     8000
#define GAMMA_SUPERCELL     GAMMA_LINEAR
#define GAMMA_DITHER        9250
#define GAMMA_GEN_PROFILE   0xFFFF


CONST COLORINFO DefColorInfoLinear =
{
    { 6400, 3300,       0 },        // xr, yr, Yr
    { 3000, 6000,       0 },        // xg, yg, Yg
    { 1500,  600,       0 },        // xb, yb, Yb
    {    0,    0,VALID_YC },        // xc, yc, Yc Y=0=HT default
    {    0,    0,       0 },        // xm, ym, Ym
    {    0,    0,       0 },        // xy, yy, Yy
    { 3127, 3290,   10000 },        // xw, yw, Yw

    10000,                          // R gamma
    10000,                          // G gamma
    10000,                          // B gamma

     712,    121,                   // M/C, Y/C
      86,    468,                   // C/M, Y/M
      21,     35                    // C/Y, M/Y
};


//*******************************************************
BOOL
RMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO *pGDIInfo
    )
/*++

Routine Description:

    This function is called to initialize raster related information in
    pPDev, pDevInfo and pGDIInfo

Arguments:

    pPDev           Pointer to PDEV structure
    pDevInfo        Pointer to DEVINFO structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    BOOL bRet = FALSE;
    PRASTERPDEV pRPDev;

    // Validate Input Parameters and ASSERT.
    ASSERT(pPDev);
    ASSERT(pDevInfo);
    ASSERT(pGDIInfo);

    // initialize the hook flag
    pPDev->fHooks |= HOOK_BITBLT | HOOK_STRETCHBLT | HOOK_COPYBITS;

    // initialize Proc jump table
    pPDev->pRasterProcs = &RasterProcs;

    // initialize Raster Pdev
    if (!bInitRasterPDev(pPDev))
        return FALSE;

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    //
    // Set up the default HALFTONE and colour calibration data.
    //
    vSetHTData( pPDev, pGDIInfo );

    //
    // initialize graphic capabilities
    //
    pDevInfo->flGraphicsCaps |= (GCAPS_ARBRUSHOPAQUE | GCAPS_HALFTONE | GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER);

    // initialize DevInfo parameters for rendering
    // test whether standard dither or custom pattern
#ifndef WINNT_40    
    if (pGDIInfo->ulHTPatternSize == HT_PATSIZE_USER) {
        pDevInfo->cxDither = (USHORT)pPDev->pHalftone->HalftonePatternSize.x;
        pDevInfo->cyDither = (USHORT)pPDev->pHalftone->HalftonePatternSize.y;
    }
    else 
#endif    
    {
        pDevInfo->cxDither =
        pDevInfo->cyDither = cxcyHTPatSize[pGDIInfo->ulHTPatternSize];
    }
    pPDev->dwHTPatSize = pDevInfo->cyDither;
    // if no quality macro setting, overwrite with halftone type
    //
    if ((pPDev->pdmPrivate->dwFlags & DXF_CUSTOM_QUALITY) ||
            (pPDev->pdmPrivate->iQuality != QS_BEST &&
             pPDev->pdmPrivate->iQuality != QS_BETTER &&
             pPDev->pdmPrivate->iQuality != QS_DRAFT))
        pPDev->pdm->dmDitherType = pGDIInfo->ulHTPatternSize;

    return TRUE;
}

//*******************************************************
BOOL
bInitRasterPDev(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine allocates the RASTERPDEV and initializes various fields.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

--*/

{
    PRASTERPDEV pRPDev;
    GLOBALS     *pGlobals = pPDev->pGlobals;
    PLISTNODE pListNode;

    if ( !(pRPDev = MemAllocZ(sizeof(RASTERPDEV))) )
    {
        ERR(("Unidrv!RMInit: Can't Allocate RASTERPDEV\n"));
        return FALSE;
    }
    pPDev->pRasterPDEV = pRPDev;

    // map all callback functions
    //

    if (pPDev->pOemHookInfo)
    {
        pRPDev->pfnOEMCompression =
            (PFN_OEMCompression)pPDev->pOemHookInfo[EP_OEMCompression].pfnHook;
        pRPDev->pfnOEMHalftonePattern =
            (PFN_OEMHalftonePattern)pPDev->pOemHookInfo[EP_OEMHalftonePattern].pfnHook;
        if (pPDev->pColorModeEx && pPDev->pColorModeEx->dwIPCallbackID > 0)
        {
            pRPDev->pfnOEMImageProcessing = (PFN_OEMImageProcessing)
                pPDev->pOemHookInfo[EP_OEMImageProcessing].pfnHook;
        }
        pRPDev->pfnOEMFilterGraphics =
            (PFN_OEMFilterGraphics)pPDev->pOemHookInfo[EP_OEMFilterGraphics].pfnHook;
    }
    // Determine the pixel depth, # planes and color order
    //
    if (!(bInitColorOrder(pPDev)))
    {
        ERR(("Invalid Color Order"));
        pPDev->pRasterPDEV = NULL;
        MemFree(pRPDev);
        return FALSE;
    }

    //* Determine whether to set DC_EXPLICIT_COLOR flag
    if (pGlobals->bUseCmdSendBlockDataForColor)
        pRPDev->fColorFormat |= DC_EXPLICIT_COLOR;

    //* Determine DC_CF_SEND_CR flag
    if (pGlobals->bMoveToX0BeforeColor)
        pRPDev->fColorFormat |= DC_CF_SEND_CR;

    //* Determine DC_SEND_ALL_PLANES flag
    if (pGlobals->bRasterSendAllData)
        pRPDev->fColorFormat |= DC_SEND_ALL_PLANES;


    /*TBD: if there is a filter callback, set BLOCK_IS_BAND
    //
    if (I've got a filter callback?)
        pRPDev->fRMode |= PFR_BLOCK_IS_BAND;
    */

    // Initialize whether there are SRCBMPWIDTH / SRCBMPHEIGHT commands
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPWIDTH))
        pRPDev->fRMode |= PFR_SENDSRCWIDTH;
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPHEIGHT))
        pRPDev->fRMode |= PFR_SENDSRCHEIGHT;

    // Initialize whether there is a BEGINRASTER command
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_BEGINRASTER))
        pRPDev->fRMode |= PFR_SENDBEGINRASTER;

    // Initialize rules testing
    // If Rectangle width and height commands exist assume we have black or
    // gray rectangles unless only white rect command exist. This is because
    // some devices have no explicit rectangle commands while others only have
    // white rectangles.
    // 
    if (pPDev->fMode & PF_RECT_FILL)
    {
        pRPDev->fRMode |= PFR_RECT_FILL | PFR_RECT_HORIZFILL;
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL))
            pRPDev->dwRectFillCommand = CMD_RECTBLACKFILL;
        else if (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL))
            pRPDev->dwRectFillCommand = CMD_RECTGRAYFILL;
        else if (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL))
            pRPDev->fRMode &= ~(PFR_RECT_FILL | PFR_RECT_HORIZFILL);
    }
    // Initialize whether to send ENDBLOCK commands
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENDBLOCKDATA))
        pRPDev->fRMode |= PFR_ENDBLOCK;

    //* Initialize resolution fields
    //
    pRPDev->sMinBlankSkip = (short)pPDev->pResolutionEx->dwMinStripBlankPixels;
    pRPDev->sNPins = (WORD)pPDev->pResolutionEx->dwPinsPerLogPass;
    pRPDev->sPinsPerPass = (WORD)pPDev->pResolutionEx->dwPinsPerPhysPass;

    //* initialize fDump flags
    //
    if (pGlobals->bOptimizeLeftBound)
        pRPDev->fDump |= RES_DM_LEFT_BOUND;
    if (pGlobals->outputdataformat == ODF_H_BYTE)
        pRPDev->fDump |= RES_DM_GDI;

    //* initialize fBlockOut flags
    //
    //* first map the GPD blanks parameters to GPC
    pListNode = LISTNODEPTR(pPDev->pDriverInfo,pPDev->pGlobals->liStripBlanks);
    while (pListNode)
    {
        if (pListNode->dwData == SB_LEADING)
            pRPDev->fBlockOut |= RES_BO_LEADING_BLNKS;
        else if (pListNode->dwData == SB_ENCLOSED)
            pRPDev->fBlockOut |= RES_BO_ENCLOSED_BLNKS;
        else if (pListNode->dwData == SB_TRAILING)
            pRPDev->fBlockOut |= RES_BO_TRAILING_BLNKS;
        pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
    }
    // Do we need to set to uni directional printing?
    //
    if (pPDev->pResolutionEx->bRequireUniDir)
        pRPDev->fBlockOut |= RES_BO_UNIDIR;

    // Can we output multiple rows at a time?
    //
    if (pPDev->pGlobals->bSendMultipleRows)
        pRPDev->fBlockOut |= RES_BO_MULTIPLE_ROWS;

    // Set flag if we need to mirror the individual raster bytes
    //
    if (pPDev->pGlobals->bMirrorRasterByte)
        pRPDev->fBlockOut |= RES_BO_MIRROR;

    // initialize fCursor flags
    //
    pRPDev->fCursor = 0;
    if (pGlobals->cyafterblock == CYSBD_AUTO_INCREMENT)
        pRPDev->fCursor |= RES_CUR_Y_POS_AUTO;

    if (pGlobals->cxafterblock == CXSBD_AT_GRXDATA_ORIGIN)
        pRPDev->fCursor |= RES_CUR_X_POS_ORG;

    else if (pGlobals->cxafterblock == CXSBD_AT_CURSOR_X_ORIGIN)
        pRPDev->fCursor |= RES_CUR_X_POS_AT_0;

    //
    // check for compression modes
    //
    if (!pRPDev->pfnOEMFilterGraphics)
    {
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLETIFF4))
        {
            pRPDev->fRMode |= PFR_COMP_TIFF;
        }
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLEFERLE))
        {
            pRPDev->fRMode |= PFR_COMP_FERLE;
        }
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLEDRC) &&
            !pPDev->pGlobals->bSendMultipleRows &&
            pRPDev->sDevPlanes == 1 && bEnoughDRCMemory(pPDev))
        {
            // For DRC we disable moving the left boundary
            //
            pRPDev->fBlockOut &= ~RES_BO_LEADING_BLNKS;
            pRPDev->fDump &= ~RES_DM_LEFT_BOUND;
            //
            // If there is a source width command we also disable
            // TRAILING blanks
            //
            if (pRPDev->fRMode & PFR_SENDSRCWIDTH)
                pRPDev->fBlockOut &= ~RES_BO_TRAILING_BLNKS;
            //
            // For DRC we disable all rules
            pRPDev->fRMode &= ~PFR_RECT_FILL;

            pRPDev->fRMode |= PFR_COMP_DRC;
        }
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLEOEMCOMP))
        {
            if (pRPDev->pfnOEMCompression)
                pRPDev->fRMode |= PFR_COMP_OEM;
        }
        // for these compression modes it is more efficient to
        // disable horizontal rules code and enclosed blanks
        //
        if (pRPDev->fRMode & (PFR_COMP_TIFF | PFR_COMP_DRC | PFR_COMP_FERLE))
        {
            pRPDev->fRMode &= ~PFR_RECT_HORIZFILL;
            pRPDev->fBlockOut &= ~RES_BO_ENCLOSED_BLNKS;
        }
    }
    return TRUE;
}

//**************************************************************
BOOL
bInitColorOrder(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine initializes the order to print the color planes
    for those devices that specify multiple plane output. It also
    maps the appropriate color command for each color.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

--*/

{
    PCOLORMODEEX pColorModeEx;
    PLISTNODE pListNode;
    DWORD dwIndex;
    DWORD dwColorCmd;
    BYTE ColorIndex;
    INT dwPlanes = 0;
    INT iDevNumPlanes;
    PRASTERPDEV pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    // check if structure exists
    if (pPDev->pColorModeEx)
    {
        short sDrvBPP;
        sDrvBPP = (short)pPDev->pColorModeEx->dwDrvBPP;
        pRPDev->sDevBPP = (short)pPDev->pColorModeEx->dwPrinterBPP;
        pRPDev->sDevPlanes = (short)pPDev->pColorModeEx->dwPrinterNumOfPlanes;
        pRPDev->dwIPCallbackID = pPDev->pColorModeEx->dwIPCallbackID;
        //
        // calculate equivalent output pixel depth and
        // test for valid formats
        //
        if (pRPDev->sDevPlanes == 1)
        {
            if (pRPDev->sDevBPP != 1 &&
                pRPDev->sDevBPP != 8 &&
                pRPDev->sDevBPP != 24)
            {
                ERR (("Unidrv: Invalid DevBPP\n"));
                return FALSE;
            }
            pRPDev->sDrvBPP = pRPDev->sDevBPP;
        }
        else if ((pRPDev->sDevBPP == 1) &&
                (pRPDev->sDevPlanes == 3 || pRPDev->sDevPlanes == 4))
        {
            pRPDev->sDrvBPP = 4;
        }
#ifdef MULTIPLANE
        else if ((pRPDev->sDevBPP == 2) &&
                (pRPDev->sDevPlanes == 3 || pRPDev->sDevPlanes == 4))
        {
            pRPDev->CyanLevels = 2;
            pRPDev->MagentaLevels = 2;
            pRPDev->YellowLevels = 2;
            pRPDev->BlackLevels = 1;
            pRPDev->sDevBitsPerPlane = 2;
            pRPDev->sDrvBPP = 8;
        }
        else if (pRPDev->sDevPlanes > 4 && pRPDev->sDevPlanes <= 8)
        {
            pRPDev->CyanLevels = 3;
            pRPDev->MagentaLevels = 3;
            pRPDev->YellowLevels = 3;
            pRPDev->BlackLevels = 3;
            pRPDev->sDevBitsPerPlane = 1;
            pRPDev->sDrvBPP = 8;
        }
#endif
        else
            pRPDev->sDrvBPP = 0;

        // test for valid input, input must match render depth
        // or there must be a callback function
        //
        if (pRPDev->sDrvBPP != sDrvBPP &&
            (pRPDev->dwIPCallbackID == 0 ||
             pRPDev->pfnOEMImageProcessing == NULL))
        {
            ERR (("Unidrv: OEMImageProcessing callback required\n"))
            return FALSE;
        }
        //
        // if color mode we need to determine the color order to
        // send the different color planes
        //
        if (pPDev->pColorModeEx->bColor && pRPDev->sDrvBPP > 1)
        {
            //* Initialize 8BPP and 24BPP flags
            pRPDev->sDevPlanes = (short)pPDev->pColorModeEx->dwPrinterNumOfPlanes;
            if (pRPDev->sDevPlanes > 1)
            {
                iDevNumPlanes = pRPDev->sDevPlanes;

                pListNode = LISTNODEPTR(pPDev->pDriverInfo,pPDev->pColorModeEx->liColorPlaneOrder);
                while (pListNode && dwPlanes < iDevNumPlanes)
                {
                    switch (pListNode->dwData)
                    {
                    case COLOR_CYAN:
                        ColorIndex = DC_PLANE_CYAN;
                        dwColorCmd = CMD_SENDCYANDATA;
                        break;
                    case COLOR_MAGENTA:
                        ColorIndex = DC_PLANE_MAGENTA;
                        dwColorCmd = CMD_SENDMAGENTADATA;
                        break;
                    case COLOR_YELLOW:
                        ColorIndex = DC_PLANE_YELLOW;
                        dwColorCmd = CMD_SENDYELLOWDATA;
                        break;
                    case COLOR_RED:
                        ColorIndex = DC_PLANE_RED;
                        dwColorCmd = CMD_SENDREDDATA;
                        pRPDev->fColorFormat |= DC_PRIMARY_RGB;
                        break;
                    case COLOR_GREEN:
                        ColorIndex = DC_PLANE_GREEN;
                        dwColorCmd = CMD_SENDGREENDATA;
                        pRPDev->fColorFormat |= DC_PRIMARY_RGB;
                        break;
                    case COLOR_BLUE:
                        ColorIndex = DC_PLANE_BLUE;
                        dwColorCmd = CMD_SENDBLUEDATA;
                        pRPDev->fColorFormat |= DC_PRIMARY_RGB;
                        break;
                    case COLOR_BLACK:
                        ColorIndex = DC_PLANE_BLACK;
                        dwColorCmd = CMD_SENDBLACKDATA;
                        break;
#ifdef MULTIPLANE
                    // TBD
#endif                        
                    default:
                        ERR (("Invalid ColorPlaneOrder value"));
                        return FALSE;
                        break;
                    }
                    // verify the command exists
                    if (COMMANDPTR(pPDev->pDriverInfo,dwColorCmd) == NULL)
                        return FALSE;

#ifdef MULTIPLANE
                    if (iDevNumPlanes >= 6)
                    {
                        pRPDev->rgbOrder[dwPlanes] = ColorIndex+4;
                        pRPDev->rgbCmdOrder[dwPlanes] = CMD_SENDBLACKDATA;
                        dwPlanes++;
                    }
#endif                    
                    pRPDev->rgbOrder[dwPlanes] = ColorIndex;
                    pRPDev->rgbCmdOrder[dwPlanes] = dwColorCmd;
                    dwPlanes++;
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
                }
                // GPD must define all planes
                if (dwPlanes < iDevNumPlanes)
                    return FALSE;

                //* Determine DC_EXTRACT_BLK flag
                if (iDevNumPlanes == 4)
                    pRPDev->fColorFormat |= DC_EXTRACT_BLK;
            }
            else if (pRPDev->sDevPlanes != 1)
                return FALSE;

            // if we have an OEM callback then it is
            // responsible for black generation and data inversion
            //
            if (pRPDev->pfnOEMImageProcessing)
                pRPDev->fColorFormat |= DC_OEM_BLACK;

            pRPDev->fDump |= RES_DM_COLOR;
        }
        // monochrome but could have pixel depth
        else {
            pRPDev->sDevPlanes = 1;
            pRPDev->rgbOrder[0] = DC_PLANE_BLACK;
            pRPDev->rgbCmdOrder[0] = CMD_SENDBLOCKDATA;
        }
    }
    // no ColorMode so use default: monochrome mode
    else {
        pRPDev->sDrvBPP = 1;
        pRPDev->sDevBPP = 1;
        pRPDev->sDevPlanes = 1;
        pRPDev->rgbOrder[0] = DC_PLANE_BLACK;
        pRPDev->rgbCmdOrder[0] = CMD_SENDBLOCKDATA;
    }
    return TRUE;
}

//*************************************************
void
vSetHTData(
    PDEV *pPDev,
    GDIINFO *pGDIInfo
)
/*++

Routine Description:
    Fill in the halftone information required by GDI.  These are filled
    in from the GPD data or from default values.

Arguments:
    pPDev           Pointer to PDEV structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

--*/
{
    INT         iPatID;
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;
    PHALFTONING pHalftone = pPDev->pHalftone;
    DWORD       dwType = REG_DWORD;
    DWORD       ul;
    int         iGenProfile;


    // set to spotdiameter, if zero, GDI calculates its own value
    // Set MS bit designating a percentage value * 10.
    //
    if (pPDev->pResolutionEx->dwSpotDiameter >= 10000)
    {
        pPDev->fMode |= PF_SINGLEDOT_FILTER;
        pGDIInfo->ulDevicePelsDPI = ((pPDev->pResolutionEx->dwSpotDiameter - 10000) * 10) | 0x8000;
    }
    else
        pGDIInfo->ulDevicePelsDPI = (pPDev->pResolutionEx->dwSpotDiameter * 10) | 0x8000;

    // RASDD always sets this to BLACK_DYE only
    // HT_FLAG_: SQUARE_DEVICE_PEL/HAS_BLACK_DYE/ADDITIVE_PRIMS/OUTPUT_CMY
    //
    pGDIInfo->flHTFlags   = HT_FLAG_HAS_BLACK_DYE;
    
#ifdef MULTIPLANE
    if (pRPDev->sDevBitsPerPlane)
    {
        pGDIInfo->flHTFlags |= MAKE_CMY332_MASK(pRPDev->CyanLevels,
                                                pRPDev->MagentaLevels,
                                                pRPDev->YellowLevels);
    }
#endif    
    
    // 
    // For 16 and 24bpp devices GDI will not do device color
    // mapping unless this flag is set in the GPD
    //
#ifndef WINNT_40    
    if (pPDev->pGlobals->bEnableGDIColorMapping)
        pGDIInfo->flHTFlags |= HT_FLAG_DO_DEVCLR_XFORM;
    if (pPDev->pdmPrivate->iQuality != QS_BEST &&  
        !(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS))
    {
        pGDIInfo->flHTFlags |= HT_FLAG_PRINT_DRAFT_MODE;
    }
#endif
    // At this point we need to determine the halftoning pattern
    // to be utilized depending on whether this is a standard halftone
    // custom halftone or oem supplied dither method
    //

    // if standard halftone ID map to standard pattern size values
    //
#ifndef WINNT_40
    if (!pHalftone || pHalftone->dwHTID == HT_PATSIZE_AUTO)
    {
        if (pPDev->sBitsPixel == 1)
            iPatID = PickDefaultHTPatSize((DWORD)pGDIInfo->ulLogPixelsX,
                                          (DWORD)pGDIInfo->ulLogPixelsY);
        else if (pPDev->sBitsPixel == 8)
            iPatID = HT_PATSIZE_4x4_M;

        else if (pPDev->sBitsPixel >= 24)
            iPatID = HT_PATSIZE_8x8_M;

        else
            iPatID = HT_PATSIZE_SUPERCELL_M;
    }
    else if (pHalftone->dwHTID <= HT_PATSIZE_MAX_INDEX)
    {
        iPatID = pHalftone->dwHTID;
    }
    else
    {
        iPatID = HT_PATSIZE_USER;
    }
#else    
    if (!pHalftone || pHalftone->dwHTID == HT_PATSIZE_AUTO || pHalftone->dwHTID > HT_PATSIZE_MAX_INDEX)
    {
	    if (pPDev->sBitsPixel == 8)
    	    iPatID = HT_PATSIZE_4x4_M;

		else if (pPDev->sBitsPixel == 4 && pGDIInfo->ulLogPixelsX < 400)
			iPatID = HT_PATSIZE_6x6_M;
    
    	else
        	iPatID = PickDefaultHTPatSize((DWORD)pGDIInfo->ulLogPixelsX,
                                          (DWORD)pGDIInfo->ulLogPixelsY);
	}
	else
		iPatID = pHalftone->dwHTID;
#endif
    //
    // setup ciDevice to point to default color space based
    // on halftone method and render depth
    //
    // 22-Jan-1998 Thu 01:17:54 updated  -by-  Daniel Chou (danielc)
    //  for saving the data, we will assume gamma 1.0 and has dye correction to
    //  start with then modify as necessary
    //

    pGDIInfo->ciDevice = DefColorInfoLinear;

    if (pPDev->sBitsPixel >= 24 && pRPDev->pfnOEMImageProcessing) 
    {

        //
        // No dye correction and the gamma is linear 1.0
        //

        ZeroMemory(&(pGDIInfo->ciDevice.MagentaInCyanDye),
                   sizeof(LDECI4) * 6);

    } 
    else 
    {

        LDECI4  Gamma;


        if (pPDev->sBitsPixel >= 8) {

            Gamma = GAMMA_DEVICE_HT;

        } 
#ifndef WINNT_40        
        else if ((iPatID == HT_PATSIZE_SUPERCELL) ||
                   (iPatID == HT_PATSIZE_SUPERCELL_M)) 
        {
            Gamma = GAMMA_SUPERCELL;
        } 
#endif        
        else 
        {
            Gamma = GAMMA_DITHER;
        }

        pGDIInfo->ciDevice.RedGamma   =
        pGDIInfo->ciDevice.GreenGamma =
        pGDIInfo->ciDevice.BlueGamma  = Gamma;
    }

    //
    // If this flag is set in the registry we inform GDI halftoning
    // to ignore all color settings and pass data through raw
    // for calibration purposes
    //
    if( !EngGetPrinterData( pPDev->devobj.hPrinter, L"ICMGenProfile", &dwType,
                       (BYTE *)&iGenProfile, sizeof(iGenProfile), &ul ) &&
        ul == sizeof(iGenProfile) && iGenProfile == 1 )
    {
        pGDIInfo->ciDevice.RedGamma   =
        pGDIInfo->ciDevice.GreenGamma =
        pGDIInfo->ciDevice.BlueGamma  = GAMMA_GEN_PROFILE;
    }
    else
    {
        //
        // now modify with any GPD parameters
        //
        if ((int)pPDev->pResolutionEx->dwRedDeviceGamma >= 0)
            pGDIInfo->ciDevice.RedGamma = pPDev->pResolutionEx->dwRedDeviceGamma;
        if ((int)pPDev->pResolutionEx->dwGreenDeviceGamma >= 0)
            pGDIInfo->ciDevice.GreenGamma = pPDev->pResolutionEx->dwGreenDeviceGamma;
        if ((int)pPDev->pResolutionEx->dwBlueDeviceGamma >= 0)
            pGDIInfo->ciDevice.BlueGamma = pPDev->pResolutionEx->dwBlueDeviceGamma;
        if ((int)pPDev->pGlobals->dwMagentaInCyanDye >= 0)
            pGDIInfo->ciDevice.MagentaInCyanDye = pPDev->pGlobals->dwMagentaInCyanDye;
        if ((int)pPDev->pGlobals->dwYellowInCyanDye >= 0)
            pGDIInfo->ciDevice.YellowInCyanDye = pPDev->pGlobals->dwYellowInCyanDye;
        if ((int)pPDev->pGlobals->dwCyanInMagentaDye >= 0)
            pGDIInfo->ciDevice.CyanInMagentaDye = pPDev->pGlobals->dwCyanInMagentaDye;
        if ((int)pPDev->pGlobals->dwYellowInMagentaDye >= 0)
            pGDIInfo->ciDevice.YellowInMagentaDye = pPDev->pGlobals->dwYellowInMagentaDye;
        if ((int)pPDev->pGlobals->dwCyanInYellowDye >= 0)
            pGDIInfo->ciDevice.CyanInYellowDye = pPDev->pGlobals->dwCyanInYellowDye;
        if ((int)pPDev->pGlobals->dwMagentaInYellowDye >= 0)
            pGDIInfo->ciDevice.MagentaInYellowDye = pPDev->pGlobals->dwMagentaInYellowDye;
    }
    //
    // test for a custom pattern
    //
#ifndef WINNT_40    
    if (iPatID == HT_PATSIZE_USER)
    {
        DWORD dwX,dwY,dwPats,dwRC,dwCallbackID,dwPatSize,dwOnePatSize;
        int iSize = 0;
        PBYTE pRes = NULL;

        dwX = pHalftone->HalftonePatternSize.x;
        dwY = pHalftone->HalftonePatternSize.y;
        dwRC = pHalftone->dwRCpatternID;

        pGDIInfo->ulHTPatternSize = HT_PATSIZE_DEFAULT;

        if (dwX < HT_USERPAT_CX_MIN || dwX > HT_USERPAT_CX_MAX ||
            dwY < HT_USERPAT_CY_MIN || dwY > HT_USERPAT_CY_MAX)
        {
            ERR (("Unidrv!RMInit: Missing or invalid custom HT size\n"));
            return;
        }
        dwPats = pHalftone->dwHTNumPatterns;
        dwCallbackID = pHalftone->dwHTCallbackID;

        // calculate the size of the halftone pattern
        //
        dwOnePatSize = ((dwX * dwY) + 3) & ~3;
        dwPatSize = dwOnePatSize * dwPats;

        // test for resource ID which means the pattern is
        // in the resource dll.
        //
        if (dwRC > 0)
        {
            RES_ELEM ResInfo;
            if (!BGetWinRes(&pPDev->WinResData,(PQUALNAMEEX)&dwRC,RC_HTPATTERN,&ResInfo))
            {
                ERR (("Unidrv!RMInit: Can't find halftone resource\n"));
                return;
            }
            else if ((DWORD)ResInfo.iResLen < dwPatSize && dwCallbackID <= 0)
            {
                ERR (("Unidrv!RMInit: Invalid resource size\n"));
                return;
            }
            pRes = ResInfo.pvResData;
            iSize = ResInfo.iResLen;
        }
        else if (dwCallbackID <= 0)
        {
            ERR (("Unidrv!RMInit: no OEMHalftonePattern callback ID\n"));
            return;
        }
        //
        // test whether we need to make the OEMHalftonePattern callback
        // this will either unencrypt the resource pattern or it will
        // generate a halftone pattern on the fly.
        //
        if (dwCallbackID > 0)
        {
            PBYTE pPattern;
            // allocate memory for the callback
            //
            if ((pPattern = MemAllocZ(dwPatSize)) != NULL)
            {
                BOOL  bStatus = FALSE;

                FIX_DEVOBJ(pPDev,EP_OEMHalftonePattern);


                if (pRPDev->pfnOEMHalftonePattern)
                {
                    if(pPDev->pOemEntry)
                    {
                        if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                        {
                                HRESULT  hr ;
                                hr = HComHalftonePattern((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                            (PDEVOBJ)pPDev,pPattern,dwX,dwY,dwPats,dwCallbackID,pRes,iSize) ;
                                if(SUCCEEDED(hr))
                                    bStatus =  TRUE ;  //  cool !
                        }
                        else
                        {
                            bStatus = pRPDev->pfnOEMHalftonePattern((PDEVOBJ)pPDev,pPattern,dwX,dwY,dwPats,dwCallbackID,pRes,iSize) ;
                        }
                    }
                }


                if(!bStatus)
                {
                    MemFree (pPattern);
                    ERR (("\nUnidrv!RMInit: Failed OEMHalftonePattern call\n"));
                    return;
                }
                else
                {
                    pRes = pPattern;
                    pRPDev->pHalftonePattern = pPattern;
                }
            }
            else
            {
                ERR (("\nUnidrv!RMInit: Failed Custom Halftone MemAlloc\n"));
                return;
            }
        }
        //
        // if we still have a valid custom pattern we will now
        // update the GDIINFO structure
        //
        pGDIInfo->cxHTPat = dwX;
        pGDIInfo->cyHTPat = dwY;
        pGDIInfo->pHTPatA = pRes;
        if (dwPats == 3)
        {
            pGDIInfo->pHTPatB = &pRes[dwOnePatSize];
            pGDIInfo->pHTPatC = &pRes[dwOnePatSize*2];
        }
        else {
            pGDIInfo->pHTPatB = pRes;
            pGDIInfo->pHTPatC = pRes;
        }
    }
#endif    
    pGDIInfo->ulHTPatternSize = iPatID;
    return;
}
//*************************************************************
DWORD
PickDefaultHTPatSize(
    DWORD   xDPI,
    DWORD   yDPI
    )

/*++

Routine Description:

    This function return default halftone pattern size used for
    a particular device resolution

Arguments:

    xDPI            - Device LOGPIXELS X

    yDPI            - Device LOGPIXELS Y

Return Value:

    DWORD   HT_PATSIZE_xxxx

--*/
{
    DWORD   HTPatSize;

    //
    // use the smaller resolution as the pattern guide
    //

    if (xDPI > yDPI)
        xDPI = yDPI;

    if (xDPI >= 2400)
        HTPatSize = HT_PATSIZE_16x16_M;

    else if (xDPI >= 1800)
        HTPatSize = HT_PATSIZE_14x14_M;

    else if (xDPI >= 1200)
        HTPatSize = HT_PATSIZE_12x12_M;

    else if (xDPI >= 800)
        HTPatSize = HT_PATSIZE_10x10_M;

    else if (xDPI >= 300)
        HTPatSize = HT_PATSIZE_8x8_M;

    else
        HTPatSize = HT_PATSIZE_6x6_M;

    return(HTPatSize);
}
//*************************************************************
BOOL
bEnoughDRCMemory(
    PDEV *pPDev
    )
/*++

Routine Description:

    This function determines whether the device has sufficient
    memory to enable DRC compression.

Arguments:

    pPDev           - pointer to PDEV structure

Return Value:

    TRUE if sufficient memory, else FALSE

--*/
{
    //
    // if this is a page printer then we will require that there be enough
    // free memory to store the entire raster page at 1bpp
    //
    if (pPDev->pGlobals->printertype != PT_PAGE ||
        !(COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION)) ||
        (pPDev->pMemOption && (int)pPDev->pMemOption->dwInstalledMem >
        (pPDev->sf.szImageAreaG.cx * pPDev->sf.szImageAreaG.cy >> 3)))
    {
        return TRUE;
    }
    VERBOSE (("Unidrv: Insufficient memory for DRC\n"));
    return FALSE;
}
#ifndef DISABLE_NEWRULES
//*************************************************************
VOID
OutputRules(
    PDEV *pPDev
    )
/*++

Routine Description:

    This function outputs any rules that still remain after rendering
	the current band or page.

Arguments:

    pPDev           - pointer to PDEV structure

Return Value:

    none

--*/
{
    if (pPDev->pbRulesArray && pPDev->dwRulesCount)
    {
        PRECTL pRect;
        DWORD i;
        DRAWPATRECT PatRect;
        PatRect.wStyle = 0;     // black rectangle
        PatRect.wPattern = 0;   // pattern not used

//		DbgPrint("Black rules = %u\n",pPDev->dwRulesCount);

        for (i = 0;i < pPDev->dwRulesCount;i++)
        {
            pRect = &pPDev->pbRulesArray[i];
            PatRect.ptPosition.x = pRect->left;
            PatRect.ptPosition.y = pRect->top;
            PatRect.ptSize.x = pRect->right - pRect->left;
            PatRect.ptSize.y = pRect->bottom - pRect->top;
            if (pPDev->fMode & PF_SINGLEDOT_FILTER)
            {
                if (PatRect.ptSize.y < 2)
                    PatRect.ptSize.y = 2;
                if (PatRect.ptSize.x < 2)
                    PatRect.ptSize.x = 2;
            }
            DrawPatternRect(pPDev,&PatRect);
        }
        pPDev->dwRulesCount = 0;
    }
}
#endif
//*************************************************************
VOID
EnableMirroring(
    PDEV *pPDev,
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function mirrors the data in the current band or page.

Arguments:

    pPDev           - pointer to PDEV structure
    pso             - pointer to SURFOBJ structure containing the bitmap

Return Value:

    none

--*/
{
    INT     iScanLine;
    INT     iLastY;
    INT     i;
    
    // if the surface hasn't been used then no point in mirroring it
    //
    if (!(pPDev->fMode & PF_SURFACE_USED))
        return;
        
    // precalculate necessary shared loop parameters
    //
    iScanLine = (((pso->sizlBitmap.cx * pPDev->sBitsPixel) + 31) & ~31) / BBITS;
    iLastY = pPDev->rcClipRgn.bottom - pPDev->rcClipRgn.top;

    // First test whether we need to do landscape mirroring
    // If so we will mirror the data top to bottom by swapping scan lines
    //
    if (pPDev->pOrientation && pPDev->pOrientation->dwRotationAngle != ROTATE_NONE)
    {
        BYTE ubWhite;
        INT  iTmpLastY = iLastY;
        
        // determined erase byte
        //
        if (pPDev->sBitsPixel == 4)
            ubWhite = 0x77;
        else if (pPDev->sBitsPixel == 8)
            ubWhite = (BYTE)((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;
        else
            ubWhite = 0xff;
        
        // loop once per scan line swapping the rows
        //
        iLastY--;
        for (i = 0;i < iLastY;i++,iLastY--)
        {
            BYTE    *pBits1,*pBits2;

            pBits1 = (PBYTE)pso->pvBits + (iScanLine * i);
            pBits2 = (PBYTE)pso->pvBits + (iScanLine * iLastY);
            
            // test if bottom line has data
            //
            if (pPDev->pbRasterScanBuf[iLastY / LINESPERBLOCK] & 1)
            {
                // test if top line has data, if so swap data
                //
                if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK] & 1)
                {
                    INT j = iScanLine >> 2;
                    do {
                        DWORD dwTmp = ((DWORD *)pBits1)[j];
                        ((DWORD *)pBits1)[j] = ((DWORD *)pBits2)[j];
                        ((DWORD *)pBits2)[j] = dwTmp;
                    } while (--j > 0);
                }
                else
                {
                    CopyMemory(pBits1,pBits2,iScanLine);
                    FillMemory(pBits2,iScanLine,ubWhite);
                }
            }
            // test if top line has data
            //
            else if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK] & 1)
            {
                CopyMemory(pBits2,pBits1,iScanLine);
                FillMemory(pBits1,iScanLine,ubWhite);
            }
            // neither scan line has data but we need to erase both anyway
            //
            else
            {
                FillMemory(pBits1,iScanLine,ubWhite);
                FillMemory(pBits2,iScanLine,ubWhite);
            }
     
        }
        // set all bits since everything has been erased
        for (i = 0;i < iTmpLastY;i += LINESPERBLOCK)
        {
            pPDev->pbRasterScanBuf[i / LINESPERBLOCK] = 1;
        }            
    }
    //
    // We are doing portrait mirroring, test for 1bpp
    //
    else if (pPDev->sBitsPixel == 1)
    {
        BYTE ubMirror[256];
        INT iLastX;
        INT iShift;

        // create byte mirroring table
        //
        for (i = 0;i < 256;i++)
        {
            BYTE bOut = 0;
            if (i & 0x01) bOut |= 0x80;
            if (i & 0x02) bOut |= 0x40;
            if (i & 0x04) bOut |= 0x20;
            if (i & 0x08) bOut |= 0x10;
            if (i & 0x10) bOut |= 0x08;
            if (i & 0x20) bOut |= 0x04;
            if (i & 0x40) bOut |= 0x02;
            if (i & 0x80) bOut |= 0x01;
            ubMirror[i] = bOut;
        }
        // create shift value to re-align data
        //
        iShift = (8 - (pso->sizlBitmap.cx & 0x7)) & 0x7;
        
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j;
                INT iLastX;
                
                // test whether we need to pre-shift the data
                //
                if (iShift)
                {
                    iLastX = (pso->sizlBitmap.cx + 7) / 8;
                    iLastX--;
                    while (iLastX > 0)
                    {
                        pBits[iLastX] = (pBits[iLastX-1] << (8-iShift)) | (pBits[iLastX] >> iShift);
                        iLastX--;
                    }
                    pBits[0] = (BYTE)(pBits[0] >> iShift);
                }
                // Now we are ready to mirror the bytes
                //                
                j = 0;
                iLastX = (pso->sizlBitmap.cx + 7) / 8;
                while (j < iLastX)
                {
                    BYTE ubTmp;
                    iLastX--;
                    ubTmp = ubMirror[pBits[iLastX]];
                    pBits[iLastX] = ubMirror[pBits[j]];
                    pBits[j] = ubTmp;
                    j++;
                }
            }
        }        
    }    
    //
    // We are doing portrait mirroring, test for 4bpp
    //
    else if (pPDev->sBitsPixel == 4)
    {
        BYTE ubMirror[256];

        // create byte mirroring table
        //
        for (i = 0;i < 256;i++)
        {
            ubMirror[i] = ((BYTE)i << 4) | ((BYTE)i >> 4);
        }
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j = 0;
                INT iLastX = (pso->sizlBitmap.cx + 1) / 2;
                while (j < iLastX)
                {
                    BYTE ubTmp;
                    iLastX--;
                    ubTmp = ubMirror[pBits[iLastX]];
                    pBits[iLastX] = ubMirror[pBits[j]];
                    pBits[j] = ubTmp;
                    j++;
                }
            }
        }        
    }    
    //
    // We are doing portrait mirroring, test for 8bpp
    //
    else if (pPDev->sBitsPixel == 8)
    {
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j = 0;
                INT iLastX = pso->sizlBitmap.cx - 1;
                while (j < iLastX)
                {
                    BYTE ubTmp = pBits[iLastX];
                    pBits[iLastX] = pBits[j];
                    pBits[j] = ubTmp;
                    iLastX--;
                    j++;
                }
            }
        }        
    }    
    //
    // We are doing portrait mirroring, 24bpp
    //
    else
    {
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j = 0;
                INT iLastX = (pso->sizlBitmap.cx * 3) - 3;
                while (j < iLastX)
                {
                    BYTE ubTmp[3];
                    memcpy(&ubTmp[0],&pBits[iLastX],3);
                    memcpy(&pBits[iLastX],&pBits[j],3);
                    memcpy(&pBits[j],&ubTmp,3);
                    iLastX -= 3;
                    j += 3;
                }
            }
        }        
    }    
}
//*************************************************************
PDWORD
pSetupOEMImageProcessing(
    PDEV *pPDev,
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function initializes all the relevant parameters and then
    calls the OEMImageProcessing function.

Arguments:

    pPDev           - pointer to PDEV structure
    pso             - pointer to SURFOBJ structure
    pptl            - pointer to current position of band

Return Value:

    Pointer to modified bitmap if any

--*/
{
#ifndef DISABLE_SUBBANDS
    BITMAPINFOHEADER bmi;
    IPPARAMS State;
    RASTERPDEV *pRPDev;
    PBYTE               pbResult = NULL ;
    INT iStart, iEnd ,iScanLine, iLastY;

    pRPDev = pPDev->pRasterPDEV;

    //
    // initialize the state structure
    //
    State.dwSize = sizeof (IPPARAMS);
    State.bBanding = pPDev->bBanding;
    //
    // Determine the pointer to the halftone option name
    //
    if (pPDev->pHalftone)
    {
        State.pHalftoneOption =
            OFFSET_TO_POINTER(pPDev->pDriverInfo->pubResourceData,
            pPDev->pHalftone->GenericOption.loKeywordName);
    }
    else
        State.pHalftoneOption = NULL;

    //
    // Set blank band flag if this band hasn't been erased or
    // drawn on.
    if ((pPDev->fMode & PF_SURFACE_USED) && 
            ((pPDev->fMode & PF_ROTATE) ||
             (pRPDev->sDrvBPP != 0) || 
             ((LINESPERBLOCK % pRPDev->sNPins) != 0)))
    {
        CheckBitmapSurface(pso, NULL);
    }

    //
    // loop once per strip
    //
    iScanLine = (((pso->sizlBitmap.cx * pPDev->sBitsPixel) + 31) & ~31) / BBITS;
    iLastY = pPDev->rcClipRgn.bottom - pPDev->rcClipRgn.top;

if(pPDev->iBandDirection == SW_UP)
{
    iStart = iLastY;
    do
    {
        // search for contiguous sub-bands of white or non-white
        //
        PBYTE pBits;
        BYTE Mode;

        iEnd = iStart ;
        iStart = ((iEnd - 1)/ LINESPERBLOCK) * LINESPERBLOCK ;

        //  first band (end of bitmap) may be partial.

        Mode = pPDev->pbRasterScanBuf[iStart / LINESPERBLOCK];
        while (iStart)  //  not yet at start of bitmap
        {
            int  iPreview  =  iStart - LINESPERBLOCK;

            if (Mode != pPDev->pbRasterScanBuf[iPreview / LINESPERBLOCK])
                break;
            iStart = iPreview  ;
        }

        // initialize starting position of the sub-band
        //
        State.ptOffset.x = pPDev->rcClipRgn.left;
        State.ptOffset.y = pPDev->rcClipRgn.top + iStart;

        // test whether to set blank flag
        //
        if (Mode)
            State.bBlankBand = FALSE;
        else
            State.bBlankBand = TRUE;

        //
        // initialize the bitmapinfo structure
        //
        bmi.biSize = sizeof (BITMAPINFOHEADER);
        bmi.biWidth = pso->sizlBitmap.cx;
        bmi.biHeight = iEnd - iStart;
        bmi.biPlanes = 1;
        bmi.biBitCount = pPDev->sBitsPixel;
        bmi.biSizeImage = iScanLine * bmi.biHeight;
        bmi.biCompression = BI_RGB;
        bmi.biXPelsPerMeter = pPDev->ptGrxRes.x;
        bmi.biYPelsPerMeter = pPDev->ptGrxRes.y;
        bmi.biClrUsed = 0;
        bmi.biClrImportant = 0;

        // update the bitmap pointer
        //
        pBits = (PBYTE)pso->pvBits + (iScanLine * iStart);

        // update the pPDev pointer for this callback
        //
        FIX_DEVOBJ(pPDev,EP_OEMImageProcessing);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComImageProcessing((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State, &pbResult);
                if(SUCCEEDED(hr))
                    ;  //  cool !
            }
            else
            {
                pbResult = pRPDev->pfnOEMImageProcessing(
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State);
            }
            if (pbResult == NULL)
            {
#if DBG
                DbgPrint ("unidrv!ImageProcessing: OEMImageProcessing returned error\n");
#endif
                break;
            }
        }
    } while (iStart  /* iEnd < iLastY */);

}
else
{

    iEnd = 0;
    do
    {
        // search for contiguous sub-bands of white or non-white
        //
        PBYTE pBits;
        BYTE Mode;
        iStart = iEnd;
        Mode = pPDev->pbRasterScanBuf[iEnd / LINESPERBLOCK];
        while (1)
        {
            iEnd += LINESPERBLOCK;
            if (iEnd >= iLastY)
                break;
            if (Mode != pPDev->pbRasterScanBuf[iEnd / LINESPERBLOCK])
                break;
        }
        //
        // limit this section to the end of the band
        //
        if (iEnd > iLastY)
            iEnd = iLastY;
            
        // initialize starting position of the sub-band
        //
        State.ptOffset.x = pPDev->rcClipRgn.left;
        State.ptOffset.y = pPDev->rcClipRgn.top + iStart;
        
        // test whether to set blank flag
        //
        if (Mode)
            State.bBlankBand = FALSE;
        else
            State.bBlankBand = TRUE;

        //
        // initialize the bitmapinfo structure
        //
        bmi.biSize = sizeof (BITMAPINFOHEADER);
        bmi.biWidth = pso->sizlBitmap.cx;
        bmi.biHeight = iEnd - iStart;
        bmi.biPlanes = 1;
        bmi.biBitCount = pPDev->sBitsPixel;
        bmi.biSizeImage = iScanLine * bmi.biHeight;
        bmi.biCompression = BI_RGB;
        bmi.biXPelsPerMeter = pPDev->ptGrxRes.x;
        bmi.biYPelsPerMeter = pPDev->ptGrxRes.y;
        bmi.biClrUsed = 0;
        bmi.biClrImportant = 0;
        
        // update the bitmap pointer
        //
        pBits = (PBYTE)pso->pvBits + (iScanLine * iStart);

        // update the pPDev pointer for this callback
        //
        FIX_DEVOBJ(pPDev,EP_OEMImageProcessing);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComImageProcessing((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State, &pbResult);
                if(SUCCEEDED(hr))
                    ;  //  cool !
            }
            else
            {
                pbResult = pRPDev->pfnOEMImageProcessing(
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State);
            }
            if (pbResult == NULL)
            {
#if DBG
                DbgPrint ("unidrv!ImageProcessing: OEMImageProcessing returned error\n");
#endif            
                break;
            }
        }
    } while (iEnd < iLastY);
}
#else
    BITMAPINFOHEADER bmi;
    IPPARAMS State;
    RASTERPDEV *pRPDev;
    PBYTE               pbResult = NULL ;

    pRPDev = pPDev->pRasterPDEV;

    //
    // initialize the state structure
    //
    State.dwSize = sizeof (IPPARAMS);
    State.bBanding = pPDev->bBanding;
    //
    // Determine the pointer to the halftone option name
    //
    if (pPDev->pHalftone)
    {
        State.pHalftoneOption =
            OFFSET_TO_POINTER(pPDev->pDriverInfo->pubResourceData,
            pPDev->pHalftone->GenericOption.loKeywordName);
    }
    else
        State.pHalftoneOption = NULL;

    //
    // Set blank band flag if this band hasn't been erased or
    // drawn on.
    if (pPDev->fMode & PF_SURFACE_USED)
    {
        CheckBitmapSurface(pso, NULL);
        State.bBlankBand = FALSE;
    }
    else
        State.bBlankBand = TRUE;

    // initialize starting position of the band
    //
    State.ptOffset.x = pPDev->rcClipRgn.left;
    State.ptOffset.y = pPDev->rcClipRgn.top;
    //
    // initialize the bitmapinfo structure
    //
    bmi.biSize = sizeof (BITMAPINFOHEADER);
    bmi.biWidth = pso->sizlBitmap.cx;
    bmi.biHeight = pso->sizlBitmap.cy;
    bmi.biPlanes = 1;
    bmi.biBitCount = pPDev->sBitsPixel;
    bmi.biCompression = BI_RGB;
    bmi.biSizeImage = (((bmi.biWidth * bmi.biBitCount) + 31) & ~31) *
                            bmi.biHeight;
    bmi.biXPelsPerMeter = pPDev->ptGrxRes.x;
    bmi.biYPelsPerMeter = pPDev->ptGrxRes.y;
    bmi.biClrUsed = 0;
    bmi.biClrImportant = 0;

    // update the pPDev pointer for this callback
    //
    FIX_DEVOBJ(pPDev,EP_OEMImageProcessing);

    if(pPDev->pOemEntry)
    {
        if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
        {
                HRESULT  hr ;
                hr = HComImageProcessing((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                    (PDEVOBJ)pPDev,
                    pso->pvBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State, &pbResult);
                if(SUCCEEDED(hr))
                    ;  //  cool !
        }
        else
        {
            pbResult = pRPDev->pfnOEMImageProcessing(
                (PDEVOBJ)pPDev,
                pso->pvBits,
                &bmi,
                (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                pRPDev->dwIPCallbackID,
                &State);
        }
    }
#endif
    return  (PDWORD)pbResult ;
}
//******************************************************************
BOOL
RMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )
/*++

Routine Description:

    This function is called to allow any raster module initialization
    at DrvStartDoc time.

Arguments:

    pso         Pointer to SURFOBJ
    pDocName    Pointer to document name
    jobId       Job ID

Return Value:

    TRUE for success and FALSE for failure

--*/
{
#ifdef TIMING
    ENG_TIME_FIELDS TimeTab;
    PDEV *pPDev = (PDEV *) pso->dhpdev;
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    pRPDev->dwDocTiming = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    DrvDbgPrint("Unidrv!StartDoc\n");
#endif
    return TRUE;
}

//************************ Function Header ***********************************
BOOL
RMEndDoc (
    SURFOBJ *pso,
    FLONG   flags
    )
/*++

Routine Description:

    This function is called at DrvEndDoc to allow the raster module
    to clean up any raster related initializations

Arguments:

    pso         Pointer to SURFOBJ
    FLONG       flags

Return Value:

    TRUE for success and FALSE for failure

--*/
{
#ifdef TIMING
    DWORD eTime;
    char    buf[80];
    ENG_TIME_FIELDS TimeTab;
    PDEV *pPDev = (PDEV *) pso->dhpdev;
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    eTime = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    sprintf (buf,"Unidrv!EndDoc: %ld\n",eTime - pRPDev->dwDocTiming);
    DrvDbgPrint(buf);
#endif
    return TRUE;
}

//******************************************************************
BOOL
RMStartPage (
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function is called to allow any raster module initialization
    at DrvStartPage time.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    return  TRUE;
}

//************************ Function Header ***********************************
BOOL
RMSendPage (
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function is called at DrvSendPage to allow the raster module
    to output any raster data to the printer.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    PDEV  *pPDev;               /* Access to all that is important */
    RENDER   RenderData;        /* Rendering data passed to bRender() */
    PRASTERPDEV pRPDev;        /* raster module PDEV */

    // all we need to do now is render the bitmap (output it to the printer)
    // we must be careful however since the control module also calls this
    // function after the last band has been output in banding mode. In this
    // case we don't want to output any data
    //
    pPDev = (PDEV *) pso->dhpdev;
    pRPDev = pPDev->pRasterPDEV;

    //
    // Reset palette data
    //
    if (pPDev->ePersonality == kPCLXL_RASTER && pPDev->pVectorPDEV)
    {
        PCLXLResetPalette((PDEVOBJ)pPDev);
    }

    if (pso->iType == STYPE_BITMAP)
    {
        PDWORD pBits;
        // 
        // test whether mirroring should be enabled
        //
        if (pPDev->fMode2 & PF2_MIRRORING_ENABLED)
            EnableMirroring(pPDev,pso);
        //
        // Decide whether to make OEM callback function
        //
        if (pRPDev->pfnOEMImageProcessing && !pPDev->bBanding)
        {
            if ((pBits = pSetupOEMImageProcessing(pPDev,pso)) == NULL)
                return FALSE;
        }
        else
            pBits = pso->pvBits;

        //
        // test whether unidrv is doing the dump
        //
        if (pRPDev->sDrvBPP)
        {
            if( pRPDev->pvRenderData != NULL )
            {
                // if we are not in banding mode we need to
                // render the data for the entire page.
                //
                if (!pPDev->bBanding)
                {
                    RenderData = *(RENDER *)(pRPDev->pvRenderData);

                    if( bRenderStartPage( pPDev ) )
                    {
#ifndef DISABLE_NEWRULES
                        OutputRules(pPDev);
#endif                        
                        bRender( pso, pPDev, &RenderData, pso->sizlBitmap, pBits );
                            ((RENDER *)(pRPDev->pvRenderData))->plrWhite =  RenderData.plrWhite;
                    }
                }
                // now we clean up our structures in
                // both banding and non-banding cases
                //
                bRenderPageEnd( pPDev );
            }
        }
        return TRUE;
    }
    return FALSE;
}


//************************ Function Header ***********************************
BOOL
RMNextBand (
    SURFOBJ *pso,
    POINTL *pptl
    )
/*++

Routine Description:

    This function is called at DrvSendPage to allow the raster module
    to output any raster data to the printer.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    RASTERPDEV *pRPDev;
    PDEV  *pPDev;                       /* Access to all that is important */

    pPDev = (PDEV *) pso->dhpdev;
    pRPDev = pPDev->pRasterPDEV;

    // only output if raster band or surface is dirty
    // if not just return true
    if (pPDev->fMode & PF_ENUM_GRXTXT)
    {
        PDWORD pBits;
        // 
        // test whether mirroring should be enabled
        //
        if (pPDev->fMode2 & PF2_MIRRORING_ENABLED)
            EnableMirroring(pPDev,pso);
        //
        // Decide whether to make OEM callback function
        //
        if (pRPDev->pfnOEMImageProcessing)
        {
            if ((pBits = pSetupOEMImageProcessing(pPDev,pso)) == NULL)
                return FALSE;
        }
        else
            pBits = pso->pvBits;

        //
        // test whether unidrv is doing the dump
        //
        if (pRPDev->sDrvBPP)
        {
            if( pRPDev->pvRenderData == NULL )
                return  FALSE;

            //
            // Reset palette data
            //
            if (pPDev->ePersonality == kPCLXL_RASTER && pPDev->pVectorPDEV)
            {
                PCLXLResetPalette((PDEVOBJ)pPDev);
            }

#ifndef DISABLE_NEWRULES
            OutputRules(pPDev);
#endif                        
            if( !bRender( pso, pPDev, pRPDev->pvRenderDataTmp, pso->sizlBitmap, pBits ) )
            {
                if ( ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite )
                    MemFree(((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite);

                ((RENDER *)(pRPDev->pvRenderData))->plrWhite =
                   ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite = NULL;
                return(FALSE);
            }

            if ( ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite )
                MemFree(((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite);

            ((RENDER *)(pRPDev->pvRenderData))->plrWhite =
               ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite = NULL;

        }
    }
    return(TRUE);
}

//************************ Function Header ***********************************
BOOL
RMStartBanding (
    SURFOBJ *pso,
    POINTL *pptl
    )
/*++

Routine Description:

    Called to tell the driver to prepare for banding and return the
    origin of the first band.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    PDEV      *pPDev;           /* Access to all that is important */
    RASTERPDEV *pRPDev;         /* raster module PDEV */

    pPDev = (PDEV *) pso->dhpdev;

    pRPDev = pPDev->pRasterPDEV;   /* For our convenience */

    //
    if (pRPDev->sDrvBPP)
    {

        if( pRPDev->pvRenderData == NULL )
            return  FALSE;          /* Should not happen, nasty if it does */

        if( !bRenderStartPage( pPDev ) )
            return   FALSE;

        /* reset the render data for this band */

        *(RENDER *)(pRPDev->pvRenderDataTmp) = *(RENDER *)(pRPDev->pvRenderData);

    }
    return(TRUE);
}

//************************ Function Header ***********************************
BOOL
RMResetPDEV (
    PDEV  *pPDevOld,
    PDEV  *pPDevNew
    )
/*++

Routine Description:
    Called when an application wishes to change the output style in the
    midst of a job.  Typically this would be to change from portrait to
    landscape or vice versa.  Any other sensible change is permitted.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:
   TRUE  - device successfully reorganised
   FALSE - unable to change - e.g. change of device name.

Note:

--*/
{
    // as near as I can tell I don't need to do anything
    // for the raster module.
    return TRUE;
}

//************************ Function Header ***********************************
BOOL
RMEnableSurface (
    PDEV *pPDev
    )
/*++

Routine Description:


Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure
Note:

--*/
{
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;

    if (DRIVER_DEVICEMANAGED (pPDev))   // device surface
        return TRUE;

    //Initialize the RPDev Paldata.
    ASSERT(pPDev->pPalData);
    pRPDev->pPalData = pPDev->pPalData;              /* For all the others! */

    //
    // initialize render parameters if we are doing
    // the dump function
    //
    if (pRPDev->sDrvBPP)
    {
        ULONG iFormat;
        // determine the bitmap format
        switch (pRPDev->sDrvBPP)
        {
        case 1:
            iFormat = BMF_1BPP;
            break;
        case 4:
            iFormat = BMF_4BPP;
            break;
        case 8:
            iFormat = BMF_8BPP;
            break;
        case 24:
            iFormat = BMF_24BPP;
            break;
        default:
            ERR(("Unknown sBitsPixel in RMEnableSurface"));
            return FALSE;
        }

        // if these calls fail, control will call RMDisableSurface
        //
        if( !bSkipInit( pPDev ) || !bInitTrans( pPDev ) )
        {
            return  FALSE;
        }

        /*
         *   Also initialise the rendering structures.
         */

        if( !bRenderInit( pPDev, pPDev->szBand, iFormat ) )
        {
            return  FALSE;
        }
    }
    return TRUE;
}

//************************ Function Header ***********************************
VOID
RMDisableSurface (
    PDEV *pPDev
    )
/*++

Routine Description:

    This function is called at DrvDisableSurface to allow the raster module
    to cleanup any required stuff usually generated at EnableSurface time.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    void

--*/
{
    RASTERPDEV  *pRPDev;          /* Unidrive stuff */


    pRPDev = pPDev->pRasterPDEV;

    /*
     *    Free the rendering storage.
     */
    if (pRPDev->sDrvBPP)
    {
        vRenderFree( pPDev );

        if( pRPDev->pdwTrans )
        {
            MemFree( pRPDev->pdwTrans );
            pRPDev->pdwTrans = NULL;
        }

        if( pRPDev->pdwColrSep )
        {
            MemFree( pRPDev->pdwColrSep );
            pRPDev->pdwColrSep = NULL;
        }

        if( pRPDev->pdwBitMask )
        {
            MemFree( pRPDev->pdwBitMask );
            pRPDev->pdwBitMask = NULL;
        }
    }
}

//************************ Function Header ***********************************
VOID
RMDisablePDEV (
    PDEV *pPDev
    )
/*++

Routine Description:

    Called when the engine has finished with this PDEV.  Basically
    we throw away all connections etc. then free the heap.

Arguments:

    pPDev         Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;

    /*
     *    Undo all that has been done with the PDEV.  Basically this means
     *  freeing the memory we consumed.
     */

    // test for valid raster PDEV
    if (pRPDev)
    {
        // Delete custom halftone pattern
        if (pRPDev->pHalftonePattern)
            MemFree(pRPDev->pHalftonePattern);

        // Delete the raster module PDEV
        MemFree(pRPDev);
    }

    //
    // PCLXL raster mode
    // Free XLRASTER
    //
    if (pPDev->ePersonality == kPCLXL_RASTER && pPDev->pVectorPDEV)
    {
        PCLXLFreeRaster((PDEVOBJ)pPDev);
    }
    return;
}

BOOL
RMInitDevicePal(
    PDEV        *pPDev,
    PAL_DATA    *pPal
    )
/*++

Routine Description:

    This function calculates a device palette to be download
    to the printer for planar mode devices

Arguments:

    pPDev           - pointer to PDEV structure
    pPal            - pointer to PAL_DATA structure
Return Value:

--*/
{
    int i,j;
    int RMask,GMask,BMask;
    ULONG *pPalette;
    RASTERPDEV *pRPDev;

    pRPDev = pPDev->pRasterPDEV;

    if (pPal == NULL || pRPDev == NULL || pRPDev->sDevPlanes != 3
        || pPal->wPalDev < 8 || (!(pPalette = pPal->pulDevPalCol)) )
    {
        ERR (("Unidrv!RMInitDevicePal: Invalid Parameters, pPal = %p, \
               pRPDev = %p, pRPDev->sDevPlanes = %d,pPal->wPalDev = %d,\
               pPalette = %p\n",pPal,pRPDev,pRPDev->sDevPlanes,pPal->wPalDev,\
               pPalette));

        return FALSE;
    }

    //
    // Determine which bits map to which color
    //
    for (i = 0;i < 3;i++)
    {
        switch (pRPDev->rgbOrder[i])
        {
        case DC_PLANE_CYAN:
        case DC_PLANE_RED:
            RMask = 1 << i;
            break;
        case DC_PLANE_MAGENTA:
        case DC_PLANE_GREEN:
            GMask = 1 << i;
            break;
        case DC_PLANE_YELLOW:
        case DC_PLANE_BLUE:
            BMask = 1 << i;
            break;
        }
    }
    //
    // create the palette entries
    //

    for (i = 0;i < 8;i++)
    {
        //
        // if CMY mode complement index
        //
        if (pRPDev->fColorFormat & DC_PRIMARY_RGB)
            j = i;
        else
            j = ~i;

        pPalette[i] = RGB((j & RMask) ? 255 : 0,
                              (j & GMask) ? 255 : 0,
                              (j & BMask) ? 255 : 0);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\render.c ===
/***************************** Module Header ********************************
 * render.c
 *      High level functions associated with rendering a bitmap to a
 *      printer.  Basic operation depends upon whether we are going to
 *      rotate the bitmap - either because the printer cannot,  or it
 *      is faster if we do it.
 *        With rotation,  allocate a chunk of memory and transpose the
 *      output bitmap into it.  Call the normal processing code,  but
 *      with this allocated memory and new fake bitmap info.  After
 *      processing this chunk,  transpose the next and process.  Repeat
 *      until the entire bitmap has been rendered.  Free the memory, return.
 *        Without rotation,  simply pass the bitmap onto the rendering
 *      code,  to process in one hit.
 *
 *
 *  Copyright (C) 1991 - 1999, Microsoft Corporation
 *
 ***************************************************************************/

#include        "raster.h"
#include        "compress.h"
#include        "rmrender.h"
#include        "fontif.h"
#include        "rmdebug.h"
#include        "xlraster.h"

/*
 *   Constants used to calculate the amount of memory to request if we
 *  need to transpose the engine's bitmap before sending to the printer.
 *  If at least one head pass will fit within the the TRANSPOSE_SIZE
 *  buffer,  then request this amount of storage.  If not,  calculate how
 *  much is needed and request that much.
 */

#define TRANSPOSE_SIZE          0x20000         /* 128k */


//used when we can grow the block height
#define DEF_BLOCK_SIZE          0x08000         /* 32k  */
#define MAX_BLOCK_SIZE          0x40000         /* 256k */



/*
 *   Set a limit to the number of interlaced lines that we can print.
 *  Interlacing is used to increase the resolution of dot matrix printers,
 *  by printing lines in between lines.  Typically the maximum interlace
 *  will be 2,  but we allow more just in case.  This size determines the
 *  size of an array allocated on the stack.  The array is of ints,  so
 *  there is not much storage consumed by setting this high a value.
 */
#define MAX_INTERLACE   10      /* Dot matrix style interlace factor */

/*
 *   Local function prototypes.
 */

BOOL  bRealRender( PDEV *, DWORD *, RENDER * );
BOOL  bOnePassOut( PDEV *, BYTE *, RENDER * );
BOOL  bOneColourPass( PDEV *, BYTE *, RENDER * );
INT   iLineOut( PDEV *, RENDER *, BYTE *, INT, INT );
void  vInvertBits( DWORD *, INT );
//void  vFindWhiteInvertBits ( RASTERPDEV *, RENDER *, DWORD *);
BOOL  bLookAheadOut( PDEV *, INT, RENDER *, INT );

#ifdef TIMING
#include <stdio.h>
void  DrvDbgPrint(
    char * pch,
    ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, pch);

    EngDebugPrint("",pch,ap);

    va_end(ap);
}
#endif
/************************ Function Header ***********************************
 * bRenderInit
 *      Called during DrvEnableSurface time - we initialise a RENDER_DATA
 *      structure which will be used for the duration of this surface.
 *
 * RETURNS:
 *      TRUE/FALSE,  FALSE means a minidriver problem or no memory.
 *
 * HISTORY:
 *  Monday November 29 1993     -by-    Norman Hendley   [normanh]
 *      Implement multiple scanline printing; fixed & variable block height.
 *
 *  10:58 on Tue 10 Nov 1992    -by-    Lindsay Harris   [lindsayh]
 *      Moved from start of bRender() - second incarnation.
 *
 ****************************************************************************/

BOOL
bRenderInit( pPDev, sizl, iFormat )
PDEV   *pPDev;                /* Our key to the universe */
SIZEL   sizl;                 /* Size of processing band, <= sizlPage */
INT     iFormat;              /* GDI bitmap format */
{

    INT        cbOutBand;       /* Bytes per output band: based on # pins */
    INT        cbOneBlock;      /* Bytes per minimum sized block if block variable */
    INT        iBPP;            /* Bits per pel - expect 1 or 4 */
    INT        iIndex;          /* Loop paramter */
    INT        iBytesPCol;      /* Bytes per column - only for colour */

    RASTERPDEV   *pRPDev;         /* The unidrive PDEV - printer details */

    RENDER    *pRD;             /* Miscellaneous rendering data */


#ifdef TIMING
    ENG_TIME_FIELDS TimeTab;
    pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    pRPDev->dwTiming = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
#endif
    ASSERTMSG(!(sizl.cx == 0 || sizl.cy == 0),("unidrv!bRenderInit - null shadow bitmap\n"));

    /*
     *    Allocate storage for our RENDER structure,  then set it all to
     *  zero,  so that it is in a known safe state.
     */

    pRPDev = pPDev->pRasterPDEV;
    if( !(pRD = (RENDER *) MemAllocZ(
            ( pPDev->bBanding) ? sizeof(RENDER) * 2 : sizeof( RENDER ))))
        return   FALSE;

    pRPDev->pvRenderData = pRD;

    pRPDev->pvRenderDataTmp = ( pPDev->bBanding ) ? pRD+1 : NULL;

    /*
     *  Various operations depend upon what format bitmap we have.  So
     *  now is the time to set this all up.
     */
    pRD->dwDevWhiteIndex = 0;
    switch( iFormat )
    {
    case  BMF_1BPP:
        iBPP = 1;
        pRD->bWhiteLine = bIsLineWhite;
        pRD->bWhiteBand = bIsBandWhite;
        pRD->ubFillWhite = 0;
        pRD->vLtoPTransFn = vTrans8N;
        break;

    case  BMF_4BPP:
        iBPP = 4;
        if ((pRPDev->fColorFormat & DC_OEM_BLACK) &&
           !(pRPDev->fColorFormat & DC_PRIMARY_RGB))
        {
            pRD->bWhiteLine = bIsLineWhite;
            pRD->bWhiteBand = bIsBandWhite;
            pRD->ubFillWhite = 0;
        }
        else
        {
            if (pRPDev->fColorFormat & DC_PRIMARY_RGB)
                pRD->dwDevWhiteIndex = 0x77777777;
            pRD->bWhiteLine = bIsRGBLineWhite;
            pRD->bWhiteBand = bIsRGBBandWhite;
            pRD->ubFillWhite = 0x77;
        }
        pRD->vLtoPTransFn = vTrans8N4BPP;
        break;

    case  BMF_8BPP:
        iBPP = 8;
        pRD->bWhiteLine = bIs8BPPLineWhite;
        pRD->bWhiteBand = bIs8BPPBandWhite;
        pRD->dwDevWhiteIndex = pRD->ubFillWhite = (BYTE)pRPDev->pPalData->iWhiteIndex;
        pRD->dwDevWhiteIndex |= pRD->dwDevWhiteIndex << 8;
        pRD->dwDevWhiteIndex |= pRD->dwDevWhiteIndex << 16;
        pRD->vLtoPTransFn = vTrans8BPP;
        break;

    case  BMF_24BPP:
        iBPP = 24;
        pRD->bWhiteLine = bIs24BPPLineWhite;
        pRD->bWhiteBand = bIs24BPPBandWhite;
        pRD->ubFillWhite = 0xff;
        pRD->dwDevWhiteIndex = ~(DWORD)0;
        pRD->vLtoPTransFn = vTrans24BPP;
        break;

    default:
#if DBG
        DbgPrint( "Unidrv!bRender: not 1, 4, 8 or 24 bits per pel bitmap\n" );
#endif
        SetLastError( ERROR_INVALID_PARAMETER );

        return  FALSE;
    }

    pRD->iBPP = iBPP;

    // If there is no Y movement commands we need to send every scan
    // so we don't want to find white lines
    // PCLXL GPD files don't have YMOVE commands. But it needs to find white
    // lines.
    if (pPDev->arCmdTable[CMD_YMOVERELDOWN] == NULL &&
        pPDev->arCmdTable[CMD_YMOVEABSOLUTE] == NULL &&
        pPDev->arCmdTable[CMD_SETLINESPACING] == NULL &&
        pPDev->ePersonality != kPCLXL_RASTER)
    {
        pRD->bWhiteLine = pRD->bWhiteBand = bIsNeverWhite;
        pRPDev->fBlockOut |= RES_BO_NO_YMOVE_CMD;
    }

    // initialize bTTY for TTY device
    pRD->PrinterType = pPDev->pGlobals->printertype;

    if( pRPDev->sMinBlankSkip == 0 || iBPP == 24)
    {
        /*  Presume this means skip should not be performed.  */
        pRPDev->fBlockOut &= ~RES_BO_ENCLOSED_BLNKS;
    }

    pRD->iCursor = pRPDev->fCursor;

    pRD->iFlags = 0;           /* Nothing set,  yet */
    pRD->fDump = pRPDev->fDump;
    pRD->Trans.pdwTransTab = pRPDev->pdwTrans;
    pRD->pdwBitMask = pRPDev->pdwBitMask;
    pRD->pdwColrSep = pRPDev->pdwColrSep;       /* Colour translation */

    pRD->ix = sizl.cx;
    pRD->iy = sizl.cy;

    pRD->iSendCmd = CMD_SENDBLOCKDATA;  //CMD_RES_SENDBLOCK;

    pRD->cBLine = pRD->ix * iBPP;             /* Bits in scanline */
    pRD->cDWLine = (pRD->cBLine + DWBITS - 1) / DWBITS;
    pRD->cBYLine = pRD->cDWLine * DWBYTES;

    pRD->iPassHigh = pRPDev->sNPins;

    // Derryd   : Minidriver Callback
    if (pRPDev->fRMode & PFR_BLOCK_IS_BAND )   //means callback wants entire band as one block
    {
        //don't want any stripping, because would mean creating new buffers
         pRPDev->fBlockOut &= ~(RES_BO_LEADING_BLNKS |
                                             RES_BO_TRAILING_BLNKS | RES_BO_ENCLOSED_BLNKS);
         pRD->fDump &= ~RES_DM_LEFT_BOUND;
         pRD->iPassHigh = pRD->iy ;
    }
    // end

    if (pPDev->ePersonality == kPCLXL_RASTER)
    {
        pRPDev->fBlockOut |= RES_BO_LEADING_BLNKS | RES_BO_TRAILING_BLNKS;
        pRPDev->fBlockOut &= ~RES_BO_ENCLOSED_BLNKS;
    }

    //Set the key fields which enable us print multiple scanlines

    if (pRD->fDump & RES_DM_GDI)   //GDI style graphics
    {
        // No interlacing on these devices
        pRD->iInterlace = 1;

        // iHeight is fixed & the minimum size block we can print
        pRD->iHeight= pRD->iPassHigh;

        //iNumScans can grow if device allows it.
        pRD->iNumScans= pRD->iHeight;

        //in case minidriver developer sets otherwise
        //Existing code relies on this being one for GDI style graphics
        pRD->iBitsPCol = 1;
    }
    else    //Old dot matrix column style graphics
    {
        pRD->iBitsPCol = pRPDev->sPinsPerPass;
        pRD->iInterlace = pRD->iPassHigh / pRD->iBitsPCol;

        // questionable choice, but enables easier checking later
        pRD->iNumScans= 1;

        //our one constant between graphics modes
        pRD->iHeight= pRD->iBitsPCol;
    }


    pRD->iPosnAdv = pRD->iHeight;  // can be negative


    if( pRD->iInterlace > MAX_INTERLACE )
    {
#if DBG
        DbgPrint( "unidrv!bRenderInit: Printer Interlace too big to handle\n" );
#endif
        SetLastError( ERROR_INVALID_PARAMETER );

        return   FALSE;
    }

    // We'll need to scan the bitmap in blocks rather than single lines
    //
    if (pRD->iNumScans > 1)
         pRD->bWhiteLine = pRD->bWhiteBand;

    /*
     *   Calculate the size needed for the output transpose buffer.  This
     *  is the buffer used to convert the data into the pin order needed
     *  for dot matrix printers.
     */

    if( pPDev->fMode & PF_ROTATE )
    {
        /*   We do the rotation,  so the Y dimension is the one to use. */
        cbOutBand = pRD->iy;
    }
    else
        cbOutBand = pRD->ix;           /* Format as it comes in */


    //used for dangling scanline scenario
    cbOneBlock = ((cbOutBand * iBPP + DWBITS - 1) / DWBITS) *
                   DWBYTES * pRD->iHeight;



    // In this case we don't know how large our final blocks will be.
    // Set a reasonable limit of 32k & use that for compression & white
    // space stripping buffers.
    // Calculate what the corresponding max number of scanlines should be.

    if (pRPDev->fBlockOut & RES_BO_MULTIPLE_ROWS)
    {
        INT tmp = ((cbOutBand * iBPP + DWBITS - 1) / DWBITS) * DWBYTES;
        cbOutBand = pPDev->pGlobals->dwMaxMultipleRowBytes;
        if (cbOutBand < tmp)
            cbOutBand = DEF_BLOCK_SIZE;
        else if (cbOutBand > MAX_BLOCK_SIZE)
            cbOutBand = MAX_BLOCK_SIZE;
        pRD->iMaxNumScans = cbOutBand / tmp;
    }
    else
    {
        pRD->iMaxNumScans = pRD->iHeight;
        cbOutBand = cbOneBlock;
    }

    //
    // If each data byte needs to be mirrored before output
    // we will generate the table here
    //
    if (pRPDev->fBlockOut & RES_BO_MIRROR)
    {
        INT i;
        if ((pRD->pbMirrorBuf = MemAlloc(256)) == NULL)
            return FALSE;
        for (i = 0;i < 256;i++)
        {
            BYTE bOut = 0;
            if (i & 0x01) bOut |= 0x80;
            if (i & 0x02) bOut |= 0x40;
            if (i & 0x04) bOut |= 0x20;
            if (i & 0x08) bOut |= 0x10;
            if (i & 0x10) bOut |= 0x08;
            if (i & 0x20) bOut |= 0x04;
            if (i & 0x40) bOut |= 0x02;
            if (i & 0x80) bOut |= 0x01;
            pRD->pbMirrorBuf[i] = bOut;
        }
    }

    //
    // time to do more color depth specific calculations
    //

    switch( iBPP )
    {
    case  4:              /* 4 bits per pel - printer is planar */

        /*  Colour, so select the colour rendering function */
        pRD->bPassProc = bOneColourPass;
        pRD->Trans.pdwTransTab = pRPDev->pdwColrSep;

        //
        // map the color order to the required data offset for planar data
        // rgbOrder valid values are emum {none,r,g,b,c,m,y,k}
        //
        iBytesPCol = (pRD->iBitsPCol + BBITS - 1) / BBITS;
        {
            INT offset  = (pRPDev->fColorFormat & DC_PRIMARY_RGB) ? 1 : 4 ;

            for( iIndex = 0; iIndex < COLOUR_MAX; ++iIndex )
            {
                INT tmp = pRPDev->rgbOrder[iIndex] - offset;

                pRD->iColOff[ iIndex ] = iBytesPCol * (COLOUR_MAX - 1 - tmp);
            }
        }
        pRD->pbColSplit = MemAlloc( cbOutBand / 4 );
        if( pRD->pbColSplit == 0 )
            return  FALSE;

        //
        // If we need to send every color plane we must disable LEADING and ENCLOSED
        // white space removal for 4bpp. However, as long as we're not sending RGB data
        // we can still enable TRAILING white space removal.
        //
        if (pRPDev->fColorFormat & DC_SEND_ALL_PLANES)
        {
            pRD->iFlags |= RD_ALL_COLOUR;
            pRD->fDump &= ~RES_DM_LEFT_BOUND;

            if (pRPDev->fColorFormat & DC_PRIMARY_RGB)
                pRPDev->fBlockOut &= ~(RES_BO_LEADING_BLNKS | RES_BO_ENCLOSED_BLNKS | RES_BO_TRAILING_BLNKS);
            else
                pRPDev->fBlockOut &= ~(RES_BO_LEADING_BLNKS | RES_BO_ENCLOSED_BLNKS);
        }

        break;

    case  1:                  /* 1 bit per pel - monochrome */
    case  8:                  /* Seiko special - 8 bits per pel */

        pRD->bPassProc = bOnePassOut;
        pRD->Trans.pdwTransTab = pRPDev->pdwTrans;
        pRD->pbColSplit = 0;           /* No storage allocated either! */

        break;

    case 24:

        pRD->bPassProc = bOnePassOut;
        pRD->Trans.pdwTransTab = NULL;
        pRD->pbColSplit = 0;           /* No storage allocated either! */

        break;
    }

    /*
     *     There are potentially 2 transpose operations.  For printers
     *  which print more than one line per pass,  AND which require the
     *  data in column order across the page (this defines dot matrix
     *  printers),  we need to transpose per output head pass.  This is
     *  not required for devices like laser printers,  which require
     *  the data one scan line at a time.
     *     Note also that this operation is unrelated to the larger
     *  question of rotating the PAGE image before rendering - for sending
     *  a landscape image to a printer that can only print portrait mode.
     */


    if (pRD->fDump & RES_DM_GDI)   // GDI style graphics
    {

        if( iBPP == 4 )
        {
            /*  Paintjet style printer - need to colour separate  */
            pRD->vTransFn = vTransColSep;
        }
        else
        {
            /*   LaserJet style printer - one pin per head pass */
            pRD->vTransFn = 0;         /* Nothing to call */
        }
        //This allows us use iIsBandWhite with multi scanline printing
        pRD->iTransHigh = pRD->iHeight;
    }
    else
    {
        /*
         *   General dot matrix case.   Apart from selecting an active
         * transpose function,  we must allocate a transpose buffer;
         * this is required for fiddling with the bit order in the lines
         * of data to be sent to the printer.
         */

        pRD->iTransWide = pRD->ix * iBPP;
        pRD->iTransHigh = pRD->iBitsPCol;
        pRD->iTransSkip = (pRD->iTransHigh + BBITS - 1) / BBITS;

        /*  How to change the address pointer during transpose operations */
        pRD->cbTLine = pRD->cDWLine * DWBYTES * pRD->iInterlace;

        if( pRD->iBitsPCol == BBITS )
        {
            /*
             *   When the printer has 8 pins,  we have a special transpose
             *  function which is faster than the more general case.
             *  So,  use that one!
             */
            pRD->vTransFn = vTrans8x8;
        }
        else if (pRD->PrinterType != PT_TTY)
            pRD->vTransFn = vTrans8N;          /* The general case */
        else
            pRD->vTransFn = NULL;          /* Txtonly no need to transpose */
    }

    if( pRD->vTransFn )
    {
        /*
         *    Determine the amount of memory needed for the transpose buffer.
         * The scan lines are DWORD aligned,  but there may be any number of
         * scan lines involved.  The presumption is that the output of
         * the transpose function will be packed on byte boundaries,  so
         * storage size only needs to be rounded up to the nearest byte size.
         */

        if( !(pRD->pvTransBuf = MemAlloc( cbOutBand )) )
            return  FALSE;
    }
    else
        pRD->pvTransBuf = 0;           /* No store, nothing to free */


    pRD->iyBase = 0;           /* When multiple passes are required */
    pRD->ixOrg = 0;            /* Graphics origin - laserjet style */

    //We need a buffer so we can strip leading and/or trailing white space
    //on multiple scan line devices.
    //We also need to set up a buffer to mask non-interesting data at end
    //of page if ScanLines_Left < iNumScans
    //This is not a concern for old dot matrix style graphics as the
    //transpose code takes care of it.
    if ( ((pRD->iNumScans > 1) || (pRPDev->fBlockOut & RES_BO_MULTIPLE_ROWS))
                                && (!(pRPDev->fRMode & PFR_BLOCK_IS_BAND ) ))
    {
        if ( !(pRD->pStripBlanks = MemAlloc(cbOutBand)))
            return FALSE;
        if (pRD->iNumScans > 1)
            if ( !(pRD->pdwTrailingScans = MemAlloc( cbOneBlock)) )
                 return  FALSE;
    }

    //
    // We need to determine which compression modes are enabled
    //
    if (pRPDev->fRMode & PFR_COMP_TIFF)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLETIFF4;
    }
    if (pRPDev->fRMode & PFR_COMP_FERLE)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLEFERLE;
    }
    if (pRPDev->fRMode & PFR_COMP_DRC)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLEDRC;
    }
    if (pRPDev->fRMode & PFR_COMP_OEM)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLEOEMCOMP;
    }
    //
    // if compression is available we need to allocate a buffer for
    // each active compression type
    //
    if (pRD->dwNumCompCmds)
    {
        INT i = pRD->dwNumCompCmds;
        //
        // calculate the size for the buffers
        //
        pRD->dwCompSize = cbOutBand + (cbOutBand >> 5) + COMP_FUDGE_FACTOR;

        //
        // if there is FERLE or OEM compression we can enable
        // no compression as a valid compression type
        //
        if (pRPDev->fRMode & (PFR_COMP_FERLE | PFR_COMP_OEM))
        {
            if (COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION))
            {
                pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_DISABLECOMPRESSION;
            }
            //
            // need to allocate a larger buffer for RLE or OEM compression if
            // no compression is not an option since it must have enough space
            //
            else
                pRD->dwCompSize = cbOutBand + (cbOutBand >> 1) + COMP_FUDGE_FACTOR;
        }

        //
        // loop once per compression type to allocate buffers
        //
        while (--i >= 0)
        {
            // allocate compression buffer
            //
            pRD->pCompBufs[i] = MemAlloc (pRD->dwCompSize);
            if (!pRD->pCompBufs[i])
                return FALSE;
            //
            // if delta row, allocate buffer for previous row
            // and initialize it to zero assuming blank row
            //
            if (pRD->pdwCompCmds[i] == CMD_ENABLEDRC)
            {
                pRD->pDeltaRowBuffer = MemAlloc(cbOutBand);
                if (!pRD->pDeltaRowBuffer)
                    return FALSE;
            }
        }
    }
    pRD->dwLastCompCmd = CMD_DISABLECOMPRESSION;
    /*
     *    Adjustments to whether we rotate the bitmap, and if so, which way.
     */

    if( pPDev->fMode & PF_ROTATE )
    {
        /*   Rotation is our responsibility  */

        if( pPDev->fMode & PF_CCW_ROTATE90 )
        {
            /*   Counter clockwise rotation - LaserJet style */
            pRD->iyPrtLine = pPDev->sf.szImageAreaG.cx - 1;
            pRD->iPosnAdv = -pRD->iPosnAdv;
            pRD->iXMoveFn = YMoveTo;
            pRD->iYMoveFn = XMoveTo;
        }
        else
        {
            /*   Clockwise rotation - dot matrix style */
            pRD->iyPrtLine = 0;
            pRD->iXMoveFn = XMoveTo;
            pRD->iYMoveFn = YMoveTo;
        }
    }
    else
    {
        /*  No rotation: either portrait, or printer does it */
        pRD->iyPrtLine = 0;
        pRD->iXMoveFn = XMoveTo;
        pRD->iYMoveFn = YMoveTo;
    }
    pRD->iyLookAhead = pRD->iyPrtLine;       /* For DeskJet lookahead */

    /*
     *    When we hit the lower level functions, we want to know how many
     *  bytes are in the buffer of stuff to be sent to the printer.  This
     *  depends upon the number of bits per pel,  number of pels and the
     *  the number of scan lines processed at the same time.
     *     The only oddity is that when we have a 4 BPP device, the
     *  planes are split before we get to the lowest level, and so we
     *  we need to reduce the size by 4 to obtain the real length.
     */


    // Note when printing a block of scanlines iMaxBytesSend will be the max byte
    // count for each scanline, not of the block , which is dword aligned.

    pRD->iMaxBytesSend = (pRD->cBLine * pRD->iBitsPCol + BBITS - 1) / BBITS;

    if( iBPP == 4 )
        pRD->iMaxBytesSend = (pRD->iMaxBytesSend + 3) / 4;



    return   TRUE;             /* Must be OK if we made it this far */

}


/************************ Function Header *********************************
 * bRenderStartPage
 *      Called at the start of a new page.  This is mostly to assist in
 *      banding,   where much of the per page initialisation would be
 *      done more than once.
 *
 * RETURNS:
 *      TRUE/FALSE,   FALSE largely being failure to allocate memory.
 *
 * HISTORY:
 *  09:42 on Fri 19 Feb 1993    -by-    Lindsay Harris   [lindsayh]
 *      First incarnation, to solve some banding problems.
 *
 ***************************************************************************/

BOOL
bRenderStartPage( pPDev )
PDEV   *pPDev;                  /* Access to everything */
{
#ifndef DISABLE_RULES
    RASTERPDEV   *pRPDev;


    pRPDev = pPDev->pRasterPDEV;


    /*
     *    If the printer can handle rules,  now is the time to initialise
     *  the rule finding code.
     */

    if( pRPDev->fRMode & PFR_RECT_FILL )
        vRuleInit( pPDev, pRPDev->pvRenderData );
#endif
    return  TRUE;
}



/************************ Function Header *********************************
 * bRenderPageEnd
 *      Called at the end of rendering a page.  Basically frees up the
 *      per page memory,  cleans up any dangling bits and pieces, and
 *      otherwise undoes vRenderPageStart.
 *
 * RETURNS:
 *      TRUE/FALSE,   FALSE being a failure of memory freeing operations.
 *
 * HISTORY:
 *  15:16 on Fri 09 Apr 1993    -by-    Lindsay Harris   [lindsayh]
 *      White text support.
 *
 *  09:44 on Fri 19 Feb 1993    -by-    Lindsay Harris   [lindsayh]
 *      First incarnation.
 *
 **************************************************************************/

BOOL
bRenderPageEnd( pPDev )
PDEV   *pPDev;
{
#ifndef DISABLE_RULES
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;

    /*    Finish up with the rules code - includes freeing memory  */
    if( pRPDev->fRMode & PFR_RECT_FILL )
        vRuleEndPage( pPDev );
#endif
    return  TRUE;
}


/************************ Function Header ***********************************
 * vRenderFree
 *      Free up any and all memory used by rendering.  Basically this is
 *      the complementary function to bRenderInit().
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  12:46 on Tue 10 Nov 1992    -by-    Lindsay Harris   [lindsayh]
 *      Removed from bRender() when initialisation code was moved out.
 *
 *****************************************************************************/

void
vRenderFree( pPDev )
PDEV   *pPDev;            /* All that we need */
{

    /*
     *   First verify that we have a RENDER structure to free!
     */

    RENDER   *pRD;        /*  For our convenience */
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;

    if( pRD = pRPDev->pvRenderData )
    {
        if( pRD->pvTransBuf )
        {
            /*
             *    Dot matrix printers require a transpose for each print head
             *  pass,  so we now free the memory used for that.
             */

            MemFree ( pRD->pvTransBuf );
        }

        if( pRD->pbColSplit )
            MemFree ( pRD->pbColSplit );
        if( pRD->pStripBlanks )
            MemFree ( pRD->pStripBlanks );

        if( pRD->pdwTrailingScans)
            MemFree ( pRD->pdwTrailingScans );

        if (pRD->pbMirrorBuf)
            MemFree (pRD->pbMirrorBuf);

        if( pRD->plrWhite)
        {
//            WARNING(("Freeing plrWhite in vRenderFree\n"));
            MemFree ( pRD->plrWhite );
        }
        // free compression buffers
        //
        if (pRD->dwNumCompCmds)
        {
            DWORD i;
            for (i = 0;i < pRD->dwNumCompCmds;i++)
            {
                if (pRD->pCompBufs[i])
                    MemFree (pRD->pCompBufs[i]);
            }
            if (pRD->pDeltaRowBuffer)
                MemFree(pRD->pDeltaRowBuffer);
        }
        MemFree ( (LPSTR)pRD );
        pRPDev->pvRenderData = NULL;       /* Won't do it again! */
    }

#ifndef DISABLE_RULES
    if( pRPDev->fRMode & PFR_RECT_FILL )
        vRuleFree( pPDev );             /*  Could do this in DisableSurface */
#endif


    return;

}

/************************ Function Header ***********************************
 * bRender
 *      Function to take a bitmap and render it to the printer.  This is the
 *      high level function that basically hides the requirement of
 *      bitmap transposing from the real rendering code.
 *
 * Auguments
 *  SURFOBJ *pso;           Surface object
 *  PDEV    *pPDev;         Our PDEV:  key to everything
 *  RENDER  *pRD;           The RENDER structure of our dreams
 *  SIZEL    sizl;          Bitmap size
 *  DWORD   *pBits;         Actual data to process
 *
 *  This code still has a lot of room for optimization.  The current
 *  implementation makes multiple passes over the entire bitmap.  This
 *  guarantees that there will rarely be an internal (8K or 16K) or
 *  external (64K to 256K) cache hit slowing things down significantly.
 *  Any possiblity to make all passes a count of scans totaling
 *  8K (minus code) or less will have significant performance advantages.
 *  Also attempting to avoid writes will have significant advantages.
 *
 *  As a first pass at attempting this, the HP laserjet code has been
 *  optimized to merge the invertion pass in with the rule processing
 *  pass along with the detection of blank scans.  It also eliminates
 *  the inversion of inverting (writing) the left and right edges of
 *  scans that are white.  It processes the scans in 34 scan bands which
 *  will have great cache effects if the area between the left and
 *  right edges of non white data total less than 4K to 6K and reasonable
 *  cache effects in all cases since it at least stay in the external
 *  cache.  In the future, this code should also be modified to ouput
 *  the scans as soon as it is done processing the rules for each band.
 *  Currently it processes all scans on the page for rules and then
 *  calls the routine to output the scans.  This would trully make it
 *  a one pass alogrithm.
 *
 *  As of 12/30/93, only the HP laserjets have been optimized in this way.
 *  All raster printers could probably be optimized particularly when
 *  any transposing is necessary, detecting the left and right edges
 *  of scans that are white.  Transposing is expensive.  It is probably
 *  less important for dot matrix printers that take so long to output
 *  but it is still burning up CPU time that might be better served
 *  giving a USER bet responsiveness from apps while printing in the
 *  back ground.
 *
 *  The optimizations to the HP LaserJet had the following results.  All
 *  numbers are in terms of number of instructions and were pretty closely
 *  matched with total times to render an entire 8.5 X 11 300dpi page.
 *
 *                    OLD       OPTIMIZED
 *  Blank page      8,500,000     950,000
 *  full text page 15,500,000   8,000,000
 *
 *
 * RETURNS:
 *      TRUE for successful completion,  else FALSE.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *
 *  14:23 on Tue 10 Nov 1992    -by-    Lindsay Harris   [lindsayh]
 *      Split up for journalling - initialisation moved up above.
 *
 *  16:11 on Fri 11 Jan 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  before DDI spec'd on how we are called.
 *
 ****************************************************************************/

BOOL
bRender(
    SURFOBJ *pso,
    PDEV    *pPDev,
    RENDER  * pRD,
    SIZEL   sizl,
    DWORD   *pBits )
{

    BOOL       bRet;            /* Return value */
    INT        iBPP;            /* Bits per pel - expect 1 or 4 */

    RASTERPDEV   *pRPDev;         /* The unidrive PDEV - printer details */

#ifdef TIMING
    ENG_TIME_FIELDS TimeTab;
    DWORD sTime,eTime;

    pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    sTime = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    {
        char buf[80];
        sprintf (buf,"Unidrv!bRender: GDI=%d, %dx%dx%d\n",
            sTime-pRPDev->dwTiming,sizl.cx,sizl.cy,pRD->iBPP);
        DrvDbgPrint(buf);
    }
#else
    pRPDev = pPDev->pRasterPDEV;
#endif

    // if all scan lines need to be output then we need to
    // make sure we don't send the extra scan lines at the
    // end of the last band
    //
    if (pRPDev->fBlockOut & RES_BO_NO_YMOVE_CMD)
    {
        if (!(pPDev->fMode & PF_ROTATE))
        {
            if ((pRD->iyPrtLine + sizl.cy) > pPDev->rcClipRgn.bottom)
                sizl.cy = pPDev->rcClipRgn.bottom - pRD->iyPrtLine;
        }
    }
    //
    // if this band is blank we will update our position
    // and then just return
    //
    else if (!(pPDev->fMode & PF_SURFACE_USED) &&
          (pRD->PrinterType == PT_PAGE || !pPDev->iFonts))
    {
        if (pPDev->fMode & PF_ROTATE)
        {
            if (pPDev->fMode & PF_CCW_ROTATE90)
                pRD->iyPrtLine -= sizl.cx;
            else
                pRD->iyPrtLine += sizl.cx;
        }
        else
            pRD->iyPrtLine += sizl.cy;

#ifdef TIMING
        DrvDbgPrint ("Unidrv!bRender: Skipping blank band\n");
#endif
        return TRUE;
    }


    iBPP = pRD->iBPP;            /* Speedier access as local variable */

    // this code filters the raster data so that any set pixel
    // will have at least one adjacent horizontal pixel set and
    // at least one adjacent vertical pixel set
    //
    if (iBPP == 1 && (pPDev->fMode & PF_SINGLEDOT_FILTER))
    {
        INT cy,i;
        cy = sizl.cy;
        while (--cy >= 0)
        {
            DWORD *pdwC,*pdwB,*pdwA;

            // Calculate pointers
            //
            pdwC = &pBits[pRD->cDWLine*cy];
            //
            // We will do horizontal filter first
            //
            if (pPDev->pbRasterScanBuf[cy / LINESPERBLOCK])
            {
                BYTE bA,bL,*pC;
                // skip leading white space
                for (i = 0;i < pRD->cDWLine;i++)
                    if (pdwC[i] != ~0) break;

                pC = (BYTE *)pdwC;
                bL = (BYTE)~0;
                i *= DWBYTES;
                while (i < pRD->cBYLine)
                {
                    bA = pC[i];
                    pC[i] &= (((bA >> 1) | (bL << 7)) | ~((bA >> 2) | (bL << 6)));
                    bL = bA;
                    i++;
                }
            }
            // Test if adjacent scan line is blank
            //
            if (cy && pPDev->pbRasterScanBuf[(cy-1) / LINESPERBLOCK])
            {
                // test if scan line is blank
                pdwB = &pdwC[-pRD->cDWLine];
                pdwA = &pdwB[-pRD->cDWLine];
                if (pPDev->pbRasterScanBuf[cy / LINESPERBLOCK] == 0)
                {
                    RECTL rcTmp;
                    // test if anything needs to be set here
                    //
                    i = pRD->cDWLine;
                    while (--i >= 0)
                        if ((~pdwA[i] | pdwB[i]) != ~0) break;
                    //
                    // if line is blank we can skip it
                    if (i < 0) continue;

                    // we need to clear this block
                    //
                    rcTmp.top = cy;
                    rcTmp.bottom = cy;
                    rcTmp.left = rcTmp.right = 0;
                    CheckBitmapSurface(pso,&rcTmp);
                }
                // this is the normal case
                //
                if (cy > 1 && pPDev->pbRasterScanBuf[(cy-2) / LINESPERBLOCK])
                {
                    for (i = 0;i < pRD->cDWLine;i++)
                    {
                        pdwC[i] &= ~pdwA[i] | pdwB[i];
                    }
                }
                // in this case line A is blank
                //
                else
                {
                    for (i = 0;i < pRD->cDWLine;i++)
                    {
                        pdwC[i] &= pdwB[i];
                    }
                }
            }
        }
    }
    // test whether we need to erase the rest of the bitmap
    //
    if (pPDev->bTTY)    // bug fix 194505
    {
        pPDev->fMode &= ~PF_SURFACE_USED;
    }
    else if ((pRPDev->fBlockOut & RES_BO_NO_YMOVE_CMD) ||
        (pPDev->fMode & PF_SURFACE_USED &&
        ((pPDev->fMode & PF_ROTATE) ||
          pRPDev->sPinsPerPass != 1 ||
          pRPDev->sNPins != 1)))
    {
        CheckBitmapSurface(pso,NULL);
    }
#ifdef TIMING
    if (!(pPDev->fMode & PF_SURFACE_ERASED) && pPDev->pbRasterScanBuf)
    {
        INT i,j,k;
        char buf[80];
        k = (pPDev->szBand.cy + LINESPERBLOCK - 1) / LINESPERBLOCK;
        for (i = 0, j = 0;i < k;i++)
            if (pPDev->pbRasterScanBuf[i] == 0) j++;
        sprintf (buf,"Unidrv!bRender: Skipped %d of %d blocks\n",j,k);
        DrvDbgPrint(buf);
    }
#endif



    /*
     *  Initialize the fields for optimizing the rendering of the bitmap.
     *  The main purpose is to have a single pass over the bits.  This
     *  can significantly speed up rendering due to cache effects.  In
     *  the old days, we took at least 3 passes over the entire bitmap for
     *  laserjets.  One to invert the bits, one+ to find rules, and then
     *  a third to output the data.  We now delay the invertion of the
     *  bits until after rules are found.  We also keep left/right information
     *  of non white space for each row.  This way, any white on the edges
     *  or completely white rows are only touch once and from then on, only
     *  DWORDS with black need be touched.  Also, the invertion is expensive
     *  since it causes writing every DWORD.
     */

    pRD->plrWhite   = NULL;
    pRD->plrCurrent = NULL;
    pRD->clr        = 0;

    //
    // Set flag to clear delta row buffer
    //
    pRD->iFlags |= RD_RESET_DRC;

    /*
     *   Various operations depend upon what format bitmap we have.  So
     * now is the time to set this all up.
     */

    //
    // If 1 bit per pixel mode we need to explicitly invert the
    // data, but we may do it later in rules.
    // The only other data this is allowed to be inverted is
    // 4BPP and it is done in the transform functions
    //
    if (pRD->iBPP == 1 && (pPDev->fMode & PF_SURFACE_USED))
        pRD->bInverted = FALSE;
    else
        pRD->bInverted = TRUE;

    /*
     *   Check if rotation is required.  If so,  allocate storage,
     *  start transposing, etc.
     */

    if( pPDev->fMode & PF_ROTATE )
    {
        /*
         *   Rotation is the order of the day.  First chew up some memory
         * for the transpose function.
         */

        INT   iTHigh;                   /* Height after transpose */
        INT   cTDWLine;                 /* DWORDS per line after transpose */
        INT   iAddrInc;                 /* Address increment AFTER transpose */
        INT   iDelta;                   /* Transpose book keeping */
        INT   cbTransBuf;               /* Bytes needed for L -> P transpose */
        INT   ixTemp;                   /* Maintain pRD->ix around this op */

        TRANSPOSE  tpBig;               /* For the landscape transpose */
        TRANSPOSE  tpSmall;             /* For the per print head pass */
        TRANSPOSE  tp;                  /* Banding: restore after we clobber */

        /*
         *    First step is to determine how large to make the area
         *  wherein the data will be transposed for later rendering.
         *  Take the number of scan lines,   and round this up to a
         *  multiple of DWORDS.  Then find out how many of these will
         *  fit into a reasonable size chunk of memory.  The number
         *  should be a multiple of the number of pins per pass -
         *  this to make sure we don't have partial head passes,  if
         *  that is possible.
         */

        /*
         *  OPTIMIZATION POTENTIAL - deterimine left/right edges of non
         *  white area and only transpose that portion (at least for
         *  laser printers).  There are often areas of white at the
         *  top and or bottom.  In the case of the HP laser printers,
         *  only the older printers (I believe series II) go through
         *  this code.  LaserJet III and beyond can do graphics in
         *  landscape so don't need this. (erick 12/20/93)
         */

        tp = pRD->Trans;              /* Keep a safe copy for later use */
        ixTemp = pRD->ix;

        cTDWLine = (sizl.cy * iBPP + DWBITS - 1) / DWBITS;

        cbTransBuf = DWBYTES * cTDWLine * pRD->iPassHigh;
        if( cbTransBuf < TRANSPOSE_SIZE )
            cbTransBuf = TRANSPOSE_SIZE;

        iTHigh = cbTransBuf / (cTDWLine * DWBYTES);


        if( iTHigh > sizl.cx )
        {
            /*   Bigger than we need,  so shrink to actual size */
            iTHigh = sizl.cx;          /* Scan lines we have to process */

            /*   Make multiple of pins per pass - round up */
            if( pRD->iPassHigh == 1 )
            {
                /*
                 *   LaserJet/PaintJet style,  so round to byte alignment.
                 */
                if (iBPP < BBITS)
                    iTHigh = (iTHigh + BBITS / iBPP - 1) & ~(BBITS / iBPP - 1);
            }
            else
                iTHigh += (pRD->iPassHigh - (iTHigh % pRD->iPassHigh)) %
                        pRD->iPassHigh;
        }
        else
        {
            /*   Make multiple of pins per pass - round down */
            if( pRD->iPassHigh == 1 )
            {
                if (iBPP < BBITS)
                    iTHigh &= ~(BBITS / iBPP - 1);         /* Byte alignment for LJs */
            }
            else
                iTHigh -= iTHigh % pRD->iPassHigh;
        }

        cbTransBuf = iTHigh * cTDWLine * DWBYTES;

        pRD->iy = iTHigh;

        /*   Set up data for the transpose function */
        tpBig.iHigh = sizl.cy;
        tpBig.iSkip = cTDWLine * DWBYTES;       /* Bytes per transpose output */
        tpBig.iWide = iTHigh * iBPP;            /* Scanlines we will process */
        tpBig.cBL = pRD->ix * iBPP;

        pRD->ix = sizl.cy;

        tpBig.cDWL = (tpBig.cBL + DWBITS - 1) / DWBITS;
        tpBig.iIntlace = 1;     /* Landscape -> portrait: no interlace */
        tpBig.cBYL = tpBig.cDWL * DWBYTES;
        tpBig.icbL = tpBig.cDWL * DWBYTES;
        tpBig.pdwTransTab = pRPDev->pdwTrans;    /* For L -> P rotation */


        if( !(tpBig.pvBuf = MemAlloc( cbTransBuf )) )
        {
            bRet = FALSE;
        }
        else
        {
            /*  Have the memory,  start pounding away  */
            INT   iAdj;                 /* Alignment adjustment, first band */


            bRet = TRUE;                /* Until proven guilty */

            /*
             *   Recompute some of the transpose data for the smaller
             *  bitmap produced from our call to transpose.
             */
            pRD->iTransWide = sizl.cy * iBPP;          /* Smaller size */
            pRD->cBLine = pRD->ix * iBPP;
            pRD->iMaxBytesSend = (pRD->cBLine * pRD->iBitsPCol + BBITS - 1) /
                        BBITS;
            if( iBPP == 4 )
                pRD->iMaxBytesSend = (pRD->iMaxBytesSend+3) / 4;

            pRD->cDWLine = (pRD->cBLine + DWBITS - 1) / DWBITS;
            pRD->cBYLine = pRD->cDWLine * DWBYTES;
            pRD->cbTLine = pRD->cDWLine * DWBYTES * pRD->iInterlace;
            tpSmall = pRD->Trans;      /* Keep it for later reuse */


            /*
             *   Set up the move commands required when rendering.  In this
             *  instance,  the X and Y operations are interchanged.
             */

            iAddrInc = (pRD->iy * iBPP) / BBITS;       /* Bytes per scanline */

            if( pPDev->fMode & PF_CCW_ROTATE90 )
            {
                /*
                 *   This is typified by the LaserJet Series II case.
                 *  The output bitmap should be rendered from the end
                 *  to the beginning,  the scan line number decreases from
                 *  one line to the next (moving down the output page),
                 *  and the X and Y move functions are interchanged.
                 */

                tpSmall.icbL = -tpSmall.icbL;           /* Scan direction */

                /*
                 *    Need to process bitmap in reverse order.  This means
                 *  shifting the address to the right hand end of the
                 *  first scan line,  then coming back one transpose pass
                 *  width.  Also set the address increment to be negative,
                 *  so that we work our way towards the beginning.
                 */

                /*
                 *    To simplify the transpose loop following,  we start
                 *  rendering the bitmap from the RHS.  The following
                 *  statement does just that:  the sizl.cx / BBITS is
                 *  the number of used bytes in the scan line, iAddrInc
                 *  is the number per transpose pass,  so subtracting it
                 *  will put us at the beginning of the last full band
                 *  on this transpose.
                 */

/* !!!LindsayH - should sizl.cx be sizl.cx * iBPP ????? */
                iAdj = (BBITS - (sizl.cx & (BBITS - 1))) % BBITS;
                sizl.cx += iAdj;                /* Byte multiple */

                (BYTE *)pBits += (sizl.cx * iBPP) / BBITS - iAddrInc;

                iAddrInc = -iAddrInc;
            }
            else
            {
                /*
                 *    Typified by HP PaintJet printers - those that have no
                 *  landscape mode,  and where the output is rendered from
                 *  the start of the bitmap towards the end,  where the
                 *  scan line number INCREASES by one from one line to the
                 *  the next (moving down the output page),  and the X and Y
                 *  move functions are as expected.
                 */
                pBits += tpBig.cDWL * (sizl.cy - 1);    /* Start of last row */
                tpBig.icbL = -tpBig.icbL;       /* Backwards through memory */

                iAdj = 0;
            }


            while( bRet && (iDelta = (int)sizl.cx) > 0 )
            {
                pRD->Trans = tpBig;    /* For the chunk transpose */

                if( (iDelta * iBPP) < pRD->iTransWide )
                {
                    /*  Last band - reduce the number of rows */
                    pRD->iTransWide = iDelta * iBPP;   /* The remainder */
                    pRD->iy = iDelta;                  /* For bRealRender */
                    if( iAddrInc < 0 )
                    {
                        iDelta = -iDelta;               /* The OTHER dirn */
                        (BYTE *)pBits += -iAddrInc + (iDelta * iBPP) / BBITS;
                    }
                }

                /*  Transpose this chunk of data unless it is empty */
                if (pPDev->fMode & PF_SURFACE_USED)
                    pRD->vLtoPTransFn( (BYTE *)pBits, pRD );

                pRD->Trans = tpSmall;


                pRD->iy -= iAdj;
                bRet = bRealRender( pPDev, tpBig.pvBuf, pRD );
                pRD->iy += iAdj;
                iAdj = 0;

                /*  Skip to the next chunk of input data */
                (BYTE *)pBits += iAddrInc;      /* May go backwards */
                pRD->iyBase += pRD->iy;
                sizl.cx -= pRD->iy;
            }

            MemFree ( tpBig.pvBuf );
        }


        pRD->Trans = tp;
        pRD->ix = ixTemp;
    }
    else
    {
        /*
         *   Simple case - no rotation,  so process the bitmap as is.
         *  This means starting at the FIRST scan line which we have
         *  set to the top of the image.
         *     Set up the move commands required when rendering.  In this
         *  instance,  the X and Y operations are their normal way.
         */

        INT   iyTemp;

        iyTemp = pRD->iy;
        pRD->iy = sizl.cy;

        bRet = bRealRender( pPDev, pBits, pRD );

        pRD->iy = iyTemp;
    }

    /*
     *  Turn unidirection off
     */
    if (pRD->iFlags & RD_UNIDIR)
    {
        pRD->iFlags &= ~RD_UNIDIR;
        WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_UNIDIRECTIONOFF));
    }

    /*
     *   Return from graphics mode,  to be civilised.
     */
    if( pRD->iFlags & RD_GRAPHICS)
    {
        if (pRD->dwLastCompCmd != CMD_DISABLECOMPRESSION)
        {
            pRD->dwLastCompCmd = CMD_DISABLECOMPRESSION;
            WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION));
        }
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_ENDRASTER));
        pRD->iFlags &= ~RD_GRAPHICS;

    }

#ifdef TIMING
    EngQueryLocalTime(&TimeTab);
    eTime = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    eTime -= sTime;
    {
        char buf[80];
        sprintf (buf,"Unidrv!bRender: %ld\n",eTime);
        DrvDbgPrint(buf);
    }
#endif
    return  bRet;
}

/************************ Function Header ***********************************
 * bRealRender
 *      The REAL rendering function.  By the time we reach here,  the bitmap
 *      is in the correct orientation,  and so we need to be serious
 *      about rendering it.
 *
 * RETURNS:
 *      TRUE for successful rendering,  else FALSE.
 *
 * HISTORY:
 *  Friday 26 November          -by-    Norman Hendley    [normanh]
 *      Added multiple scanline per send block support
 *
 *  16:22 on Fri 11 Jan 1991    -by-    Lindsay Harris   [lindsayh]
 *      Started on it.
 *
 ****************************************************************************/

BOOL
bRealRender( pPDev, pBits, pRData )
PDEV           *pPDev;          /* Our PDEV:  key to everything */
DWORD          *pBits;          /* Actual data to process */
RENDER         *pRData;         /* Details of rendering process */
{

    /*
     *    Process the bitmap in groups of scan lines.  The number in the
     *  the group is determined by the printer.  Laser printers are
     *  processed one scan line at a time,  while dot matrix are processed
     *  according to the number of pins they can fire at once.  This
     *  information is generated by our caller from the printer
     *  characterisation data,  or otherwise!
     */

    INT   iLine;                /* Current scan line */
    INT   cDWPass;              /* DWORDS per head pass */
    INT   iDWLine;              /* DWORDS processed per interlace scan */
    INT   iILAdv;               /* Line advance per interlace operation */
    INT   iHeadLine;            /* Decide when graphics pass required */
    INT   iTHKeep;              /* Local copy of iTransHigh: we change it */
    INT   iHeight;
    INT   iNumScans;            /* local copy*/
    BOOL  bCheckBlocks;

    RASTERPDEV * pRPDev;
    PAL_DATA *pPD;
    INT iWhiteIndex;

    INT   iILDone[ MAX_INTERLACE ];     /* For head pass reduction */

    PLEFTRIGHT plr = NULL;      /* left/right of non white area */

    pRPDev = pPDev->pRasterPDEV;
    pPD     = pRPDev->pPalData;
    iWhiteIndex = pPD->iWhiteIndex;

    iHeight = pRData->iHeight;
    cDWPass = pRData->cDWLine * iHeight;

    if( pRData->iPosnAdv < 0 )
    {
        /*   Data needs to be sent in reverse order,  so adjust now */
        pBits += cDWPass * (pRData->iy / pRData->iPassHigh - 1);
        cDWPass = -cDWPass;
        iDWLine = -pRData->cDWLine;
        iILAdv = -1;
    }
    else
    {
        /*  Usual case,  but some special local variables */
        iDWLine = pRData->cDWLine;
        iILAdv = 1;
    }

/* if the bits have already been inverted, don't bother with the rule proc.
 * The bits will be inverted for the multi scan line devices inside
 * bRuleProc because multi scan line implementation assumes
 * that bits are inverted. The function bRuleProc is changed to take
 * take care of multi scan line support  (erick)
 */
    if(!pRData->bInverted)
    {
        if (pRPDev->fRMode & PFR_RECT_FILL)
        {
            if (!bRuleProc( pPDev, pRData, pBits ))
                vInvertBits(pBits, pRData->iy * pRData->cDWLine);
        }
        else if (pRData->iNumScans != 1 || pRData->iPassHigh != 1 ||
                    (pRPDev->fBlockOut & RES_BO_NO_YMOVE_CMD))
            vInvertBits(pBits, pRData->iy * pRData->cDWLine);
        else {
            pRData->bWhiteLine = bIsNegatedLineWhite;
            pRData->bWhiteBand = bIsNegatedLineWhite;
        }
    }

    iHeadLine = 0;
    for( iLine = 0; iLine < pRData->iInterlace; ++iLine )
        iILDone[ iLine ] = 0;


    iTHKeep = pRData->iTransHigh;

    plr = (pRData->iMaxNumScans > 1) ? NULL : pRData->plrWhite;

    if (!(pPDev->fMode & PF_SURFACE_ERASED) && pPDev->pbRasterScanBuf)
        bCheckBlocks = TRUE;
    else
        bCheckBlocks = FALSE;
    //normanh  This code could be made tighter. My concern in adding multiple
    //scanline support was not to risk breaking existing code.
    //For improved performance, having separate code paths for GDI style &
    //old dot matrix style graphics could be considered


    for( iLine = 0; iLine < pRData->iy; iLine += iNumScans )
    {

        /*
         *    Check to see if there is graphics data in the current
         *  print pass.  This only happens once at the start of each
         *  print pass.
         */

        BOOL bIsWhite = FALSE;         /* Set if no graphics in this pass*/
        BYTE   *pbData;                 /* pointer to data we will send */
        /*
         *   Have we been aborted?  If so,  return failure NOW.
         */

        if(pPDev->fMode & PF_ABORTED )
            return  FALSE;

        iNumScans = pRData->iNumScans;
        if (!(pPDev->fMode & PF_SURFACE_USED))
        {
            bIsWhite = TRUE;
        }
        else if (plr != NULL)
        {
            if (plr[iLine].left > plr[iLine].right)
                bIsWhite = TRUE;

            pRData->plrCurrent = plr + iLine;
        }
        else if (bCheckBlocks && pPDev->pbRasterScanBuf[iLine / LINESPERBLOCK] == 0)
        {
            //
            // Since this whole block is white we will try to skip to the first line
            // of the next block rather than loop for each scan line. However we need
            // to make sure we don't skip past the end of the band.
            //
            if (((pRData->PrinterType == PT_PAGE) || !(pPDev->iFonts)) &&
                (pRData->iInterlace == 1))
            {
                if ((iNumScans = pRData->iy - iLine) > LINESPERBLOCK)
                    iNumScans = LINESPERBLOCK;
            }
            bIsWhite = TRUE;
        }

        if( iILDone[ iHeadLine ] == 0 )
        {
            if( (pRData->iy - iLine) < pRData->iPassHigh )
            {
                /*
                 *   MESSY:  the end of the page,  and there are some
                 * dangling scan lines.  Since this IS the end of the
                 * page,  we can fiddle with RENDER information, since
                 * this will no longer be used after this time.  iTransHigh
                 * is used for rendering operations.  They will be
                 * adjusted now so that we do not flow off the end of
                 * the engine's bitmap.
                 */

                pRData->iTransHigh = (pRData->iy - iLine +
                        pRData->iInterlace - 1) / pRData->iInterlace;

                if (plr == NULL && !bIsWhite)
                    bIsWhite = pRData->bWhiteBand( pBits, pRData, iWhiteIndex );

                /*
                 *   If this band is all white,  we can set the iLDone
                 *  entry,  since we now know that this remaining part
                 *  of the page/band is white,  and so we do not wish to
                 *  consider it further.   Note that interlaced output
                 *  allows the possibility that some other lines in this
                 *  area will be output.
                 *    Note that the value (iBitsPCol - 1) may be larger than
                 *  the number of lines remaining in this band.  However
                 *  this is safe to do,  since we drop out of this function
                 *  before reaching the excess lines, and the array data
                 *  is initialised on every call to this function.
                 */
                if( bIsWhite )
                    iILDone[ iHeadLine ] = pRData->iBitsPCol - 1;
                else
                {
                    /*
                    *   Need to consider a special case in here.  If the
                    * printer has > 8 pins,  and there are 8 or more
                    * scan lines to be dropped off the bottom,  then the
                    * transpose function will not clear the remaining
                    * part of the buffer,  since it only zeroes up
                    * to 7 scan lines at the bottom of the transpose area.
                    * Hence,  if we meet these conditions,  we zero the
                    * area before calling the transpose operation.
                    *
                    *   It can be argued that this should happen in the
                    * transpose code,  but it is really a special case that
                    * can only happen at this location.
                    */
                    if( pRData->vTransFn &&
                            (iHeight - pRData->iTransHigh) >= BBITS )
                    {
                    /*   Set the memory to zero.  */
                        ZeroMemory( pRData->pvTransBuf,
                            DWBYTES * pRData->cDWLine * pRData->iHeight );
                    }

                    // Another special case; block of scanlines
                    // Copy the data we're interesed in , into a white buffer of
                    // block size
                    if (iNumScans > 1)
                    {
                        DWORD iDataLeft = DWBYTES * pRData->cDWLine * (pRData->iy - iLine);
                        FillMemory((PBYTE)pRData->pdwTrailingScans+iDataLeft,
                            (pRData->cDWLine * iHeight * DWBYTES) - iDataLeft,
                            pRData->ubFillWhite);
                        CopyMemory(pRData->pdwTrailingScans,pBits,iDataLeft);
                        pBits = pRData->pdwTrailingScans;
                    }
                }
            }
            else
            {
                if (plr == NULL && !bIsWhite)
                {
                    bIsWhite = pRData->bWhiteLine( pBits, pRData, iWhiteIndex );
                }
            }


            /*  Data to go,  so go send it to the printer  */

            if( !bIsWhite )
            {

                pbData = (BYTE *)pBits;             /* What we are given */


                 // This is not elegant. This code is not structured to what we need to
                 // do here when printing multiple scanlines.
                 // What we do is basically take control from the outer loop, increase the
                 // block size to what we want to print, print it & then increase outer
                 // loop counters appropriately

                 // Found First non-white scanline
                 // Grow the block height until we hit a white scanline,
                 // reach the max block height, or end of page
                 // Note the following loop will execute only if the device is
                 // capable of increasing the block height: iHeight < iMaxNumScans

                while (((pRData->iNumScans + iHeight) < pRData->iMaxNumScans) &&
                       ((iLine + iHeight + iHeight) <= pRData->iy) &&
                       (!bCheckBlocks || pPDev->pbRasterScanBuf[(iLine+iHeight) / LINESPERBLOCK]) &&
                       !(pRData->bWhiteBand((DWORD *)(pBits + cDWPass),pRData,iWhiteIndex)))
                {
                    pRData->iNumScans += iHeight;
                    pBits += cDWPass;
                    iLine += iHeight;
                }

                /*
                *   Time to transpose the data into the order required to be
                * sent to the printer.  For single pin printers (Laserjets),
                * nothing happens at this stage,  but for dot matrix printers,
                * typically n scan lines are sent in bit column order,  so now
                * the bits are transposed into that order.
                */

                if( pRData->vTransFn )
                {
                    /*
                    *  this will not work with lazy invertion used with rule
                    *  detection for HP laserjet's. (erick 12/20/93)
                    */

                    ASSERTMSG(plr == NULL,("unidrv!bRealRender - vTrans with rules\n"));

                    /*   Transpose activity - do some transposing now */
                    pRData->vTransFn( pbData, pRData );

                    pbData = pRData->pvTransBuf;        /* Data to process */
                }

                if( !pRData->bPassProc( pPDev, pbData, pRData ) )
                    return  FALSE;

                // Have we grown the block height
                if (pRData->iNumScans > iHeight)
                {
                    // Update our Y cursor position remembering iTLAdv can be negative
                    pRData->iyPrtLine += iILAdv * (pRData->iNumScans - iHeight);

                    // Reset to minimum block height
                    pRData->iNumScans = iHeight;
                }

                iILDone[ iHeadLine ] = pRData->iBitsPCol -1;
            }
            //
            // Set flag to clear delta row buffer since we are
            // skipping white lines
            //
            else
                pRData->iFlags |= RD_RESET_DRC;

        }
        else
            --iILDone[ iHeadLine ];

        /*
         *   Output some text.   The complication here is that we have just
         *  printed a bunch of scan lines,  so we need to print text that
         *  is positioned within any of those.  This means we need to
         *  scan through all those lines now,  and print any fonts that
         *  are positioned within them.
         */
        if ((pRData->PrinterType != PT_PAGE) && (pPDev->iFonts) )
        {
            /*   Possible text, so go to it  */

            BOOL      bRetn;

            if( pPDev->dwLookAhead > 0 )
            {
                /*  DeskJet style lookahead region to handle */
                bRetn = bLookAheadOut( pPDev, pRData->iyPrtLine, pRData,
                      iILAdv );
            }
            else
            {
                /*  Plain vanilla dot matrix  */
                bRetn = BDelayGlyphOut( pPDev, pRData->iyPrtLine );
            }

            if( !bRetn )
                return  FALSE;         /* Bad news no matter how you see it */

        }
        pRData->iyPrtLine += iILAdv * iNumScans;     /* Next line to print */

        pBits += iDWLine * iNumScans;                /* May step backward */

        /*
         *   Keep track of the location of the head relative to the
         * graphics band.   For multiple pin printers,  we only print
         * graphics data on the first few scan lines,  the exact number
         * depending upon the interlace factor.  For example, an 8 pin printer
         * with interlace set to 1,  then graphics data is output only
         * on scan lines 0, 8, 16, 24,.....  We proces all of the scan
         * lines for text,  since the text may appear on any line.
         */

        iHeadLine = (iHeadLine + 1) % pRData->iInterlace;
    }
    pRData->iTransHigh = iTHKeep;
    return  TRUE;
}


/************************** Function Header *******************************
 * bOneColourPass
 *      Transforms an output pass consisting of colour data (split into
 *      sequences of bytes per colour) into a single, contiguous array
 *      of data that is then passed to bOnePassOut.  We also check that
 *      some data is to be set,  and set the colour as required.
 *
 * RETURNS:
 *      TRUE/FALSE,  as returned from bOnePassOut
 *
 * HISTORY:
 *   Friday December 3rd 1993   -by-    Norman Hendley   [norman]
 *      Trivial change to allow multiple scanlines
 *
 *  14:11 on Tue 25 Jun 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it to complete (untested) colour support.
 *
 *************************************************************************/

BOOL
bOneColourPass( pPDev, pbData, pRData )
PDEV    *pPDev;         /* The key to everything */
BYTE    *pbData;        /* Actual bitmap data */
RENDER  *pRData;        /* Information about rendering operations */
{

    register  BYTE  *pbIn,  *pbOut;             /* Copying data */
    register  INT    iBPC;

    INT   iColour;                      /* Colour we are handling */
    INT   iColourMax;                   /* Number of colour iterations */

    INT   iByte;                        /* Byte number of output */

    INT   iBytesPCol;                   /* Bytes per column */

    INT   iTemp;

    BYTE  bSum;                         /* Check for empty line */

    RASTERPDEV  *pRPDev;                  /* For convenience */


    pRPDev = pPDev->pRasterPDEV;

    iBytesPCol = (pRData->iBitsPCol + BBITS - 1) / BBITS;

    iColourMax = pRPDev->sDevPlanes;

    iTemp = pRData->cBYLine;



    /*
     *   The RENDERDATA structure value for the count of DWORDS per
     *  scanline should now be reduced to the number of bits per plane.
     *  The reason is that colour separation takes place in here,  so
     *  bOnePassOut() only sees the data for a single plane.  This means
     *  that bOnePassOut() is then independent of colour/monochrome.
     */

    pRData->cBYLine = iTemp / COLOUR_MAX;

    /*
     *    Disable the automatic cursor adjustment at the end of the line.
     *  This only happens on the last colour pass,  so we delay accounting
     *  for the printing until then.
     */
    pRData->iCursor = pRPDev->fCursor & ~RES_CUR_Y_POS_AUTO;


    for( iColour = 0; iColour < iColourMax; ++iColour )
    {
        /*
         *   Separate out the data for this particular colour.  Basically,
         *  it means copy n bytes, skip COLOUR_MAX * n bytes,  copy n bytes
         *  etc,  up to the end of the line.  Then call bOnePassOut with
         *  this data.
         */

        if( iColour == (iColourMax - 1) )
        {
            /*   Reinstate the automatic cursor position adjustment */
            pRData->iCursor |= pRPDev->fCursor & RES_CUR_Y_POS_AUTO;
        }
        pbIn = pbData + pRData->iColOff[ iColour ];

        pbOut = pRData->pbColSplit;             /* Colour splitting data */
        bSum = 0;

        // now we need to repack the color data
        //
        iByte = pRData->iMaxBytesSend * pRData->iNumScans;

        if (iBytesPCol == 1)
        {
            // This repacks a specific color plane
            // into concurrent planar data
            // It does multiple bytes per loop
            // for performance.
            DWORD dwSum = 0;
            while (iByte >= 4)
            {
                pbOut[0] = pbIn[0];
                pbOut[1] = pbIn[4];
                pbOut[2] = pbIn[8];
                pbOut[3] = pbIn[12];
                dwSum |= *((DWORD *)pbOut)++;
                pbIn += COLOUR_MAX*4;
                iByte -= 4;
            }
            bSum = dwSum ? 1 : 0;
            while (--iByte >= 0)
            {
                bSum |= *pbOut++ = *pbIn;
                pbIn += 4;
            }
        }
        else if (iBytesPCol == 3)
        {
            // special case 24 pin printers
            do {
                bSum |= *pbOut = *pbIn;
                bSum |= pbOut[1] = pbIn[1];
                bSum |= pbOut[2] = pbIn[2];
                pbIn += 3 * COLOUR_MAX;
                pbOut += 3;
            } while ((iByte -= 3) > 0);
        }
        else {
            // generic data repacking for V_BYTE devices
            //
            do {
                iBPC = iBytesPCol;
                do {
                    bSum |= *pbOut++ = *pbIn++;
                } while (--iBPC);
                pbIn += (COLOUR_MAX-1) * iBytesPCol;
            } while ((iByte -= iBytesPCol) > 0);
        }

        /*
         *   Check to see if any of this colour is to be printed.  We are
         *  called here if there is any non-white on the line.  However,
         *  it could,  for instance,  be red only,  and so it is wasteful
         *  of printer time to send a null green pass!
         */
        if( (pRData->iFlags & RD_ALL_COLOUR) || bSum )
        {
            //
            // Send a separate color command from the data to select
            // the color plane
            //
            if( pRPDev->fColorFormat & DC_EXPLICIT_COLOR )
                SelectColor (pPDev, iColour);

            //
            // The color command is sent with the data so we determine
            // which command should be used.
            //
            else
                pRData->iSendCmd = pRPDev->rgbCmdOrder[iColour];

            //
            // OK, lets output 1 color plane of data
            //
            if( !bOnePassOut( pPDev, pRData->pbColSplit, pRData ) )
            {
                pRData->cBYLine = iTemp;
                return  FALSE;
            }
        }

    }
    pRData->cBYLine = iTemp;            /* Correct value for other parts */

    return  TRUE;
}
/************************* Function Header ***********************************
 *  SelectColor
 *          Selects color, 0 must be the last color to be selected.
 *          Assumes that color info contains parameters for selecting
 *          black cyan magenta yellow
 *          Keep track of the current color selection, to reduce the amount
 *          of data sent to the printer
 *
 * RETURNS:
 *         Nothing.
 *
 * HISTORY:
 *
 *****************************************************************************/

void
SelectColor(
    PDEV *pPDev,
    INT color
)
{
    PRASTERPDEV pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    if( color >= 0 && color != pPDev->ctl.sColor )
    {
        // check to see if to send CR or not.
        if( pRPDev->fColorFormat & DC_CF_SEND_CR )
            XMoveTo( pPDev, 0, MV_PHYSICAL );

        WriteChannel(pPDev,COMMANDPTR(pPDev->pDriverInfo,
            pRPDev->rgbCmdOrder[color]));
        pPDev->ctl.sColor = (short)color;
    }
}

/************************** Function Header ********************************
 * bOnePassOut
 *      Function to process a group of scan lines and turn the data into
 *      commands for the printer.
 *
 * RETURNS:
 *      TRUE for success,  else FALSE.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *  14:26 on Thu 17 Jan 1991    -by-    Lindsay Harris   [lindsayh]
 *      Started on it,  VERY loosely based on Windows 16 UNIDRV.
 *
 *  Thu 25 Nov 1993             -by-    Norman Hendley   [normanh]
 *      Enabled multple scanlines & multiple parameters
 *
 ***************************************************************************/

BOOL
bOnePassOut( pPDev, pbData, pRData )
PDEV           *pPDev;          /* The key to everything */
BYTE           *pbData;         /* Actual bitmap data */
register RENDER  *pRData;       /* Information about rendering operations */
{

    INT  iLeft;         /* Left bound of output buffer,  as a byte index */
    INT  iRight;        /* Right bound, as array index of output buffer */
    INT  iBytesPCol;    /* Bytes per column of print data */
    INT  iMinSkip;      /* Minimum null byte count before skipping */
    INT  iNumScans;     /* Number Of Scanlines in Block */
    INT   iWidth;       /* Width of one scanline in multiscanline printing
                     * before stripping */
    INT   iSzBlock;     /* size of Block */


    WORD  fCursor;      /* Temporary copy of cursor modes in Resolution */
    WORD  fDump;        /* Device capabilities */
    WORD  fBlockOut;    /* Output minimising details */

    RASTERPDEV  *pRPDev;  /* Unidrv's pdev */
    DWORD dwWhiteIndex;

    PLEFTRIGHT plr = pRData->plrCurrent;

    pRPDev = pPDev->pRasterPDEV;

    fDump = pRData->fDump;
    fCursor = pRPDev->fCursor;
    fBlockOut = pRPDev->fBlockOut;

    if (pRData->iBPP == 24)
        iBytesPCol = 3;
    else
        iBytesPCol = (pRData->iBitsPCol + BBITS - 1) / BBITS;

    iMinSkip = (int)pRPDev->sMinBlankSkip;

    iNumScans= pRData->iNumScans;
    iWidth = pRData->cBYLine;     // bytes per line
    iSzBlock= iWidth * iNumScans;

    iRight = pRData->iMaxBytesSend;

    dwWhiteIndex = pRData->dwDevWhiteIndex;

    /*
     *    IF we can skip any leading null data,  then do so now.  This
     *  reduces the amount of data sent to the printer,  and so can
     *  be beneficial to speed up data transmission time.
     */

    if  ((fBlockOut & RES_BO_LEADING_BLNKS) || ( fDump & RES_DM_LEFT_BOUND ))
    {
         if (iNumScans == 1) //Don't slow the single scanline code
         {
            /*  Look for the first non zero column */

            iLeft = 0;

            if (plr != NULL)
            {
                ASSERTMSG ((WORD)iRight >= (plr->right * sizeof(DWORD)),("unidrv!bOnePassOut - invalid right\n"));
                ASSERTMSG (fBlockOut & RES_BO_TRAILING_BLNKS,("unidrv!bOnePassOut - invalid fBlockOut\n"));
                iLeft  = plr->left * sizeof(DWORD);
                iRight = (plr->right+1) * sizeof(DWORD);
            }
            // since the left margin is zero this buffer will be DWORD aligned
            // this allows for faster white space detection
            // NOTE: we don't currently support 8 bit indexed mode
            else
            {
                while ((iLeft+4) <= iRight && *(DWORD *)&pbData[iLeft] == dwWhiteIndex)
                    iLeft += 4;
            }
            while (iLeft < iRight && pbData[iLeft] == (BYTE)dwWhiteIndex)
                iLeft++;

            /*  Round it to the nearest column  */
            iLeft -= iLeft % iBytesPCol;

            /*
             *   If less than the minimum skip amount,  ignore it.
             */
            if((plr == NULL) && (iLeft < iMinSkip))
                iLeft = 0;

         }
         else
         {
            INT pos;

            pos = iSzBlock +1;
            for (iLeft=0; iRight > iLeft &&  pos >= iSzBlock ;iLeft++)
                for (pos =iLeft; pos < iSzBlock && pbData[ pos] == (BYTE)dwWhiteIndex ;pos += iWidth)
                    ;

            iLeft--;

            /*  Round it to the nearest column  */
            iLeft -= iLeft % iBytesPCol;

            /*
             *   If less than the minimum skip amount,  ignore it.
             */

            if( iLeft < iMinSkip )
                iLeft = 0;
         }
    }
    else
    {
        iLeft = 0;
    }

    /*
     *    Check for eliminating trailing blanks.  If possible,  now
     *  is the time to find the right end of the data.
     */

    if( fBlockOut & RES_BO_TRAILING_BLNKS )
    {
        /*  Scan from the RHS to the first non-zero byte */

        if (iNumScans == 1)
        {
            if (plr != NULL)
                iRight = (plr->right+1) * sizeof(DWORD);

            // if the number of bytes to check is large
            // we will optimize to check it using DWORDS
            else if ((iRight - iLeft) >= 8)
            {
                // first we need to DWORD align the right position
                // we will be aligned when the 2 LSB's of iRight are 0
                //
                while (iRight & 3)
                    if (pbData[--iRight] != (BYTE)dwWhiteIndex)
                        goto DoneTestingBlanks;

                // OK now that we are DWORD aligned we can check
                // for white space a DWORD at a time
                //
                while ((iRight -= 4) >= iLeft && *(DWORD *)&pbData[iRight] == dwWhiteIndex);
                iRight += 4;
            }
            // now we can quickly test any remaining bytes
            //
            while (--iRight >= iLeft && pbData[iRight] == (BYTE)dwWhiteIndex);
        }
        else
        {
            INT pos;

            pos = iSzBlock +1;
            while(iRight > iLeft &&  pos > iSzBlock)
                for (pos = --iRight; pos < iSzBlock && pbData[ pos] == (BYTE)dwWhiteIndex ;pos += iWidth)
                    ;
        }
DoneTestingBlanks:
        iRight += iBytesPCol - (iRight % iBytesPCol);
    }


    /*
     *   If possible,  switch to unidirectional printing for graphics.
     *  The reason is to improve output quality,  since head position
     *  is not as reproducible in bidirectional mode.
     */
    if( (fBlockOut & RES_BO_UNIDIR) && !(pRData->iFlags & RD_UNIDIR) )
    {
        pRData->iFlags |= RD_UNIDIR;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_UNIDIRECTIONON) );
    }

    if( fBlockOut & RES_BO_ENCLOSED_BLNKS )
    {
        /*
         *   We can skip blank patches in the middle of the scan line.
         *  This is only worthwhile when the number of blank columns
         *  is > iMinSkip,  because there is also overhead in not
         *  sending blanks,  especially the need to reposition the cursor.
         */

        INT   iIndex;           /* Scan between iLeft and iRight */
        INT   iBlank;           /* Start of blank area */
        INT   iMax;
        INT   iIncrement;

        iBlank = 0;             /* None to start with */

        if (iNumScans ==1)
        {
            iMax = iBytesPCol;
            iIncrement =1;
        }
        else
        {
            iMax = iSzBlock;
            iIncrement = iWidth;
        }

        for( iIndex = iLeft; iIndex < iRight; iIndex += iBytesPCol )
        {
            INT  iI;
            for( iI = 0; iI < iMax; iI +=iIncrement )
            {
                if( pbData[iIndex + iI] )
                    break;
            }

            if( iI < iMax )
            {
                /*
                 *   If this is the end of a blank stretch,  then consider
                 *  the possibility of not sending the blank part.
                 */
                if( iBlank && (iIndex - iBlank) >= iMinSkip )
                {
                /*  Skip it!  */

                    iLineOut( pPDev, pRData, pbData, iLeft, iBlank );
                    iLeft = iIndex;
                }
                iBlank = 0;             /* Back in the printed zone */
            }
            else
            {
                /*
                 *    A blank column - remember it if this is the first.
                 */
                if( iBlank == 0 )
                    iBlank = iIndex;            /* Record start of blank */
            }

        }
        /*  What's left over needs to go too! */
        if( iLeft != iIndex )
            iLineOut( pPDev, pRData, pbData, iLeft, iIndex );
    }
    else
    {
        //
        // PCLXL raster mode
        //
        if (pPDev->ePersonality == kPCLXL_RASTER)
        {
            DWORD dwcbOut;


            if (S_OK != PCLXLSetCursor((PDEVOBJ)pPDev,
                                        pRData->ixOrg,
	        pRData->iyPrtLine) ||
                S_OK != PCLXLSendBitmap((PDEVOBJ)pPDev,
                                        pRData->iBPP,
    	        pRData->iNumScans,
	        pRData->cBYLine,
	        iLeft,
	        iRight,
	        pbData,
	        &dwcbOut))
            {
                return FALSE;
            }

        }
        else
        {
            /*   Write the whole of the (remaining) scan line out */
            /*   For multiple scanlines, iRight is right side of top scanline */

            iLineOut( pPDev, pRData, pbData, iLeft, iRight );
        }

    }
    return  TRUE;
}

/************************** Function Header *********************************
 * iLineOut
 *      Sends the passed in line of graphics data to the printer,  after
 *      setting the X position, etc.
 *
 * RETURNS:
 *      Value from WriteSpoolBuf: number of bytes written.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *  Mon 29th November 1993      -by-    Norman Hendley   [normanh]
 *      Added multiple scanline support
 *
 *  10:38 on Wed 15 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it during render speed ups
 *
 ****************************************************************************/

int
iLineOut( pPDev, pRData, pbOut, ixPos, ixEnd )
PDEV     *pPDev;          /* The key to everything */
RENDER   *pRData;       /*  Critical rendering information */
BYTE     *pbOut;        /*  Area containing data to send */
INT       ixPos;        /*  X location to start the output */
INT       ixEnd;        /*  Byte address of first byte to NOT send */
{

    INT    iBytesPCol;          /* Bytes per output col; dot matrix */
    INT    ixErr;               /* Error in setting X location */
    INT    ixLeft;              /* Left position in dots */
    INT    cbOut;               /* Number of bytes to send */
    INT    iRet;                /* Return value from output function */
    INT    iNumScans;           /* local copy          */
    INT    iScanWidth;          /* Width of scanline, used for multi-scanline printing*/
    INT    iCursor;             /* Cursor behavior flag */
    DWORD  fRMode;              // local copy

    BYTE     *pbSend;           /* Address of data to send out */

    RASTERPDEV  *pRPDev;

    if (ixPos < 0)
    {
        ERR (("Unidrv!iLineOut: ixPos < 0\n"));
        ixPos = 0;
    }

    pRPDev = pPDev->pRasterPDEV;
    fRMode = pRPDev->fRMode;

    iNumScans = pRData->iNumScans;
    iCursor = pRData->iCursor;

    /*
     *   Set the Y position - safe to do so at anytime.
     */
    pRData->iYMoveFn( pPDev, pRData->iyPrtLine, MV_GRAPHICS );

    if ((iBytesPCol = pRData->iBitsPCol) != 1)
        iBytesPCol /= BBITS;

#if DBG
    if( (ixEnd - ixPos) % iBytesPCol )
    {
        DbgPrint( "unidrv!iLineOut: cbOut = %ld, NOT multiple of iBytesPCol = %ld\n",
        ixEnd - ixPos, iBytesPCol );

        return  0;
    }
#endif


    /*
     *    Set the preferred left limit and number of columns to send.
     *  Note that the left limit may be adjusted to the left if the
     *  command to set the X position cannot set it exactly.
     *    Note also that some printers are unable to set the x position
     *  while in graphics mode,  so for these,  we ignore what may be
     *  able to be skipped.
     */

    if( pRData->fDump & RES_DM_LEFT_BOUND)
    {
        INT iMinSkip = pRPDev->sMinBlankSkip;
        if (!(pRData->iFlags & RD_GRAPHICS))
            iMinSkip >>= 2;
        if (ixPos < pRData->ixOrg || (pRData->ixOrg + iMinSkip) < ixPos)
        {
            /*
             *     Need to move left boundary.  This may mean
             *  exiting graphics mode if we are already there,  since
             *  that is the only way to change the origin!
             */

            if( pRData->iFlags & RD_GRAPHICS )
            {
                pRData->iFlags &= ~RD_GRAPHICS;
                if (pRData->dwLastCompCmd != CMD_DISABLECOMPRESSION)
                {
                    pRData->dwLastCompCmd = CMD_DISABLECOMPRESSION;
                    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION));
                }
                WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_ENDRASTER));
            }
            //
            // Save the new graphics origin
            //
            pRData->ixOrg = ixPos;
        }
        else
        {
            // we can't optimize the left edge, better make it white

            if (pRData->plrCurrent != NULL)
                ZeroMemory(&pbOut[pRData->ixOrg], ixPos - pRData->ixOrg);

            ixPos = pRData->ixOrg;
        }
    }
    /*
     *    Adjust the right side position to dot column version.
     */

    if( pRData->iBitsPCol == 1 )
    {
        /*  Laserjet style - work in byte units  */
        if (pRData->iBPP == 8)
            ixLeft = ixPos;              /* In dot/column units */
        else if (pRData->iBPP == 24)
            ixLeft = (ixPos * BBITS) / 24;
        else
            ixLeft = ixPos * BBITS;
    }
    else
    {
        /*   Dot matrix printers */
        ixLeft = ixPos / iBytesPCol;
    }


    /*
     *   Move as close as possible to the position along this scanline.
     * This is true regardless of orientation - this move is ALONG the
     * direction of the scan line.
     */
    if( ixErr = pRData->iXMoveFn( pPDev, ixLeft, MV_GRAPHICS ) )
    {
        /*
         *   Fiddle factor - the head location could not
         * be exactly set, so send extra graphics data to
         * compensate.
         *   NOTE:  Presumption is that this will NEVER try to move
         *  the head past the left most position.  If it does,  then
         *  we will be referencing memory lower than the scan line
         *  buffer!
         */

        if( pRData->iBitsPCol == 1 )
        {
            /*
             *    We should not come in here - there are some difficulties
             *  in adjusting the position because there is also a byte
             *  alignment requirement.
             */
#if DBG
            DbgPrint( "+++BAD NEWS: ixErr != 0 for 1 pin printer\n" );
#endif
        }
        else
        {
            /*
             *    Should adjust our position by the number of additional cols
             *  we wish to send.  Also recalculate the array index position
             *  corresponding to the new graphical position,
             */
             if (ixLeft <= ixErr)
                ixPos = 0;
             else
                ixPos = (ixLeft - ixErr) * iBytesPCol;
        }

    }

    // For a multiple scanline block the printable data will not be contiguous.
    // We have already identified where to strip white space
    // Only now can we actually remove the white data

    if(( iNumScans > 1 ) && !( fRMode & PFR_BLOCK_IS_BAND ))
    {
        cbOut = iStripBlanks( pRData->pStripBlanks, pbOut, ixPos,
                    ixEnd, iNumScans, pRData->cBYLine);
        ixEnd = ixEnd - ixPos;
        ixPos = 0;
        pbOut = pRData->pStripBlanks;
    }


    // Calculate the width of the source data in bytes and check
    // whether we need to output this to the device. If so, we
    // evidently need to exit raster mode first

    iScanWidth = ixEnd - ixPos;
    if ((DWORD)iScanWidth != pPDev->dwWidthInBytes)
    {
        pPDev->dwWidthInBytes = iScanWidth;
        if (fRMode & PFR_SENDSRCWIDTH)
        {
            if( pRData->iFlags & RD_GRAPHICS )
            {
                pRData->iFlags &= ~RD_GRAPHICS;
                if (pRData->dwLastCompCmd != CMD_DISABLECOMPRESSION)
                {
                    pRData->dwLastCompCmd = CMD_DISABLECOMPRESSION;
                    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION) );
                }
                WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_ENDRASTER) );
            }
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPWIDTH));
        }
    }

    //
    // Check whether we should send the source height to the device
    //
    if ((DWORD)iNumScans != pPDev->dwHeightInPixels)
    {
        pPDev->dwHeightInPixels = iNumScans;
        if (fRMode & PFR_SENDSRCHEIGHT)
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPHEIGHT));
    }

    //
    // Make sure we are in raster mode at this point
    //
    if( !(pRData->iFlags & RD_GRAPHICS))
    {
        pRData->iFlags |= RD_GRAPHICS;
        if (fRMode & PFR_SENDBEGINRASTER)
            WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_BEGINRASTER));
    }

    //
    //  Calculate the number of bytes to send.
    //  If compression is available, use it first.
    //
    cbOut = iScanWidth * iNumScans ;

    pbSend = &pbOut[ ixPos ];

    //
    //  Mirror each data byte if required
    //
    if (pRData->pbMirrorBuf)
    {
        INT i = cbOut;
        PBYTE pMirror = pRData->pbMirrorBuf;
        while (--i >= 0)
            pbSend[i] = pMirror[pbSend[i]];
    }
    //
    // If there are compression modes we want to determine the
    // most efficient algorithm of those that are enabled.
    //
    if (pRData->dwNumCompCmds)
    {
        DWORD i;
        INT iBestCompSize;
        DWORD dwBestCompCmd;
        INT iCompLimit;
        INT iLastCompLimit;
        PBYTE pBestCompPtr;

        //
        // test whether to initialize dwDeltaRowBuffer
        //
        if (pRData->pDeltaRowBuffer && pRData->iFlags & RD_RESET_DRC)
        {
            pRData->iFlags &= ~RD_RESET_DRC;
            ZeroMemory(pRData->pDeltaRowBuffer,pRData->iMaxBytesSend);
        }

        // initialize to size of buffer
        //
        iCompLimit = iLastCompLimit = pRData->dwCompSize;
        dwBestCompCmd = 0;

        // loop until we've compressed using all active compression modes
        // and have found the most efficient
        //
        for (i = 0;i < pRData->dwNumCompCmds;i++)
        {
            INT iTmpCompSize;
            PBYTE pTmpCompBuffer = pRData->pCompBufs[i];
            DWORD dwTmpCompCmd = pRData->pdwCompCmds[i];
            //
            // do the appropriate compression
            //
            iTmpCompSize = -1;
            switch (dwTmpCompCmd)
            {
            case CMD_ENABLETIFF4:
                iTmpCompSize = iCompTIFF(pTmpCompBuffer,pbSend,cbOut);
                break;
            case CMD_ENABLEFERLE:
                iTmpCompSize = iCompFERLE(pTmpCompBuffer,pbSend,cbOut,iLastCompLimit);
                break;
            case CMD_ENABLEOEMCOMP:
                FIX_DEVOBJ(pPDev,EP_OEMCompression);
                //  also add these members to the struct _PDEV   (unidrv2\inc\pdev.h)
                //  POEM_PLUGINS    pOemEntry;

                //  note add macro FIX_DEVOBJ in unidrv2\inc\oemkm.h so it also does this:

                //  (pPDev)->pOemEntry = ((pPDev)->pOemHookInfo[ep].pOemEntry)
                //        (pOemEntry is defined as type POEM_PLUGIN_ENTRY in printer5\inc\oemutil.h)
                //

                if(pPDev->pOemEntry)
                {
                    if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                    {
                            HRESULT  hr ;
                            hr = HComCompression((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                        (PDEVOBJ)pPDev,pbSend,pTmpCompBuffer,cbOut,iLastCompLimit, &iTmpCompSize);
                            if(SUCCEEDED(hr))
                                ;  //  cool !
                    }
                    else
                    {
                        iTmpCompSize = pRPDev->pfnOEMCompression((PDEVOBJ)pPDev,pbSend,pTmpCompBuffer,cbOut,iLastCompLimit);
                    }
                }
                break;
            case CMD_ENABLEDRC:
                iTmpCompSize = iCompDeltaRow(pTmpCompBuffer,pbSend,
                    pRData->pDeltaRowBuffer,pRData->iMaxBytesSend,iLastCompLimit);
                break;
            case CMD_DISABLECOMPRESSION:
                iTmpCompSize = cbOut;
                pTmpCompBuffer = pbSend;
                break;
            }
            //
            // decide if new compression is smaller than last
            //
            if (iTmpCompSize >= 0)
            {
                if (dwTmpCompCmd == pRData->dwLastCompCmd)
                {
                    if (iTmpCompSize >= iLastCompLimit)
                        continue;

                    iLastCompLimit = iCompLimit = iTmpCompSize - COMP_FUDGE_FACTOR;
                }
                else if (iTmpCompSize < iCompLimit)
                {
                    iCompLimit = iTmpCompSize;
                    if (iLastCompLimit > (iTmpCompSize + COMP_FUDGE_FACTOR))
                        iLastCompLimit = iTmpCompSize + COMP_FUDGE_FACTOR;
                }
                else
                    continue;

                iBestCompSize = iTmpCompSize;
                pBestCompPtr = pTmpCompBuffer;
                dwBestCompCmd = dwTmpCompCmd;
                if (iCompLimit <= 1)
                    break;
            }
        }

        // if DRC is enabled we need to save the scan line
        //
        if (pRData->pDeltaRowBuffer)
            CopyMemory (pRData->pDeltaRowBuffer,pbSend,pRData->iMaxBytesSend);

        //
        // verify we found a valid compression technique
        // otherwise use no compression mode
        //
        if (dwBestCompCmd == 0)
        {
            dwBestCompCmd = CMD_DISABLECOMPRESSION;
            if (!(COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION)))
            {
                ERR (("Unidrv: No valid compression found\n"));
                pPDev->fMode |= PF_ABORTED;
            }
        }
        else
        {
            // update the output pointer and size with the best
            // compression method.
            //
            pbSend = pBestCompPtr;
            cbOut = iBestCompSize;
        }

        // if we've changed compression modes we need to
        // output the new mode to the printer
        //
        if (dwBestCompCmd != pRData->dwLastCompCmd)
        {
//            DbgPrint ("New Comp: %ld,y=%ld,size=%ld\n",dwBestCompCmd,
//                pRData->iyPrtLine,cbOut);
            pRData->dwLastCompCmd = dwBestCompCmd;
            WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,dwBestCompCmd));
        }
    }

    // update data block size
    // output the raster command and
    // output the actual raster data
    //
    pPDev->dwNumOfDataBytes = cbOut;

    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,pRData->iSendCmd));

    //
    // if callback, adjust the pdev and make the OEM callback
    //
    if (pRPDev->pfnOEMFilterGraphics)
    {
        FIX_DEVOBJ(pPDev,EP_OEMFilterGraphics);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                    HRESULT  hr ;
                    hr = HComFilterGraphics((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                (PDEVOBJ)pPDev, pbSend, cbOut);
                    if(SUCCEEDED(hr))
                        iRet = cbOut;  //  cool !
                    else
                        iRet = 0 ;  //  hackey, the OEM function should return # bytes written to spooler
                                        //  but too late to change the interface now.
            }
            else
            {
                iRet = pRPDev->pfnOEMFilterGraphics((PDEVOBJ)pPDev, pbSend, cbOut);
            }
        }

    }
    //
    // otherwise we just write out the data ourselves
    //
    else
        iRet = WriteSpoolBuf(pPDev, pbSend, cbOut );

    // Test whether to send end of block command
    //
    if (fRMode & PFR_ENDBLOCK)
        WriteChannel (pPDev,COMMANDPTR(pPDev->pDriverInfo,CMD_ENDBLOCKDATA));

    //
    // Test whether to reset fonts after sending raster data
    //
    if (pPDev->fMode & PF_RESELECTFONT_AFTER_GRXDATA)
    {
        VResetFont(pPDev);
    }

    /*
     *    Adjust our idea of the printer's cursor position.  IF the printer
     *  does not change the cursor's X position after printing,  then we leave
     *  it where it now is,  otherwise we set to what the printer has.
     */

    if( !(iCursor & RES_CUR_X_POS_ORG) )
    {
        if( iCursor & RES_CUR_X_POS_AT_0 )
        {
            /*
             *    This type of printer sets the cursor to the left hand
             *  side after printing,  so set that as our current position.
             */
            pRData->iXMoveFn( pPDev, 0, MV_PHYSICAL | MV_UPDATE );
        }
        else
        {
            /*
             *   Cursor remains at end of output.  So,  set that as our
             *  position too.  But first,  calculate the RHS dot position.
             */

            INT   ixRight;

            if( pRData->iBitsPCol == 1 )
                ixRight = ixEnd * BBITS;        /*  Laserjet style */
            else
                ixRight = ixEnd / iBytesPCol;   /*   Dot matrix printers */


            pRData->iXMoveFn( pPDev, ixRight, MV_UPDATE | MV_GRAPHICS );
        }
    }

    /*
     *    If the printer moves the Y position after printing,  then now
     *  is the time to adjust our Y position.
     */
    if( iCursor & RES_CUR_Y_POS_AUTO )
    {
        pRData->iYMoveFn( pPDev, pRData->iPosnAdv,
                MV_UPDATE | MV_RELATIVE | MV_GRAPHICS );
    }

    return  iRet;
}
//*******************************************************
void
vInvertBits (
    DWORD  *pBits,
    INT    cDW
    )
/*++

Routine Description:

    This function inverts a group of bits. This is used to convert
    1 bit data from 0 = black and 1 = white to the opposite.

Arguments:

    pRD         Pointer to RENDER structure
    pBits       Pointer to data buffer to invert

Return Value:

    none

--*/
{
#ifndef _X86_
    INT cDWT = cDW >> 2;
    while( --cDWT >= 0 )
    {
        pBits[0] ^= ~((DWORD)0);
        pBits[1] ^= ~((DWORD)0);
        pBits[2] ^= ~((DWORD)0);
        pBits[3] ^= ~((DWORD)0);
        pBits += 4;
    }
    cDWT = cDW & 3;
    while (--cDWT >= 0)
        *pBits++ ^= ~((DWORD)0);

#else
//
// if intel processor, do it in assembly, for some reason
// the compiler always does the NOT in three vs one instruction
//
__asm
{
    mov ecx,cDW
    mov eax,pBits
    sar ecx,2
    jz  SHORT IB2
IB1:
    not DWORD PTR [eax]
    not DWORD PTR [eax+4]
    not DWORD PTR [eax+8]
    not DWORD PTR [eax+12]
    add eax,16
    dec ecx
    jnz IB1
IB2:
    mov ecx,cDW
    and ecx,3
    jz  SHORT IB4
IB3:
    not DWORD PTR [eax]
    add eax,4
    dec ecx
    jnz IB3
IB4:
}
#endif
}

#if 0
//*******************************************************
void
vFindWhiteInvertBits (
    RASTERPDEV *pRPDev,
    RENDER *pRD,
    DWORD  *pBits
    )
/*++

Routine Description:

    This function determines the leading and trailing white
    space for this buffer and inverts all the necessary bits
    such that 0's are white and 1's are black.

Arguments:
    pRPDev      Pointer to RASTERPDEV structure
    pRD         Pointer to RENDER structure
    pBits       Pointer to data buffer to invert

Return Value:

    none

--*/
{
    DWORD cDW = pRD->cDWLine;
    DWORD cLine = pRD->iy;

    //
    // if the MaxNumScans is 1 then it is useful to determine
    // the first and last non-white dword and store them as left
    // and right in the plrWhite structure. Only the non-white
    // data needs to be inverted in this case
    //
    if (pRD->iMaxNumScans == 1 &&
        ((pRPDev->fBlockOut & RES_BO_LEADING_BLNKS) ||
         (pRD->fDump & RES_DM_LEFT_BOUND)) &&
         (pRPDev->fBlockOut & RES_BO_TRAILING_BLNKS))
    {
        PLEFTRIGHT plr;
        DWORD dwMask = pRD->pdwBitMask[pRD->cBLine % DWBITS];
        if (dwMask != 0)
            dwMask = ~dwMask;
        // allocate blank space structure
        //
        if (pRD->plrWhite == NULL || (pRD->clr < cLine))
        {
            if (pRD->plrWhite != NULL)
                MemFree (pRD->plrWhite);
            pRD->plrWhite = MemAlloc(sizeof(LEFTRIGHT) * cLine);
            pRD->clr = cLine;

            // can't allocate structure so invert everything
            //
            if (pRD->plrWhite == NULL)
            {
                vInvertBits( pBits, cDW * cLine );
                return;
            }
        }
        plr = pRD->plrWhite;
        while (cLine-- > 0)
        {
            DWORD *pdwIn = pBits;
            DWORD *pdwLast = &pBits[cDW-1];
            DWORD dwLast = *pdwLast | dwMask;

            // find leading blanks, set last dword to zero
            // for faster checking
            //
            *pdwLast = 0;
            while (*pdwIn == -1)
                pdwIn++;

            *pdwLast = dwLast;

            // find trailing blanks
            //
            if (dwLast == (DWORD)-1)
            {
                pdwLast--;
                if (pdwIn < pdwLast)
                {
                    while (*pdwLast == (DWORD)-1)
                        pdwLast--;
                }
            }
            plr->left = pdwIn - pBits;
            plr->right = pdwLast - pBits;

            // invert remaining dwords
            //
            while (pdwIn <= pdwLast)
                *pdwIn++ ^= ~((DWORD)0);

            // increment to next line
            pBits += cDW;
            plr++;
        }
    }
    // MaxNumScans > 1 so invert everything
    //
    else
        vInvertBits( pBits, cDW * cLine );

}
#endif
/************************** Function Header *********************************
 * bLookAheadOut
 *      Process text for printers requiring a lookahead region.  These are
 *      typified by the HP DeskJet family,  where the output needs to be
 *      sent before the printer reaches that point in the raster scan.
 *      The algorithm is explained in the DeskJet manual.
 *
 * RETURNS:
 *      TRUE/FALSE,  FALSE being some substantial failure.
 *
 * HISTORY:
 *  10:43 on Mon 11 Jan 1993    -by-    Lindsay Harris   [lindsayh]
 *      Created it to support the DeskJet.
 *
 ****************************************************************************/

BOOL
bLookAheadOut( pPDev, iyVal, pRD, iILAdv )
PDEV     *pPDev;         /* Our PDEV,  gives us access to all our data */
INT       iyVal;         /* Scan line being processed. */
RENDER   *pRD;           /* The myriad of data about what we do */
INT       iILAdv;        /* Add to scan line number to get next one */
{
    /*
     *    First step is to find the largest font in the lookahead region.
     *  The position sorting code does this for us.
     */

    INT     iTextBox;         /* Scan lines to look for text to send */
    INT     iIndex;           /* Loop parameter */

    RASTERPDEV   *pRPDev;       /* The active stuff */


    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    iTextBox = ILookAheadMax( pPDev, iyVal, pPDev->dwLookAhead );

    iIndex = pRD->iyLookAhead - iyVal;
    iyVal = pRD->iyLookAhead;                 /* Base address of scan */

    while( iIndex < iTextBox )
    {
        if( !BDelayGlyphOut( pPDev, iyVal ) )
            return   FALSE;                    /* Doomsday is here */

        ++iIndex;
        ++iyVal;
    }

    pRD->iyLookAhead = iyVal;

    return   TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\rmdebug.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    rmdebug.h

Abstract:

    Raster module Debugging header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    02/14/97 -alvins-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _RMDEBUG_H
#define _RMDEBUG_H

#if DBG

/* Debugging Macroes */
#define IFTRACE(b, xxx)          {if((b)) {VERBOSE((xxx));}}
#define PRINTVAL( Val, format)   {\
            if (giDebugLevel <= DBG_VERBOSE) \
                DbgPrint("Value of "#Val " is "#format "\n",Val );\
            }

#define TRACE( Val )             {\
            if (giDebugLevel <= DBG_VERBOSE) \
                DbgPrint(#Val"\n");\
            }


#else  //!DBG Retail Build

/* Debugging Macroes */
#define IFTRACE(b, xxx)
#define PRINTVAL( Val, format)
#define TRACE( Val )

#endif //DBG

#endif  // !_RMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\transpos.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    The module contains the functions associated with transposing bitmaps.
    This includes rotation of 1, 4, 8, and 24 bit formats as well as special
    transformations of color formats for planar of vertical head devices.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/
#include        "raster.h"
#include        "rmrender.h"


/*
 *   The transpose table:  maps one byte into two longs,  such that the
 * 8 bits of the byte turn into 64 bits: each bit of the original is
 * turned into one byte of output.
 *   THUS:
 * Input byte:   hgfedcba
 *   transposes into output bytes:
 *      0000000a  0000000b  0000000c  0000000d
 *      0000000e  0000000f  0000000g  0000000h
 *
 *   The table is allocated at DrvEnableSurface time,  thus ensuring that
 *  we do not allocate memory that we are not going to use.
 */

#define TABLE_SIZE      (256 * 2 * sizeof( DWORD ))

/*
 *   We also need a similar table for colour separation.  This one
 *  consists of 256 DWORDs,  and is used to split the RGB(K) format
 *  input byte into an output DWORD with the two R bits in one byte,
 *  the two G bits in the next byte etc.  Used for single pin colour
 *  printers,  like the HP PaintJet.
 *   The table is generated according to the following rule:
 *
 *  INPUT BYTE:  KRGBkrgb
 *
 *  OUTPUT DWORD:  000000Kk 000000Rr 000000Gg 000000Bb
 */

#define SEP_TABLE_SIZE  (256 * sizeof( DWORD ))



//*******************************************************
BOOL
bInitTrans (
    PDEV *pPDev
    )
/*++

Routine Description:

    This function initializes the transpose tables.  This is done to make
    the table independent of whether the processor is big endian or little
    endian since the data is generated by the processor that is going
    to use it!

Arguments:

    pPDev           Pointer to PDEV structure

Return Value:

    TRUE for success and FALSE for failure (MemAlloc failure)

--*/
{
    /*
     *   Function to generate the transposition table.  There is nothing
     * difficult about generating the table.  The only trick is the use
     * of the union.  This allows us to setup a DWORD table with the
     * byte ordering of the hardware on which we are running.  This is
     * achieved by writing the data into the BYTE entry,  then using
     * the same memory as a DWORD to be put away into memory.  The reason
     * for using DWORDS is to get maximum benefit from memory references
     * in the inner loop of the transpose functions.
     *   Note that the 8/24 bits per pel case is special, as we are shuffling
     * bytes around, and thus do not need any tables.  For this case,
     * return TRUE without allocating any storage.
     */

    register  DWORD   *pdw;
    register  int   iShift,  j;

    int    i;
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;

    union
    {
        BYTE   b[ 8 ];          /* Exactly 64 bits */
        DWORD  dw[ 2 ];         /* Also exactly 64 bits */
    } u;


    if( pRPDev->sDevBPP == 8 || pRPDev->sDevBPP == 24)
    {
        pRPDev->pdwTrans = NULL;

        return   TRUE;              /* Byte operations - no table needed */
    }

    if( !(pRPDev->pdwTrans = (DWORD *)MemAlloc( TABLE_SIZE )) )
        return  FALSE;


    pdw = pRPDev->pdwTrans;              /* Speedier access */


    /*
     *   Colour requires different tables,  as the pixel data consists of
     * 4 bits which need to move in a single group.
     */

    if( pRPDev->fDump & RES_DM_COLOR )
    {
        /*
         *   First generate the landscape to portrait transpose data.
         *  The only complication is maintaining 4 bit nibbles as a single
         *  entity.
         */
        u.dw[0] = 0;
        for (iShift = 0; iShift < 256; iShift++)
        {
            u.b[1] = (BYTE)((iShift >> 4) & 0x0f);
            u.b[3] = (BYTE)(iShift & 0x0f);
            *pdw = u.dw[0];
            *(pdw+1) = u.dw[0] << 4;
            pdw += 2;
        }
        /*
         * There is an additional transpose operation that requires
         * 4 bit pixel data be transformed to another format.
         */
        pRPDev->pdwColrSep = (DWORD *)MemAlloc( (pRPDev->fDump & RES_DM_GDI) ?
                                                        SEP_TABLE_SIZE : TABLE_SIZE );
        if( pRPDev->pdwColrSep == NULL )
        {
            MemFree((LPSTR)pRPDev->pdwTrans );
            pRPDev->pdwTrans = 0;

            return   FALSE;
        }

        pdw = pRPDev->pdwColrSep;    /* Speedier access */

        if( pRPDev->fDump & RES_DM_GDI )
        {

           /*
            *  HP Paintjet type devices require separating the RGB pixels
            *  (2 per colour per byte) into bytes where the two bits for
            *  each color are consecutive.
            */
            for( i = 0; i <= 0xff; i++ )
            {
                u.dw[ 0 ] = 0;

                iShift = i;
                if (!(pRPDev->fColorFormat & DC_OEM_BLACK))
                {
                    //
                    // if required combine the RGB to CMY(K) conversion
                    //
                    if ( !(pRPDev->fColorFormat & DC_PRIMARY_RGB))
                    {
                        iShift = (~iShift) & 0x77;
                        if (pRPDev->fColorFormat & DC_EXTRACT_BLK)
                        {
                            if( (iShift & 0x07) == 0x07 )
                                iShift = (iShift & ~0x07) | 0x08;

                            if( (iShift & 0x70) == 0x70 )
                                iShift = (iShift & ~0x70) | 0x80;
                        }
                    }
                    else
                        iShift &= 0x77;
                }

                /*   The two bits Bb  */
                u.b[ 3 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));
                iShift >>= 1;


                /*   The two bits Gg  */
                u.b[ 2 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));
                iShift >>= 1;


                /*   The two bits Rr  */
                u.b[ 1 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));
                iShift >>= 1;


                /*   The two bits Kk  */
                u.b[ 0 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));

                *pdw++ = u.dw[ 0 ];             /* Safe for posterity */
            }
        }
        else
        {
            /*
             *   The dot matrix case.  Here we will call the relevant
             * transpose function,  but use the modified table below.  This
             * table will do the colour separation,  and will result in the
             * transpose operation splitting up the data for each head pass.
             */

            for( i = 0; i <= 0xff; i++ )
            {
                /*  Each bit of i goes into one byte of the output  */
                u.dw[ 0 ] = 0;
                u.dw[ 1 ] = 0;

                iShift = i;
                if (!(pRPDev->fColorFormat & DC_OEM_BLACK))
                {
                    //
                    // if required combine the RGB to CMY(K) conversion
                    //
                    if ( !(pRPDev->fColorFormat & DC_PRIMARY_RGB))
                    {
                        iShift = (~iShift) & 0x77;
                        if (pRPDev->fColorFormat & DC_EXTRACT_BLK)
                        {
                            if( (iShift & 0x07) == 0x07 )
                                iShift = (iShift & ~0x07) | 0x08;

                            if( (iShift & 0x70) == 0x70 )
                                iShift = (iShift & ~0x70) | 0x80;
                        }
                    }
                    else
                        iShift &= 0x77;
                }

                for( j = 8; --j >= 0; )
                {
                    u.b[ j ] = (BYTE)(iShift & 0x1);
                    iShift >>= 1;
                }

                /*   Store the result  */
                *pdw = u.dw[0];
                *(pdw+1) = u.dw[1];
                pdw += 2;
            }
        }
    }
    else
    {
        /*
         *   Monochrome case - simple transpositions.
         */

        for( i = 0; i <= 0xff; i++ )
        {
            /*  Each bit of i goes into one byte of the output  */
            iShift = i;
            u.dw[ 0 ] = 0;
            u.dw[ 1 ] = 0;

            for( j = 8; --j >= 0; )
            {
                u.b[ j ] = (BYTE)(iShift & 0x1);
                iShift >>= 1;
            }

            /*   Store the result  */
            *pdw = u.dw[0];
            *(pdw+1) = u.dw[1];
            pdw += 2;
        }
    }

    return  TRUE;
}

//*******************************************************
void
vTrans8x8 (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the input array into the output array,
    where the input data is to be considered 8 rows of bitmap data,
    and the output area is dword aligned.

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    The technique is quite simple,  though not necessarily obvious.
     *  Take an 8 scan line by 8 bits block of data,  and transform it
     *  into 8 bytes with bits in the scan line order,  rather than
     *  along the scan line as supplied.
     *    To do this as quickly as possible, each byte to be converted
     *  is used as an index into a lookup table;  each table entry is
     *  64 bits long (a pair of longs above).  These 64 bits are ORed
     *  with the running total of 64 bits (the two variables, dw0, dw1);
     *  shift the running total one bit left.  Repeat this operation
     *  for the corresponding byte in the next scan line - this is
     *  the new table lookup index.  Repeat for all 8 bytes in the 8
     *  scan lines being processed.  Store the 64 bit temporary results
     *  in the output dword array.  Move to the next byte in the
     *  scan line,  and repeat the loop for this column.
     */

    register  DWORD  dw0,  dw1;         /* Inner loop temporaries */
    register  BYTE  *pbTemp;
    register  DWORD *pdw;

    register  int    cbLine;            /* Bytes per line in scan data */
    register  int    i;                 /* Loop variable. */


    int      iWide;                     /* Pixels across the bitmap */
    DWORD   *pdwOut;                    /* Destination */
    DWORD   *pdwTrans;                  /* Local copy of output buffer */


    /*
     *   Some initialisation:  byte count,  area limits, etc.
     */


    cbLine = pRData->cbTLine;
    pdwOut = pRData->pvTransBuf;
    pdwTrans = pRData->Trans.pdwTransTab;

    if( pRData->iTransHigh != 8 )
    {
        /*  This can happen at the end of a page. */

        vTrans8N( pbIn,  pRData );

        return;
    }


    /*
     *   Scan across the lines in groups of 8 bits.  In the case that the
     *  input is not a multiple of 8,  we will produce a few extra
     *  bytes at the end;  the caller should allow for this when allocating
     *  storage for pdwOut.  The consequence is that the last few
     *  bytes will contain garbage; presumably the caller will not
     *  process them further.
     */

    for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
    {
        dw0 = 0;
        dw1 = 0;

        /*
         *   Loop DOWN the scanlines at the starting byte location,
         * generating the transposed data as we go.
         */

        for( i = BBITS, pbTemp = pbIn++; --i >= 0; pbTemp += cbLine )
        {
            dw0 <<= 1;
            dw1 <<= 1;
            pdw = pdwTrans + (*pbTemp << 1);
            dw0 |= *pdw;
            dw1 |= *(pdw + 1);
        }

        /*   Store the two temporary values in the output buffer. */
        *pdwOut = dw0;
        *(pdwOut + 1) = dw1;
        pdwOut += 2;
    }

    return;
}

//*******************************************************
void
vTrans8N (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the input array into the output array,
    where the input data is to be considered N rows of bitmap data,
    and the output area is byte aligned.

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    The technique is quite simple,  though not necessarily obvious.
     *  Take an 8 scan line by 8 bits block of data,  and transform it
     *  into 8 bytes with bits in the scan line order,  rather than
     *  along the scan line as supplied.
     *    To do this as quickly as possible, each byte to be converted
     *  is used as an index into a lookup table;  each table entry is
     *  64 bits long (a pair of longs above).  These 64 bits are ORed
     *  with the running total of 64 bits (the two variables, dw0, dw1);
     *  shift the running total one bit left.  Repeat this operation
     *  for the corresponding byte in the next scan line - this is
     *  the new table lookup index.  Repeat for all 8 bytes in the 8
     *  scan lines being processed.  Store the 64 bit temporary results
     *  in the output dword array.  Move to the next byte in the
     *  scan line,  and repeat the loop for this column.
     *    This function is based on the special 8 X 8 case (vTrans8x8).
     *  The significant differences are that the transposed data needs
     *  to be written byte at a time (instead of DWORD at a time),
     *  and that there are N scan lines to convert in each loop.
     */

    DWORD  dw0,  dw1;         /* Inner loop temporaries */
    BYTE  *pbTemp;
    DWORD *pdw;
    int    cbLine;            /* Bytes per line in scan data */
    int    i;                 /* Loop variable. */
    int    iBand;             /* For moving down the scan lines */

    int      iSkip;                     /* Output interleave factor */
    int      iWide;                     /* Pixels across the bitmap */

    BYTE    *pbOut;                     /* Destination, local copy */
    BYTE    *pbBase;                    /* Start addr of 8 scan line group */
    BYTE    *pbOutTmp;                  /* For output loop */

    DWORD   *pdwTrans;                  /* Speedier access */
    BOOL    bOptimize = FALSE;



    /*
     *   Set up the local variables from the RENDER structure passed in.
     */

    cbLine = pRData->cbTLine;
    iSkip = pRData->iTransSkip;
    pbOut = pRData->pvTransBuf;                 /* Reserved for us! */
    pdwTrans = pRData->Trans.pdwTransTab;

    // if the translation table isn't inverting bits and the rows are DWORD aligned
    // we can optimize the algorithm by initializing everything to white
    // and then skipping the rotation of 32x8 white areas.
    //
    if (pdwTrans[0] == 0 && !(cbLine & 3) && pRData->iPassHigh == 1)
    {
        bOptimize = TRUE;
        FillMemory (pbOut, pRData->iTransWide * iSkip, 0xff);
    }
    /*
     *     To ease MMU thrashing,  we scan ACROSS the bitmap in 8 line
     *  groups.  This results in closer memory references,  and so less
     *  page faults and so faster execution.  Hence,  the outer most loop
     *  loops DOWN the scanlines.  The next inner loop scans across groups
     *  of 8 scan lines at a time,  while the inner most loop transposes
     *  one byte by 8 scan lines of bitmap image.
     *     Note that processing the data this way causes a slight increase
     *  in scattered memory addresses when writing the output data.
     *  There is no way to avoid one or the other memory references being
     *  scattered;  however,  the output area is smaller than the input
     *  input,  so scattering here will be less severe to the MMU.
     */
    for( iBand = pRData->iTransHigh; iBand >= BBITS; iBand -= BBITS )
    {
        /*
         *    Have selected the next group of 8 scan lines to process,
         *  so scan from left to right,  transposing data in 8 x 8 bit
         *  groups.  This is the size that can be done very quickly with
         *  a 32 bit environment.
         */

        pbBase = pbIn;
        pbIn += BBITS * cbLine;         /* Next address */

        pbOutTmp = pbOut;
        ++pbOut;                /* Onto the next byte sequence */

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            //
            // White space optimization. If input data is white then
            // we don't have to output rotated data since the
            // output buffer is already initialized to white.
            //
            if (bOptimize)
            {
                // test whether we are dword aligned so we can check
                // 32x8 area for white
                if (!((ULONG_PTR)pbBase & 3) && iWide >= DWBITS)
                {
                    if (*(DWORD *)&pbBase[0] == -1 &&
                        *(DWORD *)&pbBase[cbLine] == -1 &&
                        *(DWORD *)&pbBase[cbLine*2] == -1 &&
                        *(DWORD *)&pbBase[cbLine*3] == -1 &&
                        *(DWORD *)&pbBase[cbLine*4] == -1 &&
                        *(DWORD *)&pbBase[cbLine*5] == -1 &&
                        *(DWORD *)&pbBase[cbLine*6] == -1 &&
                        *(DWORD *)&pbBase[cbLine*7] == -1)
                    {
                        pbBase += 4;
                        iWide -= BBITS * 3;
                        pbOutTmp += iSkip * DWBITS;
                        continue;
                    }
                }
                // check 8x8 area for white
                else
                {
                    if (pbBase[0] == (BYTE)-1 &&
                        pbBase[cbLine] == (BYTE)-1 &&
                        pbBase[cbLine*2] == (BYTE)-1 &&
                        pbBase[cbLine*3] == (BYTE)-1 &&
                        pbBase[cbLine*4] == (BYTE)-1 &&
                        pbBase[cbLine*5] == (BYTE)-1 &&
                        pbBase[cbLine*6] == (BYTE)-1 &&
                        pbBase[cbLine*7] == (BYTE)-1)
                    {
                        pbBase++;
                        pbOutTmp += iSkip * BBITS;
                        continue;
                    }
                }
            }
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 bit array.  We can do that quickly.
             */
            pbTemp = pbBase++;
            dw0 = 0;
            dw1 = 0;
            for( i = BBITS; --i >= 0; pbTemp += cbLine )
            {
                /*   The INNER loop - the bit swapping operations */
                dw0 <<= 1;
                dw1 <<= 1;
                pdw = pdwTrans + (*pbTemp << 1);
                dw0 |= *pdw;
                dw1 |= *(pdw + 1);
            }

            /*   Store the two temporary values in the output buffer. */
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            dw0 >>= BBITS;              /* One byte's worth */
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            dw0 >>= BBITS;
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            dw0 >>= BBITS;
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;
            dw1 >>= BBITS;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;
            dw1 >>= BBITS;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;
            dw1 >>= BBITS;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;  /* Next chunk of output data */
        }
    }

    /*
     *    There may be some scan lines remaining.  If so,  iBand will
     *  be > 0,  and that indicates the number of output scan lines
     *  remaining.
     */

    if( iBand > 0 )
    {

        /*
         *   This is basically the same as the stripped down version
         *  in the outer loop above.  Note that the output data is still
         *  byte aligned,  IT IS PRESUMED THAT THE 'MISSING' LINES ARE
         *  ZERO FILLED.  This may not be what is desired - it is for
         *  transposing bits to output to a dot matrix printer where
         *  the page length is not a multiple of the number of pins.
         *  I don't know if that can ever happen.
         */

        pbBase = pbIn;
        pbOutTmp = pbOut;

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 bit array.  We can do that quickly.
             */
            dw0 = 0;
            dw1 = 0;
            pbTemp = pbBase++;

            /*
             *    The inner loop now only transposes as many scan lines
             *  as the bitmap actually contains - we must not run off
             *  the end of memory.
             */

            for( i = iBand; --i >= 0; pbTemp += cbLine )
            {
                /*   The INNER loop - the bit swapping operations */
                dw0 <<= 1;
                dw1 <<= 1;
                pdw = pdwTrans + (*pbTemp << 1);
                dw0 |= *pdw;
                dw1 |= *(pdw + 1);

            }

            // white fill remaining bits
            //
            pdw = pdwTrans + (pRData->ubFillWhite << 1);
            i = BBITS - iBand;
            while (--i >= 0)
            {
                dw0 <<= 1;
                dw1 <<= 1;
                dw0 |= *pdw;
                dw1 |= *(pdw + 1);
            }

            /*   Store the two temporary values in the output buffer. */
            pbTemp = pbOutTmp;
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            dw0 >>= BBITS;              /* One byte's worth */
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            dw0 >>= BBITS;
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            dw0 >>= BBITS;
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            *pbTemp = (BYTE)dw1;

            pbTemp += iSkip;
            dw1 >>= BBITS;
            *pbTemp = (BYTE)dw1;

            pbTemp += iSkip;
            dw1 >>= BBITS;
            *pbTemp = (BYTE)dw1;

            pbTemp += iSkip;
            dw1 >>= BBITS;
            *pbTemp = (BYTE)dw1;

            pbOutTmp += BBITS * iSkip;  /* Next chunk of output data */
        }

    }

    return;
}


/*
 *   Define the number of pels transposed per loop iteration.  In the case
 * of a colour bitmap, this is 2,  since there are 4 bits per pel, thus
 * 2 per byte.
 */

#define PELS_PER_LOOP   (BBITS / 4)


//*******************************************************
void
vTrans8N4BPP (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the input array into the output array,
    where the input data is to be considered N rows of bitmap data,
    and the output area is byte aligned.
    This version works on 4 bits per pel bitmaps (colour for us).

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    The technique is quite simple,  though not necessarily obvious.
     *  Take an 8 scan line by 8 bits block of data,  and transform it
     *  into 8 bytes with bits in the scan line order,  rather than
     *  along the scan line as supplied.
     *    To do this as quickly as possible, each byte to be converted
     *  is used as an index into a lookup table;  each table entry is
     *  64 bits long (a pair of longs above).  These 64 bits are ORed
     *  with the running total of 64 bits (the two variables, dw0, dw1);
     *  shift the running total one bit left.  Repeat this operation
     *  for the corresponding byte in the next scan line - this is
     *  the new table lookup index.  Repeat for all 8 bytes in the 8
     *  scan lines being processed.  Store the 64 bit temporary results
     *  in the output dword array.  Move to the next byte in the
     *  scan line,  and repeat the loop for this column.
     *    This function is based on the special 8 X 8 case (vTrans8x8).
     *  The significant differences are that the transposed data needs
     *  to be written byte at a time (instead of DWORD at a time),
     *  and that there are N scan lines to convert in each loop.
     */

    register  DWORD  dw0,  dw1;         /* Inner loop temporaries */
    register  BYTE  *pbTemp;
    register  DWORD *pdw;

    register  int    cbLine;            /* Bytes per line in scan data */
    register  int    i;                 /* Loop variable. */
    register  int    iBand;             /* For moving down the scan lines */

    int      iSkip;                     /* Output interleave factor */
    int      iWide;                     /* Pixels across the bitmap */

    DWORD   *pdwOut;                    /* Destination, local copy */
    BYTE    *pbBase;                    /* Start addr of 8 scan line group */
    DWORD   *pdwOutTmp;                 /* For output loop */

    DWORD   *pdwTrans;                  /* Speedier access */


    /*
     *   Set up the local variables from the RENDER structure passed in.
     *  See the above function for explanation of iSkip.
     */

    cbLine = pRData->cbTLine;
    iSkip = pRData->iTransSkip / DWBYTES;
    pdwOut = pRData->pvTransBuf;                        /* Reserved for us! */
    pdwTrans = pRData->Trans.pdwTransTab;

    /*
     *     To ease MMU thrashing,  we scan ACROSS the bitmap in 8 line
     *  groups.  This results in closer memory references,  and so less
     *  page faults and faster execution.  Hence,  the outer most loop
     *  loops DOWN the scanlines.  Then next inner loop scans across groups
     *  of 8 scan lines at a time,  while the inner most loop transposes
     *  one byte by 8 scan lines of bitmap image.
     *     Note that processing the data this way causes a slight increase
     *  in scattered memory addresses when writing the output data.
     *  There is no way to avoid one or the other memory references being
     *  scattered;  however,  the output area is smaller than the input
     *  input,  so scattering here will be less severe on the MMU.
     */


    for( iBand = pRData->iTransHigh; iBand >= BBITS; iBand -= BBITS )
    {

        /*
         *    Have selected the next group of 8 scan lines to process,
         *  so scan from left to right,  transposing data in 8 x 8 bit
         *  groups.  This is the size that can be done very quickly with
         *  a 32 bit environment.
         */

        pbBase = pbIn;
        pbIn += BBITS * cbLine;         /* Next address */

        pdwOutTmp = pdwOut;
        ++pdwOut;               /* Onto the next byte sequence */

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 pixel array.  We can do that quickly.
             */

            pbTemp = pbBase++;

            dw0 = *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw0 |= *(pdwTrans + (*pbTemp << 1));
            pbTemp += cbLine;

            dw0 >>= 8;

            dw0 |= *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw0 |= *(pdwTrans + (*pbTemp << 1));
            pbTemp += cbLine;

            dw1 = *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw1 |= *(pdwTrans + (*pbTemp << 1));
            pbTemp += cbLine;

            dw1 >>= 8;

            dw1 |= *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw1 |= *(pdwTrans + (*pbTemp << 1));

            *(WORD *)pdwOutTmp = (WORD)dw0;
            *(((WORD *)pdwOutTmp)+1) = (WORD)dw1;
            *(pdwOutTmp+iSkip) = (dw1 & 0xffff0000) | (dw0 >> 16);
            pdwOutTmp += PELS_PER_LOOP * iSkip; /* Next chunk of output data */
        }

    }

    /*
     *    There may be some scan lines remaining.  If so,  iBand will
     *  be > 0,  and that indicates the number of output scan lines
     *  remaining.
     */

    if( iBand > 0 )
    {

        /*
         *   This is basically the same as the stripped down version
         *  in the outer loop above.  Note that the output data is still
         *  byte aligned,  IT IS PRESUMED THAT THE 'MISSING' LINES ARE
         *  ZERO FILLED.  This may not be what is desired - it is for
         *  transposing bits to output to a dot matrix printer where
         *  the page length is not a multiple of the number of pins.
         *  I don't know if that can ever happen.
         */

        pbBase = pbIn;
        pdwOutTmp = pdwOut;

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 bit array.  We can do that quickly.
             */
            pbTemp = pbBase++;

            dw0 = *(pdwTrans + 1 + (*pbTemp << 1));
            dw1 = 0;
            if (iBand > 1)
            {
                pbTemp += cbLine;
                dw0 |= *(pdwTrans + (*pbTemp << 1));
                dw0 >>= 8;
                if (iBand > 2)
                {
                    pbTemp += cbLine;
                    dw0 |= *(pdwTrans + 1 + (*pbTemp << 1));
                    if (iBand > 3)
                    {
                        pbTemp += cbLine;
                        dw0 |= *(pdwTrans + (*pbTemp << 1));
                        if (iBand > 4)
                        {
                            pbTemp += cbLine;
                            dw1 = *(pdwTrans + 1 + (*pbTemp << 1));
                            if (iBand > 5)
                            {
                                pbTemp += cbLine;
                                dw1 |= *(pdwTrans + (*pbTemp << 1));
                                dw1 >>= 8;
                                if (iBand > 6)
                                {
                                    pbTemp += cbLine;
                                    dw1 |= *(pdwTrans + 1 + (*pbTemp << 1));
                                }
                            }
                            else
                                dw1 >>= 8;
                        }
                    }
                }
            }
            else
                dw0 >>= 8;

            *(WORD *)pdwOutTmp = (WORD)dw0;
            *(((WORD *)pdwOutTmp)+1) = (WORD)dw1;
            *(pdwOutTmp+iSkip) = (dw1 & 0xffff0000) | (dw0 >> 16);

            pdwOutTmp += 2 * iSkip;     /* Next chunk of output data */
        }

    }

    return;
}

//*******************************************************
void
vTransColSep (
    register BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the colour bits in a 4 Bits Per Pel colour
    bitmap into an array of bytes,  where the bytes are ordered in
    the same way as the original bits.  An example of this is provided
    in the explanation for the SEP_TABLE_SIZE value at the top of this file.

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    Operation is quite simple - pass along the input array byte
     *  at a time,  and use each 4 byte group to generate a DWORD of
     *  output - placed in pdwOut.  The previously generated translation
     *  table is especially formulated to do this job!
     *
     *    NOTE:  pdwOut and pbIn MAY POINT TO THE SAME ADDRESS!  THERE IS
     *  NO OVERLAP IN OPERATIONS TO CAUSE CONFUSION.
     */

    register  DWORD   dwTemp;
    register  DWORD  *pdwSep;

    int      iI;
    int      iBlock;
    DWORD   *pdwOut;            /* Destination - DWORD aligned */
    DWORD   dwWhite;


    iBlock = pRData->cDWLine * pRData->iNumScans;

    pdwSep = pRData->pdwColrSep;                /* Colour separation table */
    pdwOut = pRData->pvTransBuf;                /* Where the data goes */


    /*   Loop through the line in 4 byte groups */

    //
    // calculate the white conversion value
    //
    dwWhite = *(pdwSep + 0x77);
    dwWhite |= (dwWhite << 2) | (dwWhite << 4) | (dwWhite << 6);

    //
    // convert the data to planar including RGB to CMY(K)
    //
    for (iI = iBlock; --iI >= 0;)
    {
        if (*(DWORD *)pbIn == 0x77777777L)
        {
            *pdwOut++ = dwWhite;
        }
        else
        {
            dwTemp = *(pdwSep + *pbIn);

            dwTemp <<= 2;
            dwTemp |= *(pdwSep + pbIn[1]);

            dwTemp <<= 2;
            dwTemp |= *(pdwSep + pbIn[2]);

            *pdwOut++ = (dwTemp << 2) | *(pdwSep + pbIn[3]);
        }
        pbIn += DWBYTES;
    }

    return;

}


//*******************************************************
void
vTrans8BPP (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    The transpose function for 8 bits per pel bitmaps.  This is rather
    easy, as all we do is shuffle bytes!

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{

    /*
     *    Scan along the input bitmap,  writing the data to the output
     *  in column order.  This results in reduced MMU thrashing, as
     *  the output addresses are all limited to a much smaller range
     *  than the incoming addresses.
     */

    register  BYTE   *pbBase;             /* Scan along input bitmap */
    register  BYTE   *pbOut;              /* The output scan column pointer */

    int     iBand;                 /* Count down scan lines */
    int     iSkip;                 /* Offset between output bytes */
    int     iWide;                 /* Loop across the input scan line */
    int     cbLine;                /* Bytes per input scan line */

    BYTE   *pbOutBase;             /* Start of column of output data */


    /*
     *   Set up the local copies (for faster access) of data passed in.
     */

    cbLine = pRData->cbTLine;
    iSkip = pRData->iTransSkip;
    pbOutBase = pRData->pvTransBuf;       /* Base output buffer address */


    for( iBand = pRData->iTransHigh; iBand > 0; --iBand )
    {
        /*
         *    This loop processes scan lines in the input bitmap. As
         *  we progress across the scan line, the output data is written
         *  in column order.
         */

        pbBase = pbIn;
        pbIn += cbLine;            /* Next scan line, DWORD aligned */

        pbOut = pbOutBase;
        ++pbOutBase;               /* One column across output area */

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *   This loop traverses the input scan line, taking bytes
             *  and writing them to the output area in column order.
             */

            *pbOut = *pbBase++;
            pbOut += iSkip;
        }
    }

    return;
}

//*******************************************************
void
vTrans24BPP (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    The transpose function for 8 bits per pel bitmaps.  This is rather
    easy, as all we do is shuffle bytes!

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    Scan along the input bitmap,  writing the data to the output
     *  in column order.  This results in reduced MMU thrashing, as
     *  the output addresses are all limited to a much smaller range
     *  than the incoming addresses.
     */

    register  BYTE   *pbBase;             /* Scan along input bitmap */
    register  BYTE   *pbOut;              /* The output scan column pointer */

    int     iBand;                 /* Count down scan lines */
    int     iSkip;                 /* Offset between output bytes */
    int     iWide;                 /* Loop across the input scan line */
    int     iCol;
    int     iRow;
    int     cbLine;                /* Bytes per input scan line */
    int     iBytesLeftOver;

    BYTE   *pbOutBase;             /* Start of column of output data */


    /*
     *   Set up the local copies (for faster access) of data passed in.
     */

    iSkip = pRData->iTransSkip;
    cbLine = pRData->cbTLine;
    pbOutBase = pRData->pvTransBuf;       /* Base output buffer address */
    iCol =  pRData->iTransWide/pRData->iBPP;
    iRow = pRData->iTransHigh;
    iBytesLeftOver = (pRData->iTransHigh *pRData->iBPP) % DWBITS;

    for( iBand = iRow; iBand > 0; --iBand )
    {
        /*
         *    This loop processes scan lines in the input bitmap. As
         *  we progress across the scan line, the output data is written
         *  in column order.
         */

        pbBase = pbIn;
        pbIn += cbLine;            /* Next scan line, DWORD aligned */

        pbOut = pbOutBase;
        pbOutBase+=3;               /* One column across output area */

        for( iWide = iCol; iWide > 0; --iWide )
        {
            /*
             *   This loop traverses the input scan line, taking bytes
             *  and writing them to the output area in column order.
             */
            *pbOut = *pbBase++;
            *(pbOut+1) = *pbBase++;
            *(pbOut+2) = *pbBase++;
            pbOut += iSkip;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\rules.c ===
/************************* Module Header ************************************
 * rules.c
 *      Functions to rummage over the final bitmap and replace black
 *      rectangular areas with rules.  The major benefit of this is
 *      to reduce the volume of data sent to the printer.  This speeds
 *      up printing by reducing the I/O bottleneck.
 *
 *      Strategy is based on Ron Murray's work for the PM PCL driver.
 *
 * CREATED:
 *  11:39 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *
 *  Copyright (C) 1991 - 1999,  Microsoft Corporation.
 *
 *****************************************************************************/

//#define _LH_DBG 1

#include "raster.h"
#include "rastproc.h"
#include "rmrender.h"

/*
 *   The structure that maps BYTES into DWORDS.
 */
typedef  union
{
    DWORD   dw;                 /* Data as a DWORD  */
    BYTE    b[ DWBYTES ];       /* Data as bytes */
}  UBDW;

/*
 *   The RULE structure stores details of the horizontal rules we have
 *  so far found.  Each rule contains the start address (top left corner)
 *  and end address (bottom right corner) of the area.
 */
typedef  struct
{
    WORD   wxOrg;               /* X origin of this rule */
    WORD   wyOrg;               /* Y origin */
    WORD   wxEnd;               /* X end of rule */
    WORD   wyEnd;               /* Y end of rule */
} RULE;

#define HRULE_MAX_OLD   15      /* Maximum horizontal rules per stripe */
#define HRULE_MAX_NEW   32      /* Maximum horizontal rules per stripe */
#define HRULE_MIN       2       /* Minimum DWORDs for a horizontal rule */
#define HRULE_MIN_HCNT  2       /* Minimum number of horizontal rules */

#define LJII_MAXHEIGHT  34      /* maximum height of laserjet II rules */
/*
 *   Other RonM determined data is:-
 *      34 scan lines per stripe
 *      14 null bytes between raster column operations
 *     112 raster rows maximum in raster column searching.
 *              The latter reduces the probability of error 21.
 */

/*
 *   Define the structure to hold the various pointers, tables, etc used
 * during the rule scanning operations.  The PDEV structure holds a pointer
 * to this,  to simplify access and freeing of the memory.
 */

typedef  struct
{
    int     iLines;             /*  Scan lines processed per pass */
    int     cdwLine;            /*  Dwords per scan line */
    int     iyPrtLine;          /*  Actual line number as printer sees it */

    int     ixScale;            /*  Scale factor for X variables */
    int     iyScale;            /*  Scale factor for Y */
    int     ixOffset;           /*  X Offset for landscape shift */
    int     iMaxRules;          /*  Maximum number of rules to allow per stripe */

    RENDER *pRData;             /*  Rendering info - useful everywhere */

                /*  Entries for finding vertical rules.  */
    DWORD  *pdwAccum;           /*  Bit accumulation this stripe */

                /*  Horizontal rule parameters.  */
    RULE    HRule[ HRULE_MAX_NEW ]; /*  Horizontal rule details */
    short  *pRTVert;            /*  Vertical run table */
    short  *pRTLast;            /*  Run table for the last line */
    short  *pRTCur;             /*  Current line run table */
    RULE  **ppRLast;            /*  Rule descriptor for the last scan line */
    RULE  **ppRCur;             /*  Current scan line rule details */

}  RULE_DATA;



#if _LH_DBG

/*  Useful for debugging purposes  */
#define NO_RULES        0x0001          /* Do not look for rules */
#define NO_SEND_RULES   0x0002          /* Do not transmit rules, but erase */
#define NO_SEND_HORZ    0x0004          /* Do not send horizontal rules */
#define NO_SEND_VERT    0x0008          /* Do not send vertical rules */
#define NO_CLEAR_HORZ   0x0010          /* Do not erase horizontal rules */
#define NO_CLEAR_VERT   0x0020          /* Do not erase vertical rules */
#define RULE_VERBOSE    0x0040          /* Print rule dimensions */
#define RULE_STRIPE     0x0080          /* Draw a rule at the end of stripe */
#define RULE_BREAK      0x0100          /* Enter debugger at init time */

static  int  _lh_flags = 0;

#endif

/*  Private function headers  */

static  void vSendRule( PDEV *, int, int, int, int );


/*************************** Module Header ********************************
 * vRuleInit
 *      Called at the beginning of rendering a bitmap.  Function allocates
 *      storage and initialises it for later.  Storage is only allocated
 *      as needed.  Second and later calls will only initialise the
 *      previously allocated storage.
 *
 * RETURNS:
 *      Nothing
 *
 * HISTORY:
 *  13:20 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  based on Ron Murray's ideas.
 *
 **************************************************************************/

void
vRuleInit( pPDev, pRData )
PDEV   *pPDev;          /* Record the info we want */
RENDER *pRData;         /* Useful rendering info */
{

    int    cbLine;              /*  Byte count per scan line */
    int    cdwLine;             /*  DWORDs per scan line - often used */
    int    iI;                  /*  Loop parameter  */

    RULE_DATA  *pRD;
    RASTERPDEV    *pRPDev;        /* For access to scaling information */


    if( pRData->iBPP != 1 )
        return;                 /* Can't handle colour */

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    /*
     *    Calculate the size of the input scan lines.  We do this because
     *  we need to consider whether we rotate or not;  the information in
     *  the RENDER structure passed in does not consider this until later.
     */

//    cdwLine = pPDev->fMode & PF_ROTATE ? pRPDev->szlPage.cy :
//                                          pRPDev->szlPage.cx;
    cdwLine = pPDev->fMode & PF_ROTATE ? pPDev->sf.szImageAreaG.cy :
                                         pPDev->sf.szImageAreaG.cx;
    cdwLine = (cdwLine + DWBITS - 1) / DWBITS;
    cbLine = cdwLine * DWBYTES;



    if( pRD = pRPDev->pRuleData )
    {
        /*
         *    This can happen if the document switches from  landscape
         *  to portrait,  for example.   The code in vRuleFree will
         *  throw away all out memory and then set the pointer to NULL,
         *  so that we allocate anew later on.
         */

        if( (int)pRD->cdwLine != cdwLine )
            vRuleFree( pPDev );                 /*  Free it all up! */
    }

    /*
     *   First step is to allocate a RULE_DATA structure from our heap.
     *  Then we can allocate the other data areas in it.
     */

    if( (pRD = pRPDev->pRuleData) == NULL )
    {
        /*
         *   Nothing exists,  so first step is to allocate it all.
         */
        if( !(pRD = (RULE_DATA *)MemAllocZ(sizeof( RULE_DATA ) )) )
            return;


        pRPDev->pRuleData = pRD;

        /*
         *    Allocate storage for the vertical rule finding code.
         */
        if( !(pRD->pdwAccum = (DWORD *)MemAllocZ( cbLine )) )
        {

            vRuleFree( pPDev );

            return;
        }
#ifndef DISABLE_HRULES
        /*
         *    Allocate storage for the horizontal rule finding code.
         */
        if (pRPDev->fRMode & PFR_RECT_HORIZFILL)
        {
            iI = cdwLine * sizeof( short );

            if( !(pRD->pRTVert = (short *)MemAlloc( iI )) ||
                !(pRD->pRTLast = (short *)MemAlloc( iI )) ||
                !(pRD->pRTCur = (short *)MemAlloc( iI )) )
            {

                vRuleFree( pPDev );

                return;
            }

            /*
             *   Storage for the horizontal rule descriptors.  These are pointers
             *  to the array stored in the RULE_DATA structure.
            */

            iI = cdwLine * sizeof( RULE * );

            if( !(pRD->ppRLast = (RULE **)MemAlloc( iI )) ||
                !(pRD->ppRCur = (RULE **)MemAlloc( iI )) )
            {

                vRuleFree( pPDev );

                return;
            }
        }
#endif
    }
    // determine maximum number of rules to allow, we allow more for
    // FE_RLE since we know these devices can handle the additional rules
    //
    if (pRPDev->fRMode & PFR_COMP_FERLE)
        pRD->iMaxRules = HRULE_MAX_NEW;
    else
    {
        pRD->iMaxRules = HRULE_MAX_OLD;
        if (pRPDev->fRMode & PFR_RECT_HORIZFILL)
            pRD->iMaxRules -= HRULE_MIN_HCNT;
    }

    /*
     *   Storage now available,  so initialise the bit vectors, etc.
     */

    if (pPDev->ptGrxRes.y >= 1200)
        pRD->iLines = 128;
    else if (pPDev->ptGrxRes.y >= 600)
        pRD->iLines = 64;
    else
        pRD->iLines = LJII_MAXHEIGHT;   // optimized for laserjet series II

    pRD->cdwLine = cdwLine;

    pRD->pRData = pRData;       /* For convenience */

    pRD->ixScale = pPDev->ptGrxScale.x;
    pRD->iyScale = pPDev->ptGrxScale.y;

    if ((pPDev->fMode & PF_CCW_ROTATE90) &&
        pPDev->ptDeviceFac.x < pPDev->ptGrxScale.x &&
        pPDev->ptDeviceFac.x > 0)
    {
        pRD->ixOffset = pPDev->ptGrxScale.x - 1;
    }
    else
        pRD->ixOffset = 0;
    return;
}


/************************** Module Header **********************************
 * vRuleFree
 *      Frees the storage allocated in vRuleInit.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  13:24 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created.
 *
 ***************************************************************************/

void
vRuleFree( pPDev )
PDEV   *pPDev;          /* Points to our storage areas */
{
    RULE_DATA  *pRD;
    RASTERPDEV *pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    if( pRD = pRPDev->pRuleData )
    {

        /*  Storage allocated,  so free it  */

        if( pRD->pdwAccum )
            MemFree( (LPSTR)pRD->pdwAccum );
        if( pRD->pRTVert )
            MemFree( (LPSTR)pRD->pRTVert );
        if( pRD->pRTLast )
            MemFree( (LPSTR)pRD->pRTLast );
        if( pRD->pRTCur )
            MemFree( (LPSTR)pRD->pRTCur );

        if( pRD->ppRLast )
            MemFree( (LPSTR)pRD->ppRLast );
        if( pRD->ppRCur )
            MemFree( (LPSTR)pRD->ppRCur );

        MemFree (pRD);
        pRPDev->pRuleData = 0;           /* Not there now that it's gone! */
    }
    return;
}

/**************************** Module Header ********************************
 * vRuleProc
 *      Function to find the rules in a bitmap stripe,  then to send them
 *      to the printer and erase them from the bitmap.
 *
 *  This function has been optimized to combine invertion and whitespace
 *  edge detection into a single pass.  Refer to the comments in bRender
 *  for a description.
 *
 *  Future optimizations include:
 *      call the output routines for each 34 scan band as the
 *      band is done with rule detection. (while it's still in the cache).
 *
 *      For various reasons, mainly due to the limitations of the ,
 *      HP LaserJet Series II, the maximum number of rules is limited to
 *      15 per 34 scan band and no coalescing is performed.  This should
 *      be made to be a per printer parameter so that the newer laserjets
 *      don't need to deal with this limitation.
 *
 *      The rules should be coalesced between bands.  I believe this can
 *      cause problems, however, for the LaserJet Series II.
 *
 *      If the printer supports compression (HP LaserJet III and on I believe)
 *      no hrules should be detected (according to info from LindsayH).
 *
 * RETURNS:
 *      Nothing.  Failure is benign.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *
 *  13:29 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  from Ron Murray's PM PCL driver ideas.
 *
 ****************************************************************************/

// given a bit index 0 - 31, this table gives a mask to see if the bit is on
// in a DWORD.

DWORD gdwBitOn[DWBITS] =
{
    0x00000080,
    0x00000040,
    0x00000020,
    0x00000010,
    0x00000008,
    0x00000004,
    0x00000002,
    0x00000001,

    0x00008000,
    0x00004000,
    0x00002000,
    0x00001000,
    0x00000800,
    0x00000400,
    0x00000200,
    0x00000100,

    0x00800000,
    0x00400000,
    0x00200000,
    0x00100000,
    0x00080000,
    0x00040000,
    0x00020000,
    0x00010000,

    0x80000000,
    0x40000000,
    0x20000000,
    0x10000000,
    0x08000000,
    0x04000000,
    0x02000000,
    0x01000000
};

// given a bit index from 1 - 31, this table gives all bits right of that index
// in a DWORD.

DWORD gdwBitMask[DWBITS] =
{
    0xffffff7f,
    0xffffff3f,
    0xffffff1f,
    0xffffff0f,
    0xffffff07,
    0xffffff03,
    0xffffff01,
    0xffffff00,

    0xffff7f00,
    0xffff3f00,
    0xffff1f00,
    0xffff0f00,
    0xffff0700,
    0xffff0300,
    0xffff0100,
    0xffff0000,

    0xff7f0000,
    0xff3f0000,
    0xff1f0000,
    0xff0f0000,
    0xff070000,
    0xff030000,
    0xff010000,
    0xff000000,

    0x7f000000,
    0x3f000000,
    0x1f000000,
    0x0f000000,
    0x07000000,
    0x03000000,
    0x01000000,
    0x00000000,
};

#if DBG
BOOL gbDoRules  = 1;
#endif

BOOL
bRuleProc( pPDev, pRData, pdwBits )
PDEV     *pPDev;                /* All we wanted to know */
RENDER   *pRData;               /* All critical rendering information */
DWORD    *pdwBits;              /* The base of the data area. */
{

    register  DWORD  *pdwOr;   /* Steps through the accumulation array */
    register  DWORD  *pdwIn;    /* Passing over input vector */
    register  int     iIReg;    /* Inner loop parameter */

    int   i;
    int   iI;           /* Loop parameter */
    int   iLim;         /* Loop limit */
    int   iLine;        /* The outer loop */
    int   iLast;        /* Remember the previous horizontal segment */
    int   cdwLine;      /* DWORDS per scan line */
    int   idwLine;      /* SIGNED dwords per line - for address fiddling */
    int   iILAdv;       /* Line number increment,  scan line to scan line */
    int   ixOrg;        /* X origin of this rule */
    int   iyPrtLine;    /* Line number, as printer sees it.  */
    int   iyEnd;        /* Last scan line this stripe */
    int   iy1Short;     /* Number of scan lines minus 1 - LJ bug?? */
    int   iLen;         /* Length of horizontal run */
    int   cHRules;      /* Count of horizontal rules in this stripe */
    int   cRuleLim;     /* Max rules allowed per stripe */

    DWORD dwMask;       /* Chop off trailing bits on bitmap */

    RULE_DATA  *pRD;    /* The important data */
    RASTERPDEV *pRPDev; // pointer to raster pdev
    BYTE       *pbRasterScanBuf; // pointer to surface block status

    PLEFTRIGHT plrCur;  /* left/right structure for current row */
    PLEFTRIGHT plr = pRData->plrWhite; /* always points to the top of the segment */

#if _LH_DBG
    if( _lh_flags & NO_RULES )
        return(FALSE);                 /* Nothing wanted here */
#endif

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;
    if( !(pRD = pRPDev->pRuleData) )
        return(FALSE);                 /*  Initialisation failed */

    if( pRD->cdwLine != pRData->cDWLine )
    {
        /*
         *   This code detects the case where vRuleInit() was called with
         * the printer set for landscape mode, and then we are called here
         * after the transpose and so are (effectively) in portrait mode.
         * If the old parameters are used,  heap corruption will occur!
         * This should not be necessary, as we ought to call vRuleInit()
         * at the correct time, but that means hacking into the rendering
         * code.
         */

#if DBG
        DbgPrint( "unidrv!bRuleProc: cdwLine differs: old = %ld, new = %ld\n",
                                 pRD->cdwLine, pRData->cDWLine );

#endif
        vRuleFree( pPDev );
        vRuleInit( pPDev, pRData );

        if( !(pRD = pRPDev->pRuleData) )
        {
            return(FALSE);
        }
    }


    idwLine = cdwLine = pRData->cDWLine;
    iILAdv = 1;
    if( pRData->iPosnAdv < 0 )
    {
        idwLine = -idwLine;
        iILAdv = -1;
    }

    iyPrtLine = pRD->iyPrtLine = pRData->iyPrtLine;

    dwMask = *(pRPDev->pdwBitMask + pRData->ix % DWBITS);
    if( dwMask == 0 )
        dwMask = ~((DWORD)0);           /* All bits are in use */

    /*
     *  setup the left/right structure.  If we can not allocate enough memory
     *  free the rule structure and return failure.
     */

    if ((plr == NULL) || ((int)pRData->clr < pRData->iy))
    {
        if (plr != NULL)
            MemFree(plr);

        pRData->plrWhite = (PLEFTRIGHT)MemAlloc(sizeof(LEFTRIGHT)*pRData->iy);

        if (pRData->plrWhite == NULL)
        {
            vRuleFree( pPDev );
            return(FALSE);
        }

        plr = pRData->plrWhite;
        pRData->clr = pRData->iy;
    }
    //
    // Determine if block erasing of the bitmap is enabled
    //
    if (!(pPDev->fMode & PF_SURFACE_ERASED))
        pbRasterScanBuf = pPDev->pbRasterScanBuf;
    else
        pbRasterScanBuf = NULL;


    /*
     *    Outer loop processes through the bitmap in chunks of iLine,
     *  the number of lines we like to process in one pass.  iLine is
     *  the basic vertical granularity for vertical rule finding.
     *  Any line less than iLines high will NOT be detected by this
     *  mechanism.
     */

    /*
     *   NOTE:  iy1Short is used to bypass what appears to be a bug in
     *  the LaserJet Series II microcode.  It does not print a rule on
     *  the last scan line of a portrait page.  SO,  we stop scanning
     *  on the second last line,  and so will send any data here.  It
     *  will be transmitted as normal scan line data.
     *
     *  We also need to setup the left/right table for the last scan
     *  and invert it.
     */
    if (pRD->iLines == LJII_MAXHEIGHT)
    {
        iy1Short = pRData->iy - 1;          /* Bottom line not printed! */

        plr[iy1Short].left  = 1;            /* assume last row  blank  */
        plr[iy1Short].right = 0;

        if (!pbRasterScanBuf || pbRasterScanBuf[iy1Short / LINESPERBLOCK])
        {
            pdwIn = pdwBits + idwLine * iy1Short;
            pdwIn[cdwLine-1] |= ~dwMask;    // make unused bits white
            for (i = 0; i < cdwLine; ++i, pdwIn++)
            {
                *pdwIn = ~*pdwIn;
                if(*pdwIn  &&  plr[iy1Short].left)
                {
                    plr[iy1Short].left  = 0;            /*  last row not blank*/
                    plr[iy1Short].right = cdwLine - 1;
                }
            }
        }
    }
    else
        iy1Short = pRData->iy;

    //
    // This is the main loop for rules. It processes iLim scan lines per
    // pass looking for vertical rules of that height. Hozizontal rules
    // are created where no vertical rules have occurred.
    //
    //  NOTE:  iLim is initialised inside the loop!

    for( iLine = 0; iLine < iy1Short; iLine += iLim )
    {
        BOOL bAllWhite = TRUE;

        DWORD  *pdw;
        int left,right;     /* bounds for verticle rules */

        iLim = iy1Short - iLine;
        if( iLim >= 2 * pRD->iLines )
            iLim = pRD->iLines;         /* Limit to nominal band size */

        //
        //  Fill in the left/right structure with the values of the first
        //  nonwhite dword for each scan line.  The bits have still not
        //  been inverted at this point.  So 0's are black and 1's are
        //  white.
        //

        pdw   = pdwBits;
        left  = 0;
        right = cdwLine-1;

        for (iI = 0, plrCur = plr; iI < iLim; plrCur++, ++iI)
        {
            // if surface block erasing is enabled check for blank block
            //
            if (pbRasterScanBuf && !pbRasterScanBuf[(iLine+iI) / LINESPERBLOCK])
            {
                plrCur->left  = 1;            /* assume last row  blank  */
                plrCur->right = 0;
            }
            // this scan line was erased so need to check if still white
            //
            else
            {
                DWORD *pdwLast = &pdw[cdwLine-1];       // pointer to last dword
                DWORD dwOld    = *pdwLast | ~dwMask;    // make unused bits white

                // find the first non white DWORD in this scan line
                // we set the last DWORD to black so we don't have
                // to test for the end of line

                *pdwLast = 0;           // set last dword temporarily to black
                pdwIn = pdw;

                while (*pdwIn == (DWORD)-1)
                    ++pdwIn;

                *pdwLast = dwOld;       // restore original value

                /*
                *  find the last non white DWORD.  If the last dword is white,
                *  see if pdwIn reached the end of the scan.  If not, work
                *  backwards with pdwLast.
                */
                if (dwOld == (DWORD)-1)
                {
                    if (pdwIn < pdwLast)
                    {
                        do {
                            pdwLast--;
                        } while (*pdwLast == (DWORD)-1);
                    }
                    else
                        pdwLast--;
                }
                // update the per row and per segment left and right dword indexes

                plrCur->left  = (WORD)(pdwIn - pdw);
                plrCur->right = (WORD)(pdwLast - pdw);
            }
            // Adjust the overall left and right margin for blank space
            // If any dword is zero within this pass no vertical rules
            // can be found, so we want to avoid looking
            //
            if (plrCur->left > left)
                left = plrCur->left;

            if (plrCur->right < right)
                right = plrCur->right;

            // turn off bAllWhite if any black was found
            //

            bAllWhite &= (plrCur->left > plrCur->right);

            pdw += idwLine;
        }


        // non-white pass so lets look for rules
        //
        if (!bAllWhite)
        {
            // Initialize the accumulation array to all 1's (white)
            // to begin searching for vertical rules.

            RtlFillMemory(pRD->pdwAccum, cdwLine * DWBYTES,-1);

    #if DBG
        if (gbDoRules)
        {
    #endif
            cRuleLim = pRD->iMaxRules;           /* Rule limit for this stripe */

            // if any scan line in this pass was all white there won't
            // be any vertical rules to find.
            //
            if (left <= right)
            {
                int cdw;
                int iBit;
                int iWhite;

                // vertical rules are found by or'ing together all the
                // scan lines in this pass. Wherever a 0 bit still exists
                // designates a vertical black line the height of the pass
                // This is where we or the scan lines together

                /*   Set the accumulation array to the first scan  */

                pdw = pdwBits + left;
                cdw = right - left + 1;

                memcpy(pRD->pdwAccum + left , pdw, cdw * DWBYTES);

                /*
                 *   Scan across the bitmap - fewer page faults in mmu.
                 */

                for( iI = 1; iI < iLim; ++iI )
                {
                    pdw   += idwLine;
                    pdwIn  = pdw;
                    pdwOr  = pRD->pdwAccum + left;
                    //
                    // or 4 dwords at a time for speed
                    //
                    iIReg = cdw >> 2;

                    while(--iIReg >= 0)
                    {
                        pdwOr[0] |= pdwIn[0];
                        pdwOr[1] |= pdwIn[1];
                        pdwOr[2] |= pdwIn[2];
                        pdwOr[3] |= pdwIn[3];
                        pdwOr += 4;
                        pdwIn += 4;
                    }
                    //
                    // or remaining dwords
                    //
                    iIReg = cdw & 3;
                    while (--iIReg >= 0)
                        *pdwOr++ |= *pdwIn++;
                }

                /*
                 *   Can now determine what happened in this band.  First step is
                 *  to figure out which rules started in this band.  Any 0 bit
                 *  in the output array corresponds to a rule extending the whole
                 *  band.  If the corresponding bit in the pdwAccum array
                 *  is NOT set, then we record the rule as starting in the
                 *  first row of this stripe.
                 */

                iyEnd = iyPrtLine + (iLim - 1) * iILAdv;                /* Last line */

                iWhite = DWBITS;
                for( iI = left, iBit = 0; iI <= right;)
                {
                    DWORD dwTemp;
                    int ixEnd;

                    // we can skip any dword that is all 1's (white)
                    //
                    if((iBit == 0) && ((dwTemp = pRD->pdwAccum[ iI ]) == (DWORD)-1) )
                    {
                        iWhite += DWBITS;
                        ++iI;
                        continue;
                    }

                    /* find the first black bit */
                    iWhite -= iBit;
                    while (dwTemp & gdwBitOn[iBit])
                        ++iBit;

                    iWhite += iBit;

                    /* set the origin     */

                    ixOrg = iI * DWBITS + iBit;

                    // find the length by looking for first white bit
                    //
                    do
                    {
                        if (++iBit == DWBITS)
                        {
                            iBit = 0;

                            if (++iI > right)
                            {
                                dwTemp = (DWORD)-1;
                                break;
                            }

                            dwTemp = pRD->pdwAccum[ iI ];
                        }
                    } while (!(dwTemp & gdwBitOn[iBit]));
#ifndef OLDSTUFF
                    //
                    // Now that we have found a rule we need to determine
                    // whether it is worthwhile to actually use it. If the rule won't
                    // result in at least 4 white bytes and we just had another rule
                    // we will skip it. If we are in rapidly changing data with data runs
                    // of less than 4 bytes then this isn't of any benefit
                    //
                    ixEnd = iI * DWBITS + iBit;
                    if ((iWhite < 16) && (((ixEnd & ~7) - ixOrg) < 32))
                    {
                        int iCnt;
                        for (iCnt = ixOrg;iCnt < ixEnd;iCnt++)
                             pRD->pdwAccum[iCnt / DWBITS] |= gdwBitOn[iCnt & 31];
                    }
                    // save this rule if there is enough space
                    //
                    else if (cRuleLim)
                    {
                        cRuleLim--;
                        pRD->HRule[cRuleLim].wxOrg = (WORD)ixOrg;
                        pRD->HRule[cRuleLim].wxEnd = (WORD)ixEnd;
                    }
                    // too many rules so look for a smaller one
                    //
                    else
                    {
                        WORD wDx1,wDx2;
                        int iCnt,iIndex;
                        wDx1 = MAX_WORD;
                        iCnt = pRD->iMaxRules;
                        iIndex = 0;
                        while (iCnt)
                        {
                            iCnt--;
                            wDx2 = pRD->HRule[iCnt].wxEnd - pRD->HRule[iCnt].wxOrg;
                            if (wDx2 < wDx1)
                            {
                                wDx1 = wDx2;
                                iIndex = iCnt;
                            }
                        }
                        wDx2 = ixEnd - ixOrg;

                        // if this is a bigger rule, substitute
                        // for the smallest earlier rule
                        if (wDx2 > wDx1)
                        {
                            // clear original rule
                            for (iCnt = pRD->HRule[iIndex].wxOrg;iCnt < pRD->HRule[iIndex].wxEnd;iCnt++)
                                pRD->pdwAccum[iCnt / DWBITS] |= gdwBitOn[iCnt & 31];

                            // update to new values
                            pRD->HRule[iIndex].wxEnd = (WORD)ixEnd;
                            pRD->HRule[iIndex].wxOrg = (WORD)ixOrg;
                        }
                        // new rule is too small so flush it
                        //
                        else
                        {
                            for (iCnt = ixOrg;iCnt < ixEnd;iCnt++)
                                pRD->pdwAccum[iCnt / DWBITS] |= gdwBitOn[iCnt & 31];
                        }
                    }

                    /* check if there are any remaining black bits in this DWORD */

                    if (!(gdwBitMask[iBit] & ~dwTemp))
                    {
                        iWhite = DWBITS - iBit;
                        ++iI;
                        iBit = 0;
                    }
                    else
                        iWhite = 0;
                }
                //
                // OK, time to output the rules
                iI = pRD->iMaxRules;
                while ( iI > cRuleLim)
                {
                    iI--;
                    vSendRule( pPDev, pRD->HRule[iI].wxOrg,iyPrtLine,pRD->HRule[iI].wxEnd-1,iyEnd);
                    pRD->HRule[iI].wxOrg = pRD->HRule[iI].wxEnd = 0;
                }
#else
                #if _LH_DBG
                    if( !(_lh_flags & NO_SEND_VERT) )
                #endif

                    //
                    vSendRule( pPDev, ixOrg, iyPrtLine, iI * DWBITS + iBit - 1, iyEnd );

                    /* check if there are any remaining black bits in this DWORD */

                    if (!(gdwBitMask[iBit] & ~dwTemp))
                    {
                        ++iI;
                        iBit = 0;
                    }

                    // quit looking if we've created the maximum number of rules
                    if (--cRuleLim == 0)
                        break;
                }

                /*
                 *  if we ended due to too many rules, zap any remaining bits.
                 */

                if ((cRuleLim == 0) && (iI <= right))
                {
                    /* make accum bits white */

                    if (iBit > 0)
                    {
                        pRD->pdwAccum[iI] |= gdwBitMask[iBit];
                        ++iI;
                    }

                    RtlFillMemory((PVOID)&pRD->pdwAccum[iI],(right - iI + 1) * DWBYTES,-1);
                }
#endif
            }
#ifndef DISABLE_HRULES
            // first check whether to bother with HRULES
            // if we didn't allocate a buffer then that means
            // we don't want them to run
            if (pRD->pRTVert)
            {
               /*
                *    Horizontal rules.  We scan on DWORDs.  These are rather
                *  coarse,  but seem reasonable for a first pass operation.
                *
                *    Step 1 is to find any VERTICAL rules that will pass the
                *  horizontal test.  This allows us to filter vertical rules
                *  from the horizontal data - we don't want to send them twice!
                */
                ZeroMemory( pRD->pRTVert, cdwLine * sizeof( short ) );

                for( iI = left, pdwIn = pRD->pdwAccum + left; iI <= right; ++iI, ++pdwIn )
                {
                    if (*pdwIn != 0)
                        continue;

                    ixOrg = iI;

                    /* find a run of black */

                    do {
                        ++iI;
                        ++pdwIn;
                    } while ((iI <= right) && (*pdwIn == 0));

                    pRD->pRTVert[ixOrg] = (short)(iI - ixOrg);
                }


                /*
                 *   Start scanning this stripe for horizontal runs.
                 */

                if (pRD->iMaxRules >= (cRuleLim + HRULE_MIN_HCNT))
                    cRuleLim += HRULE_MIN_HCNT;

                cHRules = 0;    /* Number of horizontal rules found */
                ZeroMemory( pRD->pRTLast, cdwLine * sizeof( short ) );

                for (iI = 0; (iI < iLim) && (cHRules < cRuleLim); ++iI, iyPrtLine += iILAdv)
                {
                    int iDW;
                    int iFirst;
                    PVOID pv;

                    plrCur = plr + iI;

                    pdwIn = pdwBits + iI * idwLine;
                    iLast = -1;

                    ZeroMemory( pRD->pRTCur, cdwLine * sizeof( short ) );
                    ZeroMemory( pRD->ppRCur, cdwLine * sizeof( RULE *) );

                    for (iDW = plrCur->left; iDW < plrCur->right;++iDW)
                    {
                        /* is this the start of a verticle rule already? */

                        if (pRD->pRTVert[iDW])
                        {
                            /* skip over any verticle rules */

                            iDW += (pRD->pRTVert[iDW] - 1);
                            continue;
                        }

                        /* are there at least two consecutive DWORDS of black */

                        if ((pdwIn[iDW] != 0) || (pdwIn[iDW+1] != 0))
                        {
                            continue;
                        }

                        /* yes, see how many.  Already got two. */

                        ixOrg = iDW;
                        iDW += 2;

                        while ((iDW <= plrCur->right) && (pdwIn[iDW] == 0))
                        {
                            ++iDW;
                        }

                        /*
                         *  now remember the run, setting second short of the
                         *  previous run to the start of this and first short
                         *  of this run to its size.  Note for the first run
                         *  iLast will be -1, so the offset of the first run
                         *  will be a negative value in pRTCur[0].  If the first
                         *  run starts at offset 0, pRTCur[0] will be positive
                         *  and the offset is not needed.
                         */

                        iLen = iDW - ixOrg;

                        pRD->pRTCur[iLast + 1] = -(short)ixOrg;
                        pRD->pRTCur[ixOrg] = (short)iLen;

                        iLast = ixOrg;
                    }

                    /*
                     *  Process the segments found along this scanline.  Processing
                     *  means either adding to an existing rule,  or creating a
                     *  new rule, with possible termination of an existing one.
                     */

                    iFirst = -pRD->pRTCur[0];

                    if( iFirst != 0 )
                    {
                        /*
                         *  if the pRTCur[0] is positive, the first scan starts
                         *  at 0 and the first value is a length.  Note it
                         *  has already been negated so we check for negative.
                         */

                        if (iFirst < 0)
                            iFirst = 0;

                        /*
                         *   Found something,  so process it.  Note that the
                         * following loop should be executed at least once, since
                         * iFirst may be 0 the first time through the loop.
                         */

                        pdwIn = pdwBits + iI * idwLine; /* Line start address */

                        do
                        {
                            RULE *pRule;

                            if( pRD->pRTLast[ iFirst ] != pRD->pRTCur[ iFirst ] )
                            {
                                /*  A new rule - create an entry for it  */
                                if( cHRules < cRuleLim )
                                {
                                    pRule = &pRD->HRule[ cHRules ];
                                    ++cHRules;

                                    pRule->wxOrg = (WORD)iFirst;
                                    pRule->wxEnd = (WORD)(iFirst + pRD->pRTCur[ iFirst ]);
                                    pRule->wyOrg = (WORD)iyPrtLine;
                                    pRule->wyEnd = pRule->wyOrg;

                                    pRD->ppRCur[ iFirst ] = pRule;
                                }
                                else
                                {
                                    pRD->pRTCur[ iFirst ] = 0;   /* NO zapping */
                                }
                            }
                            else
                            {
                                /*   An extension of an earlier rule  */
                                pRule = pRD->ppRLast[ iFirst ];
                                if( pRule )
                                {
                                    /*
                                     *   Note that the above if() should not be
                                     * needed,  but there have been occasions when
                                     * this code has been executed with pRule = 0,
                                     * which causes all sorts of unpleasantness.
                                     */

                                    pRule->wyEnd = (WORD)iyPrtLine;
                                    pRD->ppRCur[ iFirst ] = pRule;
                                }
                            }

                            //  Zap the bits for this horizontal rule.
                            //
                                if( (ixOrg = pRD->pRTCur[ iFirst ]) > 0 )
                            {
                                pdwOr = pdwIn + iFirst; /* Start address of data */

                                while( --ixOrg >= 0 )
                                    *pdwOr++ = (DWORD)-1;              /* Zap them */
                            }

                        } while(iFirst = -pRD->pRTCur[ iFirst + 1 ]);
                    }

                    pv = pRD->pRTLast;
                    pRD->pRTLast = pRD->pRTCur;
                    pRD->pRTCur = pv;

                    pv = pRD->ppRLast;
                    pRD->ppRLast = pRD->ppRCur;
                    pRD->ppRCur = pv;

                } // for iI

                /*
                 *   Can now send the horizontal rules,  since we have all that
                 *  are of interest.
                 */

                for( iI = 0; iI < cHRules; ++iI )
                {
                    RULE   *pRule = &pRD->HRule[ iI ];

                    vSendRule( pPDev, DWBITS * pRule->wxOrg, pRule->wyOrg,
                                    DWBITS * pRule->wxEnd - 1, pRule->wyEnd );
                }
            }
#endif  // DISABLE_HRULES
    #if DBG // gbDoRules
        }
    #endif


            // At this point we need to remove the vertical rules that
            // have been sent a scan line at a time. This is done by ANDing
            // with the complement of the bit array pdwAccum.
            // It is also at this point that we do the data inversion where
            // 0 will be white instead of 1.

            pdwOr  = pRD->pdwAccum;
            pdwIn  = pdwBits;
            plrCur = plr;

            for (iI = 0;iI < iLim; iI++)
            {
                int iCnt = plrCur->right - plrCur->left + 1;
                if (iCnt > 0)
                {
                    DWORD *pdwTmp = &pdwIn[plrCur->left];
                    //
                    // if no vertical rules were created no point in doing the
                    // masking so we will use a faster algorithm
                    //
                    if (cRuleLim == pRD->iMaxRules)
                    {
                        while (iCnt & 3)
                        {
                            *pdwTmp++ ^= (DWORD)-1;
                            iCnt--;
                        }
                        iCnt >>= 2;
                        while (--iCnt >= 0)
                        {
                            pdwTmp[0] ^= (DWORD)-1;
                            pdwTmp[1] ^= (DWORD)-1;
                            pdwTmp[2] ^= (DWORD)-1;
                            pdwTmp[3] ^= (DWORD)-1;
                            pdwTmp += 4;
                        }
                    }
                    //
                    // vertical rules so we better mask with the rules array
                    //
                    else
                    {
                        DWORD *pdwTmpOr = &pdwOr[plrCur->left];
                        while (iCnt & 3)
                        {
                            *pdwTmp = ~*pdwTmp & *pdwTmpOr++;
                            pdwTmp++;
                            iCnt--;
                        }
                        iCnt >>= 2;
                        while (--iCnt >= 0)
                        {
                            pdwTmp[0] = ~pdwTmp[0] & pdwTmpOr[0];
                            pdwTmp[1] = ~pdwTmp[1] & pdwTmpOr[1];
                            pdwTmp[2] = ~pdwTmp[2] & pdwTmpOr[2];
                            pdwTmp[3] = ~pdwTmp[3] & pdwTmpOr[3];
                            pdwTmp += 4;
                            pdwTmpOr += 4;
                        }
                    }
                }
                //
                // if the MaxNumScans == 1 then we need to check for any additional
                // white space created because of the rules removal
                //
                if (pRData->iMaxNumScans == 1)
                {
                    while ((plrCur->left <= plrCur->right) && (pdwIn[plrCur->left] == 0))
                        ++plrCur->left;

                    while ((plrCur->left <= plrCur->right) && (pdwIn[plrCur->right] == 0))
                        --plrCur->right;
                }
                //
                // we need to zero out the white margins since they
                // haven't been inverted.
                //
                else
                {
                    ZeroMemory(pdwIn,plrCur->left * DWBYTES);
                    ZeroMemory(&pdwIn[plrCur->right+1],
                        (cdwLine-plrCur->right-1) * DWBYTES);
                }
                pdwIn += idwLine;
                ++plrCur;
            }
        } // bAllWhite
        // If  the entire scan is white and device supports multi scan line
        // invert the bits;because for multi scan line support, bits have to
        // be inverted.
        else if (pRData->iMaxNumScans > 1)
        {
            pdwIn = pdwBits;
            for( iI = 0; iI < iLim; ++iI )
            {
                ZeroMemory(pdwIn,cdwLine*DWBYTES);
                pdwIn += idwLine;
            }
        }

        /* advance to next stripe */

        pdwBits += iLim * idwLine;              /* Start address next stripe */

        iyPrtLine = pRD->iyPrtLine += iILAdv * iLim;

        plr += iLim;

#if _LH_DBG
        /*
         *   If desired,  rule a line across the end of the stripe.  This
         * can be helpful during debugging.
         */

        if( _lh_flags & RULE_STRIPE )
            vSendRule( pPDev, 0, iyPrtLine, 2399, iyPrtLine );
#endif
    }

    return(TRUE);
}

/*************************** Module Header ********************************
 * vRuleEndPage
 *      Called at the end of a page, and completes any outstanding rules.
 *
 * RETURNS:
 *      Nothing
 *
 * HISTORY:
 *  17:25 on Mon 20 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  specifically for landscape mode.
 *
 ***************************************************************************/

void
vRuleEndPage( pPDev )
PDEV   *pPDev;
{
    /*
     *   Scan for any remaining rules that reach to the end of the page.
     *  This means that any 1 bits remaining in pdwAccum array have
     *  made it,  so they should be sent.  Only vertical rules will be
     *  seen in here - horizontal rules are sent at the end of each stripe.
     */

    register  int  iIReg;       /* Loop parameter */

    int     ixOrg;              /* Start of last rule,  if >= 0 */
    WORD    iyOrg;              /* Ditto, but for y */
    int     iI;                 /* Loop index */
    int     cdwLine;            /* DWORDS per line */
    int     iyMax;              /* Number of scan lines */
    int     iCol;               /* Column number being processed */

    RULE_DATA  *pRD;


    /*
     *   NOTE:   To meet the PDK ship schedule,  the rules finding code
     *  has been simplified somewhat.  As a consequence of this,  this
     *  function no longer performs any useful function.  Hence, we
     *  simply return.  We could delete the function call from the
     *  rendering code,  but at this stage I prefer to leave the
     *  call in,  since it probably will be needed later.
     */

    //return;

//!!! NOTE: this code has not be modified to deal with the LEFT/RIGHT rules

#if _LH_DBG
    if( _lh_flags & NO_RULES )
        return;                 /* Nothing wanted here */
#endif

    if( !(pRD = ((PRASTERPDEV)pPDev->pRasterPDEV)->pRuleData) )
        return;                         /* No doing anything! */
   /* Local Free plrWhite*/
    if( pRD->pRData->plrWhite )
    {
        MemFree( pRD->pRData->plrWhite );
        pRD->pRData->plrWhite = NULL;
    }
    return;
}

/****************************** Function Header ****************************
 *  vSendRule
 *      Function to send a rule command to the printer.  We are given the
 *      four corner coordinates,  from which the command is derived.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  Tuesday 30 November 1993    -by-    Norman Hendley   [normanh]
 *      minor check to allow CaPSL rules - black fill only -
 *  10:57 on Fri 17 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 ***************************************************************************/

static  void
vSendRule( pPDev, ixOrg, iyOrg, ixEnd, iyEnd )
PDEV   *pPDev;
int     ixOrg;          /* The X starting position */
int     iyOrg;          /* The Y starting location */
int     ixEnd;          /* The X end position */
int     iyEnd;          /* The Y end position */
{

    /*
     *   This code is VERY HP LaserJet specific.  Basic step is to set
     *  the cursor position to (ixOrg, iyOrg),  then set the rule length
     *  and width before issuing the rule command.
     */

    int        iTemp;           /* Temporary - for swapping operations */

    RASTERPDEV   *pRPDev;
    RULE_DATA *pRD;
    BOOL  bNoFillCommand;



#if _LH_DBG
    if( _lh_flags & NO_SEND_RULES )
    {
        if( _lh_flags & RULE_VERBOSE )
        {
            DbgPrint( "NOT SENDING RULE: (%ld, %ld) - (%ld, %ld)\n",
                                                ixOrg, iyOrg, ixEnd, iyEnd );

        }
        return;                 /* Nothing wanted here */
    }

    if( _lh_flags & RULE_VERBOSE )
    {
        DbgPrint( "SENDING RULE: (%ld, %ld) - (%ld, %ld)\n",
                                            ixOrg, iyOrg, ixEnd, iyEnd );
    }

#endif

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;           /* For convenience */
    pRD = pRPDev->pRuleData;


    /*
     *   Make sure the start position is < end position.  In landscape
     *  this may not happen.
     */
    if( ixOrg > ixEnd )
    {
        /*  Swap them */
        iTemp = ixOrg;
        ixOrg = ixEnd;
        ixEnd = iTemp;
    }
    if( iyOrg > iyEnd )
    {
        /*  Swap them */
        iTemp = iyOrg;
        iyOrg = iyEnd;
        iyEnd = iTemp;
    }

    if( pPDev->fMode & PF_ROTATE )
    {
        /*
         *    We are rotating the bitmap before sending,  so we should
         *  swap the X and Y coordinates now.  This is easier than reversing
         *  the function calls later, since we need to adjust nearly every
         *  call.
         */

        iTemp = ixOrg;
        ixOrg = iyOrg;
        iyOrg = iTemp;

        iTemp = ixEnd;
        ixEnd = iyEnd;
        iyEnd = iTemp;
    }


    /*
     *  Set the start position.
     */

    XMoveTo (pPDev, (ixOrg * pRD->ixScale) - pRD->ixOffset, 0 );
    YMoveTo( pPDev, iyOrg * pRD->iyScale, 0 );

    /*
     *     Set size of rule (rectangle area).
     * But, first convert from device units (300 dpi) to master units.
     */


    // Hack for CaPSL & other devices with different rule commands. Unidrv will always
    // send the co-ordinates for a rule. The Chicago CaPSL minidriver relies on this.
    // Check if a fill command exists, if not always send the co-ords. With CaPSL
    // these commands actually do the fill also , black (100% gray) only.

    bNoFillCommand = (!pRPDev->dwRectFillCommand) ?
        TRUE : FALSE;


    iTemp = (ixEnd - ixOrg + 1) * pRD->ixScale;
    if (iTemp != (int)pPDev->dwRectXSize || bNoFillCommand)
    {
        /*   A new width, so send the data and remember it for next time */
        pPDev->dwRectXSize = iTemp;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTWIDTH));
    }

    iTemp = (iyEnd - iyOrg + 1) * pRD->iyScale;
    if (iTemp != (int)pPDev->dwRectYSize || bNoFillCommand)
    {
        pPDev->dwRectYSize = iTemp;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTHEIGHT));
    }

    /*
     *   Black fill is the maximum grey fill.
     */
    if (!bNoFillCommand)
    {
        pPDev->dwGrayPercentage = pPDev->pGlobals->dwMaxGrayFill;
        WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,pRPDev->dwRectFillCommand));
    }

    /*
     *    If the rule changes the end coordinates,  then adjust them now.
     */
    if( pPDev->pGlobals->cxafterfill == CXARF_AT_RECT_X_END )
    {
        XMoveTo(pPDev, ixEnd, MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);
    }

    if( pPDev->pGlobals->cyafterfill == CYARF_AT_RECT_Y_END )
    {
        YMoveTo(pPDev, iyEnd, MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\control\vectorc.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    vectorc.c

Abstract:

    Implementation of the interface between Control module and Vector module

Environment:

    Windows 2000/Whistler Unidrv driver

Revision History:

    2/29/2000 -hsingh-
        Created

--*/


#include "vectorc.h"

//
// This functions is defined in control\data.c
//
extern PWSTR
PGetROnlyDisplayName(
    PDEV    *pPDev,
    PTRREF      loOffset,
    PWSTR       wstrBuf,
    WORD    wsize
    )  ;



/*++
Routine Name:
    VMInit

Routine Description:

    This function is called by the unidrv control module to initialize the vector 
    jump table. This function reads the personility from the gpd and depending 
    on whether the personality is pclxl/hpgl2, it calls the appropriate
    InitVectorProcTable() and initializes pPDev->pVectorProcs to the return value.
    If there is no *Personality or *rcPersonalityID keyword in 
    gpd, or if the Personality is nether of pclxl/hpgl2, 
    pPDev->pVectorProcs is set to NULL. 
    pPDev->ePersonality is also updated appropriately.

Arguments:

    pPDev           Pointer to PDEV structure
    pDevInfo        Pointer to DEVINFO structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

    TRUE for success and FALSE for failure
    Even if there is no personality specified in the gpd, we still return TRUE i.e.
    it is ok for pPDev->pVectorProcs to be initialized to NULL.

--*/

BOOL
VMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO *pGDIInfo
    )
{
    BOOL bRet = FALSE;
    PWSTR pPersonalityName = NULL;
    WCHAR   wchBuf[MAX_DISPLAY_NAME];

    // Validate Input Parameters and ASSERT.
    ASSERT(pPDev);
    ASSERT(pPDev->pUIInfo);
    ASSERT(pDevInfo);
    ASSERT(pGDIInfo);

    //
    // Initialize to default values.
    //
    pPDev->pVectorProcs = NULL; // It should be NULL anyway, but just making sure.
    pPDev->ePersonality = kNoPersonality;

    //
    // Get the personality Name. This should have been defined as
    // *Personality or *rcPersonalityID in the gpd. 
    // Use the generic function PGetROnlyDisplayName 
    // defined in control\data.c
    //
    if ( !(pPersonalityName = PGetROnlyDisplayName(pPDev, pPDev->pUIInfo->loPersonality,
                                                  wchBuf, MAX_DISPLAY_NAME )) ) 

    {
        //
        // If pPersonalityName == NULL, do not initialize vector table.
        //
        return TRUE;
    }

    //
    // Initialize the jump table depending on the personality specified in the gpd.
    //
    if ( !wcscmp(pPersonalityName, _T("HPGL2" )) ) // WARNING: This is not localizable.... what to do??
    {
        pPDev->pVectorProcs = HPGLInitVectorProcTable(pPDev, pDevInfo, pGDIInfo);
        if (pPDev->pVectorProcs)
        {
            pPDev->ePersonality = kHPGL2;
        }
    }
    else if ( !wcscmp(pPersonalityName, _T("PCLXL" )) )
    {
        pPDev->pVectorProcs  = PCLXLInitVectorProcTable(pPDev, pDevInfo, pGDIInfo);
        if (pPDev->pVectorProcs)
        {
            pPDev->ePersonality = kPCLXL;
        }
        else
        {
            pPDev->ePersonality = kPCLXL_RASTER;
        }

    }

    //
    // else if the personality specified is not one of hpgl2 or pclxl,
    // just return TRUE. 
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\rmrender.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Definitions, structures and constants for unidrv rendering

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/
#ifndef _RMRENDER_H_
#define _RMRENDER_H_

/*
 *    Miscellaneous constants involved in rendering.
 */

#define BBITS   8               /* Bits per BYTE */
#define WBITS   (sizeof( WORD ) * BBITS)
#define WBYTES  (sizeof( WORD ))
#define DWBITS  (sizeof( DWORD ) * BBITS)
#define DWBYTES (sizeof( DWORD ))

#define COLOUR_MAX      4       /* Maximum number of colours to send to printer */

#define MAX_COMPRESS_MODES 5


/*
 *   Data compression function prototypes.
 */

typedef  int  (* COMPFN)( BYTE *, BYTE *, int );


/*
 *   The following structures contain the important information used
 * when rendering the bitmap image to the printer.  Data is largely
 * calculated once for all future references (for this pdev).
 */

/*   Data specific to transpose operations  */
typedef  struct
{
    void  *pvBuf;               /* Where the output is placed  */
    int    iSkip;               /* Bytes to skip to separte output bytes */
    int    iHigh;               /* Number of input scan lines to transpose */
    int    iWide;               /* Number of pixels in input scan lines */
    int    cDWL;                /* DWORDS per scan line - input */
    int    cBYL;                /* BYTES per scan line - input */
    int    cBL;                 /* BITS per scan line */
    int    iIntlace;            /* Interlace factor */
    int    icbL;                /* Bytes to change pointer per line */
    DWORD *pdwTransTab;         /* Transpose table OR colour separation */
} TRANSPOSE;

typedef struct _LEFTRIGHT
{
    WORD left;
    WORD right;
} LEFTRIGHT, *PLEFTRIGHT;

/*   Overall rendering data */
typedef  struct _RENDER
{
    int   iPassHigh;            /* Scan lines processed per print pass */
    int   iyBase;               /* Processing bitmap in multiple passes */
    int   iyPrtLine;            /* Scan line # as printer sees it */
    int   iyLookAhead;          /* How far ahead we have looked - DeskJet */
    int   iBitsPCol;            /* Bits per column per head pass */
    WORD  iFlags;               /* Flag bits - see below for meaning */
    WORD  fDump;                /* Local copy of fDump from Resolution */
    int   iCursor;              /* Resolution.fCursor copy */
    int   ixOrg;                /* Reference point for graphics commands */
    int   iPosnAdv;             /* Scan lines moved after head pass printed */
    int   iNumScans;            /* Number of scan lines to be printed in one block */
    int   iMaxNumScans;         /* How high we can grow our block */
    int   iHeight;              /* Height in pixels of block to be processed*/

    int   ix;                   /* Input bitmap x size, pels */
    int   iy;                   /* Input bitmap y size, pels */
    int   iBPP;                 /* Pel format (#bits per pel) */
    int   iMaxBytesSend;        /* Number of bytes to process in bottom level */

    int   iSendCmd;             /* Command OCD to send with data block */
    DWORD dwDevWhiteIndex;      // white index for testing leading,trailing
                                // white space

    DWORD *pdwBitMask;          /* Bitmask table,  built as needed */
    DWORD *pdwColrSep;          /* Colour separation table */
    DWORD *pdwTrailingScans;     /* Buffer for dangling scanlines */
    BYTE  *pStripBlanks;

    BYTE  *pbColSplit;          /* For splitting colour bytes */
    BYTE  *pbMirrorBuf;         /* buffer for mirroring data */

    DWORD   dwNumCompCmds;      // number of different compression modes to run
    DWORD dwCompSize;           // size of compression buffer
    DWORD dwLastCompCmd;        // last compression command sent to device
    DWORD pdwCompCmds[MAX_COMPRESS_MODES];// table of active compression commands
    PBYTE pCompBufs[MAX_COMPRESS_MODES];  // pointers to compression buffers
    PBYTE pDeltaRowBuffer;      // previous scan line buffer for delta row compression

    int    iColOff[ COLOUR_MAX ];       /* Address shifting in sepn buffer */

    void  (*vTransFn)( BYTE *, struct _RENDER * );
                /* Transpose function for multi-pin printers */
    void  (*vLtoPTransFn)( BYTE *, struct _RENDER * );
                /* Landscape to portrait transpose fn */

    TRANSPOSE  Trans;           /* The transpose data  */

    int   (*iXMoveFn)( PDEV *, int, int );        /* X positioning function */
    int   (*iYMoveFn)( PDEV *, int, int );        /* Y positioning function */

    BOOL  (*bPassProc)( PDEV *, BYTE *, struct _RENDER * );     /* Color/mono */

    BOOL  (*bWhiteLine)( DWORD *, struct _RENDER *, int );   /* A white scan line? */
    BOOL  (*bWhiteBand)( DWORD *, struct _RENDER *, int );   /* A white band? */


    BOOL   bInverted;           /* have the bits been inverted yet */
    PLEFTRIGHT plrWhite;        /* list of left/right pairs for each row */
    PLEFTRIGHT plrCurrent;      /* left/right pair for current row */
    DWORD clr;                  /* count of left/right scans             */
    BYTE    ubFillWhite;        // This value is used to initialize buffers
    PRINTERTYPE PrinterType;    // type of printer, SERIAL,PAGE,TTY
} RENDER;

/*   Make access to transpose data easier  */
#define pvTransBuf      Trans.pvBuf
#define iTransSkip      Trans.iSkip
#define iTransHigh      Trans.iHigh
#define iTransWide      Trans.iWide
#define cDWLine         Trans.cDWL
#define cBYLine         Trans.cBYL
#define cBLine          Trans.cBL
#define iInterlace      Trans.iIntlace
#define cbTLine         Trans.icbL

/*
 *   Bits in iFlags above:
 */

#define RD_GRAPHICS     0x0001          /* Printer is in graphics mode */
#define RD_RESET_DRC    0x0002          /* Need to reset DRC buffer */
#define RD_UNIDIR       0x0004          /* Printer in unidirectional mode */
#define RD_ALL_COLOUR   0x0008          /* Set if ALL colour bands must be sent */


/********************************
 *    Function prototypes
 ********************************/

/*
 *   Initialisation functions.
 */

BOOL  bSkipInit( PDEV * );
BOOL  bInitTrans( PDEV * );

/*
 *   Functions to initialise the RENDER structure, and clean it up when done.
 */

BOOL  bRenderInit( PDEV  *, SIZEL, int );
void  vRenderFree( PDEV * );

/*
 *    Functions to call at the start and finish of each page.
 */

BOOL  bRenderStartPage( PDEV * );
BOOL  bRenderPageEnd( PDEV * );

/*
 *   The top level rendering function.
 */

BOOL bRender( SURFOBJ *, PDEV *, RENDER *, SIZEL, DWORD * );

/*
 *   Bitmap edge finding function.   There are versions for each flavour
 *  of bitmap we support.  There is also the one for we always send all
 *  the scan lines.
 */

BOOL bIsBandWhite( DWORD *, RENDER *, int );
BOOL bIsLineWhite( DWORD *, RENDER *, int );
BOOL bIsNegatedLineWhite( DWORD *, RENDER *, int );

BOOL bIsRGBBandWhite( DWORD *, RENDER *, int );
BOOL bIsRGBLineWhite( DWORD *, RENDER *, int );

BOOL bIs8BPPBandWhite( DWORD *, RENDER *, int );
BOOL bIs8BPPLineWhite( DWORD *, RENDER *, int );

BOOL bIs24BPPBandWhite( DWORD *, RENDER *, int );
BOOL bIs24BPPLineWhite( DWORD *, RENDER *, int );

BOOL bIsNeverWhite( DWORD *, RENDER *, int );

int iStripBlanks( BYTE *, BYTE *, int, int, int,int);
/*
 *      Functions associated with finding rules in the bitmap.  This
 *  is really helpful for LaserJet style printers.
 */

void vRuleInit( PDEV *, RENDER * );
void vRuleFree( PDEV * );
BOOL bRuleProc( PDEV *, RENDER *, DWORD * );
void vRuleEndPage( PDEV  * );


/*
 *    Functions related to transposing the bitmap from one format to
 *  another.  These are for protrait/landscape conversion,  or for
 *  turning the output data into the order required for dot matrix
 *  style printers,  where the data is in column order.
 */


/*  Special case: 8 x 8 transpose for dot matrix printers */
void vTrans8x8( BYTE  *, RENDER  * );

/*  The more general case */
void vTrans8N( BYTE  *, RENDER  * );

/* Transpose for 4 bits per pel colour bitmap */
void vTrans8N4BPP( BYTE *, RENDER * );

/* Transpose for 8 bits per pel colour bitmap */
void vTrans8BPP( BYTE *, RENDER * );

/* Transpose for 24 bits per pel colour bitmap */
void vTrans24BPP( BYTE *, RENDER * );

/*  Colour separation for single pin colour printers (e.g. PaintJet) */
void vTransColSep( BYTE *, RENDER  * );

void vInvertBits(DWORD *, int);

/* Output 24 bit data */
BOOL b24BitOnePassOut( PDEV *, BYTE *, RENDER *);

void SelectColor( PDEV *, int );

int  iLineOut( PDEV *,RENDER *, BYTE *, int, int );

#endif  // !_RMRENDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\whiteskp.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Functions to scan a bitmap for white regions.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created (mostly stolen from Lindsayh)

--*/


#include        "raster.h"
#include        "rmrender.h"

/*
 *    The following union allows machine independent conversion from
 *  DWORDS to BYTES.
 */

typedef  union
{
    DWORD   dw;                 /* Data as a DWORD  */
    BYTE    b[ DWBYTES ];       /* Data as bytes */
}  UBDW;


/*
 *   Following array is used to test the leftover bits from scanning.  The
 *  rational is that only some of the bits in the last word are part
 *  of the bitmap,  so only they must be tested.  It is initialised at
 *  DLL initialisation time.
 *      NOTE:  There are 33 entries in this array:  This is intentional!
 *  Depending upon circumstances,  either the 0 or 32nd entry will be
 *  used for a dword that is all ones.
 *
 **** THIS ARRAY IS NOW DYNAMICALLY ALLOCATED IN bSkipInit().  ************
 */


#define TABLE_SIZE      ((DWBITS + 1) * sizeof( DWORD ))

/*
 *   RGB_WHITE is the bit pattern found in a white entry for an RGB format
 *  4 bits per pel bitmap.  This is the only special case required when
 *  scanning the source bitmap for white.  In all other cases (monochrome
 *  and CMY),  white is represented by a 0 nibble.
 */

#define RGB_WHITE       0x77777777

/*
 *   Also want to know about the 8 bit per pel white index.
 */

#define BPP8_WHITE      0xffffffff

/*
 *  Define BPP values for clarify
 */
#define BPP1   1
#define BPP4   4
#define BPP8   8
#define BPP24  24


//*****************************************************
BOOL
bSkipInit(
    PDEV *pPDev
    )
/*++

Routine Description:

    The job here is to initialise the table that is used to mask off
    the unused bits in a scanline.  All scanlines are DWORD aligned,
    and we take advantage of that fact when looking for white space.
    However,  the last DWORD may not be completely used,  so we have
    a masking table used to check only those bits of interest.
    The table depends upon byte ordering within words,  and this is
    machine dependent,  so we generate the table.  This provides
    machine independence,  since the machine that is going to use
    the table generates it!    This function is called when the DLL
    is loaded,  so we are not called often.
    The union 'u' provides the mapping between BYTES and DWORDS,
    and so is the key to this function.  The union is initialised
    using the BYTE array,  but it stored in memory using the DWORD.


Arguments:

    pPDev           Pointer to PDEV structure

Return Value:

    TRUE for success and FALSE for failure

--*/
{

    register  int    iIndex;
    register  DWORD *pdw;

    UBDW  u;            /* The magic union */
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;

    u.dw = 0;

    if( !(pRPDev->pdwBitMask = (DWORD *)MemAlloc( TABLE_SIZE )) )
        return  FALSE;


    pdw = pRPDev->pdwBitMask;

    for( iIndex = 0; iIndex < DWBITS; ++iIndex )
    {
        *pdw++ = u.dw;

        /*   The left most bit in the scan line is the MSB of the byte */
        u.b[ iIndex / BBITS ] |= 1 << (BBITS - 1 - (iIndex & (BBITS - 1)));
    }

    /* ALL bits are involved in the last one */
    *pdw = (DWORD)~0;


    return   TRUE;
}

//*******************************************************
BOOL
bIsBandWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    int iWhiteIndex
)
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer. This routine also
    masks off the unused bits at the end of each scan line.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against, only
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */
    BOOL   bRet;

    //Always TRUE for Txtonly as we don't want to send any graphics.
    if(pRData->PrinterType == PT_TTY)
        return TRUE;


    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will usually be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;

    bRet = TRUE;

    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;


        /* Need to continue masking regardless */
        if (bRet)
        {
            while (*pdwBits == 0 && ++pdwBits < pdwLim);

            if( pdwBits < pdwLim )
                bRet = FALSE;
        }

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }

    return  bRet;
}


//**********************************************************
BOOL
bIsLineWhite(
    register DWORD *pdwBits,
    register RENDER *pRData,
    int iWhiteIndex
)
/*++

Routine Description:

    Scan a horizontal row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    scan line should be sent to the printer. This routine also
    masks off the unused bits at the end of each scan line.

Arguments:

    pdwBits         Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against, only
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwLim;


    DWORD  dwMask;              /* Mask to zap the trailing bits */

    //Always TRUE for Txtonly as we don't want to send any graphics.
    if(pRData->PrinterType == PT_TTY)
        return TRUE;

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */


    /* pDWLim is the DWORD past the data of interest - not used */
    pdwLim = pdwBits + pRData->cDWLine;

    /*  Clear out undefined bits at end of line  */
    *(pdwLim - 1) &= dwMask;

    while (*pdwBits == 0 && ++pdwBits < pdwLim);

    if( pdwBits < pdwLim )
        return   FALSE;

    return  TRUE;
}
//**********************************************************
BOOL
bIsNegatedLineWhite(
    DWORD *pdwBits,
    RENDER *pRData,
    int iWhiteIndex
)
/*++

Routine Description:

    Scan a horizontal row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    scan line should be sent to the printer. This routine also
    masks off the unused bits at the end of each scan line.

Arguments:

    pdwBits         Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against, only
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    DWORD  *pdwLim;
    int     iCnt;


    DWORD  dwMask;              /* Mask to zap the trailing bits */

    //Always TRUE for Txtonly as we don't want to send any graphics.
    if(pRData->PrinterType == PT_TTY)
        return TRUE;

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    /*  Clear out undefined bits at end of line  */
    pdwBits[pRData->cDWLine-1] |= ~dwMask;

    //
    // For performance we test 4 dwords at a time for white
    //
    pdwLim = pdwBits;
    iCnt = pRData->cDWLine >> 2;
    while (--iCnt >= 0)
    {
        if ((pdwBits[0] & pdwBits[1] & pdwBits[2] & pdwBits[3]) != -1)
            goto InvertTheBits;
        pdwBits += 4;
    }
    //
    // test any left over dwords for white
    //
    iCnt = pRData->cDWLine & 3;
    while (--iCnt >= 0)
    {
        if (*pdwBits != -1)
            goto InvertTheBits;
        pdwBits++;
    }
    return  TRUE;
    //
    // if this isn't a white line we need to invert the bits
    //
InvertTheBits:
    dwMask = (DWORD)(pdwBits - pdwLim);
    ZeroMemory (pdwLim,dwMask*DWBYTES);
    vInvertBits(pdwBits,pRData->cDWLine-dwMask);
    return FALSE;
}

//***************************************************
BOOL
bIsRGBBandWhite (
    DWORD   *pdwBitsIn,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;

    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;
        *(pdwLim - 1) |= ~dwMask & RGB_WHITE;


        /*
         *   NOTE:   This test is more complex than needed because the
         *  engine ignores palette entries when doing BLTs.  The WHITENESS
         *  rop sets all bits to 1.  Hence,  we choose to ignore the
         *  MSB in the comparison:  this means we detect white space
         *  with an illegal palette entry.  This makes GDI people happy,
         *  but not me.
         */
        do {
            if ((*pdwBits & RGB_WHITE) != RGB_WHITE)
                return FALSE;
        } while (++pdwBits < pdwLim);

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }
    return  TRUE;
}

//*******************************************************
BOOL
bIsRGBLineWhite (
    register  DWORD *pdwBits,
    RENDER          *pRData,
    int             iWhiteIndex
    )
/*++

Routine Description:

    Scan a single row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    DWORD  dwCnt;

    DWORD  dwMask;              /* Mask to zap the trailing bits */

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    /*  Clear out undefined bits at end of line  */
    dwCnt = pRData->cDWLine;
    pdwBits[dwCnt-1] &= dwMask;
    pdwBits[dwCnt-1] |= ~dwMask & RGB_WHITE;

    // test four dwords at a time
    //
    while (dwCnt >= 4)
    {
        if ((*pdwBits & pdwBits[1] & pdwBits[2] & pdwBits[3] & RGB_WHITE) != RGB_WHITE)
            return FALSE;
        pdwBits += 4;
        dwCnt -= 4;
    }
    while (dwCnt--)
    {
        if ((*pdwBits & RGB_WHITE) != RGB_WHITE)
            return FALSE;
        pdwBits++;
    }

    return  TRUE;
}

//**********************************************************
BOOL
bIs8BPPBandWhite (
    DWORD   *pdwBitsIn,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */
    DWORD  dwWhiteIndex;

    dwWhiteIndex = (DWORD)iWhiteIndex;

    /*
     *  As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;

    /*
     * Need to set up the white index to be a dword multiple.
     * iwhiteIndex looks like 0x000000ff but the comparison
     * is done on dword boundaries so a stream of white looks
     * like 0xffffffff.
     */
    dwWhiteIndex |= dwWhiteIndex << 8;
    dwWhiteIndex |= dwWhiteIndex << 16;

    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;
        *(pdwLim - 1) |= ~dwMask & dwWhiteIndex;

        while(*pdwBits ==  dwWhiteIndex && ++pdwBits < pdwLim);

        if( pdwBits < pdwLim )
            return  FALSE;

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }

    return  TRUE;
}

//**********************************************************
BOOL
bIs8BPPLineWhite (
    DWORD   *pdwBits,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a single row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBits         Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwLim;


    DWORD  dwMask;              /* Mask to zap the trailing bits */
    DWORD  dwWhiteIndex;

    dwWhiteIndex = (DWORD)iWhiteIndex;


    /*
     * Need to set up the white index to be a dword multiple.
     * iwhiteIndex looks like 0x000000ff but the comparison
     * is done on dword boundaries so a stream of white looks
     * like 0xffffffff.
     */

    dwWhiteIndex |= dwWhiteIndex << 8;
    dwWhiteIndex |= dwWhiteIndex << 16;
    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */


    /* pDWLim is the DWORD past the data of interest - not used */
    pdwLim = pdwBits + pRData->cDWLine;

    /*  Clear out undefined bits at end of line  */
    *(pdwLim - 1) &= dwMask;
    *(pdwLim - 1) |= ~dwMask & dwWhiteIndex;

    while(*pdwBits ==  dwWhiteIndex && ++pdwBits < pdwLim);

    if( pdwBits < pdwLim )
        return   FALSE;


    return  TRUE;
}

//**********************************************************
BOOL
bIs24BPPBandWhite (
    DWORD   *pdwBitsIn,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */
    DWORD  dwWhiteIndex;

    dwWhiteIndex = (DWORD)iWhiteIndex;
    dwWhiteIndex |= dwWhiteIndex << 8;

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;


    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;
        *(pdwLim - 1) |= ~dwMask & BPP8_WHITE;


        /*
         *   NOTE:   This test is more complex than needed because the
         *  engine ignores palette entries when doing BLTs.  The WHITENESS
         *  rop sets all bits to 1.  Hence,  we choose to ignore the
         *  MSB in the comparison:  this means we detect white space
         *  with an illegal palette entry.  This makes GDI people happy,
         *  but not me.
         */
        while(*pdwBits ==  dwWhiteIndex && ++pdwBits < pdwLim);

        if( pdwBits < pdwLim )
            return  FALSE;

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }


    return  TRUE;
}

//*******************************************************
BOOL
bIs24BPPLineWhite (
    register  DWORD *pdwBits,
    RENDER          *pRData,
    int             iWhiteIndex
    )
/*++

Routine Description:

    Scan a single row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{
    DWORD  dwMask;              /* Mask to zap the trailing bits */
    LONG   iLimit = pRData->cDWLine;

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));

    if( dwMask != 0 )
    {
        /*  Clear out undefined bits at end of line  */
        pdwBits[iLimit-1] &= dwMask;
        pdwBits[iLimit-1] |= ~dwMask & BPP8_WHITE;
    }

    /*
     *  As a speed optimisation, scan the bits in 4 DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required. First we will test the odd dwords.
     */

    while (iLimit & 3)
    {
        iLimit--;
        if (*pdwBits++ != ~0)
            return FALSE;
    }
    iLimit >>= 2;
    while (--iLimit >= 0)
    {
        pdwBits += 4;
        if ((pdwBits[-4] & pdwBits[-3] & pdwBits[-2] & pdwBits[-1]) != BPP8_WHITE)
            return FALSE;
    }
    return  TRUE;
}


//*******************************************************
BOOL
bIs1BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect
)
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               /* Number of scan lines to check */
    int     iWords;             // number of words to check per line

    DWORD  dwEndMask;              /* Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits


    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some leading and
     *  trailing bits which are handled individually
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwEndMask = *(pRData->pdwBitMask + (pRect->right % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (pRect->left % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (pRect->left / DWBITS);

    // calculate number of words to test
    iWords = ((pRect->right + DWBITS - 1) / DWBITS) - (pRect->left / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
    {
        dwBegMask &= dwEndMask;
    }
    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if (~(*pdwBits) & dwBegMask)
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                int iCnt = iWords;
                if (iCnt & 1)
                {
                    if (pdwBits[0] != ~0)
                        return FALSE;
                    pdwBits++;
                }
                if (iCnt & 2)
                {
                    if ((pdwBits[0] & pdwBits[1]) != ~0)
                        return FALSE;
                    pdwBits += 2;
                }
                while ((iCnt -= 4) >= 0)
                {
                    if ((pdwBits[0] & pdwBits[1] & pdwBits[2] & pdwBits[3]) != ~0)
                        return FALSE;
                    pdwBits += 4;
                }
            }
            //* test last dword
            if (~(*pdwBits) & dwEndMask)
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//**************************************************
BOOL
bIs4BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect
)
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               /* Number of scan lines to check */
    int     iWords;             // number of words to check per line
    int    iRight;
    int    iLeft;

    DWORD  dwEndMask;              /* Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits


    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some leading and
     *  trailing bits which are handled individually
     */

    //* Adjust horizontal positions by BPP
    iRight = pRect->right * BPP4;
    iLeft = pRect->left * BPP4;

    //*  Mask to clear first and last bits of scanline,  if not full DWORD
    //*
    dwEndMask = *(pRData->pdwBitMask + (iRight % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (iLeft % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (iLeft / DWBITS);

    // calculate number of words to test
    iWords = ((iRight + DWBITS - 1) / DWBITS) - (iLeft / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
        dwBegMask &= dwEndMask;

    //*  MSB of each pixel is ignored so combine with pixel mask
    //*  see bIsRGBLineWhite for why MSB is ignored
    dwEndMask &= RGB_WHITE;
    dwBegMask &= RGB_WHITE;

    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if ((*pdwBits & dwBegMask) != dwBegMask)
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                DWORD dwTmp = RGB_WHITE;
                int iCnt = iWords;
                while (iCnt & 3)
                {
                    dwTmp &= *pdwBits++;
                    iCnt--;
                }
                iCnt >>= 2;
                while (--iCnt >= 0)
                {
                    dwTmp &= pdwBits[0];
                    dwTmp &= pdwBits[1];
                    dwTmp &= pdwBits[2];
                    dwTmp &= pdwBits[3];
                    pdwBits += 4;
                }
                if (dwTmp != RGB_WHITE)
                    return FALSE;
            }
            //* test last dword
            if ((*pdwBits & dwEndMask) != dwEndMask)
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//**************************************************
BOOL
bIs8BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect,
    int iWhiteIndex
    )
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               /* Number of scan lines to check */
    int     iWords;             // number of words to check per line
    int iRight;
    int iLeft;

    DWORD  dwEndMask;              /* Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits

    DWORD  dwWhiteIndex;

    //* calculate WhiteIndex for 4 bytes at a time
    dwWhiteIndex = (DWORD)iWhiteIndex;
    dwWhiteIndex |= dwWhiteIndex << 8;
    dwWhiteIndex |= dwWhiteIndex << 16;

    //* Adjust horizontal positions by BPP
    iRight = pRect->right * BPP8;
    iLeft = pRect->left * BPP8;

    //*  Mask to clear first and last bits of scanline,  if not full DWORD
    //*
    dwEndMask = *(pRData->pdwBitMask + (iRight % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (iLeft % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (iLeft / DWBITS);

    // calculate number of words to test
    iWords = ((iRight + DWBITS - 1) / DWBITS) - (iLeft / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
        dwBegMask &= dwEndMask;
    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if ((*pdwBits & dwBegMask) != (dwWhiteIndex & dwBegMask))
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                int iCnt = iWords;
                do {
                    if (*pdwBits != dwWhiteIndex)
                        return FALSE;
                    pdwBits++;
                } while (--iCnt);
            }
            //* test last dword
            if ((*pdwBits & dwEndMask) != (dwWhiteIndex & dwEndMask))
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//****************************************************
BOOL
bIs24BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect
    )
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               // Number of scan lines to check */
    int     iWords;             // number of words to check per line
    int iRight;
    int iLeft;

    DWORD  dwEndMask;           // Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits

    //* Adjust horizontal positions by BPP
    iRight = pRect->right * BPP24;
    iLeft = pRect->left * BPP24;

    //*  Mask to clear first and last bits of scanline,  if not full DWORD
    //*
    dwEndMask = *(pRData->pdwBitMask + (iRight % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (iLeft % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (iLeft / DWBITS);

    // calculate number of words to test
    iWords = ((iRight + DWBITS - 1) / DWBITS) - (iLeft / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
        dwBegMask &= dwEndMask;

    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if ((*pdwBits & dwBegMask) != dwBegMask)
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                int iCnt = iWords;
                while (iCnt & 3)
                {
                    if (*pdwBits != ~0)
                        return FALSE;
                    pdwBits++;
                    iCnt--;
                }
                iCnt >>= 2;
                while (--iCnt >= 0)
                {
                    if ((pdwBits[0] & pdwBits[1] & pdwBits[2] & pdwBits[3]) != ~0)
                        return FALSE;
                    pdwBits += 4;
                }
            }
            //* test last dword
            if ((*pdwBits & dwEndMask) != dwEndMask)
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//*********************************************************
BOOL
bIsRegionWhite(
    SURFOBJ    *pso,
    RECTL   *pRect
    )

/*++

Routine Description:

    This routine determines whether a given region of the
    shadow bitmap is white.

Arguments:

    pPDev - Pointer to PDEV.
    pRect - Pointer to clip window within shadow bitmap

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    01-07-97: Created by alvins
--*/

{
    PDEV *pPDev = (PDEV *)pso->dhpdev;
    PRASTERPDEV pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;
    RENDER *pRD;
    RECTL Rectl;
    int y1,y2;

    // If the render structure hasn't been initialize how can
    // there have been data drawn in it. Also check the dirty flag
    if (!(pPDev->fMode & PF_SURFACE_USED) || pRPDev == NULL)
        return TRUE;

    pRD = pRPDev->pvRenderData;
    if (pRD == NULL)
        return TRUE;

    // lets make sure these values are positive
    // and there's still something to test
    //
    Rectl.left = pRect->left > 0 ? pRect->left : 0;
    Rectl.top = pRect->top > 0 ? pRect->top : 0;
    Rectl.right = pRect->right > 0 ? pRect->right : 0;
    Rectl.bottom = pRect->bottom > 0 ? pRect->bottom : 0;

    if (Rectl.left == Rectl.right || Rectl.top == Rectl.bottom)
        return TRUE;

    // if not surface then also assume all white
    if (pso->iType != STYPE_BITMAP)
        return TRUE;

    // need to actually check data at this point
    y1 = Rectl.top / LINESPERBLOCK;
    y2 = (Rectl.bottom-1) / LINESPERBLOCK;
    while (y1 <= y2)
    {
        RECTL tRectl = Rectl;

        if (pPDev->pbRasterScanBuf == NULL || pPDev->pbRasterScanBuf[y1])
        {
            // test a block at a time if we've block erased the surface
            //
            if (pPDev->pbRasterScanBuf)
            {
                if ((y1*LINESPERBLOCK) > tRectl.top)
                    tRectl.top = y1 * LINESPERBLOCK;
                y1++;
                if ((y1*LINESPERBLOCK) < tRectl.bottom)
                    tRectl.bottom = y1 * LINESPERBLOCK;
            }
            // surface is not block erased so make this last loop
            //
            else
                y1 = y2+1;

            switch (pRD->iBPP)
            {
            case 1:
                if (!bIs1BPPRegionWhite(pso->pvBits,pRD,&tRectl))
                    return FALSE;
                break;
            case 4:
                if (!bIs4BPPRegionWhite(pso->pvBits,pRD,&tRectl))
                    return FALSE;
                break;
            case 8:
                if (!bIs8BPPRegionWhite(pso->pvBits,pRD,&tRectl,pRPDev->pPalData->iWhiteIndex))
                    return FALSE;
                break;
            case 24:
                if (!bIs24BPPRegionWhite(pso->pvBits,pRD,&tRectl))
                    return FALSE;
                break;
            // if I don't recognize the format, I'll assume its empty
            default:
                return TRUE;
            }
        }
        else
            y1++;
    }
    return TRUE;
}

//*******************************************************
BOOL
bIsNeverWhite (
    register  DWORD *pdwBits,
    RENDER          *pRData,
    int             iWhiteIndex
    )
/*++

Routine Description:

    This function always returns FALSE and exists only to provide
    a common function call format for all the IsWhite Line/Band
    functions.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against

Return Value:

    FALSE

--*/
{

    return   FALSE;
}

//******************************************************
int
iStripBlanks(
    BYTE *pbOut,
    BYTE *pbIn,
    int  iLeft,
    int  iRight,
    int  iHeight,
    int  iWidth
    )
/*++

Routine Description:

    This function strips already identified white space
    from the buffer.

Arguments:

    pbOut       Pointer to output buffer
    pbIn        Pointer source buffer
    iLeft       First non-white leading byte
    iRight      First white trailing byte
    iHeight     Number of scanlines
    iWidth      Width of source scanlines

Return Value:

    Number of bytes in new buffer

--*/
{
    int i,j;
    BYTE * pbSrc;
    BYTE * pbTgt;
    int iDelta;

    iDelta = iRight - iLeft;
    pbTgt = pbOut;
    pbSrc = pbIn+iLeft;
    for (i = 0; i < iHeight; i++)
    {
        CopyMemory(pbTgt,pbSrc,iDelta);
        pbTgt += iDelta;
        pbSrc += iWidth;
    }
    return (iDelta * iHeight);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\render\stretch.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    stretch.c


Abstract:

    This module contains all the StretchBlt/BitBlt codes which handle halftoned
    sources

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "raster.h"

#define DW_ALIGN(x)             (((DWORD)(x) + 3) & ~(DWORD)3)

#define ROP4_NEED_MASK(Rop4)    (((Rop4 >> 8) & 0xFF) != (Rop4 & 0xFF))
#define ROP3_NEED_PAT(Rop3)     (((Rop3 >> 4) & 0x0F) != (Rop3 & 0x0F))
#define ROP3_NEED_SRC(Rop3)     (((Rop3 >> 2) & 0x33) != (Rop3 & 0x33))
#define ROP3_NEED_DST(Rop3)     (((Rop3 >> 1) & 0x55) != (Rop3 & 0x55))
#define ROP4_FG_ROP(Rop4)       (Rop4 & 0xFF)
#define ROP4_BG_ROP(Rop4)       ((Rop4 >> 8) & 0xFF)

#if DBG
BOOL    DbgWhiteRect = FALSE;
BOOL    DbgBitBlt = FALSE;
BOOL    DbgCopyBits = FALSE;
#define _DBGP(i,x)            if (i) { (DbgPrint x); }
#else
#define _DBGP(i,x)

#endif //DBG



#define DELETE_SURFOBJ(pso, phBmp)                                      \
{                                                                       \
    if (pso)      { EngUnlockSurface(pso); pso=NULL;                  } \
    if (*(phBmp)) { EngDeleteSurface((HSURF)*(phBmp)); *(phBmp)=NULL; } \
}

#ifdef WINNT_40 //NT 4.0

#if DBG
BOOL    DbgDitherColor = FALSE;
#endif

extern HSEMAPHORE   hSemBrushColor;
extern LPDWORD      pBrushSolidColor;

#endif //WINNT_40




ROP4 InvertROPs(
    ROP4    Rop4
    )
/*++

Routine Description:

    This function remaps ROPs intended for RGB mode into CMY mode for 8bpp
    monochrome printing.

--*/
{
    // Rops are remapped for CMY vs RGB rendering by reversing the order of
    // the bits in the ROP and inverting the result.
    //
    if ((Rop4 & 0xff) == ((Rop4 >> 8) & 0xff))
    {
        ROP4 NewRop = 0;
        if (Rop4 & 0x01) NewRop |= 0x8080;  
        if (Rop4 & 0x02) NewRop |= 0x4040;
        if (Rop4 & 0x04) NewRop |= 0x2020;
        if (Rop4 & 0x08) NewRop |= 0x1010;
        if (Rop4 & 0x10) NewRop |= 0x0808;  
        if (Rop4 & 0x20) NewRop |= 0x0404;
        if (Rop4 & 0x40) NewRop |= 0x0202;
        if (Rop4 & 0x80) NewRop |= 0x0101;
        NewRop ^= 0xFFFF;
#ifdef DBGROP        
        if (NewRop != Rop4)
        {
            DbgPrint ("ROP remapped: %4x -> %4x\n",Rop4,NewRop);            
        }
#endif    
        Rop4 = NewRop;
    }
/*    
    if (Rop4 == 0xB8B8)     // required for bug 22915
        Rop4 = 0xE2E2;
    else if (Rop4 == 0x0000) // BLACKNESS
        Rop4 = 0xFFFF;
    else if (Rop4 == 0xFFFF) // WHITENESS
        Rop4 = 0x0000;
    else if (Rop4 == 0x8888) // SRCAND, required for bug 36192
        Rop4 = 0xEEEE;
    else if (Rop4 == 0xEEEE) // SRCPAINT, remap so it differs from SCRAND
        Rop4 = 0x8888;
    else if (Rop4 == 0xC0C0) // MERGECOPY
        Rop4 = 0xFCFC;
    else if (Rop4 == 0xFBFB) // PATPAINT
        Rop4 = 0x2020;
*/        
    return Rop4;
}


BOOL DrawWhiteRect(
    PDEV    *pPDev,
    RECTL   *pDest,
    CLIPOBJ *pco
    )
/*++

Routine Description:

    This function sends a white rectangle directly to the device if fonts
    have been sent to the printer for this band. This is used to clear
    the region where an image will be drawn.

Arguments:

    pPDev       - pointer to PDEV structure
    pDest       - pointer to destination RECTL
    pco         - pointer to CLIPOBJ

--*/
{
    RECTL  rcClip;
    BYTE   bMask;
    BOOL   bSendRectFill;
    LONG   i;
    PBYTE  pbScanBuf;
    BOOL   bMore;
    DWORD  dwMaxRects;

    if (DRIVER_DEVICEMANAGED (pPDev))   // Device Managed Surface
        return 0;

    //
    // only send the clearing rectangle if the device supports rectangles,
    // text has been downloaded, it is not a complex clip region.
    //
    if (!(pPDev->fMode & PF_RECT_FILL) ||
            !(pPDev->fMode & PF_DOWNLOADED_TEXT) ||
            (pco && pco->iDComplexity == DC_COMPLEX && pco->iFComplexity != FC_RECT4) ||
            !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL)) ||
            pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS ||
            pPDev->fMode2 & PF2_MIRRORING_ENABLED)
    {
        return 0;
    }
    //
    // if complex clip but FC_RECT4 then there won't be more than 4 rectangles
    //
    if (pco && pco->iFComplexity == FC_RECT4)
    {
        if (CLIPOBJ_cEnumStart(pco,TRUE,CT_RECTANGLES,CD_ANY,4) == -1)
            return 0;
    }
    bMore = FALSE;
    dwMaxRects = 0;
    do 
    {
        //
        // clip to printable region or band
        //
        rcClip.left = MAX(0, pDest->left);
        rcClip.top = MAX(0, pDest->top);
        rcClip.right = MIN(pPDev->szBand.cx,pDest->right);
        rcClip.bottom = MIN(pPDev->szBand.cy,pDest->bottom);

        //
        // if clip rectangle or complex clip FC_RECT4 we need to apply
        // clip rectangle to input rectangle.
        //
        if (pco)
        {
            if (pco->iDComplexity == DC_RECT)
            {
                if (rcClip.left < pco->rclBounds.left)
                    rcClip.left = pco->rclBounds.left;
                if (rcClip.top < pco->rclBounds.top)
                    rcClip.top = pco->rclBounds.top;
                if (rcClip.right > pco->rclBounds.right)
                    rcClip.right = pco->rclBounds.right;
                if (rcClip.bottom > pco->rclBounds.bottom)
                    rcClip.bottom = pco->rclBounds.bottom;
            }
            else if (pco->iFComplexity == FC_RECT4)
            {
                ENUMRECTS eRect;
                bMore = CLIPOBJ_bEnum(pco,(ULONG)sizeof(ENUMRECTS),(ULONG *)&eRect);
                if (eRect.c != 1)
                    continue;
                if (rcClip.left < eRect.arcl[0].left)
                    rcClip.left = eRect.arcl[0].left;
                if (rcClip.top < eRect.arcl[0].top)
                    rcClip.top = eRect.arcl[0].top;
                if (rcClip.right > eRect.arcl[0].right)
                    rcClip.right = eRect.arcl[0].right;
                if (rcClip.bottom > eRect.arcl[0].bottom)
                    rcClip.bottom = eRect.arcl[0].bottom;
            }
        }
        //
        // At this point we will check whether anything has been directly downloaded to the
        // printer (ie text) to see if we need to even bother drawing the erase rectangle.
        //
        bMask = BGetMask(pPDev, &rcClip);
        bSendRectFill = FALSE;
        for (i = rcClip.top; i < rcClip.bottom ; i++)
        {
            if (pPDev->pbScanBuf[i] & bMask)
            {
                bSendRectFill = TRUE;
                break;
            }
        }

        //
        // check if we end up with an empty rect.
        //
        if (bSendRectFill && rcClip.right > rcClip.left && rcClip.bottom > rcClip.top)
        {
            DRAWPATRECT PatRect;
            PatRect.wStyle = 1;     // white rectangle
               PatRect.wPattern = 0;   // pattern not used
            PatRect.ptPosition.x = rcClip.left;
            PatRect.ptPosition.y = rcClip.top;
            PatRect.ptSize.x = rcClip.right - rcClip.left;
            PatRect.ptSize.y = rcClip.bottom - rcClip.top;
            DrawPatternRect(pPDev,&PatRect);
            dwMaxRects++;
            _DBGP(DbgWhiteRect,("DrawWhiteRect (%d,%d) (%d,%d)\n",
                rcClip.left+pPDev->rcClipRgn.left,
                rcClip.top+pPDev->rcClipRgn.top,
                rcClip.right+pPDev->rcClipRgn.left,
                rcClip.bottom+pPDev->rcClipRgn.top));
        }
    } while (bMore && dwMaxRects < 4);
    return (BOOL)dwMaxRects;
}


LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    )

/*++

Routine Description:

    This function calculate total bytes needed for a single scan line in the
    bitmap according to its format and alignment requirement.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this is must one of the
                      standard format which defined as BMF_xxx

    cx              - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero


Author:

    19-Jan-1994 Wed 16:19:39 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   Delta = cx;

    switch (SurfaceFormat) {

    case BMF_32BPP:

        Delta <<= 5;
        break;

    case BMF_24BPP:

        Delta *= 24;
        break;

    case BMF_16BPP:

        Delta <<= 4;
        break;

    case BMF_8BPP:

        Delta <<= 3;
        break;

    case BMF_4BPP:

        Delta <<= 2;
        break;

    case BMF_1BPP:

        break;

    default:

        _DBGP(1, ("\nGetBmpDelta: Invalid BMF_xxx format = %ld", SurfaceFormat));
        break;
    }

    Delta = (DWORD)DW_ALIGN((Delta + 7) >> 3);
    return((LONG)Delta);
}




SURFOBJ *
CreateBitmapSURFOBJ(
    PDEV    *pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format
    )

/*++

Routine Description:

    This function create a bitmap and lock the bitmap to return a SURFOBJ

Arguments:

    pPDev   - Pointer to our PDEV

    phBmp   - Pointer the HBITMAP location to be returned for the bitmap

    cxSize  - CX size of bitmap to be created

    cySize  - CY size of bitmap to be created

    Format  - one of BMF_xxx bitmap format to be created

Return Value:

    SURFOBJ if sucessful, NULL if failed


Author:

    19-Jan-1994 Wed 16:31:50 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    SURFOBJ *pso = NULL;
    SIZEL   szlBmp;


    szlBmp.cx = cxSize;
    szlBmp.cy = cySize;

    if (*phBmp = EngCreateBitmap(szlBmp,
                                 GetBmpDelta(Format, cxSize),
                                 Format,
                                 BMF_TOPDOWN | BMF_NOZEROINIT,
                                 NULL)) {

        if (EngAssociateSurface((HSURF)*phBmp, (HDEV)pPDev->devobj.hEngine, 0)) {

            if (pso = EngLockSurface((HSURF)*phBmp)) {

                //
                // Sucessful lock it down, return it
                //

                return(pso);

            } else {

                _DBGP(1, ("\nCreateBmpSurfObj: EngLockSruface(hBmp) failed!"));
            }

        } else {

            _DBGP(1, ("\nCreateBmpSurfObj: EngAssociateSurface() failed!"));
        }

    } else {

        _DBGP(1, ("\nCreateBMPSurfObj: FAILED to create Bitmap Format=%ld, %ld x %ld",
                                        Format, cxSize, cySize));
    }

    DELETE_SURFOBJ(pso, phBmp);

    return(NULL);
}





BOOL
IsHTCompatibleSurfObj(
    PAL_DATA    *pPD,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo
    )
/*++

Routine Description:

    This function determine if the surface obj is compatble with plotter
    halftone output format.

Arguments:

    pPD         - Pointer to the PAL_DATA

    psoDst      - Our desitnation format

    psoSrc      - Source format to be checked againest

    pxlo        - engine XLATEOBJ for source -> postscript translation

Return Value:

    BOOLEAN true if the psoSrc is compatible with halftone output format, if
    return value is true, the pDrvHTInfo->pHTXB is a valid trnaslation from
    indices to 3 planes

Revision History:


--*/

{
    ULONG   *pSrcPal = NULL;
    UINT    SrcBmpFormat;
    UINT    DstBmpFormat;
    UINT    cPal;
    BOOL    Ok = TRUE;



    if ((SrcBmpFormat = (UINT)psoSrc->iBitmapFormat) >
        (DstBmpFormat = (UINT)psoDst->iBitmapFormat))
    {
        return(FALSE);
    }

    if ((!pxlo) || (pxlo->flXlate & XO_TRIVIAL))
    {
#ifdef WINNT_40
        //
        // The palette in NT4 always indexed, so if the the xlate is trivial
        // but the Source type is not indexed then we have problem
        //

        if ((pxlo) &&
            ((pxlo->iSrcType & (PAL_INDEXED      |
                                PAL_BITFIELDS    |
                                PAL_BGR          |
                                PAL_RGB)) != PAL_INDEXED))
        {
            return FALSE;
        }
#endif
        return((BOOL)(SrcBmpFormat == DstBmpFormat));
    }

    switch (DstBmpFormat)
    {
    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:

        //
        // If we cannot get the source palette memory, we will be in the
        // loop forever.
        //

        if ((pPD->wPalGdi > 0)              &&
            (pxlo->flXlate & XO_TABLE)      &&
            (cPal = (UINT)pxlo->cEntries))
        {
            if ((pSrcPal = (ULONG *)MemAlloc(cPal * sizeof(ULONG))))
            {
                ULONG   *pUL;

                XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, cPal, pSrcPal);

                //
                // Assume palette is OK unless we can't find a match
                //

                pUL = pSrcPal;
                while (cPal--)
                {
                    ULONG   *pMyPal = pPD->ulPalCol;
                    ULONG   Pal = *pUL++;
                    UINT    j = (UINT)pPD->wPalGdi;

                    do
                    {
                        if (*pMyPal++ == Pal)
                            break;
                    } while (--j);
                        //
                    // Didn't find matching color so set to FALSE
                    //
                    if (j == 0)
                    {
                        Ok = FALSE;
                        break;
                    }
                }
                MemFree(pSrcPal);
            }
        }
        else
            Ok = FALSE;

        break;

    case BMF_24BPP:

        //
        // Since device surface is 24-bpp, we will assume all source OK
        //
        break;

    default:

        _DBGP(1, ("\nUnidrv:IsHTCompatibleSurfObj: Invalid Dest format = %ld",
                                                DstBmpFormat));
        Ok = FALSE;
        break;
    }

    return(Ok);
}



BOOL
RMBitBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    PPOINTL     pptlMask,
    BRUSHOBJ   *pbo,
    PPOINTL     pptlBrush,
    ROP4        Rop4
    )

/*++

Routine Description:

    This function will try to bitblt the source to the destination

Arguments:

    per winddi spec.


Return Value:

    BOOLEAN

Author:

    17-Feb-1993 Wed 12:39:03 created  -by-  Daniel Chou (danielc)
        NOTE:   Currently only if SRCCOPY/SRCMASKCOPY will halftone


Revision History:

    01-Feb-1994 Tue 21:51:40 updated  -by-  Daniel Chou (danielc)
        Re-written, it now will handle any ROP4 which have soruces involved
        either foreground or background.  It will half-tone the source first
        if it is not compatible with unidrv destiantion format, then it passed
        the compatible source to the EngBitBlt()


    17-May-1995 Wed 23:08:15 updated  -by-  Daniel Chou (danielc)
        Updated so it will do the brush origin correctly, also speed up by
        calling EngStretchBlt directly when SRCCOPY (0xCCCC) is passed.


--*/

{
    PDEV            *pPDev;
    SURFOBJ         *psoNewSrc;
    HBITMAP         hBmpNewSrc;
    RECTL           rclNewSrc;
    RECTL           rclOldSrc;
    POINTL          BrushOrg;
    DWORD           RopBG;
    DWORD           RopFG;
    BOOL            Ok;

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

#ifndef DISABLE_NEWRULES
    if (pPDev->pbRulesArray && pPDev->dwRulesCount < (MAX_NUM_RULES-4) &&
            Rop4 == 0xF0F0 && pbo && pxlo == NULL &&
            (pco == NULL || pco->iDComplexity != DC_COMPLEX || pco->iFComplexity == FC_RECT4) &&
            ((psoDst->iBitmapFormat != BMF_24BPP &&
            pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) ||
            (psoDst->iBitmapFormat == BMF_24BPP &&
            pbo->iSolidColor == 0)))
    {
      // 
      // if complexity is rect4 then we could add up to 4 rectangles
      //
      BOOL bMore = FALSE;
      if (pco && pco->iFComplexity == FC_RECT4)
      {
            if (CLIPOBJ_cEnumStart(pco,TRUE,CT_RECTANGLES,CD_ANY,4) == -1)
                goto SkipRules;
      }
      do
      {
        PRECTL pRect= &pPDev->pbRulesArray[pPDev->dwRulesCount];
        *pRect = *prclDst;
        //
        // if clip rectangle then clip the rule
        //
        if (pco)
        {
            if (pco->iDComplexity == DC_RECT)
            {
                if (pRect->left < pco->rclBounds.left)
                    pRect->left = pco->rclBounds.left;
                if (pRect->top < pco->rclBounds.top)
                    pRect->top = pco->rclBounds.top;
                if (pRect->right > pco->rclBounds.right)
                    pRect->right = pco->rclBounds.right;
                if (pRect->bottom > pco->rclBounds.bottom)
                    pRect->bottom = pco->rclBounds.bottom;
            }
            else if (pco->iFComplexity == FC_RECT4)
            {
                ENUMRECTS eRect;
                bMore = CLIPOBJ_bEnum(pco,(ULONG)sizeof(ENUMRECTS),(ULONG *)&eRect);
                if (eRect.c != 1)
                {
                    continue;
                }
                if (pRect->left < eRect.arcl[0].left)
                    pRect->left = eRect.arcl[0].left;
                if (pRect->top < eRect.arcl[0].top)
                    pRect->top = eRect.arcl[0].top;
                if (pRect->right > eRect.arcl[0].right)
                    pRect->right = eRect.arcl[0].right;
                if (pRect->bottom > eRect.arcl[0].bottom)
                    pRect->bottom = eRect.arcl[0].bottom;
            }
        }
        if (pRect->left < pRect->right && pRect->top < pRect->bottom)
        {
            DWORD i;
            for (i = 0;i < pPDev->dwRulesCount;i++)
            {
                    PRECTL pRect2= &pPDev->pbRulesArray[i];
                    //
                    //	test if this rectangle can be combined with another
                    //
                    if (pRect->top == pRect2->top && 
                        pRect->bottom == pRect2->bottom &&
                        pRect->left <= pRect2->right &&
                        pRect->right >= pRect2->left)
                    {
                        if (pRect2->left > pRect->left)
                            pRect2->left = pRect->left;
                        if (pRect2->right < pRect->right)
                            pRect2->right = pRect->right;
                        pPDev->dwRulesCount--;
                        break;
                    }
                    else if (pRect->left == pRect2->left && 
                        pRect->right == pRect2->right &&
                        pRect->top <= pRect2->bottom &&
                        pRect->bottom >= pRect2->top)
                    {
                        if (pRect2->top > pRect->top)
                            pRect2->top = pRect->top;
                        if (pRect2->bottom < pRect->bottom)
                            pRect2->bottom = pRect->bottom;
                        pPDev->dwRulesCount--;
                        break;
                    }
            }
            pPDev->dwRulesCount++;
        }        
      } while (bMore && pPDev->dwRulesCount < MAX_NUM_RULES);
      return TRUE;
    }

SkipRules:
#endif
    //
    // Send white rectangle to printer to clear any previously
    // downloaded text or graphics for PATCOPY and SRCCOPY rops
    //
    if (Rop4 == 0xF0F0 || Rop4 == 0xCCCC)
        DrawWhiteRect(pPDev,prclDst,pco);

    //
    // We will looked if we need the source, if we do then we check if the
    // source is compatible with halftone format, if not then we halftone the
    // source and passed the new halftoned source along to the EngBitBlt()
    //

    psoNewSrc  = NULL;
    hBmpNewSrc = NULL;
    RopBG      = ROP4_BG_ROP(Rop4);
    RopFG      = ROP4_FG_ROP(Rop4);


    if (((ROP3_NEED_PAT(RopBG)) ||
         (ROP3_NEED_PAT(RopBG)))    &&
        (pptlBrush)) {

        BrushOrg = *pptlBrush;

        _DBGP(DbgBitBlt, ("\nRMBitBlt: BrushOrg for pattern PASSED IN as (%ld, %ld)",
                BrushOrg.x, BrushOrg.y));

    } else {

        BrushOrg.x =
        BrushOrg.y = 0;

        _DBGP(DbgBitBlt, ("\nRMBitBlt: BrushOrg SET by UNIDRV to (0,0), non-pattern"));
    }

    if (((ROP3_NEED_SRC(RopBG)) ||
         (ROP3_NEED_SRC(RopFG))) &&
        (!IsHTCompatibleSurfObj((PAL_DATA *)pPDev->pPalData,
            psoDst, psoSrc, pxlo)))
    {

        rclNewSrc.left   =
        rclNewSrc.top    = 0;
        rclNewSrc.right  = prclDst->right - prclDst->left;
        rclNewSrc.bottom = prclDst->bottom - prclDst->top;
        rclOldSrc.left   = pptlSrc->x;
        rclOldSrc.top    = pptlSrc->y;
        rclOldSrc.right  = rclOldSrc.left + rclNewSrc.right;
        rclOldSrc.bottom = rclOldSrc.top + rclNewSrc.bottom;

        _DBGP(DbgBitBlt, ("\nRMBitBlt: Blt Source=(%ld, %ld)-(%ld, %ld)=%ld x %ld [psoSrc=%ld x %ld]",
                        rclOldSrc.left, rclOldSrc.top,
                        rclOldSrc.right, rclOldSrc.bottom,
                        rclOldSrc.right - rclOldSrc.left,
                        rclOldSrc.bottom - rclOldSrc.top,
                        psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy));
        _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt: DestRect=(%ld, %ld)-(%ld, %ld), BrushOrg = (%ld, %ld)",
                        prclDst->left, prclDst->top,
                        prclDst->right, prclDst->bottom,
                        BrushOrg.x, BrushOrg.y));

        //
        // If we have a SRCCOPY then call EngStretchBlt directly
        //

        if (Rop4 == 0xCCCC) {

            _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt(SRCCOPY): No Clone, call EngStretchBlt() ONLY\n"));

            //
            // At here, the brush origin guaranteed at (0,0)
            //
            CheckBitmapSurface(psoDst,prclDst);
            return(EngStretchBlt(psoDst,
                                 psoSrc,
                                 psoMask,
                                 pco,
                                 pxlo,
                                 NULL,
                                 &BrushOrg,
                                 prclDst,
                                 &rclOldSrc,
                                 pptlMask,
                                 HALFTONE));
        }
        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's 0,0 minus the original location
        //

        BrushOrg.x -= prclDst->left;
        BrushOrg.y -= prclDst->top;

        _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt: BrushOrg Change to (%ld, %ld)",
                        BrushOrg.x, BrushOrg.y));

        _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt: Clone SOURCE: from (%ld, %ld)-(%ld, %ld) to (%ld, %ld)-(%ld, %ld)=%ld x %ld\n",
                            rclOldSrc.left, rclOldSrc.top,
                            rclOldSrc.right, rclOldSrc.bottom,
                            rclNewSrc.left, rclNewSrc.top,
                            rclNewSrc.right, rclNewSrc.bottom,
                            rclOldSrc.right - rclOldSrc.left,
                            rclOldSrc.bottom - rclOldSrc.top));

        if ((psoNewSrc = CreateBitmapSURFOBJ(pPDev,
                                             &hBmpNewSrc,
                                             rclNewSrc.right,
                                             rclNewSrc.bottom,
                                             psoDst->iBitmapFormat))    &&
            (EngStretchBlt(psoNewSrc,       // psoDst
                           psoSrc,          // psoSrc
                           NULL,            // psoMask
                           NULL,            // pco
                           pxlo,            // pxlo
                           NULL,            // pca
                           &BrushOrg,       // pptlBrushOrg
                           &rclNewSrc,      // prclDst
                           &rclOldSrc,      // prclSrc
                           NULL,            // pptlmask
                           HALFTONE))) {

            //
            // If we cloning sucessful then the pxlo will be NULL because it
            // is identities for the halftoned surface to our engine managed
            // bitmap
            //

            psoSrc     = psoNewSrc;
            pptlSrc    = (PPOINTL)&(rclNewSrc.left);
            pxlo       = NULL;
            BrushOrg.x =
            BrushOrg.y = 0;

        }
        else {
            _DBGP(1, ("\nUnidrv:RMBitblt: Clone Source to halftone FAILED"));
        }
    }
    
    //
    // Check if we need to clear the bitmap surface. If it hasn't been cleared
    // but we are only going to draw a white region on it we can skip the white
    // PATCOPY bitblt.
    //
    if (!(pPDev->fMode & PF_SURFACE_USED) &&
            Rop4 == 0xF0F0 && pbo &&
#ifndef DISABLE_NEWRULES
            (pPDev->pbRulesArray == NULL || pPDev->dwRulesCount == 0) &&
#endif            
            ((psoDst->iBitmapFormat != BMF_24BPP &&
              pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex) ||
             (psoDst->iBitmapFormat == BMF_24BPP &&
              pbo->iSolidColor == 0x00FFFFFF)))
    {
        _DBGP (DbgBitBlt, ("\nUnidrv:RMBitblt: Skipping white bitblt\n"));
        Ok = TRUE;
    }
    else
    {
        // test whether to remap rops for 8bpp mono mode
        if (pPDev->fMode2 & PF2_INVERTED_ROP_MODE)
        {
            Rop4 = InvertROPs(Rop4);
        }
        
        // set dirty surface flag
        CheckBitmapSurface(psoDst,prclDst);

        Ok = EngBitBlt(psoDst,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       pptlSrc,
                       pptlMask,
                       pbo,
                      &BrushOrg,
                       Rop4);
    }
    DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
    return(Ok);
}




BOOL
RMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            BltMode
    )

/*++

Routine Description:

    This function do driver's stretch bitblt, it actually call HalftoneBlt()
    to do the actual work

Arguments:

    per above


Return Value:

    BOOLEAN

Author:

    24-Mar-1992 Tue 14:06:18 created  -by-  Daniel Chou (danielc)


Revision History:

    27-Jan-1993 Wed 07:29:00 updated  -by-  Daniel Chou (danielc)
        clean up, so gdi will do the work, we will always doing HALFTONE mode


--*/

{
    PDEV    *pPDev;           /*  Our main PDEV */


    UNREFERENCED_PARAMETER(BltMode);


    pPDev = (PDEV *)psoDest->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    // test whether we need to clear any device text that
    // may be under the graphics
    //
    DrawWhiteRect(pPDev,prclDest,pco);

    // set dirty surface flag since we're drawing in it
    CheckBitmapSurface(psoDest,prclDest);
    return(EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         HALFTONE));
}


BOOL
RMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode,
    BRUSHOBJ        *pbo,
    DWORD           rop4
    )

/*++

Routine Description:

    This function do driver's stretch bitblt, it actually call HalftoneBlt()
    to do the actual work

Arguments:

    per above


Return Value:

    BOOLEAN

--*/

{
#ifndef WINNT_40
    PDEV    *pPDev;           /*  Our main PDEV */

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;


    // test whether we need to clear any device text that
    // may be under the graphics, rop must be SRCCOPY
    //
    if (rop4 == 0xCCCC)
        DrawWhiteRect(pPDev,prclDst,pco);

    // test whether to remap rops for 8bpp mono mode
    //
    if (pPDev->fMode2 & PF2_INVERTED_ROP_MODE)
    {
        rop4 = InvertROPs(rop4);
    }

    //
    // GDI doesn't support Halftoning for StretchBltROP unless the rop is SRCCOPY
    // Therefore to fix bug 36192, we will create a new surface to stretchblt with 
    // halftone and then will bitblt the result to the actual destination with the rop4
    //
#ifndef DISABLE_SBR_GDIWORKAROUND
    if (rop4 != 0xCCCC && psoMask == NULL &&
            ROP3_NEED_SRC(ROP4_FG_ROP(rop4)) && 
            psoDst->iBitmapFormat <= BMF_4BPP && psoSrc->iBitmapFormat >= BMF_4BPP)
    {
        SURFOBJ         *psoNewSrc;
        HBITMAP         hBmpNewSrc;
        RECTL           rclNewSrc;
        POINTL          BrushOrg;
        BOOL            Ok;
        DWORD           xHTOffset=0;
        DWORD           yHTOffset=0;

//        DbgPrint("StretchBltROP: rop4=%x,iFormat=%d->%d, Dest=%d,%d\n",rop4,psoSrc->iBitmapFormat,psoDst->iBitmapFormat,prclDst->left,prclDst->top);
        //
        // determine offset into temporary surface to get halftone patterns to align
        //
        if (pPDev->dwHTPatSize > 0)
        {
            xHTOffset = prclDst->left % pPDev->dwHTPatSize;
            yHTOffset = prclDst->top % pPDev->dwHTPatSize;
        }

        rclNewSrc.left   =
        rclNewSrc.top    = 0;
        rclNewSrc.right  = (prclDst->right - prclDst->left) + xHTOffset;
        rclNewSrc.bottom = (prclDst->bottom - prclDst->top) + yHTOffset;
        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's 0,0 minus the original location
        //
        BrushOrg.x = -prclDst->left;
        BrushOrg.y = -prclDst->top;

        if ((psoNewSrc = CreateBitmapSURFOBJ(pPDev,
                                             &hBmpNewSrc,
                                             rclNewSrc.right,
                                             rclNewSrc.bottom,
                                             psoDst->iBitmapFormat)))
        {
            rclNewSrc.left += xHTOffset;
            rclNewSrc.top += yHTOffset;
            if ((EngStretchBlt(psoNewSrc,       // psoDst
                           psoSrc,          // psoSrc
                           NULL,            // psoMask
                           NULL,            // pco
                           pxlo,            // pxlo
                           NULL,            // pca
                           pptlBrushOrg,    // pptlBrushOrg
                           &rclNewSrc,      // prclDst
                           prclSrc,         // prclSrc
                           NULL,            // pptlmask
                           HALFTONE))) 
            {

                //
                // If we cloning sucessful then the pxlo will be NULL because it
                // is identities for the halftoned surface to our engine managed
                // bitmap
                //
                PPOINTL pptlSrc    = (PPOINTL)&(rclNewSrc.left);
                pxlo       = NULL;
                BrushOrg.x =
                BrushOrg.y = 0;

                // set dirty surface flag
                CheckBitmapSurface(psoDst,prclDst);

                Ok = EngBitBlt(psoDst,
                       psoNewSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       pptlSrc,
                       pptlMask,
                       pbo,
                      &BrushOrg,
                       rop4);
                DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
                if (!Ok)
                    _DBGP(1,("RMStretchBltROP: Clone bitblt failed\n"));
                return Ok;
            }
            else {
                _DBGP(1,("RMStretchBltROP: Clone Source to halftone FAILED\n"));
            }
        }
        DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
    }
#endif        

    // set dirty surface flag since we're drawing in it
    CheckBitmapSurface(psoDst,prclDst);
    return(EngStretchBltROP(psoDst,
                            psoSrc,
                            psoMask,
                            pco,
                            pxlo,
                            pca,
                            pptlBrushOrg,
                            prclDst,
                            prclSrc,
                            pptlMask,
                            HALFTONE,
                            pbo,
                            rop4));
#else
    return TRUE;
#endif
}

BOOL
RMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
/*++

Routine Description:

    Implementation of DDI entry point DrvPaint.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface on which to draw
    pco - Limits the area to be modified on the Dstination
    pbo - Points to a BRUSHOBJ which defined the pattern and colors to fill with
    pptlBrushOrg - Specifies the origin of the halftone brush
    mix - Defines the foreground and background raster operations to use for
          the brush

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
#define MIXCOPYPEN (R2_COPYPEN | (R2_COPYPEN << 8))
#define MIXWHITE   (R2_WHITE | (R2_WHITE << 8))

    PDEV *pPDev = (PDEV *)pso->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    //
    // Send white rectangle to printer to clear any previously
    // downloaded text or graphics for COPYPEN or WHITE rop2's
    //
    if ((mix == MIXCOPYPEN || mix == MIXWHITE) && pco && pco->iDComplexity == DC_RECT)
    {
        RECTL rclDst;
        rclDst.left = pco->rclBounds.left;
        rclDst.top = pco->rclBounds.top;
        rclDst.right = pco->rclBounds.right;
        rclDst.bottom = pco->rclBounds.bottom;
        DrawWhiteRect(pPDev,&rclDst,pco);
    }
    //
    // Check whether to erase surface
    //
    CheckBitmapSurface(pso,&pco->rclBounds);

    //
    // Call GDI to do the paint function
    //
    return EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
}

BOOL
RMCopyBits(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   POINTL   *pptlSrc
   )

/*++

Routine Description:

    Convert between two bitmap formats

Arguments:

    Per Engine spec.

Return Value:

    BOOLEAN


Author:

    24-Jan-1996 Wed 16:08:57 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEV    *pPDev;           /*  Our main PDEV */

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    // Handle the case which has to be passed to Engine.
    //
    if (IsHTCompatibleSurfObj((PAL_DATA *)pPDev->pPalData,
            psoDst, psoSrc, pxlo)  )
    {
        DrawWhiteRect(pPDev,prclDst,pco);
        CheckBitmapSurface(psoDst,prclDst);
        return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
    }
    else {

        POINTL  ptlBrushOrg;
        RECTL   rclSrc;
        RECTL   rclDst;

        rclDst        = *prclDst;
        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        //
        // Validate that we only BLT the available source size
        //

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy)) {

            WARNING(("RMCopyBits: Engine passed SOURCE != DEST size, CLIP IT"));

            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;

            rclDst.right  = (LONG)(rclSrc.right - rclSrc.left + rclDst.left);
            rclDst.bottom = (LONG)(rclSrc.bottom - rclSrc.top + rclDst.top);
        }

        ptlBrushOrg.x =
        ptlBrushOrg.y = 0;

        _DBGP(DbgCopyBits, ("\nUnidrv!RMCopyBits: Format Src=%ld, Dest=%ld, Halftone it\n",
                                    psoSrc->iBitmapFormat, psoDst->iBitmapFormat));
        _DBGP(DbgCopyBits, ("\nUnidrv!RMCopyBits: Source Size: (%ld, %ld)-(%ld, %ld) = %ld x %ld\n",
                                rclSrc.left, rclSrc.top, rclSrc.right, rclSrc.bottom,
                                rclSrc.right - rclSrc.left, rclSrc.bottom - rclSrc.top));
        _DBGP(DbgCopyBits, ("\nUnidrv!RMCopyBits: Dest Size: (%ld, %ld)-(%ld, %ld) = %ld x %ld\n",
                                rclDst.left, rclDst.top, rclDst.right, rclDst.bottom,
                                rclDst.right - rclDst.left, rclDst.bottom - rclDst.top));

        return(DrvStretchBlt(psoDst,
                             psoSrc,
                             NULL,
                             pco,
                             pxlo,
                             NULL,
                             &ptlBrushOrg,
                             &rclDst,
                             &rclSrc,
                             NULL,
                             HALFTONE));
    }
}



ULONG
RMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

/*++

Routine Description:

    This is the hooked brush creation function, it ask CreateHalftoneBrush()
    to do the actual work.


Arguments:

    dhpdev      - DHPDEV passed, it is our pDEV

    iMode       - Not used

    rgbColor    - Solid rgb color to be used

    pulDither   - buffer to put the halftone brush.

Return Value:

    BOOLEAN

Author:

    24-Mar-1992 Tue 14:53:36 created  -by-  Daniel Chou (danielc)


Revision History:

    27-Jan-1993 Wed 07:29:00 updated  -by-  Daniel Chou (danielc)
        clean up, so gdi will do the work.



--*/

{
    #ifndef WINNT_40 //NT 5.0
    UNREFERENCED_PARAMETER(dhpdev);
    UNREFERENCED_PARAMETER(iMode);
    UNREFERENCED_PARAMETER(rgbColor);
    UNREFERENCED_PARAMETER(pulDither);

    return(DCR_HALFTONE);

    #else // NT 4.0

    DWORD   RetVal;

    UNREFERENCED_PARAMETER(dhpdev);
    UNREFERENCED_PARAMETER(iMode);
    UNREFERENCED_PARAMETER(pulDither);

    EngAcquireSemaphore(hSemBrushColor);

    if (pBrushSolidColor) {

        *pBrushSolidColor = (DWORD)(rgbColor & 0x00FFFFFF);

        _DBGP(DbgDitherColor, ("\nDrvDitherColor(BRUSH=%08lx)\t\t",
                            *pBrushSolidColor));

        pBrushSolidColor  = NULL;
        RetVal            = DCR_SOLID;

    } else {

        _DBGP(DbgDitherColor, ("\nDrvDitherColor(HALFTONE=%08lx)\t\t", rgbColor));

        RetVal = DCR_HALFTONE;
    }

    EngReleaseSemaphore(hSemBrushColor);

    return(RetVal);

    #endif //!WINNT_40
}

BOOL
RMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            BltMode
    )

/*++

Routine Description:

    This function does driver's plgblt.

Arguments:

    per above


Return Value:

    BOOLEAN

--*/

{
    PDEV    *pPDev;           /*  Our main PDEV */

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    //
    // test for no rotation, as this is another case the GDI EngPlgBlt call fails
    // bug #336711, 3/8/01 
    //
    if (pptfx[0].x == pptfx[2].x && pptfx[0].y == pptfx[1].y && pptfx[0].y < pptfx[2].y)
    {
        RECTL rclDst;
        rclDst.top = pptfx[0].y >> 4;
        rclDst.left = pptfx[0].x >> 4;
        rclDst.bottom = pptfx[2].y >> 4;
        rclDst.right = pptfx[1].x >> 4;

        // blt surface into destination
        //
        CheckBitmapSurface(psoDst,&rclDst);
        return EngStretchBlt(psoDst,           // psoDst
                           psoSrc,             // psoSrc
                           psoMask,            // psoMask
                           pco,                // pco
                           pxlo,               // pxlo
                           pca,                // pca
                           pptlBrushOrg,       // pptlBrushOrg
                           &rclDst,            // prclDst
                           prclSrc,            // prclSrc
                           pptlMask,               // pptlmask
                           HALFTONE); 
    }
    // test for 90/270 rotation as GDI's EngPlgBlt sometimes fails if it has to do
    // both rotation and scaling. In those case this function will rotate the
    // data to an intermediate surface before scaling to the destination surface.
    //
    if (psoMask == NULL && pptfx[0].x == pptfx[1].x && pptfx[0].y == pptfx[2].y &&
        (pPDev->pdmPrivate->iLayout == ONE_UP || psoSrc->iBitmapFormat == BMF_1BPP))
    {
        SURFOBJ         *psoNewSrc = NULL;
        HBITMAP         hBmpNewSrc = NULL;
        RECTL           rclNewSrc;
        BOOL iRet;
        RECTL rclDst;
        POINTFIX pFix[3];            

        rclNewSrc.left   =
        rclNewSrc.top    = 0;
        rclNewSrc.bottom = (prclSrc->right - prclSrc->left);
        rclNewSrc.right = (prclSrc->bottom - prclSrc->top);

        // rotate 90 degrees
        //
        if (pptfx[2].x < pptfx[0].x)
        {
                pFix[0].y = pFix[2].y = 0;
                pFix[0].x = pFix[1].x = (rclNewSrc.right << 4);
                pFix[2].x = 0;
                pFix[1].y = (rclNewSrc.bottom << 4);

                rclDst.top = pptfx[2].y >> 4;
                rclDst.left = pptfx[2].x >> 4;
                rclDst.bottom = pptfx[1].y >> 4;
                rclDst.right = pptfx[1].x >> 4;
        }
        // rotate 270 degrees
        // 
        else
        {
                pFix[0].y = pFix[2].y = (rclNewSrc.bottom << 4);
                pFix[0].x = pFix[1].x = 0;
                pFix[2].x = (rclNewSrc.right << 4);
                pFix[1].y = 0;

                rclDst.top = pptfx[1].y >> 4;
                rclDst.left = pptfx[1].x >> 4;
                rclDst.bottom = pptfx[2].y >> 4;
                rclDst.right = pptfx[2].x >> 4;
        }
        // Only enable EngPlgBlt workaround when scaling up. EngPlgBlt appears to work
        // ok when scaling down and it is more efficient in that mode. This also fixes
        // the rounding error associated with scaling down (bug #356514).
        //
        if ((rclNewSrc.right < abs(rclDst.right - rclDst.left) &&
            rclNewSrc.bottom < abs(rclDst.bottom - rclDst.top)) ||
            psoSrc->iBitmapFormat == BMF_1BPP)
        {
/*        
#if DBG
            DbgPrint("PlgBlt:Src=L%d,T%d,R%d,B%d;Dst=L%d,T%d,R%d,B%d\n",
                prclSrc->left,prclSrc->top,prclSrc->right,prclSrc->bottom,
                rclDst.left,rclDst.top,rclDst.right,rclDst.bottom);
#endif            
*/
            // Create an intermediate surface and rotate the source data into 
            // the surface with no scaling.
            //        
            if ((psoNewSrc = CreateBitmapSURFOBJ(pPDev,
                                             &hBmpNewSrc,
                                             rclNewSrc.right,
                                             rclNewSrc.bottom,
                                             psoSrc->iBitmapFormat)))
            {
                if ((iRet = EngPlgBlt(psoNewSrc,
                         psoSrc,
                         psoMask,
                         NULL,
                         NULL,
                         pca,
                         pptlBrushOrg,
                         pFix,
                         prclSrc,
                         pptlMask,
                         BltMode)))
                {        
                    // blt new surface into destination
                    //
                    if (psoSrc->iBitmapFormat != BMF_1BPP)
                    {
                        BltMode = HALFTONE;
                    }
                    CheckBitmapSurface(psoDst,&rclDst);
                    iRet = EngStretchBlt(psoDst,       // psoDst
                           psoNewSrc,          // psoSrc
                           NULL,            // psoMask
                           pco,                // pco
                           pxlo,               // pxlo
                           pca,                // pca
                           pptlBrushOrg,       // pptlBrushOrg
                           &rclDst,            // prclDst
                           &rclNewSrc,         // prclSrc
                           NULL,               // pptlmask
                           BltMode); 
                }
                DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
                return iRet;
            }
        }
    }
    
    // set dirty surface flag since we're drawing in it
    CheckBitmapSurface(psoDst,NULL);
    return(EngPlgBlt(psoDst,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         pptfx,
                         prclSrc,
                         pptlMask,
                         HALFTONE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\cmnhdr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cmnhdr.h

Abstract:

    Vector module common header file.

Environment:

        Windows Whistler

Revision History:

    03/23/00 
        Created it.

--*/

#ifndef _CMNHDR_H_
#define _CMNHDR_H_

#ifdef __cplusplus

//
// Color ID
//
#define NOT_SOLID_COLOR     0xFFFFFFFF

//
// Hatch Pattern ID
// 
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

//
// PCL6 real32 values
//
#define real32_IEEE_1_0F    ((FLOATL)0x3F800000)
#define real32_IEEE_10_0F   ((FLOATL)0x41200000)

//
// floating point numbers
//
#if defined(_X86_) && !defined(USERMODE_DRIVER)
#define FLOATL_IEEE_0_005MF ((FLOATL)0xbba3d70a)
#define FLOATL_IEEE_0_005F  ((FLOATL)0x3ba3d70a)
#define FLOATL_IEEE_0_0F    ((FLOATL)0x00000000)
#define FLOATL_IEEE_1_0F    ((FLOATL)0x3F800000)
#else
#define FLOATL_IEEE_0_005MF -0.005f
#define FLOATL_IEEE_0_005F   0.005f
#define FLOATL_IEEE_0_0F     0.0f
#define FLOATL_IEEE_1_0F     1.0f
#endif

//
// Misc macros
//
#define SWAPW(a)        (USHORT)(((BYTE)((a) >> 8)) | ((BYTE)(a) << 8))
#define SWAPDW(a)       (ULONG) ((((((a) >> 24) & 0x000000ff)  | \
                                (((((a) >> 8) & 0x0000ff00)   | \
                                ((((a) << 8) & 0x00ff0000)    | \
                                (((a) << 24) & 0xff000000)))))))

#define SIGNATURE( sig )                                                \
public:                                                                 \
    class TSignature {                                                  \
    public:                                                             \
        DWORD _Signature;                                               \
        TSignature() : _Signature( SWAPDW( sig )) { }          \
    };                                                                  \
    TSignature _Signature;                                              \
                                                                        \
    BOOL bSigCheck() const                                              \
    {   return _Signature._Signature == SWAPDW( sig ); }       \
private:

#endif // __cplusplus
#endif // _CMNHDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\glyfcach.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     glfcach.h

Abstract:

    PCL XL glyph cache

Environment:

    Windows Whistler

Revision History:

    11/09/00
      Created it.

--*/
#ifndef _GLFCACH_H_
#define _GLFCACH_H_

typedef struct _GLYPHID
{
    ULONG    ulGlyphID;
    struct _GLYPHID *pPrevGID;
    struct _GLYPHID *pNextGID;
} GLYPHID, *PGLYPHID;

typedef struct _GLYPHTABLE
{
    WORD  wGlyphNum;
    WORD  wFontID;
    DWORD dwAvailableEntries;
    struct _GLYPHID *pFirstGID;
    struct _GLYPHID *pGlyphID;
} GLYPHTABLE, *PGLYPHTABLE;

class XLGlyphCache
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'glyf' )

public:

    //
    // Constructure/Destructure
    //
    XLGlyphCache::
    XLGlyphCache( VOID );

    XLGlyphCache::
    ~XLGlyphCache( VOID );

    //
    // Functions
    //
    HRESULT XLGlyphCache::XLCreateFont(ULONG ulFontID);
    HRESULT XLGlyphCache::AddGlyphID(ULONG ulFontID, ULONG ulGlyphID);
    ULONG   XLGlyphCache::UlSearchFontID( ULONG ulFontID);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    #define INIT_ARRAY 8
    #define ADD_ARRAY  8
    #define INIT_GLYPH_ARRAY 16
    #define ADD_GLYPH_ARRAY  16

    ULONG        m_ulNumberOfFonts;
    ULONG        m_ulNumberOfArray;
    PULONG       m_paulFontID;
    PGLYPHTABLE *m_ppGlyphTable;

    VOID     FreeAll(VOID);
    HRESULT  IncreaseArray(VOID);
    PGLYPHID PSearchGlyph( WORD wSearchRange, BOOL bForward, PGLYPHID pGlyphID);
    HRESULT  IncreaseGlyphArray(ULONG ulFontID);
};

#endif // _GLFCACH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\bmpcvt.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bmpcvt.cpp

Abstract:

    Bitmap conversion object

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "xlbmpcvt.h"

BPP
NumToBPP(
    ULONG ulBPP)
/*++

Routine Description:

    Converts Bits per pixel to BPP enum.

Arguments:

    Bits per pixel.

Return Value:

    BPP enum

Note:

    BPP enum is defined in xlbmpcvt.h.

--*/
{
    BPP Bpp;

    switch (ulBPP)
    {
    case 1:
        Bpp = e1bpp;
        break;
    case 4:
        Bpp = e4bpp;
        break;
    case 8:
        Bpp = e8bpp;
        break;
    case 16:
        Bpp = e16bpp;
        break;
    case 24:
        Bpp = e24bpp;
        break;
    case 32:
        Bpp = e32bpp;
        break;
    }

    return Bpp;
}

ULONG
UlBPPtoNum(
    BPP Bpp)
/*++

Routine Description:

    Converts BPP enum to bits per pixel.

Arguments:

    BPP enum

Return Value:

    Bits per pixel.

Note:

    BPP enum is defined in xlbmpcvt.h.

--*/
{
    ULONG ulRet;

    switch (Bpp)
    {
    case e1bpp:
        ulRet = 1;
        break;
    case e4bpp:
        ulRet = 4;
        break;
    case e8bpp:
        ulRet = 8;
        break;
    case e16bpp:
        ulRet = 16;
        break;
    case e24bpp:
        ulRet = 24;
        break;
    case e32bpp:
        ulRet = 32;
        break;
    }

    return ulRet;
}


//
// Constructor/Destructor
//

BMPConv::
BMPConv( VOID ):
/*++

Routine Description:

   BMPConv constructor

Arguments:

Return Value:

Note:

    Initializes values. There is no memory allocation.

--*/
    m_flags(0),
    m_dwOutputBuffSize(0),
    m_dwRLEOutputBuffSize(0),
    m_OddPixelStart(eOddPixelZero),
    m_FirstBit(eBitZero),
    m_pxlo(NULL),
    m_pubOutputBuff(NULL),
    m_pubRLEOutputBuff(NULL)

{
#if DBG
    SetDbgLevel(DBG_WARNING);
#endif

    XL_VERBOSE(("BMPConv: Ctor\n"));
}

BMPConv::
~BMPConv( VOID )
/*++

Routine Description:

    BMPConv destructor

Arguments:

Return Value:

Note:

    m_pubOutputBuff and m_pubRLEOutputBuff are allocaed ConvertBMP.
    ConvertBMP is scaline base bitmap conversion function.

--*/
{
    XL_VERBOSE(("BMPConv: Dtor\n"));

    if (m_pubOutputBuff)
        MemFree(m_pubOutputBuff);

    if  (m_pubRLEOutputBuff)
        MemFree(m_pubRLEOutputBuff);
}

//
// Public functions
//

#if DBG
VOID
BMPConv::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

BOOL
BMPConv::
BSetInputBPP(
    BPP InputBPP)
/*++

Routine Description:

    Sets source bitmap BPP in BMPConv.

Arguments:

    Source bitmap BPP enum (bits per pixel)

Return Value:

    TRUE if succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetInputBPP\n"));

    m_flags |= BMPCONV_SET_INPUTBPP;
    m_InputBPP = InputBPP;
    return TRUE;
}

BOOL
BMPConv::
BSetOutputBPP(
    BPP OutputBPP)
/*++

Routine Description:

    Sets destination bimtap BPP in BMPConv.

Arguments:

    Destination bitmap BPP enum

Return Value:

    TRUE if succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetOutputBPP\n"));

    m_OutputBPP = OutputBPP;
    return TRUE;
}

BOOL
BMPConv::
BSetOutputBMPFormat(
    OutputFormat BitmapFormat)
/*++

Routine Description:

    Sets output bitmap format (GrayScale/Palette/RGB/CMYK).

Arguments:

    OutputFormat enum.

Return Value:

    TRUE if succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetOutputBMPFormat\n"));

    m_OutputFormat = BitmapFormat;
    return TRUE;
}

BOOL
BMPConv::
BSetRLECompress(
    BOOL bRLEOn)
/*++

Routine Description:

    Enable/Disable RLE compression.

Arguments:

    Boolean value to enable RLE.

Return Value:

    TRUE if it succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetRLECompress\n"));

    if (bRLEOn)
        m_flags |= BMPCONV_RLE_ON;
    else
        m_flags &= ~BMPCONV_RLE_ON;

    return TRUE;
}

BOOL
BMPConv::
BGetRLEStatus(VOID)
/*++

Routine Description:

   Returns RLE on/off.

Arguments:

Return Value:

    TRUE if RLE is on.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BGetRLEStatus\n"));

    return (m_flags & BMPCONV_RLE_ON)?TRUE:FALSE;
}

BOOL
BMPConv::
BSetXLATEOBJ(
    XLATEOBJ *pxlo)
/*++

Routine Description:

    Sets XLATEOBJ in BMPConv.

Arguments:

    A pointer to XLATEOBJ.

Return Value:

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetXLATEOBJ\n"));

    //
    // XL_ERRor check
    //
    if (NULL == pxlo)
    {
        XL_ERR(("BMPConv::BSetXLATEOBJ: an invalid parameter.\n"));
        return FALSE;
    }

    m_pxlo = pxlo;

    m_flags |= DwCheckXlateObj(pxlo,  m_InputBPP);
    return TRUE;
}

PBYTE
BMPConv::
PubConvertBMP(
    PBYTE pubSrc,
    DWORD dwcbSrcSize)
/*++

Routine Description:

    Scaline base bitmap conversion function.

Arguments:

    pubSrc - a pointer to the source bitmap.
    dwcbSrcSize - the size of the source bitmap.

Return Value:

    A pointer to the destination bitmap.

Note:

    The pointer to the destination bitmap is stored in BMPConv.
    It is going to be freed in the BMPConv destructor.

--*/
{
    DWORD dwcbDstSize, dwInputBPP;
    LONG lWidth, lHeight;
    PBYTE pubRet = NULL;
    
    XL_VERBOSE(("BMPConv: BConvertBMP\n"));

    //
    // Calculate the number of pixels and the size of dest buffer
    // Output data has to be DWORD aligned on PCL-XL.
    //
    dwInputBPP = UlBPPtoNum(m_InputBPP);
    lWidth = ((dwcbSrcSize << 3 ) + dwInputBPP - 1) / dwInputBPP;
    dwcbDstSize = ((UlBPPtoNum(m_OutputBPP) * lWidth + 31 ) >> 5 ) << 2;

    //
    // Allocate destination buffer
    //
    if (NULL == m_pubOutputBuff)
    {
        m_pubOutputBuff = (PBYTE)MemAlloc(dwcbDstSize);
        m_dwOutputBuffSize = dwcbDstSize;
        if (NULL == m_pubOutputBuff)
        {
            XL_ERR(("BMPConv::PubConvertBMP: m_pubOutputBuff[0x%x] allocation failed..\n", dwcbDstSize));
            return NULL;
        }
    }

    //
    // Allocate RLE destination buffer if RLE is on.
    //
    if (m_flags & BMPCONV_RLE_ON && NULL == m_pubRLEOutputBuff)
    {
        dwcbDstSize *= 3;
        m_pubRLEOutputBuff = (PBYTE)MemAlloc(dwcbDstSize);
        m_dwRLEOutputBuffSize = dwcbDstSize;

        if (NULL == m_pubRLEOutputBuff)
        {
            XL_ERR(("BMPConv::PubConvertBMP: m_pubOutputBuff[0x%x] allocation failed..\n", dwcbDstSize));
            MemFree(m_pubOutputBuff);
            return NULL;
        }

    }

    //
    // Converrt source bitmap to destination.
    // Source and Destination format is set by SetXXX functions.
    //
    if (BConversionProc(pubSrc, (dwcbSrcSize * 8 + dwInputBPP - 1) / dwInputBPP))
    {
        if (m_flags & BMPCONV_RLE_ON)
        {
            if (BCompressRLE())
                pubRet = m_pubRLEOutputBuff;
            else
                pubRet = NULL;
        }
        else
            pubRet = m_pubOutputBuff;
    }
    else
        pubRet =  NULL;

    return pubRet;
}

BOOL
BMPConv::
BCompressRLE(
    VOID)
/*++

Routine Description:

    RLE compression function

Arguments:

Return Value:

   TRUE if it succeeded.

Note:

--*/
{
    DWORD dwSrcSize, dwDstSize, dwCount, dwErr;
    PBYTE pubSrcBuff, pubDstBuff, pubLiteralNum;
    BYTE  ubCurrentData;
    BOOL  bLiteral;

    XL_VERBOSE(("BMPConv: BCompressRLE\n"));

    if ( NULL == m_pubRLEOutputBuff ||
         NULL == m_pubOutputBuff     )
        return FALSE;

    //
    //
    // PCL XL Run Length Encoding Compression Method (eRLECompression)
    // The PCL XL RLE compression method employs control bytes followed by data 
    // bytes. Each
    // control byte in the compressed data sequence is a signed, two's 
    // complement byte.
    // If bit 7 of the control byte is zero (0 <= control byte <= 127) the bytes
    // following are literal.
    // Literal bytes are simply uncompressed data bytes. The number of literal
    // bytes following a control
    // byte is one plus the value of the control byte. Thus, a control byte of 0
    // means 1 literal byte
    // follows; a control byte of 6 means 7 literal bytes follow; and so on.
    // If bit 7 of the control byte is 1 (-127 <= control byte <= -1), the byte 
    // following the control byte
    // will occur two or more times as decompressed data. A byte following a
    // control byte in this range
    // is called a repeat byte. The control byte39s absolute value plus one is
    // the number of times the byte
    // following will occur in the decompressed sequence of bytes. For example, 
    // a control byte of -5
    // means the subsequent byte will occur 6 times as decompressed data.
    // A control byte of -128 is ignored and is not included in the decompressed
    // data. The byte
    // following a control byte of 128 is treated as the next control byte.
    // It is more efficient to code two consecutive identical bytes as a
    // repeated byte, unless these bytes
    // are preceded and followed by literal bytes. Three-byte repeats should
    // always be encoded using a
    // repeat control byte.
    //
    // Literal byte <= 127
    // Repeated byte <= 128
    //

    bLiteral = FALSE;
    dwCount = 1;
    dwSrcSize = m_dwOutputBuffSize;

    pubSrcBuff = m_pubOutputBuff;
    pubDstBuff = m_pubRLEOutputBuff;
    m_dwRLEOutputDataSize = 0;

    while (dwSrcSize > 0 && m_dwRLEOutputDataSize + 2 < m_dwRLEOutputBuffSize)
    {
        ubCurrentData = *pubSrcBuff++;
        while (dwSrcSize > dwCount          &&
               ubCurrentData == *pubSrcBuff &&
               dwCount < 128                 )
        {
            dwCount++;
            pubSrcBuff++;
        }

        if (dwCount > 1)
        {
            bLiteral = FALSE;
            *pubDstBuff++ = 1-(char)dwCount;
            *pubDstBuff++ = ubCurrentData;
            m_dwRLEOutputDataSize += 2;
        }
        else
        {
            if (bLiteral)
            {
                (*pubLiteralNum) ++;
                *pubDstBuff++ = ubCurrentData;
                m_dwRLEOutputDataSize ++;
                if (*pubLiteralNum == 127)
                {
                    bLiteral = FALSE;
                }
            }
            else
            {
                bLiteral = TRUE;
                pubLiteralNum = pubDstBuff;
                *pubDstBuff++ = 0;
                *pubDstBuff++ = ubCurrentData;
                m_dwRLEOutputDataSize += 2;
            }
        }

        dwSrcSize -= dwCount;
        dwCount = 1;
    }

    if (dwSrcSize == 0)
        return TRUE;
    else
        return FALSE;
}

DWORD
BMPConv::
DwGetDstSize(VOID)
/*++

Routine Description:

    Returns the size of destination bitmap.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("BMPConv: DwGetDstSize\n"));

    if (m_flags & BMPCONV_RLE_ON)
        return m_dwRLEOutputDataSize;
    else
        return m_dwOutputBuffSize;
}

//
// Scanline basis DIB conversion functions
//


BOOL
BMPConv::
BCopy(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. Simple copy for 1BPP, 4,8BPP palette image.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD  dwByteIndex, dwBitIndex, dwSrcBytes, dwSrcRemainderBits;

    XL_VERBOSE(("BMPConv: BCopy\n"));


    if (m_InputBPP == e8bpp || m_FirstBit == eBitZero)
    {
        dwSrcBytes = (dwSrcPixelNum * (DWORD)UlBPPtoNum(m_InputBPP) + 7) >> 3;

        CopyMemory(m_pubOutputBuff, pubSrc, dwSrcBytes);
    }
    else
    {
        //
        // m_InputBPP is either 1 or 4, m_FirstBit is in [1,7].
        //

        ASSERT((m_InputBPP == e1bpp) || (m_InputBPP == e4bpp));
        ASSERT(m_FirstBit != eBitZero);

        dwSrcBytes = (dwSrcPixelNum * (DWORD)UlBPPtoNum(m_InputBPP)) >> 3;
        dwSrcRemainderBits = (dwSrcPixelNum * (DWORD)UlBPPtoNum(m_InputBPP)) % 8;

        //
        // Now dwSrcBytes is the number of full bytes we need to copy from the source,
        // dwSrcRemainderBits is the number of remaining bits after dwSrcBytes number
        // of bytes in the source we need to copy.
        //
        // We first copy the full bytes from source.
        //

        for (dwByteIndex = 0; dwByteIndex < dwSrcBytes; dwByteIndex++)
        {
            //
            // Compose the destination byte from two adjacent source bytes.
            //

            m_pubOutputBuff[dwByteIndex] = (BYTE)(pubSrc[dwByteIndex]   << ((DWORD)m_FirstBit)) |
                                  (BYTE)(pubSrc[dwByteIndex+1] >> (8 - (DWORD)m_FirstBit));
        }

        if (dwSrcRemainderBits)
        {
            //
            // Now copy the remaining source bits. There are 2 cases:
            //
            // (1) the remaining source bits are in 1 byte;
            // (2) the remaining source bits run across 2 bytes;
            //

            if (((DWORD)m_FirstBit + dwSrcRemainderBits - 1) < 8)
                m_pubOutputBuff[dwByteIndex] = (BYTE)(pubSrc[dwByteIndex] << ((DWORD)m_FirstBit));
            else
                m_pubOutputBuff[dwByteIndex] = (BYTE)(pubSrc[dwByteIndex]   << ((DWORD)m_FirstBit)) |
                                      (BYTE)(pubSrc[dwByteIndex+1] >> (8 - (DWORD)m_FirstBit));
        }
    }

    return TRUE;
}

BOOL
BMPConv::
B4BPPtoCMYK(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 4BPP to CMYK.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD pdwColorTable;
    PBYTE  pubDst;
    DWORD  dwConvSize;
    ULONG  ulIndex;

    XL_VERBOSE(("BMPConv: B4BPPtoCMYK\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    dwConvSize = (DWORD)m_OddPixelStart;
    dwSrcPixelNum += dwConvSize;
    pubDst = m_pubOutputBuff;

    while (dwConvSize < dwSrcPixelNum)
    {
        ulIndex = (dwConvSize++ & 1) ?
                        pdwColorTable[*pubSrc++ & 0x0F] :
                        pdwColorTable[*pubSrc >> 4];

        pubDst[0] = CYAN(ulIndex);
        pubDst[1] = MAGENTA(ulIndex);
        pubDst[2] = YELLOW(ulIndex);
        pubDst[3] = BLACK(ulIndex);
        pubDst += 4;
    }

    return TRUE;
}

BOOL
BMPConv::
B4BPPtoRGB(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 4BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD pdwColorTable;
    DWORD  dwConvSize;
    ULONG  ulIndex;
    PBYTE  pubDst;

    XL_VERBOSE(("BMPConv: B4BPPtoRGB\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    dwConvSize = m_OddPixelStart;
    dwSrcPixelNum += dwConvSize;
    pubDst = m_pubOutputBuff;

    while (dwConvSize < dwSrcPixelNum)
    {
        ulIndex = (dwConvSize++ & 1) ?
                        pdwColorTable[*pubSrc++ & 0x0F] :
                        pdwColorTable[*pubSrc >> 4];

        pubDst[0] = RED(ulIndex);
        pubDst[1] = GREEN(ulIndex);
        pubDst[2] = BLUE(ulIndex);
        pubDst += 3;
    }

    return TRUE;
}

BOOL
BMPConv::
B4BPPtoGray(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 4BPP to Gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD pdwColorTable;
    ULONG ulIndex;
    DWORD dwConvSize;
    PBYTE pubDst;

    XL_VERBOSE(("BMPConv: B4BPPtoGray\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    dwConvSize = m_OddPixelStart;
    dwSrcPixelNum += dwConvSize;
    pubDst = m_pubOutputBuff;

    while (dwConvSize < dwSrcPixelNum)
    {
        ulIndex = (dwConvSize++ & 1) ?
                        pdwColorTable[*pubSrc++ & 0x0F] :
                        pdwColorTable[*pubSrc >> 4];

        *pubDst++ = DWORD2GRAY(ulIndex);
    }

    return TRUE;
}


BOOL
BMPConv::
B8BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum
    )

/*++

Routine Description:

    DIB conversion function - 8BPP to grayscale.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD  pdwColorTable;
    DWORD   dwColor;
    PBYTE   pubDst;

    XL_VERBOSE(("BMPConv: B8BPPtoGray\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    pubDst = m_pubOutputBuff;

    while (dwSrcPixelNum--)
    {
        dwColor = pdwColorTable[*pubSrc++];
        *pubDst++ = DWORD2GRAY(dwColor);
    }

    return TRUE;
}

BOOL
BMPConv::
B8BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 8BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return the size of translated destination bitmap

--*/
{
    PDWORD pdwColorTable;
    ULONG ulIndex;
    PBYTE pubDst;

    XL_VERBOSE(("BMPConv: B8BPPtoRGB\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    pubDst = m_pubOutputBuff;

    while (dwSrcPixelNum--)
    {
        ulIndex = pdwColorTable[*pubSrc++];

        pubDst[0] = RED(ulIndex);
        pubDst[1] = GREEN(ulIndex);
        pubDst[2] = BLUE(ulIndex);
        pubDst += 3;
    }

    return TRUE;
}

BOOL
BMPConv::
B8BPPtoCMYK(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 8BPP to CMYK.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return the size of translated destination bitmap

--*/
{
    PDWORD pdwColorTable;
    ULONG ulIndex;
    PBYTE pubDst;

    XL_VERBOSE(("BMPConv: B8BPPtoCMYK\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    pubDst = m_pubOutputBuff;

    while (dwSrcPixelNum--)
    {
        ulIndex = pdwColorTable[*pubSrc++];

        pubDst[0] = CYAN(ulIndex);
        pubDst[1] = MAGENTA(ulIndex);
        pubDst[2] = YELLOW(ulIndex);
        pubDst[3] = BLACK(ulIndex);
        pubDst += 4;
    }

    return TRUE;
}

BOOL
BMPConv::
B16BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 16BPP to 8 bits gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B16BPPtoGray\n"));

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *((PWORD) pubSrc));
        pubSrc += 2;

        *pubDst++ = DWORD2GRAY(dwColor);
    }

    return TRUE;
}

BOOL
BMPConv::
B16BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 16BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B16BPPtoRGB\n"));

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *((PWORD) pubSrc));
        pubSrc += 2;

        pubDst[0] = RED(dwColor);
        pubDst[1] = GREEN(dwColor);
        pubDst[2] = BLUE(dwColor);
        pubDst += 3;
    }

    return TRUE;
}

BOOL
BMPConv::
B24BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 24BPP to 8 bits gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPtoGray\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Pure 24BPP RGB image.
        //

        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[0], pubSrc[1], pubSrc[2]);
            pubSrc += 3;
        }
    }
    else if (m_flags & BMPCONV_BGR)
    {
        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[2], pubSrc[1], pubSrc[0]);
            pubSrc += 3;
        }
    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);

            pubSrc += 3;
            dwColor = XLATEOBJ_iXlate(m_pxlo, dwColor);
            *pubDst++ = DWORD2GRAY(dwColor);
        }
    }

    return TRUE;
}

BOOL
BMPConv::
B24BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 24BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPtoRGB\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Pure 24BPP RGB image.
        //

        CopyMemory(m_pubOutputBuff, pubSrc, dwSrcPixelNum * 3);
    }
    else if (m_flags & BMPCONV_BGR)
    {
        while (dwSrcPixelNum--)
        {
            pubDst[0] = pubSrc[2];
            pubDst[1] = pubSrc[1];
            pubDst[2] = pubSrc[0];
            pubSrc += 3;
            pubDst += 3;
        }
    }
    else if (m_flags & BMPCONV_XLATE)
    {
        while (dwSrcPixelNum--)
        {
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);

            pubSrc += 3;
            dwColor = XLATEOBJ_iXlate(m_pxlo, dwColor);
            pubDst[0] = RED(dwColor);
            pubDst[1] = GREEN(dwColor);
            pubDst[2] = BLUE(dwColor);
            pubDst += 3;
        }
    }

    return TRUE;
}


BOOL
BMPConv::
B32BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 32BPP to 8 bits Gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD dwColor;
    BYTE  ubCyan, ubMagenta, ubYellow, ubBlack;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPtoGray\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Source bitmap is a pure 32BPP CMYK image.
        //

        while (dwSrcPixelNum--)
        {
            ubCyan    = *pubSrc++;
            ubMagenta = *pubSrc++;
            ubYellow  = *pubSrc++;
            ubBlack   = *pubSrc++;

            *pubDst++ = RGB2GRAY(255 - min(255, (ubCyan    + ubBlack)),
                                 255 - min(255, (ubMagenta + ubBlack)),
                                 255 - min(255, (ubYellow  + ubBlack)));
        }
    }
    else if (m_flags & BMPCONV_32BPP_RGB)
    {
        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[0], pubSrc[1], pubSrc[2]);
            pubSrc += 4;
        }
    }
    else if (m_flags & BMPCONV_32BPP_BGR)
    {
        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[0], pubSrc[1], pubSrc[2]);
            pubSrc += 4;
        }

    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = XLATEOBJ_iXlate(m_pxlo, *((PDWORD) pubSrc));
            pubSrc += 4;
            *pubDst++ = DWORD2GRAY(dwColor);
        }
    }

    return TRUE;
}


BOOL
BMPConv::
B32BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 32BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD dwColor;
    BYTE  ubCyan, ubMagenta, ubYellow, ubBlack;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B32BPPtoRGB\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Source bitmap is a pure 32BPP CMYK image.
        //

        while (dwSrcPixelNum--)
        {
            ubCyan    = pubSrc[0];
            ubMagenta = pubSrc[1];
            ubYellow  = pubSrc[2];
            ubBlack   = pubSrc[3];
            pubSrc += 4;

            ubCyan    += ubBlack;
            ubMagenta += ubBlack;
            ubYellow  += ubBlack;

            pubDst[0] =  255 - min(255, ubCyan);
            pubDst[1] =  255 - min(255, ubMagenta);
            pubDst[2] =  255 - min(255, ubYellow);
            pubDst += 3;
        }
    }
    else if (m_flags & BMPCONV_32BPP_RGB)
    {
        while (dwSrcPixelNum--)
        {
            pubDst[0] = pubSrc[0];
            pubDst[1] = pubSrc[1];
            pubDst[2] = pubSrc[2];
            pubSrc += 4;
            pubDst += 3;
        }
    }
    else if (m_flags & BMPCONV_32BPP_BGR)
    {
        while (dwSrcPixelNum--)
        {
            pubDst[0] = pubSrc[2];
            pubDst[1] = pubSrc[1];
            pubDst[2] = pubSrc[0];
            pubSrc += 4;
            pubDst += 3;
        }
    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = XLATEOBJ_iXlate(m_pxlo, *((PDWORD) pubSrc));
            pubSrc += 4;
            pubDst[0] =  RED(dwColor);
            pubDst[1] =  GREEN(dwColor);
            pubDst[2] =  BLUE(dwColor);
        }
    }

    return TRUE;
}


BOOL
BMPConv::
B32BPPtoCMYK(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 32BPP to CMYK.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B32BPPtoCMYK\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Source bitmap is a pure 32BPP CMYK image.
        //

        CopyMemory(m_pubOutputBuff, pubSrc, dwSrcPixelNum * 4);
    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = XLATEOBJ_iXlate(m_pxlo, *((PDWORD) pubSrc));
            pubSrc += 4;

            pubDst[0] = 255 - RED(dwColor);
            pubDst[1] = 255 - GREEN(dwColor);
            pubDst[2] = 255 - BLUE(dwColor);
            pubDst[3] = 0;
            pubDst += 4;
        }
    }

    return TRUE;
}

BOOL
BMPConv::
BArbtoGray(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. Arbitray bitmap to 8 bits Gray scale.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD   dwColor;
    PDWORD  pdwSrc;
    PBYTE   pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: BArbtoGray\n"));

    pdwSrc = (PDWORD) pubSrc;

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *pdwSrc++);
        *pubDst++ = DWORD2GRAY(dwColor);
    }

    return TRUE;
}

BOOL
BMPConv::
BArbtoRGB(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. Arbitraty bitmap to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD   dwColor;
    PDWORD  pdwSrc;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: BArbtoRGB\n"));

    pdwSrc = (PDWORD) pubSrc;

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *pdwSrc++);

        pubDst[0] = RED(dwColor);
        pubDst[1] = GREEN(dwColor);
        pubDst[2] = BLUE(dwColor);
        pubDst += 3;
    }

    return TRUE;
}

#ifdef WINNT_40
BOOL
BMPConv::
B24BPPToImageMask(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 24 bpp bitmaps with only one non-white color to image mask.
    Can happen on NT4, where GDI does not optimize for that case.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD   dwColor;
    PDWORD  pdwSrc;
    BYTE    ubDest = 0;
    DWORD   dwIndex = 0;
    DWORD   dwTransp = (m_flags & BMPCONV_SRC_COPY) ? RGB_WHITE : RGB_BLACK;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPToImageMask\n"));

    while (dwSrcPixelNum--)
    {
        if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
        {
            //
            // No special conversion is necessary, 24BPP RGB image.
            //
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);
        }
        else if (m_flags & BMPCONV_BGR)
        {
            //
            // convert 24BPP BGR to RGB.
            //
            dwColor = ((DWORD) pubSrc[2]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[0] << 16);
        }
        else if (m_flags & BMPCONV_XLATE)
        {
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);

            pubSrc += 3;
            dwColor = XLATEOBJ_iXlate(m_pxlo, dwColor);
        }

        ubDest = ubDest << 1;
        dwIndex++;
        pubSrc += 3;

        if (dwColor != dwTransp)
            ubDest |= 0x01;

        if (dwIndex == 8) // one byte completed ?
        {
            *pubDst++ = ubDest;
            dwIndex = 0;
            ubDest = 0;
        }
    }

    if (dwIndex != 0) // flush leftover bits
        *pubDst = ubDest;

    return TRUE;
}
#endif

BOOL
BMPConv::
BConversionProc(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)

/*++

Routine Description:

    Return a pointer to the appropriate DIB conversion function

Arguments:

    pBMPAttrrib - Points to a BMPATTRUTE structure

Return Value:

    Pointer to a DIB conversion function

--*/

{
    //PVOID pfnDibConv[7][4] = {
    // Gray Scale, Palette,   RGB,          CMYK
    //-----------------------------------------------------------------------
    //{BCopy,        BCopy,     NULL,        NULL},        // 1bpp
    //{B4BPPtoGray,  BCopy,     B4BPPtoRGB,  B4BPPtoCMYK}, // 4bpp
    //{B8BPPtoGray,  BCopy,     B8BPPtoRGB,  B8BPPtoCMYK}, // 8bpp
    //{B16BPPtoGray, NULL,      B16BPPtoRGB, NULL},        // 16bpp
    //{B24BPPtoGray, NULL,      B24BPPtoRGB, NULL},        // 24bpp
    //{B32BPPtoGray, NULL,      B32BPPtoRGB, B32BPPtoCMYK},// 32bpp
    //{BArbtoGray,   NULL,      BArbtoRGB,   NULL}         // Arbitrary
    //};


    XL_VERBOSE(("BMPConv: BConversionProc\n"));

    //
    // special case for NT4: GDI passes all bitmaps as 24 bpp, even 1 bpp bitmaps
    // that can be better treated through image masks
    //

#if 0 // #ifdef WINNT_40
    if (m_flags & BMPCONV_2COLOR_24BPP)
    {
        return B24BPPToImageMask;
    }
#endif

    BOOL bRet = FALSE;

    //
    // Zero init for DWORD alignment
    //
    ZeroMemory(m_pubOutputBuff, m_dwOutputBuffSize);

    switch (m_InputBPP)
    {
    case e1bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputRGB:
        case eOutputCMYK:
            break;
        }
        break;

    case e4bpp:
        switch(m_OutputFormat)
        {
        case eOutputGray:
            B4BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputRGB:
            B4BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            B4BPPtoCMYK(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        }

        break;

    case e8bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B8BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputRGB:
            B8BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            B8BPPtoCMYK(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        }
        break;

    case e16bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B16BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
            break;
        case eOutputRGB:
            B16BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            XL_ERR(("BMPConv::BConversionProc: 16 to CMYK is not supported yet.\n"));
            break;
        }
        break;

    case e24bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B24BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            break;
        case eOutputRGB:
            B24BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            break;
        }
        break;

    case e32bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B32BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            break;
        case eOutputRGB:
            B32BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            B32BPPtoCMYK(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        }
        break;

    default:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            BArbtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            break;
        case eOutputRGB:
            BArbtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            XL_ERR(("BMPConv::BConversionProc: Arb to CMYK is not supported yet.\n"));
            break;
        }
    }  
    return bRet;
}

DWORD
BMPConv::
DwCheckXlateObj(
    IN XLATEOBJ *pxlo,
    IN BPP InputBPP)
/*++

Routine Description:

    Determines the type of converison.
        *Palette
        *RGB
        *BGR
        *CMYK
        *Call XLATEOBJ_XXX function.

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwRet;
    DWORD Dst[4];

    XL_VERBOSE(("BMPConv: DwCheckXlateObj\n"));

    //
    // Init dwRet
    //
    dwRet = 0;

    switch (InputBPP)
    {
    case e16bpp:
        dwRet = BMPCONV_XLATE;
        break;

    case e24bpp:
        if (pxlo->iSrcType == PAL_RGB)
            dwRet = 0;
        else
        if (pxlo->iSrcType == PAL_BGR)
            dwRet = BMPCONV_BGR;
        {
            Dst[0] = XLATEOBJ_iXlate(pxlo, 0x000000FF);
            Dst[1] = XLATEOBJ_iXlate(pxlo, 0x0000FF00);
            Dst[2] = XLATEOBJ_iXlate(pxlo, 0x00FF0000);

            if ((Dst[0] == 0x000000FF) &&
                (Dst[1] == 0x0000FF00) &&
                (Dst[2] == 0x00FF0000)  )
            {
                dwRet = 0;
            }
            else if ((Dst[0] == 0x00FF0000) &&
                     (Dst[1] == 0x0000FF00) &&
                     (Dst[2] == 0x000000FF)  )
            {
                dwRet = BMPCONV_BGR;
            }
        }
        break;

    case e32bpp:
        if (pxlo->flXlate & XO_FROM_CMYK)
            dwRet = 0;
        else
        {
            //
            // Translate all 4 bytes from the DWORD
            //

            Dst[0] = XLATEOBJ_iXlate(pxlo, 0x000000FF);
            Dst[1] = XLATEOBJ_iXlate(pxlo, 0x0000FF00);
            Dst[2] = XLATEOBJ_iXlate(pxlo, 0x00FF0000);
            Dst[3] = XLATEOBJ_iXlate(pxlo, 0xFF000000);

            if ((Dst[0] == 0x000000FF) &&
                (Dst[1] == 0x0000FF00) &&
                (Dst[2] == 0x00FF0000) &&
                (Dst[3] == 0x00000000))
            {
                //
                // If translate result is same (4th byte will be zero) then
                // we done with it except if 32bpp then we have to skip one
                // source byte for every 3 bytes
                //

                dwRet = BMPCONV_32BPP_RGB;

            }
            else if ((Dst[0] == 0x00FF0000) &&
                     (Dst[1] == 0x0000FF00) &&
                     (Dst[2] == 0x000000FF) &&
                     (Dst[3] == 0x00000000))
            {
                //
                // Simply swap the R and B component
                //

                dwRet = BMPCONV_32BPP_BGR;
            }
        }
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\inc\vectorc.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    vectorc.h

Abstract:

    Vector module main header file.

Environment:

    Windows 2000/Whistler Unidrv driver

Revision History:

    02/29/00 -hsingh-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _VECTORC_H_
#define _VECTORC_H_


#include "lib.h"
#include "unilib.h"
#include "gpd.h"
#include "mini.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "common.h"
#include "vectorif.h"
#include "printoem.h"
#include "oemutil.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Every vector "pseudo-plugin" should have an XXXXInitVectorProcTable function. This
// function will be called by VMInit to initialize the pVectorProcs in PDEV.
// VMInit is called by unidrv's EnablePDEV.
//

PVMPROCS HPGLInitVectorProcTable(
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo );

PVMPROCS PCLXLInitVectorProcTable(
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo );


#ifdef __cplusplus
}
#endif


#endif  // !_VECTORC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\gstate.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     gstate.cpp

Abstract:

    PCL XL Graphics state manager

Environment:

    Windows Whistler

Revision History:

    08/23/99 
      Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "pclxle.h"
#include "xlgstate.h"

//
// XLLine
//

//
// Default setting of LineAttrs
//
const LINEATTRS gLineAttrs =
{
    LA_GEOMETRIC,           // fl
    JOIN_ROUND,             // iJoin
    ENDCAP_ROUND,           // iEndCap
    {FLOATL_IEEE_0_0F},     // elWidth
    FLOATL_IEEE_0_0F,       // eMiterLimit
    0,                      // cstyle
    (FLOAT_LONG*) NULL,     // pstyle
    {FLOATL_IEEE_0_0F}      // elStyleState
}; 

const LINEATTRS *pgLineAttrs = &gLineAttrs;

XLLine::
XLLine(
    VOID):
/*++

Routine Description:

    XLLine constructor

Arguments:

Return Value:

Note:

--*/
    m_dwGenFlags(0),
    m_LineAttrs(gLineAttrs)
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLLine::CTor\n"));
}

XLLine::
~XLLine(
    VOID)
/*++

Routine Description:

    XLLine destructor

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLLine::DTor\n"));

    if ( NULL != m_LineAttrs.pstyle)
    {
        //
        // Free memory
        //
        MemFree(m_LineAttrs.pstyle);
    }
}

#if DBG
VOID
XLLine::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

VOID
XLLine::
ResetLine(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_LineAttrs  = gLineAttrs;
}

DWORD
XLLine::
GetDifferentAttribute(
    IN LINEATTRS *plineattrs)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwRet;

    XL_VERBOSE(("XLLine::GetDifferentAttribute\n"));

    dwRet = XLLINE_NONE;

    if (NULL == plineattrs)
    {
        XL_ERR(("XLLine::GetDifferentAttribute: plineattrs == NULL.\n"));
        return dwRet;
    }

    if ( m_LineAttrs.fl != plineattrs->fl )
        dwRet |= XLLINE_LINETYPE;

    if ( m_LineAttrs.iJoin != plineattrs->iJoin )
        dwRet |= XLLINE_JOIN;

    if ( m_LineAttrs.iEndCap != plineattrs->iEndCap )
        dwRet |= XLLINE_ENDCAP;

    if ( m_LineAttrs.elWidth.l != plineattrs->elWidth.l)
        dwRet |= XLLINE_WIDTH;

    if ( m_LineAttrs.eMiterLimit != plineattrs->eMiterLimit )
        dwRet |= XLLINE_MITERLIMIT;

    if ( m_LineAttrs.cstyle != plineattrs->cstyle ||
             plineattrs->cstyle != 0 &&
             memcmp(m_LineAttrs.pstyle,
                   plineattrs->pstyle,
                   sizeof(FLOAT_LONG) * m_LineAttrs.cstyle) ||
         m_LineAttrs.elStyleState.l != plineattrs->elStyleState.l )
        dwRet |= XLLINE_STYLE;

    XL_VERBOSE(("XLLine::GetDifferentAttribute returns %08x.\n", dwRet));
    return dwRet;
}

HRESULT
XLLine::
SetLineType(
    IN XLLineType LineType )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineType\n"));
    m_LineAttrs.fl = (FLONG)LineType;
    return S_OK;
}


HRESULT
XLLine::
SetLineJoin(
    IN XLLineJoin LineJoin )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineJoin\n"));
    m_LineAttrs.iJoin = (ULONG)LineJoin;
    return S_OK;
}


HRESULT
XLLine::
SetLineEndCap(
    IN XLLineEndCap LineEndCap )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineEndCap\n"));
    m_LineAttrs.iEndCap = (ULONG)LineEndCap;
    return S_OK;
}


HRESULT
XLLine::
SetLineWidth(
    IN FLOAT_LONG elWidth )
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLLine::SetLineWidth\n"));
    m_LineAttrs.elWidth = elWidth;
    return S_OK;
}

HRESULT
XLLine::
SetMiterLimit(
    IN FLOATL eMiterLimit )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetMiterLimit\n"));
    m_LineAttrs.eMiterLimit = eMiterLimit;
    return S_OK;
}


HRESULT
XLLine::
SetLineStyle(
    IN ULONG ulCStyle,
    IN PFLOAT_LONG pStyle,
    IN FLOAT_LONG elStyleState )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineStyle\n"));

    m_LineAttrs.elStyleState = elStyleState;

    //
    // Error check
    //     Make sure the pointer is valid.
    //     Make sure the the ulCStyle is valid, not ZERO.
    //
    if ( NULL == pStyle || 0 == ulCStyle )
    {
        XL_VERBOSE(("XLLine::SetLineStyle: pStyle == NULL.\n"));
        if (NULL != m_LineAttrs.pstyle)
        {
            MemFree(m_LineAttrs.pstyle);
        }
        m_LineAttrs.pstyle = NULL;
        m_LineAttrs.cstyle = 0;
        return S_OK;
    }

    if ( m_LineAttrs.cstyle > 0 && NULL != m_LineAttrs.pstyle)
    {
        //
        // Free memory and reset.
        //
        MemFree(m_LineAttrs.pstyle);
        m_LineAttrs.pstyle = NULL;
        m_LineAttrs.cstyle = 0;
    }

    m_LineAttrs.pstyle = (PFLOAT_LONG) MemAlloc(ulCStyle * sizeof(FLOAT_LONG));

    if ( NULL == m_LineAttrs.pstyle )
    {
        m_LineAttrs.cstyle = 0;
        XL_ERR(("XLLine::SetLineStyle: Out of memory.\n"));
        return E_OUTOFMEMORY;
    }

    m_LineAttrs.cstyle = ulCStyle;
    memcpy( m_LineAttrs.pstyle, pStyle, ulCStyle * sizeof(FLOAT_LONG));

    return S_OK;
}


//
// Common Brush
//

Brush::
Brush(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    m_Brush.dwSig = BRUSH_SIGNATURE;
    m_Brush.BrushType = kNotInitialized;
    XL_VERBOSE(("Brush:: Ctor\n"));
}

Brush::
~Brush(
    IN VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("Brush:: Dtor\n"));

}

#if DBG
VOID
Brush::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

VOID
Brush::
ResetBrush(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_Brush.BrushType = kNotInitialized;
}

HRESULT
Brush::
CheckCurrentBrush(
    IN BRUSHOBJ *pbo)
/*+++
    Routine Description
        This function checks if the current selected brush is same as
        the one specified in the parameter. 

    Note
        pbo->iSolidColor == NOT_SOLID_COLOR
        {
            iHatch < HS_DDI_MAX
                CMNBRUSH (solid color, hatch pattern)
                    --> kBrushTypeHatch

            iHatch >= HS_DDI_MAX
                CMNBRUSH pattern Brush
                    --> kBrushTypePattern
            
        }

        pbo->iSolidColor != NOT_SOLID_COLOR
        {
            Solid color, solid pattern fill
                --> kBrushTypeSolid
        }

        List of members to check
            pbo->iSolidColor (Solid color ID or NOT_SOLID_COLOR)
            lHatch (HS_XXX or >= HS_MAX_ID)
            dwColor (BRUSHOBJ_ulGetBrushColor(pbo))
            psoPattern bitmap

    Return value
        S_FALSE if the specified brush is different from the current selected.
        S_OK    if the specified brush is same as the curren one.

---*/
{
    HRESULT lrRet;

    XL_VERBOSE(("Brush::CheckCurrentBrush\n"));

    //
    // Error check: parameter
    //
    if (NULL == pbo && m_Brush.BrushType != kNoBrush ||
        m_Brush.BrushType == kNotInitialized          )
    {
        XL_VERBOSE(("Brush::CheckCurrentBrush: Set NULL Brush (pbo==NULL)\n"));
        return S_FALSE;
    }

    lrRet = S_OK;

    switch ( m_Brush.BrushType )
    {
    case kNoBrush:
        if (pbo != NULL)
            lrRet = S_FALSE;
        XL_VERBOSE(("Brush::CheckCurrentBrush: kNoBrush:%d\n", lrRet));
        break;

    case kBrushTypeSolid:
        //
        // 1. Check the brush type.
        // 2. Check solid color.
        //
        if ( pbo->iSolidColor != m_Brush.ulSolidColor ||
             BRUSHOBJ_ulGetBrushColor(pbo) != m_Brush.dwColor )
            lrRet = S_FALSE;
        XL_VERBOSE(("Brush::CheckCurrentBrush: kBrushTyepSolid:%d\n", lrRet));
        break;

    case kBrushTypeHatch:
        //
        // 1. Check the brush type.
        // 2. Check hatch type.
        // 3. Check color.
        //
        if (pbo->iSolidColor == NOT_SOLID_COLOR)
        {
            XLBRUSH *pBrush = (XLBRUSH*)BRUSHOBJ_pvGetRbrush(pbo);
            ULONG ulHatch = 0;

            if (NULL != pBrush)
            {
                if (pBrush->dwSig != XLBRUSH_SIG)
                {
                    lrRet = E_UNEXPECTED;
                    XL_ERR(("Brush::CheckCurrentBrush: BRUSHOBJ_pvGetRbrush returned invalid BRUSH.\n"));
                    break;
                }

                ulHatch = pBrush->dwHatch;

                if ( NOT_SOLID_COLOR != m_Brush.ulSolidColor ||
                     ulHatch != m_Brush.ulHatch ||
                     pbo->iSolidColor != m_Brush.ulSolidColor ||
                     pBrush->dwColor != m_Brush.dwColor )
                {
                    lrRet = S_FALSE;
                }
            }
            else
            {
                //
                // GDI requests to set solid color or NULL brush.
                //
                XL_ERR(("Brush::CheckCurrentBrush: BRUSHOBJ_pvGetRbrush returned NULL.\n"));
                lrRet = S_FALSE;
            }
            XL_VERBOSE(("Brush::CheckCurrentBrush: kBrushTypeHatch:ID(%d),%d\n", ulHatch, lrRet));
        }
        else
            lrRet = S_FALSE;
        break;

    case kBrushTypePattern:
        //
        // 1. Check brush type.
        // 2. Check pattern brush.
        //
        if (pbo->iSolidColor == NOT_SOLID_COLOR)
        {
            XLBRUSH *pBrush = (XLBRUSH*)BRUSHOBJ_pvGetRbrush(pbo);

            if (NULL != pBrush)
            {
                if (pBrush->dwSig != XLBRUSH_SIG)
                {
                    lrRet = E_UNEXPECTED;
                    XL_ERR(("Brush::CheckCurrentBrush: BRUSHOBJ_pvGetRbrush returned invalid BRUSH.\n"));
                    break;
                }

                if ( NOT_SOLID_COLOR == m_Brush.ulSolidColor ||
                     m_Brush.dwPatternBrushID != pBrush->dwPatternID)
                {
                    lrRet = S_FALSE;
                }
            }
            else
            {
                //
                // GDI requests to set solid color or NULL brush.
                //
                lrRet = S_FALSE;
            }
        }
        else
        {
            lrRet = S_FALSE;
        }
        XL_VERBOSE(("Brush::CheckCurrentBrush: kBrushTypePattern:%d\n", lrRet));
        break;
    }

    return lrRet;
}

HRESULT 
Brush::
SetBrush(
    IN CMNBRUSH *pBrush)
/*+++
    Routine Description
        This function sets if the current selected brush is same as
        the one specified in the parameter. 

---*/
{
    HRESULT lrRet;

    XL_VERBOSE(("Brush::SetBrush\n"));

    //
    // Error check: Parameter
    //
    if ( NULL == pBrush )
    {
        XL_ERR(("Brush::SetBrush: pBrush is NULL.\n"));
        return E_UNEXPECTED;
    }

    m_Brush.BrushType    = pBrush->BrushType;
    m_Brush.ulSolidColor = pBrush->ulSolidColor;
    m_Brush.ulHatch      = pBrush->ulHatch;
    m_Brush.dwCEntries   = pBrush->dwCEntries;
    m_Brush.dwColor      = pBrush->dwColor;
    m_Brush.dwPatternBrushID = pBrush->dwPatternBrushID;

    return S_OK;
}

//
// XLClip
//

XLClip::
XLClip(
    VOID):
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
    m_ClipType(kNoClip)
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    m_XLClip.dwSig = CLIP_SIGNATURE;
    XL_VERBOSE(("XLClip:: Ctor\n"));
}

XLClip::
~XLClip(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLClip:: Dtor\n"));
}

#if DBG
VOID
XLClip::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

HRESULT
XLClip::
ClearClip(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLClip::ClearClip\n"));
    m_ClipType = kNoClip;
    return S_OK;
}

HRESULT
XLClip::
CheckClip(
    IN CLIPOBJ *pco)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{

    HRESULT lrRet = S_OK;

    XL_VERBOSE(("XLClip::CheckClip\n"));

    //
    // Error check: Parameter
    //
    if (!pco)
    {
        //
        // It is not necessary to clip if pco is NULL.
        //
        XL_VERBOSE(("XLClip::CheckClip: pco == NULL.\n"));
        if (kNoClip != m_ClipType)
            lrRet = S_FALSE;
    }
    else
    {
        switch (pco->iDComplexity)
        {
        case DC_TRIVIAL:
            if ( m_ClipType != kNoClip )
                lrRet = S_FALSE;
            XL_VERBOSE(("XLClip::Type: DC_TRIVIAL:%d\n", lrRet));
            break;

        case DC_RECT:
            if ( m_ClipType != kClipTypeRectangle ||
                 m_XLClip.rclClipRect.left != pco->rclBounds.left ||
                 m_XLClip.rclClipRect.right != pco->rclBounds.right ||
                 m_XLClip.rclClipRect.top != pco->rclBounds.top ||
                 m_XLClip.rclClipRect.bottom != pco->rclBounds.bottom  )
                lrRet = S_FALSE;
            XL_VERBOSE(("XLClip::Type: DC_RECT:%d\n", lrRet));
            break;

        case DC_COMPLEX:
        #if 0 // It seems like we can't rely on iUniq.
              // Always sends complex clip path.
            if ( m_ClipType != kClipTypeComplex ||
                 m_XLClip.ulUniq == 0           ||
                 pco->iUniq == 0                ||
                 m_XLClip.ulUniq != pco->iUniq   ) 
                lrRet = S_FALSE;
        #else
            lrRet = S_FALSE;
        #endif
            XL_VERBOSE(("XLClip::Type: DC_COMPLEX\n", lrRet));
            break;
        default:
            if ( m_ClipType != kNoClip )
                lrRet = S_FALSE;
            XL_VERBOSE(("XLClip::Type: DC_TRIVIAL:%d\n", lrRet));
        }
    }

    return lrRet;
}

HRESULT
XLClip::
SetClip(
   IN CLIPOBJ *pco)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{

    HRESULT lrRet;

    XL_VERBOSE(("XLClip::SetClip\n"));

    //
    // Error check: Parameter
    //
    if (!pco)
    {
        //
        // It is not necessary to clip if pco is NULL.
        //
        XL_VERBOSE(("XLClip::SetClip: pco == NULL.\n"));
        return E_UNEXPECTED;
    }

    switch (pco->iDComplexity)
    {
    case DC_TRIVIAL:
        XL_VERBOSE(("XLClip::SetClip Type: DC_TRIVIAL\n"));
        m_ClipType = kNoClip;
        lrRet = S_OK;
        break;

    case DC_RECT:
        XL_VERBOSE(("XLClip::SetClip Type: DC_RECT\n"));
        m_ClipType = kClipTypeRectangle;
        m_XLClip.rclClipRect.left   = pco->rclBounds.left;
        m_XLClip.rclClipRect.right  = pco->rclBounds.right;
        m_XLClip.rclClipRect.top    = pco->rclBounds.top;
        m_XLClip.rclClipRect.bottom = pco->rclBounds.bottom;
        lrRet = S_OK;
        break;

    case DC_COMPLEX:
        XL_VERBOSE(("XLClip::SetClip Type: DC_COMPLEX\n"));
        m_ClipType = kClipTypeComplex;
        m_XLClip.ulUniq = pco->iUniq;
        lrRet = S_OK;
        break;

    default:
        XL_ERR(("XLClip::SetClip: Unexpected iDCompelxity\n"));
        m_ClipType = kNoClip;
        lrRet = E_UNEXPECTED;
    }

    return lrRet;
}   




//
// XLRop
// 

XLRop::
XLRop(
    VOID):
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
    m_rop3(0xCC) // SRCCPY
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLRop:: Ctor\n"));
}

XLRop::
~XLRop(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLRop:: Dtor\n"));
}

#if DBG
VOID
XLRop::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

HRESULT
XLRop::
CheckROP3(
    IN ROP3 rop3 )
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    HRESULT lrRet;

    XL_VERBOSE(("XLRop::CheckROP3\n"));

    if (rop3 != m_rop3)
        lrRet = S_FALSE;
    else
        lrRet = S_OK;

    return lrRet;
}


HRESULT
XLRop::
SetROP3(
    IN ROP3 rop3 )
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLRop::SetROP3\n"));

    m_rop3 = rop3;
    return S_OK;
}

XLFont::
XLFont(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLFont::CTor\n"));
    ResetFont();
}

XLFont::
~XLFont(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::DTor\n"));
}

#if DBG
VOID 
XLFont::
SetDbgLevel(
DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

VOID
XLFont::
ResetFont(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_XLFontType = kFontNone;
    m_aubFontName[0] = (BYTE) NULL;
    m_dwFontHeight = 0;
    m_dwFontWidth = 0;
    m_dwFontSymbolSet = 0;
    m_dwFontSimulation = 0;
}

HRESULT
XLFont::
CheckCurrentFont(
    FontType XLFontType,
    PBYTE pPCLXLFontName,
    DWORD dwFontHeight,
    DWORD dwFontWidth,
    DWORD dwFontSymbolSet,
    DWORD dwFontSimulation)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    HRESULT lrRet = S_OK;

    XL_VERBOSE(("XLFont::CheckCurrentFont\n"));

    switch (XLFontType)
    {
    case kFontNone:
        lrRet = S_FALSE;
        break;

    case kFontTypeDevice:
        ASSERT((pPCLXLFontName));
        if (m_XLFontType == kFontTypeDevice ||
            strcmp((CHAR*)pPCLXLFontName, (CHAR*)m_aubFontName) ||
            dwFontHeight != m_dwFontHeight ||
            dwFontWidth != m_dwFontWidth ||
            dwFontSymbolSet != m_dwFontSymbolSet)
            lrRet = S_FALSE;
        break;

    case kFontTypeTTBitmap:
        ASSERT((pPCLXLFontName));
        if (m_XLFontType == kFontTypeTTBitmap ||
            strcmp((CHAR*)pPCLXLFontName, (CHAR*)m_aubFontName))
            lrRet = S_FALSE;
        break;

    case kFontTypeTTOutline:
        ASSERT((pPCLXLFontName));
        if (m_XLFontType == kFontTypeTTOutline ||
            strcmp((CHAR*)pPCLXLFontName, (CHAR*)m_aubFontName) ||
            dwFontHeight != m_dwFontHeight ||
            dwFontWidth != m_dwFontWidth ||
            dwFontSymbolSet != m_dwFontSymbolSet ||
            dwFontSimulation != m_dwFontSimulation )
            lrRet = S_FALSE;
        break;
    default:
        XL_ERR(("XLFont::CheckCurrentFont: Invalid font type.\n"));
        lrRet = E_UNEXPECTED;
        break;
    }

    return lrRet;
}


HRESULT
XLFont::
SetFont(
    FontType XLFontType,
    PBYTE pPCLXLFontName,
    DWORD dwFontHeight,
    DWORD dwFontWidth,
    DWORD dwFontSymbolSet,
    DWORD dwFontSimulation)
/*++

Routine Description:

    Set font in GState.

Arguments:

    XLFontType - FontType enum, Font type (Device/TTBitmap/TTOutline)
    pPCLXLFontName - XL font name (base name + attributes)
    dwFontHeight - Font height
    dwFontWidth - Font width
    dwFontSymbolSet - Font's symbol set
    dwFontSimulation - Font attributes (Bold/Italic)

Return Value:

Note:

--*/
{
    HRESULT lrRet;

    XL_VERBOSE(("XLFont::SetFont\n"));

    switch (XLFontType)
    {
    case kFontTypeDevice:
    case kFontTypeTTOutline:
    case kFontTypeTTBitmap:
        ASSERT(pPCLXLFontName);
        m_XLFontType = XLFontType;
        CopyMemory(m_aubFontName, pPCLXLFontName, PCLXL_FONTNAME_SIZE);
        m_dwFontHeight = dwFontHeight;
        m_dwFontWidth = dwFontWidth;
        m_dwFontSymbolSet = dwFontSymbolSet;
        m_dwFontSimulation = dwFontSimulation;
        lrRet = S_OK;
        break;
    default:
        XL_ERR(("XLFont::CheckCurrentFont: Invalid font type.\n"));
        lrRet = E_UNEXPECTED;
        break;
    }

    return lrRet;

}

HRESULT
XLFont::
GetFontName(
    PBYTE paubFontName)
/*++

Routine Description:

    Returns current selected font base name.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontName\n"));

    if (NULL == paubFontName)
    {
        XL_ERR(("GetFontName: Invalid fontname pointer\n"));
        return E_UNEXPECTED;
    }

    //
    // Assumption: paubFontName is an array of 16 bytes.
    //
    CopyMemory(paubFontName, m_aubFontName, PCLXL_FONTNAME_SIZE);

    return S_OK;

}

FontType
XLFont::
GetFontType(VOID)
/*++

Routine Description:

    Returns current font's type.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontType\n"));
    return m_XLFontType;
}

DWORD
XLFont::
GetFontHeight(VOID)
/*++

Routine Description:

    Returns current font's height.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontHeight\n"));
    return m_dwFontHeight;
}

DWORD
XLFont::
GetFontWidth(VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontWidth\n"));
    return m_dwFontWidth;
}

DWORD
XLFont::
GetFontSymbolSet(VOID)
/*++

Routine Description:

    Return font symbol set.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontSymbolSet\n"));
    return m_dwFontSymbolSet;
}

DWORD
XLFont::
GetFontSimulation(VOID)
/*++

Routine Description:

    Return current font simulation.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontSimulation\n"));
    return m_dwFontSimulation;
}

//
// XLTxMode
//
XLTxMode::
XLTxMode()
   :m_SourceTxMode(eNotSet),
    m_PaintTxMode(eNotSet)
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLTxMode::CTor\n"));
}

XLTxMode::
~XLTxMode()
{
    XL_VERBOSE(("XLTxMode::DTor\n"));
}

HRESULT
XLTxMode::
SetSourceTxMode(
    TxMode SrcTxMode)
{
    XL_VERBOSE(("XLTxMode::SetSourceTxMode\n"));
    m_SourceTxMode = SrcTxMode;
    return S_OK;
}

HRESULT
XLTxMode::
SetPaintTxMode(
    TxMode PaintTxMode)
{
    XL_VERBOSE(("XLTxMode::SetPaintTxMode\n"));
    m_PaintTxMode = PaintTxMode;
    return S_OK;
}

TxMode
XLTxMode::
GetSourceTxMode()
{
    XL_VERBOSE(("XLTxMode::GetSourceTxMode\n"));
    return m_SourceTxMode;
}

TxMode
XLTxMode::
GetPaintTxMode()
{
    XL_VERBOSE(("XLTxMode::GetPaintTxMode\n"));
    return m_PaintTxMode;
}

#if DBG
VOID
XLTxMode::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

//
// XLGState
//

VOID
XLGState::
ResetGState(
VOID)
/*++

Routine Description:

Reset Graphics State.

Arguments:

Return Value:

Note:

ROP3 is set to SRCPY(0xCC)

--*/
{
    XLLine *pXLine = this;
    pXLine->ResetLine();

    XLBrush *pXBrush = this;
    pXBrush->ResetBrush();

    XLPen *pXPen = this;
    pXPen->ResetBrush();

    XLClip *pXClip = this;
    pXClip->ClearClip();

    //
    // Set CC (SrcCopy)
    //
    XLRop *pXRop = this;
    pXRop->SetROP3(0xCC);

    XLFont *pXFont = this;
    pXFont->ResetFont();

    XLTxMode *pXLTxMode = this;
    pXLTxMode->SetSourceTxMode(eNotSet);
    pXLTxMode->SetPaintTxMode(eNotSet);

}

#if DBG
VOID
XLGState::
SetAllDbgLevel(
DWORD dwLevel)
/*++

Routine Description:

Set debug level in all classes.

Arguments:

Return Value:

Note:

--*/
{
    XLLine *pXLine = this;
    pXLine->SetDbgLevel(dwLevel);

    XLBrush *pXBrush = this;
    pXBrush->SetDbgLevel(dwLevel);

    XLPen *pXPen = this;
    pXPen->SetDbgLevel(dwLevel);

    XLClip *pXClip = this;
    pXClip->SetDbgLevel(dwLevel);

    XLRop *pXRop = this;
    pXRop->SetDbgLevel(dwLevel);

    XLFont *pXFont = this;
    pXFont->SetDbgLevel(dwLevel);

    XLTxMode *pTxMode = this;
    pTxMode->SetDbgLevel(dwLevel);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxl.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pclxl.cpp

Abstract:

    PCL-XL command output high level function implementation

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created initial framework.

--*/

#include "xlpdev.h"
#include "pclxlcmd.h"
#include "pclxle.h"
#include "xldebug.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xlbmpcvt.h"

//
// Hatch brush raster pattern
//
const BYTE   gubSizeOfHatchBrush = 32 * 32 / 8;
const USHORT gusWidthOfHatchBrush = 32;
const USHORT gusHeightOfHatchBrush = 32;
const BYTE gubHatchBrush[6][gubSizeOfHatchBrush] = 
{ {0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0xff, 0xff, 0xff, 0xff},
  {0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01},
  {0x80, 0x00, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00,
   0x20, 0x00, 0x00, 0x00,
   0x10, 0x00, 0x00, 0x00,
   0x08, 0x00, 0x00, 0x00,
   0x04, 0x00, 0x00, 0x00,
   0x02, 0x00, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00,
   0x00, 0x20, 0x00, 0x00,
   0x00, 0x10, 0x00, 0x00,
   0x00, 0x08, 0x00, 0x00,
   0x00, 0x04, 0x00, 0x00,
   0x00, 0x02, 0x00, 0x00,
   0x00, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x00,
   0x00, 0x00, 0x40, 0x00,
   0x00, 0x00, 0x20, 0x00,
   0x00, 0x00, 0x10, 0x00,
   0x00, 0x00, 0x08, 0x00,
   0x00, 0x00, 0x04, 0x00,
   0x00, 0x00, 0x02, 0x00,
   0x00, 0x00, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x80,
   0x00, 0x00, 0x00, 0x40,
   0x00, 0x00, 0x00, 0x20,
   0x00, 0x00, 0x00, 0x10,
   0x00, 0x00, 0x00, 0x08,
   0x00, 0x00, 0x00, 0x04,
   0x00, 0x00, 0x00, 0x02,
   0x00, 0x00, 0x00, 0x01},
  {
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x02,
   0x00, 0x00, 0x00, 0x04,
   0x00, 0x00, 0x00, 0x08,
   0x00, 0x00, 0x00, 0x10,
   0x00, 0x00, 0x00, 0x20,
   0x00, 0x00, 0x00, 0x40,
   0x00, 0x00, 0x00, 0x80,
   0x00, 0x00, 0x01, 0x00,
   0x00, 0x00, 0x02, 0x00,
   0x00, 0x00, 0x04, 0x00,
   0x00, 0x00, 0x08, 0x00,
   0x00, 0x00, 0x10, 0x00,
   0x00, 0x00, 0x20, 0x00,
   0x00, 0x00, 0x40, 0x00,
   0x00, 0x00, 0x80, 0x00,
   0x00, 0x01, 0x00, 0x00,
   0x00, 0x02, 0x00, 0x00,
   0x00, 0x04, 0x00, 0x00,
   0x00, 0x08, 0x00, 0x00,
   0x00, 0x10, 0x00, 0x00,
   0x00, 0x20, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00,
   0x02, 0x00, 0x00, 0x00,
   0x04, 0x00, 0x00, 0x00,
   0x08, 0x00, 0x00, 0x00,
   0x10, 0x00, 0x00, 0x00,
   0x20, 0x00, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00,
   0x80, 0x00, 0x00, 0x00},
  {0xff, 0xff, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01},
  {0x80, 0x00, 0x00, 0x01,
   0x40, 0x00, 0x00, 0x02,
   0x20, 0x00, 0x00, 0x04,
   0x10, 0x00, 0x00, 0x08,
   0x08, 0x00, 0x00, 0x10,
   0x04, 0x00, 0x00, 0x20,
   0x02, 0x00, 0x00, 0x40,
   0x01, 0x00, 0x00, 0x80,
   0x00, 0x80, 0x01, 0x00,
   0x00, 0x40, 0x02, 0x00,
   0x00, 0x20, 0x04, 0x00,
   0x00, 0x10, 0x08, 0x00,
   0x00, 0x08, 0x10, 0x00,
   0x00, 0x04, 0x20, 0x00,
   0x00, 0x02, 0x40, 0x00,
   0x00, 0x01, 0x80, 0x00,
   0x00, 0x01, 0x80, 0x00,
   0x00, 0x02, 0x40, 0x00,
   0x00, 0x04, 0x20, 0x00,
   0x00, 0x08, 0x10, 0x00,
   0x00, 0x10, 0x08, 0x00,
   0x00, 0x20, 0x04, 0x00,
   0x00, 0x40, 0x02, 0x00,
   0x00, 0x80, 0x01, 0x00,
   0x01, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x40,
   0x04, 0x00, 0x00, 0x20,
   0x08, 0x00, 0x00, 0x10,
   0x10, 0x00, 0x00, 0x08,
   0x20, 0x00, 0x00, 0x04,
   0x40, 0x00, 0x00, 0x02,
   0x80, 0x00, 0x00, 0x01}
};

//
// High level output functions
//
HRESULT
XLOutput::
BeginImage(
    ColorMapping CMapping,
    ULONG   ulOutputBPP,
    ULONG   ulSrcWidth,
    ULONG   ulSrcHeight,
    ULONG   ulDestWidth,
    ULONG   ulDestHeight)
/*++

Routine Description:

     Sends BeginImage operator.

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwI = 0;

    XL_VERBOSE(("XLOutput::BeginImage:SrcW=%d, SrcH=%d, DstH=%d, DstW=%d\n",
              ulSrcWidth, ulSrcHeight, ulDestHeight, ulDestWidth));


    SetOutputBPP(CMapping, ulOutputBPP);
    SetSourceWidth((uint16)ulSrcWidth);
    SetSourceHeight((uint16)ulSrcHeight);
    SetDestinationSize((uint16)ulDestWidth, (uint16)ulDestHeight);
    Send_cmd(eBeginImage);

    return S_OK;
}
  
HRESULT
XLOutput::
SetOutputBPP(
    ColorMapping CMapping,
    ULONG   ulOutputBPP)
/*++

Routine Description:

    Sends Color mapping and output depth.

Arguments:

Return Value:

Note:

--*/
{
    switch (CMapping)
    {
    case eDirectPixel:
        SetColorMapping(eDirectPixel);
        break;
    case eIndexedPixel:
        SetColorMapping(eIndexedPixel);
        break;
    default:
        SetColorMapping(eDirectPixel);
    }

    switch (ulOutputBPP)
    {
    case 1:
        SetColorDepth(e1Bit);
        break;
    case 4:
        SetColorDepth(e4Bit);
        break;
    case 8:
        SetColorDepth(e8Bit);
        break;
    case 24:
        XL_ERR(("ulOutputBPP = 24 is not supported\n"));
        //
        // Send color depth anyway to avoid XL error.
        //
        SetColorDepth(e8Bit);
        break;
    default:
        XL_ERR(("ulOutputBPP = %d is not supported\n", ulOutputBPP));
        //
        // Send color depth anyway to avoid XL error.
        //
        SetColorDepth(e8Bit);
    }

    return S_OK;
}

HRESULT
XLOutput::
SetPalette(
    ULONG ulOutputBPP,
    ColorDepth CDepth,
    DWORD dwCEntries,
    DWORD *pdwColor)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    HRESULT hResult;

    if (dwCEntries != 0 && pdwColor != NULL)
    {
        SetPaletteDepth(CDepth);
        SetPaletteData(CDepth, dwCEntries, pdwColor);
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLOutput::SetPalette pxlo = NULL\n"));
        hResult = S_FALSE;
    }

    return hResult;
}

HRESULT
XLOutput::
SetClip(
    CLIPOBJ *pco)
/*++

Routine Description:

    Sends clip object.

Arguments:

Return Value:

Note:

--*/
{
    PATHOBJ *ppo;
    XLGState *pGState = this;
    HRESULT hResult;

    if (S_OK == pGState->CheckClip(pco))
        return S_OK;

    if ( NULL == pco )
    {
        XL_VERBOSE(("XLOutput::SetClip pco = NULL.\n"));
        Send_cmd(eSetClipToPage);
        pGState->ClearClip();
        return S_OK;
    }

    XL_VERBOSE(("XLOutput::SetClip: pco->iDComplexity=%d\n", pco->iDComplexity));

    switch(pco->iDComplexity)
    {
    case DC_RECT:
        SetClipMode(eClipEvenOdd);

        Send_cmd(eNewPath);
        RectanglePath(&(pco->rclBounds));

        SetClipRegion(eInterior);
        Send_cmd(eSetClipReplace);
        pGState->SetClip(pco);
        hResult = S_OK;
        break;

    case DC_COMPLEX:
        ppo = CLIPOBJ_ppoGetPath(pco);

        if (NULL == ppo)
        {
            XL_ERR(("XLOutput::SetClip ppo = NULL.\n"));
            Send_cmd(eSetClipToPage);
            pGState->ClearClip();
            hResult = S_FALSE;
            break;
        }

        SetClipMode(eClipEvenOdd);
        Path(ppo);
        SetClipRegion(eInterior);
        Send_cmd(eSetClipReplace);
        pGState->SetClip(pco);
        hResult = S_OK;
        break;

    case DC_TRIVIAL:
    default:
        Send_cmd(eSetClipToPage);
        pGState->ClearClip();
        hResult = S_OK;
        break;
    }

    return hResult;
}

HRESULT
XLOutput::
RoundRectanglePath(
    RECTL  *prclBounds)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    RECTL Rectl;

    if ( NULL == prclBounds )
    {
        XL_ERR(("XLOutput::RoundRectangle prclBounds = NULL.\n"));
        return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::RoundRectanglePath:left=%d, top=%d, right=%d, bottom=%d\n",
             prclBounds->left,
             prclBounds->top,
             prclBounds->right,
             prclBounds->bottom));

    //
    // BoundingBox can handle only positive numbers.
    //
    Rectl = *prclBounds;

    if (Rectl.left < 0)
    {
        Rectl.left = 0;
    }
    if (Rectl.top < 0)
    {
        Rectl.top = 0;
    }
    if (Rectl.right < 0)
    {
        Rectl.right = 0;
    }
    if (Rectl.bottom < 0)
    {
        Rectl.bottom = 0;
    }


    //
    // DCR: Round value needs to be sent!
    //
    if (S_OK == SetBoundingBox((uint16)Rectl.left,
                               (uint16)Rectl.top,
                               (uint16)Rectl.right,
                               (uint16)Rectl.bottom) &&
        S_OK == Send_uint16_xy(0, 0) &&
        S_OK == Send_attr_ubyte(eEllipseDimension) &&
        S_OK == Send_cmd(eRoundRectanglePath))
        return S_OK;
    else
        return S_FALSE;

}

HRESULT
XLOutput::
SetCursor(
    ULONG   ulX,
    ULONG   ulY)
/*++

Routine Description:

    Set cursor.

Arguments:

Return Value:

Note:

--*/
{

    XL_VERBOSE(("XLOutput::SetCursor:X=%d, Y=%d\n", ulX, ulY));

    Send_sint16_xy((sint16)ulX, (sint16)ulY);
    Send_attr_ubyte(ePoint);
    Send_cmd(eSetCursor);

    m_ulX = ulX;
    m_ulY = ulY;

    return S_OK;
}

HRESULT
XLOutput::
GetCursorPos(
    PULONG pulX,
    PULONG pulY)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{

    XL_VERBOSE(("XLOutput::GetCursor:X=%d, Y=%d\n", *pulX, *pulY));

    if (pulX == NULL || pulY == NULL)
        return E_UNEXPECTED;

    *pulX = m_ulX;
    *pulY = m_ulY;

    return S_OK;
}

HRESULT
XLOutput::
ReadImage(
    DWORD  dwBlockHeight,
    CompressMode CMode)
/*++

Routine Description:

    Sends ReadImage operator

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::ReadImage:dwBlockHeight=%d\n", dwBlockHeight));

    Send_uint16((uint16)0);
    Send_attr_ubyte(eStartLine);

    Send_uint16((uint16)dwBlockHeight);
    Send_attr_ubyte(eBlockHeight);

    //
    // DCR: Need to support JPEG
    //
    SetCompressMode(CMode);
    Send_cmd(eReadImage);

    return S_OK;
}

HRESULT
XLOutput::
ReadRasterPattern(
    DWORD  dwBlockHeight,
    CompressMode CMode)
/*++

Routine Description:

    Sends ReadRasterPattern operator.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::ReadRasterPattern:dwBlockHeight=%d\n", dwBlockHeight));

    Send_uint16((uint16)0);
    Send_attr_ubyte(eStartLine);
    Send_uint16((uint16)dwBlockHeight);
    Send_attr_ubyte(eBlockHeight);

    //
    // DCR: Need to support JPEG
    //
    SetCompressMode(CMode);
    Send_cmd(eReadRastPattern);

    return S_OK;
}


HRESULT
XLOutput::
SetGrayLevel(
    ubyte ubyte_gray)
/*++

Routine Description:

    Sends SetGrayLevel attribute.

Arguments:

Return Value:

Note:

--*/
{
    Send_ubyte(ubyte_gray);
    Send_attr_ubyte(eGrayLevel);

    return S_OK;
}

HRESULT
XLOutput::
RectanglePath(
    RECTL  *prclRect)
/*++

Routine Description:

    Sends Rectangle Path

Arguments:

Return Value:

Note:

--*/
{
    RECTL Rectl;

    if (NULL == prclRect)
    {
        XL_ERR(("XLOutput::RectanglePath: prclRect == NULL\n"));
        return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::RectanglePath:left=%d, top=%d, right=%d, bottom=%d\n",
             prclRect->left,
             prclRect->top,
             prclRect->right,
             prclRect->bottom));

    Rectl = *prclRect;

    if (prclRect->left < 0)
    {
        Rectl.left = 0;
    }
    if (prclRect->top < 0)
    {
        Rectl.top = 0;
    }
    if (prclRect->right < 0)
    {
        Rectl.right = 0;
    }
    if (prclRect->bottom < 0)
    {
        Rectl.bottom = 0;
    }


    if (S_OK == SetBoundingBox((uint16)Rectl.left,
                               (uint16)Rectl.top,
                               (uint16)Rectl.right,
                               (uint16)Rectl.bottom) &&
        S_OK == Send_cmd(eRectanglePath) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
Path(
    PATHOBJ *ppo)
/*++

Routine Description:

    Sends path.

Arguments:

Return Value:

Note:

--*/
{
    POINTFIX* pptfx;
    PATHDATA  PathData;
    LONG      lPoints;
    HRESULT   hResult;
    BOOL      bMore;

    XL_VERBOSE(("XLOutput::Path\n"));

    if (ppo == NULL)
    {
        XL_ERR(("XLOutput::Path ppo = NULL.\n"));
        return E_UNEXPECTED;
    }


    //
    // Emit newpath operator
    // Don't do it if we're between path escapes
    //
    hResult = Send_cmd(eNewPath);

    //
    // Path object case
    //

    PATHOBJ_vEnumStart(ppo);

    do
    {
        bMore   = PATHOBJ_bEnum(ppo, &PathData);

        pptfx   = PathData.pptfx;
        if ( 0 == (lPoints = PathData.count))
        {
            XL_VERBOSE(("XLOutput::Path PathData.Count == 0\n"));
            hResult = S_FALSE;
            continue;
        }

        //
        // Begin new sub path
        //

        if (PathData.flags & PD_BEGINSUBPATH)
        {
            //
            // start new path
            //

            if (hResult == S_OK)
                hResult = SetCursor(FXTOL(pptfx->x), FXTOL(pptfx->y));;
            pptfx++;
            lPoints--;
        }


        if (lPoints > 0)
        {
            if (PathData.flags & PD_BEZIERS)
            {
                //
                // Output a Bezier curve segment
                //

                ASSERTMSG((lPoints % 3) == 0,
                          ("Incorrect number of points for a Bezier curve: %d\n", lPoints));

                if (hResult == S_OK)
                    hResult = BezierPath(pptfx, lPoints);
            }
            else
            {
                //
                // Draw straight line segment
                //

                if (hResult == S_OK)
                    hResult = LinePath(pptfx, lPoints);
            }
        }

        //
        // Close subpath
        //

        if (PathData.flags & PD_CLOSEFIGURE)
        {
            if (hResult == S_OK)
                hResult = Send_cmd(eCloseSubPath);
        }

    }
    while (bMore);

    return hResult;
}


HRESULT
XLOutput::
BezierPath(
    POINTFIX* pptfx,
    LONG      lPoints)
/*++

Routine Description:

    Sends bezier path

Arguments:

Return Value:

Note:

--*/
{
    LONG lValue, lI;
    DWORD dwDataLength;

    if (NULL == pptfx)
    {
         XL_ERR(("XLOutput::BezierPath: pptfx == NULL\n"));
         return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::BezierPath(lPoints=%d)\n",lPoints));

    Send_uint16((uint16)lPoints);
    Send_attr_ubyte(eNumberOfPoints);
    Send_ubyte(eUint16);
    Send_attr_ubyte(ePointType);
    Send_cmd(eBezierPath);

    dwDataLength = lPoints * 2 * sizeof(uint16);

    if (dwDataLength > 0xff)
    {
        WriteByte(PCLXL_dataLength);
        Write((PBYTE)&dwDataLength, sizeof(DWORD));
    }
    else
    {
        WriteByte(PCLXL_dataLengthByte);
        WriteByte((ubyte)dwDataLength);
    }

    for (lI = 0; lI < lPoints; lI++)
    {
        lValue = FXTOL(pptfx->x);
        Write((PBYTE)&lValue, sizeof(uint16));
        lValue = FXTOL(pptfx->y);
        Write((PBYTE)&lValue, sizeof(uint16));
        pptfx++;
    }

    //
    // Update the last coordinate.
    // Make sure that there are some points.
    if (lPoints > 0)
    {
        pptfx--;
        m_ulX = FXTOL(pptfx->x);
        m_ulY = FXTOL(pptfx->y);
    }
    else
    {
        m_ulX = 0;
        m_ulY = 0;
    }


    return S_OK;
}
    
HRESULT
XLOutput::
LinePath(
    POINTFIX* pptfx,
    LONG      lPoints)
/*++

Routine Description:

   Sends line path.

Arguments:

Return Value:

Note:

--*/
{
    LONG lValueX, lValueY, lI, lJ;
    ULONG ulx, uly;
    DWORD dwDataLength;

    if (NULL == pptfx)
    {
         XL_ERR(("XLOutput::LinePath: pptfx == NULL\n"));
         return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::LinePath(lPoints=%d)\n", lPoints));

    //
    // Optimization. Use byte relpath to minimize the output size
    // First, check if the difference from the previous position is in a byte.
    //
    BOOL bModeChange;
    enum { eMode_SByte, eMode_SInt, eMode_None} Mode;
    LONG lStart, lEnd, lNumOfSByte;
    ULONG ulStartX, ulStartY;
    POINTFIX *pptfx_tmp = pptfx;

    //
    // Get current cursor position
    //
    ulStartX = ulx = m_ulX;
    ulStartY = uly = m_ulY;

    //
    // Reset
    //
    lStart = 0;
    Mode = eMode_None;
    bModeChange = FALSE;
    lNumOfSByte = 0;

    for (lI = 0; lI < lPoints; )
    {
        XL_VERBOSE(("XLOutput::LinePath: (%d)=(%d,%d)\n",lI, ulx, uly));
        lValueX = FXTOL(pptfx_tmp->x) - ulx;
        lValueY = FXTOL(pptfx_tmp->y) - uly;

        //
        // Mode needs to be in SByte or SInt?
        //
        if ( -128 <= lValueX && lValueX <= 127
        &&   -128 <= lValueY && lValueY <= 127 )
        {
            if (Mode == eMode_SInt)
            {
                //
                // Optimization
                //
                // To switch mode between SInt and SByte, it needs 7 bytes.
                //
                // uint16 XX NumberOfPoints
                // ubyte eSByte PointType
                // LineRelPath
                //
                // 4 points with SInt consumes 2 x 4 = 8 bytes extra data.
                // 3 points with SInt consumes 2 x 3 = 6 bytes extra data.
                //
                // 4 points is the threshold to swith mode to SInt.
                //
                // Number of points: lEnd - lStart + 1
                // if (lI - 1 - lStartSByte + 1 >= 4)
                //
                // If SByte continues more than 4 points, switch mode from
                // SByte to SInt.
                //
                if (lNumOfSByte >= 4)
                {
                    bModeChange = TRUE;
                    lI -= lNumOfSByte;
                    pptfx_tmp -= lNumOfSByte;
                    lEnd = (lI - 1);
                    lNumOfSByte = 0;
                }
            
                //
                // Reset starting point of SByte
                //
                lNumOfSByte ++;
            }
            else
            {
                Mode = eMode_SByte;
            }

            XL_VERBOSE(("XLOutput::LinePath: (SByte) lx1=%d, lx2=%d\n", ulx, FXTOL(pptfx_tmp->x)));
        }
        else
        {
            if (Mode == eMode_SByte)
            {
                bModeChange = TRUE;
                lEnd = lI - 1;
            }
            else
            {
                Mode = eMode_SInt;
                lNumOfSByte = 0;
            }
            XL_VERBOSE(("XLOutput::LinePath: (SInt) lx1=%d, lx2=%d\n", ulx, FXTOL(pptfx_tmp->x)));
        }

        if (!bModeChange && lI + 1 == lPoints)
        {
            bModeChange = TRUE;
            lEnd = lI;
            lI ++;
        }

        if (bModeChange)
        {
            XL_VERBOSE(("XLOutput::LinePath: Draw\n"));

            //
            // Get start cursor position
            //
            ulx = ulStartX;
            uly = ulStartY;

            if (Mode == eMode_SByte)
            {
                //
                // SByte
                //
                Send_uint16((uint16)(lEnd - lStart + 1));
                Send_attr_ubyte(eNumberOfPoints);
                Send_ubyte(eSByte);
                Send_attr_ubyte(ePointType);
                Send_cmd(eLineRelPath);

                dwDataLength = (lEnd - lStart + 1) * 2 * sizeof(ubyte);

                if (dwDataLength <= 0xFF)
                {
                    WriteByte(PCLXL_dataLengthByte);
                    WriteByte((ubyte)dwDataLength);
                }
                else
                {
                    WriteByte(PCLXL_dataLength);
                    Write((PBYTE)&dwDataLength, sizeof(DWORD));
                }

                for (lJ = 0; lJ <= (lEnd - lStart); lJ++)
                {
                    lValueX = FXTOL(pptfx->x) - ulx;
                    lValueY = FXTOL(pptfx->y) - uly;
                    Write((PBYTE)&lValueX, sizeof(ubyte));
                    Write((PBYTE)&lValueY, sizeof(ubyte));
                    ulx = FXTOL(pptfx->x);
                    uly = FXTOL(pptfx->y);
                    pptfx++;
                }

                Mode = eMode_SInt;
            }
            else if (Mode == eMode_SInt)
            {
                //
                // SInt16
                //
                Send_uint16((uint16)(lEnd - lStart + 1));
                Send_attr_ubyte(eNumberOfPoints);
                Send_ubyte(eSint16);
                Send_attr_ubyte(ePointType);
                Send_cmd(eLineRelPath);
                dwDataLength = (lEnd - lStart + 1) * 2 * sizeof(uint16);

                if (dwDataLength <= 0xFF)
                {
                    WriteByte(PCLXL_dataLengthByte);
                    WriteByte((ubyte)dwDataLength);
                }
                else
                {
                    WriteByte(PCLXL_dataLength);
                    Write((PBYTE)&dwDataLength, sizeof(DWORD));
                }

                for (lJ = 0; lJ <= (lEnd - lStart); lJ++)
                {
                    lValueX = FXTOL(pptfx->x) - (LONG)ulx;
                    lValueY = FXTOL(pptfx->y) - (LONG)uly;
                    Write((PBYTE)&lValueX, sizeof(sint16));
                    Write((PBYTE)&lValueY, sizeof(sint16));
                    ulx = FXTOL(pptfx->x);
                    uly = FXTOL(pptfx->y);
                    pptfx++;
                }

                Mode = eMode_SByte;
            }

            bModeChange = FALSE;

            ulStartX = ulx = FXTOL((pptfx_tmp-1)->x);
            ulStartY = uly = FXTOL((pptfx_tmp-1)->y);
            lStart = lI;
        }
        else
        {
            ulx = FXTOL((pptfx_tmp)->x);
            uly = FXTOL((pptfx_tmp)->y);
            pptfx_tmp ++;
            lI ++;
        }
    }

    //
    // Update cursor position
    //
    m_ulX = FXTOL((pptfx_tmp)->x);
    m_ulY = FXTOL((pptfx_tmp)->y);

    return S_OK;
}

inline
VOID
XLOutput::
SetupBrush(
    BRUSHOBJ *pbo,
    POINTL *pptlBrushOrg,
    CMNBRUSH *pcmnbrush)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwHatchID;
    XLBRUSH *pBrush;

    if (NULL == pcmnbrush)
    {
        //
        // Make sure that pcmnbrush is valid.
        //
        XL_ERR(("SetupBrush:pcmnbrush is invalid.\n"));
        return;
    }

    //
    // Initialize CMNBRUSH
    //
    pcmnbrush->dwSig            = BRUSH_SIGNATURE;
    pcmnbrush->BrushType        = kNoBrush;
    pcmnbrush->ulHatch          = 0XFFFFFFFF;
    pcmnbrush->dwColor          = 0x00FFFFFF;
    pcmnbrush->dwCEntries       = 0;
    pcmnbrush->dwPatternBrushID = 0xFFFFFFFF;

    XL_VERBOSE(("XLOutput::SetupBrush\n"));

    if (NULL == pbo)
    {
        XL_VERBOSE(("XLOutput::SetupBrush: pbo == NULL, set NULL brush\n"));
    }
    else
    {

        #ifndef WINNT_40
        if ( !(pbo->flColorType & BR_CMYKCOLOR)     &&
              (pbo->iSolidColor == NOT_SOLID_COLOR)  )
        #else
        if (pbo->iSolidColor == NOT_SOLID_COLOR)
        #endif
        {
            pBrush = (XLBRUSH*)BRUSHOBJ_pvGetRbrush(pbo);
            if (NULL == pBrush)
            {
                XL_ERR(("SetupBrush:BRUSHOBJ_pvGetRbrush failed.\n"));
                dwHatchID = HS_DDI_MAX;
            }
            else
            {
                dwHatchID = pBrush->dwHatch;
            }
        }
        else
        {
            dwHatchID = HS_DDI_MAX;
            pBrush = NULL;
        }

        pcmnbrush->ulHatch          = dwHatchID;
        pcmnbrush->ulSolidColor     = pbo->iSolidColor;

        switch (dwHatchID)
        {
        case HS_HORIZONTAL:
        case HS_VERTICAL:
        case HS_BDIAGONAL:
        case HS_FDIAGONAL:
        case HS_CROSS:
        case HS_DIAGCROSS:
            XL_VERBOSE(("XLOutput::SetupBrush(uiSolidColor=%d,dwHatchID=%d)\n",
                        pbo->iSolidColor,
                        dwHatchID));

            pcmnbrush->BrushType = kBrushTypeHatch;
            pcmnbrush->dwPatternBrushID = dwHatchID;

            if (pBrush)
            {
                pcmnbrush->dwColor = pBrush->dwColor;
            }
            SetColorSpace(eGray);
            SetPaletteDepth(e8Bit);
            if (pBrush->dwCEntries)
            {
                SetPaletteData(e8Bit, pBrush->dwCEntries, pBrush->adwColor);
            }
            else
            {
                DWORD dwColorTableTmp[2] = {0x00ffffff, 0x00ffffff};
                dwColorTableTmp[1] = pBrush->dwColor;
                SetPaletteData(e8Bit, 2, dwColorTableTmp);
            }
            Send_cmd(eSetColorSpace);

            if (!(m_dwHatchBrushAvailability & (HORIZONTAL_AVAILABLE << dwHatchID)))
            {

                SetColorMapping(eIndexedPixel);
                SetColorDepth(e1Bit);
                SetSourceWidth((uint16)gusWidthOfHatchBrush);
                SetSourceHeight((uint16)gusHeightOfHatchBrush);

                //
                // Pattern scaling factor
                // 160 is an experimentally introduced number.
                //
                WORD wScale = (WORD)(160 * m_dwResolution / 1200);

                SetDestinationSize((uint16)wScale, (uint16)wScale);
                SetPatternPersistence(eSessionPattern);
                SetPatternDefineID((sint16)dwHatchID);
                Send_cmd(eBeginRastPattern);

                Send_uint16((uint16)0);
                Send_attr_ubyte(eStartLine);
                Send_uint16((uint16)gusHeightOfHatchBrush);
                Send_attr_ubyte(eBlockHeight);
                SetCompressMode(eNoCompression);
                Send_cmd(eReadRastPattern);

                WriteByte(PCLXL_dataLengthByte);
                WriteByte(gubSizeOfHatchBrush);
                Write((PBYTE)gubHatchBrush[dwHatchID], gubSizeOfHatchBrush);
                Send_cmd(eEndRastPattern);

                m_dwHatchBrushAvailability |= HORIZONTAL_AVAILABLE << dwHatchID;
            }

            //
            //SendPatternSelectID();
            //
            Send_sint16((sint16)dwHatchID);
            Send_attr_ubyte(ePatternSelectID);

            break;
        case HS_DDI_MAX:
         